[
    {
        "title": "Minimum Additions to Make Valid String",
        "question_content": "Given a string word to which you can insert letters \"a\", \"b\" or \"c\" anywhere and any number of times, return the minimum number of letters that must be inserted so that word becomes valid.\nA string is called valid if it can be formed by concatenating the string \"abc\" several times.\n&nbsp;\nExample 1:\n\nInput: word = \"b\"\nOutput: 2\nExplanation: Insert the letter \"a\" right before \"b\", and the letter \"c\" right next to \"a\" to obtain the valid string \"abc\".\n\nExample 2:\n\nInput: word = \"aaa\"\nOutput: 6\nExplanation: Insert letters \"b\" and \"c\" next to each \"a\" to obtain the valid string \"abcabcabc\".\n\nExample 3:\n\nInput: word = \"abc\"\nOutput: 0\nExplanation: word is already valid. No modifications are needed. \n\n&nbsp;\nConstraints:\n\n\t1 <= word.length <= 50\n\tword consists of letters \"a\", \"b\"&nbsp;and \"c\" only.&nbsp;",
        "solutions": [
            {
                "id": 3421831,
                "title": "java-c-python-easy-and-concise-with-explanation",
                "content": "# Why somebody downvoted me without a word?\\n# Please Upvote \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n<br>\\n\\n# **Intuition**\\nSame problem:\\nFind out the minimum `k` where `word` is subsequence of `\"abc\"` repeated `k` times.\\n\\nSince `\"abc\"` is increasing,\\nso we can split the original `work` into `k` strict increasing subarray.\\n<br>\\n\\n# **Explanation**\\nInitial the `prev` as a big char,\\nthen iterate each char `c` in `word`.\\nIf `c <= prev`, it means we need to start a new `\"abc\"`,\\nthen we increase `k++`.\\n\\nFinally we find `k`, `word` is subsequence of `\"abc\"` repeated `k` times.\\nWe return `k * 3 - n`.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int addMinimum(String word) {\\n        int k = 0, prev = \\'z\\', n = word.length();\\n        for (int i = 0; i < n; ++i) {\\n            k += word.charAt(i) <= prev ? 1 : 0;\\n            prev = word.charAt(i);\\n        }\\n        return k * 3 - n;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int addMinimum(string word) {\\n        int k = 0, prev = \\'z\\';\\n        for (char& c: word) {\\n            k += c <= prev;\\n            prev = c;\\n        }\\n        return k * 3 - word.size();\\n    }\\n```\\n\\n**Python**\\n```py\\n    def addMinimum(self, word: str) -> int:\\n        k, prev = 0, \\'z\\'\\n        for c in word:\\n            k += c <= prev\\n            prev = c\\n        return k * 3 - len(word)\\n```\\n\\n**Python 1-Liner**\\n```py\\n    def addMinimum(self, word: str) -> int:\\n        return 3 + sum(a >= b for a,b in pairwise(word)) * 3 - len(word)\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int addMinimum(String word) {\\n        int k = 0, prev = \\'z\\', n = word.length();\\n        for (int i = 0; i < n; ++i) {\\n            k += word.charAt(i) <= prev ? 1 : 0;\\n            prev = word.charAt(i);\\n        }\\n        return k * 3 - n;\\n    }\\n```\n```cpp\\n    int addMinimum(string word) {\\n        int k = 0, prev = \\'z\\';\\n        for (char& c: word) {\\n            k += c <= prev;\\n            prev = c;\\n        }\\n        return k * 3 - word.size();\\n    }\\n```\n```py\\n    def addMinimum(self, word: str) -> int:\\n        k, prev = 0, \\'z\\'\\n        for c in word:\\n            k += c <= prev\\n            prev = c\\n        return k * 3 - len(word)\\n```\n```py\\n    def addMinimum(self, word: str) -> int:\\n        return 3 + sum(a >= b for a,b in pairwise(word)) * 3 - len(word)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3421709,
                "title": "c-java-python-o-n-greedy-solution-easy-to-understand",
                "content": "**C++ Code**\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        \\n        int n = word.size(), i = 0, res = 0;\\n        \\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word[i] == \\'a\\') {\\n                count++;i++;\\n            }\\n             \\n            if(i < n and word[i] == \\'b\\') {\\n                count++;i++;\\n            }\\n            \\n            if(i < n and word[i] == \\'c\\') {\\n                count++;i++;\\n            }\\n            \\n            res += 3 - count;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n**Java Code**\\n```\\npublic class Solution {\\n    public int addMinimum(String word) {\\n        int n = word.length(), i = 0, res = 0;\\n        \\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word.charAt(i) == \\'a\\') {\\n                count++;\\n                i++;\\n            }\\n             \\n            if(i < n && word.charAt(i) == \\'b\\') {\\n                count++;\\n                i++;\\n            }\\n            \\n            if(i < n && word.charAt(i) == \\'c\\') {\\n                count++;\\n                i++;\\n            }\\n            \\n            res += 3 - count;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\n**Python Code**\\n\\n```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        n = len(word)\\n        i = 0\\n        res = 0\\n        \\n        while i < n:\\n            count = 0\\n            \\n            if word[i] == \\'a\\':\\n                count += 1\\n                i += 1\\n             \\n            if i < n and word[i] == \\'b\\':\\n                count += 1\\n                i += 1\\n            \\n            if i < n and word[i] == \\'c\\':\\n                count += 1\\n                i += 1\\n            \\n            res += 3 - count\\n        \\n        return res\\n```\\n\\n**Thanks. Please do upvote**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        \\n        int n = word.size(), i = 0, res = 0;\\n        \\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word[i] == \\'a\\') {\\n                count++;i++;\\n            }\\n             \\n            if(i < n and word[i] == \\'b\\') {\\n                count++;i++;\\n            }\\n            \\n            if(i < n and word[i] == \\'c\\') {\\n                count++;i++;\\n            }\\n            \\n            res += 3 - count;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n```\\npublic class Solution {\\n    public int addMinimum(String word) {\\n        int n = word.length(), i = 0, res = 0;\\n        \\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word.charAt(i) == \\'a\\') {\\n                count++;\\n                i++;\\n            }\\n             \\n            if(i < n && word.charAt(i) == \\'b\\') {\\n                count++;\\n                i++;\\n            }\\n            \\n            if(i < n && word.charAt(i) == \\'c\\') {\\n                count++;\\n                i++;\\n            }\\n            \\n            res += 3 - count;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        n = len(word)\\n        i = 0\\n        res = 0\\n        \\n        while i < n:\\n            count = 0\\n            \\n            if word[i] == \\'a\\':\\n                count += 1\\n                i += 1\\n             \\n            if i < n and word[i] == \\'b\\':\\n                count += 1\\n                i += 1\\n            \\n            if i < n and word[i] == \\'c\\':\\n                count += 1\\n                i += 1\\n            \\n            res += 3 - count\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421894,
                "title": "short-intuitive-code-no-long-conditions-time-o-n",
                "content": "# Intuition\\nTake maximum number of characters present in increasing order (`a < b < c`)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string& s) {\\n        int n = s.size(), i = 0, result = 0;\\n        while (i < n) {\\n            string s2 = s.substr(i, 2);\\n            if (s.substr(i, 3) == \"abc\") {\\n                i += 3;\\n            } else if (s2 == \"ab\" || s2 == \"ac\" || s2 == \"bc\") {\\n                i += 2;\\n                result += 1;\\n            } else {\\n                i += 1;\\n                result += 2;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $O(1)$",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string& s) {\\n        int n = s.size(), i = 0, result = 0;\\n        while (i < n) {\\n            string s2 = s.substr(i, 2);\\n            if (s.substr(i, 3) == \"abc\") {\\n                i += 3;\\n            } else if (s2 == \"ab\" || s2 == \"ac\" || s2 == \"bc\") {\\n                i += 2;\\n                result += 1;\\n            } else {\\n                i += 1;\\n                result += 2;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421701,
                "title": "clean-solution-easy-to-understand",
                "content": "T.C: O(n)\\nS.C: O(1)\\n**Python3 code**\\n```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        it = 0\\n        result = 0\\n        while it < len(word) :\\n            if word[it:it+3] == \"abc\":\\n                it += 3  \\n            elif word[it:it+2] in [\"ab\",\"ac\",\"bc\"]:\\n                result += 1\\n                it += 2\\n            else:\\n                result += 2\\n                it += 1\\n        return result\\n                    \\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "T.C: O(n)\\nS.C: O(1)\\n**Python3 code**\\n```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        it = 0\\n        result = 0\\n        while it < len(word) :\\n            if word[it:it+3] == \"abc\":\\n                it += 3  \\n            elif word[it:it+2] in [\"ab\",\"ac\",\"bc\"]:\\n                result += 1\\n                it += 2\\n            else:\\n                result += 2\\n                it += 1\\n        return result\\n                    \\n",
                "codeTag": "Java"
            },
            {
                "id": 3422183,
                "title": "concise-easy-to-understand-c-intutive-approach",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI have used a variable current which will represent the current character we need to form the sequence \"abc\".\\nThere are two possible cases :\\n1. We will get the required current character at a[i] -> In this one, we will increment the index i.\\n2. If the current character required is not a[i] -> In this case, we will increment our ans (imagining that we have added that current character hypothetically) \\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string a) {\\n        int n = a.size();\\n        int current = 0,i=0,ans=0;\\n        // For current=  0 ->\\'a\\', 1 -> \\'b\\', 2-> \\'c\\' \\n        while(i<n || current!=0)\\n        {\\n            if(i<n && a[i]-\\'a\\' == cur)\\n            {\\n                current++;\\n                i++;\\n            }\\n            else\\n            {\\n                current++;\\n                ans++;\\n            }\\n            current%=3;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nPlease Upvote!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string a) {\\n        int n = a.size();\\n        int current = 0,i=0,ans=0;\\n        // For current=  0 ->\\'a\\', 1 -> \\'b\\', 2-> \\'c\\' \\n        while(i<n || current!=0)\\n        {\\n            if(i<n && a[i]-\\'a\\' == cur)\\n            {\\n                current++;\\n                i++;\\n            }\\n            else\\n            {\\n                current++;\\n                ans++;\\n            }\\n            current%=3;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421989,
                "title": "circular-matching-constant-space",
                "content": "We will do Circular Matching with **abc**, using which we will get to know the absent characters.\\n# Explanation:\\n+ We will iterate and match with `curr` :\\n    + If matched, we will move forward\\n    + else, we will keep moving the `curr` only until it matches with current character.\\n> Number of times `curr` mismatched is our answer\\n   \\n\\n# C++    \\n\\tint addMinimum(string A, char curr = \\'a\\', int res = 0) {\\n        for(int i = 0;i < A.size();){\\n            if(A[i] == curr) ++i;\\n            else ++res;\\n\\t\\t\\tcurr = \\'a\\' + ((curr - \\'a\\') + 1) % 3;\\n\\t\\t}\\n        return res + (curr == \\'a\\' ? 0 : \\'c\\' - curr + 1);\\n    }\\n# Java\\n    public int addMinimum(String A) {\\n        char curr = \\'a\\';\\n        int res = 0;\\n        for(int i = 0;i < A.length();){\\n            if(A.charAt(i) == curr) ++i;\\n            else ++res;\\n\\t\\t\\tcurr = (char)(\\'a\\' + ((curr - \\'a\\') + 1) % 3);\\n\\t\\t}\\n        return res + (curr == \\'a\\' ? 0 : \\'c\\' - curr + 1);\\n    }",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "We will do Circular Matching with **abc**, using which we will get to know the absent characters.\\n# Explanation:\\n+ We will iterate and match with `curr` :\\n    + If matched, we will move forward\\n    + else, we will keep moving the `curr` only until it matches with current character.\\n> Number of times `curr` mismatched is our answer\\n   \\n\\n# C++    \\n\\tint addMinimum(string A, char curr = \\'a\\', int res = 0) {\\n        for(int i = 0;i < A.size();){\\n            if(A[i] == curr) ++i;\\n            else ++res;\\n\\t\\t\\tcurr = \\'a\\' + ((curr - \\'a\\') + 1) % 3;\\n\\t\\t}\\n        return res + (curr == \\'a\\' ? 0 : \\'c\\' - curr + 1);\\n    }\\n# Java\\n    public int addMinimum(String A) {\\n        char curr = \\'a\\';\\n        int res = 0;\\n        for(int i = 0;i < A.length();){\\n            if(A.charAt(i) == curr) ++i;\\n            else ++res;\\n\\t\\t\\tcurr = (char)(\\'a\\' + ((curr - \\'a\\') + 1) % 3);\\n\\t\\t}\\n        return res + (curr == \\'a\\' ? 0 : \\'c\\' - curr + 1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3421967,
                "title": "linear-scan",
                "content": "# Intuition\\nOnly add \"wanted\" character.\\n\\n# Approach\\nLinear scan\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        char want = \\'a\\';\\n        int r = 0;\\n        for (int i = 0; i < word.length() || want != \\'a\\'; ) {\\n            if (i < word.length() && word[i] == want) {\\n                ++i;\\n            } else {\\n                ++r;\\n            }\\n            if (++want == \\'d\\') {\\n                want = \\'a\\';\\n            }\\n        }\\n        return r;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        char want = \\'a\\';\\n        int r = 0;\\n        for (int i = 0; i < word.length() || want != \\'a\\'; ) {\\n            if (i < word.length() && word[i] == want) {\\n                ++i;\\n            } else {\\n                ++r;\\n            }\\n            if (++want == \\'d\\') {\\n                want = \\'a\\';\\n            }\\n        }\\n        return r;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421694,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n  \\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int val=0,size=word.length();\\n        if(word.charAt(0)==\\'b\\')\\n        {\\n            val+=1;\\n        }\\n        if(word.charAt(0)==\\'c\\')\\n        {\\n            val+=2;\\n        }\\n        if(word.charAt(size-1)==\\'b\\')\\n        {\\n            val+=1;\\n        }\\n        if(word.charAt(size-1)==\\'a\\')\\n        {\\n            val+=2;\\n        }\\n        for(int i=0;i<size-1;i++)\\n        {\\n            char c=word.charAt(i);\\n            char d=word.charAt(i+1);\\n            if((c==\\'a\\' && d==\\'a\\') || (c==\\'b\\' && d==\\'b\\') || (c==\\'c\\' && d==\\'c\\'))\\n            {\\n                val+=2;\\n            }\\n            else if((c==\\'a\\' && d==\\'c\\') || (c==\\'b\\' && d==\\'a\\') || (c==\\'c\\' && d==\\'b\\'))\\n            {\\n                val+=1;\\n            }\\n        }\\n        return val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int val=0,size=word.length();\\n        if(word.charAt(0)==\\'b\\')\\n        {\\n            val+=1;\\n        }\\n        if(word.charAt(0)==\\'c\\')\\n        {\\n            val+=2;\\n        }\\n        if(word.charAt(size-1)==\\'b\\')\\n        {\\n            val+=1;\\n        }\\n        if(word.charAt(size-1)==\\'a\\')\\n        {\\n            val+=2;\\n        }\\n        for(int i=0;i<size-1;i++)\\n        {\\n            char c=word.charAt(i);\\n            char d=word.charAt(i+1);\\n            if((c==\\'a\\' && d==\\'a\\') || (c==\\'b\\' && d==\\'b\\') || (c==\\'c\\' && d==\\'c\\'))\\n            {\\n                val+=2;\\n            }\\n            else if((c==\\'a\\' && d==\\'c\\') || (c==\\'b\\' && d==\\'a\\') || (c==\\'c\\' && d==\\'b\\'))\\n            {\\n                val+=1;\\n            }\\n        }\\n        return val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422479,
                "title": "c-o-n-solution",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int count = 0;\\n         for(int i = 0; i < word.size(); i++) {\\n             if(i == 0) {\\n                 if(word[i] == \\'b\\') count++;\\n                 else if(word[i] == \\'c\\') count += 2;\\n             }\\n             if(i == word.size() - 1) {\\n                 if(word[i] == \\'a\\') count += 2;\\n                 else if(word[i] == \\'b\\') count++;\\n             }\\n             else {\\n                 if(word[i] == word[i + 1]) count += 2;\\n                 else if(word[i] == \\'a\\' && word[i + 1] == \\'c\\') count++;\\n                 else if(word[i] == \\'a\\' && word[i + 1] == \\'c\\') count++;\\n                 else if(word[i] == \\'b\\' && word[i + 1] == \\'a\\') count++;\\n                 else if(word[i] == \\'c\\' && word[i + 1] == \\'b\\') count++;\\n             }\\n         }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int count = 0;\\n         for(int i = 0; i < word.size(); i++) {\\n             if(i == 0) {\\n                 if(word[i] == \\'b\\') count++;\\n                 else if(word[i] == \\'c\\') count += 2;\\n             }\\n             if(i == word.size() - 1) {\\n                 if(word[i] == \\'a\\') count += 2;\\n                 else if(word[i] == \\'b\\') count++;\\n             }\\n             else {\\n                 if(word[i] == word[i + 1]) count += 2;\\n                 else if(word[i] == \\'a\\' && word[i + 1] == \\'c\\') count++;\\n                 else if(word[i] == \\'a\\' && word[i + 1] == \\'c\\') count++;\\n                 else if(word[i] == \\'b\\' && word[i + 1] == \\'a\\') count++;\\n                 else if(word[i] == \\'c\\' && word[i + 1] == \\'b\\') count++;\\n             }\\n         }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606616,
                "title": "explained-simple-and-clear-python3-code",
                "content": "# Intuition\\nThe problem requires us to determine the minimum number of letters that need to be inserted into a given string to make it valid. A valid string is defined as a string that can be formed by concatenating the string \"abc\" multiple times. To solve this problem, we can iteratively search for occurrences of \"abc\" and replace them with a placeholder, \"---\". Additionally, we also need to handle occurrences of \"ab\", \"ac\", and \"bc\" separately, replacing them with \"--\" while keeping track of the count. Finally, we count the remaining characters in the string that are not placeholders and add twice their count to the overall result.\\n\\n\\n# Approach\\nWe initialize a variable count to keep track of the minimum number of letters that need to be inserted. We then proceed with the following steps:\\n\\n1. While there is an occurrence of \"abc\" in the given word, we find its index i using the find function and replace it with \"---\" by modifying the word string.\\n2. Similarly, we search for occurrences of \"ab\", \"ac\", and \"bc\" in the word string using the find function. For each occurrence found, we replace it with \"--\" and increment the count by 1.\\n3. After handling all occurrences of \"abc\", \"ab\", \"ac\", and \"bc\", we iterate through the remaining characters in the word string. For each character that is not a placeholder (\"-\"), we increment the count by 2 to account for the necessary insertions.\\n4. Finally, we return the count as the minimum number of letters required to make the word string valid.\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution depends on the size of the word string. In the worst case, we may need to iterate over the entire word string multiple times to replace occurrences of \"abc\", \"ab\", \"ac\", and \"bc\". Therefore, the time complexity is O(n), where n represents the length of the word string.\\n\\n\\n- Space complexity:\\nThe space complexity of this solution is O(1) since we are not using any additional data structures that grow with the input size. We only require a constant amount of extra space to store the count variable and temporary variables for string modifications.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        count=0\\n        while word.find(\"abc\")!=-1:\\n            i=word.find(\"abc\")\\n            word=word[:i]+\"---\"+word[i+3:]\\n        while word.find(\"ab\")!=-1:\\n            i=word.find(\"ab\")\\n            word=word[:i]+\"--\"+word[i+2:]\\n            count+=1\\n        while word.find(\"ac\")!=-1:\\n            i=word.find(\"ac\")\\n            word=word[:i]+\"--\"+word[i+2:]\\n            count+=1\\n        while word.find(\"bc\")!=-1:\\n            i=word.find(\"bc\")\\n            word=word[:i]+\"--\"+word[i+2:]\\n            count+=1\\n        for i in range(len(word)):\\n            if word[i]!=\"-\":\\n                count+=2\\n        return count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        count=0\\n        while word.find(\"abc\")!=-1:\\n            i=word.find(\"abc\")\\n            word=word[:i]+\"---\"+word[i+3:]\\n        while word.find(\"ab\")!=-1:\\n            i=word.find(\"ab\")\\n            word=word[:i]+\"--\"+word[i+2:]\\n            count+=1\\n        while word.find(\"ac\")!=-1:\\n            i=word.find(\"ac\")\\n            word=word[:i]+\"--\"+word[i+2:]\\n            count+=1\\n        while word.find(\"bc\")!=-1:\\n            i=word.find(\"bc\")\\n            word=word[:i]+\"--\"+word[i+2:]\\n            count+=1\\n        for i in range(len(word)):\\n            if word[i]!=\"-\":\\n                count+=2\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421739,
                "title": "java-c-python-simple-and-fastest-solution-with-proper-board-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsimple one pointer solution single iteration solution\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe will iterate over string and check for the current char and next char and next to next char \\nwe will maintain two variables \\n(ans) to calc res \\n(i) as a pointer\\n\\nthen there will be 3 conditions\\ncurrent char = c\\nnex char = cnex\\n\\n# conditon 1 if(c==\\'a\\')\\n![image.png](https://assets.leetcode.com/users/images/1086b0c5-776e-42a4-8965-b26ee391e0ca_1681618245.0409527.png)\\n\\n# conditon 2 if(c==\\'b\\')\\n![image.png](https://assets.leetcode.com/users/images/78822399-4d1d-4355-ae46-1db6a86630ef_1681618123.6426458.png)\\n\\n# conditon 3 if(c==\\'c\\')\\n![image.png](https://assets.leetcode.com/users/images/7f4450fd-cd54-4f07-ae68-029421604b2f_1681618169.4481125.png)\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: none\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```c++ []\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n       int len = word.length();\\n        int ans = 0;\\n        int i = 0;\\n        while (i < len - 1) {\\n            char c = word[i];\\n            char cnex = word[i+1];\\n            if (c == \\'a\\') {\\n                if (cnex == \\'a\\')\\n                    ans += 2;\\n                else if (i < len-2 && cnex == \\'b\\' && word[i+2] == \\'c\\')\\n                    i += 2;\\n                else {\\n                    ans++;\\n                    i++;\\n                }\\n            } else if (c == \\'b\\') {\\n                if (cnex == \\'c\\') {\\n                    ans++;\\n                    i++;\\n                } else\\n                    ans += 2;\\n            } else\\n                ans += 2;\\n            i++;\\n        }\\n        if (i < len)\\n            ans += 2;\\n        return ans; \\n    }\\n};\\nConsole\\n\\n```\\n```python []\\nclass Solution(object):\\n    def addMinimum(self, word):\\n        \\n        len_word = len(word)\\n        ans = 0\\n        i = 0\\n        while i < len_word - 1:\\n            c = word[i]\\n            cnex = word[i+1]\\n            if c == \\'a\\':\\n                if cnex == \\'a\\':\\n                    ans += 2\\n                elif i < len_word-2 and cnex == \\'b\\' and word[i+2] == \\'c\\':\\n                    i += 2\\n                else:\\n                    ans += 1\\n                    i += 1\\n            elif c == \\'b\\':\\n                if cnex == \\'c\\':\\n                    ans += 1\\n                    i += 1\\n                else:\\n                    ans += 2\\n            else:\\n                ans += 2\\n            i += 1\\n        if i < len_word:\\n            ans += 2\\n        return ans\\n\\n```\\n```java []\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int len = word.length();\\n        int ans =0;\\n        int i=0;\\n        while(i<len-1){\\n            char c = word.charAt(i);\\n            char cnex = word.charAt(i+1);\\n            if(c==\\'a\\'){\\n                if(cnex ==\\'a\\')ans+=2;\\n                else if(i<len-2 && cnex==\\'b\\' && word.charAt(i+2)==\\'c\\')i+=2;\\n                else{\\n                    ans++;\\n                    i++;\\n                }\\n            }else if(c==\\'b\\'){\\n                if(cnex ==\\'c\\'){\\n                    ans++;\\n                    i++;\\n                }else ans+=2;\\n            }else ans+=2;\\n            i++;\\n        }\\n        if(i<len)ans+=2;\\n        return ans;\\n    }\\n}\\n```\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```c++ []\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n       int len = word.length();\\n        int ans = 0;\\n        int i = 0;\\n        while (i < len - 1) {\\n            char c = word[i];\\n            char cnex = word[i+1];\\n            if (c == \\'a\\') {\\n                if (cnex == \\'a\\')\\n                    ans += 2;\\n                else if (i < len-2 && cnex == \\'b\\' && word[i+2] == \\'c\\')\\n                    i += 2;\\n                else {\\n                    ans++;\\n                    i++;\\n                }\\n            } else if (c == \\'b\\') {\\n                if (cnex == \\'c\\') {\\n                    ans++;\\n                    i++;\\n                } else\\n                    ans += 2;\\n            } else\\n                ans += 2;\\n            i++;\\n        }\\n        if (i < len)\\n            ans += 2;\\n        return ans; \\n    }\\n};\\nConsole\\n\\n```\n```python []\\nclass Solution(object):\\n    def addMinimum(self, word):\\n        \\n        len_word = len(word)\\n        ans = 0\\n        i = 0\\n        while i < len_word - 1:\\n            c = word[i]\\n            cnex = word[i+1]\\n            if c == \\'a\\':\\n                if cnex == \\'a\\':\\n                    ans += 2\\n                elif i < len_word-2 and cnex == \\'b\\' and word[i+2] == \\'c\\':\\n                    i += 2\\n                else:\\n                    ans += 1\\n                    i += 1\\n            elif c == \\'b\\':\\n                if cnex == \\'c\\':\\n                    ans += 1\\n                    i += 1\\n                else:\\n                    ans += 2\\n            else:\\n                ans += 2\\n            i += 1\\n        if i < len_word:\\n            ans += 2\\n        return ans\\n\\n```\n```java []\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int len = word.length();\\n        int ans =0;\\n        int i=0;\\n        while(i<len-1){\\n            char c = word.charAt(i);\\n            char cnex = word.charAt(i+1);\\n            if(c==\\'a\\'){\\n                if(cnex ==\\'a\\')ans+=2;\\n                else if(i<len-2 && cnex==\\'b\\' && word.charAt(i+2)==\\'c\\')i+=2;\\n                else{\\n                    ans++;\\n                    i++;\\n                }\\n            }else if(c==\\'b\\'){\\n                if(cnex ==\\'c\\'){\\n                    ans++;\\n                    i++;\\n                }else ans+=2;\\n            }else ans+=2;\\n            i++;\\n        }\\n        if(i<len)ans+=2;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427029,
                "title": "0-ms-clean-code-two-pointer",
                "content": "<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n*3)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string s) {\\n        const string a = \"abc\";\\n        int n = s.size();\\n        int i=0;\\n        int ans = 0;\\n        while(i<n){\\n            int j=0;\\n            while(i<n and j<3){\\n                if(s[i]!=a[j]){\\n                    ++ans;\\n                    ++j;\\n                }\\n                else if(s[i]==a[j]){\\n                    if(i+1<n)++i,++j;\\n                    else{\\n                        ans+=2-j;\\n                        return ans;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string s) {\\n        const string a = \"abc\";\\n        int n = s.size();\\n        int i=0;\\n        int ans = 0;\\n        while(i<n){\\n            int j=0;\\n            while(i<n and j<3){\\n                if(s[i]!=a[j]){\\n                    ++ans;\\n                    ++j;\\n                }\\n                else if(s[i]==a[j]){\\n                    if(i+1<n)++i,++j;\\n                    else{\\n                        ans+=2-j;\\n                        return ans;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421752,
                "title": "c-using-conditions-explained-with-example",
                "content": "# Intuition\\nThe idea is to traverse the string character by character, and based on the current character and the previous character(s), determine the number of characters that need to be added to make the string valid. \\nSay we have a string `bbca`\\n```\\nfor \\'b\\', \\nas it is the first character, we need to add \\'a\\' before it. \\nThen check if \\'c\\' exists after it, as it doesn\\'t add a \\'c\\' after it.\\n=> count=2\\n```\\n```\\nfor \\'b\\', \\nas \\'a\\' doesn\\'t exist before it, we need to add \\'a\\' before it . \\nThen check if \\'c\\' exists after it, as it does, we skip over the character \\'c\\'.\\n=> count=2+1=3\\n```\\n```\\nWe skipped \\'c\\' as it was already used for previous combination.\\n```\\n\\n```\\nfor \\'a\\', \\nas \\'a\\' is the last character, we need to add \\'b\\' and \\'c\\' after it.\\n=> count=3+2=5\\n```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string s) {\\n        int count = 0, n = s.size();\\n        for (int i = 0; i < n; ++i) {\\n            if (s[i] == \\'a\\') { \\n                if (i == n - 1) count += 2; // If \\'a\\' is the last character, add 2\\n                else if (s[i + 1] == \\'c\\') {\\n                    ++count; // If the next character is \\'c\\', add 1\\n                    ++i; // Skip the next character\\n                }\\n                else if (s[i + 1] == \\'b\\' && (i + 2 != n && s[i + 2] == \\'c\\')) i += 2; // If the next two characters are \\'bc\\', skip them\\n                else if (s[i + 1] == \\'b\\' && (i + 2 == n || s[i + 2] != \\'c\\')) {\\n                    ++count; // If the next character is \\'b\\' and the character after that is not \\'c\\', add 1\\n                    ++i; \\n                }\\n                else count += 2; // If the next character is not \\'b\\' or \\'c\\', i.e another a, add 2\\n            }\\n            else if (s[i] == \\'b\\') { \\n                if (i == n - 1) { // If b is the last character\\n                    count+=2;\\n                }\\n                else if (s[i + 1] == \\'c\\') {\\n                    ++count; // If the next character is \\'c\\', we only need to add \\'a\\' in front of bc\\n                    ++i; \\n                }\\n                else count += 2; \\n            }\\n            else {\\n                count += 2; // If the character is \\'c\\', add 2 for \"ab` before it\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nfor \\'b\\', \\nas it is the first character, we need to add \\'a\\' before it. \\nThen check if \\'c\\' exists after it, as it doesn\\'t add a \\'c\\' after it.\\n=> count=2\\n```\n```\\nfor \\'b\\', \\nas \\'a\\' doesn\\'t exist before it, we need to add \\'a\\' before it . \\nThen check if \\'c\\' exists after it, as it does, we skip over the character \\'c\\'.\\n=> count=2+1=3\\n```\n```\\nWe skipped \\'c\\' as it was already used for previous combination.\\n```\n```\\nfor \\'a\\', \\nas \\'a\\' is the last character, we need to add \\'b\\' and \\'c\\' after it.\\n=> count=3+2=5\\n```\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string s) {\\n        int count = 0, n = s.size();\\n        for (int i = 0; i < n; ++i) {\\n            if (s[i] == \\'a\\') { \\n                if (i == n - 1) count += 2; // If \\'a\\' is the last character, add 2\\n                else if (s[i + 1] == \\'c\\') {\\n                    ++count; // If the next character is \\'c\\', add 1\\n                    ++i; // Skip the next character\\n                }\\n                else if (s[i + 1] == \\'b\\' && (i + 2 != n && s[i + 2] == \\'c\\')) i += 2; // If the next two characters are \\'bc\\', skip them\\n                else if (s[i + 1] == \\'b\\' && (i + 2 == n || s[i + 2] != \\'c\\')) {\\n                    ++count; // If the next character is \\'b\\' and the character after that is not \\'c\\', add 1\\n                    ++i; \\n                }\\n                else count += 2; // If the next character is not \\'b\\' or \\'c\\', i.e another a, add 2\\n            }\\n            else if (s[i] == \\'b\\') { \\n                if (i == n - 1) { // If b is the last character\\n                    count+=2;\\n                }\\n                else if (s[i + 1] == \\'c\\') {\\n                    ++count; // If the next character is \\'c\\', we only need to add \\'a\\' in front of bc\\n                    ++i; \\n                }\\n                else count += 2; \\n            }\\n            else {\\n                count += 2; // If the character is \\'c\\', add 2 for \"ab` before it\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421697,
                "title": "easiest-code-to-understand-simple-logic",
                "content": "\\u201Ca\\u201D, \\u201Cb\\u201D , \\u201Cc\\u201D can be convert to \\u201Cabc\\u201D in 2 steps\\n \\u201Cab\\u201D, \\u201Cac\\u201D, \\u201Cbc\\u201D can be converted to \\u201Cabc\\u201D in 1 steps\\n \\u201Cabc\\u201D can be converted to \\u201Cabc\\u201D in 0 steps\\n\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word)\\n    {\\n        int n = word.size(), ans = 0;\\n        int i = 0;\\n        while(i < n)\\n        {\\n            //getting the character indexes\\n            int curr = word[i] - \\'a\\';\\n            int next = (i + 1 >= n)? -1 : word[i + 1] - \\'a\\';\\n            int nextToNext = (i + 2 >= n)? -1 : word[i + 2] - \\'a\\';\\n            \\n            if (curr < next && next < nextToNext) { i += 3; }  //\"abc\"\\n            else if (curr < next) { ans++; i += 2; } //\"ab\" or \"ac\" or \"bc\"\\n            else { ans += 2; i++; } //\"a\" or \"b\" or \"c\"\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word)\\n    {\\n        int n = word.size(), ans = 0;\\n        int i = 0;\\n        while(i < n)\\n        {\\n            //getting the character indexes\\n            int curr = word[i] - \\'a\\';\\n            int next = (i + 1 >= n)? -1 : word[i + 1] - \\'a\\';\\n            int nextToNext = (i + 2 >= n)? -1 : word[i + 2] - \\'a\\';\\n            \\n            if (curr < next && next < nextToNext) { i += 3; }  //\"abc\"\\n            else if (curr < next) { ans++; i += 2; } //\"ab\" or \"ac\" or \"bc\"\\n            else { ans += 2; i++; } //\"a\" or \"b\" or \"c\"\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424460,
                "title": "python-3-1-liner-using-replace-t-m-92-100",
                "content": "```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n\\n        return len(word.replace(\\'abc\\',\\'X\\' )\\n                       .replace(\\'ab\\' ,\\'C\\' )\\n                       .replace(\\'ac\\' ,\\'B\\' )\\n                       .replace(\\'bc\\' ,\\'A\\' )\\n                       .replace(\\'a\\'  ,\\'AA\\')\\n                       .replace(\\'b\\'  ,\\'BB\\')\\n                       .replace(\\'c\\'  ,\\'CC\\')\\n                       .replace(\\'X\\'  ,\\'\\'  ))\\n```\\n[https://leetcode.com/problems/minimum-additions-to-make-valid-string/submissions/934853699/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n\\n        return len(word.replace(\\'abc\\',\\'X\\' )\\n                       .replace(\\'ab\\' ,\\'C\\' )\\n                       .replace(\\'ac\\' ,\\'B\\' )\\n                       .replace(\\'bc\\' ,\\'A\\' )\\n                       .replace(\\'a\\'  ,\\'AA\\')\\n                       .replace(\\'b\\'  ,\\'BB\\')\\n                       .replace(\\'c\\'  ,\\'CC\\')\\n                       .replace(\\'X\\'  ,\\'\\'  ))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423624,
                "title": "c-2-pointer-o-n-easy-explanation",
                "content": "\\t// Just try to form more number of \"abc\".\\n\\t// Creater two pointers i and j for string word and \"abc\" respectively.\\n\\t// if any of chars in word does not match with abc then increase the count else move the i pointer.\\n\\t\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\tint addMinimum(string word) {\\n\\n\\t\\t\\tstring abc=\"abc\";\\n\\t\\t\\tint count=0,j=0;\\n\\n\\t\\t\\tfor(int i=0;i<word.size();)\\n\\t\\t\\t{\\n\\t\\t\\t\\tj=j%3;\\n\\n\\t\\t\\t\\tif(word[i]==abc[j])\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tcount++;\\n\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tcount +=(3-j);        // if last letter was not c then add count of remaining chars \\n\\t\\t\\treturn count;\\n\\t\\t }\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\tint addMinimum(string word) {\\n\\n\\t\\t\\tstring abc=\"abc\";\\n\\t\\t\\tint count=0,j=0;\\n\\n\\t\\t\\tfor(int i=0;i<word.size();)\\n\\t\\t\\t{\\n\\t\\t\\t\\tj=j%3;\\n\\n\\t\\t\\t\\tif(word[i]==abc[j])\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tcount++;\\n\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3421808,
                "title": "easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        string val = \"abc\";\\n        int n = word.length(),i=0,c=0;\\n        string str1,str2;\\n        \\n        while(i<n){\\n            if(i+2<n)\\n                str1 = word.substr(i,3);\\n            if(i+1<n)\\n                str2 = word.substr(i,2);\\n            \\n            if(i+2 < n && str1 == \"abc\"){\\n                i+=3;\\n            }\\n            else if(i+1<n  &&  (( str2 == \"ab\") || (str2 == \"bc\") || (str2== \"ac\") )  ){\\n                    i+=2;\\n                    c++;\\n            }\\n            else{\\n                c+=2;\\n                i++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        string val = \"abc\";\\n        int n = word.length(),i=0,c=0;\\n        string str1,str2;\\n        \\n        while(i<n){\\n            if(i+2<n)\\n                str1 = word.substr(i,3);\\n            if(i+1<n)\\n                str2 = word.substr(i,2);\\n            \\n            if(i+2 < n && str1 == \"abc\"){\\n                i+=3;\\n            }\\n            else if(i+1<n  &&  (( str2 == \"ab\") || (str2 == \"bc\") || (str2== \"ac\") )  ){\\n                    i+=2;\\n                    c++;\\n            }\\n            else{\\n                c+=2;\\n                i++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425733,
                "title": "2645-minimum-additions-to-make-valid-string",
                "content": "<iframe src=\"https://leetcode.com/playground/mjpv5oYM/shared\" frameBorder=\"0\" width=\"560\" height=\"500\"></iframe>",
                "solutionTags": [
                    "Python",
                    "C",
                    "Array",
                    "String",
                    "Greedy"
                ],
                "code": "<iframe src=\"https://leetcode.com/playground/mjpv5oYM/shared\" frameBorder=\"0\" width=\"560\" height=\"500\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 3422456,
                "title": "easy-8-line-code-2-approaches",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code 1\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        //Calculate value of k => the number of times repeatance of \"abc\" is required\\n        int k=0;\\n        // take prev as last char of \"abc\" \\n        char prev=\\'c\\';\\n        for(int i=0;i<word.length();i++){\\n            k+= prev >= word.charAt(i)?1:0;\\n            prev= word.charAt(i);\\n        }\\n        return 3*k-word.length();\\n    }\\n}\\n```\\n\\n#**Code 2**\\n```\\nclass Solution {\\n    int addMinimum(String word) {\\n    int ans=0;\\n    for(int i=0; i<word.length();){\\n        if(word.charAt(i)== \\'a\\') i++; else ans++;         \\n        if( i < word.length() && word.charAt(i)== \\'b\\')i++; else ans++;\\n        if(i < word.length() && word.charAt(i) == \\'c\\')i++; else ans++;\\n    }\\n    return ans;\\n}\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        //Calculate value of k => the number of times repeatance of \"abc\" is required\\n        int k=0;\\n        // take prev as last char of \"abc\" \\n        char prev=\\'c\\';\\n        for(int i=0;i<word.length();i++){\\n            k+= prev >= word.charAt(i)?1:0;\\n            prev= word.charAt(i);\\n        }\\n        return 3*k-word.length();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int addMinimum(String word) {\\n    int ans=0;\\n    for(int i=0; i<word.length();){\\n        if(word.charAt(i)== \\'a\\') i++; else ans++;         \\n        if( i < word.length() && word.charAt(i)== \\'b\\')i++; else ans++;\\n        if(i < word.length() && word.charAt(i) == \\'c\\')i++; else ans++;\\n    }\\n    return ans;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422061,
                "title": "best-c-well-explained-two-pointer",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTwo Pointer method\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n***O(N)***\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n***O(1)***\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int i=0, j=0, cnt=0;\\n        string s = \"abc\";   // this string is used to matching\\n        \\n        while(i < word.length())    {\\n            // if match then go forward\\n            if(word[i] == s[j]) {\\n                i++;\\n                j++;\\n                if(j >= 3)  j = 0;\\n            }\\n            // here character is not matching s[j] so increment the count and go next char of s\\n            else    {\\n                cnt++;\\n                j++;\\n                if(j >= 3)  j = 0;\\n            }\\n        }\\n        if(j==1)    cnt += 2;\\n        if(j==2)    cnt += 1;\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int i=0, j=0, cnt=0;\\n        string s = \"abc\";   // this string is used to matching\\n        \\n        while(i < word.length())    {\\n            // if match then go forward\\n            if(word[i] == s[j]) {\\n                i++;\\n                j++;\\n                if(j >= 3)  j = 0;\\n            }\\n            // here character is not matching s[j] so increment the count and go next char of s\\n            else    {\\n                cnt++;\\n                j++;\\n                if(j >= 3)  j = 0;\\n            }\\n        }\\n        if(j==1)    cnt += 2;\\n        if(j==2)    cnt += 1;\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421996,
                "title": "java-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we take a = 0, b = 1, c = 2, then the string must follow the pattern 012 012...\\nSo we can iterate over the characters and check if `(previous + 1) % 3 = current`\\n\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int ans = 0;\\n        int prev = 2;\\n        int i = 0;\\n        while (i < word.length()) {\\n            int curr = word.charAt(i) - \\'a\\';\\n            if ((prev+1)%3 == curr) {\\n                i++;\\n                prev = curr;\\n            }\\n            else {\\n                ans++;\\n                prev = (prev+1)%3;\\n            }\\n        }\\n        return ans + 2 - prev;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int ans = 0;\\n        int prev = 2;\\n        int i = 0;\\n        while (i < word.length()) {\\n            int curr = word.charAt(i) - \\'a\\';\\n            if ((prev+1)%3 == curr) {\\n                i++;\\n                prev = curr;\\n            }\\n            else {\\n                ans++;\\n                prev = (prev+1)%3;\\n            }\\n        }\\n        return ans + 2 - prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926257,
                "title": "beat-100-c-python",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int ans = 0, i = 0;\\n        while(i < word.size()){\\n            (word[i] == \\'a\\') ? i++ : ans++;         \\n            (word[i] == \\'b\\') ? i++ : ans++;\\n            (word[i] == \\'c\\') ? i++ : ans++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n# Python \\n```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        ans = 0\\n        i = 0\\n        while i < len(word):\\n            if word[i] == \\'a\\':\\n                i += 1\\n            else:\\n                ans += 1\\n                \\n            if word[i] == \\'b\\':\\n                i += 1\\n            else:\\n                ans += 1\\n                \\n            if word[i] == \\'c\\':\\n                i += 1\\n            else:\\n                ans += 1\\n                \\n        return ans\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int ans = 0, i = 0;\\n        while(i < word.size()){\\n            (word[i] == \\'a\\') ? i++ : ans++;         \\n            (word[i] == \\'b\\') ? i++ : ans++;\\n            (word[i] == \\'c\\') ? i++ : ans++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        ans = 0\\n        i = 0\\n        while i < len(word):\\n            if word[i] == \\'a\\':\\n                i += 1\\n            else:\\n                ans += 1\\n                \\n            if word[i] == \\'b\\':\\n                i += 1\\n            else:\\n                ans += 1\\n                \\n            if word[i] == \\'c\\':\\n                i += 1\\n            else:\\n                ans += 1\\n                \\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731536,
                "title": "two-pointers-easy-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake a temporary string \"abc\" and count the number of insertions to make it a valid string.\\n**For Ex:- string word = \"abb\"**\\n\\na b b **(i pointer)**\\n|----------->    same character increment i and j by 1.\\nabc  **(j pointer)**\\n\\na b b\\n--|----------->  same character increment i and j by 1.\\n-abc\\n\\na b b\\n----|-----------> Not same increment j  and count by 1. count = 1\\n-abc\\n\\na b b\\n----|-----------> Not same increment j  and count by 1. count = 2\\n----abc\\na b b\\n----|-----------> same character increment i and j by 1.\\n---abc\\n\\n**return count+3-j;**\\n\\n\\n# Complexity\\n- Time complexity:O(3*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string w) {\\n        string s = \"abc\";\\n        int ans = 0;\\n        int j = 0,i = 0;\\n        while(i<w.size())\\n        {\\n            if(s[j]!=w[i])\\n            {\\n                ans++;\\n                j = (j==2) ? 0:j+1;\\n            }\\n            else\\n            {\\n                i++;\\n                j = (j==2) ? 0:j+1;\\n            }\\n        }\\n        if(j!=0) ans+=3-j;\\n        return ans; \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/9802c181-91d8-447d-8966-5ee30a62072f_1688723009.8175957.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string w) {\\n        string s = \"abc\";\\n        int ans = 0;\\n        int j = 0,i = 0;\\n        while(i<w.size())\\n        {\\n            if(s[j]!=w[i])\\n            {\\n                ans++;\\n                j = (j==2) ? 0:j+1;\\n            }\\n            else\\n            {\\n                i++;\\n                j = (j==2) ? 0:j+1;\\n            }\\n        }\\n        if(j!=0) ans+=3-j;\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553528,
                "title": "faster-than-light-10-line-java-code-faster-than-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int res = 0 ,cur = 0, pos = 0, len = word.length();;   \\n        while(pos < len){\\n            if(cur == word.charAt(pos) - \\'a\\') pos ++;\\n            else   res ++;\\n            cur  = (cur + 1) % 3;\\n        }\\n        return res + \\'c\\' -  word.charAt(len - 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int res = 0 ,cur = 0, pos = 0, len = word.length();;   \\n        while(pos < len){\\n            if(cur == word.charAt(pos) - \\'a\\') pos ++;\\n            else   res ++;\\n            cur  = (cur + 1) % 3;\\n        }\\n        return res + \\'c\\' -  word.charAt(len - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538679,
                "title": "c-simple-iteration-no-dp-100-time-limit",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int ans=0;\\n        int i=0;\\n        int z=word.size()-2;\\n        for(i=0;i<z;i++)\\n        {\\n            if(word[i]==\\'a\\')\\n            {\\n                if(word[i+1]==\\'b\\'&&word[i+2]==\\'c\\') i+=2;\\n                else if(word[i+1]==\\'b\\'||word[i+1]==\\'c\\'){ans++; i++;}\\n                else {ans+=2;}\\n            }\\n            else if(word[i]==\\'b\\')\\n            {\\n                if(word[i+1]==\\'c\\'){ans++;i++;}\\n                else { ans+=2;}\\n            }\\n            else if(word[i]==\\'c\\') ans+=2;\\n        }\\n        int n=word.size()-1;\\n        if(i==n-1)\\n        {\\n            if(word[n-1]==\\'a\\')\\n            {\\n                if(word[n]==\\'b\\'||word[n]==\\'c\\') ans++;\\n                else\\n                {\\n                    ans+=4;\\n                }\\n            }\\n            else if(word[n-1]==\\'b\\')\\n            {\\n                if(word[n]==\\'c\\') ans++;\\n                else\\n                {\\n                    ans+=4;\\n                }\\n            }\\n            else if(word[n-1]==\\'c\\')\\n            {\\n                ans+=4;\\n            }\\n        }\\n        else if(i==n)\\n        {\\n            ans+=2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int ans=0;\\n        int i=0;\\n        int z=word.size()-2;\\n        for(i=0;i<z;i++)\\n        {\\n            if(word[i]==\\'a\\')\\n            {\\n                if(word[i+1]==\\'b\\'&&word[i+2]==\\'c\\') i+=2;\\n                else if(word[i+1]==\\'b\\'||word[i+1]==\\'c\\'){ans++; i++;}\\n                else {ans+=2;}\\n            }\\n            else if(word[i]==\\'b\\')\\n            {\\n                if(word[i+1]==\\'c\\'){ans++;i++;}\\n                else { ans+=2;}\\n            }\\n            else if(word[i]==\\'c\\') ans+=2;\\n        }\\n        int n=word.size()-1;\\n        if(i==n-1)\\n        {\\n            if(word[n-1]==\\'a\\')\\n            {\\n                if(word[n]==\\'b\\'||word[n]==\\'c\\') ans++;\\n                else\\n                {\\n                    ans+=4;\\n                }\\n            }\\n            else if(word[n-1]==\\'b\\')\\n            {\\n                if(word[n]==\\'c\\') ans++;\\n                else\\n                {\\n                    ans+=4;\\n                }\\n            }\\n            else if(word[n-1]==\\'c\\')\\n            {\\n                ans+=4;\\n            }\\n        }\\n        else if(i==n)\\n        {\\n            ans+=2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434022,
                "title": "c-most-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        stack<char> st;\\n        int n=word.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            string s1=\"\",s2=\"\";\\n            if(i+2<n)\\n            s1=word.substr(i,3);\\n            if(i+1<n)\\n            s2=word.substr(i,2);\\n            if(s1==\"abc\")\\n            {\\n                i+=2;\\n            }\\n            else if(s2==\"ab\" or s2==\"ac\" or s2==\"bc\")\\n            {\\n                i+=1;\\n                ans++;\\n            }\\n            else\\n            {\\n                ans+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        stack<char> st;\\n        int n=word.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            string s1=\"\",s2=\"\";\\n            if(i+2<n)\\n            s1=word.substr(i,3);\\n            if(i+1<n)\\n            s2=word.substr(i,2);\\n            if(s1==\"abc\")\\n            {\\n                i+=2;\\n            }\\n            else if(s2==\"ab\" or s2==\"ac\" or s2==\"bc\")\\n            {\\n                i+=1;\\n                ans++;\\n            }\\n            else\\n            {\\n                ans+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430920,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string w) {\\n        int k=0;\\n        int i=0, n=w.size();\\n        while(i<n)\\n        {\\n          int c=0;\\n          if(i<n && w[i]==\\'a\\')\\n            {\\n              c++; \\n              i++;\\n            }\\n          if(i<n && w[i]==\\'b\\')\\n            {\\n              c++; \\n              i++;\\n            }\\n          if(i<n && w[i]==\\'c\\')\\n            {\\n              c++; \\n              i++;\\n            }\\n            k+=(3-c);\\n            \\n        }\\n       return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string w) {\\n        int k=0;\\n        int i=0, n=w.size();\\n        while(i<n)\\n        {\\n          int c=0;\\n          if(i<n && w[i]==\\'a\\')\\n            {\\n              c++; \\n              i++;\\n            }\\n          if(i<n && w[i]==\\'b\\')\\n            {\\n              c++; \\n              i++;\\n            }\\n          if(i<n && w[i]==\\'c\\')\\n            {\\n              c++; \\n              i++;\\n            }\\n            k+=(3-c);\\n            \\n        }\\n       return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3429950,
                "title": "java-solution-easy-to-understand",
                "content": "![upvote.jpeg](https://assets.leetcode.com/users/images/3a1c7f54-0891-406c-a144-fa071056ca4c_1681802025.596787.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        if(word.equals(\"abc\"))return 0;\\n        int count=0;\\n        int i=0;\\n        for(i=0;i<word.length()-1;i++){\\n            if(i+3<=word.length()){\\n                String h=word.substring(i,i+3);\\n                if(h.equals(\"abc\")){\\n                i+=2;\\n                continue;\\n            }\\n        }\\n            String l=word.substring(i,i+2);\\n            if(l.equals(\"ab\")||l.equals(\"bc\")||l.equals(\"ac\")){\\n                count++;\\n                i++;\\n                continue;\\n            }\\n            \\n            char ch=word.charAt(i);\\n            if(ch==\\'a\\'||ch==\\'b\\'||ch==\\'c\\')count+=2;\\n        }\\n        if(i==word.length()-1){\\n            char ch=word.charAt(i);\\n            if(ch==\\'a\\'||ch==\\'b\\'||ch==\\'c\\')count+=2;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        if(word.equals(\"abc\"))return 0;\\n        int count=0;\\n        int i=0;\\n        for(i=0;i<word.length()-1;i++){\\n            if(i+3<=word.length()){\\n                String h=word.substring(i,i+3);\\n                if(h.equals(\"abc\")){\\n                i+=2;\\n                continue;\\n            }\\n        }\\n            String l=word.substring(i,i+2);\\n            if(l.equals(\"ab\")||l.equals(\"bc\")||l.equals(\"ac\")){\\n                count++;\\n                i++;\\n                continue;\\n            }\\n            \\n            char ch=word.charAt(i);\\n            if(ch==\\'a\\'||ch==\\'b\\'||ch==\\'c\\')count+=2;\\n        }\\n        if(i==word.length()-1){\\n            char ch=word.charAt(i);\\n            if(ch==\\'a\\'||ch==\\'b\\'||ch==\\'c\\')count+=2;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3428861,
                "title": "c-replace-abc-ab-bc-ac-a-b-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMark the matched string with star(s).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nReplace \"abc\"/\"ab\"/\"bc\"/\"ac\"/\"a\"/\"b\"/\"c\" with star(s).\\nCount the char(s) we need to insert for each replacement.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n = word.size();\\n        int ans = 0;\\n        \\n        // replace \"abc\"\\n        for (int i = 0; (i + 2) < n; i++) {\\n            if (word.substr(i, 3) == \"abc\") {\\n                word[i] = \\'*\\';\\n                word[i + 1] = \\'*\\';\\n                word[i + 2] = \\'*\\';\\n            }\\n        }\\n        \\n        // replace \"ab\"/\"bc\"/\"ac\"\\n        for (int i = 0; (i + 1) < n; i++) {\\n            string str = word.substr(i, 2);\\n            if ((str == \"ab\") || (str == \"bc\") || (str == \"ac\")) {\\n                word[i] = \\'*\\';\\n                word[i + 1] = \\'*\\';\\n                ans++;\\n            }\\n        }\\n        \\n        // replace \"a\"/\"b\"/\"c\"\\n        for (int i = 0; i < n; i++) {\\n            if (word[i] != \\'*\\') ans += 2;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n = word.size();\\n        int ans = 0;\\n        \\n        // replace \"abc\"\\n        for (int i = 0; (i + 2) < n; i++) {\\n            if (word.substr(i, 3) == \"abc\") {\\n                word[i] = \\'*\\';\\n                word[i + 1] = \\'*\\';\\n                word[i + 2] = \\'*\\';\\n            }\\n        }\\n        \\n        // replace \"ab\"/\"bc\"/\"ac\"\\n        for (int i = 0; (i + 1) < n; i++) {\\n            string str = word.substr(i, 2);\\n            if ((str == \"ab\") || (str == \"bc\") || (str == \"ac\")) {\\n                word[i] = \\'*\\';\\n                word[i + 1] = \\'*\\';\\n                ans++;\\n            }\\n        }\\n        \\n        // replace \"a\"/\"b\"/\"c\"\\n        for (int i = 0; i < n; i++) {\\n            if (word[i] != \\'*\\') ans += 2;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426386,
                "title": "swift-linear-solution-o-n",
                "content": "**Code:**\\n```\\nclass Solution {\\n    func addMinimum(_ word: String) -> Int {\\n        let word = Array(word)\\n        var i = 0\\n        var j = 0\\n        var res = 0\\n        let letters: [Character] = [\"a\", \"b\", \"c\"]\\n\\n        while i < word.count {\\n            if word[i] == letters[j] {\\n                i += 1\\n            } else {\\n                res += 1\\n            }\\n            j += 1\\n            j %= letters.count\\n        }\\n\\n        if j != 0 {\\n            res += letters.count - j\\n        }\\n\\n        return res\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func addMinimum(_ word: String) -> Int {\\n        let word = Array(word)\\n        var i = 0\\n        var j = 0\\n        var res = 0\\n        let letters: [Character] = [\"a\", \"b\", \"c\"]\\n\\n        while i < word.count {\\n            if word[i] == letters[j] {\\n                i += 1\\n            } else {\\n                res += 1\\n            }\\n            j += 1\\n            j %= letters.count\\n        }\\n\\n        if j != 0 {\\n            res += letters.count - j\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424647,
                "title": "state-machine-linear",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn next(c: char) -> char {\\n        match c {\\n            \\'a\\' => { \\'b\\' }\\n            \\'b\\' => { \\'c\\' }\\n            \\'c\\' => { \\'a\\' } \\n            _ => { \\' \\' }\\n        }\\n    }\\n    pub fn diff(e: char, g: char) -> (i32,char) {\\n        match (e,g) {\\n            (\\'a\\',\\'b\\') => (1, \\'c\\'),\\n            (\\'a\\',\\'c\\') => (2, \\'a\\'),\\n            (\\'b\\',\\'a\\') => (2, \\'b\\'),\\n            (\\'b\\',\\'c\\') => (1, \\'a\\'),\\n            (\\'c\\',\\'a\\') => (1, \\'b\\'),\\n            (\\'c\\',\\'b\\') => (2, \\'c\\'),\\n            (_,_) => (0, \\'a\\'),\\n        }\\n    }\\n    pub fn add_minimum(word: String) -> i32 {\\n        let mut cnt: i32 = 0;\\n        let mut n: char = \\'a\\';\\n        for c in word.chars() {\\n            if c != n {\\n                let (d,f) = Solution::diff(n, c);\\n                cnt += d;\\n                n = f;\\n            }\\n            else {\\n                n = Solution::next(n);\\n            }\\n        }\\n        match word.chars().last().unwrap() {\\n            \\'a\\' => cnt += 2,\\n            \\'b\\' => cnt += 1,\\n            _ => {}\\n        }\\n        cnt\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn next(c: char) -> char {\\n        match c {\\n            \\'a\\' => { \\'b\\' }\\n            \\'b\\' => { \\'c\\' }\\n            \\'c\\' => { \\'a\\' } \\n            _ => { \\' \\' }\\n        }\\n    }\\n    pub fn diff(e: char, g: char) -> (i32,char) {\\n        match (e,g) {\\n            (\\'a\\',\\'b\\') => (1, \\'c\\'),\\n            (\\'a\\',\\'c\\') => (2, \\'a\\'),\\n            (\\'b\\',\\'a\\') => (2, \\'b\\'),\\n            (\\'b\\',\\'c\\') => (1, \\'a\\'),\\n            (\\'c\\',\\'a\\') => (1, \\'b\\'),\\n            (\\'c\\',\\'b\\') => (2, \\'c\\'),\\n            (_,_) => (0, \\'a\\'),\\n        }\\n    }\\n    pub fn add_minimum(word: String) -> i32 {\\n        let mut cnt: i32 = 0;\\n        let mut n: char = \\'a\\';\\n        for c in word.chars() {\\n            if c != n {\\n                let (d,f) = Solution::diff(n, c);\\n                cnt += d;\\n                n = f;\\n            }\\n            else {\\n                n = Solution::next(n);\\n            }\\n        }\\n        match word.chars().last().unwrap() {\\n            \\'a\\' => cnt += 2,\\n            \\'b\\' => cnt += 1,\\n            _ => {}\\n        }\\n        cnt\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3423089,
                "title": "java-simple-and-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String str) {\\n        int i=0,ans=0;\\n       while(i<str.length())\\n       {int count=0;\\n        if(str.charAt(i)==\\'a\\')\\n        {\\n            count++;\\n            i++;\\n        }\\n        if(i<str.length() && str.charAt(i)==\\'b\\')\\n        {\\n            count++;\\n            i++;\\n        }\\n        if(i<str.length() && str.charAt(i)==\\'c\\')\\n        {\\n            count++;\\n            i++;\\n        }\\n        ans=ans+(3-count);\\n       }\\n       return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String str) {\\n        int i=0,ans=0;\\n       while(i<str.length())\\n       {int count=0;\\n        if(str.charAt(i)==\\'a\\')\\n        {\\n            count++;\\n            i++;\\n        }\\n        if(i<str.length() && str.charAt(i)==\\'b\\')\\n        {\\n            count++;\\n            i++;\\n        }\\n        if(i<str.length() && str.charAt(i)==\\'c\\')\\n        {\\n            count++;\\n            i++;\\n        }\\n        ans=ans+(3-count);\\n       }\\n       return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422424,
                "title": "simplest-4-line-solution-no-loop-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo find what makes abc and its ab,bc,ac that makes abc in 1 additions\\nelse all in 2 additions\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst remove all present abc as they are not required\\nthen count all ab,bc,ac\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def addMinimum(self, w: str) -> int:\\n        w=w.replace(\"abc\",\" \")\\n        r=w.count(\"ab\")+w.count(\"bc\")+w.count(\"ac\")\\n        k=w.count(\"a\")+w.count(\"b\")+w.count(\"c\")\\n        return k*2-r*3\\n                    \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addMinimum(self, w: str) -> int:\\n        w=w.replace(\"abc\",\" \")\\n        r=w.count(\"ab\")+w.count(\"bc\")+w.count(\"ac\")\\n        k=w.count(\"a\")+w.count(\"b\")+w.count(\"c\")\\n        return k*2-r*3\\n                    \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422144,
                "title": "c-stack-greedy-2-approaches",
                "content": "## Explanation\\nWe can use stack or greedy approaches to solve this problem. For explanation, check code comments :-)\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n## Code\\n\\n##  Greedy\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int res = 0, n = word.length();\\n        \\n        if(word.length() == 1) return 2;\\n        \\n        // checking if the first character is \\'a\\'\\n        // else if \\'b\\' insert a - 1\\n        // else if \\'c\\' insert ab - 2\\n        if(word[0] == \\'b\\') res++;\\n        else if(word[0] == \\'c\\') res += 2;\\n\\n        // checking if the last character is \\'c\\'\\n        // else if \\'a\\' insert bc - 2\\n        // else if \\'b\\' insert c - 1\\n        if(word[n-1] == \\'b\\') res++;\\n        else if(word[n-1] == \\'a\\') res += 2;\\n    \\n        for(int i = 0; i < word.length()-1; i++){\\n            int curr = word[i] - \\'a\\', next = word[i+1] - \\'a\\';\\n\\n            // if \"ab\" or \"bc\" or \"ca\" are the adjacent characters, continue\\n            if(curr == 0 and next == 1 or curr == 1 and next == 2 or curr == 2 and next == 0) continue;\\n            // if \"aa\" or \"bb\" or \"cc\" , insert two characters inbetween them\\n            else if(curr==next) res+=2;\\n            // if \"ac\" or \"cb\" or \"ba\"\\n            else res++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n## Stack\\n\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        stack <int> st;\\n        for(char c : word) st.push(c-\\'a\\');\\n        int res = 0;\\n\\n        while( !st.empty() ){\\n\\n            // stack would have the string reversed . so \"cba\" is the string to be concatenated\\n            // finding \"cba\" patterns \\n            \\n            if( !st.empty() and st.top() == 2) st.pop();\\n            else res++;\\n\\n            if( !st.empty() and st.top() == 1) st.pop();\\n            else res++;\\n\\n            if( !st.empty() and st.top() == 0) st.pop();\\n            else res++;\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int res = 0, n = word.length();\\n        \\n        if(word.length() == 1) return 2;\\n        \\n        // checking if the first character is \\'a\\'\\n        // else if \\'b\\' insert a - 1\\n        // else if \\'c\\' insert ab - 2\\n        if(word[0] == \\'b\\') res++;\\n        else if(word[0] == \\'c\\') res += 2;\\n\\n        // checking if the last character is \\'c\\'\\n        // else if \\'a\\' insert bc - 2\\n        // else if \\'b\\' insert c - 1\\n        if(word[n-1] == \\'b\\') res++;\\n        else if(word[n-1] == \\'a\\') res += 2;\\n    \\n        for(int i = 0; i < word.length()-1; i++){\\n            int curr = word[i] - \\'a\\', next = word[i+1] - \\'a\\';\\n\\n            // if \"ab\" or \"bc\" or \"ca\" are the adjacent characters, continue\\n            if(curr == 0 and next == 1 or curr == 1 and next == 2 or curr == 2 and next == 0) continue;\\n            // if \"aa\" or \"bb\" or \"cc\" , insert two characters inbetween them\\n            else if(curr==next) res+=2;\\n            // if \"ac\" or \"cb\" or \"ba\"\\n            else res++;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        stack <int> st;\\n        for(char c : word) st.push(c-\\'a\\');\\n        int res = 0;\\n\\n        while( !st.empty() ){\\n\\n            // stack would have the string reversed . so \"cba\" is the string to be concatenated\\n            // finding \"cba\" patterns \\n            \\n            if( !st.empty() and st.top() == 2) st.pop();\\n            else res++;\\n\\n            if( !st.empty() and st.top() == 1) st.pop();\\n            else res++;\\n\\n            if( !st.empty() and st.top() == 0) st.pop();\\n            else res++;\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422127,
                "title": "c-simple-easy-to-understand",
                "content": "````class Solution {\\npublic:\\n    int addMinimum(string str) {\\n        int a = 0, b = 0, c = 0, ans = 0;\\n        int i = 0, n = str.length();\\n        if(n==1)return 2;\\n        for(i = 0; i < n; i++){\\n            if(str[i]==\\'a\\'){\\n                if(i+1<n&&str[i+1]==\\'b\\'){\\n                    if(i+2<n&&str[i+2]==\\'c\\'){\\n                        i++;\\n                    }else{\\n                        ans++;\\n                    }\\n                    i++;\\n                }else if(i+1<n&&str[i+1]==\\'a\\'){\\n                    ans += 2;\\n                }else if(i+1<n&&str[i+1]==\\'c\\'){\\n                    ans++;\\n                    i++;\\n                }\\n                else{\\n                    ans += 2;\\n                }\\n            }else if(str[i]==\\'b\\'){\\n                if(i+1<n&&str[i+1]==\\'c\\'){\\n                    ans++;\\n                    i++;\\n                }else if(i+1<n&&str[i+1]!=\\'c\\'){\\n                    ans += 2;\\n                }else{\\n                    ans += 2;\\n                }\\n            }else if(str[i]==\\'c\\'){\\n                ans += 2;\\n            }\\n        }\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "````class Solution {\\npublic:\\n    int addMinimum(string str) {\\n        int a = 0, b = 0, c = 0, ans = 0;\\n        int i = 0, n = str.length();\\n        if(n==1)return 2;\\n        for(i = 0; i < n; i++){\\n            if(str[i]==\\'a\\'){\\n                if(i+1<n&&str[i+1]==\\'b\\'){\\n                    if(i+2<n&&str[i+2]==\\'c\\'){\\n                        i++;\\n                    }else{\\n                        ans++;\\n                    }\\n                    i++;\\n                }else if(i+1<n&&str[i+1]==\\'a\\'){\\n                    ans += 2;\\n                }else if(i+1<n&&str[i+1]==\\'c\\'){\\n                    ans++;\\n                    i++;\\n                }\\n                else{\\n                    ans += 2;\\n                }\\n            }else if(str[i]==\\'b\\'){\\n                if(i+1<n&&str[i+1]==\\'c\\'){\\n                    ans++;\\n                    i++;\\n                }else if(i+1<n&&str[i+1]!=\\'c\\'){\\n                    ans += 2;\\n                }else{\\n                    ans += 2;\\n                }\\n            }else if(str[i]==\\'c\\'){\\n                ans += 2;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422081,
                "title": "step-by-step-explanation-go-c",
                "content": "1 Initialize variables: order to keep track of the current pattern order (0, 1 or 2), pattern to store the pattern \"abc\", i to loop through the characters in word, and n to store the minimum number of changes required to make word follow the pattern.\\n2 Loop through the characters in word until the end is reached.\\n3 Compare the current character with the character in the pattern that corresponds to the current order value (0, 1 or 2).\\n4 If the characters are not equal, increment n to indicate that a change is required.\\n5 If the characters are equal, move to the next character in word.\\n6 Increment order to move to the next character in the pattern.\\n7 After the loop, calculate the remaining number of characters required to complete the pattern (3 - order % 3) % 3.\\n8 Add the remaining number of characters to n and return it as the minimum number of changes required to make word follow the pattern.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nGo\\n```\\nfunc addMinimum(word string) int {\\n    order, n := 0, 0\\n    pattern := \"abc\"\\n    \\n    for i := 0; i < len(word); {\\n        c := word[i]\\n        if pattern[order%3] != c {\\n            n++\\n        } else {\\n            i++\\n        }\\n        order++\\n    }\\n    \\n    n += (3 - order % 3) % 3\\n    \\n    return n\\n}\\n```\\nC#\\n```\\npublic class Solution {\\n    public int AddMinimum(string word) {\\n        var order = 0;\\n        var pattern = \"abc\";\\n        var i = 0;\\n        var n = 0;\\n        while (i < word.Length) {\\n            var c = word[i];\\n            if (pattern[order % 3] != c) n++;\\n            else i++;\\n            order++;\\n        }\\n\\n        n += (3 - order % 3) % 3;\\n\\n        return n;\\n    }\\n}\\n```\\n![a6c83c54-1d1a-4f26-8273-b687d119dd5b_1679889261.1494205.png](https://assets.leetcode.com/users/images/cc82e8aa-dc98-4f10-af4c-64b1528c0fb6_1680844232.130332.png)",
                "solutionTags": [
                    "C#",
                    "Go"
                ],
                "code": "```\\nfunc addMinimum(word string) int {\\n    order, n := 0, 0\\n    pattern := \"abc\"\\n    \\n    for i := 0; i < len(word); {\\n        c := word[i]\\n        if pattern[order%3] != c {\\n            n++\\n        } else {\\n            i++\\n        }\\n        order++\\n    }\\n    \\n    n += (3 - order % 3) % 3\\n    \\n    return n\\n}\\n```\n```\\npublic class Solution {\\n    public int AddMinimum(string word) {\\n        var order = 0;\\n        var pattern = \"abc\";\\n        var i = 0;\\n        var n = 0;\\n        while (i < word.Length) {\\n            var c = word[i];\\n            if (pattern[order % 3] != c) n++;\\n            else i++;\\n            order++;\\n        }\\n\\n        n += (3 - order % 3) % 3;\\n\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422044,
                "title": "short-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n = word.size();\\n        int cnt = 0;\\n        string s = \"abc\";\\n        int x = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            if(word[i] == s[x % 3]){\\n                x++;\\n                continue;\\n            }\\n            cnt++;\\n            x++;\\n            i--;\\n        }\\n        \\n        cnt += ((3 - x % 3) % 3);\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n = word.size();\\n        int cnt = 0;\\n        string s = \"abc\";\\n        int x = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            if(word[i] == s[x % 3]){\\n                x++;\\n                continue;\\n            }\\n            cnt++;\\n            x++;\\n            i--;\\n        }\\n        \\n        cnt += ((3 - x % 3) % 3);\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422031,
                "title": "add-characters-by-rules-ii-no-need-to-really-add-characters",
                "content": "# Intuition\\nSame as https://leetcode.com/problems/minimum-additions-to-make-valid-string/solutions/3422008/add-character-s-by-rules/.\\n\\n# Approach\\n(1) Add \\'c\\' after each \\'b\\' if necessary.\\n(2) Add \\'b\\' before each \\'c\\' if necessary.\\n(3) Add \\'a\\' before each \\'b\\' if necessary.\\n(4) Add \"bc\" after each \\'a\\' if necessary.\\n\\nNo need to really add characters.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        const int n = word.length();\\n        int r = 0;\\n        for (int i = 0; i < n; ++i) {\\n            switch(word[i]) {\\n                case \\'c\\':\\n                    r += 2;\\n                    break;\\n                case \\'b\\':\\n                    ++r;\\n                    if (i + 1 >= n || word[i + 1] != \\'c\\') {\\n                        ++r;\\n                    } else {\\n                        ++i;\\n                    }\\n                    break;\\n                case \\'a\\':\\n                    if (i + 1 >= n || word[i + 1] != \\'b\\') {\\n                        ++r;\\n                    } else {\\n                        ++i;\\n                    }\\n                    if (i + 1 >= n || word[i + 1] != \\'c\\') {\\n                        ++r;\\n                    } else {\\n                        ++i;\\n                    }\\n                    break;   \\n            }\\n            \\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        const int n = word.length();\\n        int r = 0;\\n        for (int i = 0; i < n; ++i) {\\n            switch(word[i]) {\\n                case \\'c\\':\\n                    r += 2;\\n                    break;\\n                case \\'b\\':\\n                    ++r;\\n                    if (i + 1 >= n || word[i + 1] != \\'c\\') {\\n                        ++r;\\n                    } else {\\n                        ++i;\\n                    }\\n                    break;\\n                case \\'a\\':\\n                    if (i + 1 >= n || word[i + 1] != \\'b\\') {\\n                        ++r;\\n                    } else {\\n                        ++i;\\n                    }\\n                    if (i + 1 >= n || word[i + 1] != \\'c\\') {\\n                        ++r;\\n                    } else {\\n                        ++i;\\n                    }\\n                    break;   \\n            }\\n            \\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422008,
                "title": "add-character-s-by-rules",
                "content": "# Intuition\\nAdd characters by rules.\\n\\n# Approach\\nAdd characters by rules.\\n\\n(1) Add \\'c\\' after each \\'b\\' if necessary.\\n(2) Add \\'b\\' before each \\'c\\' if necessary.\\n(3) Add \\'a\\' before each \\'b\\' if necessary.\\n(4) Add \"bc\" after each \\'a\\' if necessary.\\n\\n# Complexity\\n- Time complexity:\\nO(n ^ 2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        const int n = word.length();\\n        for (int i = 0; i < word.length(); ++i) {\\n            if (word[i] == \\'b\\' && (i + 1 >= word.length() || word[i + 1] != \\'c\\')) {\\n                word = word.substr(0, i + 1) + \\'c\\' + word.substr(i + 1);\\n                ++i;\\n            }\\n        }\\n        for (int i = 0; i < word.length(); ++i) {\\n            if (word[i] == \\'c\\' && (i == 0 || word[i - 1] != \\'b\\')) {\\n                word = word.substr(0, i) + \\'b\\' + word.substr(i);\\n                ++i;\\n            }\\n        }\\n        for (int i = 0; i < word.length(); ++i) {\\n            if (word[i] == \\'b\\' && (i == 0 || word[i - 1] != \\'a\\')) {\\n                word = word.substr(0, i) + \\'a\\' + word.substr(i);\\n                ++i;\\n            }\\n        }\\n        for (int i = 0; i < word.length(); ++i) {\\n            if (word[i] == \\'a\\' && (i + 1 >= word.length() || word[i + 1] != \\'b\\')) {\\n                word = word.substr(0, i + 1) + \"bc\" + word.substr(i + 1);\\n                i += 2;\\n            }\\n        }\\n        return word.length() - n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        const int n = word.length();\\n        for (int i = 0; i < word.length(); ++i) {\\n            if (word[i] == \\'b\\' && (i + 1 >= word.length() || word[i + 1] != \\'c\\')) {\\n                word = word.substr(0, i + 1) + \\'c\\' + word.substr(i + 1);\\n                ++i;\\n            }\\n        }\\n        for (int i = 0; i < word.length(); ++i) {\\n            if (word[i] == \\'c\\' && (i == 0 || word[i - 1] != \\'b\\')) {\\n                word = word.substr(0, i) + \\'b\\' + word.substr(i);\\n                ++i;\\n            }\\n        }\\n        for (int i = 0; i < word.length(); ++i) {\\n            if (word[i] == \\'b\\' && (i == 0 || word[i - 1] != \\'a\\')) {\\n                word = word.substr(0, i) + \\'a\\' + word.substr(i);\\n                ++i;\\n            }\\n        }\\n        for (int i = 0; i < word.length(); ++i) {\\n            if (word[i] == \\'a\\' && (i + 1 >= word.length() || word[i + 1] != \\'b\\')) {\\n                word = word.substr(0, i + 1) + \"bc\" + word.substr(i + 1);\\n                i += 2;\\n            }\\n        }\\n        return word.length() - n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421978,
                "title": "brute-force-checking-subsequence",
                "content": "# Intuition\\nAdd substring \"abc\" until we have a string that has word as a subsequence.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n ^ 2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    bool isSubsequence(const string &s, const string &w) {\\n        int j = 0;\\n        for (int i = j = 0; i < s.length() && j < w.length(); ++i) {\\n            if (s[i] == w[j]) {\\n                ++j;\\n            }\\n        }\\n        return j >= w.length();\\n    }\\npublic:\\n    int addMinimum(string word) {\\n        string s;\\n        for (;!isSubsequence(s, word); s.append(\"abc\"))\\n        ;\\n        return s.length() - word.length();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    bool isSubsequence(const string &s, const string &w) {\\n        int j = 0;\\n        for (int i = j = 0; i < s.length() && j < w.length(); ++i) {\\n            if (s[i] == w[j]) {\\n                ++j;\\n            }\\n        }\\n        return j >= w.length();\\n    }\\npublic:\\n    int addMinimum(string word) {\\n        string s;\\n        for (;!isSubsequence(s, word); s.append(\"abc\"))\\n        ;\\n        return s.length() - word.length();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421920,
                "title": "java-code-using-stack-100-faster-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    Stack Data Structure\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n- If the character is \\'a\\' you can push it into the stack.\\n- If the character is \\'b\\' then you have to check the peek character is \\'a\\' or not, if not then you have to push respective characters first and then push character \\'b\\'.\\n- If the character is \\'c\\' then check peek character is \\'b\\' or not , if not then push the respective characters first then push \\'c\\'.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String s) {\\n        Stack<Character> stack = new Stack<>();\\n       \\n        for(char c : s.toCharArray()) {\\n            if(stack.isEmpty()) {\\n                if(c == \\'b\\') {\\n                    stack.push(\\'a\\');\\n                   \\n                    stack.push(c);\\n                }\\n                else if(c == \\'c\\') {\\n                    stack.push(\\'a\\');\\n                    stack.push(\\'b\\');\\n                    stack.push(c);\\n                    \\n                }\\n                else stack.push(c);\\n            }\\n            else {\\n                if(c == \\'b\\') {\\n                   \\n                   if(stack.peek() == \\'b\\') {\\n                       stack.push(\\'c\\');\\n                       stack.push(\\'a\\');\\n                      \\n                   }\\n                    else if(stack.peek() == \\'c\\') {\\n                        stack.push(\\'a\\');\\n                        \\n                    }\\n                   \\n                }\\n                else if(c == \\'c\\') {\\n                   \\n                    if(stack.peek() == \\'a\\') {\\n                         \\n                        stack.push(\\'b\\');\\n                        \\n                        \\n                    }\\n                    else if(stack.peek() == c) {\\n                        stack.push(\\'a\\');\\n                        stack.push(\\'b\\');\\n                        \\n                    }\\n                }\\n                else {\\n                    if(stack.peek() == \\'a\\') {\\n                        \\n                        stack.push(\\'b\\');\\n                        stack.push(\\'c\\');\\n                       \\n                       \\n                    }\\n                    else if(stack.peek()==\\'b\\') {\\n                        stack.push(\\'c\\');\\n                       \\n                    }\\n                }\\n                stack.push(c);\\n            }\\n        }\\n        if(stack.peek() == \\'a\\') {\\n            stack.push(\\'b\\');\\n            stack.push(\\'c\\');\\n           \\n        }\\n        else if(stack.peek() == \\'b\\') {\\n            stack.push(\\'c\\');\\n           \\n        }\\n        \\n        return stack.size() - s.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String s) {\\n        Stack<Character> stack = new Stack<>();\\n       \\n        for(char c : s.toCharArray()) {\\n            if(stack.isEmpty()) {\\n                if(c == \\'b\\') {\\n                    stack.push(\\'a\\');\\n                   \\n                    stack.push(c);\\n                }\\n                else if(c == \\'c\\') {\\n                    stack.push(\\'a\\');\\n                    stack.push(\\'b\\');\\n                    stack.push(c);\\n                    \\n                }\\n                else stack.push(c);\\n            }\\n            else {\\n                if(c == \\'b\\') {\\n                   \\n                   if(stack.peek() == \\'b\\') {\\n                       stack.push(\\'c\\');\\n                       stack.push(\\'a\\');\\n                      \\n                   }\\n                    else if(stack.peek() == \\'c\\') {\\n                        stack.push(\\'a\\');\\n                        \\n                    }\\n                   \\n                }\\n                else if(c == \\'c\\') {\\n                   \\n                    if(stack.peek() == \\'a\\') {\\n                         \\n                        stack.push(\\'b\\');\\n                        \\n                        \\n                    }\\n                    else if(stack.peek() == c) {\\n                        stack.push(\\'a\\');\\n                        stack.push(\\'b\\');\\n                        \\n                    }\\n                }\\n                else {\\n                    if(stack.peek() == \\'a\\') {\\n                        \\n                        stack.push(\\'b\\');\\n                        stack.push(\\'c\\');\\n                       \\n                       \\n                    }\\n                    else if(stack.peek()==\\'b\\') {\\n                        stack.push(\\'c\\');\\n                       \\n                    }\\n                }\\n                stack.push(c);\\n            }\\n        }\\n        if(stack.peek() == \\'a\\') {\\n            stack.push(\\'b\\');\\n            stack.push(\\'c\\');\\n           \\n        }\\n        else if(stack.peek() == \\'b\\') {\\n            stack.push(\\'c\\');\\n           \\n        }\\n        \\n        return stack.size() - s.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421816,
                "title": "easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n=word.length(),ans=0;\\n        for(int i=0;i<n;i++){\\n            if(word[i]==\\'a\\'){\\n                if(i<n-2 && word[i+1]==\\'b\\' && word[i+2]==\\'c\\') i+=2;\\n                else if(i<n-1 && (word[i+1]==\\'b\\' || word[i+1]==\\'c\\')) {\\n                    ans+=1;\\n                    i+=1;\\n                }\\n                else ans+=2;\\n            }\\n            else if(word[i]==\\'b\\'){\\n                if(i<n-1 && word[i+1]==\\'c\\'){\\n                    ans+=1;\\n                    i+=1;\\n                }\\n                else ans+=2;\\n            }\\n            else ans+=2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n=word.length(),ans=0;\\n        for(int i=0;i<n;i++){\\n            if(word[i]==\\'a\\'){\\n                if(i<n-2 && word[i+1]==\\'b\\' && word[i+2]==\\'c\\') i+=2;\\n                else if(i<n-1 && (word[i+1]==\\'b\\' || word[i+1]==\\'c\\')) {\\n                    ans+=1;\\n                    i+=1;\\n                }\\n                else ans+=2;\\n            }\\n            else if(word[i]==\\'b\\'){\\n                if(i<n-1 && word[i+1]==\\'c\\'){\\n                    ans+=1;\\n                    i+=1;\\n                }\\n                else ans+=2;\\n            }\\n            else ans+=2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421803,
                "title": "c-beginer-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string w) {\\n        int i=0;\\n        \\n        int cnt=0;\\n        char pehla=\\'a\\';\\n        while(i<w.size()){\\n            if(w[i]==pehla){\\n                i++;\\n            }\\n            else{\\n                cnt++;\\n            }\\n        \\n        if(pehla==\\'a\\')pehla=\\'b\\';\\n        else if(pehla==\\'b\\')pehla=\\'c\\';\\n        else{\\n            pehla=\\'a\\';\\n        }\\n        }\\n        if(w[w.size()-1]==\\'a\\'){\\n            cnt++;\\n        cnt++;\\n        }\\n        else if(w[w.size()-1]==\\'b\\'){\\n            cnt++;\\n        }\\n        return cnt;}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string w) {\\n        int i=0;\\n        \\n        int cnt=0;\\n        char pehla=\\'a\\';\\n        while(i<w.size()){\\n            if(w[i]==pehla){\\n                i++;\\n            }\\n            else{\\n                cnt++;\\n            }\\n        \\n        if(pehla==\\'a\\')pehla=\\'b\\';\\n        else if(pehla==\\'b\\')pehla=\\'c\\';\\n        else{\\n            pehla=\\'a\\';\\n        }\\n        }\\n        if(w[w.size()-1]==\\'a\\'){\\n            cnt++;\\n        cnt++;\\n        }\\n        else if(w[w.size()-1]==\\'b\\'){\\n            cnt++;\\n        }\\n        return cnt;}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421726,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int count=0;\\n        HashMap<Character,Character> hm=new HashMap<>();\\n        <!-- next character needed -->\\n        hm.put(\\'a\\',\\'b\\');\\n        hm.put(\\'b\\',\\'c\\');\\n        hm.put(\\'c\\',\\'a\\');\\n        if(word.charAt(0)==\\'b\\')\\n            count+=1;\\n        if(word.charAt(0)==\\'c\\'){\\n            count+=2;\\n            if(word.length()==1)\\n                return count;\\n        }\\n        for(int i=0;i<word.length();i++){\\n            if(i==word.length()-1){\\n                if(word.charAt(i)==\\'a\\')\\n                    count+=2;\\n                if(word.charAt(i)==\\'b\\')\\n                    count+=1;\\n                break;\\n            }\\n            char ch=word.charAt(i);\\n            char ch2=word.charAt(i+1);\\n            if(ch==ch2)\\n                count+=2;\\n            else{\\n                if(ch2!=hm.get(ch))\\n                    count+=1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int count=0;\\n        HashMap<Character,Character> hm=new HashMap<>();\\n        <!-- next character needed -->\\n        hm.put(\\'a\\',\\'b\\');\\n        hm.put(\\'b\\',\\'c\\');\\n        hm.put(\\'c\\',\\'a\\');\\n        if(word.charAt(0)==\\'b\\')\\n            count+=1;\\n        if(word.charAt(0)==\\'c\\'){\\n            count+=2;\\n            if(word.length()==1)\\n                return count;\\n        }\\n        for(int i=0;i<word.length();i++){\\n            if(i==word.length()-1){\\n                if(word.charAt(i)==\\'a\\')\\n                    count+=2;\\n                if(word.charAt(i)==\\'b\\')\\n                    count+=1;\\n                break;\\n            }\\n            char ch=word.charAt(i);\\n            char ch2=word.charAt(i+1);\\n            if(ch==ch2)\\n                count+=2;\\n            else{\\n                if(ch2!=hm.get(ch))\\n                    count+=1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421683,
                "title": "easiest-and-detailed-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        \\n        if(word.equals(\"abc\")) return 0;\\n        if(word.length() == 1) return 2;\\n        \\n        int moves = 0, n = word.length();\\n        \\n        //If first char is \\'b\\', then we need to add \"a\", so count += 1\\n        if(word.charAt(0) == \\'b\\') moves += 1;\\n        \\n        //Similarly, if first char is \\'c\\', then we need to add \"ab\", so count += 2\\n        if(word.charAt(0) == \\'c\\') moves += 2;\\n        \\n        //We check char after curr_char in each step, and increment count accordingly\\n        for(int i = 0; i < word.length() - 1; i++){\\n            \\n            int curr = word.charAt(i) - \\'a\\', next = word.charAt(i + 1) - \\'a\\';\\n            \\n            //Suppose, if curr_char is b and next_char is b, so need we need to add \"ca\" to make the string valid\\n            if(curr == next){\\n                moves += 2;\\n            }\\n            \\n            //Add \"b\" in between\\n            else if(word.charAt(i) == \\'a\\' && word.charAt(i + 1) == \\'c\\'){\\n                moves += 1;\\n            }\\n            \\n            //Add \"c\" in between\\n            else if(word.charAt(i) == \\'b\\' && word.charAt(i + 1) == \\'a\\'){\\n                moves += 1;\\n            }\\n            \\n            //Add \"a\" in between\\n            else if(word.charAt(i) == \\'c\\' && word.charAt(i + 1) == \\'b\\'){\\n                moves += 1;\\n            }\\n            \\n        }\\n        \\n        //Checks for last char\\n        if(word.charAt(n - 1) == \\'a\\') moves += 2;\\n        if(word.charAt(n - 1) == \\'b\\') moves += 1;\\n        \\n        return moves;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        \\n        if(word.equals(\"abc\")) return 0;\\n        if(word.length() == 1) return 2;\\n        \\n        int moves = 0, n = word.length();\\n        \\n        //If first char is \\'b\\', then we need to add \"a\", so count += 1\\n        if(word.charAt(0) == \\'b\\') moves += 1;\\n        \\n        //Similarly, if first char is \\'c\\', then we need to add \"ab\", so count += 2\\n        if(word.charAt(0) == \\'c\\') moves += 2;\\n        \\n        //We check char after curr_char in each step, and increment count accordingly\\n        for(int i = 0; i < word.length() - 1; i++){\\n            \\n            int curr = word.charAt(i) - \\'a\\', next = word.charAt(i + 1) - \\'a\\';\\n            \\n            //Suppose, if curr_char is b and next_char is b, so need we need to add \"ca\" to make the string valid\\n            if(curr == next){\\n                moves += 2;\\n            }\\n            \\n            //Add \"b\" in between\\n            else if(word.charAt(i) == \\'a\\' && word.charAt(i + 1) == \\'c\\'){\\n                moves += 1;\\n            }\\n            \\n            //Add \"c\" in between\\n            else if(word.charAt(i) == \\'b\\' && word.charAt(i + 1) == \\'a\\'){\\n                moves += 1;\\n            }\\n            \\n            //Add \"a\" in between\\n            else if(word.charAt(i) == \\'c\\' && word.charAt(i + 1) == \\'b\\'){\\n                moves += 1;\\n            }\\n            \\n        }\\n        \\n        //Checks for last char\\n        if(word.charAt(n - 1) == \\'a\\') moves += 2;\\n        if(word.charAt(n - 1) == \\'b\\') moves += 1;\\n        \\n        return moves;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421681,
                "title": "o-n-but-why-the-length-is-just-50",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        word += \"  \";\\n        int ans = 0;\\n        for(int i = 0; i < word.size() - 2; i++) {\\n            int c = word[i];\\n            if(c == \\'a\\') {\\n                if(word[i + 1] == \\'b\\') {\\n                    i++;\\n                    if(word[i + 1] == \\'c\\') {\\n                        i++;\\n                    } else {\\n                        ans++;\\n                    }\\n                } else if(word[i + 1] == \\'c\\'){\\n                    i++;\\n                    ++ans;\\n                } else {\\n                    ans += 2;\\n                }\\n            } else if(c == \\'b\\') {\\n                if(word[i + 1] == \\'c\\') {\\n                    i++;\\n                    ++ans;\\n                } else {\\n                    ans += 2;\\n                }\\n            } else if(c == \\'c\\') {\\n                ans += 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        word += \"  \";\\n        int ans = 0;\\n        for(int i = 0; i < word.size() - 2; i++) {\\n            int c = word[i];\\n            if(c == \\'a\\') {\\n                if(word[i + 1] == \\'b\\') {\\n                    i++;\\n                    if(word[i + 1] == \\'c\\') {\\n                        i++;\\n                    } else {\\n                        ans++;\\n                    }\\n                } else if(word[i + 1] == \\'c\\'){\\n                    i++;\\n                    ++ans;\\n                } else {\\n                    ans += 2;\\n                }\\n            } else if(c == \\'b\\') {\\n                if(word[i + 1] == \\'c\\') {\\n                    i++;\\n                    ++ans;\\n                } else {\\n                    ans += 2;\\n                }\\n            } else if(c == \\'c\\') {\\n                ans += 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503622,
                "title": "python-solution",
                "content": "\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        n=len(word)\\n        i=0 #iterator \\n        s=0   \\n        while (i<n):\\n            c=0\\n            if word[i]==\\'a\\':\\n                c+=1\\n                i+=1\\n            \\n            if i<n and word[i]==\\'b\\':\\n                c+=1\\n                i+=1\\n            \\n            if i<n and word[i]==\\'c\\':\\n                c+=1\\n                i+=1\\n            \\n            s+=3-c\\n        \\n        return s\\n\\n\\n             \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        n=len(word)\\n        i=0 #iterator \\n        s=0   \\n        while (i<n):\\n            c=0\\n            if word[i]==\\'a\\':\\n                c+=1\\n                i+=1\\n            \\n            if i<n and word[i]==\\'b\\':\\n                c+=1\\n                i+=1\\n            \\n            if i<n and word[i]==\\'c\\':\\n                c+=1\\n                i+=1\\n            \\n            s+=3-c\\n        \\n        return s\\n\\n\\n             \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476967,
                "title": "simple-c-solution-in-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis Problem is not that complex if you think we just need to print the extra characters that will be added to make the entire string in the form (abc)^x.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo we first initialize a string s as \"abc\" and then we check if the current index (idx) on string s matches the character i of string word then we continue else we just iterate on string s till it matches the char of word and also increase count by 1 for every iteration of while loop.\\n\\nI am doing %3 so that idx stays in the range of 3 for string s.\\nFor the last statement i am checking if the char at last place is c or not if not then it can onlu ne a or b hence we add that diff to count.\\n\\n# Complexity\\n- Time complexity: O(3N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int count = 0,idx=0;\\n        string s = \"abc\";\\n        for(auto i:word){\\n            while(i!=s[(idx++)%3]){\\n                count++;\\n            }\\n        }\\n        return count + (\\'c\\' - word[word.size()-1]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int count = 0,idx=0;\\n        string s = \"abc\";\\n        for(auto i:word){\\n            while(i!=s[(idx++)%3]){\\n                count++;\\n            }\\n        }\\n        return count + (\\'c\\' - word[word.size()-1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3463556,
                "title": "c-linear-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem can be solved using a linear dynamic programming approach. We maintain a linear sequence (the given string \"word\") and use the values of previous states to compute the current state.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- For `dp[0]`, we set it to 2 since for one character, 2 additions are needed to form \"abc\". This is our base case.\\n- For each subsequent character, if the current character is greater than the previous character, we can decrease the number of additions required by 1. Otherwise, we increase the number of additions required by 2.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$, where n is the length of the input string.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$, where n is the length of the input string.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n = word.size();\\n        vector<int> dp(n);\\n        dp[0] = 2;\\n        for (int i = 1; i < n; ++i)\\n            dp[i] = word[i] > word[i-1] ? dp[i-1] - 1 : dp[i-1] + 2;\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n = word.size();\\n        vector<int> dp(n);\\n        dp[0] = 2;\\n        for (int i = 1; i < n; ++i)\\n            dp[i] = word[i] > word[i-1] ? dp[i-1] - 1 : dp[i-1] + 2;\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456679,
                "title": "easy-peesy-c-100-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int i=0;\\n        char temp=\\'a\\';\\n        int count=0;\\n        while(i<word.size())\\n        {\\n            if(word[i]==temp)\\n            {\\n                i++;\\n            }\\n            else\\n                count++;\\n            \\n            if(temp==\\'a\\')\\n                temp=\\'b\\';\\n            else if(temp==\\'b\\')\\n                temp=\\'c\\';\\n            else\\n                temp=\\'a\\';\\n        }\\n        if(word[word.size()-1]==\\'a\\')\\n            count=count+2;\\n        else if(word[word.size()-1]==\\'b\\')\\n            count=count+1;\\n    \\n        return count;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int i=0;\\n        char temp=\\'a\\';\\n        int count=0;\\n        while(i<word.size())\\n        {\\n            if(word[i]==temp)\\n            {\\n                i++;\\n            }\\n            else\\n                count++;\\n            \\n            if(temp==\\'a\\')\\n                temp=\\'b\\';\\n            else if(temp==\\'b\\')\\n                temp=\\'c\\';\\n            else\\n                temp=\\'a\\';\\n        }\\n        if(word[word.size()-1]==\\'a\\')\\n            count=count+2;\\n        else if(word[word.size()-1]==\\'b\\')\\n            count=count+1;\\n    \\n        return count;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437959,
                "title": "c-beginner-s-approach",
                "content": "\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string w) {\\n        stack<char>s;\\n        int cnt=0;\\n        for(int i=0; i<w.size(); i++){\\n            if(s.empty()){\\n                if(w[i]==\\'a\\'){\\n                    s.push(\\'a\\');\\n                }\\n                else if(w[i]==\\'b\\'){\\n                    cnt++;\\n                    s.push(\\'a\\');\\n                    s.push(\\'b\\');\\n                }\\n                else{\\n                    cnt+=2;\\n                }\\n            }\\n            else{\\n                if(s.top()==\\'a\\'){\\n                    if(w[i]==\\'a\\'){\\n                        cnt+=2;\\n                        s.pop();\\n                        s.push(w[i]);\\n                    }\\n                    else if(w[i]==\\'b\\'){\\n                        s.push(w[i]);\\n                    }\\n                    else{\\n                        cnt++;\\n                        s.pop();\\n                    }\\n                }\\n                else if(s.top()==\\'b\\'){\\n                    if(w[i]==\\'a\\'){\\n                        cnt++;\\n                        s.pop();\\n                        s.pop();\\n                        s.push(w[i]);\\n                    }\\n                    else if(w[i]==\\'b\\'){\\n                        cnt+=2;\\n                        s.pop();\\n                        s.push(w[i]);\\n                    }\\n                    else{\\n                        s.pop();\\n                        s.pop();\\n                    }\\n                }\\n            }\\n        }\\n        //cout<<cnt<<\" \"<<s.size()<<endl;\\n        while(!s.empty()){\\n            if(s.top()==\\'a\\'){\\n                cnt+=2;\\n                s.pop();\\n            }\\n            else if(s.top()==\\'b\\'){\\n                cnt++;\\n                s.pop();\\n                s.pop();\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string w) {\\n        stack<char>s;\\n        int cnt=0;\\n        for(int i=0; i<w.size(); i++){\\n            if(s.empty()){\\n                if(w[i]==\\'a\\'){\\n                    s.push(\\'a\\');\\n                }\\n                else if(w[i]==\\'b\\'){\\n                    cnt++;\\n                    s.push(\\'a\\');\\n                    s.push(\\'b\\');\\n                }\\n                else{\\n                    cnt+=2;\\n                }\\n            }\\n            else{\\n                if(s.top()==\\'a\\'){\\n                    if(w[i]==\\'a\\'){\\n                        cnt+=2;\\n                        s.pop();\\n                        s.push(w[i]);\\n                    }\\n                    else if(w[i]==\\'b\\'){\\n                        s.push(w[i]);\\n                    }\\n                    else{\\n                        cnt++;\\n                        s.pop();\\n                    }\\n                }\\n                else if(s.top()==\\'b\\'){\\n                    if(w[i]==\\'a\\'){\\n                        cnt++;\\n                        s.pop();\\n                        s.pop();\\n                        s.push(w[i]);\\n                    }\\n                    else if(w[i]==\\'b\\'){\\n                        cnt+=2;\\n                        s.pop();\\n                        s.push(w[i]);\\n                    }\\n                    else{\\n                        s.pop();\\n                        s.pop();\\n                    }\\n                }\\n            }\\n        }\\n        //cout<<cnt<<\" \"<<s.size()<<endl;\\n        while(!s.empty()){\\n            if(s.top()==\\'a\\'){\\n                cnt+=2;\\n                s.pop();\\n            }\\n            else if(s.top()==\\'b\\'){\\n                cnt++;\\n                s.pop();\\n                s.pop();\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3432266,
                "title": "c-beats-100-simple-iteration-greedy",
                "content": "# Intuition\\nSimple iteration\\n\\n# Approach\\nGreddy\\n\\n## Don\\'t forget to upvote and give a like \\uD83D\\uDE43\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n = word.size();\\n        int count = 0;\\n        int i = 0;\\n        while(i<n){\\n            if(word[i] == \\'a\\'){\\n                if(word[i+1] == \\'b\\' and word[i+2] == \\'c\\'){\\n                    i+=3;\\n                }\\n                else if(word[i+1] == \\'b\\'){\\n                    count++;\\n                    i+=2;\\n                }\\n                else if(word[i+1] == \\'c\\'){\\n                    count++;\\n                    i+=2;\\n                }\\n                else if(word[i+1] == \\'a\\'){\\n                    count+=2;\\n                    i++;\\n                }\\n                else{\\n                    count+=2;\\n                    i++;\\n                }\\n            }\\n            if(word[i] == \\'b\\'){\\n                if(word[i+1] == \\'c\\'){\\n                    count++;\\n                    i+=2;\\n                }\\n                else{\\n                    count+=2;\\n                    i++;\\n                }\\n            }\\n            if(word[i] == \\'c\\'){\\n                count+=2;\\n                i++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n### I hope the solution is clear; use the comment section regarding any doubt.",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n = word.size();\\n        int count = 0;\\n        int i = 0;\\n        while(i<n){\\n            if(word[i] == \\'a\\'){\\n                if(word[i+1] == \\'b\\' and word[i+2] == \\'c\\'){\\n                    i+=3;\\n                }\\n                else if(word[i+1] == \\'b\\'){\\n                    count++;\\n                    i+=2;\\n                }\\n                else if(word[i+1] == \\'c\\'){\\n                    count++;\\n                    i+=2;\\n                }\\n                else if(word[i+1] == \\'a\\'){\\n                    count+=2;\\n                    i++;\\n                }\\n                else{\\n                    count+=2;\\n                    i++;\\n                }\\n            }\\n            if(word[i] == \\'b\\'){\\n                if(word[i+1] == \\'c\\'){\\n                    count++;\\n                    i+=2;\\n                }\\n                else{\\n                    count+=2;\\n                    i++;\\n                }\\n            }\\n            if(word[i] == \\'c\\'){\\n                count+=2;\\n                i++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432215,
                "title": "o-n-solution-easy-approach-beginner-friendly-code-c",
                "content": "# Approach\\nCheck if \"abc\" substring is present in the given string then skip them else for \"ab\", \"bc\", \"ac\" add 1 to your answer else add 2 for single substrings and move the pointer accordingly\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        if (word == \"abc\") {\\n            return 0;\\n        }\\n        int n = word.size();\\n        int i = 0;\\n        int ans = 0;\\n        while (i < n) {\\n            if (i == n-1) {\\n                ans += 2;\\n                i++;\\n            } else if (i+2 < n && word.substr(i, 3) == \"abc\") {\\n                i += 3;\\n            } else if (i+1 < n) {\\n                if (word.substr(i, 2) == \"ab\" || word.substr(i, 2) == \"bc\" || word.substr(i, 2) == \"ac\") {\\n                    ans += 1;\\n                    i += 2;\\n                } else {\\n                    ans += 2;\\n                    i++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nIf you like the solution please upvote. Thanks \\uD83D\\uDE0A\\uD83D\\uDE03",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        if (word == \"abc\") {\\n            return 0;\\n        }\\n        int n = word.size();\\n        int i = 0;\\n        int ans = 0;\\n        while (i < n) {\\n            if (i == n-1) {\\n                ans += 2;\\n                i++;\\n            } else if (i+2 < n && word.substr(i, 3) == \"abc\") {\\n                i += 3;\\n            } else if (i+1 < n) {\\n                if (word.substr(i, 2) == \"ab\" || word.substr(i, 2) == \"bc\" || word.substr(i, 2) == \"ac\") {\\n                    ans += 1;\\n                    i += 2;\\n                } else {\\n                    ans += 2;\\n                    i++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430671,
                "title": "two-pointer",
                "content": "# Approach\\nTwo Pointer\\n\\n# Code\\n```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        \\n        target = \"abc\"\\n        i, j = 0, 0\\n        count = 0\\n\\n        while i < len(word):\\n            if j == len(target):\\n                j = 0\\n            if word[i] == target[j]:            \\n                i += 1\\n                j += 1\\n            else:         \\n                count += 1\\n                j += 1\\n    \\n        count += len(target) - j\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        \\n        target = \"abc\"\\n        i, j = 0, 0\\n        count = 0\\n\\n        while i < len(word):\\n            if j == len(target):\\n                j = 0\\n            if word[i] == target[j]:            \\n                i += 1\\n                j += 1\\n            else:         \\n                count += 1\\n                j += 1\\n    \\n        count += len(target) - j\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3429563,
                "title": "easy-greedy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n=word.size();\\n        int res=0;\\n        int i=0;\\n        while(i<n){\\n            int cnt=0;\\n            if(word[i]==\\'a\\'){\\n                cnt++;i++;\\n            }\\n            if(i<n && word[i]==\\'b\\'){\\n                cnt++;i++;\\n            }\\n            if(i<n && word[i]==\\'c\\'){\\n                cnt++;i++;\\n            }\\n            res+=(3-cnt);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n=word.size();\\n        int res=0;\\n        int i=0;\\n        while(i<n){\\n            int cnt=0;\\n            if(word[i]==\\'a\\'){\\n                cnt++;i++;\\n            }\\n            if(i<n && word[i]==\\'b\\'){\\n                cnt++;i++;\\n            }\\n            if(i<n && word[i]==\\'c\\'){\\n                cnt++;i++;\\n            }\\n            res+=(3-cnt);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3428432,
                "title": "c-easy-to-understand-concise-gready-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int countSections = 1;\\n        for(int i=0; i<word.size()-1; i++){\\n            if(word[i] >= word[i+1]) countSections++;\\n        }\\n        \\n        return (3*countSections) - word.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int countSections = 1;\\n        for(int i=0; i<word.size()-1; i++){\\n            if(word[i] >= word[i+1]) countSections++;\\n        }\\n        \\n        return (3*countSections) - word.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425944,
                "title": "eazy-to-understand-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) \\n    {\\n        int add = 0;\\n        int offset = 0;\\n        int idx = 0;\\n        while(idx < (word.length()))\\n        {\\n            char expected_char = char(\\'a\\' + offset);\\n            if(word[idx] == expected_char)\\n            {\\n                idx++;\\n                offset = offset + 1;\\n\\n                if(char(\\'a\\' + offset) == \\'d\\')\\n                offset = 0;\\n            }\\n            else\\n            {\\n                 add++;\\n                 offset = offset + 1;\\n\\n                 if(char(\\'a\\' + offset) == \\'d\\')\\n                 offset = 0;\\t \\n            }\\n        }\\n        char expected_char = char(\\'a\\' + offset);\\n        if(expected_char == \\'a\\') return add;\\n        else if(expected_char == \\'b\\') return add+2;\\n\\n        return add+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) \\n    {\\n        int add = 0;\\n        int offset = 0;\\n        int idx = 0;\\n        while(idx < (word.length()))\\n        {\\n            char expected_char = char(\\'a\\' + offset);\\n            if(word[idx] == expected_char)\\n            {\\n                idx++;\\n                offset = offset + 1;\\n\\n                if(char(\\'a\\' + offset) == \\'d\\')\\n                offset = 0;\\n            }\\n            else\\n            {\\n                 add++;\\n                 offset = offset + 1;\\n\\n                 if(char(\\'a\\' + offset) == \\'d\\')\\n                 offset = 0;\\t \\n            }\\n        }\\n        char expected_char = char(\\'a\\' + offset);\\n        if(expected_char == \\'a\\') return add;\\n        else if(expected_char == \\'b\\') return add+2;\\n\\n        return add+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424967,
                "title": "python-stack-deque",
                "content": "# Intuition\\nNeed to find the correct sequence of letters, parse and correct errors where necessary. \\n\\n# Approach\\nInspect from the end using a stack. \\nAlternatively use deque for inspection from beginning. \\n\\n# Complexity\\n- Time/space complexity:\\nO(n), n = length of input\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        stack = list(word)\\n        result = 0\\n        while stack:\\n            for l in \"cba\":\\n                if stack and stack[-1] == l: stack.pop()\\n                else: result += 1\\n        return result\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        stack = list(word)\\n        result = 0\\n        while stack:\\n            for l in \"cba\":\\n                if stack and stack[-1] == l: stack.pop()\\n                else: result += 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424455,
                "title": "easy-c-solution-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(3)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) \\n    {\\n        string abc = \"abc\";\\n        int n = 3;\\n        int i=0;\\n        int j=0;\\n        int count=0;\\n        while(i<word.length())\\n        {\\n            if(j==3)\\n            {\\n                j=0;\\n            }\\n            if(word[i]==abc[j])\\n            {\\n                i++;\\n                j++;\\n            }\\n            else\\n            {\\n                count++;\\n                j++;\\n            }\\n        }\\n        count += n - j;\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) \\n    {\\n        string abc = \"abc\";\\n        int n = 3;\\n        int i=0;\\n        int j=0;\\n        int count=0;\\n        while(i<word.length())\\n        {\\n            if(j==3)\\n            {\\n                j=0;\\n            }\\n            if(word[i]==abc[j])\\n            {\\n                i++;\\n                j++;\\n            }\\n            else\\n            {\\n                count++;\\n                j++;\\n            }\\n        }\\n        count += n - j;\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424398,
                "title": "c-recursion",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void helper(string s, char compa, int i, int& cnt){\\n        if (i>=s.size())return;\\n        if (s[i]!=compa){cnt++;i=i-1;}\\n        helper(s,(\\'a\\'+(compa-\\'a\\'+1)%3),i+1,cnt);\\n    }\\n    int addMinimum(string s) {\\n        int cnt=0;\\n        int n= s.size();\\n        char compa=\\'a\\';\\n        helper(s,compa,0,cnt);\\n        if (s.back()==\\'a\\')cnt+=2;\\n        if (s.back()==\\'b\\')cnt++;\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy",
                    "Recursion",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(string s, char compa, int i, int& cnt){\\n        if (i>=s.size())return;\\n        if (s[i]!=compa){cnt++;i=i-1;}\\n        helper(s,(\\'a\\'+(compa-\\'a\\'+1)%3),i+1,cnt);\\n    }\\n    int addMinimum(string s) {\\n        int cnt=0;\\n        int n= s.size();\\n        char compa=\\'a\\';\\n        helper(s,compa,0,cnt);\\n        if (s.back()==\\'a\\')cnt+=2;\\n        if (s.back()==\\'b\\')cnt++;\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424033,
                "title": "c-probably-the-most-easiest-solution-beats-80-o-n",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int ans = 0;\\n        if(word[0]==\\'b\\')\\n            ans = ans + 1;\\n        if(word[0]==\\'c\\')\\n            ans = ans + 2;\\n        \\n        if(word[word.size()-1] == \\'a\\')\\n            ans = ans + 2;\\n        if(word[word.size()-1]==\\'b\\')\\n            ans = ans + 1;\\n        \\n        for(int i=0;i<word.size()-1;i++)\\n        {\\n            char c1 = word[i];\\n            char c2 = word[i+1];\\n            \\n            if(c1 == c2)\\n                ans = ans + 2;\\n            if(c1 == \\'a\\' && c2 == \\'c\\' || c1 == \\'b\\' && c2 == \\'a\\' || c1==\\'c\\' && c2 == \\'b\\' )\\n                ans = ans+1;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int ans = 0;\\n        if(word[0]==\\'b\\')\\n            ans = ans + 1;\\n        if(word[0]==\\'c\\')\\n            ans = ans + 2;\\n        \\n        if(word[word.size()-1] == \\'a\\')\\n            ans = ans + 2;\\n        if(word[word.size()-1]==\\'b\\')\\n            ans = ans + 1;\\n        \\n        for(int i=0;i<word.size()-1;i++)\\n        {\\n            char c1 = word[i];\\n            char c2 = word[i+1];\\n            \\n            if(c1 == c2)\\n                ans = ans + 2;\\n            if(c1 == \\'a\\' && c2 == \\'c\\' || c1 == \\'b\\' && c2 == \\'a\\' || c1==\\'c\\' && c2 == \\'b\\' )\\n                ans = ans+1;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423633,
                "title": "python-simple-two-pointer-approach",
                "content": "```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:     \\n       s=\\'abc\\'\\n       i=0\\n       j=0\\n       res=0 \\n       while i<len(word):\\n           if j==3:\\n               j=0\\n           if word[i]==s[j]:\\n              i+=1\\n           else:\\n             res+=1   \\n           j+=1        \\n       return res+3-j \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:     \\n       s=\\'abc\\'\\n       i=0\\n       j=0\\n       res=0 \\n       while i<len(word):\\n           if j==3:\\n               j=0\\n           if word[i]==s[j]:\\n              i+=1\\n           else:\\n             res+=1   \\n           j+=1        \\n       return res+3-j \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423014,
                "title": "simple-c-solution",
                "content": "# Intuition + Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nYou just have to increase the index if it matches with the current character you have assigned.\\nAlso change the character according to the needed string ```abc```.\\nThen see the last index of string if it is ```a``` add 2 in cnt if ```b``` add 1 in cnt else add 0 in cnt.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n = word.length(), i = 0; \\n        char c = \\'a\\'; \\n        int cnt = 0; \\n        while(i < n) { \\n            if(word[i] == c) i++; \\n            else cnt++; \\n             \\n            if(c == \\'a\\') c = \\'b\\';\\n            else if(c == \\'b\\') c = \\'c\\';\\n            else c = \\'a\\';\\n        } \\n         \\n         \\n        if(word[n-1] == \\'a\\') cnt += 2;\\n        else if(word[n-1] == \\'b\\') cnt++;\\n         \\n        return cnt; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```abc```\n```a```\n```b```\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n = word.length(), i = 0; \\n        char c = \\'a\\'; \\n        int cnt = 0; \\n        while(i < n) { \\n            if(word[i] == c) i++; \\n            else cnt++; \\n             \\n            if(c == \\'a\\') c = \\'b\\';\\n            else if(c == \\'b\\') c = \\'c\\';\\n            else c = \\'a\\';\\n        } \\n         \\n         \\n        if(word[n-1] == \\'a\\') cnt += 2;\\n        else if(word[n-1] == \\'b\\') cnt++;\\n         \\n        return cnt; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422705,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        k=0\\n        prev=\\'z\\'\\n        for c in word:\\n            k+=c<=prev\\n            prev=c\\n\\n        return k*3-len(word)    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        k=0\\n        prev=\\'z\\'\\n        for c in word:\\n            k+=c<=prev\\n            prev=c\\n\\n        return k*3-len(word)    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422482,
                "title": "simple-stupid-javascript-logic-with-comments-84-ms",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * @param {string} word\\n * @return {number}\\n */\\nvar addMinimum = function(word) {\\n    let result = 0;\\n\\n    for (let i = 0; i < word.length; ++i) {\\n        if (word[i] === \"a\") {\\n            if (word[i + 1] === \"b\" && word[i + 2] === \"c\") i += 2; // we have abc\\n            else if (word[i + 1] === \"b\" || word[i + 1] === \"c\") { // ab or ac only\\n                ++i;\\n                ++result;\\n            } else { // just a\\n                result += 2;\\n            }\\n        } else if (word[i] === \"b\") { // we start from b\\n            ++result;\\n            if (word[i + 1] === \"c\") { // it is bc\\n                ++i;\\n            } else ++result; // just b\\n        } else {\\n            result += 2; // only c\\n        }\\n    }\\n\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} word\\n * @return {number}\\n */\\nvar addMinimum = function(word) {\\n    let result = 0;\\n\\n    for (let i = 0; i < word.length; ++i) {\\n        if (word[i] === \"a\") {\\n            if (word[i + 1] === \"b\" && word[i + 2] === \"c\") i += 2; // we have abc\\n            else if (word[i + 1] === \"b\" || word[i + 1] === \"c\") { // ab or ac only\\n                ++i;\\n                ++result;\\n            } else { // just a\\n                result += 2;\\n            }\\n        } else if (word[i] === \"b\") { // we start from b\\n            ++result;\\n            if (word[i + 1] === \"c\") { // it is bc\\n                ++i;\\n            } else ++result; // just b\\n        } else {\\n            result += 2; // only c\\n        }\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3422428,
                "title": "easy-and-intutive-algorightm-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea here is every character should be valid.\\n\\'a\\' will be valid if \\'b\\' follows it similarly,\\n\\'b\\' will be valid if \\'c\\' follows it and \\n\\'c\\' will be valid if it is last or \\'a\\' follows it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNow when the character is not valid:\\n- when \\'a\\' is followed by \\'a\\'\\nso in this case we will be adding \"bc\" after \\'a\\' i.e performing 2 operations (we are not actully adding in string).\\n- when \\'a\\' is followed by \\'c\\'\\nso in this case we will be adding \"b\" after \\'a\\' i.e performing 1 operation (we are not actully adding in string).\\n- when \\'a is followed by \\'b\\' its already a valid case, so no need to perform any operation. REPEAT SIMILAR STEPS FOR \\'b\\' and \\'c\\'\\n\\n- THE MAIN IDEA HERE IS WE DO NOT WORRY ABOUT PREV CHARCATERS AS THEY ARE ALREADY TAKEN CARE OF.\\n- MEANS PREV CHAR HAS DONE ITS OPERATION AND HAS MADE STRING VALID TILL CURRENT CHAR. \\n- NOTE:we\\'ve to make first letter \\'a\\' in order to begin with algorithm and we have to take care of last char seprately\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int cnt=0;\\n        if(word[0]!=\\'a\\'){\\n            word=\"a\"+word;\\n            cnt++;\\n        }\\n        int n=word.size();\\n        for(int i=0;i<n-1;i++){\\n            if(word[i]==\\'a\\'){\\n                if(word[i+1]==\\'a\\')cnt+=2;\\n                if(word[i+1]==\\'c\\')cnt+=1;\\n            }\\n            if(word[i]==\\'b\\'){\\n                if(word[i+1]==\\'b\\')cnt+=2;\\n                if(word[i+1]==\\'a\\')cnt+=1;\\n            }\\n            if(word[i]==\\'c\\'){\\n                if(word[i+1]==\\'c\\')cnt+=2;\\n                if(word[i+1]==\\'b\\')cnt+=1;\\n            }\\n        }\\n        if(word[n-1]==\\'a\\')cnt+=2;\\n        if(word[n-1]==\\'b\\')cnt+=1;\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int cnt=0;\\n        if(word[0]!=\\'a\\'){\\n            word=\"a\"+word;\\n            cnt++;\\n        }\\n        int n=word.size();\\n        for(int i=0;i<n-1;i++){\\n            if(word[i]==\\'a\\'){\\n                if(word[i+1]==\\'a\\')cnt+=2;\\n                if(word[i+1]==\\'c\\')cnt+=1;\\n            }\\n            if(word[i]==\\'b\\'){\\n                if(word[i+1]==\\'b\\')cnt+=2;\\n                if(word[i+1]==\\'a\\')cnt+=1;\\n            }\\n            if(word[i]==\\'c\\'){\\n                if(word[i+1]==\\'c\\')cnt+=2;\\n                if(word[i+1]==\\'b\\')cnt+=1;\\n            }\\n        }\\n        if(word[n-1]==\\'a\\')cnt+=2;\\n        if(word[n-1]==\\'b\\')cnt+=1;\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422302,
                "title": "easy-and-simple-c-solution",
                "content": "# Approach\\n1. First store the count of abc, ab, bc, ac ,a,b,c patterns in the map.\\n2. And then count the remaining letters from the patterns to make  string \"abc\".\\n3. Then return the no. of count.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string s) {\\n        unordered_map<string,int>mp;\\n        for(int i=0;i<s.size();i++){\\n            string t=\"\";\\n            int ind=s[i]-\\'a\\';\\n            t=t+s[i];\\n            int index=i;\\n            for(int j=i+1;j<index+3 && j<s.size();j++){\\n                \\n                // handle \\'a\\' and then \\'c\\' patterns\\n                  if(s[i]==\\'a\\'&&s[j]-\\'a\\'==ind+2){\\n                    t=t+s[j];\\n                    i++;\\n                    break;\\n                }\\n\\n                //handle \"a\",\"b\",\"c\",\"ab\",\"bc\" and \"abc\" kind of patterns\\n                if(s[j]-\\'a\\'==ind+1){\\n                    t=t+s[j];\\n                    ind++;\\n                    i++;\\n                }else break;\\n            }\\n            mp[t]++;\\n        }\\n        int ans=0;\\n        // And then count remaining letters of different patterns to make \"abc\" string\\n        for(auto it:mp){\\n            if(it.first.size()==3)continue;\\n            else if(it.first.size()==2)ans=ans+it.second;\\n            else ans=ans+(it.second*2);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string s) {\\n        unordered_map<string,int>mp;\\n        for(int i=0;i<s.size();i++){\\n            string t=\"\";\\n            int ind=s[i]-\\'a\\';\\n            t=t+s[i];\\n            int index=i;\\n            for(int j=i+1;j<index+3 && j<s.size();j++){\\n                \\n                // handle \\'a\\' and then \\'c\\' patterns\\n                  if(s[i]==\\'a\\'&&s[j]-\\'a\\'==ind+2){\\n                    t=t+s[j];\\n                    i++;\\n                    break;\\n                }\\n\\n                //handle \"a\",\"b\",\"c\",\"ab\",\"bc\" and \"abc\" kind of patterns\\n                if(s[j]-\\'a\\'==ind+1){\\n                    t=t+s[j];\\n                    ind++;\\n                    i++;\\n                }else break;\\n            }\\n            mp[t]++;\\n        }\\n        int ans=0;\\n        // And then count remaining letters of different patterns to make \"abc\" string\\n        for(auto it:mp){\\n            if(it.first.size()==3)continue;\\n            else if(it.first.size()==2)ans=ans+it.second;\\n            else ans=ans+(it.second*2);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422290,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn add_minimum(word: String) -> i32 {\\n        let words: Vec<char> = word.chars().collect();\\n        let mut dp = vec![2; words.len()];\\n        for i in 1..words.len() {\\n            if words[i] > words[i - 1] {\\n                dp[i] = dp[i - 1] - 1;\\n            } else {\\n                dp[i] = dp[i - 1] + 2;\\n            }\\n        }\\n        dp[dp.len() - 1]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn add_minimum(word: String) -> i32 {\\n        let words: Vec<char> = word.chars().collect();\\n        let mut dp = vec![2; words.len()];\\n        for i in 1..words.len() {\\n            if words[i] > words[i - 1] {\\n                dp[i] = dp[i - 1] - 1;\\n            } else {\\n                dp[i] = dp[i - 1] + 2;\\n            }\\n        }\\n        dp[dp.len() - 1]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3422274,
                "title": "java-easy-o-n-sliding-window-easy-solution",
                "content": "upvote if you like\\n```\\n\\nclass Solution {\\n    public int addMinimum(String word) {\\n        HashMap<String,Integer>map= new HashMap<>();\\n        map.put(\"a\",2);\\n        map.put(\"ab\",1);\\n        map.put(\"ac\",1);\\n        map.put(\"abc\",0);\\n        map.put(\"b\",2);\\n        map.put(\"bc\",1);\\n        map.put(\"c\",2);\\n      //  map.put(\"\",0);\\n        int i=0;\\n       // int k=0;\\n        int sum=0;\\n        String temp=\"\";\\n        int k=0;\\n            while(i<word.length())\\n            {\\n                int l=0;\\n                  temp=word.substring(k,k+1);\\n                while(map.containsKey(temp))\\n                {\\n                    i++;\\n                     if(i==word.length()) \\n                    {\\n                       // temp=word.substring(k,i);\\n                        l++;\\n                        break;\\n                    }\\n                    temp=word.substring(k,i+1);\\n                   \\n                }\\n                if(l>0)\\n                {\\n                    sum+=map.get(temp);\\n                }\\n                else\\n                {\\n                String ans=word.substring(k,i);\\n                    sum+=map.get(ans);\\n                   ;\\n                    k=i;\\n                   \\n                }\\n            }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sliding Window"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int addMinimum(String word) {\\n        HashMap<String,Integer>map= new HashMap<>();\\n        map.put(\"a\",2);\\n        map.put(\"ab\",1);\\n        map.put(\"ac\",1);\\n        map.put(\"abc\",0);\\n        map.put(\"b\",2);\\n        map.put(\"bc\",1);\\n        map.put(\"c\",2);\\n      //  map.put(\"\",0);\\n        int i=0;\\n       // int k=0;\\n        int sum=0;\\n        String temp=\"\";\\n        int k=0;\\n            while(i<word.length())\\n            {\\n                int l=0;\\n                  temp=word.substring(k,k+1);\\n                while(map.containsKey(temp))\\n                {\\n                    i++;\\n                     if(i==word.length()) \\n                    {\\n                       // temp=word.substring(k,i);\\n                        l++;\\n                        break;\\n                    }\\n                    temp=word.substring(k,i+1);\\n                   \\n                }\\n                if(l>0)\\n                {\\n                    sum+=map.get(temp);\\n                }\\n                else\\n                {\\n                String ans=word.substring(k,i);\\n                    sum+=map.get(ans);\\n                   ;\\n                    k=i;\\n                   \\n                }\\n            }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422266,
                "title": "simple-c-solution-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        stack<char> st;\\n        for(int i=0;i<word.size();i++)\\n        {\\n            st.push(word[i]);\\n        }\\n        int count=0;\\n        while(!st.empty())\\n        {\\n            if(!st.empty()&&st.top()==\\'c\\')\\n            st.pop();\\n            else\\n            count++;\\n            if(!st.empty()&&st.top()==\\'b\\'){\\n                      st.pop();\\n            } \\n            else\\n            count++;\\n            if(!st.empty()&&st.top()==\\'a\\')\\n            st.pop();\\n            else\\n            count++;\\n            if(st.empty())\\n            break;\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        stack<char> st;\\n        for(int i=0;i<word.size();i++)\\n        {\\n            st.push(word[i]);\\n        }\\n        int count=0;\\n        while(!st.empty())\\n        {\\n            if(!st.empty()&&st.top()==\\'c\\')\\n            st.pop();\\n            else\\n            count++;\\n            if(!st.empty()&&st.top()==\\'b\\'){\\n                      st.pop();\\n            } \\n            else\\n            count++;\\n            if(!st.empty()&&st.top()==\\'a\\')\\n            st.pop();\\n            else\\n            count++;\\n            if(st.empty())\\n            break;\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422135,
                "title": "simple-and-easy-structured-java-solution",
                "content": "# Approach\\nIn this solution, we check for the following things:\\n```\\n - if element is a, \\n check if it is followed by bc -> ans+0 | \"abc\"\\n if followed by only b or only c -> ans+1 | \"ab\"/\"ac\"\\n if followed by none -> ans+2 | \"a\"\\n\\n - if element is b,\\n  check if it is followed by c -> ans+1 | \"bc\"\\n  else -> ans+2 | \"b\"\\n\\n - if element is c -> ans+2 | \"c\"\\n\\n```\\nNOTE: Conditions for b and c are less because they\\'re already covered in the conditions above them.\\n\\n ALSO: once we\\'ve checked the element is a following one, we do not iterate to it again, Hence, we need to update `i` pointer accordingly.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int ans=0;\\n        for(int i=0;i<word.length();i++){\\n            if(word.charAt(i)==\\'a\\'){\\n                if(i+1<word.length() && word.charAt(i+1)==\\'b\\'){\\n                    if(i+2<word.length() && word.charAt(i+2)==\\'c\\')\\n                        i+=2;\\n                    else{\\n                        ans++;\\n                        i++;\\n                    }\\n                }\\n                else if(i+1<word.length() && word.charAt(i+1)==\\'c\\'){\\n                    ans++;\\n                    i++;\\n                }\\n                else\\n                    ans+=2;\\n            }\\n            else if(word.charAt(i)==\\'b\\'){\\n                if(i+1<word.length() && word.charAt(i+1)==\\'c\\'){\\n                    ans++;\\n                    i++;\\n                }\\n                else{\\n                    ans+=2;\\n                }\\n            }\\n            else\\n                ans+=2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n - if element is a, \\n check if it is followed by bc -> ans+0 | \"abc\"\\n if followed by only b or only c -> ans+1 | \"ab\"/\"ac\"\\n if followed by none -> ans+2 | \"a\"\\n\\n - if element is b,\\n  check if it is followed by c -> ans+1 | \"bc\"\\n  else -> ans+2 | \"b\"\\n\\n - if element is c -> ans+2 | \"c\"\\n\\n```\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int ans=0;\\n        for(int i=0;i<word.length();i++){\\n            if(word.charAt(i)==\\'a\\'){\\n                if(i+1<word.length() && word.charAt(i+1)==\\'b\\'){\\n                    if(i+2<word.length() && word.charAt(i+2)==\\'c\\')\\n                        i+=2;\\n                    else{\\n                        ans++;\\n                        i++;\\n                    }\\n                }\\n                else if(i+1<word.length() && word.charAt(i+1)==\\'c\\'){\\n                    ans++;\\n                    i++;\\n                }\\n                else\\n                    ans+=2;\\n            }\\n            else if(word.charAt(i)==\\'b\\'){\\n                if(i+1<word.length() && word.charAt(i+1)==\\'c\\'){\\n                    ans++;\\n                    i++;\\n                }\\n                else{\\n                    ans+=2;\\n                }\\n            }\\n            else\\n                ans+=2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422078,
                "title": "c-easy-intuitive-approach-generalized-for-string-length-abc-but-in-lex-order",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nKeep string \"abc\" and match somehow \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nKeep given string w=\"abc\"\\nand at index i, string matching it with w\\nsuppose matching at \\n\"abc\"\\n\\n\"a b b c c a a c\"\\n 0 1 2 3 4 5 6 7\\na matches with a, we increment both counters, b matches with b, again increment, but b and c does not match, so we **determine the count**=2 matched characters.\\n\\nNext **directly move to 2nd index** as 1st index is already included in previous match \\n\\nNow, we are not only incrementing counters when character of w matches with word, but when character of word is **greater than w\\'s character also**,\\n\\n**word[j]>=w[k]**\\n\\nConsider next iteration\\nwe get after matching \"bc\"\\nwe only have to add \"a\" to it.\\n\\nanother example at 6th index, we will get \"ac\" after matching as\\na matched with a \\nb matched with c as **c>=b**\\n\\nHere we only have to insert \"a\" in between.\\n\\n **Also consider,** \\nthe condition word[j]>=w[k] might repeat characters, as \\n\\nabc will get matched with \"bb\" as\\na with b as b>=a\\nb with b as b>=b\\n\\nabc will get matched with \"cb\" as\\na with c as c>=a\\nb with b as b>=b\\n\\nwhich is **wrong**\\nSo make sure while matching,\\n1. **same character does not gets repeated** \\n2. **they do not get matched in decreasing order**\\n\\ntherefore I added the condition :  if(j>i && word[j-1]>=word[j]) break;\\n\\nOnce determined the count at an iteration, subtract it with length of \"abc\" and add it to final Answer\\n\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        string w=\"abc\";\\n        int ans=0;\\n        for(int i=0;i<word.size();i++){\\n            int j=i;\\n            int k=0;\\n            \\n            while(j<word.size() && k<3 && word[j]>=w[k]){\\n                if(j>i && word[j-1]>=word[j]) break;\\n                j++;\\n                k++;\\n            }\\n            int cnt=j-i;\\n            if(j-i<=1) ans+=2;\\n            else if(j-i==2) ans+=1;\\n            if(j>i+1) i=j-1;\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        string w=\"abc\";\\n        int ans=0;\\n        for(int i=0;i<word.size();i++){\\n            int j=i;\\n            int k=0;\\n            \\n            while(j<word.size() && k<3 && word[j]>=w[k]){\\n                if(j>i && word[j-1]>=word[j]) break;\\n                j++;\\n                k++;\\n            }\\n            int cnt=j-i;\\n            if(j-i<=1) ans+=2;\\n            else if(j-i==2) ans+=1;\\n            if(j>i+1) i=j-1;\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421993,
                "title": "c-o-n-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int count=0;\\n        int n=word.size();\\n        if(n==1)\\n        {\\n            return 2;\\n        }\\n     \\n        for(int i=0;i<n;i++)\\n        {   \\n            \\n            if(i==n-1 && i>=1)\\n            {\\n                if(word[i]==\\'a\\')\\n                {\\n                  count+=2;\\n                    continue;\\n                }\\n                else if(word[i]==\\'b\\')\\n                {\\n                   count+=1;\\n                }\\n            \\n                    \\n            }\\n            else{\\n            if(word[i]==\\'a\\')\\n            {\\n                if(word[i+1]==\\'a\\')count+=2;\\n                else if(word[i+1]==\\'b\\')continue;\\n                else if(word[i+1]==\\'c\\')count+=1;\\n                //cout<<\"yes\"<<endl;\\n            }\\n            if(word[i]==\\'b\\')\\n            {\\n                if(i==0)\\n                {\\n                    if(word[i+1]==\\'c\\')count+=1;\\n                    else if(word[i+1]==\\'b\\')count+=3;\\n                    else if(word[i+1]==\\'a\\')count+=2;\\n                }\\n                else if(i>0)\\n                {\\n                    if(word[i]==\\'c\\')continue;\\n                    else if(word[i+1]==\\'b\\')count+=2;\\n                    else if(word[i+1]==\\'a\\')count+=1;\\n                }\\n            }\\n            if(word[i]==\\'c\\')\\n            {\\n                if(i==0)\\n                {\\n                    if(word[i+1]==\\'a\\')count+=2;\\n                    else if(word[i+1]==\\'b\\')count+=3;\\n                    else if(word[i+1]==\\'c\\')count+=4;\\n                }\\n                else if(i>0)\\n                {\\n                    if(word[i+1]==\\'a\\')continue;\\n                    else if(word[i+1]==\\'b\\')count+=1;\\n                    else if(word[i+1]==\\'c\\')count+=2;\\n                }\\n            }\\n            \\n        }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int count=0;\\n        int n=word.size();\\n        if(n==1)\\n        {\\n            return 2;\\n        }\\n     \\n        for(int i=0;i<n;i++)\\n        {   \\n            \\n            if(i==n-1 && i>=1)\\n            {\\n                if(word[i]==\\'a\\')\\n                {\\n                  count+=2;\\n                    continue;\\n                }\\n                else if(word[i]==\\'b\\')\\n                {\\n                   count+=1;\\n                }\\n            \\n                    \\n            }\\n            else{\\n            if(word[i]==\\'a\\')\\n            {\\n                if(word[i+1]==\\'a\\')count+=2;\\n                else if(word[i+1]==\\'b\\')continue;\\n                else if(word[i+1]==\\'c\\')count+=1;\\n                //cout<<\"yes\"<<endl;\\n            }\\n            if(word[i]==\\'b\\')\\n            {\\n                if(i==0)\\n                {\\n                    if(word[i+1]==\\'c\\')count+=1;\\n                    else if(word[i+1]==\\'b\\')count+=3;\\n                    else if(word[i+1]==\\'a\\')count+=2;\\n                }\\n                else if(i>0)\\n                {\\n                    if(word[i]==\\'c\\')continue;\\n                    else if(word[i+1]==\\'b\\')count+=2;\\n                    else if(word[i+1]==\\'a\\')count+=1;\\n                }\\n            }\\n            if(word[i]==\\'c\\')\\n            {\\n                if(i==0)\\n                {\\n                    if(word[i+1]==\\'a\\')count+=2;\\n                    else if(word[i+1]==\\'b\\')count+=3;\\n                    else if(word[i+1]==\\'c\\')count+=4;\\n                }\\n                else if(i>0)\\n                {\\n                    if(word[i+1]==\\'a\\')continue;\\n                    else if(word[i+1]==\\'b\\')count+=1;\\n                    else if(word[i+1]==\\'c\\')count+=2;\\n                }\\n            }\\n            \\n        }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3421970,
                "title": "c-solutions-beginner-friendly-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        char now=\\'a\\';\\n        int ans=0;\\n        for(auto it:word){\\n            while(now!=it){\\n                ans++;\\n                now=now+1;\\n                if(now==\\'d\\')now=\\'a\\';\\n            }\\n            now=now+1;\\n            if(now==\\'d\\')now=\\'a\\';\\n        }\\n        while(now!=\\'a\\'){\\n            ans++;\\n            now=now+1;\\n            if(now==\\'d\\')now=\\'a\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        char now=\\'a\\';\\n        int ans=0;\\n        for(auto it:word){\\n            while(now!=it){\\n                ans++;\\n                now=now+1;\\n                if(now==\\'d\\')now=\\'a\\';\\n            }\\n            now=now+1;\\n            if(now==\\'d\\')now=\\'a\\';\\n        }\\n        while(now!=\\'a\\'){\\n            ans++;\\n            now=now+1;\\n            if(now==\\'d\\')now=\\'a\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421926,
                "title": "c-stack-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string w) {\\n        int cnt=0;\\n        map<char, int>m;\\n        for(int i=0; i<w.size(); i++){\\n            m[w[i]]++;\\n        }\\n        if(w.size()==1){return 2;}\\n        if(w.size()==2){\\n            if(m.size()==1){\\n                return 4;\\n            }\\n            else{\\n                if(w[0]>w[1]){\\n                    return 4;\\n                }\\n                else{\\n                    return 1;\\n                }\\n            }\\n        }\\n        stack<char>s;\\n        for(int i=0; i<w.size(); i++){\\n            if(s.empty()){\\n                if(w[i]==\\'a\\'){\\n                    s.push(w[i]);\\n                }\\n                else if(w[i]==\\'b\\'){\\n                    cnt++;\\n                    s.push(w[i]);\\n                }\\n                else{\\n                    cnt+=2;\\n                }\\n            }\\n            else{\\n                if(w[i]-s.top()==2){\\n                    cnt++;\\n                    s.pop();\\n                }\\n                else if(w[i]-s.top()==1){\\n                    s.push(w[i]);\\n                    if(w[i]==\\'c\\'){\\n                        while(!s.empty()){s.pop();}\\n                    }\\n                }\\n                else if(w[i]-s.top()==0){\\n                    cnt+=2;\\n                    while(!s.empty()){s.pop();}\\n                    s.push(w[i]);\\n                }\\n                else{\\n                    cnt++;\\n                    while(!s.empty()){\\n                        s.pop();\\n                    }\\n                    s.push(w[i]);\\n                }\\n            }\\n        }\\n        cout<<cnt<<endl;\\n        if(!s.empty()){\\n            cout<<s.top()<<endl;\\n            if(s.top()==\\'a\\'){cnt+=2;}\\n            else if(s.top()==\\'b\\'){cnt++;}\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string w) {\\n        int cnt=0;\\n        map<char, int>m;\\n        for(int i=0; i<w.size(); i++){\\n            m[w[i]]++;\\n        }\\n        if(w.size()==1){return 2;}\\n        if(w.size()==2){\\n            if(m.size()==1){\\n                return 4;\\n            }\\n            else{\\n                if(w[0]>w[1]){\\n                    return 4;\\n                }\\n                else{\\n                    return 1;\\n                }\\n            }\\n        }\\n        stack<char>s;\\n        for(int i=0; i<w.size(); i++){\\n            if(s.empty()){\\n                if(w[i]==\\'a\\'){\\n                    s.push(w[i]);\\n                }\\n                else if(w[i]==\\'b\\'){\\n                    cnt++;\\n                    s.push(w[i]);\\n                }\\n                else{\\n                    cnt+=2;\\n                }\\n            }\\n            else{\\n                if(w[i]-s.top()==2){\\n                    cnt++;\\n                    s.pop();\\n                }\\n                else if(w[i]-s.top()==1){\\n                    s.push(w[i]);\\n                    if(w[i]==\\'c\\'){\\n                        while(!s.empty()){s.pop();}\\n                    }\\n                }\\n                else if(w[i]-s.top()==0){\\n                    cnt+=2;\\n                    while(!s.empty()){s.pop();}\\n                    s.push(w[i]);\\n                }\\n                else{\\n                    cnt++;\\n                    while(!s.empty()){\\n                        s.pop();\\n                    }\\n                    s.push(w[i]);\\n                }\\n            }\\n        }\\n        cout<<cnt<<endl;\\n        if(!s.empty()){\\n            cout<<s.top()<<endl;\\n            if(s.top()==\\'a\\'){cnt+=2;}\\n            else if(s.top()==\\'b\\'){cnt++;}\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3421918,
                "title": "one-pass-c-easy-to-understand",
                "content": "````\\nclass Solution {\\npublic:\\n    int addMinimum(string str) {\\n        int a = 0, b = 0, c = 0, ans = 0;\\n        int i = 0, n = str.length();\\n        if(n==1)return 2;\\n        for(i = 0; i < n; i++){\\n            if(str[i]==\\'a\\'){\\n                if(i+1<n&&str[i+1]==\\'b\\'){\\n                    if(i+2<n&&str[i+2]==\\'c\\'){\\n                        i++;\\n                    }else{\\n                        ans++;\\n                    }\\n                    i++;\\n                }else if(i+1<n&&str[i+1]==\\'a\\'){\\n                    ans += 2;\\n                }else if(i+1<n&&str[i+1]==\\'c\\'){\\n                    ans++;\\n                    i++;\\n                }\\n                else{\\n                    ans += 2;\\n                }\\n            }else if(str[i]==\\'b\\'){\\n                if(i+1<n&&str[i+1]==\\'c\\'){\\n                    ans++;\\n                    i++;\\n                }else if(i+1<n&&str[i+1]!=\\'c\\'){\\n                    ans += 2;\\n                }else{\\n                    ans += 2;\\n                }\\n            }else if(str[i]==\\'c\\'){\\n                ans += 2;\\n            }\\n            cout<<ans<<\" \";\\n        }\\n        // if(str[n-1]==\\'a\\')ans += 2;\\n        // if(n-2>=0&&str[n-1]==\\'b\\'&&str[n-2]==\\'a\\')ans++;\\n        // if(n-2>=0&&str[n-1]==\\'b\\'&&str[n-2]!=\\'a\\')ans += 2;\\n        // if(n-2>0&&str[n-1]==\\'c\\'&&str[n-2]!=\\'c\\')ans += 2;\\n            return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int addMinimum(string str) {\\n        int a = 0, b = 0, c = 0, ans = 0;\\n        int i = 0, n = str.length();\\n        if(n==1)return 2;\\n        for(i = 0; i < n; i++){\\n            if(str[i]==\\'a\\'){\\n                if(i+1<n&&str[i+1]==\\'b\\'){\\n                    if(i+2<n&&str[i+2]==\\'c\\'){\\n                        i++;\\n                    }else{\\n                        ans++;\\n                    }\\n                    i++;\\n                }else if(i+1<n&&str[i+1]==\\'a\\'){\\n                    ans += 2;\\n                }else if(i+1<n&&str[i+1]==\\'c\\'){\\n                    ans++;\\n                    i++;\\n                }\\n                else{\\n                    ans += 2;\\n                }\\n            }else if(str[i]==\\'b\\'){\\n                if(i+1<n&&str[i+1]==\\'c\\'){\\n                    ans++;\\n                    i++;\\n                }else if(i+1<n&&str[i+1]!=\\'c\\'){\\n                    ans += 2;\\n                }else{\\n                    ans += 2;\\n                }\\n            }else if(str[i]==\\'c\\'){\\n                ans += 2;\\n            }\\n            cout<<ans<<\" \";\\n        }\\n        // if(str[n-1]==\\'a\\')ans += 2;\\n        // if(n-2>=0&&str[n-1]==\\'b\\'&&str[n-2]==\\'a\\')ans++;\\n        // if(n-2>=0&&str[n-1]==\\'b\\'&&str[n-2]!=\\'a\\')ans += 2;\\n        // if(n-2>0&&str[n-1]==\\'c\\'&&str[n-2]!=\\'c\\')ans += 2;\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3421870,
                "title": "easy-to-understand-c",
                "content": "\\n\\n\\n# Approach\\nFirst we will look for \\'a\\' and if it is found we will look for further \\'b\\' and \\'c\\'. If \\'b\\' is found on next index we will increment our temp by 1 and also if \\'c\\' is also found on next to next index again we will increment temp by 1.\\n\\nSimilarly if \\'b\\' is found we will look for \\'c\\' and if \\'c\\' is found on next index we will increment temp by 1.\\n\\nFor \\'c\\' there is no need for looking for any character.\\n\\nadd+= (3-temp) in every if else gives required additions we need to perform\\n\\n# Complexity\\n- Time complexity:\\nO(N)  --> N is length of string\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        \\n        int add=0;\\n        \\n        for(int i=0; i<word.size(); i++){\\n\\n            if(word[i]==\\'a\\'){\\n\\n                int temp=1;\\n\\n                if(i+1<word.size() && word[i+1]==\\'b\\'){\\n                    temp++;\\n                    i++;\\n\\n                    if (i+1<word.size() && word[i+1]==\\'c\\')\\n                    {\\n                        temp++;\\n                        i++;\\n                    }\\n                    \\n                }\\n                else if(i+1<word.size() && word[i+1]==\\'c\\'){\\n                    temp++;\\n                    i++;\\n                }\\n                \\n\\n                add+=3-temp;\\n            }\\n\\n            else if (word[i]==\\'b\\')\\n            {\\n                int temp=1;\\n\\n                if(i+1<word.size() && word[i+1]==\\'c\\'){\\n                    temp++;\\n                    i++;\\n                }\\n\\n                add+=3-temp;\\n            }\\n\\n            else if(word[i]==\\'c\\'){\\n                int temp=1;\\n\\n                add+=3-temp;\\n            }\\n            \\n        }\\n\\n        return add;\\n\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        \\n        int add=0;\\n        \\n        for(int i=0; i<word.size(); i++){\\n\\n            if(word[i]==\\'a\\'){\\n\\n                int temp=1;\\n\\n                if(i+1<word.size() && word[i+1]==\\'b\\'){\\n                    temp++;\\n                    i++;\\n\\n                    if (i+1<word.size() && word[i+1]==\\'c\\')\\n                    {\\n                        temp++;\\n                        i++;\\n                    }\\n                    \\n                }\\n                else if(i+1<word.size() && word[i+1]==\\'c\\'){\\n                    temp++;\\n                    i++;\\n                }\\n                \\n\\n                add+=3-temp;\\n            }\\n\\n            else if (word[i]==\\'b\\')\\n            {\\n                int temp=1;\\n\\n                if(i+1<word.size() && word[i+1]==\\'c\\'){\\n                    temp++;\\n                    i++;\\n                }\\n\\n                add+=3-temp;\\n            }\\n\\n            else if(word[i]==\\'c\\'){\\n                int temp=1;\\n\\n                add+=3-temp;\\n            }\\n            \\n        }\\n\\n        return add;\\n\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421798,
                "title": "python-saving-last-seen-letter",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def addMinimum(self, word):\\n        \"\"\"\\n        :type word: str\\n        :rtype: int\\n        \"\"\"\\n        last = \"c\"\\n        res = 0\\n        \\n        for letter in word:\\n            if letter == \"a\":\\n                if last != \"c\":\\n                    if last == \"a\":\\n                        res += 2\\n                    else:\\n                        res += 1\\n            elif letter == \"b\":\\n                if last != \"a\":\\n                    if last == \"b\":\\n                        res += 2\\n                    else:\\n                        res += 1\\n            else:\\n                if last != \"b\":\\n                    if last == \"c\":\\n                        res += 2\\n                    else:\\n                        res += 1\\n            last = letter\\n        \\n        if last == \"a\":\\n            res += 2\\n        elif last == \"b\":\\n            res += 1\\n        \\n        return res\\n        \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def addMinimum(self, word):\\n        \"\"\"\\n        :type word: str\\n        :rtype: int\\n        \"\"\"\\n        last = \"c\"\\n        res = 0\\n        \\n        for letter in word:\\n            if letter == \"a\":\\n                if last != \"c\":\\n                    if last == \"a\":\\n                        res += 2\\n                    else:\\n                        res += 1\\n            elif letter == \"b\":\\n                if last != \"a\":\\n                    if last == \"b\":\\n                        res += 2\\n                    else:\\n                        res += 1\\n            else:\\n                if last != \"b\":\\n                    if last == \"c\":\\n                        res += 2\\n                    else:\\n                        res += 1\\n            last = letter\\n        \\n        if last == \"a\":\\n            res += 2\\n        elif last == \"b\":\\n            res += 1\\n        \\n        return res\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421723,
                "title": "java-two-pointers-o-n",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n``` java []\\nclass Solution {\\n    public int addMinimum(String word) {\\n         int c=0;\\n         char[] m = {\\'a\\',\\'b\\',\\'c\\'};\\n         int i=0, j=0;\\n         while(i<word.length()){\\n             if(word.charAt(i)==m[j%3]){\\n                 i++;\\n             }\\n             else{\\n                 c++;\\n             }\\n             j++;\\n         }\\n         char last = (word.charAt(word.length()-1));\\n         if(last==\\'a\\'){\\n             return c+2;\\n         }\\n         if(last==\\'b\\'){\\n            return c+1;\\n         }\\n         return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int addMinimum(String word) {\\n         int c=0;\\n         char[] m = {\\'a\\',\\'b\\',\\'c\\'};\\n         int i=0, j=0;\\n         while(i<word.length()){\\n             if(word.charAt(i)==m[j%3]){\\n                 i++;\\n             }\\n             else{\\n                 c++;\\n             }\\n             j++;\\n         }\\n         char last = (word.charAt(word.length()-1));\\n         if(last==\\'a\\'){\\n             return c+2;\\n         }\\n         if(last==\\'b\\'){\\n            return c+1;\\n         }\\n         return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421706,
                "title": "python3-one-pass-o-n-clean-concise",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        n = len(word)\\n        ans, curr = 0, 1\\n        for i in range(n):\\n            if i + 1 < n and word[i] < word[i + 1]:\\n                curr += 1\\n            else:\\n                ans += 3 - curr\\n                curr = 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        n = len(word)\\n        ans, curr = 0, 1\\n        for i in range(n):\\n            if i + 1 < n and word[i] < word[i + 1]:\\n                curr += 1\\n            else:\\n                ans += 3 - curr\\n                curr = 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421703,
                "title": "10-line-simple-python-solution-two-pointers",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:        \\n        s = \"abc\"\\n        i,j,count = 0, 0, 0\\n        while j < len(word) :\\n            if i == 3 :\\n                i = 0\\n            if word[j] != s[i] :\\n                count += 1\\n            else :\\n                j += 1\\n            i += 1\\n        return count + (3-i)\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:        \\n        s = \"abc\"\\n        i,j,count = 0, 0, 0\\n        while j < len(word) :\\n            if i == 3 :\\n                i = 0\\n            if word[j] != s[i] :\\n                count += 1\\n            else :\\n                j += 1\\n            i += 1\\n        return count + (3-i)\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421699,
                "title": "easy-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        if(word.length() == 1)\\n        {\\n            return 2;\\n        }\\n        int count = 0;\\n        for(int i = 0; i < word.length(); i++)\\n        {\\n            if(i != word.length()-1)\\n            {\\n                if(word[i] == \\'a\\' && word[i+1] == \\'b\\')\\n                {\\n\\n                }\\n                else if(word[i] == \\'b\\' && word[i+1] == \\'c\\')\\n                {\\n                    if(i == 0)\\n                    {\\n                        count++;\\n                    }\\n                }\\n                else if(word[i] == \\'a\\' && word[i+1] == \\'c\\')\\n                {\\n                    count++;\\n                }\\n                else if(word[i] == \\'b\\' && word[i+1] == \\'a\\')\\n                {\\n                    if(i == 0)\\n                    {\\n                        count = count + 2;\\n                    }\\n                    else\\n                    {\\n                        count++;\\n                    }            \\n                }\\n                else if(word[i] == \\'c\\' && word[i+1] == \\'b\\')\\n                {\\n                    if(i == 0)\\n                    {\\n                        count = count + 3;\\n                    }\\n                    else\\n                    {\\n                        count++;\\n                    }\\n                }\\n                else if(word[i] == \\'c\\' && word[i+1] == \\'a\\')\\n                {\\n                    if(i == 0)\\n                    {\\n                        count = count + 2;\\n                    }\\n                    else\\n                    {\\n                        \\n                    }\\n                }\\n                else if(word[i] == \\'a\\' && word[i+1] == \\'a\\')\\n                {\\n                    count = count + 2;\\n                }\\n                else if(word[i] == \\'b\\' && word[i+1] == \\'b\\')\\n                {\\n                    if(i == 0)\\n                    {\\n                        count = count + 3;\\n                    }\\n                    else\\n                    {\\n                        count = count + 2;\\n                    }\\n                    \\n                }\\n                else if(word[i] == \\'c\\' && word[i+1] == \\'c\\')\\n                {\\n                    if(i == 0)\\n                    {\\n                        count = count + 4;\\n                    }\\n                    else\\n                    {\\n                        count = count + 2;\\n                    }\\n                    \\n                }\\n            }\\n            else\\n            {\\n                if(word[i] == \\'a\\')\\n                {\\n                    count = count+2;\\n                }\\n                else if(word[i] == \\'b\\')\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        if(word.length() == 1)\\n        {\\n            return 2;\\n        }\\n        int count = 0;\\n        for(int i = 0; i < word.length(); i++)\\n        {\\n            if(i != word.length()-1)\\n            {\\n                if(word[i] == \\'a\\' && word[i+1] == \\'b\\')\\n                {\\n\\n                }\\n                else if(word[i] == \\'b\\' && word[i+1] == \\'c\\')\\n                {\\n                    if(i == 0)\\n                    {\\n                        count++;\\n                    }\\n                }\\n                else if(word[i] == \\'a\\' && word[i+1] == \\'c\\')\\n                {\\n                    count++;\\n                }\\n                else if(word[i] == \\'b\\' && word[i+1] == \\'a\\')\\n                {\\n                    if(i == 0)\\n                    {\\n                        count = count + 2;\\n                    }\\n                    else\\n                    {\\n                        count++;\\n                    }            \\n                }\\n                else if(word[i] == \\'c\\' && word[i+1] == \\'b\\')\\n                {\\n                    if(i == 0)\\n                    {\\n                        count = count + 3;\\n                    }\\n                    else\\n                    {\\n                        count++;\\n                    }\\n                }\\n                else if(word[i] == \\'c\\' && word[i+1] == \\'a\\')\\n                {\\n                    if(i == 0)\\n                    {\\n                        count = count + 2;\\n                    }\\n                    else\\n                    {\\n                        \\n                    }\\n                }\\n                else if(word[i] == \\'a\\' && word[i+1] == \\'a\\')\\n                {\\n                    count = count + 2;\\n                }\\n                else if(word[i] == \\'b\\' && word[i+1] == \\'b\\')\\n                {\\n                    if(i == 0)\\n                    {\\n                        count = count + 3;\\n                    }\\n                    else\\n                    {\\n                        count = count + 2;\\n                    }\\n                    \\n                }\\n                else if(word[i] == \\'c\\' && word[i+1] == \\'c\\')\\n                {\\n                    if(i == 0)\\n                    {\\n                        count = count + 4;\\n                    }\\n                    else\\n                    {\\n                        count = count + 2;\\n                    }\\n                    \\n                }\\n            }\\n            else\\n            {\\n                if(word[i] == \\'a\\')\\n                {\\n                    count = count+2;\\n                }\\n                else if(word[i] == \\'b\\')\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421691,
                "title": "c-o-n-6-simple-condition",
                "content": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int ans=0,x=0;\\n        int i=0;\\n        while(i<word.size()){\\n            if(x==0 && word[i]==\\'a\\') i+=1;\\n            else if(x==0 && word[i]!=\\'a\\') ans+=1;\\n            else if(x==1 && word[i]==\\'b\\') i+=1;\\n            else if(x==1 && word[i]!=\\'b\\') ans+=1;\\n            else if(x==2 && word[i]==\\'c\\') i+=1;\\n            else if(x==2 && word[i]!=\\'c\\') ans+=1;\\n            x = (x+1)%3;\\n        }\\n        if(x!=0) ans += (3-x);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int ans=0,x=0;\\n        int i=0;\\n        while(i<word.size()){\\n            if(x==0 && word[i]==\\'a\\') i+=1;\\n            else if(x==0 && word[i]!=\\'a\\') ans+=1;\\n            else if(x==1 && word[i]==\\'b\\') i+=1;\\n            else if(x==1 && word[i]!=\\'b\\') ans+=1;\\n            else if(x==2 && word[i]==\\'c\\') i+=1;\\n            else if(x==2 && word[i]!=\\'c\\') ans+=1;\\n            x = (x+1)%3;\\n        }\\n        if(x!=0) ans += (3-x);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088680,
                "title": "2-methods-minimum-additions-to-make-valid-string-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# 1. Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple Traversal of the given string\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int i, count=0;\\n\\n        for(i=0 ; i<word.length() ; i++)\\n        {\\n            if(word[i]==\\'a\\')\\n            {\\n                if(i<word.length()-1)\\n                {\\n                    if(word[i+1]==\\'a\\')\\n                        count += 2;\\n                    else if(word[i+1]==\\'c\\')\\n                        count++;\\n                }\\n                else\\n                    count += 2;\\n            }\\n            else if(word[i]==\\'b\\')\\n            {\\n                if(i>0 && i<word.length()-1)\\n                {\\n                    if(word[i-1]!=\\'a\\')\\n                        count++;\\n                    if(word[i+1]!=\\'c\\')\\n                        count++;\\n                }\\n                else\\n                {\\n                    if(i==0 && i==word.length()-1)\\n                        count += 2;\\n                    else if(i==0 && i<word.length()-1 && word[i+1]!=\\'c\\')\\n                        count += 2;\\n                    else if(i==0 && i<word.length()-1 && word[i+1]==\\'c\\')\\n                        count += 1;\\n                    else if(i>0 && i==word.length()-1 && word[i-1]!=\\'a\\')\\n                        count += 2;\\n                    else if(i>0 && i==word.length()-1 && word[i-1]==\\'a\\')\\n                        count += 1;\\n                }\\n            }\\n            else if(word[i]==\\'c\\')\\n            {\\n                if(i>0)\\n                {\\n                    if(word[i-1]==\\'c\\')\\n                        count += 2;\\n                }\\n                else\\n                    count += 2;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n# 2. Approach\\n<!-- Describe your approach to solving the problem. -->\\nOptimum Approach\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int i=0, ans=0;\\n        while(i<word.size())\\n        {\\n            if(word[i]==\\'a\\')\\n                i++;\\n            else\\n                ans++;\\n            if(word[i]==\\'b\\')\\n                i++;\\n            else\\n                ans++;\\n            if(word[i]==\\'c\\')\\n                i++;\\n            else\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/b4ee092c-6ff8-43c2-acb2-b6d398639553_1695646639.0620859.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int i, count=0;\\n\\n        for(i=0 ; i<word.length() ; i++)\\n        {\\n            if(word[i]==\\'a\\')\\n            {\\n                if(i<word.length()-1)\\n                {\\n                    if(word[i+1]==\\'a\\')\\n                        count += 2;\\n                    else if(word[i+1]==\\'c\\')\\n                        count++;\\n                }\\n                else\\n                    count += 2;\\n            }\\n            else if(word[i]==\\'b\\')\\n            {\\n                if(i>0 && i<word.length()-1)\\n                {\\n                    if(word[i-1]!=\\'a\\')\\n                        count++;\\n                    if(word[i+1]!=\\'c\\')\\n                        count++;\\n                }\\n                else\\n                {\\n                    if(i==0 && i==word.length()-1)\\n                        count += 2;\\n                    else if(i==0 && i<word.length()-1 && word[i+1]!=\\'c\\')\\n                        count += 2;\\n                    else if(i==0 && i<word.length()-1 && word[i+1]==\\'c\\')\\n                        count += 1;\\n                    else if(i>0 && i==word.length()-1 && word[i-1]!=\\'a\\')\\n                        count += 2;\\n                    else if(i>0 && i==word.length()-1 && word[i-1]==\\'a\\')\\n                        count += 1;\\n                }\\n            }\\n            else if(word[i]==\\'c\\')\\n            {\\n                if(i>0)\\n                {\\n                    if(word[i-1]==\\'c\\')\\n                        count += 2;\\n                }\\n                else\\n                    count += 2;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int i=0, ans=0;\\n        while(i<word.size())\\n        {\\n            if(word[i]==\\'a\\')\\n                i++;\\n            else\\n                ans++;\\n            if(word[i]==\\'b\\')\\n                i++;\\n            else\\n                ans++;\\n            if(word[i]==\\'c\\')\\n                i++;\\n            else\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4087932,
                "title": "basic-approach-with-70-using-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        string=\\'abc\\'\\n        count=0\\n        i=0\\n        if not word:\\n            return count\\n        count+=string.index(word[i])\\n        index=0\\n        while i<len(word)-1:\\n            index=string.index(word[i])\\n            next_index=(index+1)%3\\n            if string[next_index]!=word[i+1]:\\n                count+=1\\n                word=word[:i+1]+string[next_index]+word[i+1:]\\n            i+=1\\n        if word[-1]==\\'a\\':\\n            count+=2\\n        elif word[-1]==\\'b\\':\\n            count+=1\\n        return count\\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        string=\\'abc\\'\\n        count=0\\n        i=0\\n        if not word:\\n            return count\\n        count+=string.index(word[i])\\n        index=0\\n        while i<len(word)-1:\\n            index=string.index(word[i])\\n            next_index=(index+1)%3\\n            if string[next_index]!=word[i+1]:\\n                count+=1\\n                word=word[:i+1]+string[next_index]+word[i+1:]\\n            i+=1\\n        if word[-1]==\\'a\\':\\n            count+=2\\n        elif word[-1]==\\'b\\':\\n            count+=1\\n        return count\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074813,
                "title": "c-simple-solution-in-one-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTravesring string and checking for requirement\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTraversing the string and checking if \\'abc\\' is there, go to i+3 index. If \\'ab\\' or \\'ac\\' or \\'bc\\' is there, increment ans by 1 and go to i+2 index. if none of them is there then we need to increment ans by 2 and go to i+1 index.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int ans = 0;\\n        for(int i=0;i<word.length();i++)\\n        {\\n            if(i+2<word.size() && word[i]==\\'a\\' && word[i+1]==\\'b\\' && word[i+2]==\\'c\\')\\n            {\\n                i+=2;\\n                continue;\\n            }\\n            else\\n            {\\n                if(i+1 < word.size() && word[i]==\\'a\\' && word[i+1]==\\'b\\')\\n                {\\n                    ans++;\\n                    i++;\\n                }\\n                else if(i+1 < word.size() && word[i]==\\'a\\' && word[i+1]==\\'c\\')\\n                {\\n                    ans++;\\n                    i++;\\n                }\\n                else if(i+1 < word.size() && word[i]==\\'b\\' && word[i+1]==\\'c\\')\\n                {\\n                    ans++;\\n                    i++;\\n                }\\n                else\\n                {\\n                    ans+=2;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease upvote if you liked solution",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int ans = 0;\\n        for(int i=0;i<word.length();i++)\\n        {\\n            if(i+2<word.size() && word[i]==\\'a\\' && word[i+1]==\\'b\\' && word[i+2]==\\'c\\')\\n            {\\n                i+=2;\\n                continue;\\n            }\\n            else\\n            {\\n                if(i+1 < word.size() && word[i]==\\'a\\' && word[i+1]==\\'b\\')\\n                {\\n                    ans++;\\n                    i++;\\n                }\\n                else if(i+1 < word.size() && word[i]==\\'a\\' && word[i+1]==\\'c\\')\\n                {\\n                    ans++;\\n                    i++;\\n                }\\n                else if(i+1 < word.size() && word[i]==\\'b\\' && word[i+1]==\\'c\\')\\n                {\\n                    ans++;\\n                    i++;\\n                }\\n                else\\n                {\\n                    ans+=2;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054576,
                "title": "python3-solution-beginner-friendly",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        s = [\"a\", \"b\", \"c\"]\\n        i, count = 0, 0\\n        while i < len(word):\\n            for char in s:\\n                if i < len(word) and char == word[i]:\\n                    i += 1\\n                else:\\n                    count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        s = [\"a\", \"b\", \"c\"]\\n        i, count = 0, 0\\n        while i < len(word):\\n            for char in s:\\n                if i < len(word) and char == word[i]:\\n                    i += 1\\n                else:\\n                    count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050111,
                "title": "2645-minimum-additions-to-make-valid-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n\\n        int ans=0;\\n    for(int i=0; i<word.length();){\\n        if(word.charAt(i)== \\'a\\') i++; else ans++;         \\n        if( i < word.length() && word.charAt(i)== \\'b\\')i++; else ans++;\\n        if(i < word.length() && word.charAt(i) == \\'c\\')i++; else ans++;\\n    }\\n    return ans;\\n        \\n    }\\n}\\n\\n \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String word) {\\n\\n        int ans=0;\\n    for(int i=0; i<word.length();){\\n        if(word.charAt(i)== \\'a\\') i++; else ans++;         \\n        if( i < word.length() && word.charAt(i)== \\'b\\')i++; else ans++;\\n        if(i < word.length() && word.charAt(i) == \\'c\\')i++; else ans++;\\n    }\\n    return ans;\\n        \\n    }\\n}\\n\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044877,
                "title": "c-easy-solution-using-stack",
                "content": "class Solution {\\npublic:\\n    int addMinimum(string s) {\\n        stack<char>st;\\n        for(int i=s.length()-1;i>=0;i--)\\n        {\\n            st.push(s[i]);\\n        }\\n        char c=\\'a\\';int ans=0;\\n        while(!st.empty())\\n        {\\n            if(st.top()!=c)\\n            {\\n               ans++; \\n            }\\n            else{\\n                st.pop();\\n            }\\n            c=c+1;\\n            if(c==\\'d\\')\\n            {\\n                c=\\'a\\';\\n            }\\n            \\n        }\\n        if(c==\\'b\\')\\n        {\\n            ans=ans+2;\\n        }\\n        else if(c==\\'c\\')\\n        {\\n            ans++;\\n        }\\n        return ans;\\n        \\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int addMinimum(string s) {\\n        stack<char>st;\\n        for(int i=s.length()-1;i>=0;i--)\\n        {\\n            st.push(s[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4026174,
                "title": "c-o-n",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(string& word, string s)\\n    {\\n        int ans = 0;\\n        int i = 0;\\n        int j = 0;\\n        while(i<word.length())\\n        {\\n            if(word[i]!=s[j]) ans++;\\n            else i++;\\n            j++;\\n            j = j%3;\\n        }\\n        if(j!=0) ans = ans+(3-j);\\n        return ans;\\n    }\\n    int addMinimum(string word) \\n    {\\n        return solve(word, \"abc\");\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(string& word, string s)\\n    {\\n        int ans = 0;\\n        int i = 0;\\n        int j = 0;\\n        while(i<word.length())\\n        {\\n            if(word[i]!=s[j]) ans++;\\n            else i++;\\n            j++;\\n            j = j%3;\\n        }\\n        if(j!=0) ans = ans+(3-j);\\n        return ans;\\n    }\\n    int addMinimum(string word) \\n    {\\n        return solve(word, \"abc\");\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021986,
                "title": "beats-69-runtime",
                "content": "# Intuition\\nby simple observation we can do this problem\\n\\n# Approach\\nbasic maths\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int l=word.length();\\n        if(l==1) return 2;\\n        int cnt=0;\\n        for(int i=0;i<l-1;i++)\\n        {\\n            if(word[i]==\\'a\\' && word[i+1]==\\'a\\') cnt+=2;\\n            if(word[i]==\\'a\\' && word[i+1]==\\'c\\') cnt++;\\n            if(word[i]==\\'b\\' && word[i+1]==\\'a\\') cnt++;\\n            if(word[i]==\\'b\\' && word[i+1]==\\'b\\') cnt+=2;\\n            if(word[i]==\\'c\\' && word[i+1]==\\'b\\') cnt++;\\n            if(word[i]==\\'c\\' && word[i+1]==\\'c\\') cnt+=2;\\n        }\\n        if(word[0]==\\'b\\') cnt++;\\n        if(word[0]==\\'c\\') cnt+=2;\\n        if(word[l-1]==\\'a\\') cnt+=2;\\n        if(word[l-1]==\\'b\\') cnt++;\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int l=word.length();\\n        if(l==1) return 2;\\n        int cnt=0;\\n        for(int i=0;i<l-1;i++)\\n        {\\n            if(word[i]==\\'a\\' && word[i+1]==\\'a\\') cnt+=2;\\n            if(word[i]==\\'a\\' && word[i+1]==\\'c\\') cnt++;\\n            if(word[i]==\\'b\\' && word[i+1]==\\'a\\') cnt++;\\n            if(word[i]==\\'b\\' && word[i+1]==\\'b\\') cnt+=2;\\n            if(word[i]==\\'c\\' && word[i+1]==\\'b\\') cnt++;\\n            if(word[i]==\\'c\\' && word[i+1]==\\'c\\') cnt+=2;\\n        }\\n        if(word[0]==\\'b\\') cnt++;\\n        if(word[0]==\\'c\\') cnt+=2;\\n        if(word[l-1]==\\'a\\') cnt+=2;\\n        if(word[l-1]==\\'b\\') cnt++;\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010194,
                "title": "count-number-of-updated-string-as-you-go-c-100-96-o-n-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string s) {\\n        int ans=1;\\n        for(int i=1;i<s.size();i++){\\n            if(!(s[i]>s[i-1])){\\n                ans++;\\n            }\\n        }\\n        return (3*ans)-s.size();\\n    }\\n};\\n\\n// a ab bc c\\n// abc abc abc abc\\n\\n// a ac c b b\\n// abc abc abc abc abc\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string s) {\\n        int ans=1;\\n        for(int i=1;i<s.size();i++){\\n            if(!(s[i]>s[i-1])){\\n                ans++;\\n            }\\n        }\\n        return (3*ans)-s.size();\\n    }\\n};\\n\\n// a ab bc c\\n// abc abc abc abc\\n\\n// a ac c b b\\n// abc abc abc abc abc\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008844,
                "title": "java-solution-easy",
                "content": "# Intuition\\nFor any given letter at any index we need to make it like \"abc\". \\n\\n# Approach\\nWe have a given pattern. For a given character we will keep on appending to the left based on patternIndex. At last we will add characters to the right so that pattern \"abc\" can be form \\n\\nFor eg: Word -> \"aaa\" Pattern -> \"abc\";\\nat 0th index of word character is \\'a\\'\\nat 0th index of Pattern character is \\'a\\'\\nso nothing will appended to the left. \\n\\nat 1st index of word character is \\'a\\'\\nat 0th index of Pattern character is \\'b\\'\\nCharacters are not matching so move the patternIndex in ciruclar fashion so that it matches. \\n2 characters will be added before 1st Index of word \\'b\\', \\'c\\' and now bothe word and pattern index are pointing to the same character.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        String pattern = \"abc\";\\n        int patternIndex = 0;\\n        int additionalCount = 0;\\n\\n        for (int i = 0; i < word.length(); i++) {\\n            char currentChar = word.charAt(i);\\n            \\n            while (currentChar != pattern.charAt(patternIndex)) {\\n                additionalCount++;\\n                patternIndex = (patternIndex + 1) % 3; // loop within bounds of \\'abc\\'\\n            }\\n            patternIndex = (patternIndex + 1) % 3; // move to next expected character in pattern\\n        }\\n\\n        switch (word.charAt(word.length() - 1)) {\\n            case \\'a\\':\\n                additionalCount += 2;\\n                break;\\n            case \\'b\\':\\n                additionalCount += 1;\\n                break;\\n        }\\n\\n        return additionalCount;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        String pattern = \"abc\";\\n        int patternIndex = 0;\\n        int additionalCount = 0;\\n\\n        for (int i = 0; i < word.length(); i++) {\\n            char currentChar = word.charAt(i);\\n            \\n            while (currentChar != pattern.charAt(patternIndex)) {\\n                additionalCount++;\\n                patternIndex = (patternIndex + 1) % 3; // loop within bounds of \\'abc\\'\\n            }\\n            patternIndex = (patternIndex + 1) % 3; // move to next expected character in pattern\\n        }\\n\\n        switch (word.charAt(word.length() - 1)) {\\n            case \\'a\\':\\n                additionalCount += 2;\\n                break;\\n            case \\'b\\':\\n                additionalCount += 1;\\n                break;\\n        }\\n\\n        return additionalCount;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006616,
                "title": "concise-and-clear-two-pointers-approach",
                "content": "# Intuition\\n\\n  First of all take the idea from the **hint** section then come here because this logic is totally based upon that hint part.\\n\\n  Take the string \"abc\" and keep one pointer at 0th index of original string nd keep another pointer at 0th index of \"abc\" string so here if both the characters get match it means we are going in the right direction but if both the character doesn\\'t match then keep incrementing \"abc\" string and incrementing your answer untill you didn\\'t get your desire character.\\n\\nNow in the end if your last character from the original string doesn\\'t have \\'c\\' character then you need to add (3-j) in your answer , the reason is that suppose your last character is \\'b\\' then it did calculate for the previous characters but it misses out the track for the last character so for such situation you need to add (3-j) in your answer.\\n\\n# Approach\\n  Two Pointers.\\n\\n# Complexity\\n- Time complexity:\\n  O(n)\\n\\n- Space complexity:\\n  O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int len = word.length();\\n        String check = \"abc\";\\n        int j=0,ans=0;\\n        for(int i=0;i<len;j++){\\n            j=j%3;\\n            if(word.charAt(i)==check.charAt(j)) i++;\\n            else ans++;\\n        }\\n        if(word.charAt(len-1)!=\\'c\\') ans+=(3-j);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int len = word.length();\\n        String check = \"abc\";\\n        int j=0,ans=0;\\n        for(int i=0;i<len;j++){\\n            j=j%3;\\n            if(word.charAt(i)==check.charAt(j)) i++;\\n            else ans++;\\n        }\\n        if(word.charAt(len-1)!=\\'c\\') ans+=(3-j);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995677,
                "title": "easy-case-by-case-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string s) {    \\n    \\n        int n = s.length();\\n        int i = 0;\\n        int ans = 0;\\n\\n        while(i < n){\\n            if(s[i] == \\'a\\'){\\n                char c1 = \\'*\\';\\n                char c2 = \\'*\\';\\n                \\n                if(i+1 < n){\\n                    c1 = s[i+1];\\n                }\\n                if(i+2 < n){\\n                    c2 = s[i+2];\\n                }\\n\\n                if(c1 == \\'b\\' && c2 == \\'c\\'){\\n                    i += 3;\\n                } else if(c1 == \\'b\\'){\\n                    i += 2;\\n                    ans++;\\n                } else if(c1 == \\'c\\'){\\n                    i += 2;\\n                    ans++;\\n                } else {\\n                    ans += 2;\\n                    i++;\\n                }\\n            } else if(s[i] == \\'b\\'){\\n                if(i+1 < n && s[i+1] == \\'c\\') {\\n                    ans++;\\n                    i += 2;\\n                } else {\\n                    ans += 2;\\n                    i++;\\n                }\\n            } else {\\n                ans += 2;\\n                i++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string s) {    \\n    \\n        int n = s.length();\\n        int i = 0;\\n        int ans = 0;\\n\\n        while(i < n){\\n            if(s[i] == \\'a\\'){\\n                char c1 = \\'*\\';\\n                char c2 = \\'*\\';\\n                \\n                if(i+1 < n){\\n                    c1 = s[i+1];\\n                }\\n                if(i+2 < n){\\n                    c2 = s[i+2];\\n                }\\n\\n                if(c1 == \\'b\\' && c2 == \\'c\\'){\\n                    i += 3;\\n                } else if(c1 == \\'b\\'){\\n                    i += 2;\\n                    ans++;\\n                } else if(c1 == \\'c\\'){\\n                    i += 2;\\n                    ans++;\\n                } else {\\n                    ans += 2;\\n                    i++;\\n                }\\n            } else if(s[i] == \\'b\\'){\\n                if(i+1 < n && s[i+1] == \\'c\\') {\\n                    ans++;\\n                    i += 2;\\n                } else {\\n                    ans += 2;\\n                    i++;\\n                }\\n            } else {\\n                ans += 2;\\n                i++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3986815,
                "title": "minimum-additions-to-make-valid-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int i=0;\\n        String s = \"abc\";\\n        int count =0;\\n        while(i<word.length())\\n        {for(int j=0;j<s.length();j++)\\n        {\\n            if(i<word.length()&&word.charAt(i)==s.charAt(j))\\n            i++;\\n            else\\n            count++;\\n        }}\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int i=0;\\n        String s = \"abc\";\\n        int count =0;\\n        while(i<word.length())\\n        {for(int j=0;j<s.length();j++)\\n        {\\n            if(i<word.length()&&word.charAt(i)==s.charAt(j))\\n            i++;\\n            else\\n            count++;\\n        }}\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984045,
                "title": "easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int ans=0;\\n        string ref=\"abc\";\\n        int i=0,p=0;\\n        while(i<word.size()){\\n           if(word[i]==ref[p]){\\n               i++;\\n           }\\n           else{\\n               ans++;\\n           }\\n           p++;\\n           if(p>=3)\\n           p=0;\\n        }\\n        if(p>0)\\n        ans+=3-p;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int ans=0;\\n        string ref=\"abc\";\\n        int i=0,p=0;\\n        while(i<word.size()){\\n           if(word[i]==ref[p]){\\n               i++;\\n           }\\n           else{\\n               ans++;\\n           }\\n           p++;\\n           if(p>=3)\\n           p=0;\\n        }\\n        if(p>0)\\n        ans+=3-p;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972963,
                "title": "minimum-additions-to-make-valid-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Count the occurrences of \\'a\\', \\'b\\', and \\'c\\' in the string. Determine the valid \"abc\" chunks that can be formed. Calculate the minimum insertions needed by adding remaining characters based on valid chunks.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Brute Force Approach (Inefficient):\\nGenerate all possible strings by inserting \\'a\\', \\'b\\', and \\'c\\' into the given string, and calculate the minimum additions required to make them valid. This approach has exponential time complexity due to the large number of possibilities.\\n\\n- Optimal Approach (Efficient):(read code)\\nIt iterates through the characters in the input string using the index i and keeps track of the required additions using the ans variable. For each character, it checks if it is \\'a\\', \\'b\\', or \\'c\\', and either increments the index i (if the character is already valid) or increments the ans variable (if the character needs to be added to form a valid \"abc\" chunk). The final value of ans represents the minimum number of characters needed to make the string valid..\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- 1\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int ans = 0, i = 0; // Initialize ans (answer) to keep track of additions needed, and i to iterate through the characters\\n        \\n        // Loop through the characters in the word\\n        while (i < word.size()) {\\n            // If the current character is \\'a\\', increment i to skip this character\\n            // If it\\'s not \\'a\\', increment ans since we need to add a character to form a valid \"abc\" chunk\\n            (word[i] == \\'a\\') ? i++ : ans++;\\n            \\n            // Similar logic for \\'b\\'\\n            (word[i] == \\'b\\') ? i++ : ans++;\\n            \\n            // Similar logic for \\'c\\'\\n            (word[i] == \\'c\\') ? i++ : ans++;\\n        }\\n        \\n        return ans; // Return the minimum number of additions needed\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int ans = 0, i = 0; // Initialize ans (answer) to keep track of additions needed, and i to iterate through the characters\\n        \\n        // Loop through the characters in the word\\n        while (i < word.size()) {\\n            // If the current character is \\'a\\', increment i to skip this character\\n            // If it\\'s not \\'a\\', increment ans since we need to add a character to form a valid \"abc\" chunk\\n            (word[i] == \\'a\\') ? i++ : ans++;\\n            \\n            // Similar logic for \\'b\\'\\n            (word[i] == \\'b\\') ? i++ : ans++;\\n            \\n            // Similar logic for \\'c\\'\\n            (word[i] == \\'c\\') ? i++ : ans++;\\n        }\\n        \\n        return ans; // Return the minimum number of additions needed\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971296,
                "title": "easy-solution-recursion-tc-o-n-sc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int solve(int i,string word,string s)\\n   {\\n     if(i>=word.size())\\n    {   cout<<s;\\n        return(\\'c\\'-word[word.size()-1]);\\n   }\\n     int insert=0,noinsert=0;\\n     if(s.size()==0)\\n     {\\n       if(word[0]==\\'a\\')\\n       {\\n         return(solve(i+1,word,s+word[i]));\\n       }\\n       else\\n       {\\n         return(solve(i,word,s+\\'a\\'))+1;\\n       }\\n     }\\n     if(s[s.size()-1]==\\'c\\'&&word[i]==\\'a\\'||s[s.size()-1]==\\'a\\'&&word[i]==\\'b\\'||s[s.size()-1]==\\'b\\'&&word[i]==\\'c\\')\\n     {\\n        return solve(i+1,word,s+word[i]);\\n     }\\n     else\\n     {\\n       char ch;\\n       if(s[s.size()-1]==\\'c\\')\\n       ch=\\'a\\';\\n       else\\n       {\\n         if(s[s.size()-1]==\\'a\\')\\n         ch=\\'b\\';\\n         else\\n         ch=\\'c\\';\\n       }\\n       cout<<word[i]<<endl;\\n       return solve(i,word,s+ch)+1;\\n     }\\n   }\\n    int addMinimum(string word) {\\n        if(word.size()==0)\\n        return(0);\\n        string s;\\n       return(solve(0,word,s));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int solve(int i,string word,string s)\\n   {\\n     if(i>=word.size())\\n    {   cout<<s;\\n        return(\\'c\\'-word[word.size()-1]);\\n   }\\n     int insert=0,noinsert=0;\\n     if(s.size()==0)\\n     {\\n       if(word[0]==\\'a\\')\\n       {\\n         return(solve(i+1,word,s+word[i]));\\n       }\\n       else\\n       {\\n         return(solve(i,word,s+\\'a\\'))+1;\\n       }\\n     }\\n     if(s[s.size()-1]==\\'c\\'&&word[i]==\\'a\\'||s[s.size()-1]==\\'a\\'&&word[i]==\\'b\\'||s[s.size()-1]==\\'b\\'&&word[i]==\\'c\\')\\n     {\\n        return solve(i+1,word,s+word[i]);\\n     }\\n     else\\n     {\\n       char ch;\\n       if(s[s.size()-1]==\\'c\\')\\n       ch=\\'a\\';\\n       else\\n       {\\n         if(s[s.size()-1]==\\'a\\')\\n         ch=\\'b\\';\\n         else\\n         ch=\\'c\\';\\n       }\\n       cout<<word[i]<<endl;\\n       return solve(i,word,s+ch)+1;\\n     }\\n   }\\n    int addMinimum(string word) {\\n        if(word.size()==0)\\n        return(0);\\n        string s;\\n       return(solve(0,word,s));\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3968455,
                "title": "java-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int ans =0;\\n        for(int i =0; i < word.length();) {\\n            if(word.charAt(i) == \\'a\\') \\n            i++; \\n            else\\n             ans++;\\n            if(i < word.length() && word.charAt(i) == \\'b\\') \\n            i++;\\n             else \\n             ans++;\\n            if(i < word.length() && word.charAt(i) == \\'c\\') {\\n                 i++;\\n            }else {\\n                       ans++; \\n                    }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int ans =0;\\n        for(int i =0; i < word.length();) {\\n            if(word.charAt(i) == \\'a\\') \\n            i++; \\n            else\\n             ans++;\\n            if(i < word.length() && word.charAt(i) == \\'b\\') \\n            i++;\\n             else \\n             ans++;\\n            if(i < word.length() && word.charAt(i) == \\'c\\') {\\n                 i++;\\n            }else {\\n                       ans++; \\n                    }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963511,
                "title": "simple-implementation-using-if-else-condition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHow can we make every character part of an abc substring.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing simple if else condition.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(len(word))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n=word.length();\\n        int count=0;\\n        for(int i=0;i<=n-2;i++)\\n        {\\n            if(word[i]==\\'a\\')\\n            {\\n                if(word[i+1]==\\'a\\')\\n                    count+=2;\\n                if(word[i+1]==\\'c\\')\\n                    count+=1;\\n            }\\n            else if(word[i]==\\'b\\')\\n            {\\n                if(word[i+1]==\\'b\\')\\n                    count+=2;\\n                if(word[i+1]==\\'a\\')\\n                    count+=1;\\n            }\\n            else if(word[i]==\\'c\\')\\n            {\\n                if(word[i+1]==\\'c\\')\\n                    count+=2;\\n                if(word[i+1]==\\'b\\')\\n                    count+=1;\\n            }\\n        }\\n        //checking for first\\n        if(word[0]==\\'b\\')\\n            count+=1;\\n        if(word[0]==\\'c\\')\\n            count+=2;\\n        //checking for last\\n           if(word[n-1]==\\'b\\')\\n            count+=1;\\n          if(word[n-1]==\\'a\\')\\n            count+=2;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n=word.length();\\n        int count=0;\\n        for(int i=0;i<=n-2;i++)\\n        {\\n            if(word[i]==\\'a\\')\\n            {\\n                if(word[i+1]==\\'a\\')\\n                    count+=2;\\n                if(word[i+1]==\\'c\\')\\n                    count+=1;\\n            }\\n            else if(word[i]==\\'b\\')\\n            {\\n                if(word[i+1]==\\'b\\')\\n                    count+=2;\\n                if(word[i+1]==\\'a\\')\\n                    count+=1;\\n            }\\n            else if(word[i]==\\'c\\')\\n            {\\n                if(word[i+1]==\\'c\\')\\n                    count+=2;\\n                if(word[i+1]==\\'b\\')\\n                    count+=1;\\n            }\\n        }\\n        //checking for first\\n        if(word[0]==\\'b\\')\\n            count+=1;\\n        if(word[0]==\\'c\\')\\n            count+=2;\\n        //checking for last\\n           if(word[n-1]==\\'b\\')\\n            count+=1;\\n          if(word[n-1]==\\'a\\')\\n            count+=2;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950691,
                "title": "dp-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int ans = 0;\\n        // std::vector<int> dp(word.size(),0);\\n        ans = word[0] - \\'a\\';\\n        for(int i = 1; i < word.size(); i ++){\\n            if(word[i]-word[i-1] > 0)\\n                ans = ans + word[i]-word[i-1] -1;\\n            else{\\n                ans = ans + \\'c\\' - word[i-1] + word[i] - \\'a\\';\\n            }\\n        }\\n        return ans + \\'c\\' - word[word.size()-1];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int ans = 0;\\n        // std::vector<int> dp(word.size(),0);\\n        ans = word[0] - \\'a\\';\\n        for(int i = 1; i < word.size(); i ++){\\n            if(word[i]-word[i-1] > 0)\\n                ans = ans + word[i]-word[i-1] -1;\\n            else{\\n                ans = ans + \\'c\\' - word[i-1] + word[i] - \\'a\\';\\n            }\\n        }\\n        return ans + \\'c\\' - word[word.size()-1];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948000,
                "title": "python-beats-98-77",
                "content": "![\\u672A\\u547D\\u540D.png](https://assets.leetcode.com/users/images/e451422b-c134-4362-8e73-c239268e2d5f_1692757950.2525883.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        Output = 0\\n        word = \\'_\\' + \\'_\\' + word + \\'_\\' + \\'_\\'\\n\\n        for i in range(2,len(word)-2):\\n            if word[i] == \\'a\\':\\n                if word[i+1] == \\'a\\':\\n                    Output = Output + 2\\n                elif word[i+1] == \\'b\\':\\n                    if word[i+2] == \\'c\\':\\n                        pass\\n                    else:\\n                        Output = Output + 1\\n                elif word[i+1] == \\'c\\':\\n                    Output = Output + 1\\n                else:\\n                    Output = Output + 2\\n            elif word[i] == \\'b\\':\\n                if word[i-1] == \\'a\\':\\n                    pass\\n                elif word[i-1] != \\'a\\':\\n                    if word[i+1] == \\'c\\':\\n                        Output = Output + 1\\n                    else:\\n                        Output = Output + 2\\n            elif word[i] == \\'c\\':\\n                if word[i-1] == \\'a\\':\\n                    pass\\n                elif word[i-1] == \\'b\\':\\n                    pass\\n                else:\\n                    Output = Output + 2\\n        \\n        return Output\\n\\n        # 20230823\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        Output = 0\\n        word = \\'_\\' + \\'_\\' + word + \\'_\\' + \\'_\\'\\n\\n        for i in range(2,len(word)-2):\\n            if word[i] == \\'a\\':\\n                if word[i+1] == \\'a\\':\\n                    Output = Output + 2\\n                elif word[i+1] == \\'b\\':\\n                    if word[i+2] == \\'c\\':\\n                        pass\\n                    else:\\n                        Output = Output + 1\\n                elif word[i+1] == \\'c\\':\\n                    Output = Output + 1\\n                else:\\n                    Output = Output + 2\\n            elif word[i] == \\'b\\':\\n                if word[i-1] == \\'a\\':\\n                    pass\\n                elif word[i-1] != \\'a\\':\\n                    if word[i+1] == \\'c\\':\\n                        Output = Output + 1\\n                    else:\\n                        Output = Output + 2\\n            elif word[i] == \\'c\\':\\n                if word[i-1] == \\'a\\':\\n                    pass\\n                elif word[i-1] == \\'b\\':\\n                    pass\\n                else:\\n                    Output = Output + 2\\n        \\n        return Output\\n\\n        # 20230823\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3945762,
                "title": "basic-approach-c-using-maps-and-stacks",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->used maps and stacks to solve this question\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->made a mapping for each a ,b, c with their next alphaber resp. Iterated through the string and then checked the conditions\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        stack<char> st;\\n        int cnt = 0;\\n        map<char, char> mp = { {\\'a\\', \\'b\\'}, {\\'b\\', \\'c\\'}, {\\'c\\', \\'a\\'} };\\n        int i = 0;\\n        while(i<word.length()){\\n\\n            if(st.empty() && word[i] != \\'a\\'){\\n                st.push(\\'a\\');\\n                cnt++;\\n            }\\n            \\n            if(!st.empty() && mp[st.top()] != word[i]){\\n                while(mp[st.top()] != word[i]){\\n                    st.push(mp[st.top()]);\\n                    cnt++;\\n                }\\n\\n                st.push(word[i]);\\n            }\\n\\n            \\n            else{\\n                st.push(word[i]);\\n            }\\n            i++;\\n\\n        }\\n\\n        if(st.top() != \\'c\\'){\\n            while(st.top() != \\'c\\'){\\n                st.push(mp[st.top()]);\\n                cnt++;\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        stack<char> st;\\n        int cnt = 0;\\n        map<char, char> mp = { {\\'a\\', \\'b\\'}, {\\'b\\', \\'c\\'}, {\\'c\\', \\'a\\'} };\\n        int i = 0;\\n        while(i<word.length()){\\n\\n            if(st.empty() && word[i] != \\'a\\'){\\n                st.push(\\'a\\');\\n                cnt++;\\n            }\\n            \\n            if(!st.empty() && mp[st.top()] != word[i]){\\n                while(mp[st.top()] != word[i]){\\n                    st.push(mp[st.top()]);\\n                    cnt++;\\n                }\\n\\n                st.push(word[i]);\\n            }\\n\\n            \\n            else{\\n                st.push(word[i]);\\n            }\\n            i++;\\n\\n        }\\n\\n        if(st.top() != \\'c\\'){\\n            while(st.top() != \\'c\\'){\\n                st.push(mp[st.top()]);\\n                cnt++;\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926087,
                "title": "python-simple-solution-beats-98-26",
                "content": "# Intuition\\ncheck each letter and the letter before it, count missed letter in them, finally we got the answer\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nfor better performance, I build a dict to count missed letter quickly, then check each letter, don\\'t forget check the head and the tail\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        mp={\\'aa\\':2,\\'ab\\':0,\\'ac\\':1,\\'ba\\':1,\\'bb\\':2,\\'bc\\':0,\\'ca\\':0,\\'cb\\':1,\\'cc\\':2}\\n        res=mp[\\'c\\'+word[0]]+mp[word[-1]+\\'a\\']\\n        for i in range(1,len(word)):\\n            res+=mp[word[i-1:i+1]]\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        mp={\\'aa\\':2,\\'ab\\':0,\\'ac\\':1,\\'ba\\':1,\\'bb\\':2,\\'bc\\':0,\\'ca\\':0,\\'cb\\':1,\\'cc\\':2}\\n        res=mp[\\'c\\'+word[0]]+mp[word[-1]+\\'a\\']\\n        for i in range(1,len(word)):\\n            res+=mp[word[i-1:i+1]]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894330,
                "title": "best-solution-c-with-comments-beats-100-in-time-complexity-97-in-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n = word.size();  //finding size of the word\\n        int flag = 0; //to determine what should be the character at particular position 0 means\\'a\\' , 1 means \\'b\\' , 2 means\\'c\\'\\n        int insert = 0; //to count number of inserts in string\\n        \\n        int i = 0; //pointer to traverse string\\n        while(i<n) {\\n            //flag can be 0,1,2\\n\\n            if(flag==0) { \\n                //represents that the char should be \\'a\\' at this position\\n                if(word[i]==\\'a\\') i++; //if character is already \\'a\\' then increase the pointer \\n                else insert++; //if character is not \\'a\\' then \\'a\\' need to be added\\n                \\n                flag = 1; //next character should be \\'b\\'\\n            }\\n\\n            else if(flag==1) {\\n                 //represents that the char should be \\'b\\' at this position\\n                if(word[i]==\\'b\\') i++; //if character is already \\'b\\' then increase the pointer\\n                else insert++; //if character is not \\'b\\' then \\'b\\' need to be added\\n                \\n                flag = 2; //next character should be \\'c\\'\\n            }\\n\\n            else {\\n                //represents that the char should be \\'c\\' at this position\\n                if(word[i]==\\'c\\') i++; //if character is already \\'c\\' then increase the pointer\\n                else insert++; //if character is not \\'c\\' then \\'c\\' need to be added\\n                \\n                flag = 0; //next character should be \\'a\\'\\n            }\\n            \\n        }\\n        \\n        if(flag==1) insert+=2; //flag = 1 means last char was \\'a\\' thus two more inserts are needed\\n        else if(flag==2) insert+=1; //flag = 2 means last char was \\'b\\' thus one more insert is needed\\n        \\n        return insert;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n = word.size();  //finding size of the word\\n        int flag = 0; //to determine what should be the character at particular position 0 means\\'a\\' , 1 means \\'b\\' , 2 means\\'c\\'\\n        int insert = 0; //to count number of inserts in string\\n        \\n        int i = 0; //pointer to traverse string\\n        while(i<n) {\\n            //flag can be 0,1,2\\n\\n            if(flag==0) { \\n                //represents that the char should be \\'a\\' at this position\\n                if(word[i]==\\'a\\') i++; //if character is already \\'a\\' then increase the pointer \\n                else insert++; //if character is not \\'a\\' then \\'a\\' need to be added\\n                \\n                flag = 1; //next character should be \\'b\\'\\n            }\\n\\n            else if(flag==1) {\\n                 //represents that the char should be \\'b\\' at this position\\n                if(word[i]==\\'b\\') i++; //if character is already \\'b\\' then increase the pointer\\n                else insert++; //if character is not \\'b\\' then \\'b\\' need to be added\\n                \\n                flag = 2; //next character should be \\'c\\'\\n            }\\n\\n            else {\\n                //represents that the char should be \\'c\\' at this position\\n                if(word[i]==\\'c\\') i++; //if character is already \\'c\\' then increase the pointer\\n                else insert++; //if character is not \\'c\\' then \\'c\\' need to be added\\n                \\n                flag = 0; //next character should be \\'a\\'\\n            }\\n            \\n        }\\n        \\n        if(flag==1) insert+=2; //flag = 1 means last char was \\'a\\' thus two more inserts are needed\\n        else if(flag==2) insert+=1; //flag = 2 means last char was \\'b\\' thus one more insert is needed\\n        \\n        return insert;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894329,
                "title": "best-solution-c-with-comments-beats-100-in-time-complexity-97-in-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n = word.size();  //finding size of the word\\n        int flag = 0; //to determine what should be the character at particular position 0 means\\'a\\' , 1 means \\'b\\' , 2 means\\'c\\'\\n        int insert = 0; //to count number of inserts in string\\n        \\n        int i = 0; //pointer to traverse string\\n        while(i<n) {\\n            //flag can be 0,1,2\\n\\n            if(flag==0) { \\n                //represents that the char should be \\'a\\' at this position\\n                if(word[i]==\\'a\\') i++; //if character is already \\'a\\' then increase the pointer \\n                else insert++; //if character is not \\'a\\' then \\'a\\' need to be added\\n                \\n                flag = 1; //next character should be \\'b\\'\\n            }\\n\\n            else if(flag==1) {\\n                 //represents that the char should be \\'b\\' at this position\\n                if(word[i]==\\'b\\') i++; //if character is already \\'b\\' then increase the pointer\\n                else insert++; //if character is not \\'b\\' then \\'b\\' need to be added\\n                \\n                flag = 2; //next character should be \\'c\\'\\n            }\\n\\n            else {\\n                //represents that the char should be \\'c\\' at this position\\n                if(word[i]==\\'c\\') i++; //if character is already \\'c\\' then increase the pointer\\n                else insert++; //if character is not \\'c\\' then \\'c\\' need to be added\\n                \\n                flag = 0; //next character should be \\'a\\'\\n            }\\n            \\n        }\\n        \\n        if(flag==1) insert+=2; //flag = 1 means last char was \\'a\\' thus two more inserts are needed\\n        else if(flag==2) insert+=1; //flag = 2 means last char was \\'b\\' thus one more insert is needed\\n        \\n        return insert;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n = word.size();  //finding size of the word\\n        int flag = 0; //to determine what should be the character at particular position 0 means\\'a\\' , 1 means \\'b\\' , 2 means\\'c\\'\\n        int insert = 0; //to count number of inserts in string\\n        \\n        int i = 0; //pointer to traverse string\\n        while(i<n) {\\n            //flag can be 0,1,2\\n\\n            if(flag==0) { \\n                //represents that the char should be \\'a\\' at this position\\n                if(word[i]==\\'a\\') i++; //if character is already \\'a\\' then increase the pointer \\n                else insert++; //if character is not \\'a\\' then \\'a\\' need to be added\\n                \\n                flag = 1; //next character should be \\'b\\'\\n            }\\n\\n            else if(flag==1) {\\n                 //represents that the char should be \\'b\\' at this position\\n                if(word[i]==\\'b\\') i++; //if character is already \\'b\\' then increase the pointer\\n                else insert++; //if character is not \\'b\\' then \\'b\\' need to be added\\n                \\n                flag = 2; //next character should be \\'c\\'\\n            }\\n\\n            else {\\n                //represents that the char should be \\'c\\' at this position\\n                if(word[i]==\\'c\\') i++; //if character is already \\'c\\' then increase the pointer\\n                else insert++; //if character is not \\'c\\' then \\'c\\' need to be added\\n                \\n                flag = 0; //next character should be \\'a\\'\\n            }\\n            \\n        }\\n        \\n        if(flag==1) insert+=2; //flag = 1 means last char was \\'a\\' thus two more inserts are needed\\n        else if(flag==2) insert+=1; //flag = 2 means last char was \\'b\\' thus one more insert is needed\\n        \\n        return insert;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881135,
                "title": "beat-100-of-all-t-c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string nums) \\n    {\\n        int step=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n            {if(nums[i]!=\\'c\\'&&nums[i+1]!=nums[i]+1){\\n                nums.insert(i+1,1,nums[i]+1);step++;}\\n            else if(nums[i]==\\'c\\'&&nums[i+1]!=\\'a\\'){\\n                nums.insert(i+1,1,\\'a\\');step++;}}\\n        if(nums[0]==\\'b\\')\\n            {nums=\\'a\\'+nums;step++;}\\n        else if(nums[0]==\\'c\\')\\n            {nums=\"ab\"+nums;step+=2;}\\n        \\n        if(nums.back()==\\'b\\')\\n            {nums=nums+\\'c\\';step++;}\\n        else if(nums.back()==\\'a\\')\\n            {nums=nums+\"bc\";step+=2;}\\n        \\n        return step;\\n                \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string nums) \\n    {\\n        int step=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n            {if(nums[i]!=\\'c\\'&&nums[i+1]!=nums[i]+1){\\n                nums.insert(i+1,1,nums[i]+1);step++;}\\n            else if(nums[i]==\\'c\\'&&nums[i+1]!=\\'a\\'){\\n                nums.insert(i+1,1,\\'a\\');step++;}}\\n        if(nums[0]==\\'b\\')\\n            {nums=\\'a\\'+nums;step++;}\\n        else if(nums[0]==\\'c\\')\\n            {nums=\"ab\"+nums;step+=2;}\\n        \\n        if(nums.back()==\\'b\\')\\n            {nums=nums+\\'c\\';step++;}\\n        else if(nums.back()==\\'a\\')\\n            {nums=nums+\"bc\";step+=2;}\\n        \\n        return step;\\n                \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876837,
                "title": "c-very-easy-solution-understand-just-by-looking",
                "content": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n     int count=0,i=0;\\n        while(i<word.size())\\n        {\\n            (word[i]==\\'a\\')?i++:count++;\\n            (word[i]==\\'b\\')?i++:count++;\\n            (word[i]==\\'c\\')?i++:count++;\\n        }\\n        return count; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n     int count=0,i=0;\\n        while(i<word.size())\\n        {\\n            (word[i]==\\'a\\')?i++:count++;\\n            (word[i]==\\'b\\')?i++:count++;\\n            (word[i]==\\'c\\')?i++:count++;\\n        }\\n        return count; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876609,
                "title": "java-solution",
                "content": "# Complexity\\n- Time complexity:$$O(3*n)$$\\n- Space complexity:$$O(n)$$\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int n=word.length();\\n        int op=0;\\n        StringBuilder s=new StringBuilder();\\n        for(int i=0;i<n;i++) s.append(\"abc\");\\n        if(word.charAt(n-1)!=\\'c\\'){\\n            word=word+\\'c\\';\\n            op++;\\n        }\\n        int count=0;\\n        int index=0;\\n        for(int i=0;i<s.length() && index<word.length();i++){\\n            if(s.charAt(i)!=word.charAt(index)){\\n                count++;\\n            }\\n            else{\\n                index++;\\n                op+=count;\\n                count=0;\\n            }\\n        }\\n        return op;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int n=word.length();\\n        int op=0;\\n        StringBuilder s=new StringBuilder();\\n        for(int i=0;i<n;i++) s.append(\"abc\");\\n        if(word.charAt(n-1)!=\\'c\\'){\\n            word=word+\\'c\\';\\n            op++;\\n        }\\n        int count=0;\\n        int index=0;\\n        for(int i=0;i<s.length() && index<word.length();i++){\\n            if(s.charAt(i)!=word.charAt(index)){\\n                count++;\\n            }\\n            else{\\n                index++;\\n                op+=count;\\n                count=0;\\n            }\\n        }\\n        return op;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866672,
                "title": "javascript-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction addMinimum(word) {\\n    if (word.length === 1) return 2;\\n    let res = 0;\\n    if (word[0] === \\'b\\') res++;\\n    if (word[0] === \\'c\\') res += 2;\\n    const stack = [word[0]];\\n    let i = 1;\\n    while (i < word.length) {\\n        const peek = stack[stack.length-1];\\n        if (peek === \\'a\\') {\\n            if (word[i] === \\'a\\') {\\n                res += 2;\\n            }\\n            else if (word[i] === \\'b\\'){\\n            } \\n            else {\\n                res++; \\n            }\\n        } else if (peek === \\'b\\') {\\n            if (word[i] === \\'a\\') {\\n                res++;\\n            }\\n            else if (word[i] === \\'b\\'){\\n                res += 2;\\n            } \\n            else {\\n                // res++;\\n            }\\n        } else {\\n            if (word[i] === \\'a\\') {\\n            }\\n            else if (word[i] === \\'b\\'){\\n                res++;\\n            } \\n            else {\\n                res += 2;\\n            }\\n        }\\n        stack.push(word[i]);\\n        i++;\\n\\n    }\\n    if (word[word.length-1] === \\'a\\') res +=2;\\n    if (word[word.length-1] === \\'b\\') res++;\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction addMinimum(word) {\\n    if (word.length === 1) return 2;\\n    let res = 0;\\n    if (word[0] === \\'b\\') res++;\\n    if (word[0] === \\'c\\') res += 2;\\n    const stack = [word[0]];\\n    let i = 1;\\n    while (i < word.length) {\\n        const peek = stack[stack.length-1];\\n        if (peek === \\'a\\') {\\n            if (word[i] === \\'a\\') {\\n                res += 2;\\n            }\\n            else if (word[i] === \\'b\\'){\\n            } \\n            else {\\n                res++; \\n            }\\n        } else if (peek === \\'b\\') {\\n            if (word[i] === \\'a\\') {\\n                res++;\\n            }\\n            else if (word[i] === \\'b\\'){\\n                res += 2;\\n            } \\n            else {\\n                // res++;\\n            }\\n        } else {\\n            if (word[i] === \\'a\\') {\\n            }\\n            else if (word[i] === \\'b\\'){\\n                res++;\\n            } \\n            else {\\n                res += 2;\\n            }\\n        }\\n        stack.push(word[i]);\\n        i++;\\n\\n    }\\n    if (word[word.length-1] === \\'a\\') res +=2;\\n    if (word[word.length-1] === \\'b\\') res++;\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3864831,
                "title": "java-easy-solution-comparing-current-and-prev-characters",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        char prev = \\'c\\';\\n        int min = 0;\\n        for(char ch : word.toCharArray()) {\\n            if(ch == \\'a\\' && prev != \\'c\\') \\n                min += prev == \\'a\\' ? 2 : 1;\\n            else if(ch == \\'b\\' && prev != \\'a\\') \\n                min += prev == \\'c\\' ? 1: 2;\\n            else if(ch == \\'c\\' && prev != \\'b\\') \\n                min += prev == \\'c\\' ? 2 : 1;\\n            prev = ch;\\n        }\\n        if(prev == \\'c\\') return min;\\n        return prev == \\'a\\' ? min + 2 : min + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        char prev = \\'c\\';\\n        int min = 0;\\n        for(char ch : word.toCharArray()) {\\n            if(ch == \\'a\\' && prev != \\'c\\') \\n                min += prev == \\'a\\' ? 2 : 1;\\n            else if(ch == \\'b\\' && prev != \\'a\\') \\n                min += prev == \\'c\\' ? 1: 2;\\n            else if(ch == \\'c\\' && prev != \\'b\\') \\n                min += prev == \\'c\\' ? 2 : 1;\\n            prev = ch;\\n        }\\n        if(prev == \\'c\\') return min;\\n        return prev == \\'a\\' ? min + 2 : min + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856244,
                "title": "two-pointers-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        string s = \"abc\";\\n        int j=0,ct=0;\\n        for(int i=0;i<word.size();){\\n            if(s[j%3]==word[i]){\\n                j++;i++;\\n            }\\n            else {\\n                ct++;j++;\\n            }\\n        }\\n        \\n        ct+=(\\'c\\'-s[(j-1)%3]);\\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        string s = \"abc\";\\n        int j=0,ct=0;\\n        for(int i=0;i<word.size();){\\n            if(s[j%3]==word[i]){\\n                j++;i++;\\n            }\\n            else {\\n                ct++;j++;\\n            }\\n        }\\n        \\n        ct+=(\\'c\\'-s[(j-1)%3]);\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850898,
                "title": "understandable-java-solution-demonstrating-full-comprehension-of-ds-algo",
                "content": "Many other solutions floating around are correct but do not demonstrate a comprehensive understanding or mastery of the algorithms and data structures to a level that might be expected in an interview. They also suggest an approach or thought process that does not lead to any reliable way of solving such a problem cold in an interview.\\n# Intuition\\nRealize the problem is an optimization problem over a decision space of exponential size (branching factor at least 3), and note that a search over the problem space implemented with a simple recursion with backtracking implementation will yield a correct, albeit exponential runtime.\\nUsing your observation from #1, and your knowledge that greedy algorithms are often employed to efficiently optimize a set of decisions over even exponentially sized search trees, begin examining a set of \\'localized\\' choices that might exhibit the Greedy Choice Property\\nObserve that every valid solution modifies the problem space to a string that begins with \\'abc\\', therefore, the optimal solution must contain these set of localized steps. Use intuition to posit that one \\'choice\\' (set of local decisions) we can make would be to minimally append either an a,b,c to each of the initial characters until we arrive at \\'abc\\'. Perform a quick \\'proof\\' by contradiction in your head to gain confidence that no optimal solution excludes this minimal set of decisions. You have identified a choice that satisfies the Greedy Choice Property\\nRealize that the Greedy Choice you have identified leads to a substructure decomposition which is also an optimal substructure (no surprise there, but good to check)\\n\\n# Approach\\nUsing the \\'choice\\' you have identified as satisfying both the Greedy Choice Property and resolving the problem to an Optimal Substructure (you need those two things to proceed with confidence that your algorithm will actually work) implement a greedy algorithm using a combination of iteration and/or recursion, and use LinkedList backed stacks are your data structure to demonstrate additional mastery of data structures\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N) linear with respect to the number of characters in the word.\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        LinkedList<Character> wordStack = new LinkedList<Character>();\\n        for (Character c : word.toCharArray()) {\\n            wordStack.add(c);\\n        }\\n        LinkedList<Character> abcStack = new LinkedList<Character>();\\n\\n        int j = 0;\\n        while (!wordStack.isEmpty()) {\\n            abcStack.add(\\'a\\');\\n            abcStack.add(\\'b\\');\\n            abcStack.add(\\'c\\');\\n\\n            while (!abcStack.isEmpty() && !wordStack.isEmpty()) {\\n                char c = wordStack.remove(0).charValue();\\n                char i = abcStack.remove(0).charValue();\\n\\n                if (c != i) {\\n                    wordStack.add(0, c);\\n                    j++;\\n                }\\n            }\\n\\n        }\\n        return j + abcStack.size();\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        LinkedList<Character> wordStack = new LinkedList<Character>();\\n        for (Character c : word.toCharArray()) {\\n            wordStack.add(c);\\n        }\\n        LinkedList<Character> abcStack = new LinkedList<Character>();\\n\\n        int j = 0;\\n        while (!wordStack.isEmpty()) {\\n            abcStack.add(\\'a\\');\\n            abcStack.add(\\'b\\');\\n            abcStack.add(\\'c\\');\\n\\n            while (!abcStack.isEmpty() && !wordStack.isEmpty()) {\\n                char c = wordStack.remove(0).charValue();\\n                char i = abcStack.remove(0).charValue();\\n\\n                if (c != i) {\\n                    wordStack.add(0, c);\\n                    j++;\\n                }\\n            }\\n\\n        }\\n        return j + abcStack.size();\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3836083,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int n=word.length();\\n        int i=0;\\n        int leterRequre=0;\\n        while(i<n){\\n            int valid=0;\\n            if(word.charAt(i)==\\'a\\'){\\n                valid+=1;\\n                i++;\\n            }\\n            if(i<n && word.charAt(i) ==\\'b\\'){\\n                valid+=1;\\n                i++;\\n            }\\n            if(i<n && word.charAt(i)==\\'c\\'){\\n                valid+=1;\\n                i++;\\n            }\\n            leterRequre +=3-valid;\\n        }\\n        return leterRequre;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int n=word.length();\\n        int i=0;\\n        int leterRequre=0;\\n        while(i<n){\\n            int valid=0;\\n            if(word.charAt(i)==\\'a\\'){\\n                valid+=1;\\n                i++;\\n            }\\n            if(i<n && word.charAt(i) ==\\'b\\'){\\n                valid+=1;\\n                i++;\\n            }\\n            if(i<n && word.charAt(i)==\\'c\\'){\\n                valid+=1;\\n                i++;\\n            }\\n            leterRequre +=3-valid;\\n        }\\n        return leterRequre;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819083,
                "title": "greedy",
                "content": "```\\nint addMinimum(const string w)\\n{\\n\\tint out{};\\n\\tfor(int i{}; i<size(w); )\\n\\t\\tif(w[i+1]<=w[i])  \\n\\t\\t\\ti+=1, out+=2; \\n\\t\\telse if(w[i+2]<=w[i+1])  \\n\\t\\t\\ti+=2, out+=1;\\n\\t\\telse\\n\\t\\t\\ti+=3, out+=0;\\n\\treturn out;\\n}\\n```\\n||\\nHere `w[i+1]<=w[i]`\\n\\n![image](https://assets.leetcode.com/users/images/7535df7f-1c4f-4b84-914c-5efea6fc53d4_1690392467.1924953.png)\\n\\notherwise\\n\\n![image](https://assets.leetcode.com/users/images/3cc321cf-495f-4ffe-b837-0cf4dc7f3222_1690392987.6664252.png)\\n\\n```\\nint addMinimum(const string w)\\n{\\n\\tint n{};\\n\\tfor(int i{}; i<size(w); ++i)\\n\\t\\tn += w[i+1]<=w[i]; \\n\\treturn 3*n-size(w);\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint addMinimum(const string w)\\n{\\n\\tint out{};\\n\\tfor(int i{}; i<size(w); )\\n\\t\\tif(w[i+1]<=w[i])  \\n\\t\\t\\ti+=1, out+=2; \\n\\t\\telse if(w[i+2]<=w[i+1])  \\n\\t\\t\\ti+=2, out+=1;\\n\\t\\telse\\n\\t\\t\\ti+=3, out+=0;\\n\\treturn out;\\n}\\n```\n```\\nint addMinimum(const string w)\\n{\\n\\tint n{};\\n\\tfor(int i{}; i<size(w); ++i)\\n\\t\\tn += w[i+1]<=w[i]; \\n\\treturn 3*n-size(w);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3817888,
                "title": "o-n-time-o-1-space-solution",
                "content": "# Intuition\\nkeep tracking two string, one is the word and the other is \"abc\".\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n);\\n\\n- Space complexity:\\nO(1);\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n = word.length();\\n        int cur = 0, ans = 0;\\n        string temp = \"abc\";\\n        for(int i = 0; i< n; i++){\\n            if(word[i] == temp[cur])\\n                cur = (cur + 1)%3;\\n            else\\n            {\\n                if(word[i]<temp[cur]){\\n                    ans += 3 - (temp[cur] - word[i]); // word[i]<temp[cur]\\n                    cur = (cur + 3 - (temp[cur] - word[i]) + 1) %3;\\n                }\\n                else {\\n                // word[i]>temp[cur]\\n                ans += word[i] - temp[cur];\\n                cur = (cur + word[i] - temp[cur] + 1) %3;\\n                }\\n            }\\n        }\\n        \\n        if (word[n-1]!=\\'c\\') ans += \\'c\\' - word[n-1];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n = word.length();\\n        int cur = 0, ans = 0;\\n        string temp = \"abc\";\\n        for(int i = 0; i< n; i++){\\n            if(word[i] == temp[cur])\\n                cur = (cur + 1)%3;\\n            else\\n            {\\n                if(word[i]<temp[cur]){\\n                    ans += 3 - (temp[cur] - word[i]); // word[i]<temp[cur]\\n                    cur = (cur + 3 - (temp[cur] - word[i]) + 1) %3;\\n                }\\n                else {\\n                // word[i]>temp[cur]\\n                ans += word[i] - temp[cur];\\n                cur = (cur + word[i] - temp[cur] + 1) %3;\\n                }\\n            }\\n        }\\n        \\n        if (word[n-1]!=\\'c\\') ans += \\'c\\' - word[n-1];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796634,
                "title": "using-stack-datastruture",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing Stack datastructure .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nans=0\\n  Read each char from string \\n1 if char is \\'a\\' then \\n    if  stack is empty or top is \\'c\\'  then push \\'a\\' \\n    else if top is \\'b\\' then increment ans by 1 and push \\'c\\' and \\'a\\'.\\n    else if top is \\'a\\' then increment ans by 2 and push \\'b\\' and \\'c\\'.\\n\\n2 if char is \\'b\\' then\\n   if stack is empty or top is \\'c\\' then increnment ans by 1 push \\'a\\' and \\'b\\'.\\n    else if top is \\'a\\' then push \\'b\\'.\\n    else if top is \\'b\\' then increment ans by 2 and push \\'c\\'and \\'a\\'.\\n\\n3  if char is \\'c\\' then\\n    check similarly and increment the ans\\n \\nafter completion of loop (the last char should be ends with \\'c\\')\\n if top of the stack is a then increment the ans by 2 \\n else if top of the stack is b then increment the ans by 1\\n   \\nreturn ans;\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String s) {\\n        Stack<Character> st=new Stack<>();\\n        int max=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'a\\')\\n            {\\n            if(st.isEmpty()||st.peek()==\\'c\\')\\n            {\\n              st.push(s.charAt(i));\\n            }\\n            else if(st.peek()==\\'b\\')\\n            {\\n              max++;\\n                st.push(\\'c\\');\\n                st.push(s.charAt(i));\\n            }\\n            else if(st.peek()==\\'a\\')\\n            {\\n                max+=2;\\n                st.push(\\'b\\');\\n                st.push(\\'c\\');\\n                st.push(s.charAt(i));\\n            }\\n            }\\n            else if(s.charAt(i)==\\'b\\')\\n            {\\n                  if(st.isEmpty()||st.peek()==\\'c\\')\\n                  {\\n                      max++;\\n                      st.push(\\'a\\');\\n                    st.push(s.charAt(i));\\n                  }\\n                 else if(st.peek()==\\'a\\')\\n                  {\\n                    st.push(s.charAt(i));\\n                  }\\n                 else if(st.peek()==\\'b\\')\\n                 {\\n                    max+=2;\\n                    st.push(\\'c\\');\\n                    st.push(\\'a\\');\\n                   st.push(s.charAt(i));\\n                 }\\n            }\\n            else {\\n                 if(st.isEmpty()||st.peek()==\\'c\\')\\n                  {\\n                      max+=2;\\n                      st.push(\\'a\\');\\n                      st.push(\\'b\\');\\n                    st.push(s.charAt(i));\\n                   }\\n                  else if(st.peek()==\\'b\\')\\n                  {\\n                    st.push(s.charAt(i));\\n                   }\\n                  else if(st.peek()==\\'a\\')\\n                  {\\n                    max++;\\n                    st.push(\\'b\\');\\n                    st.push(s.charAt(i));\\n                  }\\n            }\\n        }\\n        if(st.peek()==\\'a\\')\\n        {\\n            max+=2;\\n            st.push(\\'b\\');\\n            st.push(\\'c\\');\\n        }\\n        else if(st.peek()==\\'b\\')\\n        {\\n            max++;\\n            st.push(\\'c\\');\\n        }\\n        return max;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String s) {\\n        Stack<Character> st=new Stack<>();\\n        int max=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'a\\')\\n            {\\n            if(st.isEmpty()||st.peek()==\\'c\\')\\n            {\\n              st.push(s.charAt(i));\\n            }\\n            else if(st.peek()==\\'b\\')\\n            {\\n              max++;\\n                st.push(\\'c\\');\\n                st.push(s.charAt(i));\\n            }\\n            else if(st.peek()==\\'a\\')\\n            {\\n                max+=2;\\n                st.push(\\'b\\');\\n                st.push(\\'c\\');\\n                st.push(s.charAt(i));\\n            }\\n            }\\n            else if(s.charAt(i)==\\'b\\')\\n            {\\n                  if(st.isEmpty()||st.peek()==\\'c\\')\\n                  {\\n                      max++;\\n                      st.push(\\'a\\');\\n                    st.push(s.charAt(i));\\n                  }\\n                 else if(st.peek()==\\'a\\')\\n                  {\\n                    st.push(s.charAt(i));\\n                  }\\n                 else if(st.peek()==\\'b\\')\\n                 {\\n                    max+=2;\\n                    st.push(\\'c\\');\\n                    st.push(\\'a\\');\\n                   st.push(s.charAt(i));\\n                 }\\n            }\\n            else {\\n                 if(st.isEmpty()||st.peek()==\\'c\\')\\n                  {\\n                      max+=2;\\n                      st.push(\\'a\\');\\n                      st.push(\\'b\\');\\n                    st.push(s.charAt(i));\\n                   }\\n                  else if(st.peek()==\\'b\\')\\n                  {\\n                    st.push(s.charAt(i));\\n                   }\\n                  else if(st.peek()==\\'a\\')\\n                  {\\n                    max++;\\n                    st.push(\\'b\\');\\n                    st.push(s.charAt(i));\\n                  }\\n            }\\n        }\\n        if(st.peek()==\\'a\\')\\n        {\\n            max+=2;\\n            st.push(\\'b\\');\\n            st.push(\\'c\\');\\n        }\\n        else if(st.peek()==\\'b\\')\\n        {\\n            max++;\\n            st.push(\\'c\\');\\n        }\\n        return max;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794486,
                "title": "beginner-friendly-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        \\n        \\'\\'\\'\\n        a -> a = 2\\n        b -> b = 2\\n        c -> c = 2\\n        a -> c = 1\\n        b -> a = 1\\n        c -> b = 1\\n        \\'\\'\\'\\n        st = []\\n        p = 0\\n        for i in range(len(word)):\\n            if st and ord(st[-1]) == ord(word[i]):\\n                p += 2 \\n            elif st and ord(st[-1]) == ord(word[i])-2:\\n                p += 1\\n            elif st and ord(st[-1])-1 == ord(word[i]):\\n                p += 1\\n            st.append(word[i])\\n           \\n        if word[0] == \\'b\\':\\n            p += 1\\n        elif word[0] == \\'c\\':\\n            p += 2\\n        if word[-1] == \\'a\\':\\n            p += 2\\n        elif word[-1] == \\'b\\':\\n            p += 1\\n        return p\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addMinimum(self, word: str) -> int:\\n        \\n        \\'\\'\\'\\n        a -> a = 2\\n        b -> b = 2\\n        c -> c = 2\\n        a -> c = 1\\n        b -> a = 1\\n        c -> b = 1\\n        \\'\\'\\'\\n        st = []\\n        p = 0\\n        for i in range(len(word)):\\n            if st and ord(st[-1]) == ord(word[i]):\\n                p += 2 \\n            elif st and ord(st[-1]) == ord(word[i])-2:\\n                p += 1\\n            elif st and ord(st[-1])-1 == ord(word[i]):\\n                p += 1\\n            st.append(word[i])\\n           \\n        if word[0] == \\'b\\':\\n            p += 1\\n        elif word[0] == \\'c\\':\\n            p += 2\\n        if word[-1] == \\'a\\':\\n            p += 2\\n        elif word[-1] == \\'b\\':\\n            p += 1\\n        return p\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3792582,
                "title": "six-if-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        char prev = \\'c\\';\\n        int l = 0;\\n        int count = 0;\\n        while(!(l == word.size() && prev == \\'c\\')) {\\n            if (prev == \\'c\\' && word[l] != \\'a\\') {\\n                count++;\\n                prev = \\'a\\';\\n            } else if (prev == \\'a\\' && word[l] != \\'b\\') {\\n                count++;\\n                prev = \\'b\\';\\n            } else if (prev == \\'b\\' && word[l] != \\'c\\') {\\n                count++;\\n                prev = \\'c\\';\\n            } else if (prev == \\'c\\' && word[l] == \\'a\\') {\\n                l++;\\n                prev = \\'a\\';\\n            } else if (prev == \\'a\\' && word[l] == \\'b\\') {\\n                l++;\\n                prev = \\'b\\';\\n            } else if (prev == \\'b\\' && word[l] == \\'c\\') {\\n                l++;\\n                prev = \\'c\\';\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        char prev = \\'c\\';\\n        int l = 0;\\n        int count = 0;\\n        while(!(l == word.size() && prev == \\'c\\')) {\\n            if (prev == \\'c\\' && word[l] != \\'a\\') {\\n                count++;\\n                prev = \\'a\\';\\n            } else if (prev == \\'a\\' && word[l] != \\'b\\') {\\n                count++;\\n                prev = \\'b\\';\\n            } else if (prev == \\'b\\' && word[l] != \\'c\\') {\\n                count++;\\n                prev = \\'c\\';\\n            } else if (prev == \\'c\\' && word[l] == \\'a\\') {\\n                l++;\\n                prev = \\'a\\';\\n            } else if (prev == \\'a\\' && word[l] == \\'b\\') {\\n                l++;\\n                prev = \\'b\\';\\n            } else if (prev == \\'b\\' && word[l] == \\'c\\') {\\n                l++;\\n                prev = \\'c\\';\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3787888,
                "title": "easy-greedy-solution-linear-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        \\n        int sum=int(word[0]-\\'0\\')-49,n=word.size();\\n         \\n        for(int i=1;i<n;i++)\\n        {\\n                //for each pair of sequential indices take their difference\\n            int diff=int(word[i-1]-\\'0\\')-int(word[i]-\\'0\\');\\n            //if difference is 0 then we have to add 2 characters \\n            //else if difference is 1 or -2 (i.e ba,cb,ac) add 1\\n           //charater in the gap \\n            if(!diff)\\n                sum+=2;\\n            else if(diff==1|| diff==-2)\\n                sum+=1;\\n\\n        }\\n        \\n        sum+=2-(int(word[n-1]-\\'0\\')-49);\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        \\n        int sum=int(word[0]-\\'0\\')-49,n=word.size();\\n         \\n        for(int i=1;i<n;i++)\\n        {\\n                //for each pair of sequential indices take their difference\\n            int diff=int(word[i-1]-\\'0\\')-int(word[i]-\\'0\\');\\n            //if difference is 0 then we have to add 2 characters \\n            //else if difference is 1 or -2 (i.e ba,cb,ac) add 1\\n           //charater in the gap \\n            if(!diff)\\n                sum+=2;\\n            else if(diff==1|| diff==-2)\\n                sum+=1;\\n\\n        }\\n        \\n        sum+=2-(int(word[n-1]-\\'0\\')-49);\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779702,
                "title": "c-two-pointer-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        string s=\"abc\";\\n        int i=0,j=0;\\n        int ans=0;\\n        while(j<word.size()){\\n            if(s[i]==word[j]){\\n                i++;\\n                j++;\\n            }\\n            else{\\n                ans++;\\n                i++;\\n            }\\n            i=i%3;\\n        }\\n        if(i!=0)\\n        ans=ans+(3-i);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        string s=\"abc\";\\n        int i=0,j=0;\\n        int ans=0;\\n        while(j<word.size()){\\n            if(s[i]==word[j]){\\n                i++;\\n                j++;\\n            }\\n            else{\\n                ans++;\\n                i++;\\n            }\\n            i=i%3;\\n        }\\n        if(i!=0)\\n        ans=ans+(3-i);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768595,
                "title": "simple-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n = word.size();\\n        int cnt = 0;\\n        if(word[0]==\\'b\\') cnt+=1;\\n        if(word[0]==\\'c\\') cnt+=2;\\n        for(int i = 1;i<n;i++)\\n        {\\n            if(word[i]==\\'a\\')\\n            {\\n                if(word[i-1]==\\'a\\')\\n                    cnt+=2;\\n                else if(word[i-1]==\\'b\\')\\n                    cnt+=1;\\n                    \\n            }\\n            else if(word[i]==\\'b\\')\\n            {\\n                if(word[i-1]==\\'b\\')\\n                    cnt+=2;\\n                else if(word[i-1]==\\'c\\')\\n                    cnt+=1;\\n            }\\n            else\\n            {\\n                if(word[i-1]==\\'a\\')\\n                    cnt+=1;\\n                else if(word[i-1]==\\'c\\')\\n                    cnt+=2;\\n            }\\n                \\n        }\\n        \\n        if(word[n-1]==\\'a\\') return cnt+2;\\n        \\n        if(word[n-1]==\\'b\\') return cnt+1;\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n = word.size();\\n        int cnt = 0;\\n        if(word[0]==\\'b\\') cnt+=1;\\n        if(word[0]==\\'c\\') cnt+=2;\\n        for(int i = 1;i<n;i++)\\n        {\\n            if(word[i]==\\'a\\')\\n            {\\n                if(word[i-1]==\\'a\\')\\n                    cnt+=2;\\n                else if(word[i-1]==\\'b\\')\\n                    cnt+=1;\\n                    \\n            }\\n            else if(word[i]==\\'b\\')\\n            {\\n                if(word[i-1]==\\'b\\')\\n                    cnt+=2;\\n                else if(word[i-1]==\\'c\\')\\n                    cnt+=1;\\n            }\\n            else\\n            {\\n                if(word[i-1]==\\'a\\')\\n                    cnt+=1;\\n                else if(word[i-1]==\\'c\\')\\n                    cnt+=2;\\n            }\\n                \\n        }\\n        \\n        if(word[n-1]==\\'a\\') return cnt+2;\\n        \\n        if(word[n-1]==\\'b\\') return cnt+1;\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757814,
                "title": "c-solution-one-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        stack<char> st;\\n\\n        for(int i = 0; i < word.length(); i++) {\\n            if(st.empty()) {\\n                if(word[i] == \\'a\\') {\\n                    st.push(\\'a\\');\\n                } else if (word[i] == \\'b\\') {\\n                    st.push(\\'a\\');\\n                    st.push(\\'b\\');\\n                } else {\\n                    st.push(\\'a\\');\\n                    st.push(\\'b\\');\\n                    st.push(\\'c\\');\\n                }\\n            } else {\\n                char chtop = st.top();\\n                if(chtop == \\'b\\') {\\n                    if(word[i] == \\'a\\') {\\n                        st.push(\\'c\\');\\n                        st.push(\\'a\\');\\n                    } else if(word[i] == \\'b\\') {\\n                        st.push(\\'c\\');\\n                        st.push(\\'a\\');\\n                        st.push(\\'b\\');\\n                    } else {\\n                        st.push(\\'c\\');\\n                    }\\n                } else if(chtop == \\'a\\') {\\n                    if(word[i] == \\'a\\') {\\n                        st.push(\\'b\\');\\n                        st.push(\\'c\\');\\n                        st.push(\\'a\\');\\n                    } else if(word[i] == \\'b\\') {\\n                        st.push(\\'b\\');\\n                    } else {\\n                        st.push(\\'b\\');\\n                        st.push(\\'c\\');\\n                    }\\n                } else if(chtop == \\'c\\') {\\n                    if(word[i] == \\'b\\') {\\n                        st.push(\\'a\\');\\n                        st.push(\\'b\\');\\n                    } else if(word[i] == \\'a\\') {\\n                        st.push(\\'a\\');\\n                    } else {\\n                        st.push(\\'a\\');\\n                        st.push(\\'b\\');\\n                        st.push(\\'c\\');\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if(st.top() == \\'a\\') {\\n            st.push(\\'b\\');\\n            st.push(\\'c\\');\\n        } else if(st.top() == \\'b\\') {\\n            st.push(\\'c\\');\\n        }\\n\\n        int size = st.size() - word.length();\\n        return size;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        stack<char> st;\\n\\n        for(int i = 0; i < word.length(); i++) {\\n            if(st.empty()) {\\n                if(word[i] == \\'a\\') {\\n                    st.push(\\'a\\');\\n                } else if (word[i] == \\'b\\') {\\n                    st.push(\\'a\\');\\n                    st.push(\\'b\\');\\n                } else {\\n                    st.push(\\'a\\');\\n                    st.push(\\'b\\');\\n                    st.push(\\'c\\');\\n                }\\n            } else {\\n                char chtop = st.top();\\n                if(chtop == \\'b\\') {\\n                    if(word[i] == \\'a\\') {\\n                        st.push(\\'c\\');\\n                        st.push(\\'a\\');\\n                    } else if(word[i] == \\'b\\') {\\n                        st.push(\\'c\\');\\n                        st.push(\\'a\\');\\n                        st.push(\\'b\\');\\n                    } else {\\n                        st.push(\\'c\\');\\n                    }\\n                } else if(chtop == \\'a\\') {\\n                    if(word[i] == \\'a\\') {\\n                        st.push(\\'b\\');\\n                        st.push(\\'c\\');\\n                        st.push(\\'a\\');\\n                    } else if(word[i] == \\'b\\') {\\n                        st.push(\\'b\\');\\n                    } else {\\n                        st.push(\\'b\\');\\n                        st.push(\\'c\\');\\n                    }\\n                } else if(chtop == \\'c\\') {\\n                    if(word[i] == \\'b\\') {\\n                        st.push(\\'a\\');\\n                        st.push(\\'b\\');\\n                    } else if(word[i] == \\'a\\') {\\n                        st.push(\\'a\\');\\n                    } else {\\n                        st.push(\\'a\\');\\n                        st.push(\\'b\\');\\n                        st.push(\\'c\\');\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if(st.top() == \\'a\\') {\\n            st.push(\\'b\\');\\n            st.push(\\'c\\');\\n        } else if(st.top() == \\'b\\') {\\n            st.push(\\'c\\');\\n        }\\n\\n        int size = st.size() - word.length();\\n        return size;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745920,
                "title": "smartest-solution-available-mind-blown",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n=word.length();\\n        int ct=0,i=0;\\n        for(i=0;i<n-2;){\\n            if(word[i]==\\'a\\'){\\n                if(word[i+1]==\\'b\\' && word[i+2]==\\'c\\') i+=3;\\n                else if(word[i+1]==\\'b\\'){\\n                  ct+=1; i+=2;\\n                }\\n                else if(word[i+1]==\\'c\\'){\\n                    ct+=1; i+=2;\\n                }\\n                else if(word[i+1]==\\'a\\'){\\n                    ct+=2; i+=1;\\n                }\\n            }\\n            else if(word[i]==\\'b\\'){\\n                if(word[i+1]==\\'c\\'){\\n                    ct+=1; i+=2;\\n                }\\n                else if(word[i+1]==\\'a\\' || word[i+1]==\\'b\\'){\\n                    ct+=2; i+=1;\\n                }\\n            }\\n            else if(word[i]==\\'c\\'){\\n                ct+=2; i+=1;\\n            }\\n        }\\n        if(i>=n) return ct;\\n        else{\\n            if(i==n-2){\\n                if(word[i]==word[i+1]) ct+=4;\\n                else if(word[i]==\\'a\\' && (word[i+1]==\\'b\\' || word[i+1]==\\'c\\')) ct+=1;\\n                else if(word[i]==\\'b\\' && word[i+1]==\\'c\\') ct+=1;\\n                else if(word[i]==\\'b\\' && word[i+1]==\\'a\\') ct+=4;\\n                else if(word[i]==\\'c\\') ct+=4;\\n            }\\n            else{\\n                ct+=2;\\n            }\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int n=word.length();\\n        int ct=0,i=0;\\n        for(i=0;i<n-2;){\\n            if(word[i]==\\'a\\'){\\n                if(word[i+1]==\\'b\\' && word[i+2]==\\'c\\') i+=3;\\n                else if(word[i+1]==\\'b\\'){\\n                  ct+=1; i+=2;\\n                }\\n                else if(word[i+1]==\\'c\\'){\\n                    ct+=1; i+=2;\\n                }\\n                else if(word[i+1]==\\'a\\'){\\n                    ct+=2; i+=1;\\n                }\\n            }\\n            else if(word[i]==\\'b\\'){\\n                if(word[i+1]==\\'c\\'){\\n                    ct+=1; i+=2;\\n                }\\n                else if(word[i+1]==\\'a\\' || word[i+1]==\\'b\\'){\\n                    ct+=2; i+=1;\\n                }\\n            }\\n            else if(word[i]==\\'c\\'){\\n                ct+=2; i+=1;\\n            }\\n        }\\n        if(i>=n) return ct;\\n        else{\\n            if(i==n-2){\\n                if(word[i]==word[i+1]) ct+=4;\\n                else if(word[i]==\\'a\\' && (word[i+1]==\\'b\\' || word[i+1]==\\'c\\')) ct+=1;\\n                else if(word[i]==\\'b\\' && word[i+1]==\\'c\\') ct+=1;\\n                else if(word[i]==\\'b\\' && word[i+1]==\\'a\\') ct+=4;\\n                else if(word[i]==\\'c\\') ct+=4;\\n            }\\n            else{\\n                ct+=2;\\n            }\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743394,
                "title": "simplest-c-ans-sooo-easy",
                "content": "# Intiuition\\nwe know that in the expected string the ans will always be of the format \"abcabc..\"\\nso our first letter should be \\'a\\' \\nif its \\'a\\' we can check the next letter\\nif its not \\'a\\' we can increase sum by 1 bcz we know in the word[0] position the expected string will be \\'a\\'\\n\\nsimilarly we know word[1]=\\'b\\' no matter what \\nif its \\'b\\' we can check the next letter\\nif its not we have to increment sum\\n\\n\\napply same logic for \\'c\\' as well\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int sum=0,n=word.length();\\n        for(int i=0;i<n;)\\n        {\\n            if(word[i]==\\'a\\') i++;\\n            else sum++;\\n            if(word[i]==\\'b\\') i++;\\n            else sum++;\\n            if(word[i]==\\'c\\') i++;\\n            else sum++;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int sum=0,n=word.length();\\n        for(int i=0;i<n;)\\n        {\\n            if(word[i]==\\'a\\') i++;\\n            else sum++;\\n            if(word[i]==\\'b\\') i++;\\n            else sum++;\\n            if(word[i]==\\'c\\') i++;\\n            else sum++;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740810,
                "title": "simple-java-solution-bruteforce-using-subsequence",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        String s=\"\";\\n        for(int i=0;i<word.length();i++){\\n            if(!isSubsequence(word,s)){\\n                s+=\"abc\";\\n            }\\n        }\\n        return s.length()-word.length();\\n    }\\n    public boolean isSubsequence(String s, String t) {\\n        int z=0;\\n        if(s.isEmpty()){\\n            return true;\\n        }\\n        for(int i=0;i<t.length() && z<s.length();i++){\\n            if(s.charAt(z)==t.charAt(i)){\\n                z++;\\n            }\\n            if(z==s.length()){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        String s=\"\";\\n        for(int i=0;i<word.length();i++){\\n            if(!isSubsequence(word,s)){\\n                s+=\"abc\";\\n            }\\n        }\\n        return s.length()-word.length();\\n    }\\n    public boolean isSubsequence(String s, String t) {\\n        int z=0;\\n        if(s.isEmpty()){\\n            return true;\\n        }\\n        for(int i=0;i<t.length() && z<s.length();i++){\\n            if(s.charAt(z)==t.charAt(i)){\\n                z++;\\n            }\\n            if(z==s.length()){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729421,
                "title": "python-greedy-question-specific-and-generic-approach",
                "content": "# The Question Specific (and very bad) approach:\\nThis is DSA\\'s equivalent of hard coding in values and using \"magic numbers\". The solution is not scalable, and will fail at the smallest change of conditions. The values used here are specific to the constraints of this question, where the only three letters involved are \"a\", \"b\", \"c\". Even though solving for \"b\", \"c\", \"d\" should be the same, our solution will fail at it, or any other slightest change to the input type. \\n\\nThese relations have been attained by drawing all the possible test cases on a notebook, and noting down the answers themeselves.\\n\\n```\\ndef add_minimum(word: str) -> int:\\n    n = len(word)\\n    if (first := word[0]) == \"a\":\\n        ans = 0\\n    elif first == \"b\":\\n        ans = 1\\n    else:\\n        ans = 2\\n\\n    for i in range(1, n):\\n        if word[i] == word[i - 1]:\\n            ans += 2\\n        elif (word[i - 1], word[i]) in ((\"a\", \"b\"), (\"b\", \"c\"), (\"c\", \"a\")):\\n            continue\\n        else:\\n            ans += 1\\n\\n    if word[-1] == \"a\":\\n        ans += 2\\n    elif word[-1] == \"b\":\\n        ans += 1\\n\\n    return ans\\n\\n```\\n\\n# Generic Approach:\\nThis is a better and more sturdy solution to this problem. It is scalable, and will provide correct answers for any number of letters, starting from wherever in the alphabet, as long as all of them are in increasing order. We can adjust ```base``` to modify the starting letter, and pass in the number of letters that the string may have.\\n\\nThese equations have been attained by writing the test cases on a notebook, and finding the *general relations* between the input and the output, instead of directly noting down the answers.\\n\\nWe can further improve scalability by allowing letters to loop around after \"Z\", but I\\'ll leave that as an exercise to you.\\n\\nEg- ```base = ord(\"a\")``` with ```n_letters = 3``` will cover ```(\"a\",\"b\",\"c\")```, whereas \\n```base = ord(\"m\")``` with ```n_letters = 5``` will cover ```(\"m\",\"n\",\"o\",\"p\",\"q\")``` and so on.\\n```\\ndef add_minimum_generic(word: str, base: str, n_letters: int) -> int:\\n    # Base is a mono-character string\\n\\n    n = len(word)\\n    base = ord(base)\\n\\n    ans = ord(word[0]) - base\\n    for i in range(1, n):\\n        if word[i] == word[i - 1]:\\n            ans += n_letters - 1\\n        else:\\n            ans += (ord(word[i]) + n_letters - ord(word[i - 1])) % n_letters - 1\\n\\n    ans += base + n_letters - ord(word[-1]) - 1\\n    return ans\\n```\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N), since we\\'re iterating through the word just once.\\n- Space complexity:\\nO(1), since we\\'re using constant space.",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "String",
                    "Greedy"
                ],
                "code": "```\\ndef add_minimum(word: str) -> int:\\n    n = len(word)\\n    if (first := word[0]) == \"a\":\\n        ans = 0\\n    elif first == \"b\":\\n        ans = 1\\n    else:\\n        ans = 2\\n\\n    for i in range(1, n):\\n        if word[i] == word[i - 1]:\\n            ans += 2\\n        elif (word[i - 1], word[i]) in ((\"a\", \"b\"), (\"b\", \"c\"), (\"c\", \"a\")):\\n            continue\\n        else:\\n            ans += 1\\n\\n    if word[-1] == \"a\":\\n        ans += 2\\n    elif word[-1] == \"b\":\\n        ans += 1\\n\\n    return ans\\n\\n```\n```base```\n```base = ord(\"a\")```\n```n_letters = 3```\n```(\"a\",\"b\",\"c\")```\n```base = ord(\"m\")```\n```n_letters = 5```\n```(\"m\",\"n\",\"o\",\"p\",\"q\")```\n```\\ndef add_minimum_generic(word: str, base: str, n_letters: int) -> int:\\n    # Base is a mono-character string\\n\\n    n = len(word)\\n    base = ord(base)\\n\\n    ans = ord(word[0]) - base\\n    for i in range(1, n):\\n        if word[i] == word[i - 1]:\\n            ans += n_letters - 1\\n        else:\\n            ans += (ord(word[i]) + n_letters - ord(word[i - 1])) % n_letters - 1\\n\\n    ans += base + n_letters - ord(word[-1]) - 1\\n    return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3728680,
                "title": "masum-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        stack<char>st;\\n        for(int i=0;i<word.size();i++)\\n        {\\n            st.push(word[i]);\\n        }\\n        int count=0;\\n        while(!st.empty())\\n        {\\n            if(!st.empty() && st.top()==\\'c\\')\\n            {\\n                st.pop();\\n            }\\n            else\\n            {\\n                count++;\\n            }\\n\\n            if(!st.empty() && st.top()==\\'b\\')\\n            {\\n                st.pop();\\n            }\\n            else\\n            {\\n                count++;\\n            }\\n\\n            if(!st.empty() && st.top()==\\'a\\')\\n            {\\n                st.pop();\\n            }\\n            else\\n            {\\n                count++;\\n            }\\n            if(st.empty())\\n            {\\n                break;\\n            }\\n        }\\n        return count;\\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        stack<char>st;\\n        for(int i=0;i<word.size();i++)\\n        {\\n            st.push(word[i]);\\n        }\\n        int count=0;\\n        while(!st.empty())\\n        {\\n            if(!st.empty() && st.top()==\\'c\\')\\n            {\\n                st.pop();\\n            }\\n            else\\n            {\\n                count++;\\n            }\\n\\n            if(!st.empty() && st.top()==\\'b\\')\\n            {\\n                st.pop();\\n            }\\n            else\\n            {\\n                count++;\\n            }\\n\\n            if(!st.empty() && st.top()==\\'a\\')\\n            {\\n                st.pop();\\n            }\\n            else\\n            {\\n                count++;\\n            }\\n            if(st.empty())\\n            {\\n                break;\\n            }\\n        }\\n        return count;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711797,
                "title": "solved-using-easy-implementation-of-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int count=0;\\n        stack<char>s;\\n        if(word[0]==\\'a\\'){\\n            s.push(word[0]);\\n        }\\n        else if(word[0]==\\'b\\'){\\n            count++;\\n            s.push(word[0]);\\n        }\\n        else if(word[0]==\\'c\\'){\\n            count += 2;\\n            s.push(word[0]);\\n        }\\n        for(int i=1;i<word.size();i++){\\n            if(word[i]==\\'a\\'){\\n                if(s.top()==\\'b\\'){\\n                    count++;\\n                    s.push(word[i]);\\n                }\\n                else if(s.top()==\\'a\\'){\\n                    count += 2;\\n                    s.push(word[i]);\\n                }\\n                else{\\n                    s.push(word[i]);\\n                }\\n            }\\n            else if(word[i]==\\'b\\'){\\n                if(s.top()==\\'c\\'){\\n                    count++;\\n                    s.push(word[i]);\\n                }\\n                else if(s.top()==\\'b\\'){\\n                    count += 2;\\n                    s.push(word[i]);\\n                }\\n                else{\\n                    s.push(word[i]);\\n                }\\n            }\\n            else if(word[i]==\\'c\\'){\\n                if(s.top()==\\'a\\'){\\n                    count++;\\n                    s.push(word[i]);\\n                }\\n                else if(s.top()==\\'c\\'){\\n                    count += 2;\\n                    s.push(word[i]);\\n                }\\n                else{\\n                    s.push(word[i]);\\n                }\\n            }\\n        }\\n        if(word[word.size()-1]==\\'b\\'){\\n            count++;\\n        }\\n        else if(word[word.size()-1]==\\'a\\'){\\n            count += 2;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int count=0;\\n        stack<char>s;\\n        if(word[0]==\\'a\\'){\\n            s.push(word[0]);\\n        }\\n        else if(word[0]==\\'b\\'){\\n            count++;\\n            s.push(word[0]);\\n        }\\n        else if(word[0]==\\'c\\'){\\n            count += 2;\\n            s.push(word[0]);\\n        }\\n        for(int i=1;i<word.size();i++){\\n            if(word[i]==\\'a\\'){\\n                if(s.top()==\\'b\\'){\\n                    count++;\\n                    s.push(word[i]);\\n                }\\n                else if(s.top()==\\'a\\'){\\n                    count += 2;\\n                    s.push(word[i]);\\n                }\\n                else{\\n                    s.push(word[i]);\\n                }\\n            }\\n            else if(word[i]==\\'b\\'){\\n                if(s.top()==\\'c\\'){\\n                    count++;\\n                    s.push(word[i]);\\n                }\\n                else if(s.top()==\\'b\\'){\\n                    count += 2;\\n                    s.push(word[i]);\\n                }\\n                else{\\n                    s.push(word[i]);\\n                }\\n            }\\n            else if(word[i]==\\'c\\'){\\n                if(s.top()==\\'a\\'){\\n                    count++;\\n                    s.push(word[i]);\\n                }\\n                else if(s.top()==\\'c\\'){\\n                    count += 2;\\n                    s.push(word[i]);\\n                }\\n                else{\\n                    s.push(word[i]);\\n                }\\n            }\\n        }\\n        if(word[word.size()-1]==\\'b\\'){\\n            count++;\\n        }\\n        else if(word[word.size()-1]==\\'a\\'){\\n            count += 2;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3700047,
                "title": "c-stack-usage",
                "content": "# Intuition\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n       stack<char>st;\\n       for(auto it:word){\\n           st.push(it);\\n       }\\n       int count=0;\\n       while(!st.empty()){\\n           if(!st.empty() && st.top()==\\'c\\'){\\n               st.pop();\\n           }\\n           else{\\n               count++;\\n           }\\n           if(!st.empty() && st.top()==\\'b\\'){\\n               st.pop();\\n           }\\n           else{\\n               count++;\\n           }\\n           if(!st.empty() && st.top()==\\'a\\'){\\n               st.pop();\\n           }\\n           else{\\n               count++;\\n           }\\n           if(st.empty()){\\n               break;\\n           }\\n       }\\n       return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n       stack<char>st;\\n       for(auto it:word){\\n           st.push(it);\\n       }\\n       int count=0;\\n       while(!st.empty()){\\n           if(!st.empty() && st.top()==\\'c\\'){\\n               st.pop();\\n           }\\n           else{\\n               count++;\\n           }\\n           if(!st.empty() && st.top()==\\'b\\'){\\n               st.pop();\\n           }\\n           else{\\n               count++;\\n           }\\n           if(!st.empty() && st.top()==\\'a\\'){\\n               st.pop();\\n           }\\n           else{\\n               count++;\\n           }\\n           if(st.empty()){\\n               break;\\n           }\\n       }\\n       return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697791,
                "title": "solution-for-idiots-like-me-stack-c-beats-96",
                "content": "# Intuition\\nPushing word to Stack, then popping every char increasing counter, depending on letter. \\n\\n# Approach\\n\\n# Complexity\\n\\n# Code\\n```\\npublic class Solution {\\n    public int AddMinimum(string word) {\\n        int counter = 0;\\n        Stack<char> abc = new Stack<char>();\\n        abc.Push(\\'a\\');\\n        abc.Push(\\'b\\');\\n        abc.Push(\\'c\\');\\n        foreach(char c in word){\\n            abc.Push(c);\\n        }\\n        if(abc.Peek() == \\'a\\'){\\n            abc.Push(\\'b\\');\\n            abc.Push(\\'c\\');\\n            counter += 2;\\n        }\\n        if(abc.Peek() == \\'b\\'){\\n            abc.Push(\\'c\\');\\n            counter ++;\\n        }\\n        while(abc.Count > 2){\\n            if(abc.Peek() == \\'c\\'){\\n                abc.Pop();\\n                if(abc.Peek() == \\'a\\'){\\n                    counter++;\\n                    continue;\\n                }\\n                if(abc.Peek() == \\'c\\'){\\n                    counter += 2;\\n                    continue;\\n                }\\n                if(abc.Peek() == \\'b\\'){\\n                    continue;\\n                }\\n            }\\n            if(abc.Peek() == \\'b\\'){\\n                abc.Pop();\\n                if(abc.Peek() == \\'a\\'){\\n                    continue;\\n                }\\n                if(abc.Peek() == \\'c\\'){\\n                    counter++;\\n                    continue;\\n                }\\n                if(abc.Peek() == \\'b\\'){\\n                    counter += 2;\\n                    continue;\\n                }\\n            }\\n            if(abc.Peek() == \\'a\\'){\\n                abc.Pop();\\n                if(abc.Peek() == \\'c\\'){\\n                    continue;\\n                }\\n                if(abc.Peek() == \\'b\\'){\\n                    counter++;\\n                    continue;\\n                }\\n                if(abc.Peek() == \\'a\\'){\\n                    counter += 2;\\n                    continue;\\n                }\\n            }\\n        }\\n    return(counter);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Stack"
                ],
                "code": "```\\npublic class Solution {\\n    public int AddMinimum(string word) {\\n        int counter = 0;\\n        Stack<char> abc = new Stack<char>();\\n        abc.Push(\\'a\\');\\n        abc.Push(\\'b\\');\\n        abc.Push(\\'c\\');\\n        foreach(char c in word){\\n            abc.Push(c);\\n        }\\n        if(abc.Peek() == \\'a\\'){\\n            abc.Push(\\'b\\');\\n            abc.Push(\\'c\\');\\n            counter += 2;\\n        }\\n        if(abc.Peek() == \\'b\\'){\\n            abc.Push(\\'c\\');\\n            counter ++;\\n        }\\n        while(abc.Count > 2){\\n            if(abc.Peek() == \\'c\\'){\\n                abc.Pop();\\n                if(abc.Peek() == \\'a\\'){\\n                    counter++;\\n                    continue;\\n                }\\n                if(abc.Peek() == \\'c\\'){\\n                    counter += 2;\\n                    continue;\\n                }\\n                if(abc.Peek() == \\'b\\'){\\n                    continue;\\n                }\\n            }\\n            if(abc.Peek() == \\'b\\'){\\n                abc.Pop();\\n                if(abc.Peek() == \\'a\\'){\\n                    continue;\\n                }\\n                if(abc.Peek() == \\'c\\'){\\n                    counter++;\\n                    continue;\\n                }\\n                if(abc.Peek() == \\'b\\'){\\n                    counter += 2;\\n                    continue;\\n                }\\n            }\\n            if(abc.Peek() == \\'a\\'){\\n                abc.Pop();\\n                if(abc.Peek() == \\'c\\'){\\n                    continue;\\n                }\\n                if(abc.Peek() == \\'b\\'){\\n                    counter++;\\n                    continue;\\n                }\\n                if(abc.Peek() == \\'a\\'){\\n                    counter += 2;\\n                    continue;\\n                }\\n            }\\n        }\\n    return(counter);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693055,
                "title": "best-solution-intuitive-t-c-o-n-spacecomplexity-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        char first=word.charAt(0);\\n        char last=word.charAt(word.length()-1);\\n        int count=0;\\n        if (first==\\'c\\'){\\n            count=count+2;\\n        }\\n        else if(first==\\'b\\'){\\n            count=count+1;\\n        }\\n        for(int i=1;i<word.length();i++){\\n            char s=word.charAt(i-1);\\n            char t=word.charAt(i);\\n            if(t==\\'a\\'){\\n                if(s==\\'a\\'){\\n                    count=count+2;\\n                }\\n                else if(s==\\'b\\'){\\n                    count=count+1;\\n                }\\n            }\\n            else if(t==\\'b\\'){\\n                if(s==\\'b\\'){\\n                    count=count+2;\\n                }\\n                else if(s==\\'c\\'){\\n                    count=count+1;\\n                }\\n            }\\n            else{\\n                if(s==\\'a\\'){\\n                    count=count+1;\\n                }\\n                else if(s==\\'c\\'){\\n                    count=count+2;\\n                }\\n            }\\n        }\\n        if(last==\\'a\\'){\\n            count=count+2;\\n        }\\n        else if(last==\\'b\\'){\\n            count=count+1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        char first=word.charAt(0);\\n        char last=word.charAt(word.length()-1);\\n        int count=0;\\n        if (first==\\'c\\'){\\n            count=count+2;\\n        }\\n        else if(first==\\'b\\'){\\n            count=count+1;\\n        }\\n        for(int i=1;i<word.length();i++){\\n            char s=word.charAt(i-1);\\n            char t=word.charAt(i);\\n            if(t==\\'a\\'){\\n                if(s==\\'a\\'){\\n                    count=count+2;\\n                }\\n                else if(s==\\'b\\'){\\n                    count=count+1;\\n                }\\n            }\\n            else if(t==\\'b\\'){\\n                if(s==\\'b\\'){\\n                    count=count+2;\\n                }\\n                else if(s==\\'c\\'){\\n                    count=count+1;\\n                }\\n            }\\n            else{\\n                if(s==\\'a\\'){\\n                    count=count+1;\\n                }\\n                else if(s==\\'c\\'){\\n                    count=count+2;\\n                }\\n            }\\n        }\\n        if(last==\\'a\\'){\\n            count=count+2;\\n        }\\n        else if(last==\\'b\\'){\\n            count=count+1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690371,
                "title": "java-paper-pen-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int ans =0;\\n        for(int i =0; i < word.length();) {\\n            if(word.charAt(i) == \\'a\\') i++; else ans++;\\n            if(i < word.length() && word.charAt(i) == \\'b\\') i++; else ans++;\\n            if(i < word.length() && word.charAt(i) == \\'c\\') {\\n                 i++;\\n            }else {\\n                       ans++; \\n                    }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int ans =0;\\n        for(int i =0; i < word.length();) {\\n            if(word.charAt(i) == \\'a\\') i++; else ans++;\\n            if(i < word.length() && word.charAt(i) == \\'b\\') i++; else ans++;\\n            if(i < word.length() && word.charAt(i) == \\'c\\') {\\n                 i++;\\n            }else {\\n                       ans++; \\n                    }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676988,
                "title": "c-simple-string-well-explained-solution-time-complexity-o-3-n-space-complexity-o-1",
                "content": "# UPVOTE IF YOU LIKE  ;)\\n\\n# Intuition\\nYou can observe one thing that we need to find minimum number of characters to be added to the given string to convert it into a smallest possible patern like --> abcabcabc.... \\n\\nSo one can also say that our given string \"word\" is actually a subsequence from our actual answer which is the smallest \" abcabcabc.... \" pattern needed.\\n\\nIMPORTANT--> try doing some dry run on your own to understand my approach and observe it\\'s working\\n\\n\\n# Approach\\nI rcreated a cursive function with two pointers \\'i\\' anf \\'j\\'\\n\\n\\'i\\' is for our give string \"word\" and j is to point towards any one of the characters among \\'a\\' , \\'b\\' and \\'c\\'.\\ni.e. if\\n\\nj==1, it is pointing to \\'a\\'\\nj==2, it is pointing to \\'b\\'\\nj==3, it is pointing to \\'c\\'\\n\\nvalues of j would move like 1 2 3 1 2 3 1 2 3... until \\'i\\' would traverse the string \"word\" completely \\n\\nand now our functions works like this-->\\n\\nif(word[i-1]==char by j)\\nthen we don\\'t need to add this character as it is already present in given string \"word\" at required position and do i=i+1 and j=j+1, but \\n\\nif(word[i-1]!=char by j)\\nthen this \"char by j\" is not present in string \"word\" at required position so we need to count it and then do j=j+1 to check for next character.\\n\\nSome Dry Runs-->\\nstring\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int min_addition(string& word, int i, int j)\\n    {\\n        if(j==4)\\n        {\\n            j=1;\\n        }\\n\\n        if(i>word.length())\\n        {\\n            int len=word.length();\\n            // if(word[len-1]==\\'c\\')\\n            // {\\n            //     return 0;\\n            // }\\n            // else if(word[len-1]==\\'b\\')\\n            // {\\n            //     return 1;\\n            // }\\n            // else if(word[len-1]==\\'a\\')\\n            // {\\n            //     return 2;\\n            // }\\n\\n            return \\'c\\' - word[len-1];\\n        }\\n\\n        char c1=word[i-1];\\n        char c2=\\'a\\'+(j-1);\\n\\n        if(c1==c2)\\n        {\\n           return min_addition(word, i+1, j+1);\\n        }\\n\\n        // if(c1 != c2)\\n\\n        return 1+min_addition(word, i, j+1);\\n    }\\n\\n    int addMinimum(string word) \\n    {\\n        return min_addition(word, 1, 1);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int min_addition(string& word, int i, int j)\\n    {\\n        if(j==4)\\n        {\\n            j=1;\\n        }\\n\\n        if(i>word.length())\\n        {\\n            int len=word.length();\\n            // if(word[len-1]==\\'c\\')\\n            // {\\n            //     return 0;\\n            // }\\n            // else if(word[len-1]==\\'b\\')\\n            // {\\n            //     return 1;\\n            // }\\n            // else if(word[len-1]==\\'a\\')\\n            // {\\n            //     return 2;\\n            // }\\n\\n            return \\'c\\' - word[len-1];\\n        }\\n\\n        char c1=word[i-1];\\n        char c2=\\'a\\'+(j-1);\\n\\n        if(c1==c2)\\n        {\\n           return min_addition(word, i+1, j+1);\\n        }\\n\\n        // if(c1 != c2)\\n\\n        return 1+min_addition(word, i, j+1);\\n    }\\n\\n    int addMinimum(string word) \\n    {\\n        return min_addition(word, 1, 1);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669327,
                "title": "simple-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String w) {\\n        int i=0;\\n        int res=0;\\n        while(i<w.length())\\n        {\\n            int c=0;\\n            if(w.charAt(i)==\\'a\\'){\\n            i++;\\n            c++;\\n            }\\n            if(i<w.length() && w.charAt(i)==\\'b\\'){\\n            i++;\\n            c++;\\n            }\\n            if(i<w.length() && w.charAt(i)==\\'c\\'){\\n            i++;\\n            c++;\\n            }\\n            \\n            res=res+3-c;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String w) {\\n        int i=0;\\n        int res=0;\\n        while(i<w.length())\\n        {\\n            int c=0;\\n            if(w.charAt(i)==\\'a\\'){\\n            i++;\\n            c++;\\n            }\\n            if(i<w.length() && w.charAt(i)==\\'b\\'){\\n            i++;\\n            c++;\\n            }\\n            if(i<w.length() && w.charAt(i)==\\'c\\'){\\n            i++;\\n            c++;\\n            }\\n            \\n            res=res+3-c;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658346,
                "title": "dp-solution-works-without-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[51][4];\\n    int find(string &word,int ind,int counter)\\n    {\\n        if(ind == word.size()) return 0;\\n        if(dp[ind][counter]!=-1) return dp[ind][counter];\\n        int a = 0;\\n        if(counter%3 == 1){\\n            if(word[ind] == \\'a\\')\\n                a+=find(word,ind+1,(counter+1)%3);\\n            else\\n                a+=1+find(word,ind,(counter+1)%3);\\n        }\\n        else if(counter%3 == 2){\\n            if(word[ind]==\\'b\\')\\n                a+=find(word,ind+1,(counter+1)%3);\\n            else\\n                a+=1+find(word,ind,(counter+1)%3);\\n        }\\n        else{\\n            if(word[ind] == \\'c\\')\\n                a+=find(word,ind+1,(counter+1)%3);\\n            else\\n                a+=1+find(word,ind,(counter+1)%3);\\n        }\\n        return dp[ind][counter]=a;\\n        \\n    }\\n    int addMinimum(string word) {\\n        memset(dp,-1,sizeof(dp));\\n        int res = find(word,0,1);\\n        if(word.back() == \\'c\\')\\n            return res;\\n        else if(word.back() == \\'b\\')\\n            return res+1;\\n        else \\n            return res+2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[51][4];\\n    int find(string &word,int ind,int counter)\\n    {\\n        if(ind == word.size()) return 0;\\n        if(dp[ind][counter]!=-1) return dp[ind][counter];\\n        int a = 0;\\n        if(counter%3 == 1){\\n            if(word[ind] == \\'a\\')\\n                a+=find(word,ind+1,(counter+1)%3);\\n            else\\n                a+=1+find(word,ind,(counter+1)%3);\\n        }\\n        else if(counter%3 == 2){\\n            if(word[ind]==\\'b\\')\\n                a+=find(word,ind+1,(counter+1)%3);\\n            else\\n                a+=1+find(word,ind,(counter+1)%3);\\n        }\\n        else{\\n            if(word[ind] == \\'c\\')\\n                a+=find(word,ind+1,(counter+1)%3);\\n            else\\n                a+=1+find(word,ind,(counter+1)%3);\\n        }\\n        return dp[ind][counter]=a;\\n        \\n    }\\n    int addMinimum(string word) {\\n        memset(dp,-1,sizeof(dp));\\n        int res = find(word,0,1);\\n        if(word.back() == \\'c\\')\\n            return res;\\n        else if(word.back() == \\'b\\')\\n            return res+1;\\n        else \\n            return res+2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641903,
                "title": "easy-java-with-sharan-insertion-a-b-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nProblem IS Simple: \\n\\nif a occur  count++;\\nif b occcur count++;\\nif c occur. count++;\\n\\nfor 1 loop ( we are subtarct count with  3): \\n   => that means \\n\\nfor every it will check 3 char . if how many char present i remove from 3.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int ans =0;\\n        int i=0;\\n        while(i<word.length())\\n        {\\n            int count=0;;\\n            if(word.charAt(i) == \\'a\\' ){\\n                count++;\\n                i++;\\n            }\\n            if(i<word.length()  && word.charAt(i) == \\'b\\'){\\n                count++;\\n                i++;\\n            }\\n            if(i<word.length() && word.charAt(i) == \\'c\\'){\\n                count++;\\n                i++;\\n            }\\n            ans = ans + (3 - count);\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int ans =0;\\n        int i=0;\\n        while(i<word.length())\\n        {\\n            int count=0;;\\n            if(word.charAt(i) == \\'a\\' ){\\n                count++;\\n                i++;\\n            }\\n            if(i<word.length()  && word.charAt(i) == \\'b\\'){\\n                count++;\\n                i++;\\n            }\\n            if(i<word.length() && word.charAt(i) == \\'c\\'){\\n                count++;\\n                i++;\\n            }\\n            ans = ans + (3 - count);\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617626,
                "title": "o-n-solution-observation-based-easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        string s=\"\";\\n        int count=0;\\n        int n = word.size();\\n        if(word[0] == \\'b\\'){\\n            count+=1;\\n        }else if(word[0] ==  \\'c\\'){\\n            count+=2;\\n        }\\n        for(int i=1;i<word.size();i++){\\n            if(word[i] == \\'a\\' && word[i-1] == \\'a\\') count+=2;\\n            if(word[i] == \\'a\\' && word[i-1] == \\'b\\') count+=1;\\n            if(word[i] == \\'b\\' && word[i-1] == \\'b\\') count+=2;\\n            if(word[i] == \\'b\\' && word[i-1] == \\'c\\') count+=1;\\n            if(word[i] == \\'c\\' && word[i-1] == \\'c\\') count+=2;\\n            if(word[i] == \\'c\\' && word[i-1] == \\'a\\') count+=1;\\n        }\\n        if(word[n-1] == \\'a\\'){\\n            count+=2;\\n        }else if(word[n-1] == \\'b\\'){\\n            count+=1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        string s=\"\";\\n        int count=0;\\n        int n = word.size();\\n        if(word[0] == \\'b\\'){\\n            count+=1;\\n        }else if(word[0] ==  \\'c\\'){\\n            count+=2;\\n        }\\n        for(int i=1;i<word.size();i++){\\n            if(word[i] == \\'a\\' && word[i-1] == \\'a\\') count+=2;\\n            if(word[i] == \\'a\\' && word[i-1] == \\'b\\') count+=1;\\n            if(word[i] == \\'b\\' && word[i-1] == \\'b\\') count+=2;\\n            if(word[i] == \\'b\\' && word[i-1] == \\'c\\') count+=1;\\n            if(word[i] == \\'c\\' && word[i-1] == \\'c\\') count+=2;\\n            if(word[i] == \\'c\\' && word[i-1] == \\'a\\') count+=1;\\n        }\\n        if(word[n-1] == \\'a\\'){\\n            count+=2;\\n        }else if(word[n-1] == \\'b\\'){\\n            count+=1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3604865,
                "title": "easy-to-understand-greedy-c-simulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // \\n    int addMinimum(string s) {\\n        int n = s.size();\\n        // map<char,int> mp;\\n        // int mx = 0;\\n        // for(auto it:s){\\n        //     mp[it]++;\\n        //     mx = max(mp[it],mx);\\n        // }\\n        // return 3*mx-n;\\n        int ans = 0,i=1;\\n        if(s[0]==\\'b\\') ans++;\\n        if(s[0]==\\'c\\') ans+=2;\\n        char prev = s[0];\\n        while(i<n){\\n            if(prev==\\'a\\'){\\n               if(s[i]!=\\'b\\'){\\n                   prev = \\'b\\';\\n                   ans++;\\n               }else prev=s[i],i++;\\n            }\\n            else if(prev==\\'b\\'){\\n                if(s[i]!=\\'c\\'){\\n                    prev=\\'c\\';\\n                    ans++;\\n                }else prev=s[i],i++;\\n            }\\n            else{\\n                if(s[i]!=\\'a\\'){\\n                    prev=\\'a\\';\\n                    ans++;\\n                }else prev=s[i],i++;\\n            }\\n        }\\n        if(s[n-1]==\\'a\\') ans+=2;\\n        if(s[n-1]==\\'b\\') ans+=1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // \\n    int addMinimum(string s) {\\n        int n = s.size();\\n        // map<char,int> mp;\\n        // int mx = 0;\\n        // for(auto it:s){\\n        //     mp[it]++;\\n        //     mx = max(mp[it],mx);\\n        // }\\n        // return 3*mx-n;\\n        int ans = 0,i=1;\\n        if(s[0]==\\'b\\') ans++;\\n        if(s[0]==\\'c\\') ans+=2;\\n        char prev = s[0];\\n        while(i<n){\\n            if(prev==\\'a\\'){\\n               if(s[i]!=\\'b\\'){\\n                   prev = \\'b\\';\\n                   ans++;\\n               }else prev=s[i],i++;\\n            }\\n            else if(prev==\\'b\\'){\\n                if(s[i]!=\\'c\\'){\\n                    prev=\\'c\\';\\n                    ans++;\\n                }else prev=s[i],i++;\\n            }\\n            else{\\n                if(s[i]!=\\'a\\'){\\n                    prev=\\'a\\';\\n                    ans++;\\n                }else prev=s[i],i++;\\n            }\\n        }\\n        if(s[n-1]==\\'a\\') ans+=2;\\n        if(s[n-1]==\\'b\\') ans+=1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592863,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int i = 0;\\n        int j = 0;\\n        char[] ch = new char[]{\\'a\\',\\'b\\',\\'c\\'};\\n        int ans = 0;\\n        while(i < word.length()){\\n            char expected = ch[j%3];\\n            if(word.charAt(i)==expected){\\n                i++;                \\n            }else{\\n                ans++;                \\n            }\\n            j++;\\n        }\\n        \\n        if(j%3!=0){\\n            ans += 3-j%3;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int i = 0;\\n        int j = 0;\\n        char[] ch = new char[]{\\'a\\',\\'b\\',\\'c\\'};\\n        int ans = 0;\\n        while(i < word.length()){\\n            char expected = ch[j%3];\\n            if(word.charAt(i)==expected){\\n                i++;                \\n            }else{\\n                ans++;                \\n            }\\n            j++;\\n        }\\n        \\n        if(j%3!=0){\\n            ans += 3-j%3;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3583895,
                "title": "easy-python-code-with-time-complexity-o-n",
                "content": "# Intuition and Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nKeep track of the previous letter you saw and the current letter you\\'re on. Based on the differnce between the previous letter and the current letter, add the necessary number of changes to a variable named count. \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def addMinimum(self, word):\\n        \"\"\"\\n        :type word: str\\n        :rtype: int\\n        \"\"\"\\n\\n        prev = \\'c\\'\\n        count = 0\\n\\n        for l in word:\\n            if l == prev: count+= 2\\n\\n            if l == \\'a\\':\\n                if prev == \\'b\\': count += 1\\n            if l == \\'b\\':\\n                if prev == \\'c\\': count += 1\\n            if l == \\'c\\':\\n                if prev == \\'a\\': count += 1\\n\\n            prev = l\\n\\n\\n        if word[len(word) - 1 ] == \\'a\\': count += 2\\n        if word[len(word) - 1 ] == \\'b\\': count += 1\\n        \\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def addMinimum(self, word):\\n        \"\"\"\\n        :type word: str\\n        :rtype: int\\n        \"\"\"\\n\\n        prev = \\'c\\'\\n        count = 0\\n\\n        for l in word:\\n            if l == prev: count+= 2\\n\\n            if l == \\'a\\':\\n                if prev == \\'b\\': count += 1\\n            if l == \\'b\\':\\n                if prev == \\'c\\': count += 1\\n            if l == \\'c\\':\\n                if prev == \\'a\\': count += 1\\n\\n            prev = l\\n\\n\\n        if word[len(word) - 1 ] == \\'a\\': count += 2\\n        if word[len(word) - 1 ] == \\'b\\': count += 1\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3583224,
                "title": "easy-simple-java-sol-2ms-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n       int count=0;\\n        if(word.length()==1)\\n        {\\n           return 2;\\n        }\\n          if(word.charAt(0)==\\'b\\')\\n                count+=1;\\n        else if(word.charAt(0)==\\'c\\')\\n                count+=2;\\n        for(int i=1;i<word.length();i++){\\n          \\n            \\n             if(word.charAt(i-1)==\\'a\\' && word.charAt(i)==\\'c\\')\\n                count++;\\n          else if(word.charAt(i-1)==\\'a\\' && word.charAt(i)==\\'a\\')\\n               count+=2;\\n            else if(word.charAt(i-1)==\\'b\\' && word.charAt(i)==\\'a\\')\\n                count+=1;\\n          else if(word.charAt(i-1)==\\'b\\' && word.charAt(i)==\\'b\\')\\n               count+=2;\\n            else if(word.charAt(i-1)==\\'c\\' && word.charAt(i)==\\'b\\')\\n                count+=1;\\n          else if(word.charAt(i-1)==\\'c\\' && word.charAt(i)==\\'c\\')\\n               count+=2;\\n            \\n        }\\n        if( word.charAt(word.length()-1)==\\'a\\')\\n                count+=2;\\n            else if( word.charAt(word.length()-1)==\\'b\\')\\n                count+=1;\\n        \\n        return count;\\n            \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String word) {\\n       int count=0;\\n        if(word.length()==1)\\n        {\\n           return 2;\\n        }\\n          if(word.charAt(0)==\\'b\\')\\n                count+=1;\\n        else if(word.charAt(0)==\\'c\\')\\n                count+=2;\\n        for(int i=1;i<word.length();i++){\\n          \\n            \\n             if(word.charAt(i-1)==\\'a\\' && word.charAt(i)==\\'c\\')\\n                count++;\\n          else if(word.charAt(i-1)==\\'a\\' && word.charAt(i)==\\'a\\')\\n               count+=2;\\n            else if(word.charAt(i-1)==\\'b\\' && word.charAt(i)==\\'a\\')\\n                count+=1;\\n          else if(word.charAt(i-1)==\\'b\\' && word.charAt(i)==\\'b\\')\\n               count+=2;\\n            else if(word.charAt(i-1)==\\'c\\' && word.charAt(i)==\\'b\\')\\n                count+=1;\\n          else if(word.charAt(i-1)==\\'c\\' && word.charAt(i)==\\'c\\')\\n               count+=2;\\n            \\n        }\\n        if( word.charAt(word.length()-1)==\\'a\\')\\n                count+=2;\\n            else if( word.charAt(word.length()-1)==\\'b\\')\\n                count+=1;\\n        \\n        return count;\\n            \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581017,
                "title": "beats-100-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n Linear scan the string and update i,ans accordingly\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:o(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string s) \\n    {\\n        int n=s.size(),ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n          if(s[i]==\\'a\\')\\n          {\\n              if(i+1==n||s[i+1]==\\'a\\')\\n              ans+=2;\\n              else if(s[i+1]==\\'b\\')\\n              {\\n                  i++;\\n                 if(i+1==n)\\n                 ans+=1;\\n                 else if(s[i+1]==\\'c\\')\\n                 i++;\\n                 else ans+=1;\\n              }\\n              else if(s[i+1]==\\'c\\')\\n              {\\n                  ans+=1;\\n                  i++;\\n              }\\n          }\\n            else if(s[i]==\\'b\\')\\n            {\\n                if(i+1==n||s[i+1]==\\'a\\'||s[i+1]==\\'b\\')\\n                ans+=2;\\n                else if(s[i+1]==\\'c\\')\\n                {\\n                    ans+=1;\\n                    i++;\\n                }\\n            }\\n            else if(s[i]==\\'c\\')\\n            {\\n                ans+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string s) \\n    {\\n        int n=s.size(),ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n          if(s[i]==\\'a\\')\\n          {\\n              if(i+1==n||s[i+1]==\\'a\\')\\n              ans+=2;\\n              else if(s[i+1]==\\'b\\')\\n              {\\n                  i++;\\n                 if(i+1==n)\\n                 ans+=1;\\n                 else if(s[i+1]==\\'c\\')\\n                 i++;\\n                 else ans+=1;\\n              }\\n              else if(s[i+1]==\\'c\\')\\n              {\\n                  ans+=1;\\n                  i++;\\n              }\\n          }\\n            else if(s[i]==\\'b\\')\\n            {\\n                if(i+1==n||s[i+1]==\\'a\\'||s[i+1]==\\'b\\')\\n                ans+=2;\\n                else if(s[i+1]==\\'c\\')\\n                {\\n                    ans+=1;\\n                    i++;\\n                }\\n            }\\n            else if(s[i]==\\'c\\')\\n            {\\n                ans+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579520,
                "title": "easy-two-pointer-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n         string s = \"abc\";\\n         int j = 0,i = 0,count = 0;\\n\\n        while(i < word.size()){\\n            if(s[j++] == word[i]) i++;\\n            else count++;\\n            j%=s.size();\\n        }\\n        \\n        if(word[i-1] == \\'a\\') count+=2;\\n        else if(word[i-1] == \\'b\\') count++;\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n         string s = \"abc\";\\n         int j = 0,i = 0,count = 0;\\n\\n        while(i < word.size()){\\n            if(s[j++] == word[i]) i++;\\n            else count++;\\n            j%=s.size();\\n        }\\n        \\n        if(word[i-1] == \\'a\\') count+=2;\\n        else if(word[i-1] == \\'b\\') count++;\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569953,
                "title": "c-beginner-friendly-beats-100-greedy",
                "content": "# Intuition\\nStore the last character of the iteration and calculate accordingly\\n\\n# Approach\\nGreedy approach \\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int ca=0;\\n        int cb=0;\\n        int cc=0;\\n        int s=0;\\n        char last=word[0];\\n        if(word.length()==1){\\n            return 2;\\n        }\\n        if(word[0]==\\'b\\'){\\n            s+=1;\\n        }\\n        if(word[0]==\\'c\\'){\\n            s+=2;\\n        }\\n        for(int i=1;i<word.size();i++){\\n            if(last==\\'a\\'){\\n                if(word[i]==\\'a\\'){\\n                   s+=2;\\n                   last=\\'a\\';\\n                }\\n                else if(word[i]==\\'c\\'){\\n                    s+=1;\\n                    last=\\'c\\';\\n                }\\n                else{\\n                    last=\\'b\\';\\n\\n                }\\n\\n            }\\n            else if(last==\\'b\\'){\\n\\n                if(word[i]==\\'a\\'){\\n                   s+=1;\\n                   last=\\'a\\';\\n                }\\n                else if(word[i]==\\'b\\'){\\n                    s+=2;\\n                    last=\\'b\\';\\n                }\\n                else{\\n                    last=\\'c\\';\\n\\n                }\\n\\n            }\\n            else{\\n\\n                if(word[i]==\\'b\\'){\\n                   s+=1;\\n                   last=\\'b\\';\\n                }\\n                else if(word[i]==\\'c\\'){\\n                    s+=2;\\n                    last=\\'c\\';\\n                }\\n                else{\\n                    last=\\'a\\';\\n\\n                }\\n\\n\\n            }\\n\\n\\n        }\\n        if(last==\\'a\\'){\\n            s+=2;\\n        }\\n        else if(last==\\'b\\'){\\n            s+=1;\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        int ca=0;\\n        int cb=0;\\n        int cc=0;\\n        int s=0;\\n        char last=word[0];\\n        if(word.length()==1){\\n            return 2;\\n        }\\n        if(word[0]==\\'b\\'){\\n            s+=1;\\n        }\\n        if(word[0]==\\'c\\'){\\n            s+=2;\\n        }\\n        for(int i=1;i<word.size();i++){\\n            if(last==\\'a\\'){\\n                if(word[i]==\\'a\\'){\\n                   s+=2;\\n                   last=\\'a\\';\\n                }\\n                else if(word[i]==\\'c\\'){\\n                    s+=1;\\n                    last=\\'c\\';\\n                }\\n                else{\\n                    last=\\'b\\';\\n\\n                }\\n\\n            }\\n            else if(last==\\'b\\'){\\n\\n                if(word[i]==\\'a\\'){\\n                   s+=1;\\n                   last=\\'a\\';\\n                }\\n                else if(word[i]==\\'b\\'){\\n                    s+=2;\\n                    last=\\'b\\';\\n                }\\n                else{\\n                    last=\\'c\\';\\n\\n                }\\n\\n            }\\n            else{\\n\\n                if(word[i]==\\'b\\'){\\n                   s+=1;\\n                   last=\\'b\\';\\n                }\\n                else if(word[i]==\\'c\\'){\\n                    s+=2;\\n                    last=\\'c\\';\\n                }\\n                else{\\n                    last=\\'a\\';\\n\\n                }\\n\\n\\n            }\\n\\n\\n        }\\n        if(last==\\'a\\'){\\n            s+=2;\\n        }\\n        else if(last==\\'b\\'){\\n            s+=1;\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565849,
                "title": "c-o-n-simple-easy-to-understand-beats-100-in-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int addMinimum(string word) {\\n        int ans=0;\\n        if(word[0]==\\'b\\'){\\n            ans+=1;\\n        }\\n        if(word[0]==\\'c\\'){\\n            ans+=2;\\n        }\\n        for(int i=1;i<word.size();i++){\\n            if(word[i]==\\'a\\'){\\n                if(word[i-1]==\\'a\\'){\\n                    ans+=2;\\n                }\\n                if(word[i-1]==\\'b\\'){\\n                    ans+=1;\\n                }\\n            }\\n            if(word[i]==\\'b\\'){\\n                if(word[i-1]==\\'b\\'){\\n                    ans+=2;\\n                }\\n                if(word[i-1]==\\'c\\'){\\n                    ans+=1;\\n                }\\n            }\\n            if(word[i]==\\'c\\'){\\n                if(word[i-1]==\\'a\\'){\\n                    ans+=1;\\n                }\\n                if(word[i-1]==\\'c\\'){\\n                    ans+=2;\\n                }\\n            }\\n        }\\n        if(word[word.size()-1]==\\'b\\'){\\n            ans+=1;\\n        }\\n        if(word[word.size()-1]==\\'a\\'){\\n            ans+=2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int addMinimum(string word) {\\n        int ans=0;\\n        if(word[0]==\\'b\\'){\\n            ans+=1;\\n        }\\n        if(word[0]==\\'c\\'){\\n            ans+=2;\\n        }\\n        for(int i=1;i<word.size();i++){\\n            if(word[i]==\\'a\\'){\\n                if(word[i-1]==\\'a\\'){\\n                    ans+=2;\\n                }\\n                if(word[i-1]==\\'b\\'){\\n                    ans+=1;\\n                }\\n            }\\n            if(word[i]==\\'b\\'){\\n                if(word[i-1]==\\'b\\'){\\n                    ans+=2;\\n                }\\n                if(word[i-1]==\\'c\\'){\\n                    ans+=1;\\n                }\\n            }\\n            if(word[i]==\\'c\\'){\\n                if(word[i-1]==\\'a\\'){\\n                    ans+=1;\\n                }\\n                if(word[i-1]==\\'c\\'){\\n                    ans+=2;\\n                }\\n            }\\n        }\\n        if(word[word.size()-1]==\\'b\\'){\\n            ans+=1;\\n        }\\n        if(word[word.size()-1]==\\'a\\'){\\n            ans+=2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561545,
                "title": "c-ugly-map-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        unordered_map<char, unordered_map<char, int>> m;\\n        m[\\'a\\'][\\'a\\'] = 2;\\n        m[\\'a\\'][\\'c\\'] = 1;\\n        m[\\'a\\'][\\'b\\'] = 0;\\n        m[\\'b\\'][\\'c\\'] = 0;\\n        m[\\'b\\'][\\'a\\'] = 1;\\n        m[\\'b\\'][\\'b\\'] = 2;\\n        m[\\'c\\'][\\'c\\'] = 2;\\n        m[\\'c\\'][\\'a\\'] = 0;\\n        m[\\'c\\'][\\'b\\'] = 1;\\n        int ans = word[0] == \\'a\\' ? 0 : word[0] == \\'b\\' ? 1 : 2;\\n        char prev = word[0];\\n        for (int i = 1; i < word.size(); ++i){\\n            ans += m[prev][word[i]];\\n            prev = word[i];\\n        }\\n        int add = prev == \\'c\\' ? 0 : prev == \\'b\\' ? 1 : 2;\\n        return ans + add;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int addMinimum(string word) {\\n        unordered_map<char, unordered_map<char, int>> m;\\n        m[\\'a\\'][\\'a\\'] = 2;\\n        m[\\'a\\'][\\'c\\'] = 1;\\n        m[\\'a\\'][\\'b\\'] = 0;\\n        m[\\'b\\'][\\'c\\'] = 0;\\n        m[\\'b\\'][\\'a\\'] = 1;\\n        m[\\'b\\'][\\'b\\'] = 2;\\n        m[\\'c\\'][\\'c\\'] = 2;\\n        m[\\'c\\'][\\'a\\'] = 0;\\n        m[\\'c\\'][\\'b\\'] = 1;\\n        int ans = word[0] == \\'a\\' ? 0 : word[0] == \\'b\\' ? 1 : 2;\\n        char prev = word[0];\\n        for (int i = 1; i < word.size(); ++i){\\n            ans += m[prev][word[i]];\\n            prev = word[i];\\n        }\\n        int add = prev == \\'c\\' ? 0 : prev == \\'b\\' ? 1 : 2;\\n        return ans + add;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561029,
                "title": "easy-simple-solution-o-1-space-o-n",
                "content": "# Approach\\n\\'abc\\' is the pattern that should be followed so after a ,b should come and after b, c and after c, a should come and if the order is not same then increase the count as per old and current character.\\n**The last character** should be \\'c\\' and if a ,b then count should be increase by 2 , 1 respectively. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int count=0;\\n        char old=\\'c\\';\\n        for(int t=0;t<word.length();t++){\\n            char ch=word.charAt(t);\\n            if(ch==\\'a\\'){\\n                if(old==\\'a\\')count+=2;\\n                if(old==\\'b\\')count++;\\n            }\\n             if(ch==\\'b\\'){\\n                if(old==\\'c\\')count+=1;\\n                if(old==\\'b\\')count+=2;\\n            }\\n             if(ch==\\'c\\'){\\n                if(old==\\'c\\')count+=2;\\n                if(old==\\'a\\')count++;\\n            }\\n            old=ch;\\n        }\\n        count+=(\\'c\\'-old);\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int count=0;\\n        char old=\\'c\\';\\n        for(int t=0;t<word.length();t++){\\n            char ch=word.charAt(t);\\n            if(ch==\\'a\\'){\\n                if(old==\\'a\\')count+=2;\\n                if(old==\\'b\\')count++;\\n            }\\n             if(ch==\\'b\\'){\\n                if(old==\\'c\\')count+=1;\\n                if(old==\\'b\\')count+=2;\\n            }\\n             if(ch==\\'c\\'){\\n                if(old==\\'c\\')count+=2;\\n                if(old==\\'a\\')count++;\\n            }\\n            old=ch;\\n        }\\n        count+=(\\'c\\'-old);\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554268,
                "title": "java-one-swipe-no-dp-with-explanation",
                "content": "# Intuition\\nWe need to repeat a pattern of \"abc\" in a given string by adding charecters .\\nAs we can only add charecters , to add the minimum number of them we will have to use those who partialy or completely fit the pattern and expand upon them .\\n\\n# Approach\\nIn the given solution we repeat a patten of 0 , 1 , 2 in the variable pattern\\n```\\n    int pattern = 0;\\n    .\\n    .\\n    .\\n    pattern = (pattern+1)%3;\\n```\\n and in turn repeating the pattern \\'a\\' , \\'b\\' , \\'c\\' in\\n```\\n    pattern+\\'a\\'\\n```\\nWe then iterate through the given string and check if the charecter at a give index matches or not .\\n\\n- If the pattern and charecter at index mathch then both move forword and there is no need to add extra charecters (no change in res)\\n- Otherwise we need to add new charecter (res ++) and pattern moves forword\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int res = 0 ;\\n        int index = 0;\\n        int pattern = 0;\\n        int len = word.length();\\n        while (index<len){\\n            if(word.charAt(index)==pattern+\\'a\\'){\\n                index++;\\n            }\\n            else{\\n                res++;\\n            }\\n            pattern = (pattern+1)%3;\\n        }\\n        return res + (\\'c\\'- word.charAt(len-1));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    int pattern = 0;\\n    .\\n    .\\n    .\\n    pattern = (pattern+1)%3;\\n```\n```\\n    pattern+\\'a\\'\\n```\n```\\nclass Solution {\\n    public int addMinimum(String word) {\\n        int res = 0 ;\\n        int index = 0;\\n        int pattern = 0;\\n        int len = word.length();\\n        while (index<len){\\n            if(word.charAt(index)==pattern+\\'a\\'){\\n                index++;\\n            }\\n            else{\\n                res++;\\n            }\\n            pattern = (pattern+1)%3;\\n        }\\n        return res + (\\'c\\'- word.charAt(len-1));\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1865764,
                "content": [
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Replace \"abc\" -> \"0\"\\n\"ab\" -> \"1\"\\n\"bc\" -> \"1\"\\n\"ac\" -> \"1\"\\n\"a\" -> \"2\"\\n\"b\" -> \"2\"\\n\"c\" -> \"2\"\\n\\nand iterate over the new modified string and sum up all the digits.\\nNote: The order of replacing is the key"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "why im getting error for \"aaaabb\"??\\n\\n\\nclass Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int counta=0,countb=0,countc=0;\\n        for(int i=0;i<word.size();i++){\\n            if(word[i]==\\'a\\') counta++;\\n            else if(word[i]==\\'b\\') countb++;\\n            else countc++;\\n        }\\n        int m=max(max(counta,countb),countc);\\n        int res=(3*m)-counta-countb-countc;\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "krishna859768",
                        "content": "same problem\\nHave you find the reason?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "One of the most amazing question i solved on LC. Pure Logical, and the feeling of acceptance in one go is heavenly.  "
                    },
                    {
                        "username": "chachraanubhav",
                        "content": "Did anyone try the LCS approach ? I know it will take O(N^2) , and there is a simple iterative method that works in O(N)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone tell me the thought process how he/she come up with a Solution."
                    },
                    {
                        "username": "jason400",
                        "content": "If you want to be able to reliably derive a solution on sight without making lucky guesses or pattern recognition from similar problems, other thought processes like trying to recognize a pattern and then coding something up until it works won't cut it IMO. That would make it seem like you saw the problem before and turn the interview into essentially floundering around with intuition until you hopefully arrive at a solution in time. This is my thought process.\n1) Realize the problem is an optimization problem over a decision space of exponential size (branching factor at least 3), and note that a search over the problem space implemented with a simple recursion with backtracking implementation will yield a correct, albeit exponential runtime.\n2) Using your observation from #1, and your knowledge that greedy algorithms are often employed to efficiently optimize a set of decisions over even exponentially sized search trees, begin examining a set of 'localized' choices that might exhibit the Greedy Choice Property\n3) Observe that every valid solution modifies the problem space to a string that begins with 'abc', therefore, the optimal solution must contain these set of localized steps. Use intuition to posit that one 'choice' (set of local decisions) we can make would be to minimally append either an a,b,c to each of the initial characters until we arrive at 'abc'. Perform a quick 'proof' by contradiction in your head to gain confidence that no optimal solution excludes this minimal set of decisions. You have identified a choice that satisfies the Greedy Choice Property\n4) Realize that the Greedy Choice you have identified leads to a substructure decomposition which is also an optimal substructure (no surprise there, but good to check)\n5) Using the 'choice' you have identified as satisfying both the Greedy Choice Property and resolving the problem to an Optimal Substructure (you need those two things to proceed with confidence that your algorithm will actually work) implement a greedy algorithm using a combination of iteration and/or recursion, and use LinkedList backed stacks are your data structure to demonstrate additional mastery of data structures\n6) [Very Optional at best IMO] Further simplify the implementation by ripping out the linkedlist/stacks data structures, and any references to characters, by leveraging properties of ascii characters to achieve a slight constant time reduction in both runtime and memory, as well as LOC\n"
                    },
                    {
                        "username": "Kai_Ghost",
                        "content": "Find the pattern in the string in the nested while loop in the code beneath \n\n```\nclass Solution {\npublic:\n    int addMinimum(string word) {\n        int res = 0;\n        int ptr1 = 0;\n        int n = word.size();\n        while (ptr1 < n) {\n            char starting = word[ptr1];\n            int temp = ptr1 + 1;\n            char prev = starting;\n            while (temp < n && word[temp] > prev) {\n                prev = word[temp];\n                temp++;\n            }\n\n            res += 3 - (temp - ptr1);\n            ptr1 = temp;\n            \n        }\n\n\n\n\n\n        return res;\n\n        \n    }\n};\n\n\n```"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "we will interate word and check if expected letter is there or not according to repeating pattern of \"abc\" .if not present we increment count and increment and modulo index (we are adding a missing char to word)"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Leetcode, why is the result for \"aaaabb\" 9? I think it\\'s 6 because for 4 - a, 2 - b, 0 - c you need to add 2 \"b\" and 4 \"c\""
                    },
                    {
                        "username": "Dhaval25",
                        "content": "[a]bc [a]bc [a]bc  [ab]c  a[b]c :  As you can see the number of non-square brackets is 9 not 6. We add bc for first 3 \\'a\\' then we club 4th \\'ab\\' together and add \\'c\\' and for last \\'b\\' we add \\'ac\\' so in total we added 9 characters "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You can\\'t change the position of Characters.That\\'s why bb also need 2a and 2c."
                    },
                    {
                        "username": "bharat231",
                        "content": "We need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh"
                    },
                    {
                        "username": "Tim-Ax",
                        "content": "word = \\'aaaabb\\'\\n\\u041Eutput 6\\nExpected. 9\\nI meant it like that:\\naaaabb-> a a a a b b ->  ab ab a a => ab+c   ab+c   b+bc    b+bc\\nc c b c b c     6 letters\\n\\nDid I misunderstand the task?  :)\\nThanks"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "The question says \"you can insert letters \"a\", \"b\" or \"c\" anywhere and any number of times\".  So, I don\\'t think you can move around the existing letters.  \\n\\nSo, in this case the solution will be \\n      aaaabb \\n=> a a a a b b \\n=> a (bc) a (bc) a (bc) a b (c) (a) b (c)\\n=> abc abc abc abc abc \\n\\ninserted : b c b c b c c a c \\n"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "For this string, \"aaaabb\" => my output is 6, but it says 9 expected output"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "[@sergei-durkin](/sergei-durkin) hi bro, actually it s correct , we cannot move letters of word , so we need to validate it as it is "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "You are right, Litcode described the problem incorrectly. I also fell into this trap)\\n\\nif we look at this problem from the other side, we need to make valid string for each symbol in this string\\n\\nbharat231 described the answer to your question \\n```\\nWe need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh\\n```"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "This should be tagged as EASY :\n-  The problem is not that hard ( Though is a good one for beginner )\n-  The solutions mostly require tools LeetCode it self considers \"Fundamental\"\n-  The problem has many different ways it can be solved (Like many other Easy problems on the site )\n- The test case Constraints are smaller so that a solution with high time and space complexity can be accepted .\n- All in all signs of an Easy LeetCode problem ."
                    },
                    {
                        "username": "jason400",
                        "content": "It's quite challenging to derive it cold. To completely and fully solve such a problem one would need to model the problem as a decision tree, identify the minimal set prepend 'a','b','c' or pass steps to arrive at the first 'abc' subsequence in the optimal solution as both satisfying the greedy choice problem and resolving the problem to an optimal substructure. Then implement either a recursive or stack-based iterative greedy algorithm using such a greedy choice. While much of the implementation around the actual values of the characters can be stripped away to leave a simple iterative algorithm, any implementation would need to derive from such a solution in order to demonstrate a full understanding of the algorithm that is being employed.\n\nAnything less would indicate either a familiarity with the problem or an aimless luck or intuition based guess, which could be a failure in any real world interview.\n    \n\n\n\n    class Solution {\n        public int addMinimum(String word) {\n            ArrayList<Character> wordStack = new ArrayList<Character>();\n            for (Character c : word.toCharArray()) {\n                wordStack.add(c);\n            }\n            ArrayList<Character> abcStack = new ArrayList<Character>();\n    \n            int j = 0;\n            while (!wordStack.isEmpty()) {\n                abcStack.add('a');\n                abcStack.add('b');\n                abcStack.add('c');\n    \n                while (!abcStack.isEmpty() && !wordStack.isEmpty()) {\n                    char c = wordStack.remove(0).charValue();\n                    char i = abcStack.remove(0).charValue();\n    \n                    if (c != i) {\n                        wordStack.add(0, c);\n                        j++;\n                    }\n                }\n    \n            }\n            return j + abcStack.size();\n        }\n    }"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int i=0,count=0,n=word.size(),res=0;\\n\\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word[i] == \\'a\\') {\\n                count++;\\n            }\\n             \\n            if(word[i] == \\'b\\') {\\n                count++;\\n            }\\n            \\n            if(word[i] == \\'c\\') {\\n                count++;\\n            }\\n            i++;\\n            res += 3 - count;\\n        }\\n        cout<<res;\\n\\n\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1865557,
                "content": [
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Replace \"abc\" -> \"0\"\\n\"ab\" -> \"1\"\\n\"bc\" -> \"1\"\\n\"ac\" -> \"1\"\\n\"a\" -> \"2\"\\n\"b\" -> \"2\"\\n\"c\" -> \"2\"\\n\\nand iterate over the new modified string and sum up all the digits.\\nNote: The order of replacing is the key"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "why im getting error for \"aaaabb\"??\\n\\n\\nclass Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int counta=0,countb=0,countc=0;\\n        for(int i=0;i<word.size();i++){\\n            if(word[i]==\\'a\\') counta++;\\n            else if(word[i]==\\'b\\') countb++;\\n            else countc++;\\n        }\\n        int m=max(max(counta,countb),countc);\\n        int res=(3*m)-counta-countb-countc;\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "krishna859768",
                        "content": "same problem\\nHave you find the reason?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "One of the most amazing question i solved on LC. Pure Logical, and the feeling of acceptance in one go is heavenly.  "
                    },
                    {
                        "username": "chachraanubhav",
                        "content": "Did anyone try the LCS approach ? I know it will take O(N^2) , and there is a simple iterative method that works in O(N)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone tell me the thought process how he/she come up with a Solution."
                    },
                    {
                        "username": "jason400",
                        "content": "If you want to be able to reliably derive a solution on sight without making lucky guesses or pattern recognition from similar problems, other thought processes like trying to recognize a pattern and then coding something up until it works won't cut it IMO. That would make it seem like you saw the problem before and turn the interview into essentially floundering around with intuition until you hopefully arrive at a solution in time. This is my thought process.\n1) Realize the problem is an optimization problem over a decision space of exponential size (branching factor at least 3), and note that a search over the problem space implemented with a simple recursion with backtracking implementation will yield a correct, albeit exponential runtime.\n2) Using your observation from #1, and your knowledge that greedy algorithms are often employed to efficiently optimize a set of decisions over even exponentially sized search trees, begin examining a set of 'localized' choices that might exhibit the Greedy Choice Property\n3) Observe that every valid solution modifies the problem space to a string that begins with 'abc', therefore, the optimal solution must contain these set of localized steps. Use intuition to posit that one 'choice' (set of local decisions) we can make would be to minimally append either an a,b,c to each of the initial characters until we arrive at 'abc'. Perform a quick 'proof' by contradiction in your head to gain confidence that no optimal solution excludes this minimal set of decisions. You have identified a choice that satisfies the Greedy Choice Property\n4) Realize that the Greedy Choice you have identified leads to a substructure decomposition which is also an optimal substructure (no surprise there, but good to check)\n5) Using the 'choice' you have identified as satisfying both the Greedy Choice Property and resolving the problem to an Optimal Substructure (you need those two things to proceed with confidence that your algorithm will actually work) implement a greedy algorithm using a combination of iteration and/or recursion, and use LinkedList backed stacks are your data structure to demonstrate additional mastery of data structures\n6) [Very Optional at best IMO] Further simplify the implementation by ripping out the linkedlist/stacks data structures, and any references to characters, by leveraging properties of ascii characters to achieve a slight constant time reduction in both runtime and memory, as well as LOC\n"
                    },
                    {
                        "username": "Kai_Ghost",
                        "content": "Find the pattern in the string in the nested while loop in the code beneath \n\n```\nclass Solution {\npublic:\n    int addMinimum(string word) {\n        int res = 0;\n        int ptr1 = 0;\n        int n = word.size();\n        while (ptr1 < n) {\n            char starting = word[ptr1];\n            int temp = ptr1 + 1;\n            char prev = starting;\n            while (temp < n && word[temp] > prev) {\n                prev = word[temp];\n                temp++;\n            }\n\n            res += 3 - (temp - ptr1);\n            ptr1 = temp;\n            \n        }\n\n\n\n\n\n        return res;\n\n        \n    }\n};\n\n\n```"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "we will interate word and check if expected letter is there or not according to repeating pattern of \"abc\" .if not present we increment count and increment and modulo index (we are adding a missing char to word)"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Leetcode, why is the result for \"aaaabb\" 9? I think it\\'s 6 because for 4 - a, 2 - b, 0 - c you need to add 2 \"b\" and 4 \"c\""
                    },
                    {
                        "username": "Dhaval25",
                        "content": "[a]bc [a]bc [a]bc  [ab]c  a[b]c :  As you can see the number of non-square brackets is 9 not 6. We add bc for first 3 \\'a\\' then we club 4th \\'ab\\' together and add \\'c\\' and for last \\'b\\' we add \\'ac\\' so in total we added 9 characters "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You can\\'t change the position of Characters.That\\'s why bb also need 2a and 2c."
                    },
                    {
                        "username": "bharat231",
                        "content": "We need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh"
                    },
                    {
                        "username": "Tim-Ax",
                        "content": "word = \\'aaaabb\\'\\n\\u041Eutput 6\\nExpected. 9\\nI meant it like that:\\naaaabb-> a a a a b b ->  ab ab a a => ab+c   ab+c   b+bc    b+bc\\nc c b c b c     6 letters\\n\\nDid I misunderstand the task?  :)\\nThanks"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "The question says \"you can insert letters \"a\", \"b\" or \"c\" anywhere and any number of times\".  So, I don\\'t think you can move around the existing letters.  \\n\\nSo, in this case the solution will be \\n      aaaabb \\n=> a a a a b b \\n=> a (bc) a (bc) a (bc) a b (c) (a) b (c)\\n=> abc abc abc abc abc \\n\\ninserted : b c b c b c c a c \\n"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "For this string, \"aaaabb\" => my output is 6, but it says 9 expected output"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "[@sergei-durkin](/sergei-durkin) hi bro, actually it s correct , we cannot move letters of word , so we need to validate it as it is "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "You are right, Litcode described the problem incorrectly. I also fell into this trap)\\n\\nif we look at this problem from the other side, we need to make valid string for each symbol in this string\\n\\nbharat231 described the answer to your question \\n```\\nWe need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh\\n```"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "This should be tagged as EASY :\n-  The problem is not that hard ( Though is a good one for beginner )\n-  The solutions mostly require tools LeetCode it self considers \"Fundamental\"\n-  The problem has many different ways it can be solved (Like many other Easy problems on the site )\n- The test case Constraints are smaller so that a solution with high time and space complexity can be accepted .\n- All in all signs of an Easy LeetCode problem ."
                    },
                    {
                        "username": "jason400",
                        "content": "It's quite challenging to derive it cold. To completely and fully solve such a problem one would need to model the problem as a decision tree, identify the minimal set prepend 'a','b','c' or pass steps to arrive at the first 'abc' subsequence in the optimal solution as both satisfying the greedy choice problem and resolving the problem to an optimal substructure. Then implement either a recursive or stack-based iterative greedy algorithm using such a greedy choice. While much of the implementation around the actual values of the characters can be stripped away to leave a simple iterative algorithm, any implementation would need to derive from such a solution in order to demonstrate a full understanding of the algorithm that is being employed.\n\nAnything less would indicate either a familiarity with the problem or an aimless luck or intuition based guess, which could be a failure in any real world interview.\n    \n\n\n\n    class Solution {\n        public int addMinimum(String word) {\n            ArrayList<Character> wordStack = new ArrayList<Character>();\n            for (Character c : word.toCharArray()) {\n                wordStack.add(c);\n            }\n            ArrayList<Character> abcStack = new ArrayList<Character>();\n    \n            int j = 0;\n            while (!wordStack.isEmpty()) {\n                abcStack.add('a');\n                abcStack.add('b');\n                abcStack.add('c');\n    \n                while (!abcStack.isEmpty() && !wordStack.isEmpty()) {\n                    char c = wordStack.remove(0).charValue();\n                    char i = abcStack.remove(0).charValue();\n    \n                    if (c != i) {\n                        wordStack.add(0, c);\n                        j++;\n                    }\n                }\n    \n            }\n            return j + abcStack.size();\n        }\n    }"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int i=0,count=0,n=word.size(),res=0;\\n\\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word[i] == \\'a\\') {\\n                count++;\\n            }\\n             \\n            if(word[i] == \\'b\\') {\\n                count++;\\n            }\\n            \\n            if(word[i] == \\'c\\') {\\n                count++;\\n            }\\n            i++;\\n            res += 3 - count;\\n        }\\n        cout<<res;\\n\\n\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1964460,
                "content": [
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Replace \"abc\" -> \"0\"\\n\"ab\" -> \"1\"\\n\"bc\" -> \"1\"\\n\"ac\" -> \"1\"\\n\"a\" -> \"2\"\\n\"b\" -> \"2\"\\n\"c\" -> \"2\"\\n\\nand iterate over the new modified string and sum up all the digits.\\nNote: The order of replacing is the key"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "why im getting error for \"aaaabb\"??\\n\\n\\nclass Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int counta=0,countb=0,countc=0;\\n        for(int i=0;i<word.size();i++){\\n            if(word[i]==\\'a\\') counta++;\\n            else if(word[i]==\\'b\\') countb++;\\n            else countc++;\\n        }\\n        int m=max(max(counta,countb),countc);\\n        int res=(3*m)-counta-countb-countc;\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "krishna859768",
                        "content": "same problem\\nHave you find the reason?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "One of the most amazing question i solved on LC. Pure Logical, and the feeling of acceptance in one go is heavenly.  "
                    },
                    {
                        "username": "chachraanubhav",
                        "content": "Did anyone try the LCS approach ? I know it will take O(N^2) , and there is a simple iterative method that works in O(N)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone tell me the thought process how he/she come up with a Solution."
                    },
                    {
                        "username": "jason400",
                        "content": "If you want to be able to reliably derive a solution on sight without making lucky guesses or pattern recognition from similar problems, other thought processes like trying to recognize a pattern and then coding something up until it works won't cut it IMO. That would make it seem like you saw the problem before and turn the interview into essentially floundering around with intuition until you hopefully arrive at a solution in time. This is my thought process.\n1) Realize the problem is an optimization problem over a decision space of exponential size (branching factor at least 3), and note that a search over the problem space implemented with a simple recursion with backtracking implementation will yield a correct, albeit exponential runtime.\n2) Using your observation from #1, and your knowledge that greedy algorithms are often employed to efficiently optimize a set of decisions over even exponentially sized search trees, begin examining a set of 'localized' choices that might exhibit the Greedy Choice Property\n3) Observe that every valid solution modifies the problem space to a string that begins with 'abc', therefore, the optimal solution must contain these set of localized steps. Use intuition to posit that one 'choice' (set of local decisions) we can make would be to minimally append either an a,b,c to each of the initial characters until we arrive at 'abc'. Perform a quick 'proof' by contradiction in your head to gain confidence that no optimal solution excludes this minimal set of decisions. You have identified a choice that satisfies the Greedy Choice Property\n4) Realize that the Greedy Choice you have identified leads to a substructure decomposition which is also an optimal substructure (no surprise there, but good to check)\n5) Using the 'choice' you have identified as satisfying both the Greedy Choice Property and resolving the problem to an Optimal Substructure (you need those two things to proceed with confidence that your algorithm will actually work) implement a greedy algorithm using a combination of iteration and/or recursion, and use LinkedList backed stacks are your data structure to demonstrate additional mastery of data structures\n6) [Very Optional at best IMO] Further simplify the implementation by ripping out the linkedlist/stacks data structures, and any references to characters, by leveraging properties of ascii characters to achieve a slight constant time reduction in both runtime and memory, as well as LOC\n"
                    },
                    {
                        "username": "Kai_Ghost",
                        "content": "Find the pattern in the string in the nested while loop in the code beneath \n\n```\nclass Solution {\npublic:\n    int addMinimum(string word) {\n        int res = 0;\n        int ptr1 = 0;\n        int n = word.size();\n        while (ptr1 < n) {\n            char starting = word[ptr1];\n            int temp = ptr1 + 1;\n            char prev = starting;\n            while (temp < n && word[temp] > prev) {\n                prev = word[temp];\n                temp++;\n            }\n\n            res += 3 - (temp - ptr1);\n            ptr1 = temp;\n            \n        }\n\n\n\n\n\n        return res;\n\n        \n    }\n};\n\n\n```"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "we will interate word and check if expected letter is there or not according to repeating pattern of \"abc\" .if not present we increment count and increment and modulo index (we are adding a missing char to word)"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Leetcode, why is the result for \"aaaabb\" 9? I think it\\'s 6 because for 4 - a, 2 - b, 0 - c you need to add 2 \"b\" and 4 \"c\""
                    },
                    {
                        "username": "Dhaval25",
                        "content": "[a]bc [a]bc [a]bc  [ab]c  a[b]c :  As you can see the number of non-square brackets is 9 not 6. We add bc for first 3 \\'a\\' then we club 4th \\'ab\\' together and add \\'c\\' and for last \\'b\\' we add \\'ac\\' so in total we added 9 characters "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You can\\'t change the position of Characters.That\\'s why bb also need 2a and 2c."
                    },
                    {
                        "username": "bharat231",
                        "content": "We need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh"
                    },
                    {
                        "username": "Tim-Ax",
                        "content": "word = \\'aaaabb\\'\\n\\u041Eutput 6\\nExpected. 9\\nI meant it like that:\\naaaabb-> a a a a b b ->  ab ab a a => ab+c   ab+c   b+bc    b+bc\\nc c b c b c     6 letters\\n\\nDid I misunderstand the task?  :)\\nThanks"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "The question says \"you can insert letters \"a\", \"b\" or \"c\" anywhere and any number of times\".  So, I don\\'t think you can move around the existing letters.  \\n\\nSo, in this case the solution will be \\n      aaaabb \\n=> a a a a b b \\n=> a (bc) a (bc) a (bc) a b (c) (a) b (c)\\n=> abc abc abc abc abc \\n\\ninserted : b c b c b c c a c \\n"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "For this string, \"aaaabb\" => my output is 6, but it says 9 expected output"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "[@sergei-durkin](/sergei-durkin) hi bro, actually it s correct , we cannot move letters of word , so we need to validate it as it is "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "You are right, Litcode described the problem incorrectly. I also fell into this trap)\\n\\nif we look at this problem from the other side, we need to make valid string for each symbol in this string\\n\\nbharat231 described the answer to your question \\n```\\nWe need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh\\n```"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "This should be tagged as EASY :\n-  The problem is not that hard ( Though is a good one for beginner )\n-  The solutions mostly require tools LeetCode it self considers \"Fundamental\"\n-  The problem has many different ways it can be solved (Like many other Easy problems on the site )\n- The test case Constraints are smaller so that a solution with high time and space complexity can be accepted .\n- All in all signs of an Easy LeetCode problem ."
                    },
                    {
                        "username": "jason400",
                        "content": "It's quite challenging to derive it cold. To completely and fully solve such a problem one would need to model the problem as a decision tree, identify the minimal set prepend 'a','b','c' or pass steps to arrive at the first 'abc' subsequence in the optimal solution as both satisfying the greedy choice problem and resolving the problem to an optimal substructure. Then implement either a recursive or stack-based iterative greedy algorithm using such a greedy choice. While much of the implementation around the actual values of the characters can be stripped away to leave a simple iterative algorithm, any implementation would need to derive from such a solution in order to demonstrate a full understanding of the algorithm that is being employed.\n\nAnything less would indicate either a familiarity with the problem or an aimless luck or intuition based guess, which could be a failure in any real world interview.\n    \n\n\n\n    class Solution {\n        public int addMinimum(String word) {\n            ArrayList<Character> wordStack = new ArrayList<Character>();\n            for (Character c : word.toCharArray()) {\n                wordStack.add(c);\n            }\n            ArrayList<Character> abcStack = new ArrayList<Character>();\n    \n            int j = 0;\n            while (!wordStack.isEmpty()) {\n                abcStack.add('a');\n                abcStack.add('b');\n                abcStack.add('c');\n    \n                while (!abcStack.isEmpty() && !wordStack.isEmpty()) {\n                    char c = wordStack.remove(0).charValue();\n                    char i = abcStack.remove(0).charValue();\n    \n                    if (c != i) {\n                        wordStack.add(0, c);\n                        j++;\n                    }\n                }\n    \n            }\n            return j + abcStack.size();\n        }\n    }"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int i=0,count=0,n=word.size(),res=0;\\n\\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word[i] == \\'a\\') {\\n                count++;\\n            }\\n             \\n            if(word[i] == \\'b\\') {\\n                count++;\\n            }\\n            \\n            if(word[i] == \\'c\\') {\\n                count++;\\n            }\\n            i++;\\n            res += 3 - count;\\n        }\\n        cout<<res;\\n\\n\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1864937,
                "content": [
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Replace \"abc\" -> \"0\"\\n\"ab\" -> \"1\"\\n\"bc\" -> \"1\"\\n\"ac\" -> \"1\"\\n\"a\" -> \"2\"\\n\"b\" -> \"2\"\\n\"c\" -> \"2\"\\n\\nand iterate over the new modified string and sum up all the digits.\\nNote: The order of replacing is the key"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "why im getting error for \"aaaabb\"??\\n\\n\\nclass Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int counta=0,countb=0,countc=0;\\n        for(int i=0;i<word.size();i++){\\n            if(word[i]==\\'a\\') counta++;\\n            else if(word[i]==\\'b\\') countb++;\\n            else countc++;\\n        }\\n        int m=max(max(counta,countb),countc);\\n        int res=(3*m)-counta-countb-countc;\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "krishna859768",
                        "content": "same problem\\nHave you find the reason?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "One of the most amazing question i solved on LC. Pure Logical, and the feeling of acceptance in one go is heavenly.  "
                    },
                    {
                        "username": "chachraanubhav",
                        "content": "Did anyone try the LCS approach ? I know it will take O(N^2) , and there is a simple iterative method that works in O(N)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone tell me the thought process how he/she come up with a Solution."
                    },
                    {
                        "username": "jason400",
                        "content": "If you want to be able to reliably derive a solution on sight without making lucky guesses or pattern recognition from similar problems, other thought processes like trying to recognize a pattern and then coding something up until it works won't cut it IMO. That would make it seem like you saw the problem before and turn the interview into essentially floundering around with intuition until you hopefully arrive at a solution in time. This is my thought process.\n1) Realize the problem is an optimization problem over a decision space of exponential size (branching factor at least 3), and note that a search over the problem space implemented with a simple recursion with backtracking implementation will yield a correct, albeit exponential runtime.\n2) Using your observation from #1, and your knowledge that greedy algorithms are often employed to efficiently optimize a set of decisions over even exponentially sized search trees, begin examining a set of 'localized' choices that might exhibit the Greedy Choice Property\n3) Observe that every valid solution modifies the problem space to a string that begins with 'abc', therefore, the optimal solution must contain these set of localized steps. Use intuition to posit that one 'choice' (set of local decisions) we can make would be to minimally append either an a,b,c to each of the initial characters until we arrive at 'abc'. Perform a quick 'proof' by contradiction in your head to gain confidence that no optimal solution excludes this minimal set of decisions. You have identified a choice that satisfies the Greedy Choice Property\n4) Realize that the Greedy Choice you have identified leads to a substructure decomposition which is also an optimal substructure (no surprise there, but good to check)\n5) Using the 'choice' you have identified as satisfying both the Greedy Choice Property and resolving the problem to an Optimal Substructure (you need those two things to proceed with confidence that your algorithm will actually work) implement a greedy algorithm using a combination of iteration and/or recursion, and use LinkedList backed stacks are your data structure to demonstrate additional mastery of data structures\n6) [Very Optional at best IMO] Further simplify the implementation by ripping out the linkedlist/stacks data structures, and any references to characters, by leveraging properties of ascii characters to achieve a slight constant time reduction in both runtime and memory, as well as LOC\n"
                    },
                    {
                        "username": "Kai_Ghost",
                        "content": "Find the pattern in the string in the nested while loop in the code beneath \n\n```\nclass Solution {\npublic:\n    int addMinimum(string word) {\n        int res = 0;\n        int ptr1 = 0;\n        int n = word.size();\n        while (ptr1 < n) {\n            char starting = word[ptr1];\n            int temp = ptr1 + 1;\n            char prev = starting;\n            while (temp < n && word[temp] > prev) {\n                prev = word[temp];\n                temp++;\n            }\n\n            res += 3 - (temp - ptr1);\n            ptr1 = temp;\n            \n        }\n\n\n\n\n\n        return res;\n\n        \n    }\n};\n\n\n```"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "we will interate word and check if expected letter is there or not according to repeating pattern of \"abc\" .if not present we increment count and increment and modulo index (we are adding a missing char to word)"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Leetcode, why is the result for \"aaaabb\" 9? I think it\\'s 6 because for 4 - a, 2 - b, 0 - c you need to add 2 \"b\" and 4 \"c\""
                    },
                    {
                        "username": "Dhaval25",
                        "content": "[a]bc [a]bc [a]bc  [ab]c  a[b]c :  As you can see the number of non-square brackets is 9 not 6. We add bc for first 3 \\'a\\' then we club 4th \\'ab\\' together and add \\'c\\' and for last \\'b\\' we add \\'ac\\' so in total we added 9 characters "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You can\\'t change the position of Characters.That\\'s why bb also need 2a and 2c."
                    },
                    {
                        "username": "bharat231",
                        "content": "We need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh"
                    },
                    {
                        "username": "Tim-Ax",
                        "content": "word = \\'aaaabb\\'\\n\\u041Eutput 6\\nExpected. 9\\nI meant it like that:\\naaaabb-> a a a a b b ->  ab ab a a => ab+c   ab+c   b+bc    b+bc\\nc c b c b c     6 letters\\n\\nDid I misunderstand the task?  :)\\nThanks"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "The question says \"you can insert letters \"a\", \"b\" or \"c\" anywhere and any number of times\".  So, I don\\'t think you can move around the existing letters.  \\n\\nSo, in this case the solution will be \\n      aaaabb \\n=> a a a a b b \\n=> a (bc) a (bc) a (bc) a b (c) (a) b (c)\\n=> abc abc abc abc abc \\n\\ninserted : b c b c b c c a c \\n"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "For this string, \"aaaabb\" => my output is 6, but it says 9 expected output"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "[@sergei-durkin](/sergei-durkin) hi bro, actually it s correct , we cannot move letters of word , so we need to validate it as it is "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "You are right, Litcode described the problem incorrectly. I also fell into this trap)\\n\\nif we look at this problem from the other side, we need to make valid string for each symbol in this string\\n\\nbharat231 described the answer to your question \\n```\\nWe need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh\\n```"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "This should be tagged as EASY :\n-  The problem is not that hard ( Though is a good one for beginner )\n-  The solutions mostly require tools LeetCode it self considers \"Fundamental\"\n-  The problem has many different ways it can be solved (Like many other Easy problems on the site )\n- The test case Constraints are smaller so that a solution with high time and space complexity can be accepted .\n- All in all signs of an Easy LeetCode problem ."
                    },
                    {
                        "username": "jason400",
                        "content": "It's quite challenging to derive it cold. To completely and fully solve such a problem one would need to model the problem as a decision tree, identify the minimal set prepend 'a','b','c' or pass steps to arrive at the first 'abc' subsequence in the optimal solution as both satisfying the greedy choice problem and resolving the problem to an optimal substructure. Then implement either a recursive or stack-based iterative greedy algorithm using such a greedy choice. While much of the implementation around the actual values of the characters can be stripped away to leave a simple iterative algorithm, any implementation would need to derive from such a solution in order to demonstrate a full understanding of the algorithm that is being employed.\n\nAnything less would indicate either a familiarity with the problem or an aimless luck or intuition based guess, which could be a failure in any real world interview.\n    \n\n\n\n    class Solution {\n        public int addMinimum(String word) {\n            ArrayList<Character> wordStack = new ArrayList<Character>();\n            for (Character c : word.toCharArray()) {\n                wordStack.add(c);\n            }\n            ArrayList<Character> abcStack = new ArrayList<Character>();\n    \n            int j = 0;\n            while (!wordStack.isEmpty()) {\n                abcStack.add('a');\n                abcStack.add('b');\n                abcStack.add('c');\n    \n                while (!abcStack.isEmpty() && !wordStack.isEmpty()) {\n                    char c = wordStack.remove(0).charValue();\n                    char i = abcStack.remove(0).charValue();\n    \n                    if (c != i) {\n                        wordStack.add(0, c);\n                        j++;\n                    }\n                }\n    \n            }\n            return j + abcStack.size();\n        }\n    }"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int i=0,count=0,n=word.size(),res=0;\\n\\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word[i] == \\'a\\') {\\n                count++;\\n            }\\n             \\n            if(word[i] == \\'b\\') {\\n                count++;\\n            }\\n            \\n            if(word[i] == \\'c\\') {\\n                count++;\\n            }\\n            i++;\\n            res += 3 - count;\\n        }\\n        cout<<res;\\n\\n\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1864814,
                "content": [
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Replace \"abc\" -> \"0\"\\n\"ab\" -> \"1\"\\n\"bc\" -> \"1\"\\n\"ac\" -> \"1\"\\n\"a\" -> \"2\"\\n\"b\" -> \"2\"\\n\"c\" -> \"2\"\\n\\nand iterate over the new modified string and sum up all the digits.\\nNote: The order of replacing is the key"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "why im getting error for \"aaaabb\"??\\n\\n\\nclass Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int counta=0,countb=0,countc=0;\\n        for(int i=0;i<word.size();i++){\\n            if(word[i]==\\'a\\') counta++;\\n            else if(word[i]==\\'b\\') countb++;\\n            else countc++;\\n        }\\n        int m=max(max(counta,countb),countc);\\n        int res=(3*m)-counta-countb-countc;\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "krishna859768",
                        "content": "same problem\\nHave you find the reason?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "One of the most amazing question i solved on LC. Pure Logical, and the feeling of acceptance in one go is heavenly.  "
                    },
                    {
                        "username": "chachraanubhav",
                        "content": "Did anyone try the LCS approach ? I know it will take O(N^2) , and there is a simple iterative method that works in O(N)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone tell me the thought process how he/she come up with a Solution."
                    },
                    {
                        "username": "jason400",
                        "content": "If you want to be able to reliably derive a solution on sight without making lucky guesses or pattern recognition from similar problems, other thought processes like trying to recognize a pattern and then coding something up until it works won't cut it IMO. That would make it seem like you saw the problem before and turn the interview into essentially floundering around with intuition until you hopefully arrive at a solution in time. This is my thought process.\n1) Realize the problem is an optimization problem over a decision space of exponential size (branching factor at least 3), and note that a search over the problem space implemented with a simple recursion with backtracking implementation will yield a correct, albeit exponential runtime.\n2) Using your observation from #1, and your knowledge that greedy algorithms are often employed to efficiently optimize a set of decisions over even exponentially sized search trees, begin examining a set of 'localized' choices that might exhibit the Greedy Choice Property\n3) Observe that every valid solution modifies the problem space to a string that begins with 'abc', therefore, the optimal solution must contain these set of localized steps. Use intuition to posit that one 'choice' (set of local decisions) we can make would be to minimally append either an a,b,c to each of the initial characters until we arrive at 'abc'. Perform a quick 'proof' by contradiction in your head to gain confidence that no optimal solution excludes this minimal set of decisions. You have identified a choice that satisfies the Greedy Choice Property\n4) Realize that the Greedy Choice you have identified leads to a substructure decomposition which is also an optimal substructure (no surprise there, but good to check)\n5) Using the 'choice' you have identified as satisfying both the Greedy Choice Property and resolving the problem to an Optimal Substructure (you need those two things to proceed with confidence that your algorithm will actually work) implement a greedy algorithm using a combination of iteration and/or recursion, and use LinkedList backed stacks are your data structure to demonstrate additional mastery of data structures\n6) [Very Optional at best IMO] Further simplify the implementation by ripping out the linkedlist/stacks data structures, and any references to characters, by leveraging properties of ascii characters to achieve a slight constant time reduction in both runtime and memory, as well as LOC\n"
                    },
                    {
                        "username": "Kai_Ghost",
                        "content": "Find the pattern in the string in the nested while loop in the code beneath \n\n```\nclass Solution {\npublic:\n    int addMinimum(string word) {\n        int res = 0;\n        int ptr1 = 0;\n        int n = word.size();\n        while (ptr1 < n) {\n            char starting = word[ptr1];\n            int temp = ptr1 + 1;\n            char prev = starting;\n            while (temp < n && word[temp] > prev) {\n                prev = word[temp];\n                temp++;\n            }\n\n            res += 3 - (temp - ptr1);\n            ptr1 = temp;\n            \n        }\n\n\n\n\n\n        return res;\n\n        \n    }\n};\n\n\n```"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "we will interate word and check if expected letter is there or not according to repeating pattern of \"abc\" .if not present we increment count and increment and modulo index (we are adding a missing char to word)"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Leetcode, why is the result for \"aaaabb\" 9? I think it\\'s 6 because for 4 - a, 2 - b, 0 - c you need to add 2 \"b\" and 4 \"c\""
                    },
                    {
                        "username": "Dhaval25",
                        "content": "[a]bc [a]bc [a]bc  [ab]c  a[b]c :  As you can see the number of non-square brackets is 9 not 6. We add bc for first 3 \\'a\\' then we club 4th \\'ab\\' together and add \\'c\\' and for last \\'b\\' we add \\'ac\\' so in total we added 9 characters "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You can\\'t change the position of Characters.That\\'s why bb also need 2a and 2c."
                    },
                    {
                        "username": "bharat231",
                        "content": "We need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh"
                    },
                    {
                        "username": "Tim-Ax",
                        "content": "word = \\'aaaabb\\'\\n\\u041Eutput 6\\nExpected. 9\\nI meant it like that:\\naaaabb-> a a a a b b ->  ab ab a a => ab+c   ab+c   b+bc    b+bc\\nc c b c b c     6 letters\\n\\nDid I misunderstand the task?  :)\\nThanks"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "The question says \"you can insert letters \"a\", \"b\" or \"c\" anywhere and any number of times\".  So, I don\\'t think you can move around the existing letters.  \\n\\nSo, in this case the solution will be \\n      aaaabb \\n=> a a a a b b \\n=> a (bc) a (bc) a (bc) a b (c) (a) b (c)\\n=> abc abc abc abc abc \\n\\ninserted : b c b c b c c a c \\n"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "For this string, \"aaaabb\" => my output is 6, but it says 9 expected output"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "[@sergei-durkin](/sergei-durkin) hi bro, actually it s correct , we cannot move letters of word , so we need to validate it as it is "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "You are right, Litcode described the problem incorrectly. I also fell into this trap)\\n\\nif we look at this problem from the other side, we need to make valid string for each symbol in this string\\n\\nbharat231 described the answer to your question \\n```\\nWe need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh\\n```"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "This should be tagged as EASY :\n-  The problem is not that hard ( Though is a good one for beginner )\n-  The solutions mostly require tools LeetCode it self considers \"Fundamental\"\n-  The problem has many different ways it can be solved (Like many other Easy problems on the site )\n- The test case Constraints are smaller so that a solution with high time and space complexity can be accepted .\n- All in all signs of an Easy LeetCode problem ."
                    },
                    {
                        "username": "jason400",
                        "content": "It's quite challenging to derive it cold. To completely and fully solve such a problem one would need to model the problem as a decision tree, identify the minimal set prepend 'a','b','c' or pass steps to arrive at the first 'abc' subsequence in the optimal solution as both satisfying the greedy choice problem and resolving the problem to an optimal substructure. Then implement either a recursive or stack-based iterative greedy algorithm using such a greedy choice. While much of the implementation around the actual values of the characters can be stripped away to leave a simple iterative algorithm, any implementation would need to derive from such a solution in order to demonstrate a full understanding of the algorithm that is being employed.\n\nAnything less would indicate either a familiarity with the problem or an aimless luck or intuition based guess, which could be a failure in any real world interview.\n    \n\n\n\n    class Solution {\n        public int addMinimum(String word) {\n            ArrayList<Character> wordStack = new ArrayList<Character>();\n            for (Character c : word.toCharArray()) {\n                wordStack.add(c);\n            }\n            ArrayList<Character> abcStack = new ArrayList<Character>();\n    \n            int j = 0;\n            while (!wordStack.isEmpty()) {\n                abcStack.add('a');\n                abcStack.add('b');\n                abcStack.add('c');\n    \n                while (!abcStack.isEmpty() && !wordStack.isEmpty()) {\n                    char c = wordStack.remove(0).charValue();\n                    char i = abcStack.remove(0).charValue();\n    \n                    if (c != i) {\n                        wordStack.add(0, c);\n                        j++;\n                    }\n                }\n    \n            }\n            return j + abcStack.size();\n        }\n    }"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int i=0,count=0,n=word.size(),res=0;\\n\\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word[i] == \\'a\\') {\\n                count++;\\n            }\\n             \\n            if(word[i] == \\'b\\') {\\n                count++;\\n            }\\n            \\n            if(word[i] == \\'c\\') {\\n                count++;\\n            }\\n            i++;\\n            res += 3 - count;\\n        }\\n        cout<<res;\\n\\n\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1864768,
                "content": [
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Replace \"abc\" -> \"0\"\\n\"ab\" -> \"1\"\\n\"bc\" -> \"1\"\\n\"ac\" -> \"1\"\\n\"a\" -> \"2\"\\n\"b\" -> \"2\"\\n\"c\" -> \"2\"\\n\\nand iterate over the new modified string and sum up all the digits.\\nNote: The order of replacing is the key"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "why im getting error for \"aaaabb\"??\\n\\n\\nclass Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int counta=0,countb=0,countc=0;\\n        for(int i=0;i<word.size();i++){\\n            if(word[i]==\\'a\\') counta++;\\n            else if(word[i]==\\'b\\') countb++;\\n            else countc++;\\n        }\\n        int m=max(max(counta,countb),countc);\\n        int res=(3*m)-counta-countb-countc;\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "krishna859768",
                        "content": "same problem\\nHave you find the reason?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "One of the most amazing question i solved on LC. Pure Logical, and the feeling of acceptance in one go is heavenly.  "
                    },
                    {
                        "username": "chachraanubhav",
                        "content": "Did anyone try the LCS approach ? I know it will take O(N^2) , and there is a simple iterative method that works in O(N)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone tell me the thought process how he/she come up with a Solution."
                    },
                    {
                        "username": "jason400",
                        "content": "If you want to be able to reliably derive a solution on sight without making lucky guesses or pattern recognition from similar problems, other thought processes like trying to recognize a pattern and then coding something up until it works won't cut it IMO. That would make it seem like you saw the problem before and turn the interview into essentially floundering around with intuition until you hopefully arrive at a solution in time. This is my thought process.\n1) Realize the problem is an optimization problem over a decision space of exponential size (branching factor at least 3), and note that a search over the problem space implemented with a simple recursion with backtracking implementation will yield a correct, albeit exponential runtime.\n2) Using your observation from #1, and your knowledge that greedy algorithms are often employed to efficiently optimize a set of decisions over even exponentially sized search trees, begin examining a set of 'localized' choices that might exhibit the Greedy Choice Property\n3) Observe that every valid solution modifies the problem space to a string that begins with 'abc', therefore, the optimal solution must contain these set of localized steps. Use intuition to posit that one 'choice' (set of local decisions) we can make would be to minimally append either an a,b,c to each of the initial characters until we arrive at 'abc'. Perform a quick 'proof' by contradiction in your head to gain confidence that no optimal solution excludes this minimal set of decisions. You have identified a choice that satisfies the Greedy Choice Property\n4) Realize that the Greedy Choice you have identified leads to a substructure decomposition which is also an optimal substructure (no surprise there, but good to check)\n5) Using the 'choice' you have identified as satisfying both the Greedy Choice Property and resolving the problem to an Optimal Substructure (you need those two things to proceed with confidence that your algorithm will actually work) implement a greedy algorithm using a combination of iteration and/or recursion, and use LinkedList backed stacks are your data structure to demonstrate additional mastery of data structures\n6) [Very Optional at best IMO] Further simplify the implementation by ripping out the linkedlist/stacks data structures, and any references to characters, by leveraging properties of ascii characters to achieve a slight constant time reduction in both runtime and memory, as well as LOC\n"
                    },
                    {
                        "username": "Kai_Ghost",
                        "content": "Find the pattern in the string in the nested while loop in the code beneath \n\n```\nclass Solution {\npublic:\n    int addMinimum(string word) {\n        int res = 0;\n        int ptr1 = 0;\n        int n = word.size();\n        while (ptr1 < n) {\n            char starting = word[ptr1];\n            int temp = ptr1 + 1;\n            char prev = starting;\n            while (temp < n && word[temp] > prev) {\n                prev = word[temp];\n                temp++;\n            }\n\n            res += 3 - (temp - ptr1);\n            ptr1 = temp;\n            \n        }\n\n\n\n\n\n        return res;\n\n        \n    }\n};\n\n\n```"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "we will interate word and check if expected letter is there or not according to repeating pattern of \"abc\" .if not present we increment count and increment and modulo index (we are adding a missing char to word)"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Leetcode, why is the result for \"aaaabb\" 9? I think it\\'s 6 because for 4 - a, 2 - b, 0 - c you need to add 2 \"b\" and 4 \"c\""
                    },
                    {
                        "username": "Dhaval25",
                        "content": "[a]bc [a]bc [a]bc  [ab]c  a[b]c :  As you can see the number of non-square brackets is 9 not 6. We add bc for first 3 \\'a\\' then we club 4th \\'ab\\' together and add \\'c\\' and for last \\'b\\' we add \\'ac\\' so in total we added 9 characters "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You can\\'t change the position of Characters.That\\'s why bb also need 2a and 2c."
                    },
                    {
                        "username": "bharat231",
                        "content": "We need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh"
                    },
                    {
                        "username": "Tim-Ax",
                        "content": "word = \\'aaaabb\\'\\n\\u041Eutput 6\\nExpected. 9\\nI meant it like that:\\naaaabb-> a a a a b b ->  ab ab a a => ab+c   ab+c   b+bc    b+bc\\nc c b c b c     6 letters\\n\\nDid I misunderstand the task?  :)\\nThanks"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "The question says \"you can insert letters \"a\", \"b\" or \"c\" anywhere and any number of times\".  So, I don\\'t think you can move around the existing letters.  \\n\\nSo, in this case the solution will be \\n      aaaabb \\n=> a a a a b b \\n=> a (bc) a (bc) a (bc) a b (c) (a) b (c)\\n=> abc abc abc abc abc \\n\\ninserted : b c b c b c c a c \\n"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "For this string, \"aaaabb\" => my output is 6, but it says 9 expected output"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "[@sergei-durkin](/sergei-durkin) hi bro, actually it s correct , we cannot move letters of word , so we need to validate it as it is "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "You are right, Litcode described the problem incorrectly. I also fell into this trap)\\n\\nif we look at this problem from the other side, we need to make valid string for each symbol in this string\\n\\nbharat231 described the answer to your question \\n```\\nWe need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh\\n```"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "This should be tagged as EASY :\n-  The problem is not that hard ( Though is a good one for beginner )\n-  The solutions mostly require tools LeetCode it self considers \"Fundamental\"\n-  The problem has many different ways it can be solved (Like many other Easy problems on the site )\n- The test case Constraints are smaller so that a solution with high time and space complexity can be accepted .\n- All in all signs of an Easy LeetCode problem ."
                    },
                    {
                        "username": "jason400",
                        "content": "It's quite challenging to derive it cold. To completely and fully solve such a problem one would need to model the problem as a decision tree, identify the minimal set prepend 'a','b','c' or pass steps to arrive at the first 'abc' subsequence in the optimal solution as both satisfying the greedy choice problem and resolving the problem to an optimal substructure. Then implement either a recursive or stack-based iterative greedy algorithm using such a greedy choice. While much of the implementation around the actual values of the characters can be stripped away to leave a simple iterative algorithm, any implementation would need to derive from such a solution in order to demonstrate a full understanding of the algorithm that is being employed.\n\nAnything less would indicate either a familiarity with the problem or an aimless luck or intuition based guess, which could be a failure in any real world interview.\n    \n\n\n\n    class Solution {\n        public int addMinimum(String word) {\n            ArrayList<Character> wordStack = new ArrayList<Character>();\n            for (Character c : word.toCharArray()) {\n                wordStack.add(c);\n            }\n            ArrayList<Character> abcStack = new ArrayList<Character>();\n    \n            int j = 0;\n            while (!wordStack.isEmpty()) {\n                abcStack.add('a');\n                abcStack.add('b');\n                abcStack.add('c');\n    \n                while (!abcStack.isEmpty() && !wordStack.isEmpty()) {\n                    char c = wordStack.remove(0).charValue();\n                    char i = abcStack.remove(0).charValue();\n    \n                    if (c != i) {\n                        wordStack.add(0, c);\n                        j++;\n                    }\n                }\n    \n            }\n            return j + abcStack.size();\n        }\n    }"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int i=0,count=0,n=word.size(),res=0;\\n\\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word[i] == \\'a\\') {\\n                count++;\\n            }\\n             \\n            if(word[i] == \\'b\\') {\\n                count++;\\n            }\\n            \\n            if(word[i] == \\'c\\') {\\n                count++;\\n            }\\n            i++;\\n            res += 3 - count;\\n        }\\n        cout<<res;\\n\\n\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2075372,
                "content": [
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Replace \"abc\" -> \"0\"\\n\"ab\" -> \"1\"\\n\"bc\" -> \"1\"\\n\"ac\" -> \"1\"\\n\"a\" -> \"2\"\\n\"b\" -> \"2\"\\n\"c\" -> \"2\"\\n\\nand iterate over the new modified string and sum up all the digits.\\nNote: The order of replacing is the key"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "why im getting error for \"aaaabb\"??\\n\\n\\nclass Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int counta=0,countb=0,countc=0;\\n        for(int i=0;i<word.size();i++){\\n            if(word[i]==\\'a\\') counta++;\\n            else if(word[i]==\\'b\\') countb++;\\n            else countc++;\\n        }\\n        int m=max(max(counta,countb),countc);\\n        int res=(3*m)-counta-countb-countc;\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "krishna859768",
                        "content": "same problem\\nHave you find the reason?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "One of the most amazing question i solved on LC. Pure Logical, and the feeling of acceptance in one go is heavenly.  "
                    },
                    {
                        "username": "chachraanubhav",
                        "content": "Did anyone try the LCS approach ? I know it will take O(N^2) , and there is a simple iterative method that works in O(N)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone tell me the thought process how he/she come up with a Solution."
                    },
                    {
                        "username": "jason400",
                        "content": "If you want to be able to reliably derive a solution on sight without making lucky guesses or pattern recognition from similar problems, other thought processes like trying to recognize a pattern and then coding something up until it works won't cut it IMO. That would make it seem like you saw the problem before and turn the interview into essentially floundering around with intuition until you hopefully arrive at a solution in time. This is my thought process.\n1) Realize the problem is an optimization problem over a decision space of exponential size (branching factor at least 3), and note that a search over the problem space implemented with a simple recursion with backtracking implementation will yield a correct, albeit exponential runtime.\n2) Using your observation from #1, and your knowledge that greedy algorithms are often employed to efficiently optimize a set of decisions over even exponentially sized search trees, begin examining a set of 'localized' choices that might exhibit the Greedy Choice Property\n3) Observe that every valid solution modifies the problem space to a string that begins with 'abc', therefore, the optimal solution must contain these set of localized steps. Use intuition to posit that one 'choice' (set of local decisions) we can make would be to minimally append either an a,b,c to each of the initial characters until we arrive at 'abc'. Perform a quick 'proof' by contradiction in your head to gain confidence that no optimal solution excludes this minimal set of decisions. You have identified a choice that satisfies the Greedy Choice Property\n4) Realize that the Greedy Choice you have identified leads to a substructure decomposition which is also an optimal substructure (no surprise there, but good to check)\n5) Using the 'choice' you have identified as satisfying both the Greedy Choice Property and resolving the problem to an Optimal Substructure (you need those two things to proceed with confidence that your algorithm will actually work) implement a greedy algorithm using a combination of iteration and/or recursion, and use LinkedList backed stacks are your data structure to demonstrate additional mastery of data structures\n6) [Very Optional at best IMO] Further simplify the implementation by ripping out the linkedlist/stacks data structures, and any references to characters, by leveraging properties of ascii characters to achieve a slight constant time reduction in both runtime and memory, as well as LOC\n"
                    },
                    {
                        "username": "Kai_Ghost",
                        "content": "Find the pattern in the string in the nested while loop in the code beneath \n\n```\nclass Solution {\npublic:\n    int addMinimum(string word) {\n        int res = 0;\n        int ptr1 = 0;\n        int n = word.size();\n        while (ptr1 < n) {\n            char starting = word[ptr1];\n            int temp = ptr1 + 1;\n            char prev = starting;\n            while (temp < n && word[temp] > prev) {\n                prev = word[temp];\n                temp++;\n            }\n\n            res += 3 - (temp - ptr1);\n            ptr1 = temp;\n            \n        }\n\n\n\n\n\n        return res;\n\n        \n    }\n};\n\n\n```"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "we will interate word and check if expected letter is there or not according to repeating pattern of \"abc\" .if not present we increment count and increment and modulo index (we are adding a missing char to word)"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Leetcode, why is the result for \"aaaabb\" 9? I think it\\'s 6 because for 4 - a, 2 - b, 0 - c you need to add 2 \"b\" and 4 \"c\""
                    },
                    {
                        "username": "Dhaval25",
                        "content": "[a]bc [a]bc [a]bc  [ab]c  a[b]c :  As you can see the number of non-square brackets is 9 not 6. We add bc for first 3 \\'a\\' then we club 4th \\'ab\\' together and add \\'c\\' and for last \\'b\\' we add \\'ac\\' so in total we added 9 characters "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You can\\'t change the position of Characters.That\\'s why bb also need 2a and 2c."
                    },
                    {
                        "username": "bharat231",
                        "content": "We need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh"
                    },
                    {
                        "username": "Tim-Ax",
                        "content": "word = \\'aaaabb\\'\\n\\u041Eutput 6\\nExpected. 9\\nI meant it like that:\\naaaabb-> a a a a b b ->  ab ab a a => ab+c   ab+c   b+bc    b+bc\\nc c b c b c     6 letters\\n\\nDid I misunderstand the task?  :)\\nThanks"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "The question says \"you can insert letters \"a\", \"b\" or \"c\" anywhere and any number of times\".  So, I don\\'t think you can move around the existing letters.  \\n\\nSo, in this case the solution will be \\n      aaaabb \\n=> a a a a b b \\n=> a (bc) a (bc) a (bc) a b (c) (a) b (c)\\n=> abc abc abc abc abc \\n\\ninserted : b c b c b c c a c \\n"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "For this string, \"aaaabb\" => my output is 6, but it says 9 expected output"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "[@sergei-durkin](/sergei-durkin) hi bro, actually it s correct , we cannot move letters of word , so we need to validate it as it is "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "You are right, Litcode described the problem incorrectly. I also fell into this trap)\\n\\nif we look at this problem from the other side, we need to make valid string for each symbol in this string\\n\\nbharat231 described the answer to your question \\n```\\nWe need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh\\n```"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "This should be tagged as EASY :\n-  The problem is not that hard ( Though is a good one for beginner )\n-  The solutions mostly require tools LeetCode it self considers \"Fundamental\"\n-  The problem has many different ways it can be solved (Like many other Easy problems on the site )\n- The test case Constraints are smaller so that a solution with high time and space complexity can be accepted .\n- All in all signs of an Easy LeetCode problem ."
                    },
                    {
                        "username": "jason400",
                        "content": "It's quite challenging to derive it cold. To completely and fully solve such a problem one would need to model the problem as a decision tree, identify the minimal set prepend 'a','b','c' or pass steps to arrive at the first 'abc' subsequence in the optimal solution as both satisfying the greedy choice problem and resolving the problem to an optimal substructure. Then implement either a recursive or stack-based iterative greedy algorithm using such a greedy choice. While much of the implementation around the actual values of the characters can be stripped away to leave a simple iterative algorithm, any implementation would need to derive from such a solution in order to demonstrate a full understanding of the algorithm that is being employed.\n\nAnything less would indicate either a familiarity with the problem or an aimless luck or intuition based guess, which could be a failure in any real world interview.\n    \n\n\n\n    class Solution {\n        public int addMinimum(String word) {\n            ArrayList<Character> wordStack = new ArrayList<Character>();\n            for (Character c : word.toCharArray()) {\n                wordStack.add(c);\n            }\n            ArrayList<Character> abcStack = new ArrayList<Character>();\n    \n            int j = 0;\n            while (!wordStack.isEmpty()) {\n                abcStack.add('a');\n                abcStack.add('b');\n                abcStack.add('c');\n    \n                while (!abcStack.isEmpty() && !wordStack.isEmpty()) {\n                    char c = wordStack.remove(0).charValue();\n                    char i = abcStack.remove(0).charValue();\n    \n                    if (c != i) {\n                        wordStack.add(0, c);\n                        j++;\n                    }\n                }\n    \n            }\n            return j + abcStack.size();\n        }\n    }"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int i=0,count=0,n=word.size(),res=0;\\n\\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word[i] == \\'a\\') {\\n                count++;\\n            }\\n             \\n            if(word[i] == \\'b\\') {\\n                count++;\\n            }\\n            \\n            if(word[i] == \\'c\\') {\\n                count++;\\n            }\\n            i++;\\n            res += 3 - count;\\n        }\\n        cout<<res;\\n\\n\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2022727,
                "content": [
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Replace \"abc\" -> \"0\"\\n\"ab\" -> \"1\"\\n\"bc\" -> \"1\"\\n\"ac\" -> \"1\"\\n\"a\" -> \"2\"\\n\"b\" -> \"2\"\\n\"c\" -> \"2\"\\n\\nand iterate over the new modified string and sum up all the digits.\\nNote: The order of replacing is the key"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "why im getting error for \"aaaabb\"??\\n\\n\\nclass Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int counta=0,countb=0,countc=0;\\n        for(int i=0;i<word.size();i++){\\n            if(word[i]==\\'a\\') counta++;\\n            else if(word[i]==\\'b\\') countb++;\\n            else countc++;\\n        }\\n        int m=max(max(counta,countb),countc);\\n        int res=(3*m)-counta-countb-countc;\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "krishna859768",
                        "content": "same problem\\nHave you find the reason?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "One of the most amazing question i solved on LC. Pure Logical, and the feeling of acceptance in one go is heavenly.  "
                    },
                    {
                        "username": "chachraanubhav",
                        "content": "Did anyone try the LCS approach ? I know it will take O(N^2) , and there is a simple iterative method that works in O(N)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone tell me the thought process how he/she come up with a Solution."
                    },
                    {
                        "username": "jason400",
                        "content": "If you want to be able to reliably derive a solution on sight without making lucky guesses or pattern recognition from similar problems, other thought processes like trying to recognize a pattern and then coding something up until it works won't cut it IMO. That would make it seem like you saw the problem before and turn the interview into essentially floundering around with intuition until you hopefully arrive at a solution in time. This is my thought process.\n1) Realize the problem is an optimization problem over a decision space of exponential size (branching factor at least 3), and note that a search over the problem space implemented with a simple recursion with backtracking implementation will yield a correct, albeit exponential runtime.\n2) Using your observation from #1, and your knowledge that greedy algorithms are often employed to efficiently optimize a set of decisions over even exponentially sized search trees, begin examining a set of 'localized' choices that might exhibit the Greedy Choice Property\n3) Observe that every valid solution modifies the problem space to a string that begins with 'abc', therefore, the optimal solution must contain these set of localized steps. Use intuition to posit that one 'choice' (set of local decisions) we can make would be to minimally append either an a,b,c to each of the initial characters until we arrive at 'abc'. Perform a quick 'proof' by contradiction in your head to gain confidence that no optimal solution excludes this minimal set of decisions. You have identified a choice that satisfies the Greedy Choice Property\n4) Realize that the Greedy Choice you have identified leads to a substructure decomposition which is also an optimal substructure (no surprise there, but good to check)\n5) Using the 'choice' you have identified as satisfying both the Greedy Choice Property and resolving the problem to an Optimal Substructure (you need those two things to proceed with confidence that your algorithm will actually work) implement a greedy algorithm using a combination of iteration and/or recursion, and use LinkedList backed stacks are your data structure to demonstrate additional mastery of data structures\n6) [Very Optional at best IMO] Further simplify the implementation by ripping out the linkedlist/stacks data structures, and any references to characters, by leveraging properties of ascii characters to achieve a slight constant time reduction in both runtime and memory, as well as LOC\n"
                    },
                    {
                        "username": "Kai_Ghost",
                        "content": "Find the pattern in the string in the nested while loop in the code beneath \n\n```\nclass Solution {\npublic:\n    int addMinimum(string word) {\n        int res = 0;\n        int ptr1 = 0;\n        int n = word.size();\n        while (ptr1 < n) {\n            char starting = word[ptr1];\n            int temp = ptr1 + 1;\n            char prev = starting;\n            while (temp < n && word[temp] > prev) {\n                prev = word[temp];\n                temp++;\n            }\n\n            res += 3 - (temp - ptr1);\n            ptr1 = temp;\n            \n        }\n\n\n\n\n\n        return res;\n\n        \n    }\n};\n\n\n```"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "we will interate word and check if expected letter is there or not according to repeating pattern of \"abc\" .if not present we increment count and increment and modulo index (we are adding a missing char to word)"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Leetcode, why is the result for \"aaaabb\" 9? I think it\\'s 6 because for 4 - a, 2 - b, 0 - c you need to add 2 \"b\" and 4 \"c\""
                    },
                    {
                        "username": "Dhaval25",
                        "content": "[a]bc [a]bc [a]bc  [ab]c  a[b]c :  As you can see the number of non-square brackets is 9 not 6. We add bc for first 3 \\'a\\' then we club 4th \\'ab\\' together and add \\'c\\' and for last \\'b\\' we add \\'ac\\' so in total we added 9 characters "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You can\\'t change the position of Characters.That\\'s why bb also need 2a and 2c."
                    },
                    {
                        "username": "bharat231",
                        "content": "We need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh"
                    },
                    {
                        "username": "Tim-Ax",
                        "content": "word = \\'aaaabb\\'\\n\\u041Eutput 6\\nExpected. 9\\nI meant it like that:\\naaaabb-> a a a a b b ->  ab ab a a => ab+c   ab+c   b+bc    b+bc\\nc c b c b c     6 letters\\n\\nDid I misunderstand the task?  :)\\nThanks"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "The question says \"you can insert letters \"a\", \"b\" or \"c\" anywhere and any number of times\".  So, I don\\'t think you can move around the existing letters.  \\n\\nSo, in this case the solution will be \\n      aaaabb \\n=> a a a a b b \\n=> a (bc) a (bc) a (bc) a b (c) (a) b (c)\\n=> abc abc abc abc abc \\n\\ninserted : b c b c b c c a c \\n"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "For this string, \"aaaabb\" => my output is 6, but it says 9 expected output"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "[@sergei-durkin](/sergei-durkin) hi bro, actually it s correct , we cannot move letters of word , so we need to validate it as it is "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "You are right, Litcode described the problem incorrectly. I also fell into this trap)\\n\\nif we look at this problem from the other side, we need to make valid string for each symbol in this string\\n\\nbharat231 described the answer to your question \\n```\\nWe need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh\\n```"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "This should be tagged as EASY :\n-  The problem is not that hard ( Though is a good one for beginner )\n-  The solutions mostly require tools LeetCode it self considers \"Fundamental\"\n-  The problem has many different ways it can be solved (Like many other Easy problems on the site )\n- The test case Constraints are smaller so that a solution with high time and space complexity can be accepted .\n- All in all signs of an Easy LeetCode problem ."
                    },
                    {
                        "username": "jason400",
                        "content": "It's quite challenging to derive it cold. To completely and fully solve such a problem one would need to model the problem as a decision tree, identify the minimal set prepend 'a','b','c' or pass steps to arrive at the first 'abc' subsequence in the optimal solution as both satisfying the greedy choice problem and resolving the problem to an optimal substructure. Then implement either a recursive or stack-based iterative greedy algorithm using such a greedy choice. While much of the implementation around the actual values of the characters can be stripped away to leave a simple iterative algorithm, any implementation would need to derive from such a solution in order to demonstrate a full understanding of the algorithm that is being employed.\n\nAnything less would indicate either a familiarity with the problem or an aimless luck or intuition based guess, which could be a failure in any real world interview.\n    \n\n\n\n    class Solution {\n        public int addMinimum(String word) {\n            ArrayList<Character> wordStack = new ArrayList<Character>();\n            for (Character c : word.toCharArray()) {\n                wordStack.add(c);\n            }\n            ArrayList<Character> abcStack = new ArrayList<Character>();\n    \n            int j = 0;\n            while (!wordStack.isEmpty()) {\n                abcStack.add('a');\n                abcStack.add('b');\n                abcStack.add('c');\n    \n                while (!abcStack.isEmpty() && !wordStack.isEmpty()) {\n                    char c = wordStack.remove(0).charValue();\n                    char i = abcStack.remove(0).charValue();\n    \n                    if (c != i) {\n                        wordStack.add(0, c);\n                        j++;\n                    }\n                }\n    \n            }\n            return j + abcStack.size();\n        }\n    }"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int i=0,count=0,n=word.size(),res=0;\\n\\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word[i] == \\'a\\') {\\n                count++;\\n            }\\n             \\n            if(word[i] == \\'b\\') {\\n                count++;\\n            }\\n            \\n            if(word[i] == \\'c\\') {\\n                count++;\\n            }\\n            i++;\\n            res += 3 - count;\\n        }\\n        cout<<res;\\n\\n\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1902740,
                "content": [
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Replace \"abc\" -> \"0\"\\n\"ab\" -> \"1\"\\n\"bc\" -> \"1\"\\n\"ac\" -> \"1\"\\n\"a\" -> \"2\"\\n\"b\" -> \"2\"\\n\"c\" -> \"2\"\\n\\nand iterate over the new modified string and sum up all the digits.\\nNote: The order of replacing is the key"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "why im getting error for \"aaaabb\"??\\n\\n\\nclass Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int counta=0,countb=0,countc=0;\\n        for(int i=0;i<word.size();i++){\\n            if(word[i]==\\'a\\') counta++;\\n            else if(word[i]==\\'b\\') countb++;\\n            else countc++;\\n        }\\n        int m=max(max(counta,countb),countc);\\n        int res=(3*m)-counta-countb-countc;\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "krishna859768",
                        "content": "same problem\\nHave you find the reason?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "One of the most amazing question i solved on LC. Pure Logical, and the feeling of acceptance in one go is heavenly.  "
                    },
                    {
                        "username": "chachraanubhav",
                        "content": "Did anyone try the LCS approach ? I know it will take O(N^2) , and there is a simple iterative method that works in O(N)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone tell me the thought process how he/she come up with a Solution."
                    },
                    {
                        "username": "jason400",
                        "content": "If you want to be able to reliably derive a solution on sight without making lucky guesses or pattern recognition from similar problems, other thought processes like trying to recognize a pattern and then coding something up until it works won't cut it IMO. That would make it seem like you saw the problem before and turn the interview into essentially floundering around with intuition until you hopefully arrive at a solution in time. This is my thought process.\n1) Realize the problem is an optimization problem over a decision space of exponential size (branching factor at least 3), and note that a search over the problem space implemented with a simple recursion with backtracking implementation will yield a correct, albeit exponential runtime.\n2) Using your observation from #1, and your knowledge that greedy algorithms are often employed to efficiently optimize a set of decisions over even exponentially sized search trees, begin examining a set of 'localized' choices that might exhibit the Greedy Choice Property\n3) Observe that every valid solution modifies the problem space to a string that begins with 'abc', therefore, the optimal solution must contain these set of localized steps. Use intuition to posit that one 'choice' (set of local decisions) we can make would be to minimally append either an a,b,c to each of the initial characters until we arrive at 'abc'. Perform a quick 'proof' by contradiction in your head to gain confidence that no optimal solution excludes this minimal set of decisions. You have identified a choice that satisfies the Greedy Choice Property\n4) Realize that the Greedy Choice you have identified leads to a substructure decomposition which is also an optimal substructure (no surprise there, but good to check)\n5) Using the 'choice' you have identified as satisfying both the Greedy Choice Property and resolving the problem to an Optimal Substructure (you need those two things to proceed with confidence that your algorithm will actually work) implement a greedy algorithm using a combination of iteration and/or recursion, and use LinkedList backed stacks are your data structure to demonstrate additional mastery of data structures\n6) [Very Optional at best IMO] Further simplify the implementation by ripping out the linkedlist/stacks data structures, and any references to characters, by leveraging properties of ascii characters to achieve a slight constant time reduction in both runtime and memory, as well as LOC\n"
                    },
                    {
                        "username": "Kai_Ghost",
                        "content": "Find the pattern in the string in the nested while loop in the code beneath \n\n```\nclass Solution {\npublic:\n    int addMinimum(string word) {\n        int res = 0;\n        int ptr1 = 0;\n        int n = word.size();\n        while (ptr1 < n) {\n            char starting = word[ptr1];\n            int temp = ptr1 + 1;\n            char prev = starting;\n            while (temp < n && word[temp] > prev) {\n                prev = word[temp];\n                temp++;\n            }\n\n            res += 3 - (temp - ptr1);\n            ptr1 = temp;\n            \n        }\n\n\n\n\n\n        return res;\n\n        \n    }\n};\n\n\n```"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "we will interate word and check if expected letter is there or not according to repeating pattern of \"abc\" .if not present we increment count and increment and modulo index (we are adding a missing char to word)"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Leetcode, why is the result for \"aaaabb\" 9? I think it\\'s 6 because for 4 - a, 2 - b, 0 - c you need to add 2 \"b\" and 4 \"c\""
                    },
                    {
                        "username": "Dhaval25",
                        "content": "[a]bc [a]bc [a]bc  [ab]c  a[b]c :  As you can see the number of non-square brackets is 9 not 6. We add bc for first 3 \\'a\\' then we club 4th \\'ab\\' together and add \\'c\\' and for last \\'b\\' we add \\'ac\\' so in total we added 9 characters "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You can\\'t change the position of Characters.That\\'s why bb also need 2a and 2c."
                    },
                    {
                        "username": "bharat231",
                        "content": "We need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh"
                    },
                    {
                        "username": "Tim-Ax",
                        "content": "word = \\'aaaabb\\'\\n\\u041Eutput 6\\nExpected. 9\\nI meant it like that:\\naaaabb-> a a a a b b ->  ab ab a a => ab+c   ab+c   b+bc    b+bc\\nc c b c b c     6 letters\\n\\nDid I misunderstand the task?  :)\\nThanks"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "The question says \"you can insert letters \"a\", \"b\" or \"c\" anywhere and any number of times\".  So, I don\\'t think you can move around the existing letters.  \\n\\nSo, in this case the solution will be \\n      aaaabb \\n=> a a a a b b \\n=> a (bc) a (bc) a (bc) a b (c) (a) b (c)\\n=> abc abc abc abc abc \\n\\ninserted : b c b c b c c a c \\n"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "For this string, \"aaaabb\" => my output is 6, but it says 9 expected output"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "[@sergei-durkin](/sergei-durkin) hi bro, actually it s correct , we cannot move letters of word , so we need to validate it as it is "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "You are right, Litcode described the problem incorrectly. I also fell into this trap)\\n\\nif we look at this problem from the other side, we need to make valid string for each symbol in this string\\n\\nbharat231 described the answer to your question \\n```\\nWe need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh\\n```"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "This should be tagged as EASY :\n-  The problem is not that hard ( Though is a good one for beginner )\n-  The solutions mostly require tools LeetCode it self considers \"Fundamental\"\n-  The problem has many different ways it can be solved (Like many other Easy problems on the site )\n- The test case Constraints are smaller so that a solution with high time and space complexity can be accepted .\n- All in all signs of an Easy LeetCode problem ."
                    },
                    {
                        "username": "jason400",
                        "content": "It's quite challenging to derive it cold. To completely and fully solve such a problem one would need to model the problem as a decision tree, identify the minimal set prepend 'a','b','c' or pass steps to arrive at the first 'abc' subsequence in the optimal solution as both satisfying the greedy choice problem and resolving the problem to an optimal substructure. Then implement either a recursive or stack-based iterative greedy algorithm using such a greedy choice. While much of the implementation around the actual values of the characters can be stripped away to leave a simple iterative algorithm, any implementation would need to derive from such a solution in order to demonstrate a full understanding of the algorithm that is being employed.\n\nAnything less would indicate either a familiarity with the problem or an aimless luck or intuition based guess, which could be a failure in any real world interview.\n    \n\n\n\n    class Solution {\n        public int addMinimum(String word) {\n            ArrayList<Character> wordStack = new ArrayList<Character>();\n            for (Character c : word.toCharArray()) {\n                wordStack.add(c);\n            }\n            ArrayList<Character> abcStack = new ArrayList<Character>();\n    \n            int j = 0;\n            while (!wordStack.isEmpty()) {\n                abcStack.add('a');\n                abcStack.add('b');\n                abcStack.add('c');\n    \n                while (!abcStack.isEmpty() && !wordStack.isEmpty()) {\n                    char c = wordStack.remove(0).charValue();\n                    char i = abcStack.remove(0).charValue();\n    \n                    if (c != i) {\n                        wordStack.add(0, c);\n                        j++;\n                    }\n                }\n    \n            }\n            return j + abcStack.size();\n        }\n    }"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int i=0,count=0,n=word.size(),res=0;\\n\\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word[i] == \\'a\\') {\\n                count++;\\n            }\\n             \\n            if(word[i] == \\'b\\') {\\n                count++;\\n            }\\n            \\n            if(word[i] == \\'c\\') {\\n                count++;\\n            }\\n            i++;\\n            res += 3 - count;\\n        }\\n        cout<<res;\\n\\n\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1865638,
                "content": [
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Replace \"abc\" -> \"0\"\\n\"ab\" -> \"1\"\\n\"bc\" -> \"1\"\\n\"ac\" -> \"1\"\\n\"a\" -> \"2\"\\n\"b\" -> \"2\"\\n\"c\" -> \"2\"\\n\\nand iterate over the new modified string and sum up all the digits.\\nNote: The order of replacing is the key"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "why im getting error for \"aaaabb\"??\\n\\n\\nclass Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int counta=0,countb=0,countc=0;\\n        for(int i=0;i<word.size();i++){\\n            if(word[i]==\\'a\\') counta++;\\n            else if(word[i]==\\'b\\') countb++;\\n            else countc++;\\n        }\\n        int m=max(max(counta,countb),countc);\\n        int res=(3*m)-counta-countb-countc;\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "krishna859768",
                        "content": "same problem\\nHave you find the reason?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "One of the most amazing question i solved on LC. Pure Logical, and the feeling of acceptance in one go is heavenly.  "
                    },
                    {
                        "username": "chachraanubhav",
                        "content": "Did anyone try the LCS approach ? I know it will take O(N^2) , and there is a simple iterative method that works in O(N)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone tell me the thought process how he/she come up with a Solution."
                    },
                    {
                        "username": "jason400",
                        "content": "If you want to be able to reliably derive a solution on sight without making lucky guesses or pattern recognition from similar problems, other thought processes like trying to recognize a pattern and then coding something up until it works won't cut it IMO. That would make it seem like you saw the problem before and turn the interview into essentially floundering around with intuition until you hopefully arrive at a solution in time. This is my thought process.\n1) Realize the problem is an optimization problem over a decision space of exponential size (branching factor at least 3), and note that a search over the problem space implemented with a simple recursion with backtracking implementation will yield a correct, albeit exponential runtime.\n2) Using your observation from #1, and your knowledge that greedy algorithms are often employed to efficiently optimize a set of decisions over even exponentially sized search trees, begin examining a set of 'localized' choices that might exhibit the Greedy Choice Property\n3) Observe that every valid solution modifies the problem space to a string that begins with 'abc', therefore, the optimal solution must contain these set of localized steps. Use intuition to posit that one 'choice' (set of local decisions) we can make would be to minimally append either an a,b,c to each of the initial characters until we arrive at 'abc'. Perform a quick 'proof' by contradiction in your head to gain confidence that no optimal solution excludes this minimal set of decisions. You have identified a choice that satisfies the Greedy Choice Property\n4) Realize that the Greedy Choice you have identified leads to a substructure decomposition which is also an optimal substructure (no surprise there, but good to check)\n5) Using the 'choice' you have identified as satisfying both the Greedy Choice Property and resolving the problem to an Optimal Substructure (you need those two things to proceed with confidence that your algorithm will actually work) implement a greedy algorithm using a combination of iteration and/or recursion, and use LinkedList backed stacks are your data structure to demonstrate additional mastery of data structures\n6) [Very Optional at best IMO] Further simplify the implementation by ripping out the linkedlist/stacks data structures, and any references to characters, by leveraging properties of ascii characters to achieve a slight constant time reduction in both runtime and memory, as well as LOC\n"
                    },
                    {
                        "username": "Kai_Ghost",
                        "content": "Find the pattern in the string in the nested while loop in the code beneath \n\n```\nclass Solution {\npublic:\n    int addMinimum(string word) {\n        int res = 0;\n        int ptr1 = 0;\n        int n = word.size();\n        while (ptr1 < n) {\n            char starting = word[ptr1];\n            int temp = ptr1 + 1;\n            char prev = starting;\n            while (temp < n && word[temp] > prev) {\n                prev = word[temp];\n                temp++;\n            }\n\n            res += 3 - (temp - ptr1);\n            ptr1 = temp;\n            \n        }\n\n\n\n\n\n        return res;\n\n        \n    }\n};\n\n\n```"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "we will interate word and check if expected letter is there or not according to repeating pattern of \"abc\" .if not present we increment count and increment and modulo index (we are adding a missing char to word)"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Leetcode, why is the result for \"aaaabb\" 9? I think it\\'s 6 because for 4 - a, 2 - b, 0 - c you need to add 2 \"b\" and 4 \"c\""
                    },
                    {
                        "username": "Dhaval25",
                        "content": "[a]bc [a]bc [a]bc  [ab]c  a[b]c :  As you can see the number of non-square brackets is 9 not 6. We add bc for first 3 \\'a\\' then we club 4th \\'ab\\' together and add \\'c\\' and for last \\'b\\' we add \\'ac\\' so in total we added 9 characters "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You can\\'t change the position of Characters.That\\'s why bb also need 2a and 2c."
                    },
                    {
                        "username": "bharat231",
                        "content": "We need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh"
                    },
                    {
                        "username": "Tim-Ax",
                        "content": "word = \\'aaaabb\\'\\n\\u041Eutput 6\\nExpected. 9\\nI meant it like that:\\naaaabb-> a a a a b b ->  ab ab a a => ab+c   ab+c   b+bc    b+bc\\nc c b c b c     6 letters\\n\\nDid I misunderstand the task?  :)\\nThanks"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "The question says \"you can insert letters \"a\", \"b\" or \"c\" anywhere and any number of times\".  So, I don\\'t think you can move around the existing letters.  \\n\\nSo, in this case the solution will be \\n      aaaabb \\n=> a a a a b b \\n=> a (bc) a (bc) a (bc) a b (c) (a) b (c)\\n=> abc abc abc abc abc \\n\\ninserted : b c b c b c c a c \\n"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "For this string, \"aaaabb\" => my output is 6, but it says 9 expected output"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "[@sergei-durkin](/sergei-durkin) hi bro, actually it s correct , we cannot move letters of word , so we need to validate it as it is "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "You are right, Litcode described the problem incorrectly. I also fell into this trap)\\n\\nif we look at this problem from the other side, we need to make valid string for each symbol in this string\\n\\nbharat231 described the answer to your question \\n```\\nWe need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh\\n```"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "This should be tagged as EASY :\n-  The problem is not that hard ( Though is a good one for beginner )\n-  The solutions mostly require tools LeetCode it self considers \"Fundamental\"\n-  The problem has many different ways it can be solved (Like many other Easy problems on the site )\n- The test case Constraints are smaller so that a solution with high time and space complexity can be accepted .\n- All in all signs of an Easy LeetCode problem ."
                    },
                    {
                        "username": "jason400",
                        "content": "It's quite challenging to derive it cold. To completely and fully solve such a problem one would need to model the problem as a decision tree, identify the minimal set prepend 'a','b','c' or pass steps to arrive at the first 'abc' subsequence in the optimal solution as both satisfying the greedy choice problem and resolving the problem to an optimal substructure. Then implement either a recursive or stack-based iterative greedy algorithm using such a greedy choice. While much of the implementation around the actual values of the characters can be stripped away to leave a simple iterative algorithm, any implementation would need to derive from such a solution in order to demonstrate a full understanding of the algorithm that is being employed.\n\nAnything less would indicate either a familiarity with the problem or an aimless luck or intuition based guess, which could be a failure in any real world interview.\n    \n\n\n\n    class Solution {\n        public int addMinimum(String word) {\n            ArrayList<Character> wordStack = new ArrayList<Character>();\n            for (Character c : word.toCharArray()) {\n                wordStack.add(c);\n            }\n            ArrayList<Character> abcStack = new ArrayList<Character>();\n    \n            int j = 0;\n            while (!wordStack.isEmpty()) {\n                abcStack.add('a');\n                abcStack.add('b');\n                abcStack.add('c');\n    \n                while (!abcStack.isEmpty() && !wordStack.isEmpty()) {\n                    char c = wordStack.remove(0).charValue();\n                    char i = abcStack.remove(0).charValue();\n    \n                    if (c != i) {\n                        wordStack.add(0, c);\n                        j++;\n                    }\n                }\n    \n            }\n            return j + abcStack.size();\n        }\n    }"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int i=0,count=0,n=word.size(),res=0;\\n\\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word[i] == \\'a\\') {\\n                count++;\\n            }\\n             \\n            if(word[i] == \\'b\\') {\\n                count++;\\n            }\\n            \\n            if(word[i] == \\'c\\') {\\n                count++;\\n            }\\n            i++;\\n            res += 3 - count;\\n        }\\n        cout<<res;\\n\\n\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1865764,
                "content": [
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Replace \"abc\" -> \"0\"\\n\"ab\" -> \"1\"\\n\"bc\" -> \"1\"\\n\"ac\" -> \"1\"\\n\"a\" -> \"2\"\\n\"b\" -> \"2\"\\n\"c\" -> \"2\"\\n\\nand iterate over the new modified string and sum up all the digits.\\nNote: The order of replacing is the key"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "why im getting error for \"aaaabb\"??\\n\\n\\nclass Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int counta=0,countb=0,countc=0;\\n        for(int i=0;i<word.size();i++){\\n            if(word[i]==\\'a\\') counta++;\\n            else if(word[i]==\\'b\\') countb++;\\n            else countc++;\\n        }\\n        int m=max(max(counta,countb),countc);\\n        int res=(3*m)-counta-countb-countc;\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "krishna859768",
                        "content": "same problem\\nHave you find the reason?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "One of the most amazing question i solved on LC. Pure Logical, and the feeling of acceptance in one go is heavenly.  "
                    },
                    {
                        "username": "chachraanubhav",
                        "content": "Did anyone try the LCS approach ? I know it will take O(N^2) , and there is a simple iterative method that works in O(N)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone tell me the thought process how he/she come up with a Solution."
                    },
                    {
                        "username": "jason400",
                        "content": "If you want to be able to reliably derive a solution on sight without making lucky guesses or pattern recognition from similar problems, other thought processes like trying to recognize a pattern and then coding something up until it works won't cut it IMO. That would make it seem like you saw the problem before and turn the interview into essentially floundering around with intuition until you hopefully arrive at a solution in time. This is my thought process.\n1) Realize the problem is an optimization problem over a decision space of exponential size (branching factor at least 3), and note that a search over the problem space implemented with a simple recursion with backtracking implementation will yield a correct, albeit exponential runtime.\n2) Using your observation from #1, and your knowledge that greedy algorithms are often employed to efficiently optimize a set of decisions over even exponentially sized search trees, begin examining a set of 'localized' choices that might exhibit the Greedy Choice Property\n3) Observe that every valid solution modifies the problem space to a string that begins with 'abc', therefore, the optimal solution must contain these set of localized steps. Use intuition to posit that one 'choice' (set of local decisions) we can make would be to minimally append either an a,b,c to each of the initial characters until we arrive at 'abc'. Perform a quick 'proof' by contradiction in your head to gain confidence that no optimal solution excludes this minimal set of decisions. You have identified a choice that satisfies the Greedy Choice Property\n4) Realize that the Greedy Choice you have identified leads to a substructure decomposition which is also an optimal substructure (no surprise there, but good to check)\n5) Using the 'choice' you have identified as satisfying both the Greedy Choice Property and resolving the problem to an Optimal Substructure (you need those two things to proceed with confidence that your algorithm will actually work) implement a greedy algorithm using a combination of iteration and/or recursion, and use LinkedList backed stacks are your data structure to demonstrate additional mastery of data structures\n6) [Very Optional at best IMO] Further simplify the implementation by ripping out the linkedlist/stacks data structures, and any references to characters, by leveraging properties of ascii characters to achieve a slight constant time reduction in both runtime and memory, as well as LOC\n"
                    },
                    {
                        "username": "Kai_Ghost",
                        "content": "Find the pattern in the string in the nested while loop in the code beneath \n\n```\nclass Solution {\npublic:\n    int addMinimum(string word) {\n        int res = 0;\n        int ptr1 = 0;\n        int n = word.size();\n        while (ptr1 < n) {\n            char starting = word[ptr1];\n            int temp = ptr1 + 1;\n            char prev = starting;\n            while (temp < n && word[temp] > prev) {\n                prev = word[temp];\n                temp++;\n            }\n\n            res += 3 - (temp - ptr1);\n            ptr1 = temp;\n            \n        }\n\n\n\n\n\n        return res;\n\n        \n    }\n};\n\n\n```"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "we will interate word and check if expected letter is there or not according to repeating pattern of \"abc\" .if not present we increment count and increment and modulo index (we are adding a missing char to word)"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Leetcode, why is the result for \"aaaabb\" 9? I think it\\'s 6 because for 4 - a, 2 - b, 0 - c you need to add 2 \"b\" and 4 \"c\""
                    },
                    {
                        "username": "Dhaval25",
                        "content": "[a]bc [a]bc [a]bc  [ab]c  a[b]c :  As you can see the number of non-square brackets is 9 not 6. We add bc for first 3 \\'a\\' then we club 4th \\'ab\\' together and add \\'c\\' and for last \\'b\\' we add \\'ac\\' so in total we added 9 characters "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You can\\'t change the position of Characters.That\\'s why bb also need 2a and 2c."
                    },
                    {
                        "username": "bharat231",
                        "content": "We need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh"
                    },
                    {
                        "username": "Tim-Ax",
                        "content": "word = \\'aaaabb\\'\\n\\u041Eutput 6\\nExpected. 9\\nI meant it like that:\\naaaabb-> a a a a b b ->  ab ab a a => ab+c   ab+c   b+bc    b+bc\\nc c b c b c     6 letters\\n\\nDid I misunderstand the task?  :)\\nThanks"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "The question says \"you can insert letters \"a\", \"b\" or \"c\" anywhere and any number of times\".  So, I don\\'t think you can move around the existing letters.  \\n\\nSo, in this case the solution will be \\n      aaaabb \\n=> a a a a b b \\n=> a (bc) a (bc) a (bc) a b (c) (a) b (c)\\n=> abc abc abc abc abc \\n\\ninserted : b c b c b c c a c \\n"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "For this string, \"aaaabb\" => my output is 6, but it says 9 expected output"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "[@sergei-durkin](/sergei-durkin) hi bro, actually it s correct , we cannot move letters of word , so we need to validate it as it is "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "You are right, Litcode described the problem incorrectly. I also fell into this trap)\\n\\nif we look at this problem from the other side, we need to make valid string for each symbol in this string\\n\\nbharat231 described the answer to your question \\n```\\nWe need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh\\n```"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "This should be tagged as EASY :\n-  The problem is not that hard ( Though is a good one for beginner )\n-  The solutions mostly require tools LeetCode it self considers \"Fundamental\"\n-  The problem has many different ways it can be solved (Like many other Easy problems on the site )\n- The test case Constraints are smaller so that a solution with high time and space complexity can be accepted .\n- All in all signs of an Easy LeetCode problem ."
                    },
                    {
                        "username": "jason400",
                        "content": "It's quite challenging to derive it cold. To completely and fully solve such a problem one would need to model the problem as a decision tree, identify the minimal set prepend 'a','b','c' or pass steps to arrive at the first 'abc' subsequence in the optimal solution as both satisfying the greedy choice problem and resolving the problem to an optimal substructure. Then implement either a recursive or stack-based iterative greedy algorithm using such a greedy choice. While much of the implementation around the actual values of the characters can be stripped away to leave a simple iterative algorithm, any implementation would need to derive from such a solution in order to demonstrate a full understanding of the algorithm that is being employed.\n\nAnything less would indicate either a familiarity with the problem or an aimless luck or intuition based guess, which could be a failure in any real world interview.\n    \n\n\n\n    class Solution {\n        public int addMinimum(String word) {\n            ArrayList<Character> wordStack = new ArrayList<Character>();\n            for (Character c : word.toCharArray()) {\n                wordStack.add(c);\n            }\n            ArrayList<Character> abcStack = new ArrayList<Character>();\n    \n            int j = 0;\n            while (!wordStack.isEmpty()) {\n                abcStack.add('a');\n                abcStack.add('b');\n                abcStack.add('c');\n    \n                while (!abcStack.isEmpty() && !wordStack.isEmpty()) {\n                    char c = wordStack.remove(0).charValue();\n                    char i = abcStack.remove(0).charValue();\n    \n                    if (c != i) {\n                        wordStack.add(0, c);\n                        j++;\n                    }\n                }\n    \n            }\n            return j + abcStack.size();\n        }\n    }"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int i=0,count=0,n=word.size(),res=0;\\n\\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word[i] == \\'a\\') {\\n                count++;\\n            }\\n             \\n            if(word[i] == \\'b\\') {\\n                count++;\\n            }\\n            \\n            if(word[i] == \\'c\\') {\\n                count++;\\n            }\\n            i++;\\n            res += 3 - count;\\n        }\\n        cout<<res;\\n\\n\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1865557,
                "content": [
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Replace \"abc\" -> \"0\"\\n\"ab\" -> \"1\"\\n\"bc\" -> \"1\"\\n\"ac\" -> \"1\"\\n\"a\" -> \"2\"\\n\"b\" -> \"2\"\\n\"c\" -> \"2\"\\n\\nand iterate over the new modified string and sum up all the digits.\\nNote: The order of replacing is the key"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "why im getting error for \"aaaabb\"??\\n\\n\\nclass Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int counta=0,countb=0,countc=0;\\n        for(int i=0;i<word.size();i++){\\n            if(word[i]==\\'a\\') counta++;\\n            else if(word[i]==\\'b\\') countb++;\\n            else countc++;\\n        }\\n        int m=max(max(counta,countb),countc);\\n        int res=(3*m)-counta-countb-countc;\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "krishna859768",
                        "content": "same problem\\nHave you find the reason?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "One of the most amazing question i solved on LC. Pure Logical, and the feeling of acceptance in one go is heavenly.  "
                    },
                    {
                        "username": "chachraanubhav",
                        "content": "Did anyone try the LCS approach ? I know it will take O(N^2) , and there is a simple iterative method that works in O(N)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone tell me the thought process how he/she come up with a Solution."
                    },
                    {
                        "username": "jason400",
                        "content": "If you want to be able to reliably derive a solution on sight without making lucky guesses or pattern recognition from similar problems, other thought processes like trying to recognize a pattern and then coding something up until it works won't cut it IMO. That would make it seem like you saw the problem before and turn the interview into essentially floundering around with intuition until you hopefully arrive at a solution in time. This is my thought process.\n1) Realize the problem is an optimization problem over a decision space of exponential size (branching factor at least 3), and note that a search over the problem space implemented with a simple recursion with backtracking implementation will yield a correct, albeit exponential runtime.\n2) Using your observation from #1, and your knowledge that greedy algorithms are often employed to efficiently optimize a set of decisions over even exponentially sized search trees, begin examining a set of 'localized' choices that might exhibit the Greedy Choice Property\n3) Observe that every valid solution modifies the problem space to a string that begins with 'abc', therefore, the optimal solution must contain these set of localized steps. Use intuition to posit that one 'choice' (set of local decisions) we can make would be to minimally append either an a,b,c to each of the initial characters until we arrive at 'abc'. Perform a quick 'proof' by contradiction in your head to gain confidence that no optimal solution excludes this minimal set of decisions. You have identified a choice that satisfies the Greedy Choice Property\n4) Realize that the Greedy Choice you have identified leads to a substructure decomposition which is also an optimal substructure (no surprise there, but good to check)\n5) Using the 'choice' you have identified as satisfying both the Greedy Choice Property and resolving the problem to an Optimal Substructure (you need those two things to proceed with confidence that your algorithm will actually work) implement a greedy algorithm using a combination of iteration and/or recursion, and use LinkedList backed stacks are your data structure to demonstrate additional mastery of data structures\n6) [Very Optional at best IMO] Further simplify the implementation by ripping out the linkedlist/stacks data structures, and any references to characters, by leveraging properties of ascii characters to achieve a slight constant time reduction in both runtime and memory, as well as LOC\n"
                    },
                    {
                        "username": "Kai_Ghost",
                        "content": "Find the pattern in the string in the nested while loop in the code beneath \n\n```\nclass Solution {\npublic:\n    int addMinimum(string word) {\n        int res = 0;\n        int ptr1 = 0;\n        int n = word.size();\n        while (ptr1 < n) {\n            char starting = word[ptr1];\n            int temp = ptr1 + 1;\n            char prev = starting;\n            while (temp < n && word[temp] > prev) {\n                prev = word[temp];\n                temp++;\n            }\n\n            res += 3 - (temp - ptr1);\n            ptr1 = temp;\n            \n        }\n\n\n\n\n\n        return res;\n\n        \n    }\n};\n\n\n```"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "we will interate word and check if expected letter is there or not according to repeating pattern of \"abc\" .if not present we increment count and increment and modulo index (we are adding a missing char to word)"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Leetcode, why is the result for \"aaaabb\" 9? I think it\\'s 6 because for 4 - a, 2 - b, 0 - c you need to add 2 \"b\" and 4 \"c\""
                    },
                    {
                        "username": "Dhaval25",
                        "content": "[a]bc [a]bc [a]bc  [ab]c  a[b]c :  As you can see the number of non-square brackets is 9 not 6. We add bc for first 3 \\'a\\' then we club 4th \\'ab\\' together and add \\'c\\' and for last \\'b\\' we add \\'ac\\' so in total we added 9 characters "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You can\\'t change the position of Characters.That\\'s why bb also need 2a and 2c."
                    },
                    {
                        "username": "bharat231",
                        "content": "We need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh"
                    },
                    {
                        "username": "Tim-Ax",
                        "content": "word = \\'aaaabb\\'\\n\\u041Eutput 6\\nExpected. 9\\nI meant it like that:\\naaaabb-> a a a a b b ->  ab ab a a => ab+c   ab+c   b+bc    b+bc\\nc c b c b c     6 letters\\n\\nDid I misunderstand the task?  :)\\nThanks"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "The question says \"you can insert letters \"a\", \"b\" or \"c\" anywhere and any number of times\".  So, I don\\'t think you can move around the existing letters.  \\n\\nSo, in this case the solution will be \\n      aaaabb \\n=> a a a a b b \\n=> a (bc) a (bc) a (bc) a b (c) (a) b (c)\\n=> abc abc abc abc abc \\n\\ninserted : b c b c b c c a c \\n"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "For this string, \"aaaabb\" => my output is 6, but it says 9 expected output"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "[@sergei-durkin](/sergei-durkin) hi bro, actually it s correct , we cannot move letters of word , so we need to validate it as it is "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "You are right, Litcode described the problem incorrectly. I also fell into this trap)\\n\\nif we look at this problem from the other side, we need to make valid string for each symbol in this string\\n\\nbharat231 described the answer to your question \\n```\\nWe need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh\\n```"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "This should be tagged as EASY :\n-  The problem is not that hard ( Though is a good one for beginner )\n-  The solutions mostly require tools LeetCode it self considers \"Fundamental\"\n-  The problem has many different ways it can be solved (Like many other Easy problems on the site )\n- The test case Constraints are smaller so that a solution with high time and space complexity can be accepted .\n- All in all signs of an Easy LeetCode problem ."
                    },
                    {
                        "username": "jason400",
                        "content": "It's quite challenging to derive it cold. To completely and fully solve such a problem one would need to model the problem as a decision tree, identify the minimal set prepend 'a','b','c' or pass steps to arrive at the first 'abc' subsequence in the optimal solution as both satisfying the greedy choice problem and resolving the problem to an optimal substructure. Then implement either a recursive or stack-based iterative greedy algorithm using such a greedy choice. While much of the implementation around the actual values of the characters can be stripped away to leave a simple iterative algorithm, any implementation would need to derive from such a solution in order to demonstrate a full understanding of the algorithm that is being employed.\n\nAnything less would indicate either a familiarity with the problem or an aimless luck or intuition based guess, which could be a failure in any real world interview.\n    \n\n\n\n    class Solution {\n        public int addMinimum(String word) {\n            ArrayList<Character> wordStack = new ArrayList<Character>();\n            for (Character c : word.toCharArray()) {\n                wordStack.add(c);\n            }\n            ArrayList<Character> abcStack = new ArrayList<Character>();\n    \n            int j = 0;\n            while (!wordStack.isEmpty()) {\n                abcStack.add('a');\n                abcStack.add('b');\n                abcStack.add('c');\n    \n                while (!abcStack.isEmpty() && !wordStack.isEmpty()) {\n                    char c = wordStack.remove(0).charValue();\n                    char i = abcStack.remove(0).charValue();\n    \n                    if (c != i) {\n                        wordStack.add(0, c);\n                        j++;\n                    }\n                }\n    \n            }\n            return j + abcStack.size();\n        }\n    }"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int i=0,count=0,n=word.size(),res=0;\\n\\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word[i] == \\'a\\') {\\n                count++;\\n            }\\n             \\n            if(word[i] == \\'b\\') {\\n                count++;\\n            }\\n            \\n            if(word[i] == \\'c\\') {\\n                count++;\\n            }\\n            i++;\\n            res += 3 - count;\\n        }\\n        cout<<res;\\n\\n\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1964460,
                "content": [
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Replace \"abc\" -> \"0\"\\n\"ab\" -> \"1\"\\n\"bc\" -> \"1\"\\n\"ac\" -> \"1\"\\n\"a\" -> \"2\"\\n\"b\" -> \"2\"\\n\"c\" -> \"2\"\\n\\nand iterate over the new modified string and sum up all the digits.\\nNote: The order of replacing is the key"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "why im getting error for \"aaaabb\"??\\n\\n\\nclass Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int counta=0,countb=0,countc=0;\\n        for(int i=0;i<word.size();i++){\\n            if(word[i]==\\'a\\') counta++;\\n            else if(word[i]==\\'b\\') countb++;\\n            else countc++;\\n        }\\n        int m=max(max(counta,countb),countc);\\n        int res=(3*m)-counta-countb-countc;\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "krishna859768",
                        "content": "same problem\\nHave you find the reason?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "One of the most amazing question i solved on LC. Pure Logical, and the feeling of acceptance in one go is heavenly.  "
                    },
                    {
                        "username": "chachraanubhav",
                        "content": "Did anyone try the LCS approach ? I know it will take O(N^2) , and there is a simple iterative method that works in O(N)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone tell me the thought process how he/she come up with a Solution."
                    },
                    {
                        "username": "jason400",
                        "content": "If you want to be able to reliably derive a solution on sight without making lucky guesses or pattern recognition from similar problems, other thought processes like trying to recognize a pattern and then coding something up until it works won't cut it IMO. That would make it seem like you saw the problem before and turn the interview into essentially floundering around with intuition until you hopefully arrive at a solution in time. This is my thought process.\n1) Realize the problem is an optimization problem over a decision space of exponential size (branching factor at least 3), and note that a search over the problem space implemented with a simple recursion with backtracking implementation will yield a correct, albeit exponential runtime.\n2) Using your observation from #1, and your knowledge that greedy algorithms are often employed to efficiently optimize a set of decisions over even exponentially sized search trees, begin examining a set of 'localized' choices that might exhibit the Greedy Choice Property\n3) Observe that every valid solution modifies the problem space to a string that begins with 'abc', therefore, the optimal solution must contain these set of localized steps. Use intuition to posit that one 'choice' (set of local decisions) we can make would be to minimally append either an a,b,c to each of the initial characters until we arrive at 'abc'. Perform a quick 'proof' by contradiction in your head to gain confidence that no optimal solution excludes this minimal set of decisions. You have identified a choice that satisfies the Greedy Choice Property\n4) Realize that the Greedy Choice you have identified leads to a substructure decomposition which is also an optimal substructure (no surprise there, but good to check)\n5) Using the 'choice' you have identified as satisfying both the Greedy Choice Property and resolving the problem to an Optimal Substructure (you need those two things to proceed with confidence that your algorithm will actually work) implement a greedy algorithm using a combination of iteration and/or recursion, and use LinkedList backed stacks are your data structure to demonstrate additional mastery of data structures\n6) [Very Optional at best IMO] Further simplify the implementation by ripping out the linkedlist/stacks data structures, and any references to characters, by leveraging properties of ascii characters to achieve a slight constant time reduction in both runtime and memory, as well as LOC\n"
                    },
                    {
                        "username": "Kai_Ghost",
                        "content": "Find the pattern in the string in the nested while loop in the code beneath \n\n```\nclass Solution {\npublic:\n    int addMinimum(string word) {\n        int res = 0;\n        int ptr1 = 0;\n        int n = word.size();\n        while (ptr1 < n) {\n            char starting = word[ptr1];\n            int temp = ptr1 + 1;\n            char prev = starting;\n            while (temp < n && word[temp] > prev) {\n                prev = word[temp];\n                temp++;\n            }\n\n            res += 3 - (temp - ptr1);\n            ptr1 = temp;\n            \n        }\n\n\n\n\n\n        return res;\n\n        \n    }\n};\n\n\n```"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "we will interate word and check if expected letter is there or not according to repeating pattern of \"abc\" .if not present we increment count and increment and modulo index (we are adding a missing char to word)"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Leetcode, why is the result for \"aaaabb\" 9? I think it\\'s 6 because for 4 - a, 2 - b, 0 - c you need to add 2 \"b\" and 4 \"c\""
                    },
                    {
                        "username": "Dhaval25",
                        "content": "[a]bc [a]bc [a]bc  [ab]c  a[b]c :  As you can see the number of non-square brackets is 9 not 6. We add bc for first 3 \\'a\\' then we club 4th \\'ab\\' together and add \\'c\\' and for last \\'b\\' we add \\'ac\\' so in total we added 9 characters "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You can\\'t change the position of Characters.That\\'s why bb also need 2a and 2c."
                    },
                    {
                        "username": "bharat231",
                        "content": "We need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh"
                    },
                    {
                        "username": "Tim-Ax",
                        "content": "word = \\'aaaabb\\'\\n\\u041Eutput 6\\nExpected. 9\\nI meant it like that:\\naaaabb-> a a a a b b ->  ab ab a a => ab+c   ab+c   b+bc    b+bc\\nc c b c b c     6 letters\\n\\nDid I misunderstand the task?  :)\\nThanks"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "The question says \"you can insert letters \"a\", \"b\" or \"c\" anywhere and any number of times\".  So, I don\\'t think you can move around the existing letters.  \\n\\nSo, in this case the solution will be \\n      aaaabb \\n=> a a a a b b \\n=> a (bc) a (bc) a (bc) a b (c) (a) b (c)\\n=> abc abc abc abc abc \\n\\ninserted : b c b c b c c a c \\n"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "For this string, \"aaaabb\" => my output is 6, but it says 9 expected output"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "[@sergei-durkin](/sergei-durkin) hi bro, actually it s correct , we cannot move letters of word , so we need to validate it as it is "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "You are right, Litcode described the problem incorrectly. I also fell into this trap)\\n\\nif we look at this problem from the other side, we need to make valid string for each symbol in this string\\n\\nbharat231 described the answer to your question \\n```\\nWe need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh\\n```"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "This should be tagged as EASY :\n-  The problem is not that hard ( Though is a good one for beginner )\n-  The solutions mostly require tools LeetCode it self considers \"Fundamental\"\n-  The problem has many different ways it can be solved (Like many other Easy problems on the site )\n- The test case Constraints are smaller so that a solution with high time and space complexity can be accepted .\n- All in all signs of an Easy LeetCode problem ."
                    },
                    {
                        "username": "jason400",
                        "content": "It's quite challenging to derive it cold. To completely and fully solve such a problem one would need to model the problem as a decision tree, identify the minimal set prepend 'a','b','c' or pass steps to arrive at the first 'abc' subsequence in the optimal solution as both satisfying the greedy choice problem and resolving the problem to an optimal substructure. Then implement either a recursive or stack-based iterative greedy algorithm using such a greedy choice. While much of the implementation around the actual values of the characters can be stripped away to leave a simple iterative algorithm, any implementation would need to derive from such a solution in order to demonstrate a full understanding of the algorithm that is being employed.\n\nAnything less would indicate either a familiarity with the problem or an aimless luck or intuition based guess, which could be a failure in any real world interview.\n    \n\n\n\n    class Solution {\n        public int addMinimum(String word) {\n            ArrayList<Character> wordStack = new ArrayList<Character>();\n            for (Character c : word.toCharArray()) {\n                wordStack.add(c);\n            }\n            ArrayList<Character> abcStack = new ArrayList<Character>();\n    \n            int j = 0;\n            while (!wordStack.isEmpty()) {\n                abcStack.add('a');\n                abcStack.add('b');\n                abcStack.add('c');\n    \n                while (!abcStack.isEmpty() && !wordStack.isEmpty()) {\n                    char c = wordStack.remove(0).charValue();\n                    char i = abcStack.remove(0).charValue();\n    \n                    if (c != i) {\n                        wordStack.add(0, c);\n                        j++;\n                    }\n                }\n    \n            }\n            return j + abcStack.size();\n        }\n    }"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int i=0,count=0,n=word.size(),res=0;\\n\\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word[i] == \\'a\\') {\\n                count++;\\n            }\\n             \\n            if(word[i] == \\'b\\') {\\n                count++;\\n            }\\n            \\n            if(word[i] == \\'c\\') {\\n                count++;\\n            }\\n            i++;\\n            res += 3 - count;\\n        }\\n        cout<<res;\\n\\n\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1864937,
                "content": [
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Replace \"abc\" -> \"0\"\\n\"ab\" -> \"1\"\\n\"bc\" -> \"1\"\\n\"ac\" -> \"1\"\\n\"a\" -> \"2\"\\n\"b\" -> \"2\"\\n\"c\" -> \"2\"\\n\\nand iterate over the new modified string and sum up all the digits.\\nNote: The order of replacing is the key"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "why im getting error for \"aaaabb\"??\\n\\n\\nclass Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int counta=0,countb=0,countc=0;\\n        for(int i=0;i<word.size();i++){\\n            if(word[i]==\\'a\\') counta++;\\n            else if(word[i]==\\'b\\') countb++;\\n            else countc++;\\n        }\\n        int m=max(max(counta,countb),countc);\\n        int res=(3*m)-counta-countb-countc;\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "krishna859768",
                        "content": "same problem\\nHave you find the reason?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "One of the most amazing question i solved on LC. Pure Logical, and the feeling of acceptance in one go is heavenly.  "
                    },
                    {
                        "username": "chachraanubhav",
                        "content": "Did anyone try the LCS approach ? I know it will take O(N^2) , and there is a simple iterative method that works in O(N)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone tell me the thought process how he/she come up with a Solution."
                    },
                    {
                        "username": "jason400",
                        "content": "If you want to be able to reliably derive a solution on sight without making lucky guesses or pattern recognition from similar problems, other thought processes like trying to recognize a pattern and then coding something up until it works won't cut it IMO. That would make it seem like you saw the problem before and turn the interview into essentially floundering around with intuition until you hopefully arrive at a solution in time. This is my thought process.\n1) Realize the problem is an optimization problem over a decision space of exponential size (branching factor at least 3), and note that a search over the problem space implemented with a simple recursion with backtracking implementation will yield a correct, albeit exponential runtime.\n2) Using your observation from #1, and your knowledge that greedy algorithms are often employed to efficiently optimize a set of decisions over even exponentially sized search trees, begin examining a set of 'localized' choices that might exhibit the Greedy Choice Property\n3) Observe that every valid solution modifies the problem space to a string that begins with 'abc', therefore, the optimal solution must contain these set of localized steps. Use intuition to posit that one 'choice' (set of local decisions) we can make would be to minimally append either an a,b,c to each of the initial characters until we arrive at 'abc'. Perform a quick 'proof' by contradiction in your head to gain confidence that no optimal solution excludes this minimal set of decisions. You have identified a choice that satisfies the Greedy Choice Property\n4) Realize that the Greedy Choice you have identified leads to a substructure decomposition which is also an optimal substructure (no surprise there, but good to check)\n5) Using the 'choice' you have identified as satisfying both the Greedy Choice Property and resolving the problem to an Optimal Substructure (you need those two things to proceed with confidence that your algorithm will actually work) implement a greedy algorithm using a combination of iteration and/or recursion, and use LinkedList backed stacks are your data structure to demonstrate additional mastery of data structures\n6) [Very Optional at best IMO] Further simplify the implementation by ripping out the linkedlist/stacks data structures, and any references to characters, by leveraging properties of ascii characters to achieve a slight constant time reduction in both runtime and memory, as well as LOC\n"
                    },
                    {
                        "username": "Kai_Ghost",
                        "content": "Find the pattern in the string in the nested while loop in the code beneath \n\n```\nclass Solution {\npublic:\n    int addMinimum(string word) {\n        int res = 0;\n        int ptr1 = 0;\n        int n = word.size();\n        while (ptr1 < n) {\n            char starting = word[ptr1];\n            int temp = ptr1 + 1;\n            char prev = starting;\n            while (temp < n && word[temp] > prev) {\n                prev = word[temp];\n                temp++;\n            }\n\n            res += 3 - (temp - ptr1);\n            ptr1 = temp;\n            \n        }\n\n\n\n\n\n        return res;\n\n        \n    }\n};\n\n\n```"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "we will interate word and check if expected letter is there or not according to repeating pattern of \"abc\" .if not present we increment count and increment and modulo index (we are adding a missing char to word)"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Leetcode, why is the result for \"aaaabb\" 9? I think it\\'s 6 because for 4 - a, 2 - b, 0 - c you need to add 2 \"b\" and 4 \"c\""
                    },
                    {
                        "username": "Dhaval25",
                        "content": "[a]bc [a]bc [a]bc  [ab]c  a[b]c :  As you can see the number of non-square brackets is 9 not 6. We add bc for first 3 \\'a\\' then we club 4th \\'ab\\' together and add \\'c\\' and for last \\'b\\' we add \\'ac\\' so in total we added 9 characters "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You can\\'t change the position of Characters.That\\'s why bb also need 2a and 2c."
                    },
                    {
                        "username": "bharat231",
                        "content": "We need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh"
                    },
                    {
                        "username": "Tim-Ax",
                        "content": "word = \\'aaaabb\\'\\n\\u041Eutput 6\\nExpected. 9\\nI meant it like that:\\naaaabb-> a a a a b b ->  ab ab a a => ab+c   ab+c   b+bc    b+bc\\nc c b c b c     6 letters\\n\\nDid I misunderstand the task?  :)\\nThanks"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "The question says \"you can insert letters \"a\", \"b\" or \"c\" anywhere and any number of times\".  So, I don\\'t think you can move around the existing letters.  \\n\\nSo, in this case the solution will be \\n      aaaabb \\n=> a a a a b b \\n=> a (bc) a (bc) a (bc) a b (c) (a) b (c)\\n=> abc abc abc abc abc \\n\\ninserted : b c b c b c c a c \\n"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "For this string, \"aaaabb\" => my output is 6, but it says 9 expected output"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "[@sergei-durkin](/sergei-durkin) hi bro, actually it s correct , we cannot move letters of word , so we need to validate it as it is "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "You are right, Litcode described the problem incorrectly. I also fell into this trap)\\n\\nif we look at this problem from the other side, we need to make valid string for each symbol in this string\\n\\nbharat231 described the answer to your question \\n```\\nWe need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh\\n```"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "This should be tagged as EASY :\n-  The problem is not that hard ( Though is a good one for beginner )\n-  The solutions mostly require tools LeetCode it self considers \"Fundamental\"\n-  The problem has many different ways it can be solved (Like many other Easy problems on the site )\n- The test case Constraints are smaller so that a solution with high time and space complexity can be accepted .\n- All in all signs of an Easy LeetCode problem ."
                    },
                    {
                        "username": "jason400",
                        "content": "It's quite challenging to derive it cold. To completely and fully solve such a problem one would need to model the problem as a decision tree, identify the minimal set prepend 'a','b','c' or pass steps to arrive at the first 'abc' subsequence in the optimal solution as both satisfying the greedy choice problem and resolving the problem to an optimal substructure. Then implement either a recursive or stack-based iterative greedy algorithm using such a greedy choice. While much of the implementation around the actual values of the characters can be stripped away to leave a simple iterative algorithm, any implementation would need to derive from such a solution in order to demonstrate a full understanding of the algorithm that is being employed.\n\nAnything less would indicate either a familiarity with the problem or an aimless luck or intuition based guess, which could be a failure in any real world interview.\n    \n\n\n\n    class Solution {\n        public int addMinimum(String word) {\n            ArrayList<Character> wordStack = new ArrayList<Character>();\n            for (Character c : word.toCharArray()) {\n                wordStack.add(c);\n            }\n            ArrayList<Character> abcStack = new ArrayList<Character>();\n    \n            int j = 0;\n            while (!wordStack.isEmpty()) {\n                abcStack.add('a');\n                abcStack.add('b');\n                abcStack.add('c');\n    \n                while (!abcStack.isEmpty() && !wordStack.isEmpty()) {\n                    char c = wordStack.remove(0).charValue();\n                    char i = abcStack.remove(0).charValue();\n    \n                    if (c != i) {\n                        wordStack.add(0, c);\n                        j++;\n                    }\n                }\n    \n            }\n            return j + abcStack.size();\n        }\n    }"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int i=0,count=0,n=word.size(),res=0;\\n\\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word[i] == \\'a\\') {\\n                count++;\\n            }\\n             \\n            if(word[i] == \\'b\\') {\\n                count++;\\n            }\\n            \\n            if(word[i] == \\'c\\') {\\n                count++;\\n            }\\n            i++;\\n            res += 3 - count;\\n        }\\n        cout<<res;\\n\\n\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1864814,
                "content": [
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Replace \"abc\" -> \"0\"\\n\"ab\" -> \"1\"\\n\"bc\" -> \"1\"\\n\"ac\" -> \"1\"\\n\"a\" -> \"2\"\\n\"b\" -> \"2\"\\n\"c\" -> \"2\"\\n\\nand iterate over the new modified string and sum up all the digits.\\nNote: The order of replacing is the key"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "why im getting error for \"aaaabb\"??\\n\\n\\nclass Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int counta=0,countb=0,countc=0;\\n        for(int i=0;i<word.size();i++){\\n            if(word[i]==\\'a\\') counta++;\\n            else if(word[i]==\\'b\\') countb++;\\n            else countc++;\\n        }\\n        int m=max(max(counta,countb),countc);\\n        int res=(3*m)-counta-countb-countc;\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "krishna859768",
                        "content": "same problem\\nHave you find the reason?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "One of the most amazing question i solved on LC. Pure Logical, and the feeling of acceptance in one go is heavenly.  "
                    },
                    {
                        "username": "chachraanubhav",
                        "content": "Did anyone try the LCS approach ? I know it will take O(N^2) , and there is a simple iterative method that works in O(N)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone tell me the thought process how he/she come up with a Solution."
                    },
                    {
                        "username": "jason400",
                        "content": "If you want to be able to reliably derive a solution on sight without making lucky guesses or pattern recognition from similar problems, other thought processes like trying to recognize a pattern and then coding something up until it works won't cut it IMO. That would make it seem like you saw the problem before and turn the interview into essentially floundering around with intuition until you hopefully arrive at a solution in time. This is my thought process.\n1) Realize the problem is an optimization problem over a decision space of exponential size (branching factor at least 3), and note that a search over the problem space implemented with a simple recursion with backtracking implementation will yield a correct, albeit exponential runtime.\n2) Using your observation from #1, and your knowledge that greedy algorithms are often employed to efficiently optimize a set of decisions over even exponentially sized search trees, begin examining a set of 'localized' choices that might exhibit the Greedy Choice Property\n3) Observe that every valid solution modifies the problem space to a string that begins with 'abc', therefore, the optimal solution must contain these set of localized steps. Use intuition to posit that one 'choice' (set of local decisions) we can make would be to minimally append either an a,b,c to each of the initial characters until we arrive at 'abc'. Perform a quick 'proof' by contradiction in your head to gain confidence that no optimal solution excludes this minimal set of decisions. You have identified a choice that satisfies the Greedy Choice Property\n4) Realize that the Greedy Choice you have identified leads to a substructure decomposition which is also an optimal substructure (no surprise there, but good to check)\n5) Using the 'choice' you have identified as satisfying both the Greedy Choice Property and resolving the problem to an Optimal Substructure (you need those two things to proceed with confidence that your algorithm will actually work) implement a greedy algorithm using a combination of iteration and/or recursion, and use LinkedList backed stacks are your data structure to demonstrate additional mastery of data structures\n6) [Very Optional at best IMO] Further simplify the implementation by ripping out the linkedlist/stacks data structures, and any references to characters, by leveraging properties of ascii characters to achieve a slight constant time reduction in both runtime and memory, as well as LOC\n"
                    },
                    {
                        "username": "Kai_Ghost",
                        "content": "Find the pattern in the string in the nested while loop in the code beneath \n\n```\nclass Solution {\npublic:\n    int addMinimum(string word) {\n        int res = 0;\n        int ptr1 = 0;\n        int n = word.size();\n        while (ptr1 < n) {\n            char starting = word[ptr1];\n            int temp = ptr1 + 1;\n            char prev = starting;\n            while (temp < n && word[temp] > prev) {\n                prev = word[temp];\n                temp++;\n            }\n\n            res += 3 - (temp - ptr1);\n            ptr1 = temp;\n            \n        }\n\n\n\n\n\n        return res;\n\n        \n    }\n};\n\n\n```"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "we will interate word and check if expected letter is there or not according to repeating pattern of \"abc\" .if not present we increment count and increment and modulo index (we are adding a missing char to word)"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Leetcode, why is the result for \"aaaabb\" 9? I think it\\'s 6 because for 4 - a, 2 - b, 0 - c you need to add 2 \"b\" and 4 \"c\""
                    },
                    {
                        "username": "Dhaval25",
                        "content": "[a]bc [a]bc [a]bc  [ab]c  a[b]c :  As you can see the number of non-square brackets is 9 not 6. We add bc for first 3 \\'a\\' then we club 4th \\'ab\\' together and add \\'c\\' and for last \\'b\\' we add \\'ac\\' so in total we added 9 characters "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You can\\'t change the position of Characters.That\\'s why bb also need 2a and 2c."
                    },
                    {
                        "username": "bharat231",
                        "content": "We need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh"
                    },
                    {
                        "username": "Tim-Ax",
                        "content": "word = \\'aaaabb\\'\\n\\u041Eutput 6\\nExpected. 9\\nI meant it like that:\\naaaabb-> a a a a b b ->  ab ab a a => ab+c   ab+c   b+bc    b+bc\\nc c b c b c     6 letters\\n\\nDid I misunderstand the task?  :)\\nThanks"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "The question says \"you can insert letters \"a\", \"b\" or \"c\" anywhere and any number of times\".  So, I don\\'t think you can move around the existing letters.  \\n\\nSo, in this case the solution will be \\n      aaaabb \\n=> a a a a b b \\n=> a (bc) a (bc) a (bc) a b (c) (a) b (c)\\n=> abc abc abc abc abc \\n\\ninserted : b c b c b c c a c \\n"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "For this string, \"aaaabb\" => my output is 6, but it says 9 expected output"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "[@sergei-durkin](/sergei-durkin) hi bro, actually it s correct , we cannot move letters of word , so we need to validate it as it is "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "You are right, Litcode described the problem incorrectly. I also fell into this trap)\\n\\nif we look at this problem from the other side, we need to make valid string for each symbol in this string\\n\\nbharat231 described the answer to your question \\n```\\nWe need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh\\n```"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "This should be tagged as EASY :\n-  The problem is not that hard ( Though is a good one for beginner )\n-  The solutions mostly require tools LeetCode it self considers \"Fundamental\"\n-  The problem has many different ways it can be solved (Like many other Easy problems on the site )\n- The test case Constraints are smaller so that a solution with high time and space complexity can be accepted .\n- All in all signs of an Easy LeetCode problem ."
                    },
                    {
                        "username": "jason400",
                        "content": "It's quite challenging to derive it cold. To completely and fully solve such a problem one would need to model the problem as a decision tree, identify the minimal set prepend 'a','b','c' or pass steps to arrive at the first 'abc' subsequence in the optimal solution as both satisfying the greedy choice problem and resolving the problem to an optimal substructure. Then implement either a recursive or stack-based iterative greedy algorithm using such a greedy choice. While much of the implementation around the actual values of the characters can be stripped away to leave a simple iterative algorithm, any implementation would need to derive from such a solution in order to demonstrate a full understanding of the algorithm that is being employed.\n\nAnything less would indicate either a familiarity with the problem or an aimless luck or intuition based guess, which could be a failure in any real world interview.\n    \n\n\n\n    class Solution {\n        public int addMinimum(String word) {\n            ArrayList<Character> wordStack = new ArrayList<Character>();\n            for (Character c : word.toCharArray()) {\n                wordStack.add(c);\n            }\n            ArrayList<Character> abcStack = new ArrayList<Character>();\n    \n            int j = 0;\n            while (!wordStack.isEmpty()) {\n                abcStack.add('a');\n                abcStack.add('b');\n                abcStack.add('c');\n    \n                while (!abcStack.isEmpty() && !wordStack.isEmpty()) {\n                    char c = wordStack.remove(0).charValue();\n                    char i = abcStack.remove(0).charValue();\n    \n                    if (c != i) {\n                        wordStack.add(0, c);\n                        j++;\n                    }\n                }\n    \n            }\n            return j + abcStack.size();\n        }\n    }"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int i=0,count=0,n=word.size(),res=0;\\n\\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word[i] == \\'a\\') {\\n                count++;\\n            }\\n             \\n            if(word[i] == \\'b\\') {\\n                count++;\\n            }\\n            \\n            if(word[i] == \\'c\\') {\\n                count++;\\n            }\\n            i++;\\n            res += 3 - count;\\n        }\\n        cout<<res;\\n\\n\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1864768,
                "content": [
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Replace \"abc\" -> \"0\"\\n\"ab\" -> \"1\"\\n\"bc\" -> \"1\"\\n\"ac\" -> \"1\"\\n\"a\" -> \"2\"\\n\"b\" -> \"2\"\\n\"c\" -> \"2\"\\n\\nand iterate over the new modified string and sum up all the digits.\\nNote: The order of replacing is the key"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "why im getting error for \"aaaabb\"??\\n\\n\\nclass Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int counta=0,countb=0,countc=0;\\n        for(int i=0;i<word.size();i++){\\n            if(word[i]==\\'a\\') counta++;\\n            else if(word[i]==\\'b\\') countb++;\\n            else countc++;\\n        }\\n        int m=max(max(counta,countb),countc);\\n        int res=(3*m)-counta-countb-countc;\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "krishna859768",
                        "content": "same problem\\nHave you find the reason?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "One of the most amazing question i solved on LC. Pure Logical, and the feeling of acceptance in one go is heavenly.  "
                    },
                    {
                        "username": "chachraanubhav",
                        "content": "Did anyone try the LCS approach ? I know it will take O(N^2) , and there is a simple iterative method that works in O(N)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone tell me the thought process how he/she come up with a Solution."
                    },
                    {
                        "username": "jason400",
                        "content": "If you want to be able to reliably derive a solution on sight without making lucky guesses or pattern recognition from similar problems, other thought processes like trying to recognize a pattern and then coding something up until it works won't cut it IMO. That would make it seem like you saw the problem before and turn the interview into essentially floundering around with intuition until you hopefully arrive at a solution in time. This is my thought process.\n1) Realize the problem is an optimization problem over a decision space of exponential size (branching factor at least 3), and note that a search over the problem space implemented with a simple recursion with backtracking implementation will yield a correct, albeit exponential runtime.\n2) Using your observation from #1, and your knowledge that greedy algorithms are often employed to efficiently optimize a set of decisions over even exponentially sized search trees, begin examining a set of 'localized' choices that might exhibit the Greedy Choice Property\n3) Observe that every valid solution modifies the problem space to a string that begins with 'abc', therefore, the optimal solution must contain these set of localized steps. Use intuition to posit that one 'choice' (set of local decisions) we can make would be to minimally append either an a,b,c to each of the initial characters until we arrive at 'abc'. Perform a quick 'proof' by contradiction in your head to gain confidence that no optimal solution excludes this minimal set of decisions. You have identified a choice that satisfies the Greedy Choice Property\n4) Realize that the Greedy Choice you have identified leads to a substructure decomposition which is also an optimal substructure (no surprise there, but good to check)\n5) Using the 'choice' you have identified as satisfying both the Greedy Choice Property and resolving the problem to an Optimal Substructure (you need those two things to proceed with confidence that your algorithm will actually work) implement a greedy algorithm using a combination of iteration and/or recursion, and use LinkedList backed stacks are your data structure to demonstrate additional mastery of data structures\n6) [Very Optional at best IMO] Further simplify the implementation by ripping out the linkedlist/stacks data structures, and any references to characters, by leveraging properties of ascii characters to achieve a slight constant time reduction in both runtime and memory, as well as LOC\n"
                    },
                    {
                        "username": "Kai_Ghost",
                        "content": "Find the pattern in the string in the nested while loop in the code beneath \n\n```\nclass Solution {\npublic:\n    int addMinimum(string word) {\n        int res = 0;\n        int ptr1 = 0;\n        int n = word.size();\n        while (ptr1 < n) {\n            char starting = word[ptr1];\n            int temp = ptr1 + 1;\n            char prev = starting;\n            while (temp < n && word[temp] > prev) {\n                prev = word[temp];\n                temp++;\n            }\n\n            res += 3 - (temp - ptr1);\n            ptr1 = temp;\n            \n        }\n\n\n\n\n\n        return res;\n\n        \n    }\n};\n\n\n```"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "we will interate word and check if expected letter is there or not according to repeating pattern of \"abc\" .if not present we increment count and increment and modulo index (we are adding a missing char to word)"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Leetcode, why is the result for \"aaaabb\" 9? I think it\\'s 6 because for 4 - a, 2 - b, 0 - c you need to add 2 \"b\" and 4 \"c\""
                    },
                    {
                        "username": "Dhaval25",
                        "content": "[a]bc [a]bc [a]bc  [ab]c  a[b]c :  As you can see the number of non-square brackets is 9 not 6. We add bc for first 3 \\'a\\' then we club 4th \\'ab\\' together and add \\'c\\' and for last \\'b\\' we add \\'ac\\' so in total we added 9 characters "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You can\\'t change the position of Characters.That\\'s why bb also need 2a and 2c."
                    },
                    {
                        "username": "bharat231",
                        "content": "We need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh"
                    },
                    {
                        "username": "Tim-Ax",
                        "content": "word = \\'aaaabb\\'\\n\\u041Eutput 6\\nExpected. 9\\nI meant it like that:\\naaaabb-> a a a a b b ->  ab ab a a => ab+c   ab+c   b+bc    b+bc\\nc c b c b c     6 letters\\n\\nDid I misunderstand the task?  :)\\nThanks"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "The question says \"you can insert letters \"a\", \"b\" or \"c\" anywhere and any number of times\".  So, I don\\'t think you can move around the existing letters.  \\n\\nSo, in this case the solution will be \\n      aaaabb \\n=> a a a a b b \\n=> a (bc) a (bc) a (bc) a b (c) (a) b (c)\\n=> abc abc abc abc abc \\n\\ninserted : b c b c b c c a c \\n"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "For this string, \"aaaabb\" => my output is 6, but it says 9 expected output"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "[@sergei-durkin](/sergei-durkin) hi bro, actually it s correct , we cannot move letters of word , so we need to validate it as it is "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "You are right, Litcode described the problem incorrectly. I also fell into this trap)\\n\\nif we look at this problem from the other side, we need to make valid string for each symbol in this string\\n\\nbharat231 described the answer to your question \\n```\\nWe need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh\\n```"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "This should be tagged as EASY :\n-  The problem is not that hard ( Though is a good one for beginner )\n-  The solutions mostly require tools LeetCode it self considers \"Fundamental\"\n-  The problem has many different ways it can be solved (Like many other Easy problems on the site )\n- The test case Constraints are smaller so that a solution with high time and space complexity can be accepted .\n- All in all signs of an Easy LeetCode problem ."
                    },
                    {
                        "username": "jason400",
                        "content": "It's quite challenging to derive it cold. To completely and fully solve such a problem one would need to model the problem as a decision tree, identify the minimal set prepend 'a','b','c' or pass steps to arrive at the first 'abc' subsequence in the optimal solution as both satisfying the greedy choice problem and resolving the problem to an optimal substructure. Then implement either a recursive or stack-based iterative greedy algorithm using such a greedy choice. While much of the implementation around the actual values of the characters can be stripped away to leave a simple iterative algorithm, any implementation would need to derive from such a solution in order to demonstrate a full understanding of the algorithm that is being employed.\n\nAnything less would indicate either a familiarity with the problem or an aimless luck or intuition based guess, which could be a failure in any real world interview.\n    \n\n\n\n    class Solution {\n        public int addMinimum(String word) {\n            ArrayList<Character> wordStack = new ArrayList<Character>();\n            for (Character c : word.toCharArray()) {\n                wordStack.add(c);\n            }\n            ArrayList<Character> abcStack = new ArrayList<Character>();\n    \n            int j = 0;\n            while (!wordStack.isEmpty()) {\n                abcStack.add('a');\n                abcStack.add('b');\n                abcStack.add('c');\n    \n                while (!abcStack.isEmpty() && !wordStack.isEmpty()) {\n                    char c = wordStack.remove(0).charValue();\n                    char i = abcStack.remove(0).charValue();\n    \n                    if (c != i) {\n                        wordStack.add(0, c);\n                        j++;\n                    }\n                }\n    \n            }\n            return j + abcStack.size();\n        }\n    }"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int i=0,count=0,n=word.size(),res=0;\\n\\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word[i] == \\'a\\') {\\n                count++;\\n            }\\n             \\n            if(word[i] == \\'b\\') {\\n                count++;\\n            }\\n            \\n            if(word[i] == \\'c\\') {\\n                count++;\\n            }\\n            i++;\\n            res += 3 - count;\\n        }\\n        cout<<res;\\n\\n\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2075372,
                "content": [
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Replace \"abc\" -> \"0\"\\n\"ab\" -> \"1\"\\n\"bc\" -> \"1\"\\n\"ac\" -> \"1\"\\n\"a\" -> \"2\"\\n\"b\" -> \"2\"\\n\"c\" -> \"2\"\\n\\nand iterate over the new modified string and sum up all the digits.\\nNote: The order of replacing is the key"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "why im getting error for \"aaaabb\"??\\n\\n\\nclass Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int counta=0,countb=0,countc=0;\\n        for(int i=0;i<word.size();i++){\\n            if(word[i]==\\'a\\') counta++;\\n            else if(word[i]==\\'b\\') countb++;\\n            else countc++;\\n        }\\n        int m=max(max(counta,countb),countc);\\n        int res=(3*m)-counta-countb-countc;\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "krishna859768",
                        "content": "same problem\\nHave you find the reason?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "One of the most amazing question i solved on LC. Pure Logical, and the feeling of acceptance in one go is heavenly.  "
                    },
                    {
                        "username": "chachraanubhav",
                        "content": "Did anyone try the LCS approach ? I know it will take O(N^2) , and there is a simple iterative method that works in O(N)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone tell me the thought process how he/she come up with a Solution."
                    },
                    {
                        "username": "jason400",
                        "content": "If you want to be able to reliably derive a solution on sight without making lucky guesses or pattern recognition from similar problems, other thought processes like trying to recognize a pattern and then coding something up until it works won't cut it IMO. That would make it seem like you saw the problem before and turn the interview into essentially floundering around with intuition until you hopefully arrive at a solution in time. This is my thought process.\n1) Realize the problem is an optimization problem over a decision space of exponential size (branching factor at least 3), and note that a search over the problem space implemented with a simple recursion with backtracking implementation will yield a correct, albeit exponential runtime.\n2) Using your observation from #1, and your knowledge that greedy algorithms are often employed to efficiently optimize a set of decisions over even exponentially sized search trees, begin examining a set of 'localized' choices that might exhibit the Greedy Choice Property\n3) Observe that every valid solution modifies the problem space to a string that begins with 'abc', therefore, the optimal solution must contain these set of localized steps. Use intuition to posit that one 'choice' (set of local decisions) we can make would be to minimally append either an a,b,c to each of the initial characters until we arrive at 'abc'. Perform a quick 'proof' by contradiction in your head to gain confidence that no optimal solution excludes this minimal set of decisions. You have identified a choice that satisfies the Greedy Choice Property\n4) Realize that the Greedy Choice you have identified leads to a substructure decomposition which is also an optimal substructure (no surprise there, but good to check)\n5) Using the 'choice' you have identified as satisfying both the Greedy Choice Property and resolving the problem to an Optimal Substructure (you need those two things to proceed with confidence that your algorithm will actually work) implement a greedy algorithm using a combination of iteration and/or recursion, and use LinkedList backed stacks are your data structure to demonstrate additional mastery of data structures\n6) [Very Optional at best IMO] Further simplify the implementation by ripping out the linkedlist/stacks data structures, and any references to characters, by leveraging properties of ascii characters to achieve a slight constant time reduction in both runtime and memory, as well as LOC\n"
                    },
                    {
                        "username": "Kai_Ghost",
                        "content": "Find the pattern in the string in the nested while loop in the code beneath \n\n```\nclass Solution {\npublic:\n    int addMinimum(string word) {\n        int res = 0;\n        int ptr1 = 0;\n        int n = word.size();\n        while (ptr1 < n) {\n            char starting = word[ptr1];\n            int temp = ptr1 + 1;\n            char prev = starting;\n            while (temp < n && word[temp] > prev) {\n                prev = word[temp];\n                temp++;\n            }\n\n            res += 3 - (temp - ptr1);\n            ptr1 = temp;\n            \n        }\n\n\n\n\n\n        return res;\n\n        \n    }\n};\n\n\n```"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "we will interate word and check if expected letter is there or not according to repeating pattern of \"abc\" .if not present we increment count and increment and modulo index (we are adding a missing char to word)"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Leetcode, why is the result for \"aaaabb\" 9? I think it\\'s 6 because for 4 - a, 2 - b, 0 - c you need to add 2 \"b\" and 4 \"c\""
                    },
                    {
                        "username": "Dhaval25",
                        "content": "[a]bc [a]bc [a]bc  [ab]c  a[b]c :  As you can see the number of non-square brackets is 9 not 6. We add bc for first 3 \\'a\\' then we club 4th \\'ab\\' together and add \\'c\\' and for last \\'b\\' we add \\'ac\\' so in total we added 9 characters "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You can\\'t change the position of Characters.That\\'s why bb also need 2a and 2c."
                    },
                    {
                        "username": "bharat231",
                        "content": "We need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh"
                    },
                    {
                        "username": "Tim-Ax",
                        "content": "word = \\'aaaabb\\'\\n\\u041Eutput 6\\nExpected. 9\\nI meant it like that:\\naaaabb-> a a a a b b ->  ab ab a a => ab+c   ab+c   b+bc    b+bc\\nc c b c b c     6 letters\\n\\nDid I misunderstand the task?  :)\\nThanks"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "The question says \"you can insert letters \"a\", \"b\" or \"c\" anywhere and any number of times\".  So, I don\\'t think you can move around the existing letters.  \\n\\nSo, in this case the solution will be \\n      aaaabb \\n=> a a a a b b \\n=> a (bc) a (bc) a (bc) a b (c) (a) b (c)\\n=> abc abc abc abc abc \\n\\ninserted : b c b c b c c a c \\n"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "For this string, \"aaaabb\" => my output is 6, but it says 9 expected output"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "[@sergei-durkin](/sergei-durkin) hi bro, actually it s correct , we cannot move letters of word , so we need to validate it as it is "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "You are right, Litcode described the problem incorrectly. I also fell into this trap)\\n\\nif we look at this problem from the other side, we need to make valid string for each symbol in this string\\n\\nbharat231 described the answer to your question \\n```\\nWe need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh\\n```"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "This should be tagged as EASY :\n-  The problem is not that hard ( Though is a good one for beginner )\n-  The solutions mostly require tools LeetCode it self considers \"Fundamental\"\n-  The problem has many different ways it can be solved (Like many other Easy problems on the site )\n- The test case Constraints are smaller so that a solution with high time and space complexity can be accepted .\n- All in all signs of an Easy LeetCode problem ."
                    },
                    {
                        "username": "jason400",
                        "content": "It's quite challenging to derive it cold. To completely and fully solve such a problem one would need to model the problem as a decision tree, identify the minimal set prepend 'a','b','c' or pass steps to arrive at the first 'abc' subsequence in the optimal solution as both satisfying the greedy choice problem and resolving the problem to an optimal substructure. Then implement either a recursive or stack-based iterative greedy algorithm using such a greedy choice. While much of the implementation around the actual values of the characters can be stripped away to leave a simple iterative algorithm, any implementation would need to derive from such a solution in order to demonstrate a full understanding of the algorithm that is being employed.\n\nAnything less would indicate either a familiarity with the problem or an aimless luck or intuition based guess, which could be a failure in any real world interview.\n    \n\n\n\n    class Solution {\n        public int addMinimum(String word) {\n            ArrayList<Character> wordStack = new ArrayList<Character>();\n            for (Character c : word.toCharArray()) {\n                wordStack.add(c);\n            }\n            ArrayList<Character> abcStack = new ArrayList<Character>();\n    \n            int j = 0;\n            while (!wordStack.isEmpty()) {\n                abcStack.add('a');\n                abcStack.add('b');\n                abcStack.add('c');\n    \n                while (!abcStack.isEmpty() && !wordStack.isEmpty()) {\n                    char c = wordStack.remove(0).charValue();\n                    char i = abcStack.remove(0).charValue();\n    \n                    if (c != i) {\n                        wordStack.add(0, c);\n                        j++;\n                    }\n                }\n    \n            }\n            return j + abcStack.size();\n        }\n    }"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int i=0,count=0,n=word.size(),res=0;\\n\\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word[i] == \\'a\\') {\\n                count++;\\n            }\\n             \\n            if(word[i] == \\'b\\') {\\n                count++;\\n            }\\n            \\n            if(word[i] == \\'c\\') {\\n                count++;\\n            }\\n            i++;\\n            res += 3 - count;\\n        }\\n        cout<<res;\\n\\n\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2022727,
                "content": [
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Replace \"abc\" -> \"0\"\\n\"ab\" -> \"1\"\\n\"bc\" -> \"1\"\\n\"ac\" -> \"1\"\\n\"a\" -> \"2\"\\n\"b\" -> \"2\"\\n\"c\" -> \"2\"\\n\\nand iterate over the new modified string and sum up all the digits.\\nNote: The order of replacing is the key"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "why im getting error for \"aaaabb\"??\\n\\n\\nclass Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int counta=0,countb=0,countc=0;\\n        for(int i=0;i<word.size();i++){\\n            if(word[i]==\\'a\\') counta++;\\n            else if(word[i]==\\'b\\') countb++;\\n            else countc++;\\n        }\\n        int m=max(max(counta,countb),countc);\\n        int res=(3*m)-counta-countb-countc;\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "krishna859768",
                        "content": "same problem\\nHave you find the reason?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "One of the most amazing question i solved on LC. Pure Logical, and the feeling of acceptance in one go is heavenly.  "
                    },
                    {
                        "username": "chachraanubhav",
                        "content": "Did anyone try the LCS approach ? I know it will take O(N^2) , and there is a simple iterative method that works in O(N)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone tell me the thought process how he/she come up with a Solution."
                    },
                    {
                        "username": "jason400",
                        "content": "If you want to be able to reliably derive a solution on sight without making lucky guesses or pattern recognition from similar problems, other thought processes like trying to recognize a pattern and then coding something up until it works won't cut it IMO. That would make it seem like you saw the problem before and turn the interview into essentially floundering around with intuition until you hopefully arrive at a solution in time. This is my thought process.\n1) Realize the problem is an optimization problem over a decision space of exponential size (branching factor at least 3), and note that a search over the problem space implemented with a simple recursion with backtracking implementation will yield a correct, albeit exponential runtime.\n2) Using your observation from #1, and your knowledge that greedy algorithms are often employed to efficiently optimize a set of decisions over even exponentially sized search trees, begin examining a set of 'localized' choices that might exhibit the Greedy Choice Property\n3) Observe that every valid solution modifies the problem space to a string that begins with 'abc', therefore, the optimal solution must contain these set of localized steps. Use intuition to posit that one 'choice' (set of local decisions) we can make would be to minimally append either an a,b,c to each of the initial characters until we arrive at 'abc'. Perform a quick 'proof' by contradiction in your head to gain confidence that no optimal solution excludes this minimal set of decisions. You have identified a choice that satisfies the Greedy Choice Property\n4) Realize that the Greedy Choice you have identified leads to a substructure decomposition which is also an optimal substructure (no surprise there, but good to check)\n5) Using the 'choice' you have identified as satisfying both the Greedy Choice Property and resolving the problem to an Optimal Substructure (you need those two things to proceed with confidence that your algorithm will actually work) implement a greedy algorithm using a combination of iteration and/or recursion, and use LinkedList backed stacks are your data structure to demonstrate additional mastery of data structures\n6) [Very Optional at best IMO] Further simplify the implementation by ripping out the linkedlist/stacks data structures, and any references to characters, by leveraging properties of ascii characters to achieve a slight constant time reduction in both runtime and memory, as well as LOC\n"
                    },
                    {
                        "username": "Kai_Ghost",
                        "content": "Find the pattern in the string in the nested while loop in the code beneath \n\n```\nclass Solution {\npublic:\n    int addMinimum(string word) {\n        int res = 0;\n        int ptr1 = 0;\n        int n = word.size();\n        while (ptr1 < n) {\n            char starting = word[ptr1];\n            int temp = ptr1 + 1;\n            char prev = starting;\n            while (temp < n && word[temp] > prev) {\n                prev = word[temp];\n                temp++;\n            }\n\n            res += 3 - (temp - ptr1);\n            ptr1 = temp;\n            \n        }\n\n\n\n\n\n        return res;\n\n        \n    }\n};\n\n\n```"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "we will interate word and check if expected letter is there or not according to repeating pattern of \"abc\" .if not present we increment count and increment and modulo index (we are adding a missing char to word)"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Leetcode, why is the result for \"aaaabb\" 9? I think it\\'s 6 because for 4 - a, 2 - b, 0 - c you need to add 2 \"b\" and 4 \"c\""
                    },
                    {
                        "username": "Dhaval25",
                        "content": "[a]bc [a]bc [a]bc  [ab]c  a[b]c :  As you can see the number of non-square brackets is 9 not 6. We add bc for first 3 \\'a\\' then we club 4th \\'ab\\' together and add \\'c\\' and for last \\'b\\' we add \\'ac\\' so in total we added 9 characters "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You can\\'t change the position of Characters.That\\'s why bb also need 2a and 2c."
                    },
                    {
                        "username": "bharat231",
                        "content": "We need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh"
                    },
                    {
                        "username": "Tim-Ax",
                        "content": "word = \\'aaaabb\\'\\n\\u041Eutput 6\\nExpected. 9\\nI meant it like that:\\naaaabb-> a a a a b b ->  ab ab a a => ab+c   ab+c   b+bc    b+bc\\nc c b c b c     6 letters\\n\\nDid I misunderstand the task?  :)\\nThanks"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "The question says \"you can insert letters \"a\", \"b\" or \"c\" anywhere and any number of times\".  So, I don\\'t think you can move around the existing letters.  \\n\\nSo, in this case the solution will be \\n      aaaabb \\n=> a a a a b b \\n=> a (bc) a (bc) a (bc) a b (c) (a) b (c)\\n=> abc abc abc abc abc \\n\\ninserted : b c b c b c c a c \\n"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "For this string, \"aaaabb\" => my output is 6, but it says 9 expected output"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "[@sergei-durkin](/sergei-durkin) hi bro, actually it s correct , we cannot move letters of word , so we need to validate it as it is "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "You are right, Litcode described the problem incorrectly. I also fell into this trap)\\n\\nif we look at this problem from the other side, we need to make valid string for each symbol in this string\\n\\nbharat231 described the answer to your question \\n```\\nWe need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh\\n```"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "This should be tagged as EASY :\n-  The problem is not that hard ( Though is a good one for beginner )\n-  The solutions mostly require tools LeetCode it self considers \"Fundamental\"\n-  The problem has many different ways it can be solved (Like many other Easy problems on the site )\n- The test case Constraints are smaller so that a solution with high time and space complexity can be accepted .\n- All in all signs of an Easy LeetCode problem ."
                    },
                    {
                        "username": "jason400",
                        "content": "It's quite challenging to derive it cold. To completely and fully solve such a problem one would need to model the problem as a decision tree, identify the minimal set prepend 'a','b','c' or pass steps to arrive at the first 'abc' subsequence in the optimal solution as both satisfying the greedy choice problem and resolving the problem to an optimal substructure. Then implement either a recursive or stack-based iterative greedy algorithm using such a greedy choice. While much of the implementation around the actual values of the characters can be stripped away to leave a simple iterative algorithm, any implementation would need to derive from such a solution in order to demonstrate a full understanding of the algorithm that is being employed.\n\nAnything less would indicate either a familiarity with the problem or an aimless luck or intuition based guess, which could be a failure in any real world interview.\n    \n\n\n\n    class Solution {\n        public int addMinimum(String word) {\n            ArrayList<Character> wordStack = new ArrayList<Character>();\n            for (Character c : word.toCharArray()) {\n                wordStack.add(c);\n            }\n            ArrayList<Character> abcStack = new ArrayList<Character>();\n    \n            int j = 0;\n            while (!wordStack.isEmpty()) {\n                abcStack.add('a');\n                abcStack.add('b');\n                abcStack.add('c');\n    \n                while (!abcStack.isEmpty() && !wordStack.isEmpty()) {\n                    char c = wordStack.remove(0).charValue();\n                    char i = abcStack.remove(0).charValue();\n    \n                    if (c != i) {\n                        wordStack.add(0, c);\n                        j++;\n                    }\n                }\n    \n            }\n            return j + abcStack.size();\n        }\n    }"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int i=0,count=0,n=word.size(),res=0;\\n\\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word[i] == \\'a\\') {\\n                count++;\\n            }\\n             \\n            if(word[i] == \\'b\\') {\\n                count++;\\n            }\\n            \\n            if(word[i] == \\'c\\') {\\n                count++;\\n            }\\n            i++;\\n            res += 3 - count;\\n        }\\n        cout<<res;\\n\\n\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1902740,
                "content": [
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Replace \"abc\" -> \"0\"\\n\"ab\" -> \"1\"\\n\"bc\" -> \"1\"\\n\"ac\" -> \"1\"\\n\"a\" -> \"2\"\\n\"b\" -> \"2\"\\n\"c\" -> \"2\"\\n\\nand iterate over the new modified string and sum up all the digits.\\nNote: The order of replacing is the key"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "why im getting error for \"aaaabb\"??\\n\\n\\nclass Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int counta=0,countb=0,countc=0;\\n        for(int i=0;i<word.size();i++){\\n            if(word[i]==\\'a\\') counta++;\\n            else if(word[i]==\\'b\\') countb++;\\n            else countc++;\\n        }\\n        int m=max(max(counta,countb),countc);\\n        int res=(3*m)-counta-countb-countc;\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "krishna859768",
                        "content": "same problem\\nHave you find the reason?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "One of the most amazing question i solved on LC. Pure Logical, and the feeling of acceptance in one go is heavenly.  "
                    },
                    {
                        "username": "chachraanubhav",
                        "content": "Did anyone try the LCS approach ? I know it will take O(N^2) , and there is a simple iterative method that works in O(N)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone tell me the thought process how he/she come up with a Solution."
                    },
                    {
                        "username": "jason400",
                        "content": "If you want to be able to reliably derive a solution on sight without making lucky guesses or pattern recognition from similar problems, other thought processes like trying to recognize a pattern and then coding something up until it works won't cut it IMO. That would make it seem like you saw the problem before and turn the interview into essentially floundering around with intuition until you hopefully arrive at a solution in time. This is my thought process.\n1) Realize the problem is an optimization problem over a decision space of exponential size (branching factor at least 3), and note that a search over the problem space implemented with a simple recursion with backtracking implementation will yield a correct, albeit exponential runtime.\n2) Using your observation from #1, and your knowledge that greedy algorithms are often employed to efficiently optimize a set of decisions over even exponentially sized search trees, begin examining a set of 'localized' choices that might exhibit the Greedy Choice Property\n3) Observe that every valid solution modifies the problem space to a string that begins with 'abc', therefore, the optimal solution must contain these set of localized steps. Use intuition to posit that one 'choice' (set of local decisions) we can make would be to minimally append either an a,b,c to each of the initial characters until we arrive at 'abc'. Perform a quick 'proof' by contradiction in your head to gain confidence that no optimal solution excludes this minimal set of decisions. You have identified a choice that satisfies the Greedy Choice Property\n4) Realize that the Greedy Choice you have identified leads to a substructure decomposition which is also an optimal substructure (no surprise there, but good to check)\n5) Using the 'choice' you have identified as satisfying both the Greedy Choice Property and resolving the problem to an Optimal Substructure (you need those two things to proceed with confidence that your algorithm will actually work) implement a greedy algorithm using a combination of iteration and/or recursion, and use LinkedList backed stacks are your data structure to demonstrate additional mastery of data structures\n6) [Very Optional at best IMO] Further simplify the implementation by ripping out the linkedlist/stacks data structures, and any references to characters, by leveraging properties of ascii characters to achieve a slight constant time reduction in both runtime and memory, as well as LOC\n"
                    },
                    {
                        "username": "Kai_Ghost",
                        "content": "Find the pattern in the string in the nested while loop in the code beneath \n\n```\nclass Solution {\npublic:\n    int addMinimum(string word) {\n        int res = 0;\n        int ptr1 = 0;\n        int n = word.size();\n        while (ptr1 < n) {\n            char starting = word[ptr1];\n            int temp = ptr1 + 1;\n            char prev = starting;\n            while (temp < n && word[temp] > prev) {\n                prev = word[temp];\n                temp++;\n            }\n\n            res += 3 - (temp - ptr1);\n            ptr1 = temp;\n            \n        }\n\n\n\n\n\n        return res;\n\n        \n    }\n};\n\n\n```"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "we will interate word and check if expected letter is there or not according to repeating pattern of \"abc\" .if not present we increment count and increment and modulo index (we are adding a missing char to word)"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Leetcode, why is the result for \"aaaabb\" 9? I think it\\'s 6 because for 4 - a, 2 - b, 0 - c you need to add 2 \"b\" and 4 \"c\""
                    },
                    {
                        "username": "Dhaval25",
                        "content": "[a]bc [a]bc [a]bc  [ab]c  a[b]c :  As you can see the number of non-square brackets is 9 not 6. We add bc for first 3 \\'a\\' then we club 4th \\'ab\\' together and add \\'c\\' and for last \\'b\\' we add \\'ac\\' so in total we added 9 characters "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You can\\'t change the position of Characters.That\\'s why bb also need 2a and 2c."
                    },
                    {
                        "username": "bharat231",
                        "content": "We need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh"
                    },
                    {
                        "username": "Tim-Ax",
                        "content": "word = \\'aaaabb\\'\\n\\u041Eutput 6\\nExpected. 9\\nI meant it like that:\\naaaabb-> a a a a b b ->  ab ab a a => ab+c   ab+c   b+bc    b+bc\\nc c b c b c     6 letters\\n\\nDid I misunderstand the task?  :)\\nThanks"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "The question says \"you can insert letters \"a\", \"b\" or \"c\" anywhere and any number of times\".  So, I don\\'t think you can move around the existing letters.  \\n\\nSo, in this case the solution will be \\n      aaaabb \\n=> a a a a b b \\n=> a (bc) a (bc) a (bc) a b (c) (a) b (c)\\n=> abc abc abc abc abc \\n\\ninserted : b c b c b c c a c \\n"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "For this string, \"aaaabb\" => my output is 6, but it says 9 expected output"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "[@sergei-durkin](/sergei-durkin) hi bro, actually it s correct , we cannot move letters of word , so we need to validate it as it is "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "You are right, Litcode described the problem incorrectly. I also fell into this trap)\\n\\nif we look at this problem from the other side, we need to make valid string for each symbol in this string\\n\\nbharat231 described the answer to your question \\n```\\nWe need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh\\n```"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "This should be tagged as EASY :\n-  The problem is not that hard ( Though is a good one for beginner )\n-  The solutions mostly require tools LeetCode it self considers \"Fundamental\"\n-  The problem has many different ways it can be solved (Like many other Easy problems on the site )\n- The test case Constraints are smaller so that a solution with high time and space complexity can be accepted .\n- All in all signs of an Easy LeetCode problem ."
                    },
                    {
                        "username": "jason400",
                        "content": "It's quite challenging to derive it cold. To completely and fully solve such a problem one would need to model the problem as a decision tree, identify the minimal set prepend 'a','b','c' or pass steps to arrive at the first 'abc' subsequence in the optimal solution as both satisfying the greedy choice problem and resolving the problem to an optimal substructure. Then implement either a recursive or stack-based iterative greedy algorithm using such a greedy choice. While much of the implementation around the actual values of the characters can be stripped away to leave a simple iterative algorithm, any implementation would need to derive from such a solution in order to demonstrate a full understanding of the algorithm that is being employed.\n\nAnything less would indicate either a familiarity with the problem or an aimless luck or intuition based guess, which could be a failure in any real world interview.\n    \n\n\n\n    class Solution {\n        public int addMinimum(String word) {\n            ArrayList<Character> wordStack = new ArrayList<Character>();\n            for (Character c : word.toCharArray()) {\n                wordStack.add(c);\n            }\n            ArrayList<Character> abcStack = new ArrayList<Character>();\n    \n            int j = 0;\n            while (!wordStack.isEmpty()) {\n                abcStack.add('a');\n                abcStack.add('b');\n                abcStack.add('c');\n    \n                while (!abcStack.isEmpty() && !wordStack.isEmpty()) {\n                    char c = wordStack.remove(0).charValue();\n                    char i = abcStack.remove(0).charValue();\n    \n                    if (c != i) {\n                        wordStack.add(0, c);\n                        j++;\n                    }\n                }\n    \n            }\n            return j + abcStack.size();\n        }\n    }"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int i=0,count=0,n=word.size(),res=0;\\n\\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word[i] == \\'a\\') {\\n                count++;\\n            }\\n             \\n            if(word[i] == \\'b\\') {\\n                count++;\\n            }\\n            \\n            if(word[i] == \\'c\\') {\\n                count++;\\n            }\\n            i++;\\n            res += 3 - count;\\n        }\\n        cout<<res;\\n\\n\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1865638,
                "content": [
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Replace \"abc\" -> \"0\"\\n\"ab\" -> \"1\"\\n\"bc\" -> \"1\"\\n\"ac\" -> \"1\"\\n\"a\" -> \"2\"\\n\"b\" -> \"2\"\\n\"c\" -> \"2\"\\n\\nand iterate over the new modified string and sum up all the digits.\\nNote: The order of replacing is the key"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "why im getting error for \"aaaabb\"??\\n\\n\\nclass Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int counta=0,countb=0,countc=0;\\n        for(int i=0;i<word.size();i++){\\n            if(word[i]==\\'a\\') counta++;\\n            else if(word[i]==\\'b\\') countb++;\\n            else countc++;\\n        }\\n        int m=max(max(counta,countb),countc);\\n        int res=(3*m)-counta-countb-countc;\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "krishna859768",
                        "content": "same problem\\nHave you find the reason?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "One of the most amazing question i solved on LC. Pure Logical, and the feeling of acceptance in one go is heavenly.  "
                    },
                    {
                        "username": "chachraanubhav",
                        "content": "Did anyone try the LCS approach ? I know it will take O(N^2) , and there is a simple iterative method that works in O(N)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can anyone tell me the thought process how he/she come up with a Solution."
                    },
                    {
                        "username": "jason400",
                        "content": "If you want to be able to reliably derive a solution on sight without making lucky guesses or pattern recognition from similar problems, other thought processes like trying to recognize a pattern and then coding something up until it works won't cut it IMO. That would make it seem like you saw the problem before and turn the interview into essentially floundering around with intuition until you hopefully arrive at a solution in time. This is my thought process.\n1) Realize the problem is an optimization problem over a decision space of exponential size (branching factor at least 3), and note that a search over the problem space implemented with a simple recursion with backtracking implementation will yield a correct, albeit exponential runtime.\n2) Using your observation from #1, and your knowledge that greedy algorithms are often employed to efficiently optimize a set of decisions over even exponentially sized search trees, begin examining a set of 'localized' choices that might exhibit the Greedy Choice Property\n3) Observe that every valid solution modifies the problem space to a string that begins with 'abc', therefore, the optimal solution must contain these set of localized steps. Use intuition to posit that one 'choice' (set of local decisions) we can make would be to minimally append either an a,b,c to each of the initial characters until we arrive at 'abc'. Perform a quick 'proof' by contradiction in your head to gain confidence that no optimal solution excludes this minimal set of decisions. You have identified a choice that satisfies the Greedy Choice Property\n4) Realize that the Greedy Choice you have identified leads to a substructure decomposition which is also an optimal substructure (no surprise there, but good to check)\n5) Using the 'choice' you have identified as satisfying both the Greedy Choice Property and resolving the problem to an Optimal Substructure (you need those two things to proceed with confidence that your algorithm will actually work) implement a greedy algorithm using a combination of iteration and/or recursion, and use LinkedList backed stacks are your data structure to demonstrate additional mastery of data structures\n6) [Very Optional at best IMO] Further simplify the implementation by ripping out the linkedlist/stacks data structures, and any references to characters, by leveraging properties of ascii characters to achieve a slight constant time reduction in both runtime and memory, as well as LOC\n"
                    },
                    {
                        "username": "Kai_Ghost",
                        "content": "Find the pattern in the string in the nested while loop in the code beneath \n\n```\nclass Solution {\npublic:\n    int addMinimum(string word) {\n        int res = 0;\n        int ptr1 = 0;\n        int n = word.size();\n        while (ptr1 < n) {\n            char starting = word[ptr1];\n            int temp = ptr1 + 1;\n            char prev = starting;\n            while (temp < n && word[temp] > prev) {\n                prev = word[temp];\n                temp++;\n            }\n\n            res += 3 - (temp - ptr1);\n            ptr1 = temp;\n            \n        }\n\n\n\n\n\n        return res;\n\n        \n    }\n};\n\n\n```"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "we will interate word and check if expected letter is there or not according to repeating pattern of \"abc\" .if not present we increment count and increment and modulo index (we are adding a missing char to word)"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Leetcode, why is the result for \"aaaabb\" 9? I think it\\'s 6 because for 4 - a, 2 - b, 0 - c you need to add 2 \"b\" and 4 \"c\""
                    },
                    {
                        "username": "Dhaval25",
                        "content": "[a]bc [a]bc [a]bc  [ab]c  a[b]c :  As you can see the number of non-square brackets is 9 not 6. We add bc for first 3 \\'a\\' then we club 4th \\'ab\\' together and add \\'c\\' and for last \\'b\\' we add \\'ac\\' so in total we added 9 characters "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You can\\'t change the position of Characters.That\\'s why bb also need 2a and 2c."
                    },
                    {
                        "username": "bharat231",
                        "content": "We need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh"
                    },
                    {
                        "username": "Tim-Ax",
                        "content": "word = \\'aaaabb\\'\\n\\u041Eutput 6\\nExpected. 9\\nI meant it like that:\\naaaabb-> a a a a b b ->  ab ab a a => ab+c   ab+c   b+bc    b+bc\\nc c b c b c     6 letters\\n\\nDid I misunderstand the task?  :)\\nThanks"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "The question says \"you can insert letters \"a\", \"b\" or \"c\" anywhere and any number of times\".  So, I don\\'t think you can move around the existing letters.  \\n\\nSo, in this case the solution will be \\n      aaaabb \\n=> a a a a b b \\n=> a (bc) a (bc) a (bc) a b (c) (a) b (c)\\n=> abc abc abc abc abc \\n\\ninserted : b c b c b c c a c \\n"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "For this string, \"aaaabb\" => my output is 6, but it says 9 expected output"
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "[@sergei-durkin](/sergei-durkin) hi bro, actually it s correct , we cannot move letters of word , so we need to validate it as it is "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "You are right, Litcode described the problem incorrectly. I also fell into this trap)\\n\\nif we look at this problem from the other side, we need to make valid string for each symbol in this string\\n\\nbharat231 described the answer to your question \\n```\\nWe need to make valid string for each char,\\n\\nfor 3 a\\'s -> 2(bc) => 6,\\nnext is ab -> 1 c => 1\\nand for last b -> 2(ac) => 2\\nso 9 is the ans\\n\\nwierd question tbh\\n```"
                    },
                    {
                        "username": "Manas_Ranjan_Das",
                        "content": "This should be tagged as EASY :\n-  The problem is not that hard ( Though is a good one for beginner )\n-  The solutions mostly require tools LeetCode it self considers \"Fundamental\"\n-  The problem has many different ways it can be solved (Like many other Easy problems on the site )\n- The test case Constraints are smaller so that a solution with high time and space complexity can be accepted .\n- All in all signs of an Easy LeetCode problem ."
                    },
                    {
                        "username": "jason400",
                        "content": "It's quite challenging to derive it cold. To completely and fully solve such a problem one would need to model the problem as a decision tree, identify the minimal set prepend 'a','b','c' or pass steps to arrive at the first 'abc' subsequence in the optimal solution as both satisfying the greedy choice problem and resolving the problem to an optimal substructure. Then implement either a recursive or stack-based iterative greedy algorithm using such a greedy choice. While much of the implementation around the actual values of the characters can be stripped away to leave a simple iterative algorithm, any implementation would need to derive from such a solution in order to demonstrate a full understanding of the algorithm that is being employed.\n\nAnything less would indicate either a familiarity with the problem or an aimless luck or intuition based guess, which could be a failure in any real world interview.\n    \n\n\n\n    class Solution {\n        public int addMinimum(String word) {\n            ArrayList<Character> wordStack = new ArrayList<Character>();\n            for (Character c : word.toCharArray()) {\n                wordStack.add(c);\n            }\n            ArrayList<Character> abcStack = new ArrayList<Character>();\n    \n            int j = 0;\n            while (!wordStack.isEmpty()) {\n                abcStack.add('a');\n                abcStack.add('b');\n                abcStack.add('c');\n    \n                while (!abcStack.isEmpty() && !wordStack.isEmpty()) {\n                    char c = wordStack.remove(0).charValue();\n                    char i = abcStack.remove(0).charValue();\n    \n                    if (c != i) {\n                        wordStack.add(0, c);\n                        j++;\n                    }\n                }\n    \n            }\n            return j + abcStack.size();\n        }\n    }"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b) return a;\\n        return b;\\n    }\\n    int addMinimum(string word) {\\n        int i=0,count=0,n=word.size(),res=0;\\n\\n        while(i < n) {\\n            int count = 0;\\n            \\n            if(word[i] == \\'a\\') {\\n                count++;\\n            }\\n             \\n            if(word[i] == \\'b\\') {\\n                count++;\\n            }\\n            \\n            if(word[i] == \\'c\\') {\\n                count++;\\n            }\\n            i++;\\n            res += 3 - count;\\n        }\\n        cout<<res;\\n\\n\\n        return res;\\n    }\\n};"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find Maximal Uncovered Ranges",
        "question_content": null,
        "solutions": [],
        "discussions": []
    },
    {
        "title": "Find the Distinct Difference Array",
        "question_content": "<p>You are given a <strong>0-indexed</strong> array <code>nums</code> of length <code>n</code>.</p>\n\n<p>The <strong>distinct difference</strong> array of <code>nums</code> is an array <code>diff</code> of length <code>n</code> such that <code>diff[i]</code> is equal to the number of distinct elements in the suffix <code>nums[i + 1, ..., n - 1]</code> <strong>subtracted from</strong> the number of distinct elements in the prefix <code>nums[0, ..., i]</code>.</p>\n\n<p>Return <em>the <strong>distinct difference</strong> array of </em><code>nums</code>.</p>\n\n<p>Note that <code>nums[i, ..., j]</code> denotes the subarray of <code>nums</code> starting at index <code>i</code> and ending at index <code>j</code> inclusive. Particularly, if <code>i &gt; j</code> then <code>nums[i, ..., j]</code> denotes an empty subarray.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4,5]\n<strong>Output:</strong> [-3,-1,1,3,5]\n<strong>Explanation:</strong> For index i = 0, there is 1 element in the prefix and 4 distinct elements in the suffix. Thus, diff[0] = 1 - 4 = -3.\nFor index i = 1, there are 2 distinct elements in the prefix and 3 distinct elements in the suffix. Thus, diff[1] = 2 - 3 = -1.\nFor index i = 2, there are 3 distinct elements in the prefix and 2 distinct elements in the suffix. Thus, diff[2] = 3 - 2 = 1.\nFor index i = 3, there are 4 distinct elements in the prefix and 1 distinct element in the suffix. Thus, diff[3] = 4 - 1 = 3.\nFor index i = 4, there are 5 distinct elements in the prefix and no elements in the suffix. Thus, diff[4] = 5 - 0 = 5.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,2,3,4,2]\n<strong>Output:</strong> [-2,-1,0,2,3]\n<strong>Explanation:</strong> For index i = 0, there is 1 element in the prefix and 3 distinct elements in the suffix. Thus, diff[0] = 1 - 3 = -2.\nFor index i = 1, there are 2 distinct elements in the prefix and 3 distinct elements in the suffix. Thus, diff[1] = 2 - 3 = -1.\nFor index i = 2, there are 2 distinct elements in the prefix and 2 distinct elements in the suffix. Thus, diff[2] = 2 - 2 = 0.\nFor index i = 3, there are 3 distinct elements in the prefix and 1 distinct element in the suffix. Thus, diff[3] = 3 - 1 = 2.\nFor index i = 4, there are 3 distinct elements in the prefix and no elements in the suffix. Thus, diff[4] = 3 - 0 = 3.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n == nums.length&nbsp;&lt;= 50</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 50</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3495134,
                "title": "explained-using-map-very-simple-easy-to-understand-solution",
                "content": "<b> Up vote if you like the solution </b>\\n\\n# Approach\\nTake two map, one to have the prefix indexed (mp) & second one is suffix indexed (rmp ).\\nFirst evaluate the suffix mapping of all element by traversing and indexing all elements\\nThen on second traverse start mapping the prefix index and removing the same from suffix mapping.\\n    - Need to erase the index if its occurance is zero.\\nTake diff of the size of the maps & store in to the ans array.\\n        \\n        \\n```\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        vector<int> ans;\\n        unordered_map<int,int> mp, rmp;\\n        for(auto n: nums){ rmp[n]++; }\\n        for(auto n: nums){\\n            mp[n]++;\\n            rmp[n]--;\\n            if(rmp[n] == 0) rmp.erase(n);\\n            ans.push_back(mp.size() - rmp.size());\\n        }\\n        return ans;\\n    }\\n```\\n\\n<b>Here is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        vector<int> ans;\\n        unordered_map<int,int> mp, rmp;\\n        for(auto n: nums){ rmp[n]++; }\\n        for(auto n: nums){\\n            mp[n]++;\\n            rmp[n]--;\\n            if(rmp[n] == 0) rmp.erase(n);\\n            ans.push_back(mp.size() - rmp.size());\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495054,
                "title": "c-java-python-simple-hashmap-store-frequency-time-o-n",
                "content": "# Intuition\\nSince we want number of distinct elements in a window, we can use hash map to store the frequency of each number in current window.\\nFor an index `i`,\\n- `prefix` maintains frequency table of `nums[0...i]`\\n- `suffix` maintains frequency table of `nums[i + 1...n - 1]`\\n\\n# Approach\\n1. Initially, `prefix` is empty, and `suffix` contains frequency of complete array. \\n2. Now, for each index `i`, remove `nums[i]` from `suffix` and add to `prefix`. Calculate `size(prefix) - size(suffix)`.\\n3. While removing an element from `suffix`, frequency might become 0. To make sure this `{key, value} = {x, 0}` pair is not counted, remove it from the hashmap.\\n\\n# Code\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        unordered_map<int, int> prefix, suffix;\\n        vector<int> result;\\n        for (int& x: nums) {\\n            suffix[x]++;\\n        }\\n        for (int& x: nums) {\\n            prefix[x]++;\\n            if (--suffix[x] == 0) {\\n                suffix.erase(x);\\n            }\\n            result.push_back(prefix.size() - suffix.size());\\n        }\\n        return result;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        HashMap<Integer, Integer> prefix = new HashMap<>();\\n        HashMap<Integer, Integer> suffix = new HashMap<>();\\n        int[] result = new int[nums.length];\\n        for (int x: nums) {\\n            suffix.put(x, suffix.getOrDefault(x, 0) + 1);\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            Integer x = nums[i];\\n            prefix.put(x, prefix.getOrDefault(x, 0) + 1);\\n            suffix.put(x, suffix.get(x) - 1);\\n            if (suffix.get(x) == 0) {\\n                suffix.remove(x);\\n            }\\n            result[i] = prefix.size() - suffix.size();\\n        }\\n        return result;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        # One liner\\n        # return [len(Counter(nums[:i + 1])) - len(Counter(nums[i + 1:])) for i in range(len(nums))]\\n        prefix = defaultdict(int)\\n        suffix = Counter(nums)\\n        result = []\\n        for x in nums:\\n            prefix[x] += 1\\n            suffix[x] -= 1\\n            if suffix[x] == 0:\\n                del suffix[x]\\n            result.append(len(prefix) - len(suffix))\\n        return result\\n```\\n\\n# Complexity\\n- Time complexity: $$\\\\Theta(n)$$\\n- Space complexity: $$\\\\Theta(n)$$",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        unordered_map<int, int> prefix, suffix;\\n        vector<int> result;\\n        for (int& x: nums) {\\n            suffix[x]++;\\n        }\\n        for (int& x: nums) {\\n            prefix[x]++;\\n            if (--suffix[x] == 0) {\\n                suffix.erase(x);\\n            }\\n            result.push_back(prefix.size() - suffix.size());\\n        }\\n        return result;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        HashMap<Integer, Integer> prefix = new HashMap<>();\\n        HashMap<Integer, Integer> suffix = new HashMap<>();\\n        int[] result = new int[nums.length];\\n        for (int x: nums) {\\n            suffix.put(x, suffix.getOrDefault(x, 0) + 1);\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            Integer x = nums[i];\\n            prefix.put(x, prefix.getOrDefault(x, 0) + 1);\\n            suffix.put(x, suffix.get(x) - 1);\\n            if (suffix.get(x) == 0) {\\n                suffix.remove(x);\\n            }\\n            result[i] = prefix.size() - suffix.size();\\n        }\\n        return result;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        # One liner\\n        # return [len(Counter(nums[:i + 1])) - len(Counter(nums[i + 1:])) for i in range(len(nums))]\\n        prefix = defaultdict(int)\\n        suffix = Counter(nums)\\n        result = []\\n        for x in nums:\\n            prefix[x] += 1\\n            suffix[x] -= 1\\n            if suffix[x] == 0:\\n                del suffix[x]\\n            result.append(len(prefix) - len(suffix))\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494932,
                "title": "l2r-r2l",
                "content": "**C++**\\n```cpp\\nvector<int> distinctDifferenceArray(vector<int>& nums) {\\n    int cnt[51] = {}, dist = 0;\\n    vector<int> res;\\n    for (int n : nums)\\n        res.push_back((res.empty() ? 0 : res.back()) + (cnt[n]++ == 0));\\n    for (int i = nums.size() - 1; i >= 1; --i) {\\n        dist += exchange(cnt[nums[i]], 0) > 0;\\n        res[i - 1] -= dist;        \\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<int> distinctDifferenceArray(vector<int>& nums) {\\n    int cnt[51] = {}, dist = 0;\\n    vector<int> res;\\n    for (int n : nums)\\n        res.push_back((res.empty() ? 0 : res.back()) + (cnt[n]++ == 0));\\n    for (int i = nums.size() - 1; i >= 1; --i) {\\n        dist += exchange(cnt[nums[i]], 0) > 0;\\n        res[i - 1] -= dist;        \\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3505217,
                "title": "set-prefix-and-suffix",
                "content": "\\nFirst thought - The length of input is small. To find the number of distinct numbers, we can use Set. Therefore, we can iterate each number, put `nums[:i + 1]` and `nums[i + 1:]` to Set,  count the lengths and calculate the difference.\\n\\n```py\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        res = []\\n        for i in range(len(nums)):\\n            res.append(len(set(nums[:i + 1])) - len(set(nums[i + 1:])))\\n        return res\\n```\\n\\nHere\\'s the one-liner of the above solution.\\n\\n```py\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        return [len(set(nums[:i + 1])) - len(set(nums[i + 1:])) for i in range(len(nums))]\\n```\\n\\nHowever, in above solution, it is not optimize as we slice the list for each index. To improve it, we can use prefix and suffix. The logic is similar. For each index, we add `nums[i]` in set and record the length. \\n\\n```py\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        pre, suf = [], []\\n        ps, ss = set(), set()\\n        n = len(nums)\\n        for i in range(n):\\n            ps.add(nums[i])\\n            pre.append(len(ps))\\n        for i in range(n - 1, -1, -1):\\n            suf.insert(0, len(ss))\\n            ss.add(nums[i])\\n        # pre: [1, 2, 3, 4, 5]\\n        # suf: [4, 3, 2, 1, 0]\\n        # ans: [-3, -1, 1, 3, 5]\\n        return [pre[i] - suf[i] for i in range(n)]\\n```",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```py\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        res = []\\n        for i in range(len(nums)):\\n            res.append(len(set(nums[:i + 1])) - len(set(nums[i + 1:])))\\n        return res\\n```\n```py\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        return [len(set(nums[:i + 1])) - len(set(nums[i + 1:])) for i in range(len(nums))]\\n```\n```py\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        pre, suf = [], []\\n        ps, ss = set(), set()\\n        n = len(nums)\\n        for i in range(n):\\n            ps.add(nums[i])\\n            pre.append(len(ps))\\n        for i in range(n - 1, -1, -1):\\n            suf.insert(0, len(ss))\\n            ss.add(nums[i])\\n        # pre: [1, 2, 3, 4, 5]\\n        # suf: [4, 3, 2, 1, 0]\\n        # ans: [-3, -1, 1, 3, 5]\\n        return [pre[i] - suf[i] for i in range(n)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497064,
                "title": "c-iterate-backward-and-forward-using-std-bitset-fast-39ms-100",
                "content": "**TODO(heder): Insert cute cat meme to ask for up-votes. ;)**\\n\\n# Approach 1: using std::bitset\\nSince the input range is so limited we can using a ```std::bitset``` to count unique elements instead of ```std::unordered_map```. With only 64bit wide the compiler can use ```popcount``` to count the number of set bits / unique elments.\\n\\n```cpp\\n    static vector<int> distinctDifferenceArray(const vector<int>& nums) {\\n        // scan backward\\n        bitset<64> bw;\\n        vector<int> cnt_bw(size(nums));\\n        for (int i = size(nums) - 1; i >= 0; --i) {\\n            cnt_bw[i] = bw.count();\\n            bw.set(nums[i]);\\n        }\\n        // scan forward\\n        bitset<64> fw;\\n        vector<int> ans;\\n        ans.reserve(size(nums));\\n        for (int i = 0; i < size(nums); ++i) {\\n            fw.set(nums[i]);\\n            ans.push_back(fw.count() - cnt_bw[i]);\\n        }\\n        return ans;\\n    }\\n```\\n\\n**Complexity Analysis**\\nLet $$n$$ be the lenght of the input then\\n  * Time complexity is $$O(n)$$ as we need to scan it forward and backward and\\n  * Space complexity is $$O(1)$$.\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```std::bitset```\n```std::unordered_map```\n```popcount```\n```cpp\\n    static vector<int> distinctDifferenceArray(const vector<int>& nums) {\\n        // scan backward\\n        bitset<64> bw;\\n        vector<int> cnt_bw(size(nums));\\n        for (int i = size(nums) - 1; i >= 0; --i) {\\n            cnt_bw[i] = bw.count();\\n            bw.set(nums[i]);\\n        }\\n        // scan forward\\n        bitset<64> fw;\\n        vector<int> ans;\\n        ans.reserve(size(nums));\\n        for (int i = 0; i < size(nums); ++i) {\\n            fw.set(nums[i]);\\n            ans.push_back(fw.count() - cnt_bw[i]);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495901,
                "title": "javascript-2670-find-the-distinct-difference-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```\\nconst distinctDifferenceArray = function (a) {\\n  const n = a.length\\n  const pre = new Array(n) // prefix counts\\n  const suf = new Array(n) // suffix counts\\n  let set\\n\\n  set = new Set()\\n  for (let i = 0; i < n; i++) {\\n    set.add(a[i])\\n    pre[i] = set.size\\n  }\\n\\n  set = new Set()\\n  for (let i = n - 1; i >= 0; i--) {\\n    suf[i] = set.size\\n    set.add(a[i])\\n  }\\n\\n  const an = new Array(n)\\n  for (let i = 0; i < n; i++) {\\n    an[i] = pre[i] - suf[i]\\n  }\\n  return an\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst distinctDifferenceArray = function (a) {\\n  const n = a.length\\n  const pre = new Array(n) // prefix counts\\n  const suf = new Array(n) // suffix counts\\n  let set\\n\\n  set = new Set()\\n  for (let i = 0; i < n; i++) {\\n    set.add(a[i])\\n    pre[i] = set.size\\n  }\\n\\n  set = new Set()\\n  for (let i = n - 1; i >= 0; i--) {\\n    suf[i] = set.size\\n    set.add(a[i])\\n  }\\n\\n  const an = new Array(n)\\n  for (let i = 0; i < n; i++) {\\n    an[i] = pre[i] - suf[i]\\n  }\\n  return an\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3494987,
                "title": "c-easiest-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        unordered_map<int,int>mpsuffix,mpprefix;\\n        for(int i=0;i<nums.size();i++){\\n            mpsuffix[nums[i]]++;\\n        }\\n    vector<int>ans;\\n    \\n    for(int i=0;i<nums.size();i++){\\n        mpprefix[nums[i]]++;\\n        mpsuffix[nums[i]]--;\\n        \\n        if(mpsuffix[nums[i]]<=0) mpsuffix.erase(nums[i]);\\n        int bsz=mpprefix.size();\\n        int fsz=mpsuffix.size();\\n        \\n        ans.push_back(bsz-fsz);\\n    }\\n    \\n    return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        unordered_map<int,int>mpsuffix,mpprefix;\\n        for(int i=0;i<nums.size();i++){\\n            mpsuffix[nums[i]]++;\\n        }\\n    vector<int>ans;\\n    \\n    for(int i=0;i<nums.size();i++){\\n        mpprefix[nums[i]]++;\\n        mpsuffix[nums[i]]--;\\n        \\n        if(mpsuffix[nums[i]]<=0) mpsuffix.erase(nums[i]);\\n        int bsz=mpprefix.size();\\n        int fsz=mpsuffix.size();\\n        \\n        ans.push_back(bsz-fsz);\\n    }\\n    \\n    return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494949,
                "title": "easy-to-understand-set",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        vector<int>ans(n, 0);\\n        //==========================================================\\n        set<int>suffixSet;\\n        vector<int>suffix(n, 0); \\n        for (int i = n - 1; i >= 0; i--)\\n        {\\n            suffixSet.insert(nums[i]);\\n            suffix[i] = suffixSet.size();\\n        }\\n        //=========================================================\\n        set<int>prefixSet;\\n        for (int i = 0; i < n; i++)\\n        {\\n            prefixSet.insert(nums[i]);\\n            int prefixDistinct  = prefixSet.size();\\n            int suffixDistinct = (i + 1 >= n)? 0 : suffix[i + 1];\\n            ans[i] = prefixDistinct - suffixDistinct;\\n        }\\n        //===========================================================\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        vector<int>ans(n, 0);\\n        //==========================================================\\n        set<int>suffixSet;\\n        vector<int>suffix(n, 0); \\n        for (int i = n - 1; i >= 0; i--)\\n        {\\n            suffixSet.insert(nums[i]);\\n            suffix[i] = suffixSet.size();\\n        }\\n        //=========================================================\\n        set<int>prefixSet;\\n        for (int i = 0; i < n; i++)\\n        {\\n            prefixSet.insert(nums[i]);\\n            int prefixDistinct  = prefixSet.size();\\n            int suffixDistinct = (i + 1 >= n)? 0 : suffix[i + 1];\\n            ans[i] = prefixDistinct - suffixDistinct;\\n        }\\n        //===========================================================\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494946,
                "title": "day-402-beginner-friendly-100-0ms-python-java-c-explained-approach",
                "content": "# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n\\n\\nJUST AN IMPLEMENTATION PRBOLEM. \\nAlways try to explore more  \\n\\n# Intuition &  Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n##### \\u2022\\tInitialize an array answer of size n, where n is the length of the input array.\\n##### \\u2022\\tInitialize two arrays prefix and suffix of size n.\\n##### \\u2022\\tInitialize two hash sets prefixset and suffixSet.\\n##### \\u2022\\tIterate over the input array nums from left to right, and for each element nums[i], do the following:\\n##### \\u2022 a. If  prefixset does not contain nums[i], add nums[i] to prefixset and set prefix[i] to the size of prefixset.\\n##### \\u2022 b. If prefixset contains nums[i], set prefix[i] to the value of prefix[i-1].\\n##### \\u2022\\tIterate over the input arrayfrom right to left, and for each element, do the following:\\n##### \\u2022 a. If  suffixSet does not contain nums[i], add nums[i] to suffixSet and set suffix[i] to the size of suffixSet.\\n##### \\u2022 b. If suffixSet contains nums[i], set suffix[i] to the value of suffix[i+1].\\n##### \\u2022\\tIterate over the input array nums from left to right, and for each element, set answer[i] to prefix[i]-surffix[i+1]\\n##### \\u2022\\tSet answer[n-1] = prefix[n-1].\\n##### \\u2022\\tReturn the answer array.\\n\\n\\n\\n# Code\\n```java []\\npublic int[] distinctDifferenceArray(int[] nums) {\\n    int n = nums.length;\\n    int[] answer = new int[n];\\n    int[] prefix = new int[n];\\n    int[] suffix = new int[n];\\n    HashSet<Integer> prefixSet = new HashSet<>();\\n    HashSet<Integer> suffixSet = new HashSet<>();\\n\\n    // Step 1: Iterate over the input array from left to right to fill the prefix array\\n    for (int i = 0, j = 1; i < n; i++) {\\n        if (!prefixSet.contains(nums[i])) {\\n            prefixSet.add(nums[i]);\\n            prefix[i] = j++;\\n        } else if (i > 0) {\\n            prefix[i] = prefix[i-1];\\n        }\\n    }\\n\\n    // Step 2: Iterate over the input array from right to left to fill the suffix array\\n    for (int i = n-1, j = 1; i >= 0; i--) {\\n        if (!suffixSet.contains(nums[i])) {\\n            suffixSet.add(nums[i]);\\n            suffix[i] = j++;\\n        } else if (i > 0) {\\n            suffix[i] = suffix[i+1];\\n        }\\n    }\\n\\n    // Step 3: Iterate over the input array to fill the answer array\\n    for (int i = 0; i < n-1; i++) {\\n        answer[i] = prefix[i] - suffix[i+1];\\n    }\\n    answer[n-1] = prefix[n-1];\\n\\n    return answer;\\n}\\n```\\n```c++ []\\nvector<int> distinctDifferenceArray(std::vector<int>& nums) {\\n    int n = nums.size();\\n    std::vector<int> answer(n);\\n    std::vector<int> prefix(n);\\n    std::vector<int> suffix(n);\\n    std::unordered_set<int> prefixSet;\\n    std::unordered_set<int> suffixSet;\\n    for (int i = 0, j = 1; i < n; i++) {\\n        if (prefixSet.find(nums[i]) == prefixSet.end()) {\\n            prefixSet.insert(nums[i]);\\n            prefix[i] = j++;\\n        } else if (i > 0) {\\n            prefix[i] = prefix[i-1];\\n        }\\n    }\\n    for (int i = n-1, j = 1; i >= 0; i--) {\\n        if (suffixSet.find(nums[i]) == suffixSet.end()) {\\n            suffixSet.insert(nums[i]);\\n            suffix[i] = j++;\\n        } else if (i < n-1) {\\n            suffix[i] = suffix[i+1];\\n        }\\n    }\\n    for (int i = 0; i < n-1; i++) {\\n        answer[i] = prefix[i] - suffix[i+1];\\n    }\\n    answer[n-1] = prefix[n-1];\\n    return answer;\\n}\\n```\\n```python []\\ndef distinctDifferenceArray(nums: List[int]) -> List[int]:\\n    n = len(nums)\\n    answer = [0] * n\\n    prefix = [0] * n\\n    suffix = [0] * n\\n    prefixSet = set()\\n    suffixSet = set()\\n    for i in range(n):\\n        if nums[i] not in prefixSet:\\n            prefixSet.add(nums[i])\\n            prefix[i] = len(prefixSet)\\n        elif i > 0:\\n            prefix[i] = prefix[i-1]\\n    for i in range(n-1, -1, -1):\\n        if nums[i] not in suffixSet:\\n            suffixSet.add(nums[i])\\n            suffix[i] = len(suffixSet)\\n        elif i < n-1:\\n            suffix[i] = suffix[i+1]\\n    for i in range(n-1):\\n        answer[i] = prefix[i] - suffix[i+1]\\n    answer[n-1] = prefix[n-1]\\n    return answer\\n```\\n\\n\\n# Complexity\\n- Time complexity:o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# using premitives faster runtime 4ms [objects are Costlier  ]\\n![image.png](https://assets.leetcode.com/users/images/6640aa48-415a-4c65-b841-0450f5d3a5f1_1683443184.084796.png)\\n\\n```java []\\npublic int[] distinctDifferenceArray(int[] nums) {\\n    int n = nums.length;\\n    int[] answer = new int[n];\\n    int[] prefix = new int[n];\\n    int[] suffix = new int[n];\\n    boolean[] prefixSeen = new boolean[51];\\n    boolean[] suffixSeen = new boolean[51];\\n\\n    // Step 1: Iterate over the input array from left to right to fill the prefix array\\n    for (int i = 0, j = 1; i < n; i++) {\\n        if (!prefixSeen[nums[i]]) {\\n            prefixSeen[nums[i]] = true;\\n            prefix[i] = j++;\\n        } else if (i > 0) {\\n            prefix[i] = prefix[i-1];\\n        }\\n    }\\n\\n    // Step 2: Iterate over the input array from right to left to fill the suffix array\\n    for (int i = n-1, j = 1; i >= 0; i--) {\\n        if (!suffixSeen[nums[i]]) {\\n            suffixSeen[nums[i]] = true;\\n            suffix[i] = j++;\\n        } else if (i < n-1) {\\n            suffix[i] = suffix[i+1];\\n        }\\n    }\\n\\n    // Step 3: Iterate over the input array to fill the answer array\\n    for (int i = 0; i < n-1; i++) {\\n        answer[i] = prefix[i] - suffix[i+1];\\n    }\\n    answer[n-1] = prefix[n-1];\\n\\n    return answer;\\n}\\n````\\n\\n\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/062630f0-ef80-4e74-abdb-302827b99235_1680054012.5054147.webp)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Suffix Array"
                ],
                "code": "```java []\\npublic int[] distinctDifferenceArray(int[] nums) {\\n    int n = nums.length;\\n    int[] answer = new int[n];\\n    int[] prefix = new int[n];\\n    int[] suffix = new int[n];\\n    HashSet<Integer> prefixSet = new HashSet<>();\\n    HashSet<Integer> suffixSet = new HashSet<>();\\n\\n    // Step 1: Iterate over the input array from left to right to fill the prefix array\\n    for (int i = 0, j = 1; i < n; i++) {\\n        if (!prefixSet.contains(nums[i])) {\\n            prefixSet.add(nums[i]);\\n            prefix[i] = j++;\\n        } else if (i > 0) {\\n            prefix[i] = prefix[i-1];\\n        }\\n    }\\n\\n    // Step 2: Iterate over the input array from right to left to fill the suffix array\\n    for (int i = n-1, j = 1; i >= 0; i--) {\\n        if (!suffixSet.contains(nums[i])) {\\n            suffixSet.add(nums[i]);\\n            suffix[i] = j++;\\n        } else if (i > 0) {\\n            suffix[i] = suffix[i+1];\\n        }\\n    }\\n\\n    // Step 3: Iterate over the input array to fill the answer array\\n    for (int i = 0; i < n-1; i++) {\\n        answer[i] = prefix[i] - suffix[i+1];\\n    }\\n    answer[n-1] = prefix[n-1];\\n\\n    return answer;\\n}\\n```\n```c++ []\\nvector<int> distinctDifferenceArray(std::vector<int>& nums) {\\n    int n = nums.size();\\n    std::vector<int> answer(n);\\n    std::vector<int> prefix(n);\\n    std::vector<int> suffix(n);\\n    std::unordered_set<int> prefixSet;\\n    std::unordered_set<int> suffixSet;\\n    for (int i = 0, j = 1; i < n; i++) {\\n        if (prefixSet.find(nums[i]) == prefixSet.end()) {\\n            prefixSet.insert(nums[i]);\\n            prefix[i] = j++;\\n        } else if (i > 0) {\\n            prefix[i] = prefix[i-1];\\n        }\\n    }\\n    for (int i = n-1, j = 1; i >= 0; i--) {\\n        if (suffixSet.find(nums[i]) == suffixSet.end()) {\\n            suffixSet.insert(nums[i]);\\n            suffix[i] = j++;\\n        } else if (i < n-1) {\\n            suffix[i] = suffix[i+1];\\n        }\\n    }\\n    for (int i = 0; i < n-1; i++) {\\n        answer[i] = prefix[i] - suffix[i+1];\\n    }\\n    answer[n-1] = prefix[n-1];\\n    return answer;\\n}\\n```\n```python []\\ndef distinctDifferenceArray(nums: List[int]) -> List[int]:\\n    n = len(nums)\\n    answer = [0] * n\\n    prefix = [0] * n\\n    suffix = [0] * n\\n    prefixSet = set()\\n    suffixSet = set()\\n    for i in range(n):\\n        if nums[i] not in prefixSet:\\n            prefixSet.add(nums[i])\\n            prefix[i] = len(prefixSet)\\n        elif i > 0:\\n            prefix[i] = prefix[i-1]\\n    for i in range(n-1, -1, -1):\\n        if nums[i] not in suffixSet:\\n            suffixSet.add(nums[i])\\n            suffix[i] = len(suffixSet)\\n        elif i < n-1:\\n            suffix[i] = suffix[i+1]\\n    for i in range(n-1):\\n        answer[i] = prefix[i] - suffix[i+1]\\n    answer[n-1] = prefix[n-1]\\n    return answer\\n```\n```java []\\npublic int[] distinctDifferenceArray(int[] nums) {\\n    int n = nums.length;\\n    int[] answer = new int[n];\\n    int[] prefix = new int[n];\\n    int[] suffix = new int[n];\\n    boolean[] prefixSeen = new boolean[51];\\n    boolean[] suffixSeen = new boolean[51];\\n\\n    // Step 1: Iterate over the input array from left to right to fill the prefix array\\n    for (int i = 0, j = 1; i < n; i++) {\\n        if (!prefixSeen[nums[i]]) {\\n            prefixSeen[nums[i]] = true;\\n            prefix[i] = j++;\\n        } else if (i > 0) {\\n            prefix[i] = prefix[i-1];\\n        }\\n    }\\n\\n    // Step 2: Iterate over the input array from right to left to fill the suffix array\\n    for (int i = n-1, j = 1; i >= 0; i--) {\\n        if (!suffixSeen[nums[i]]) {\\n            suffixSeen[nums[i]] = true;\\n            suffix[i] = j++;\\n        } else if (i < n-1) {\\n            suffix[i] = suffix[i+1];\\n        }\\n    }\\n\\n    // Step 3: Iterate over the input array to fill the answer array\\n    for (int i = 0; i < n-1; i++) {\\n        answer[i] = prefix[i] - suffix[i+1];\\n    }\\n    answer[n-1] = prefix[n-1];\\n\\n    return answer;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3497314,
                "title": "python-3-7-lines-no-sets-w-example-t-m-122-ms-16-2-mb",
                "content": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:    #  Example:   nums = [3,2,3,4,2]\\n                                                                        #  \\n        pref, suff = defaultdict(int), Counter(nums)                    #   pref, suff = {}, {2:2, 3:2, 4:1}\\n\\n        cur = -len(suff)                                                #  cur = -3\\n\\n        for i, n in enumerate(nums):                                    #  n  cur  pref           suff           nums\\n            pref[n]+= 1                                                 # \\u2013\\u2013\\u2013 \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013       \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013        \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\n            suff[n]-= 1                                                 #      -3  {2:0,3:0,4:0}  {2:2,3:2,4:1}  [| 3, 2, 3, 4, 2]\\n            cur = nums[i] = cur + (pref[n] == 1) + (suff[n] == 0)       #  3   -2  {2:0,3:1,4:0}  {2:2,3:1,4:1}  [-2,| 2, 3, 4, 2]\\n                                                                        #  2   -1  {2:1,3:1,4:0}  {2:1,3:1,4:1}  [-2,-1,| 3, 4, 2]\\n        return  nums                                                    #  3    0  {2:1,3:2,4:0}  {2:1,3:0,4:1}  [-2,-1, 0,| 4, 2]\\n                                                                        #  4    2  {2:1,3:2,4:1}  {2:1,3:0,4:0}  [-2,-1, 0, 2,| 2]\\n                                                                        #  2    3  {2:2,3:2,4:1}  {2:0,3:0,4:0}  [-2,-1, 0, 2, 3|]\\n```\\n[https://leetcode.com/problems/find-the-distinct-difference-array/submissions/946122293/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:    #  Example:   nums = [3,2,3,4,2]\\n                                                                        #  \\n        pref, suff = defaultdict(int), Counter(nums)                    #   pref, suff = {}, {2:2, 3:2, 4:1}\\n\\n        cur = -len(suff)                                                #  cur = -3\\n\\n        for i, n in enumerate(nums):                                    #  n  cur  pref           suff           nums\\n            pref[n]+= 1                                                 # \\u2013\\u2013\\u2013 \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013       \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013        \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\n            suff[n]-= 1                                                 #      -3  {2:0,3:0,4:0}  {2:2,3:2,4:1}  [| 3, 2, 3, 4, 2]\\n            cur = nums[i] = cur + (pref[n] == 1) + (suff[n] == 0)       #  3   -2  {2:0,3:1,4:0}  {2:2,3:1,4:1}  [-2,| 2, 3, 4, 2]\\n                                                                        #  2   -1  {2:1,3:1,4:0}  {2:1,3:1,4:1}  [-2,-1,| 3, 4, 2]\\n        return  nums                                                    #  3    0  {2:1,3:2,4:0}  {2:1,3:0,4:1}  [-2,-1, 0,| 4, 2]\\n                                                                        #  4    2  {2:1,3:2,4:1}  {2:1,3:0,4:0}  [-2,-1, 0, 2,| 2]\\n                                                                        #  2    3  {2:2,3:2,4:1}  {2:0,3:0,4:0}  [-2,-1, 0, 2, 3|]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497091,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int a[]=new int[51];\\n        int len=nums.length;\\n        int res[]=new int[len];\\n        for(int i:nums)\\n        {\\n            a[i]++;\\n        }\\n        int b[]=new int[51];\\n        for(int i=0;i<len;i++)\\n        {\\n            b[nums[i]]++;\\n            a[nums[i]]--;\\n            int count=0,count1=0;\\n            for(int j=1;j<=50;j++)\\n            {\\n                if(a[j]>0)\\n                {\\n                    count++;\\n                }\\n            }\\n            for(int j=1;j<=50;j++)\\n            {\\n                if(b[j]>0)\\n                {\\n                    count1++;\\n                }\\n            }\\n            res[i]=count1-count;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int a[]=new int[51];\\n        int len=nums.length;\\n        int res[]=new int[len];\\n        for(int i:nums)\\n        {\\n            a[i]++;\\n        }\\n        int b[]=new int[51];\\n        for(int i=0;i<len;i++)\\n        {\\n            b[nums[i]]++;\\n            a[nums[i]]--;\\n            int count=0,count1=0;\\n            for(int j=1;j<=50;j++)\\n            {\\n                if(a[j]>0)\\n                {\\n                    count++;\\n                }\\n            }\\n            for(int j=1;j<=50;j++)\\n            {\\n                if(b[j]>0)\\n                {\\n                    count1++;\\n                }\\n            }\\n            res[i]=count1-count;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495596,
                "title": "c-map-100-faster",
                "content": "FIRST I STORE COUNT OF EACH ELEMENT IN AN UNORDERED_MAP(mp2) WORK AS SUFFIX DISTICNT NO.\\nUSE ANOTHER UNORDERED_MAP(mp1) MAINTAIN DISTINCT COUNT OF PREFIX ELEMENTS.\\nPUSH (prefix.distint_no - suffix.distint_no) into answer array\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        unordered_map<int,int> mp1,mp2;\\n        for(auto &i: nums)mp2[i]++;\\n        vector<int> ans;\\n        for(auto &i: nums){\\n            mp2[i]--;\\n            mp1[i]++;\\n            if(mp2[i]==0)mp2.erase(i);\\n            ans.push_back(mp1.size()-mp2.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        unordered_map<int,int> mp1,mp2;\\n        for(auto &i: nums)mp2[i]++;\\n        vector<int> ans;\\n        for(auto &i: nums){\\n            mp2[i]--;\\n            mp1[i]++;\\n            if(mp2[i]==0)mp2.erase(i);\\n            ans.push_back(mp1.size()-mp2.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3510833,
                "title": "python-easy-solution",
                "content": "# Code\\u2705\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        diff = []\\n        for i in range(len(nums)):\\n            prefix = len(set(nums[:i+1]))\\n            surfix = len(set(nums[i+1:]))\\n            diff.append(prefix-surfix)\\n        return diff\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        diff = []\\n        for i in range(len(nums)):\\n            prefix = len(set(nums[:i+1]))\\n            surfix = len(set(nums[i+1:]))\\n            diff.append(prefix-surfix)\\n        return diff\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495361,
                "title": "full-explanation-no-hashmap-simplest-approach",
                "content": "# Intuition\\n\\nNo hashmap Simple Iteration\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. The problem asks to find the distinct difference array of a given array \"nums\". The distinct difference array is an array of the same length as \"nums\", where each element \"diff[i]\" is calculated by subtracting the number of distinct elements in the suffix of \"nums\" (i.e., elements from index i+1 to n-1) from the number of distinct elements in the prefix of \"nums\" (i.e., elements from index 0 to i).\\n 2. To solve the problem, the above code defines a class \"Solution\" with a public method \"distinctDifferenceArray\" that takes an integer array \"nums\" as input and returns an integer array \"diff\". \\n 3. The \"distinctDifferenceArray\" method loops through each index of the \"nums\" array and calculates the difference between the number of distinct elements in the prefix and the number of distinct elements in the suffix, and stores the result in the \"diff\" array. \\n 4. To count the number of distinct elements in a given subarray of \"nums\", the code defines a helper method \"countDistinctElements\" that takes an integer array \"nums\", a starting index \"start\", and an ending index \"end\" as input, and returns the count of distinct elements in the subarray from index \"start\" to index \"end\". \\n 5. The method uses a boolean array \"visited\" to keep track of the elements that have been visited before. Overall, the code solves the problem by calculating the distinct difference array for the given \"nums\" array, where each element in the array is calculated using the \"countDistinctElements\" helper method to count the number of distinct elements in the prefix and suffix of the current element.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n      \\n        int n = nums.length;\\n        int[] diff = new int[n];\\n        \\n        // iterate through each index\\n        for (int i = 0; i < n; i++) {\\n            int countPrefix = countDistinctElements(nums, 0, i);\\n            int countSuffix = countDistinctElements(nums, i + 1, n - 1);\\n            diff[i] = countPrefix - countSuffix;\\n        }\\n        \\n        return diff;\\n    }\\n    \\n    private static int countDistinctElements(int[] nums, int start, int end) {\\n        boolean[] visited = new boolean[100001]; // assuming values are less than 100001\\n        int count = 0;\\n        for (int i = start; i <= end; i++) {\\n            if (!visited[nums[i]]) {\\n                visited[nums[i]] = true;\\n                count++;\\n            }\\n        }\\n        return count;\\n}}\\n```\\n![images.jpeg](https://assets.leetcode.com/users/images/22b6e345-a194-4819-9449-bed0b0eb321b_1683435836.4436464.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n      \\n        int n = nums.length;\\n        int[] diff = new int[n];\\n        \\n        // iterate through each index\\n        for (int i = 0; i < n; i++) {\\n            int countPrefix = countDistinctElements(nums, 0, i);\\n            int countSuffix = countDistinctElements(nums, i + 1, n - 1);\\n            diff[i] = countPrefix - countSuffix;\\n        }\\n        \\n        return diff;\\n    }\\n    \\n    private static int countDistinctElements(int[] nums, int start, int end) {\\n        boolean[] visited = new boolean[100001]; // assuming values are less than 100001\\n        int count = 0;\\n        for (int i = start; i <= end; i++) {\\n            if (!visited[nums[i]]) {\\n                visited[nums[i]] = true;\\n                count++;\\n            }\\n        }\\n        return count;\\n}}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788773,
                "title": "java-easy-solution-using-set",
                "content": "# Complexity\\n- Time complexity: O(N * N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int n = nums.length;\\n        int ans[] = new int[n];\\n        Set<Integer> prefix = new HashSet<>();\\n        for(int i = 0; i < n; i ++) {\\n            prefix.add(nums[i]);\\n\\n            Set<Integer> suffix = new HashSet<>();\\n            for(int j = i + 1; j < n; j ++)\\n               suffix.add(nums[j]);\\n\\n            ans[i] = prefix.size() - suffix.size();\\n        }\\n        return ans;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int n = nums.length;\\n        int ans[] = new int[n];\\n        Set<Integer> prefix = new HashSet<>();\\n        for(int i = 0; i < n; i ++) {\\n            prefix.add(nums[i]);\\n\\n            Set<Integer> suffix = new HashSet<>();\\n            for(int j = i + 1; j < n; j ++)\\n               suffix.add(nums[j]);\\n\\n            ans[i] = prefix.size() - suffix.size();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497052,
                "title": "100-fast-c-unordered-map-well-explained",
                "content": "# Intuition\\nWe need to find the difference between the number of distinct elements in the suffix of an element and the number of distinct elements in its prefix. We can achieve this by using two hash maps, one to keep track of the prefix and another to keep track of the suffix.\\n\\n- We can start by creating an empty hash map m1 to keep track of the prefix. We can iterate through the array and add each element to m1, incrementing its count.\\n\\n- We can then create another empty hash map m2 to keep track of the suffix. We can iterate through the array again, adding each element to m2, incrementing its count, and calculating the difference between the size of m2 and m1.\\n\\n- To get the difference in the number of distinct elements, we can subtract the size of m1 from the size of m2.\\n\\n- After calculating the difference, we can push it into a result vector v.\\n\\n- To update m1 for the next element, we can decrement the count of the current element in m1 and remove it from m1 if its count becomes zero.\\n\\n- Finally, we can return the result vector v.\\n\\nOverall, the approach involves using hash maps to keep track of the prefix and suffix and iterating through the array twice to calculate the difference between the number of distinct elements in the prefix and suffix of each element.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe problem asks to find the distinct difference array of the given array, which can be solved using two pointers approach and hash maps.\\n\\n1. We first create two hash maps, m1, and m2. Here m1 will be used to keep track of the elements in the suffix and m2 will be used to keep track of the elements in the prefix.\\n\\n2. Then we loop through the array from left to right and for each element, we add it to the m2 map and remove it from the m1 map.\\n\\n3. After adding the current element to the m2 map, we calculate the difference in the size of m2 and m1 maps. This gives us the number of distinct elements in the prefix and the number of distinct elements in the suffix.\\n\\n4. We store this difference value in the resultant array, which gives us the distinct difference array of the given array.\\n\\n5. We continue this process for each element of the array and return the resultant array.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- **Time complexity**: As we are iterating through the array only once and performing constant time operations for each element.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity**: As we are using two hash maps to store the elements, the space required will be linear in terms of the size of the input array.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        unordered_map<int,int> m1;\\n        for(int i=0;i<nums.size();i++)\\n            m1[nums[i]]++;\\n        unordered_map<int,int> m2;\\n        vector<int> v;\\n        for(int i=0;i<nums.size();i++){\\n            m2[nums[i]]++;\\n            m1[nums[i]]--;\\n            if(m1[nums[i]]==0)\\n                m1.erase(nums[i]);\\n            int diff=m2.size()-m1.size();\\n            v.push_back(diff);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        unordered_map<int,int> m1;\\n        for(int i=0;i<nums.size();i++)\\n            m1[nums[i]]++;\\n        unordered_map<int,int> m2;\\n        vector<int> v;\\n        for(int i=0;i<nums.size();i++){\\n            m2[nums[i]]++;\\n            m1[nums[i]]--;\\n            if(m1[nums[i]]==0)\\n                m1.erase(nums[i]);\\n            int diff=m2.size()-m1.size();\\n            v.push_back(diff);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495320,
                "title": "c-best-solution-set-prefix-suffix-easy-to-understand",
                "content": ">\\n\\n# Complexity\\n- Time complexity: $$O(n logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(4n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        set<int> suffSet, prefSet;\\n        vector<int> suff(nums.size()), pref(nums.size()), ans(nums.size());\\n        \\n        for(int i=0; i<nums.size(); i++)   \\n            suffSet.insert(nums[i]), suff[i] = suffSet.size();\\n        \\n        for(int i=nums.size() - 1; i>=0; i--)   \\n            pref[i] = prefSet.size(), prefSet.insert(nums[i]);\\n        \\n        for(int i=0; i<nums.size(); i++)    ans[i] = suff[i] - pref[i];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Suffix Array",
                    "Prefix Sum",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        set<int> suffSet, prefSet;\\n        vector<int> suff(nums.size()), pref(nums.size()), ans(nums.size());\\n        \\n        for(int i=0; i<nums.size(); i++)   \\n            suffSet.insert(nums[i]), suff[i] = suffSet.size();\\n        \\n        for(int i=nums.size() - 1; i>=0; i--)   \\n            pref[i] = prefSet.size(), prefSet.insert(nums[i]);\\n        \\n        for(int i=0; i<nums.size(); i++)    ans[i] = suff[i] - pref[i];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495158,
                "title": "best-simple-java-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int n = nums.length;\\n        HashMap<Integer,Integer> map1 = new HashMap<>();\\n        HashMap<Integer,Integer> map2 = new HashMap<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            map2.put(nums[i],map2.getOrDefault(nums[i],0)+1);\\n        }\\n        int[] diff = new int[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            map2.put(nums[i],map2.get(nums[i])-1);\\n            if(map2.get(nums[i])==0) map2.remove(nums[i]);\\n            map1.put(nums[i],map1.getOrDefault(nums[i],0)+1);\\n            diff[i] = map1.size()-map2.size();\\n        }\\n        return diff;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int n = nums.length;\\n        HashMap<Integer,Integer> map1 = new HashMap<>();\\n        HashMap<Integer,Integer> map2 = new HashMap<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            map2.put(nums[i],map2.getOrDefault(nums[i],0)+1);\\n        }\\n        int[] diff = new int[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            map2.put(nums[i],map2.get(nums[i])-1);\\n            if(map2.get(nums[i])==0) map2.remove(nums[i]);\\n            map1.put(nums[i],map1.getOrDefault(nums[i],0)+1);\\n            diff[i] = map1.size()-map2.size();\\n        }\\n        return diff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495101,
                "title": "c-hashset",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\npublic class Solution \\n{\\n    public int[] DistinctDifferenceArray(int[] nums) \\n    {\\n        int n = nums.Length;\\n        int[] result = new int[n];\\n        HashSet<int> distinctElements = new HashSet<int>();\\n\\n        distinctElements.Add(nums[n-1]);\\n        for (int i = n - 2; i >= 0; i--)\\n        {\\n            result[i] = -distinctElements.Count;\\n            distinctElements.Add(nums[i]);\\n        }\\n\\n        distinctElements.Clear();\\n\\n        for (int i = 0; i <= n - 1; i++)\\n        {\\n            distinctElements.Add(nums[i]);\\n            result[i] += distinctElements.Count;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int[] DistinctDifferenceArray(int[] nums) \\n    {\\n        int n = nums.Length;\\n        int[] result = new int[n];\\n        HashSet<int> distinctElements = new HashSet<int>();\\n\\n        distinctElements.Add(nums[n-1]);\\n        for (int i = n - 2; i >= 0; i--)\\n        {\\n            result[i] = -distinctElements.Count;\\n            distinctElements.Add(nums[i]);\\n        }\\n\\n        distinctElements.Clear();\\n\\n        for (int i = 0; i <= n - 1; i++)\\n        {\\n            distinctElements.Add(nums[i]);\\n            result[i] += distinctElements.Count;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494977,
                "title": "brute-force-simple",
                "content": "\\n\\n# Approach\\nBrute Force using Sets \\nCheck size of pre stack and post stack for each index of nums.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>ans(n);\\n        set<int>preSet;\\n        set<int>postSet;\\n        \\n        for(int i=0;i<n;i++){\\n            preSet.clear();\\n            postSet.clear();\\n            for(int j=0;j<=i;j++){\\n               preSet.insert(nums[j]);\\n            }\\n            for(int k=i+1;k<n;k++){\\n                postSet.insert(nums[k]);\\n            }\\n             ans[i]=preSet.size()-postSet.size();\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease Upvote.",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>ans(n);\\n        set<int>preSet;\\n        set<int>postSet;\\n        \\n        for(int i=0;i<n;i++){\\n            preSet.clear();\\n            postSet.clear();\\n            for(int j=0;j<=i;j++){\\n               preSet.insert(nums[j]);\\n            }\\n            for(int k=i+1;k<n;k++){\\n                postSet.insert(nums[k]);\\n            }\\n             ans[i]=preSet.size()-postSet.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494957,
                "title": "c-o-n-prefix-suffix-and-set",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        unordered_set<int> s1, s2;\\n        vector<int> pre, suf(nums.size());\\n        int count = 0;\\n        // prefix array\\n        for(auto i : nums) {\\n            if(s1.find(i) == s1.end()) count++;\\n            pre.push_back(count);\\n            s1.insert(i);\\n        }\\n        // suffix array\\n        count = 0;\\n        for(int i = nums.size()-1; i > 0; i--) {\\n            if(s2.find(nums[i]) == s2.end()) count++;\\n            suf[i - 1] = count;\\n            s2.insert(nums[i]);\\n        }\\n        // ans;\\n        for(int i = 0; i < nums.size(); i++) {\\n            pre[i] = pre[i] - suf[i];\\n        }\\n        return pre;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        unordered_set<int> s1, s2;\\n        vector<int> pre, suf(nums.size());\\n        int count = 0;\\n        // prefix array\\n        for(auto i : nums) {\\n            if(s1.find(i) == s1.end()) count++;\\n            pre.push_back(count);\\n            s1.insert(i);\\n        }\\n        // suffix array\\n        count = 0;\\n        for(int i = nums.size()-1; i > 0; i--) {\\n            if(s2.find(nums[i]) == s2.end()) count++;\\n            suf[i - 1] = count;\\n            s2.insert(nums[i]);\\n        }\\n        // ans;\\n        for(int i = 0; i < nums.size(); i++) {\\n            pre[i] = pre[i] - suf[i];\\n        }\\n        return pre;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494872,
                "title": "simple-clean-java-solution",
                "content": "\\n```java []\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        Set<Integer> pre = new HashSet();\\n        int res[] = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            pre.add(nums[i]);\\n            Set<Integer> suf = new HashSet();\\n            for(int j=i+1; j<nums.length; j++)  suf.add(nums[j]);\\n            res[i] = pre.size()-suf.size();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        Set<Integer> pre = new HashSet();\\n        int res[] = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            pre.add(nums[i]);\\n            Set<Integer> suf = new HashSet();\\n            for(int j=i+1; j<nums.length; j++)  suf.add(nums[j]);\\n            res[i] = pre.size()-suf.size();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537410,
                "title": "simple-java-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int diff[] = new int[nums.length];\\n        for(int i = 0; i < nums.length; i++) {\\n            Set<Integer> prefixSet = new HashSet();\\n            Set<Integer> suffixSet = new HashSet();\\n            for(int j = 0; j < nums.length; j++) {\\n                if(j <= i) {\\n                    prefixSet.add(nums[j]);\\n                }\\n                if(j > i) {\\n                    suffixSet.add(nums[j]);\\n                }\\n            }\\n            diff[i] = prefixSet.size() - suffixSet.size();\\n        }\\n        return diff;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int diff[] = new int[nums.length];\\n        for(int i = 0; i < nums.length; i++) {\\n            Set<Integer> prefixSet = new HashSet();\\n            Set<Integer> suffixSet = new HashSet();\\n            for(int j = 0; j < nums.length; j++) {\\n                if(j <= i) {\\n                    prefixSet.add(nums[j]);\\n                }\\n                if(j > i) {\\n                    suffixSet.add(nums[j]);\\n                }\\n            }\\n            diff[i] = prefixSet.size() - suffixSet.size();\\n        }\\n        return diff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496884,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        n=len(nums)\\n        left=0\\n        right=n-1\\n        ans=[]\\n        while left<n:\\n            ans.append(len(set(nums[0:left+1]))-len(set(nums[left+1:right+1])))\\n            right+=1\\n            left+=1\\n\\n        return ans    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        n=len(nums)\\n        left=0\\n        right=n-1\\n        ans=[]\\n        while left<n:\\n            ans.append(len(set(nums[0:left+1]))-len(set(nums[left+1:right+1])))\\n            right+=1\\n            left+=1\\n\\n        return ans    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495220,
                "title": "javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar distinctDifferenceArray = function(nums) {\\n    const n = nums.length;\\n    const diff = new Array(n).fill(0);\\n    \\n    for (let i = 0; i < n; i++) {\\n            const prefix = new Set();\\n            const suffix = new Set();\\n        \\n            prefix.add(nums[0]);        \\n            for (let j = 1; j <= i; j++) {\\n             if (!prefix.has(nums[j])) prefix.add(nums[j]);\\n             }\\n        \\n            for (let j = i+1; j < n; j++) {\\n             if(!suffix.has(nums[j])) suffix.add(nums[j]);\\n             }\\n                \\n        const prefixSize = prefix.size;\\n        const suffixSize = suffix.size;\\n\\n        diff[i] = prefixSize - suffixSize;\\n    }\\n\\n    return diff;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar distinctDifferenceArray = function(nums) {\\n    const n = nums.length;\\n    const diff = new Array(n).fill(0);\\n    \\n    for (let i = 0; i < n; i++) {\\n            const prefix = new Set();\\n            const suffix = new Set();\\n        \\n            prefix.add(nums[0]);        \\n            for (let j = 1; j <= i; j++) {\\n             if (!prefix.has(nums[j])) prefix.add(nums[j]);\\n             }\\n        \\n            for (let j = i+1; j < n; j++) {\\n             if(!suffix.has(nums[j])) suffix.add(nums[j]);\\n             }\\n                \\n        const prefixSize = prefix.size;\\n        const suffixSize = suffix.size;\\n\\n        diff[i] = prefixSize - suffixSize;\\n    }\\n\\n    return diff;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495125,
                "title": "java-simple-approach-using-hashset-for-unique-difference",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n.define array for storing value after find difference \\nint [] diff = new int[n];\\n. find prefix \\n.find suffix\\n.find prefix.size()-suffix.size();\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n                int n = nums.length;\\n        int[] diff = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            Set<Integer> prefix = new HashSet<>();\\n            for (int j = 0; j <= i; j++) {\\n                prefix.add(nums[j]);\\n            }\\n\\n            Set<Integer> suffix = new HashSet<>();\\n            for (int j = i + 1; j < n; j++) {\\n                suffix.add(nums[j]);\\n            }\\n\\n            diff[i] = prefix.size() - suffix.size();\\n        }\\n\\n        return diff;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n                int n = nums.length;\\n        int[] diff = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            Set<Integer> prefix = new HashSet<>();\\n            for (int j = 0; j <= i; j++) {\\n                prefix.add(nums[j]);\\n            }\\n\\n            Set<Integer> suffix = new HashSet<>();\\n            for (int j = i + 1; j < n; j++) {\\n                suffix.add(nums[j]);\\n            }\\n\\n            diff[i] = prefix.size() - suffix.size();\\n        }\\n\\n        return diff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495022,
                "title": "easy-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> cnt1(n,0),cnt2(n,0);\\n        vector<int> ans(n,0);\\n        unordered_map<int,int> x,y;\\n        for(int i=0;i<n;i++){\\n            x[nums[i]]=1;\\n            y[nums[n-i-1]]=1;\\n            cnt1[i]=x.size();\\n            cnt2[n-i-1]=y.size();\\n        }\\n        for(int i=0;i<n-1;i++){\\n            ans[i]=cnt1[i]-cnt2[i+1];\\n        }\\n        ans[n-1]=cnt1[n-1];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> cnt1(n,0),cnt2(n,0);\\n        vector<int> ans(n,0);\\n        unordered_map<int,int> x,y;\\n        for(int i=0;i<n;i++){\\n            x[nums[i]]=1;\\n            y[nums[n-i-1]]=1;\\n            cnt1[i]=x.size();\\n            cnt2[n-i-1]=y.size();\\n        }\\n        for(int i=0;i<n-1;i++){\\n            ans[i]=cnt1[i]-cnt2[i+1];\\n        }\\n        ans[n-1]=cnt1[n-1];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494955,
                "title": "c-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        vector<int>arr(nums.size());\\n        int index;\\n        set<int>set;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            int left=0;\\n            int right =0;\\n            for(int j=0;j<=i;j++){\\n                set.insert(nums[j]);\\n        }\\n            left =set.size();\\n            set.clear();\\n            \\n            for(int k= i+1;k<nums.size();k++){\\n                set.insert(nums[k]);\\n        }\\n            right  =set.size();\\n            set.clear();\\n            arr[index++]= left -right;\\n    }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        vector<int>arr(nums.size());\\n        int index;\\n        set<int>set;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            int left=0;\\n            int right =0;\\n            for(int j=0;j<=i;j++){\\n                set.insert(nums[j]);\\n        }\\n            left =set.size();\\n            set.clear();\\n            \\n            for(int k= i+1;k<nums.size();k++){\\n                set.insert(nums[k]);\\n        }\\n            right  =set.size();\\n            set.clear();\\n            arr[index++]= left -right;\\n    }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494886,
                "title": "go-use-two-map",
                "content": "# Complexity\\n- Time complexity: $$O(2n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nfunc distinctDifferenceArray(nums []int) []int {\\n\\tn := len(nums)\\n\\tres := make([]int, n)\\n\\tm1, m2 := make(map[int]int), make(map[int]int)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tm2[nums[i]]++\\n\\t}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tm1[nums[i]]++\\n\\t\\tm2[nums[i]]--\\n\\t\\tif m2[nums[i]] == 0 {\\n\\t\\t\\tdelete(m2, nums[i])\\n\\t\\t}\\n\\t\\tres[i] = len(m1) - len(m2)\\n\\t}\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc distinctDifferenceArray(nums []int) []int {\\n\\tn := len(nums)\\n\\tres := make([]int, n)\\n\\tm1, m2 := make(map[int]int), make(map[int]int)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tm2[nums[i]]++\\n\\t}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tm1[nums[i]]++\\n\\t\\tm2[nums[i]]--\\n\\t\\tif m2[nums[i]] == 0 {\\n\\t\\t\\tdelete(m2, nums[i])\\n\\t\\t}\\n\\t\\tres[i] = len(m1) - len(m2)\\n\\t}\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4049310,
                "title": "c-o-n-using-map-set-very-simple-easy",
                "content": "**Idea :** \\n1. To count distinct element from front, we are using a set data structure simply and inserting the elements into it during the traversal. In this case, st.size() is the required prefix value.\\n\\n2. To count distinct elements from back, we are using a map. In the map we have already stored the counts of the elements. We have taken a variable \"cnt\" which basically stores the count of distinct values in the array. \\n\\n3. During the traversal, we decrement the element\\'s frequency in the map and whenever this frequency of any element = 0, we can infer that a distinct element which used to exist earlier has now been gone i.e. it does not exist in the right -> so we decrement cnt (cnt--)\\n\\n4. So during each iteration, we get this st.size() and cnt to calculate the required difference as (st.size()-cnt).\\n\\n```\\n vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        vector<int>ans;\\n        unordered_map<int,int>mp;\\n        \\n        int cnt = 0; // cnt distinct from back\\n        for(auto i : nums){\\n            mp[i]++;\\n        }\\n        \\n        for(auto it : mp){\\n            if(it.second>0){cnt++;}\\n        }\\n        \\n        unordered_set<int>st;  // cnt distinct from start\\n        \\n        for(auto i : nums){\\n            st.insert(i);\\n            mp[i]--;\\n            if(mp[i]==0){cnt--;}\\n            \\n            ans.push_back(st.size()-cnt);\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\nTime : O(N)\\nSpace : O(N)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\n vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        vector<int>ans;\\n        unordered_map<int,int>mp;\\n        \\n        int cnt = 0; // cnt distinct from back\\n        for(auto i : nums){\\n            mp[i]++;\\n        }\\n        \\n        for(auto it : mp){\\n            if(it.second>0){cnt++;}\\n        }\\n        \\n        unordered_set<int>st;  // cnt distinct from start\\n        \\n        for(auto i : nums){\\n            st.insert(i);\\n            mp[i]--;\\n            if(mp[i]==0){cnt--;}\\n            \\n            ans.push_back(st.size()-cnt);\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3957510,
                "title": "prefix-sum-algorithm-without-unnecessary-actions-and-iterations",
                "content": "```\\nvar distinctDifferenceArray = function(nums) {\\n    const set = new Set()\\n    const res = []\\n    \\n    for (let num of nums) {\\n        set.add(num)\\n        res.push(set.size)\\n    }\\n    \\n    set.clear()\\n    \\n    for (let i = nums.length - 1; i >= 0; i--) {\\n        res[i] = res[i] - set.size\\n        set.add(nums[i])\\n    }\\n    \\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar distinctDifferenceArray = function(nums) {\\n    const set = new Set()\\n    const res = []\\n    \\n    for (let num of nums) {\\n        set.add(num)\\n        res.push(set.size)\\n    }\\n    \\n    set.clear()\\n    \\n    for (let i = nums.length - 1; i >= 0; i--) {\\n        res[i] = res[i] - set.size\\n        set.add(nums[i])\\n    }\\n    \\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3674642,
                "title": "java-using-hashset-sc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nArrays using HashSet as we had a special property in HashSet that it won\\'t store any element twice.\\n\\n# Approach\\nCreate a 2 new arrays one to have prefix unique elements and another for suffiix and subract values as per repuirement \\nHere - prefix[i] - suffix[i+1]\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        HashSet<Integer> hs = new HashSet<Integer>();\\n        int i, len = nums.length;\\n        int[] prefix = new int[len];\\n        int[] suffix = new int[len];\\n        for(i=0;i<len;i++){\\n            hs.add(nums[i]);\\n            prefix[i] = hs.size();\\n        }\\n        hs.clear();\\n        for(i=len-1;i>=0;i--){\\n            hs.add(nums[i]);\\n            suffix[i] = hs.size();\\n        }\\n        for(i=0;i<len-1;i++){\\n            nums[i] = prefix[i] - suffix[i+1];\\n        }\\n        nums[len-1] =  prefix[len-1];\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        HashSet<Integer> hs = new HashSet<Integer>();\\n        int i, len = nums.length;\\n        int[] prefix = new int[len];\\n        int[] suffix = new int[len];\\n        for(i=0;i<len;i++){\\n            hs.add(nums[i]);\\n            prefix[i] = hs.size();\\n        }\\n        hs.clear();\\n        for(i=len-1;i>=0;i--){\\n            hs.add(nums[i]);\\n            suffix[i] = hs.size();\\n        }\\n        for(i=0;i<len-1;i++){\\n            nums[i] = prefix[i] - suffix[i+1];\\n        }\\n        nums[len-1] =  prefix[len-1];\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661035,
                "title": "simple-set-solution-c-easy-to-understand-using-pre-count-and-post-count",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     vector<int> distinctDifferenceArray(vector<int>& nums) {\\n         int n = nums.size();\\n         int i = 0;  \\n         vector<int> ans;\\n\\n         while(i<n){\\n             int postcount = 0;\\n             int precount = 0;\\n             set<int> count;\\n             for(int j=i+1;j<n;j++){\\n                 count.insert(nums[j]);\\n             }\\n             postcount = count.size();\\n             count.clear();\\n            \\n             for(int j=0;j<=i;j++){\\n                 count.insert(nums[j]);\\n             }\\n             precount = count.size();\\n             count.clear();\\n\\n             ans.push_back((precount - postcount));\\n             i++;\\n\\n         }\\n\\n         return ans;\\n     }\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     vector<int> distinctDifferenceArray(vector<int>& nums) {\\n         int n = nums.size();\\n         int i = 0;  \\n         vector<int> ans;\\n\\n         while(i<n){\\n             int postcount = 0;\\n             int precount = 0;\\n             set<int> count;\\n             for(int j=i+1;j<n;j++){\\n                 count.insert(nums[j]);\\n             }\\n             postcount = count.size();\\n             count.clear();\\n            \\n             for(int j=0;j<=i;j++){\\n                 count.insert(nums[j]);\\n             }\\n             precount = count.size();\\n             count.clear();\\n\\n             ans.push_back((precount - postcount));\\n             i++;\\n\\n         }\\n\\n         return ans;\\n     }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640133,
                "title": "python-hash-map",
                "content": "# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        pre={nums[0]:1}\\n        suf={}\\n        res=[]\\n        for j in range(1,len(nums)):\\n            if nums[j] in suf:\\n                suf[nums[j]]+=1\\n            else:\\n                suf[nums[j]]=1\\n        for i in range(len(nums)-1):\\n            res.append(len(pre)-len(suf))\\n            if nums[i+1] in pre:\\n                pre[nums[i+1]]+=1\\n            else:\\n                pre[nums[i+1]]=1\\n            suf[nums[i+1]]-=1\\n            if suf[nums[i+1]]==0:\\n                suf.pop(nums[i+1])\\n        res.append(len(pre)-len(suf))\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        pre={nums[0]:1}\\n        suf={}\\n        res=[]\\n        for j in range(1,len(nums)):\\n            if nums[j] in suf:\\n                suf[nums[j]]+=1\\n            else:\\n                suf[nums[j]]=1\\n        for i in range(len(nums)-1):\\n            res.append(len(pre)-len(suf))\\n            if nums[i+1] in pre:\\n                pre[nums[i+1]]+=1\\n            else:\\n                pre[nums[i+1]]=1\\n            suf[nums[i+1]]-=1\\n            if suf[nums[i+1]]==0:\\n                suf.pop(nums[i+1])\\n        res.append(len(pre)-len(suf))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3637902,
                "title": "short-c-code-single-iteration",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse unordered_set to know count of unique element in a running iteration.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nus1 will give unqiue element count for the prefix part and us2 will give unique element count for suffix part. Since, in answer we want prefix-suffix, prefix part\\'s count is added and suffix\\'s count is subtracted. The reason of subtracting before inserting to us2 is because suffix part starts from i+1.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        int n =  nums.size();\\n        vector<int> ans(n,0);\\n        unordered_set<int> us1,us2;\\n        for(int i = 0; i < n; i++){\\n            us1.insert(nums[i]);\\n            ans[n-i-1] -= us2.size();\\n            us2.insert(nums[n-i-1]);\\n            ans[i] += us1.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        int n =  nums.size();\\n        vector<int> ans(n,0);\\n        unordered_set<int> us1,us2;\\n        for(int i = 0; i < n; i++){\\n            us1.insert(nums[i]);\\n            ans[n-i-1] -= us2.size();\\n            us2.insert(nums[n-i-1]);\\n            ans[i] += us1.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537385,
                "title": "simple-java-solution-for-beginners-using-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int diff[] = new int[nums.length];\\n        Set<Integer> prefixSet = new HashSet();\\n        Set<Integer> suffixSet = new HashSet();\\n        for(int i = 0; i < nums.length; i++) {\\n            prefixSet.clear();\\n            suffixSet.clear();\\n            for(int j = 0; j < nums.length; j++) {\\n                if(j <= i) {\\n                    if(!prefixSet.contains(nums[j])) {\\n                        prefixSet.add(nums[j]);\\n                    }\\n                }\\n                if(j > i) {\\n                    if(!suffixSet.contains(nums[j])) {\\n                        suffixSet.add(nums[j]);\\n                    }\\n                }\\n            }\\n            diff[i] = prefixSet.size() - suffixSet.size();\\n        }\\n        return diff;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int diff[] = new int[nums.length];\\n        Set<Integer> prefixSet = new HashSet();\\n        Set<Integer> suffixSet = new HashSet();\\n        for(int i = 0; i < nums.length; i++) {\\n            prefixSet.clear();\\n            suffixSet.clear();\\n            for(int j = 0; j < nums.length; j++) {\\n                if(j <= i) {\\n                    if(!prefixSet.contains(nums[j])) {\\n                        prefixSet.add(nums[j]);\\n                    }\\n                }\\n                if(j > i) {\\n                    if(!suffixSet.contains(nums[j])) {\\n                        suffixSet.add(nums[j]);\\n                    }\\n                }\\n            }\\n            diff[i] = prefixSet.size() - suffixSet.size();\\n        }\\n        return diff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516323,
                "title": "easy-to-understand-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        ans = []\\n        for i in range(len(nums)):\\n            ans.append(len(set(nums[:i+1]))-len(set(nums[i+1:])))\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        ans = []\\n        for i in range(len(nums)):\\n            ans.append(len(set(nums[:i+1]))-len(set(nums[i+1:])))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511746,
                "title": "find-the-distinct-difference-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        res =[]\\n        for num in range(len(nums)):\\n            prefix_num = len(set(nums[:num+1]))\\n            suffix_num = len(set(nums[num+1:]))\\n            res.append(prefix_num - suffix_num)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        res =[]\\n        for num in range(len(nums)):\\n            prefix_num = len(set(nums[:num+1]))\\n            suffix_num = len(set(nums[num+1:]))\\n            res.append(prefix_num - suffix_num)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509571,
                "title": "linear-time-complexity-simple-and-easy-approach-with-explanation",
                "content": "# Intuition\\nUsing map as suffix and set as prefix.\\n\\n# Approach\\nUsing the map as suffix and the set as prefix\\nwhile we are traversing we put the current element in the prefix and then we see if there are more than one instance of that element exists then we will leave it in the prefix as well as suffix (or in the map and the set) if there was only one copy of that element was in the array then we remove it from the map (or the suffix ) and add into the prefix (set) and push the difference of their size in the ans vector.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        unordered_map<int,int>mp; // first we stored all the elements in the map \\n\\n        for(auto it:nums){\\n             mp[it]++;\\n        }\\n        set<int>st; // we used a set to store the prefix values\\n        vector<int>ans;\\n        for(auto it:nums){\\n           st.insert(it); // we inserted it into the set\\n           mp[it]--; // decremented the count of that element from the map used as suffix\\n           if(mp[it]==0) mp.erase(it); // if there was only one element then we delete it from suffix and the return the size of diff of prefix-suffix that is set-map and if there was more than one value of that element was present then it will exist in both pre and suffix \\n           ans.push_back(st.size()-mp.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        unordered_map<int,int>mp; // first we stored all the elements in the map \\n\\n        for(auto it:nums){\\n             mp[it]++;\\n        }\\n        set<int>st; // we used a set to store the prefix values\\n        vector<int>ans;\\n        for(auto it:nums){\\n           st.insert(it); // we inserted it into the set\\n           mp[it]--; // decremented the count of that element from the map used as suffix\\n           if(mp[it]==0) mp.erase(it); // if there was only one element then we delete it from suffix and the return the size of diff of prefix-suffix that is set-map and if there was more than one value of that element was present then it will exist in both pre and suffix \\n           ans.push_back(st.size()-mp.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502007,
                "title": "we-can-just-use-unordered-set",
                "content": "```\\nvector<int> distinctDifferenceArray(vector<int>& nums) \\n    {\\n        unordered_set<int>st ;\\n        int n = nums.size() ;\\n        vector<int>pre(n+1 , 0) , diff(n);\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            int sz1 = st.size() ;\\n            st.insert(nums[i]) ;\\n            int sz2 = st.size() ;\\n            if(sz1 != sz2)\\n            {\\n                pre[i+1] = pre[i]+1;\\n            }\\n            else\\n            {\\n                pre[i+1] = pre[i];\\n            }\\n        }\\n        \\n        unordered_set<int>st2 ;\\n        vector<int> suf(n+1 , 0) ;\\n        for(int i = n-1 ; i >= 0 ; i--)\\n        {\\n            int sz1 = st2.size() ;\\n            st2.insert(nums[i]) ;\\n            int sz2 = st2.size() ;\\n            if(sz1 != sz2)\\n            {\\n                suf[i] = suf[i+1]+1;\\n            }\\n            else\\n            {\\n                suf[i] = suf[i+1];\\n            }\\n        }\\n        \\n        for(auto it : pre)\\n        {\\n            cout << it << \" \" ;\\n        }\\n        cout << endl;\\n        for(auto it : suf)\\n        {\\n            cout << it << \" \" ;\\n        }\\n        int tt = st.size() ;\\n        \\n        for(int i = 1 ; i <= n ; i++)\\n        {\\n            diff[i-1] = pre[i] - suf[i] ;\\n        }\\n        \\n        return diff ;\\n        \\n        \\n    }\\n```\\n\\nwe can just make two vectors for prefix and suffix by checking if size of a set is changing or not .\\nOn subtracting prefix - suffix diffrence array will be created . \\n",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nvector<int> distinctDifferenceArray(vector<int>& nums) \\n    {\\n        unordered_set<int>st ;\\n        int n = nums.size() ;\\n        vector<int>pre(n+1 , 0) , diff(n);\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            int sz1 = st.size() ;\\n            st.insert(nums[i]) ;\\n            int sz2 = st.size() ;\\n            if(sz1 != sz2)\\n            {\\n                pre[i+1] = pre[i]+1;\\n            }\\n            else\\n            {\\n                pre[i+1] = pre[i];\\n            }\\n        }\\n        \\n        unordered_set<int>st2 ;\\n        vector<int> suf(n+1 , 0) ;\\n        for(int i = n-1 ; i >= 0 ; i--)\\n        {\\n            int sz1 = st2.size() ;\\n            st2.insert(nums[i]) ;\\n            int sz2 = st2.size() ;\\n            if(sz1 != sz2)\\n            {\\n                suf[i] = suf[i+1]+1;\\n            }\\n            else\\n            {\\n                suf[i] = suf[i+1];\\n            }\\n        }\\n        \\n        for(auto it : pre)\\n        {\\n            cout << it << \" \" ;\\n        }\\n        cout << endl;\\n        for(auto it : suf)\\n        {\\n            cout << it << \" \" ;\\n        }\\n        int tt = st.size() ;\\n        \\n        for(int i = 1 ; i <= n ; i++)\\n        {\\n            diff[i-1] = pre[i] - suf[i] ;\\n        }\\n        \\n        return diff ;\\n        \\n        \\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3501138,
                "title": "rust-solution-using-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing a hashset to iterate backward to calculate the negation part and to iterate forward to calculate positive part separately.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn distinct_difference_array(nums: Vec<i32>) -> Vec<i32> {\\n        let mut s = HashSet::new();\\n        let n = nums.len();\\n        let mut ret = vec![0; n]; \\n\\n        for i in (1 .. n).rev() {\\n            s.insert(nums[i]);\\n            ret[i - 1] -= s.len() as i32;\\n        }\\n\\n        s.clear();\\n        for i in 0 .. n {\\n            s.insert(nums[i]);\\n            ret[i] += s.len() as i32;\\n        }\\n\\n        ret\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn distinct_difference_array(nums: Vec<i32>) -> Vec<i32> {\\n        let mut s = HashSet::new();\\n        let n = nums.len();\\n        let mut ret = vec![0; n]; \\n\\n        for i in (1 .. n).rev() {\\n            s.insert(nums[i]);\\n            ret[i - 1] -= s.len() as i32;\\n        }\\n\\n        s.clear();\\n        for i in 0 .. n {\\n            s.insert(nums[i]);\\n            ret[i] += s.len() as i32;\\n        }\\n\\n        ret\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3499529,
                "title": "c-solution-using-unordered-maps-100-efficient",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        unordered_map<int,int> before,after;\\n        vector<int> ans;\\n        //first put every element in the after map..\\n        for(int i=0;i<nums.size();i++){\\n            after[nums[i]]++;\\n        }\\n        //now remove ith nums from the after map and add it in the before map then calculte the diff and put it in the vector named ans;\\n        for(int i=0;i<nums.size();i++){\\n            after[nums[i]]--;\\n            before[nums[i]]++;\\n            //if frequency of nums[i] in after map is 0 then remove it so we don\\'t count it in the calculation..\\n            if(after[nums[i]]==0)\\n               after.erase(nums[i]);\\n             ans.push_back(before.size()-after.size());  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        unordered_map<int,int> before,after;\\n        vector<int> ans;\\n        //first put every element in the after map..\\n        for(int i=0;i<nums.size();i++){\\n            after[nums[i]]++;\\n        }\\n        //now remove ith nums from the after map and add it in the before map then calculte the diff and put it in the vector named ans;\\n        for(int i=0;i<nums.size();i++){\\n            after[nums[i]]--;\\n            before[nums[i]]++;\\n            //if frequency of nums[i] in after map is 0 then remove it so we don\\'t count it in the calculation..\\n            if(after[nums[i]]==0)\\n               after.erase(nums[i]);\\n             ans.push_back(before.size()-after.size());  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497699,
                "title": "find-the-distinct-difference-array-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks to find the difference between the count of distinct numbers in the array before and after a certain index. One way to solve this problem is to iterate through the array and for each index, count the number of distinct elements in the subarray before that index and the number of distinct elements in the subarray after that index. Then, calculate the difference and store it in the answer array.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use two sets, pre and suf, to keep track of the distinct elements in the subarray before and after the current index, respectively. We iterate through the array, and for each index i, we insert all elements from index 0 to i in the pre set and all elements from index i+1 to n-1 in the suf set. We then calculate the difference between the sizes of the two sets, which gives us the number of distinct elements before and after the current index. We store this difference in the answer array and clear the sets before moving on to the next index.set\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity: O(n^2), where n is the size of the input array. This is because for each index, we insert all elements from index 0 to i in the pre set and all elements from index i+1 to n-1 in the suf set, which takes O(n) time. Since we do this for every index, the time complexity becomes O(n^2).\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n), where n is the size of the input array. This is because we are using two sets of size at most n to store the distinct elements before and after each index. The answer array also has size n.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        set<int>pre;\\n        vector<int>ans;\\n        set<int>suf;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++) pre.insert(nums[j]);\\n            for(int k=i+1;k<n;k++) suf.insert(nums[k]);\\n        int x=pre.size();\\n            int y=suf.size();\\n            ans.push_back(x-y);\\n              pre.clear();\\n            suf.clear();\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        set<int>pre;\\n        vector<int>ans;\\n        set<int>suf;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++) pre.insert(nums[j]);\\n            for(int k=i+1;k<n;k++) suf.insert(nums[k]);\\n        int x=pre.size();\\n            int y=suf.size();\\n            ans.push_back(x-y);\\n              pre.clear();\\n            suf.clear();\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497518,
                "title": "python3-code",
                "content": "# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        res = []\\n        for i in range(len(nums)):\\n            res.append(len(set(nums[:i+1])) - len(set(nums[i + 1:])))\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        res = []\\n        for i in range(len(nums)):\\n            res.append(len(set(nums[:i+1])) - len(set(nums[i + 1:])))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496549,
                "title": "java-easy-solution-using-hashmap",
                "content": "# Intuition \\nThe brute fore method i have used but it can be optimised using hashset in a single loop.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int n = nums.length;\\n        HashMap<Integer,Integer> prefix = new HashMap<>();\\n        HashMap<Integer,Integer> suffix = new HashMap<>();\\n        int[] ans = new int[nums.length];\\n        int[] prearr = new int[nums.length];\\n        int[] suffarr = new int[nums.length];\\n\\n        int k =0;\\n        int x = 0;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j =0; j<=i; j++){\\n                if(!prefix.containsKey(nums[j])){\\n                    prefix.put(nums[j],1);\\n                }\\n            }\\n            int pref_val = prefix.size();\\n            k++;\\n\\n            // System.out.println( prefix.size() + \" prefix\");\\n            \\n            int count = 0;\\n            for(int j = i+1; j<n; j++){\\n                \\n                if(!suffix.containsKey(nums[j])){\\n                    suffix.put(nums[j],1);\\n                }\\n                \\n            }\\n            int suff_val = suffix.size();\\n            suffix.clear();\\n\\n            ans[i] = pref_val - suff_val;\\n            \\n            System.out.println(suff_val);\\n        }\\n        \\n        \\n       \\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Two Pointers",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int n = nums.length;\\n        HashMap<Integer,Integer> prefix = new HashMap<>();\\n        HashMap<Integer,Integer> suffix = new HashMap<>();\\n        int[] ans = new int[nums.length];\\n        int[] prearr = new int[nums.length];\\n        int[] suffarr = new int[nums.length];\\n\\n        int k =0;\\n        int x = 0;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j =0; j<=i; j++){\\n                if(!prefix.containsKey(nums[j])){\\n                    prefix.put(nums[j],1);\\n                }\\n            }\\n            int pref_val = prefix.size();\\n            k++;\\n\\n            // System.out.println( prefix.size() + \" prefix\");\\n            \\n            int count = 0;\\n            for(int j = i+1; j<n; j++){\\n                \\n                if(!suffix.containsKey(nums[j])){\\n                    suffix.put(nums[j],1);\\n                }\\n                \\n            }\\n            int suff_val = suffix.size();\\n            suffix.clear();\\n\\n            ans[i] = pref_val - suff_val;\\n            \\n            System.out.println(suff_val);\\n        }\\n        \\n        \\n       \\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495879,
                "title": "hashset-java-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int n=nums.length;\\n        int ans[]=new int[n];\\n        \\n        for(int i=0;i<n;i++){\\n            Set<Integer>set1=new HashSet<>();\\n            Set<Integer>set2=new HashSet<>();\\n            \\n            for(int j=0;j<=i;j++){\\n                set1.add(nums[j]);\\n            }\\n            for(int j=i+1;j<n;j++){\\n                set2.add(nums[j]);\\n            }\\n            \\n            ans[i]= set1.size() - set2.size();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int n=nums.length;\\n        int ans[]=new int[n];\\n        \\n        for(int i=0;i<n;i++){\\n            Set<Integer>set1=new HashSet<>();\\n            Set<Integer>set2=new HashSet<>();\\n            \\n            for(int j=0;j<=i;j++){\\n                set1.add(nums[j]);\\n            }\\n            for(int j=i+1;j<n;j++){\\n                set2.add(nums[j]);\\n            }\\n            \\n            ans[i]= set1.size() - set2.size();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495856,
                "title": "python3-one-line",
                "content": "First of all, I remembered this problem [Find the Prefix Common Array of Two Arrays](https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/) and the approach used to solve it ([[Python3] One line](https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/discuss/3467605/python3-one-line)), but instead of crossing, you need to take the difference between the left and right parts.\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        return [len(set(nums[:i + 1])) - len(set(nums[i + 1:])) for i in range(len(nums))]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        return [len(set(nums[:i + 1])) - len(set(nums[i + 1:])) for i in range(len(nums))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495389,
                "title": "c-hashing",
                "content": "# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        map<int,int> pref,suff;\\n        int n= nums.size();\\n        vector<int> ans;\\n        for (int i=0; i<n; i++)suff[nums[i]]++;\\n        for (int i=0; i<n; i++){\\n            suff[nums[i]]--;\\n            pref[nums[i]]++;\\n            if (suff[nums[i]]==0)suff.erase(nums[i]);\\n            ans.push_back(pref.size()-suff.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Ordered Map",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        map<int,int> pref,suff;\\n        int n= nums.size();\\n        vector<int> ans;\\n        for (int i=0; i<n; i++)suff[nums[i]]++;\\n        for (int i=0; i<n; i++){\\n            suff[nums[i]]--;\\n            pref[nums[i]]++;\\n            if (suff[nums[i]]==0)suff.erase(nums[i]);\\n            ans.push_back(pref.size()-suff.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495292,
                "title": "java-easy-to-understand-for-beginners",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int n = nums.length;\\n        int[] res = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            HashSet<Integer> hs = new HashSet<>();\\n            for (int j = 0; j <= i; j++) {\\n                hs.add(nums[j]);\\n            }\\n            HashSet<Integer> js = new HashSet<>();\\n            for (int j = i + 1; j < n; j++) {\\n                js.add(nums[j]);\\n            }\\n            res[i] = hs.size()-js.size();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Map",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int n = nums.length;\\n        int[] res = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            HashSet<Integer> hs = new HashSet<>();\\n            for (int j = 0; j <= i; j++) {\\n                hs.add(nums[j]);\\n            }\\n            HashSet<Integer> js = new HashSet<>();\\n            for (int j = i + 1; j < n; j++) {\\n                js.add(nums[j]);\\n            }\\n            res[i] = hs.size()-js.size();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495223,
                "title": "easy-to-understand-typescript-solution",
                "content": "# Code\\n```\\nfunction distinctDifferenceArray(nums: number[]): number[] {\\n    let diffs = new Array(nums.length);\\n\\n    for(let i=0; i<nums.length; i++){\\n        for(let i=0; i<nums.length; i++){\\n        let prefix = new Set( nums.slice(0, i + 1));\\n        let suffix = new Set( nums.slice(i+1, nums.length+1));\\n        diffs[i] = prefix.size - suffix.size;\\n    }\\n\\n    return diffs;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction distinctDifferenceArray(nums: number[]): number[] {\\n    let diffs = new Array(nums.length);\\n\\n    for(let i=0; i<nums.length; i++){\\n        for(let i=0; i<nums.length; i++){\\n        let prefix = new Set( nums.slice(0, i + 1));\\n        let suffix = new Set( nums.slice(i+1, nums.length+1));\\n        diffs[i] = prefix.size - suffix.size;\\n    }\\n\\n    return diffs;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495221,
                "title": "brute-force-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMaintaing the prefix and suffix count\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> diff(n);\\n\\n    for (int i = 0; i < n; i++) {\\n        unordered_set<int> prefix, suffix;\\n        int prefix_size = 0, suffix_size = 0;\\n\\n        // Compute the size of the prefix set\\n        for (int j = 0; j <= i; j++) {\\n            if (!prefix.count(nums[j])) {\\n                prefix.insert(nums[j]);\\n                prefix_size++;\\n            }\\n        }\\n\\n        // Compute the size of the suffix set\\n        for (int j = i + 1; j < n; j++) {\\n            if (!suffix.count(nums[j])) {\\n                suffix.insert(nums[j]);\\n                suffix_size++;\\n            }\\n        }\\n        diff[i] = prefix_size - suffix_size;\\n\\n    }\\n\\n     return diff;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> diff(n);\\n\\n    for (int i = 0; i < n; i++) {\\n        unordered_set<int> prefix, suffix;\\n        int prefix_size = 0, suffix_size = 0;\\n\\n        // Compute the size of the prefix set\\n        for (int j = 0; j <= i; j++) {\\n            if (!prefix.count(nums[j])) {\\n                prefix.insert(nums[j]);\\n                prefix_size++;\\n            }\\n        }\\n\\n        // Compute the size of the suffix set\\n        for (int j = i + 1; j < n; j++) {\\n            if (!suffix.count(nums[j])) {\\n                suffix.insert(nums[j]);\\n                suffix_size++;\\n            }\\n        }\\n        diff[i] = prefix_size - suffix_size;\\n\\n    }\\n\\n     return diff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495120,
                "title": "beats-100-simple-solution-c",
                "content": "![image.png](https://assets.leetcode.com/users/images/05ae6c6d-aa6e-40cb-b02e-e45724468ee0_1683433085.243885.png)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nhere we use the technique of the hashmap \\n-whether the elements are unique or not \\n-by putting them into hashmap \\nand counting the distinct elements\\n# Complexity\\n- Time complexity:$O(n^2)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int check(vector<int>& arr,int pos)\\n    {\\n        int hash1[51]={0};\\n        int hash2[51]={0};\\n        int first=pos;\\n        int leftdistinct=0,rightdistinct=0;\\n        int last=pos+1;\\n        while(first>=0)\\n        {\\n            if(hash1[arr[first]]==0)\\n            {hash1[arr[first]]=arr[first];\\n                leftdistinct++;\\n            }\\n            first--;\\n        }\\n        while(last<arr.size())\\n        {\\n            if(hash2[arr[last]]==0)\\n            {hash2[arr[last]]=arr[last];\\n                rightdistinct++;\\n            }\\n            last++;\\n        }\\n        return leftdistinct-rightdistinct;\\n    }\\n    vector<int> distinctDifferenceArray(vector<int>& nums) \\n    {\\n        vector<int>ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans.push_back(check(nums,i));\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n![e5cc6438-63d7-47fb-84d1-e4e36cf43c6e_1683003574.1370602.png](https://assets.leetcode.com/users/images/ec82e2cc-b1ea-4e5b-889c-8e6d692fab9d_1683433036.901454.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int check(vector<int>& arr,int pos)\\n    {\\n        int hash1[51]={0};\\n        int hash2[51]={0};\\n        int first=pos;\\n        int leftdistinct=0,rightdistinct=0;\\n        int last=pos+1;\\n        while(first>=0)\\n        {\\n            if(hash1[arr[first]]==0)\\n            {hash1[arr[first]]=arr[first];\\n                leftdistinct++;\\n            }\\n            first--;\\n        }\\n        while(last<arr.size())\\n        {\\n            if(hash2[arr[last]]==0)\\n            {hash2[arr[last]]=arr[last];\\n                rightdistinct++;\\n            }\\n            last++;\\n        }\\n        return leftdistinct-rightdistinct;\\n    }\\n    vector<int> distinctDifferenceArray(vector<int>& nums) \\n    {\\n        vector<int>ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans.push_back(check(nums,i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495051,
                "title": "easy-brute-force-and-optimized-solution-map-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute Force is pretty staright forward, Optimal solution can be solved using variation of sliding Window\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis is the implementation of the function `distinctDifferenceArray`, which takes a vector of integers `v` as input and returns another vector `ans`. The purpose of this function is to calculate the distinct difference array of the input vector.\\n\\nThe distinct difference array of a vector `v` is another vector `ans` such that `ans[i]` is the number of distinct values in the subvector `v[0:i]` of `v` after taking the differences of adjacent elements.\\n\\nThe function first initializes two maps `m1` and `m2` to keep track of the frequency of each element in the subvector `v[0:i]` and `v[i+1:n-1]` respectively. It then loops through the input vector `v` and updates the maps `m1` and `m2` accordingly.\\n\\nFor each element `v[i]`, the function increments the frequency of `v[i]` in `m1` and removes it from `m2` if its frequency becomes zero. It then calculates the difference in size between `m1` and `m2`, which represents the number of distinct values in the subvector `v[0:i]` after taking the differences of adjacent elements. This value is appended to the `ans` vector.\\n\\nFinally, the function returns the `ans` vector.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Brute Force Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& v) {\\n        int n=v.size();\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            set<int>s1,s2;\\n            for(int j=0;j<=i;j++)\\n                s1.insert(v[j]);\\n            for(int j=i+1;j<n;j++)\\n                s2.insert(v[j]);\\n            ans.push_back(s1.size()-s2.size());\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n#Optimal Code using MAP\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& v) {\\n        int n=v.size();\\n        map<int,int>m1,m2;\\n        for(auto i:v)\\n            m2[i]++;\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            m2[v[i]]--;\\n            if(m2[v[i]]==0)\\n                m2.erase(v[i]);\\n            m1[v[i]]++;\\n            ans.push_back(m1.size()-m2.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& v) {\\n        int n=v.size();\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            set<int>s1,s2;\\n            for(int j=0;j<=i;j++)\\n                s1.insert(v[j]);\\n            for(int j=i+1;j<n;j++)\\n                s2.insert(v[j]);\\n            ans.push_back(s1.size()-s2.size());\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& v) {\\n        int n=v.size();\\n        map<int,int>m1,m2;\\n        for(auto i:v)\\n            m2[i]++;\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            m2[v[i]]--;\\n            if(m2[v[i]]==0)\\n                m2.erase(v[i]);\\n            m1[v[i]]++;\\n            ans.push_back(m1.size()-m2.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494978,
                "title": "c-maps-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        map<int, int>m1, m2;\\n        vector<int>ans;\\n        for(int i=0; i<nums.size(); i++){m1[nums[i]]++;}\\n        for(int i=0; i<nums.size(); i++){\\n            m2[nums[i]]++;\\n            m1[nums[i]]--;\\n            if(m1[nums[i]]==0){\\n                m1.erase(nums[i]);\\n            }\\n            ans.push_back(m2.size()-m1.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        map<int, int>m1, m2;\\n        vector<int>ans;\\n        for(int i=0; i<nums.size(); i++){m1[nums[i]]++;}\\n        for(int i=0; i<nums.size(); i++){\\n            m2[nums[i]]++;\\n            m1[nums[i]]--;\\n            if(m1[nums[i]]==0){\\n                m1.erase(nums[i]);\\n            }\\n            ans.push_back(m2.size()-m1.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494958,
                "title": "c-solution-100-beat-using-set",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        int n=nums.size();\\n        set<int>left;\\n        vector<int>prefix(n);\\n        for(int i=0;i<n;i++){\\n            left.insert(nums[i]);\\n            prefix[i]=left.size();\\n        }\\n        set<int>right;\\n        vector<int>sufix(n);\\n        for(int i=n-1;i>=0;i--){\\n            sufix[i]=right.size();\\n            right.insert(nums[i]);\\n        }\\n        vector<int>ans(n);\\n        for(int i=0;i<n;i++){\\n            ans[i]=prefix[i]-sufix[i];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        int n=nums.size();\\n        set<int>left;\\n        vector<int>prefix(n);\\n        for(int i=0;i<n;i++){\\n            left.insert(nums[i]);\\n            prefix[i]=left.size();\\n        }\\n        set<int>right;\\n        vector<int>sufix(n);\\n        for(int i=n-1;i>=0;i--){\\n            sufix[i]=right.size();\\n            right.insert(nums[i]);\\n        }\\n        vector<int>ans(n);\\n        for(int i=0;i<n;i++){\\n            ans[i]=prefix[i]-sufix[i];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494918,
                "title": "easy-java-solution-using-hashset-but-18-ms",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int n=nums.length;\\n        int[] d=new int[n];\\n        for (int i = 0; i < n; i++) {\\n            Set<Integer> pre=new HashSet<>();\\n            for (int j = 0; j <= i; j++) {\\n                pre.add(nums[j]);\\n            }\\n            Set<Integer> suf=new HashSet<>();\\n            for (int j = i + 1; j < n; j++) {\\n                suf.add(nums[j]);\\n            }\\n            d[i]=pre.size()-suf.size();\\n        }\\n        return d;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int n=nums.length;\\n        int[] d=new int[n];\\n        for (int i = 0; i < n; i++) {\\n            Set<Integer> pre=new HashSet<>();\\n            for (int j = 0; j <= i; j++) {\\n                pre.add(nums[j]);\\n            }\\n            Set<Integer> suf=new HashSet<>();\\n            for (int j = i + 1; j < n; j++) {\\n                suf.add(nums[j]);\\n            }\\n            d[i]=pre.size()-suf.size();\\n        }\\n        return d;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494903,
                "title": "java-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        int index = 0;\\n        Set<Integer> set = new HashSet<>();\\n        for(int i = 0; i < nums.length; i++) {\\n            int left = 0;\\n            int right = 0;\\n            for(int j = 0; j <= i; j++) {\\n                set.add(nums[j]);\\n            }\\n            left = set.size();\\n            set.clear();\\n            \\n            for(int k = i+1; k < nums.length; k++) {\\n                set.add(nums[k]);\\n            }\\n            right = set.size();\\n            set.clear();\\n            arr[index++] = left - right; \\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        int index = 0;\\n        Set<Integer> set = new HashSet<>();\\n        for(int i = 0; i < nums.length; i++) {\\n            int left = 0;\\n            int right = 0;\\n            for(int j = 0; j <= i; j++) {\\n                set.add(nums[j]);\\n            }\\n            left = set.size();\\n            set.clear();\\n            \\n            for(int k = i+1; k < nums.length; k++) {\\n                set.add(nums[k]);\\n            }\\n            right = set.size();\\n            set.clear();\\n            arr[index++] = left - right; \\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494901,
                "title": "easiest-simple-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        int n = nums.size();\\n    vector<int> diff(n);\\n\\n    for (int i = 0; i < n; i++) {\\n        int prefixDistinct = 0;\\n        int suffixDistinct = 0;\\n\\n        vector<bool> prefixSeen(n, false);\\n        vector<bool> suffixSeen(n, false);\\n\\n        for (int j = 0; j <= i; j++) {\\n            if (!prefixSeen[nums[j]]) {\\n                prefixDistinct++;\\n                prefixSeen[nums[j]] = true;\\n            }\\n        }\\n\\n        for (int j = n - 1; j > i; j--) {\\n            if (!suffixSeen[nums[j]]) {\\n                suffixDistinct++;\\n                suffixSeen[nums[j]] = true;\\n            }\\n        }\\n\\n        diff[i] = prefixDistinct - suffixDistinct;\\n    }\\n\\n    return diff;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        int n = nums.size();\\n    vector<int> diff(n);\\n\\n    for (int i = 0; i < n; i++) {\\n        int prefixDistinct = 0;\\n        int suffixDistinct = 0;\\n\\n        vector<bool> prefixSeen(n, false);\\n        vector<bool> suffixSeen(n, false);\\n\\n        for (int j = 0; j <= i; j++) {\\n            if (!prefixSeen[nums[j]]) {\\n                prefixDistinct++;\\n                prefixSeen[nums[j]] = true;\\n            }\\n        }\\n\\n        for (int j = n - 1; j > i; j--) {\\n            if (!suffixSeen[nums[j]]) {\\n                suffixDistinct++;\\n                suffixSeen[nums[j]] = true;\\n            }\\n        }\\n\\n        diff[i] = prefixDistinct - suffixDistinct;\\n    }\\n\\n    return diff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494882,
                "title": "c-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        unordered_set<int> st;\\n        vector<int> pre;\\n        for(auto i : nums){\\n            st.insert(i);\\n            pre.push_back(st.size());\\n        }\\n        st.clear();\\n        vector<int> suff;\\n        suff.push_back(0);\\n        for(int i=nums.size()-1;i>=0;i--){\\n            st.insert(nums[i]);\\n            suff.push_back(st.size());\\n        }\\n        reverse(suff.begin(),suff.end());\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++){\\n            ans.push_back(pre[i]-suff[i+1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        unordered_set<int> st;\\n        vector<int> pre;\\n        for(auto i : nums){\\n            st.insert(i);\\n            pre.push_back(st.size());\\n        }\\n        st.clear();\\n        vector<int> suff;\\n        suff.push_back(0);\\n        for(int i=nums.size()-1;i>=0;i--){\\n            st.insert(nums[i]);\\n            suff.push_back(st.size());\\n        }\\n        reverse(suff.begin(),suff.end());\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++){\\n            ans.push_back(pre[i]-suff[i+1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494850,
                "title": "c-solution-with-linq",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    public int[] DistinctDifferenceArray(int[] nums)\\n    {\\n        var n = nums.Length;\\n        var result = new int[n];\\n        \\n        for (var i = 0; i < n; i++)\\n            result[i] = nums[..(i + 1)].Distinct().Count() - nums[(i + 1)..].Distinct().Count();\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int[] DistinctDifferenceArray(int[] nums)\\n    {\\n        var n = nums.Length;\\n        var result = new int[n];\\n        \\n        for (var i = 0; i < n; i++)\\n            result[i] = nums[..(i + 1)].Distinct().Count() - nums[(i + 1)..].Distinct().Count();\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4095752,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> v(n,0);\\n        set<int> st;\\n\\n        \\n        for(int i=0;i<nums.size();i++){\\n            st.insert(nums[i]);\\n            v[i]=st.size();\\n        }\\n        st.clear();\\n        for(int i=n-2;i>=0;i--){\\n            st.insert(nums[i+1]);\\n            v[i]=v[i]-st.size();\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> v(n,0);\\n        set<int> st;\\n\\n        \\n        for(int i=0;i<nums.size();i++){\\n            st.insert(nums[i]);\\n            v[i]=st.size();\\n        }\\n        st.clear();\\n        for(int i=n-2;i>=0;i--){\\n            st.insert(nums[i+1]);\\n            v[i]=v[i]-st.size();\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4095164,
                "title": "simple-c-solution",
                "content": "# Intuition\\nThe code aims to calculate the difference in the count of distinct elements between the left and right subarrays for each position in the input array `nums`. This difference is then stored in the `answer` vector.\\n\\n# Approach\\nThe approach involves iterating through the input array `nums` and, for each position `i`, calculating the count of distinct elements in the left subarray (from index 0 to i) and the count of distinct elements in the right subarray (from index i+1 to the end). The difference in these counts is then appended to the `answer` vector.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$, where n is the length of the input array `nums`. This is because, for each element in `nums`, we calculate the difference in distinct elements between the left and right subarrays, which involves traversing these subarrays.\\n  \\n- Space complexity: $$O(n)$$, where n is the length of the input array `nums`. We use two unordered sets, `left` and `right`, to store distinct elements in the left and right subarrays, respectively.\\n\\n# Code Explanation\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        vector<int> answer;  // Initialize a vector to store the differences in distinct elements\\n        \\n        for(int i = 0; i < nums.size(); i++) {\\n            // Create an unordered set for distinct elements in the left subarray (from 0 to i)\\n            unordered_set<int> left(nums.begin(), nums.begin() + i + 1);\\n            \\n            // Create an unordered set for distinct elements in the right subarray (from i+1 to end)\\n            unordered_set<int> right(nums.begin() + i + 1, nums.end());\\n            \\n            // Calculate the difference in the counts of distinct elements between left and right subarrays\\n            answer.push_back(left.size() - right.size());\\n        }\\n        \\n        return answer;  // Return the vector containing differences in distinct elements\\n    }\\n};\\n```\\n\\nThe code defines a `Solution` class with a method `distinctDifferenceArray` that takes a vector `nums` as input. The function iterates over the elements of the input array, calculating the difference in distinct elements between the left and right subarrays for each position. The differences are stored in a vector, which is then returned.",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        vector<int> answer;  // Initialize a vector to store the differences in distinct elements\\n        \\n        for(int i = 0; i < nums.size(); i++) {\\n            // Create an unordered set for distinct elements in the left subarray (from 0 to i)\\n            unordered_set<int> left(nums.begin(), nums.begin() + i + 1);\\n            \\n            // Create an unordered set for distinct elements in the right subarray (from i+1 to end)\\n            unordered_set<int> right(nums.begin() + i + 1, nums.end());\\n            \\n            // Calculate the difference in the counts of distinct elements between left and right subarrays\\n            answer.push_back(left.size() - right.size());\\n        }\\n        \\n        return answer;  // Return the vector containing differences in distinct elements\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4094872,
                "title": "one-line-solution-using-list-comprehensions-and-sets",
                "content": "# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        return [len(set(nums[:i+1])) - len(set(nums[i+1:])) for i in range(len(nums))]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        return [len(set(nums[:i+1])) - len(set(nums[i+1:])) for i in range(len(nums))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066857,
                "title": "easy-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int n[]=new int[nums.length];\\n        int p=0;\\n        for(int i=0;i<nums.length;i++){\\n            Set<Integer> s=new HashSet();\\n            for(int j=i+1;j<nums.length;j++){\\n               s.add(nums[j]);\\n            }\\n            Set<Integer> s1=new HashSet<>();\\n            for(int k=0;k<=i;k++){\\n                s1.add(nums[k]);\\n            }\\n            n[p++]=s1.size()-s.size();\\n            s.clear();\\n            s1.clear();\\n        }\\n        return n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int n[]=new int[nums.length];\\n        int p=0;\\n        for(int i=0;i<nums.length;i++){\\n            Set<Integer> s=new HashSet();\\n            for(int j=i+1;j<nums.length;j++){\\n               s.add(nums[j]);\\n            }\\n            Set<Integer> s1=new HashSet<>();\\n            for(int k=0;k<=i;k++){\\n                s1.add(nums[k]);\\n            }\\n            n[p++]=s1.size()-s.size();\\n            s.clear();\\n            s1.clear();\\n        }\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056390,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        res = []\\n\\n        l = 0\\n\\n        while l < len(nums):\\n            pre = len(set(nums[:l+1]))\\n            post = len(set(nums[l+1:]))\\n            res.append(pre-post)\\n            l += 1\\n\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        res = []\\n\\n        l = 0\\n\\n        while l < len(nums):\\n            pre = len(set(nums[:l+1]))\\n            post = len(set(nums[l+1:]))\\n            res.append(pre-post)\\n            l += 1\\n\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054783,
                "title": "optimized-code-using-unordered-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Firstly, an unordered set called  st  is declared to store distinct elements from the input vector. \\n2.  A vector called  left  is created with the same size as the input vector, initialized with zeros. This vector will store the result. \\n3. The code then iterates through the input vector from left to right using a for loop. In each iteration, it performs the following steps: \\n   - Inserts the current element  nums[i]  into the unordered set  st . \\n   - Updates the corresponding element in the  left  vector with the current size of the set  st  using the  size()  function. \\n4. The unordered set  st  is cleared to prepare for the next iteration. \\n5. The code then enters another for loop that iterates through the input vector from right to left, starting from the second-to-last element. In each iteration, it performs the following steps: \\n   - Inserts the next element  nums[i + 1]  into the unordered set  st . \\n   - Updates the corresponding element in the  left  vector by subtracting the current size of the set  st  from the previous value in the  left  vector. \\n6. Finally, the  left  vector, which now contains the desired result, is returned from the function. \\n![image_2023-09-17_130516022.png](https://assets.leetcode.com/users/images/745f3f78-eb7c-49b9-9315-41b28f2606b3_1694936121.7739694.png)\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        unordered_set<int> st;\\n        int n = nums.size();\\n        vector<int> left(n, 0);\\n\\n        for (int i = 0; i < n; ++i)\\n        {\\n            st.insert(nums[i]);\\n            left[i] = st.size();\\n        }\\n\\n        st.clear();\\n\\n        for (int i = n - 2; i >= 0; --i)\\n        {\\n            st.insert(nums[i + 1]);\\n            left[i] = left[i] - st.size();\\n        }\\n\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        unordered_set<int> st;\\n        int n = nums.size();\\n        vector<int> left(n, 0);\\n\\n        for (int i = 0; i < n; ++i)\\n        {\\n            st.insert(nums[i]);\\n            left[i] = st.size();\\n        }\\n\\n        st.clear();\\n\\n        for (int i = n - 2; i >= 0; --i)\\n        {\\n            st.insert(nums[i + 1]);\\n            left[i] = left[i] - st.size();\\n        }\\n\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046903,
                "title": "easy-python-solution-python",
                "content": "# EASY PYTHON SOLUTION || PYTHON || \\u270C\\u270C\\n\\n# Runtime\\n- 102ms\\n- Beats 75.00%of users with Python3\\n# Memory\\n- 16.24MB\\n- Beats 77.50%of users with Python3\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        \\n        res = []\\n        for i in range(0,len(nums)):\\n            lset = set(nums[0:i+1])\\n            rset = set(nums[i+1:])\\n            #print(\"left\",len(lset),\\'right\\',len(rset))\\n            res.append(len(lset)-len(rset))\\n        \\n        return (res)\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        \\n        res = []\\n        for i in range(0,len(nums)):\\n            lset = set(nums[0:i+1])\\n            rset = set(nums[i+1:])\\n            #print(\"left\",len(lset),\\'right\\',len(rset))\\n            res.append(len(lset)-len(rset))\\n        \\n        return (res)\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039599,
                "title": "java-simple-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int[] res = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            Set prefixSet = new HashSet();\\n            for (int j = 0; j <= i; j++) {\\n                prefixSet.add(nums[j]);\\n            }\\n            Set suffixSet = new HashSet();\\n            for (int j = nums.length - 1; j > i; j--) {\\n                suffixSet.add(nums[j]);\\n            }\\n            res[i] = prefixSet.size() - suffixSet.size();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int[] res = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            Set prefixSet = new HashSet();\\n            for (int j = 0; j <= i; j++) {\\n                prefixSet.add(nums[j]);\\n            }\\n            Set suffixSet = new HashSet();\\n            for (int j = nums.length - 1; j > i; j--) {\\n                suffixSet.add(nums[j]);\\n            }\\n            res[i] = prefixSet.size() - suffixSet.size();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032011,
                "title": "java-solve-using-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int ans[] = new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            Set<Integer>set1 = new HashSet();\\n            Set<Integer>set2 = new HashSet();\\n\\n            for(int j=0; j<=i; j++){\\n                set1.add(nums[j]);\\n            }\\n\\n            for(int j=i+1; j<nums.length; j++){\\n                set2.add(nums[j]);\\n            }\\n            ans[i] = set1.size()-set2.size();\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int ans[] = new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            Set<Integer>set1 = new HashSet();\\n            Set<Integer>set2 = new HashSet();\\n\\n            for(int j=0; j<=i; j++){\\n                set1.add(nums[j]);\\n            }\\n\\n            for(int j=i+1; j<nums.length; j++){\\n                set2.add(nums[j]);\\n            }\\n            ans[i] = set1.size()-set2.size();\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024655,
                "title": "java-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int[] res = new int[nums.length];\\n\\n        for(int i = 0; i<nums.length; i++){\\n        HashSet<Integer> lset = new HashSet<>();\\n        HashSet<Integer> rset = new HashSet<>();\\n            for(int j = 0; j<nums.length; j++){\\n                if(j <= i){\\n                    lset.add(nums[j]);\\n                }else{\\n                    rset.add(nums[j]);\\n                }\\n                \\n            }\\n            res[i] = lset.size() - rset.size();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int[] res = new int[nums.length];\\n\\n        for(int i = 0; i<nums.length; i++){\\n        HashSet<Integer> lset = new HashSet<>();\\n        HashSet<Integer> rset = new HashSet<>();\\n            for(int j = 0; j<nums.length; j++){\\n                if(j <= i){\\n                    lset.add(nums[j]);\\n                }else{\\n                    rset.add(nums[j]);\\n                }\\n                \\n            }\\n            res[i] = lset.size() - rset.size();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009569,
                "title": "java-solution-array-manipulation-using-boolean-flag-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n\\n        int prefix = 0;\\n        int result[] = new int[nums.length];\\n\\n        boolean flag[] = new boolean[51];\\n        for(int i = 0; i < nums.length; i++){\\n\\n            prefix = 0;\\n\\n            for(int j = 0; j <= i; j++){\\n                if(!flag[nums[j]]){\\n                    prefix++;\\n                    flag[nums[j]] = true;\\n                }\\n            }\\n\\n            Arrays.fill(flag, false);\\n\\n            for(int j = i + 1; j < nums.length; j++){\\n                if(!flag[nums[j]]){\\n                    prefix--;\\n                    flag[nums[j]] = true;\\n                }\\n            }\\n\\n            Arrays.fill(flag, false);\\n\\n            result[i] = prefix;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n\\n        int prefix = 0;\\n        int result[] = new int[nums.length];\\n\\n        boolean flag[] = new boolean[51];\\n        for(int i = 0; i < nums.length; i++){\\n\\n            prefix = 0;\\n\\n            for(int j = 0; j <= i; j++){\\n                if(!flag[nums[j]]){\\n                    prefix++;\\n                    flag[nums[j]] = true;\\n                }\\n            }\\n\\n            Arrays.fill(flag, false);\\n\\n            for(int j = i + 1; j < nums.length; j++){\\n                if(!flag[nums[j]]){\\n                    prefix--;\\n                    flag[nums[j]] = true;\\n                }\\n            }\\n\\n            Arrays.fill(flag, false);\\n\\n            result[i] = prefix;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998616,
                "title": "96-beats-solution-using-set-in-java",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int n = nums.length;\\n        int[] prefix = new int[n];\\n        Set temp = new HashSet<>();\\n        int[] suffix = new int[n];\\n        for(int i = 0; i<nums.length; i++){\\n            temp.add(nums[i]);\\n            prefix[i] = temp.size();\\n        }\\n\\n        temp = new HashSet<>();\\n        temp.add(nums[n-1]);\\n        for(int i = n-2; i>=0; i--){\\n            suffix[i] = temp.size();\\n            temp.add(nums[i]);\\n        }\\n\\n\\n\\n        for(int i = 0; i<nums.length; i++){\\n            prefix[i]-=suffix[i];\\n        }\\n\\n        return prefix;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int n = nums.length;\\n        int[] prefix = new int[n];\\n        Set temp = new HashSet<>();\\n        int[] suffix = new int[n];\\n        for(int i = 0; i<nums.length; i++){\\n            temp.add(nums[i]);\\n            prefix[i] = temp.size();\\n        }\\n\\n        temp = new HashSet<>();\\n        temp.add(nums[n-1]);\\n        for(int i = n-2; i>=0; i--){\\n            suffix[i] = temp.size();\\n            temp.add(nums[i]);\\n        }\\n\\n\\n\\n        for(int i = 0; i<nums.length; i++){\\n            prefix[i]-=suffix[i];\\n        }\\n\\n        return prefix;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994949,
                "title": "elixir-using-set-map",
                "content": "```\\ndefmodule Solution do\\n  @spec distinct_difference_array(nums :: [integer]) :: [integer]\\n  def distinct_difference_array(nums) do\\n    mp = nums |> Enum.reduce(%{}, fn n, acc -> Map.update(acc, n, 1, &(&1 + 1)) end)\\n\\n    nums\\n    |> Enum.reduce({[], %MapSet{}, mp}, fn n, {acc, st, mp} ->\\n      mp = delete(mp, n)\\n      st = MapSet.put(st, n)\\n      acc = [MapSet.size(st) - map_size(mp) | acc]\\n      {acc, st, mp}\\n    end)\\n    |> elem(0)\\n    |> Enum.reverse()\\n  end\\n\\n  defp delete(mp, k) do\\n    mp = Map.update!(mp, k, &(&1 -1))\\n\\n    if mp[k] == 0 do\\n      Map.delete(mp, k)\\n    else\\n      mp\\n    end\\n  end\\nend\\n\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec distinct_difference_array(nums :: [integer]) :: [integer]\\n  def distinct_difference_array(nums) do\\n    mp = nums |> Enum.reduce(%{}, fn n, acc -> Map.update(acc, n, 1, &(&1 + 1)) end)\\n\\n    nums\\n    |> Enum.reduce({[], %MapSet{}, mp}, fn n, {acc, st, mp} ->\\n      mp = delete(mp, n)\\n      st = MapSet.put(st, n)\\n      acc = [MapSet.size(st) - map_size(mp) | acc]\\n      {acc, st, mp}\\n    end)\\n    |> elem(0)\\n    |> Enum.reverse()\\n  end\\n\\n  defp delete(mp, k) do\\n    mp = Map.update!(mp, k, &(&1 -1))\\n\\n    if mp[k] == 0 do\\n      Map.delete(mp, k)\\n    else\\n      mp\\n    end\\n  end\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3993750,
                "title": "98-beat-c-hash",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n      unordered_map<int,int>l;\\n      unordered_map<int,int>f;\\n      for(int h=0; h<nums.size(); h++){\\n          l[nums[h]]++;\\n      }\\n      vector<int>d;\\n      for(int h=0; h<nums.size(); h++){\\n          f[nums[h]]++;\\n          l[nums[h]]--;\\n          if (l[nums[h]]==0)l.erase(nums[h]);\\n          d.push_back(f.size()-l.size());\\n          \\n      }\\n      return d;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n      unordered_map<int,int>l;\\n      unordered_map<int,int>f;\\n      for(int h=0; h<nums.size(); h++){\\n          l[nums[h]]++;\\n      }\\n      vector<int>d;\\n      for(int h=0; h<nums.size(); h++){\\n          f[nums[h]]++;\\n          l[nums[h]]--;\\n          if (l[nums[h]]==0)l.erase(nums[h]);\\n          d.push_back(f.size()-l.size());\\n          \\n      }\\n      return d;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988009,
                "title": "simple-java",
                "content": "Please Upvote\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int diff[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            HashSet<Integer> set=new HashSet<>();\\n            HashSet<Integer> set1=new HashSet<>();\\n            for(int j=0;j<=i;j++){\\n               set.add(nums[j]);\\n            }\\n            for(int k=i+1;k<nums.length;k++){\\n               set1.add(nums[k]);\\n            }\\n            diff[i]=set.size()-set1.size();\\n        }\\n    return diff;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int diff[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            HashSet<Integer> set=new HashSet<>();\\n            HashSet<Integer> set1=new HashSet<>();\\n            for(int j=0;j<=i;j++){\\n               set.add(nums[j]);\\n            }\\n            for(int k=i+1;k<nums.length;k++){\\n               set1.add(nums[k]);\\n            }\\n            diff[i]=set.size()-set1.size();\\n        }\\n    return diff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984941,
                "title": "very-simple-elixir-solution-beats-100-of-no-doubt-numerous-elixir-programmers-out-there",
                "content": "```\\ndefmodule Solution do\\n  @spec distinct_difference_array(nums :: [integer]) :: [integer]\\n  def distinct_difference_array(nums) do\\n\\n    len = length(nums)\\n\\n    for i <- 0..(len - 1) do\\n      # Extract the suffix and prefix\\n      prefix = Enum.slice(nums, 0, i + 1)\\n      suffix = Enum.slice(nums, i + 1, len - i)\\n      # Determine a count of the distinct items in the prefix and suffix\\n      distinct_prefix_len = MapSet.new(prefix) |> MapSet.size()\\n      distinct_suffix_len = MapSet.new(suffix) |> MapSet.size()\\n      # The final line of an Elixir loop is a bit like a yield in Python\\n      # appending the result to some sort of internally generated\\n      # list which is finally returned to the caller.\\n      distinct_prefix_len - distinct_suffix_len\\n\\t  end\\n\\tend\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndefmodule Solution do\\n  @spec distinct_difference_array(nums :: [integer]) :: [integer]\\n  def distinct_difference_array(nums) do\\n\\n    len = length(nums)\\n\\n    for i <- 0..(len - 1) do\\n      # Extract the suffix and prefix\\n      prefix = Enum.slice(nums, 0, i + 1)\\n      suffix = Enum.slice(nums, i + 1, len - i)\\n      # Determine a count of the distinct items in the prefix and suffix\\n      distinct_prefix_len = MapSet.new(prefix) |> MapSet.size()\\n      distinct_suffix_len = MapSet.new(suffix) |> MapSet.size()\\n      # The final line of an Elixir loop is a bit like a yield in Python\\n      # appending the result to some sort of internally generated\\n      # list which is finally returned to the caller.\\n      distinct_prefix_len - distinct_suffix_len\\n\\t  end\\n\\tend\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3984535,
                "title": "simple-solution-for-begineer-only",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nusing hashset\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n       int[] res= new int[nums.length] ;\\n\\n      for(int i=0; i<nums.length ; i++){\\n           HashSet<Integer> h1 = new HashSet<>();\\n            HashSet<Integer> h2 = new HashSet<>();\\n\\n        for(int k=0; k<=i ; k++)\\n         h1.add(nums[k]) ;\\n       \\n      for(int j=i+1 ; j<nums.length && i < nums.length ;j++)\\n         h2.add(nums[j]) ;\\n\\n       res[i] = h1.size()  - h2.size() ;   \\n\\n       } \\n\\n      \\n\\n      return  res ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n       int[] res= new int[nums.length] ;\\n\\n      for(int i=0; i<nums.length ; i++){\\n           HashSet<Integer> h1 = new HashSet<>();\\n            HashSet<Integer> h2 = new HashSet<>();\\n\\n        for(int k=0; k<=i ; k++)\\n         h1.add(nums[k]) ;\\n       \\n      for(int j=i+1 ; j<nums.length && i < nums.length ;j++)\\n         h2.add(nums[j]) ;\\n\\n       res[i] = h1.size()  - h2.size() ;   \\n\\n       } \\n\\n      \\n\\n      return  res ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966250,
                "title": "using-arraylist-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int diff[]=new int[nums.length];\\n        List<Integer> prefix=new ArrayList<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(!prefix.contains(nums[i]))\\n            {\\n                prefix.add(nums[i]);\\n            }\\n           if(i!=nums.length-1)\\n           {\\n           List<Integer> suffix=new ArrayList<>();\\n           for(int j=i+1;j<nums.length;j++)\\n           {\\n               if(!suffix.contains(nums[j]))\\n               {\\n                   suffix.add(nums[j]);\\n               }\\n           }\\n           diff[i]=prefix.size()-suffix.size();\\n           }\\n           else{\\n               diff[i]=prefix.size();\\n           }\\n        }\\n        return diff;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int diff[]=new int[nums.length];\\n        List<Integer> prefix=new ArrayList<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(!prefix.contains(nums[i]))\\n            {\\n                prefix.add(nums[i]);\\n            }\\n           if(i!=nums.length-1)\\n           {\\n           List<Integer> suffix=new ArrayList<>();\\n           for(int j=i+1;j<nums.length;j++)\\n           {\\n               if(!suffix.contains(nums[j]))\\n               {\\n                   suffix.add(nums[j]);\\n               }\\n           }\\n           diff[i]=prefix.size()-suffix.size();\\n           }\\n           else{\\n               diff[i]=prefix.size();\\n           }\\n        }\\n        return diff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961892,
                "title": "amazing-six-liner-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        ans = []\\n\\n        for i in range(len(nums)-1):\\n            len_prefix = len(set(nums[:i+1]))\\n            len_suffix = len(set(nums[i+1:]))\\n            ans.append(len_prefix-len_suffix)\\n\\n        ans.append(len(set(nums)))\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        ans = []\\n\\n        for i in range(len(nums)-1):\\n            len_prefix = len(set(nums[:i+1]))\\n            len_suffix = len(set(nums[i+1:]))\\n            ans.append(len_prefix-len_suffix)\\n\\n        ans.append(len(set(nums)))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960382,
                "title": "find-the-distinct-difference-array",
                "content": "# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        result = []\\n        for i in range(len(nums)):\\n            result.append(len(set(nums[:i+1]))-len(set(nums[i+1:])))\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        result = []\\n        for i in range(len(nums)):\\n            result.append(len(set(nums[:i+1]))-len(set(nums[i+1:])))\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942108,
                "title": "python-easy-for-beginners-beats-98-second-set-approach",
                "content": "# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        prefix = set()\\n        output = []\\n        for i, num in enumerate(nums):\\n            prefix.add(num)\\n            output.append(len(prefix) - len(set(nums[i+1:]))) \\n        return output\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        prefix = set()\\n        output = []\\n        for i, num in enumerate(nums):\\n            prefix.add(num)\\n            output.append(len(prefix) - len(set(nums[i+1:]))) \\n        return output\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941732,
                "title": "with-basics-of-python-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        result=[]\\n        for i in range(0,len(nums)-1):\\n\\n            result.append((len(set(nums[:i+1])))-(len(set(nums[i+1:]))))\\n        result.append(len(set(nums[:len(nums)])))\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        result=[]\\n        for i in range(0,len(nums)-1):\\n\\n            result.append((len(set(nums[:i+1])))-(len(set(nums[i+1:]))))\\n        result.append(len(set(nums[:len(nums)])))\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939732,
                "title": "simplest-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        vector<int>ans;\\n        for(int i=0;i<nums.size();i++){\\n            set<int>prefix;\\n            set<int>suffix;\\n            for(int j=0;j<=i;j++){\\n                prefix.insert(nums[j]);\\n            }\\n            for(int k=i+1;k<nums.size();k++){\\n                suffix.insert(nums[k]);\\n            }\\n        ans.push_back((prefix.size()-suffix.size()));\\n  }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        vector<int>ans;\\n        for(int i=0;i<nums.size();i++){\\n            set<int>prefix;\\n            set<int>suffix;\\n            for(int j=0;j<=i;j++){\\n                prefix.insert(nums[j]);\\n            }\\n            for(int k=i+1;k<nums.size();k++){\\n                suffix.insert(nums[k]);\\n            }\\n        ans.push_back((prefix.size()-suffix.size()));\\n  }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939438,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>pre(n);\\n        vector<int>suf(n);\\n        set<int>s1;\\n        set<int>s2;\\n        for(int i=0;i<n;i++)\\n        {\\n            s1.insert(nums[i]);\\n            pre[i]=s1.size();\\n        }\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            suf[i]=s2.size();\\n            s2.insert(nums[i]);\\n        }\\n        vector<int>ans(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            ans[i]=pre[i]-suf[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>pre(n);\\n        vector<int>suf(n);\\n        set<int>s1;\\n        set<int>s2;\\n        for(int i=0;i<n;i++)\\n        {\\n            s1.insert(nums[i]);\\n            pre[i]=s1.size();\\n        }\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            suf[i]=s2.size();\\n            s2.insert(nums[i]);\\n        }\\n        vector<int>ans(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            ans[i]=pre[i]-suf[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939138,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  List<int> distinctDifferenceArray(List<int> nums) {\\n      final List<int> ans = [];\\n      for (int i = 0; i < nums.length; i++) {\\n          ans.add(distinctDifference(nums.sublist(0, i + 1), nums.sublist(i + 1)));\\n      }\\n\\n      return ans;\\n  }\\n\\n  int distinctDifference(List<int> prefix, List<int> suffix) {\\n      return prefix.toSet().length - suffix.toSet().length;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  List<int> distinctDifferenceArray(List<int> nums) {\\n      final List<int> ans = [];\\n      for (int i = 0; i < nums.length; i++) {\\n          ans.add(distinctDifference(nums.sublist(0, i + 1), nums.sublist(i + 1)));\\n      }\\n\\n      return ans;\\n  }\\n\\n  int distinctDifference(List<int> prefix, List<int> suffix) {\\n      return prefix.toSet().length - suffix.toSet().length;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935905,
                "title": "find-the-distinct-difference-array",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n       int count = 0;  \\n       int count1 = 0;  \\n       int len = nums.length;\\n       \\n       int [] result = new int[len];\\n      \\n      HashSet<Integer> set = new HashSet<>();\\n\\n      for( int i = 0 ; i < len ; i++){\\n          set.add(nums[i]);\\n         \\n         HashSet<Integer> set1 = new HashSet<>();\\n\\n         for( int j = i + 1 ; j < len ; j++)\\n             set1.add(nums[j]);\\n\\n          result[i] = set.size() - set1.size();\\n      }\\n\\n      return result;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n       int count = 0;  \\n       int count1 = 0;  \\n       int len = nums.length;\\n       \\n       int [] result = new int[len];\\n      \\n      HashSet<Integer> set = new HashSet<>();\\n\\n      for( int i = 0 ; i < len ; i++){\\n          set.add(nums[i]);\\n         \\n         HashSet<Integer> set1 = new HashSet<>();\\n\\n         for( int j = i + 1 ; j < len ; j++)\\n             set1.add(nums[j]);\\n\\n          result[i] = set.size() - set1.size();\\n      }\\n\\n      return result;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935165,
                "title": "using-hash",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc distinctDifferenceArray(nums []int) []int {\\n\\n    answerArray := make([]int,len(nums))\\n    start := 0\\n\\n    for i:=0 ; i<len(nums) ; i++ {\\n\\n        diff := 0\\n\\n        //prefix map creation\\n        prefixMap := make(map[int]bool)\\n        for j:=start ; j<= i ; j++ {\\n            if _ , ok := prefixMap[nums[j]] ; !ok{\\n                prefixMap[nums[j]] = true\\n            }\\n        }\\n\\n        //suffix map creation\\n        suffixMap := make(map[int]bool)\\n        if i != len(nums)-1 {\\n            for k:=i+1 ; k<len(nums) ; k++ {\\n                if _ , ok := suffixMap[nums[k]] ; !ok{\\n                    suffixMap[nums[k]] = true\\n                }\\n            }\\n            diff = len(prefixMap) - len(suffixMap)\\n        }else{\\n            diff = len(prefixMap) - len(suffixMap)\\n        }\\n        //append the difference into the answer array\\n        answerArray[i] = diff\\n    }\\n    return answerArray\\n\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc distinctDifferenceArray(nums []int) []int {\\n\\n    answerArray := make([]int,len(nums))\\n    start := 0\\n\\n    for i:=0 ; i<len(nums) ; i++ {\\n\\n        diff := 0\\n\\n        //prefix map creation\\n        prefixMap := make(map[int]bool)\\n        for j:=start ; j<= i ; j++ {\\n            if _ , ok := prefixMap[nums[j]] ; !ok{\\n                prefixMap[nums[j]] = true\\n            }\\n        }\\n\\n        //suffix map creation\\n        suffixMap := make(map[int]bool)\\n        if i != len(nums)-1 {\\n            for k:=i+1 ; k<len(nums) ; k++ {\\n                if _ , ok := suffixMap[nums[k]] ; !ok{\\n                    suffixMap[nums[k]] = true\\n                }\\n            }\\n            diff = len(prefixMap) - len(suffixMap)\\n        }else{\\n            diff = len(prefixMap) - len(suffixMap)\\n        }\\n        //append the difference into the answer array\\n        answerArray[i] = diff\\n    }\\n    return answerArray\\n\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3932889,
                "title": "without-php-magic-methods",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer[]\\n     */\\n function distinctDifferenceArray($nums) {\\n        $res = [];\\n        for($i=0; $i<count($nums); $i++){\\n            $suffix = $this->countSuffix($i, $nums);\\n            $prefix = $this->countPrefix($i, $nums);\\n            $res[] = $prefix - $suffix;\\n        }\\n\\n        return $res;\\n    }\\n    \\n    function countSuffix($tar, $array){\\n      $res = [];\\n        for($i = $tar+1; $i<count($array); $i++){\\n          $el = $array[$i];\\n          if(!in_array($el, $res)){\\n            $res[] = $el;\\n          }\\n        }\\n        return count($res);\\n    }\\n    \\n       function countPrefix($tar, $array){\\n      $res = [];\\n        for($i = 0; $i<=$tar; $i++){\\n          $el = $array[$i];\\n          if(!in_array($el, $res)){\\n            $res[] = $el;\\n          }\\n        }\\n        return count($res);\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer[]\\n     */\\n function distinctDifferenceArray($nums) {\\n        $res = [];\\n        for($i=0; $i<count($nums); $i++){\\n            $suffix = $this->countSuffix($i, $nums);\\n            $prefix = $this->countPrefix($i, $nums);\\n            $res[] = $prefix - $suffix;\\n        }\\n\\n        return $res;\\n    }\\n    \\n    function countSuffix($tar, $array){\\n      $res = [];\\n        for($i = $tar+1; $i<count($array); $i++){\\n          $el = $array[$i];\\n          if(!in_array($el, $res)){\\n            $res[] = $el;\\n          }\\n        }\\n        return count($res);\\n    }\\n    \\n       function countPrefix($tar, $array){\\n      $res = [];\\n        for($i = 0; $i<=$tar; $i++){\\n          $el = $array[$i];\\n          if(!in_array($el, $res)){\\n            $res[] = $el;\\n          }\\n        }\\n        return count($res);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924371,
                "title": "easy-to-understand-pthon-soluton-two-ways",
                "content": "# Intuition\\nThe intuition here is simple, we will create two sets, prefi and suffix, and keep adding numbers accordingly and then finding the difference between there lengths.\\nWe will see two approaches, one which is very basic and then the other how can we leverage python\\n\\n# Approach\\nWe will create an *ans* list and a prefix list since we will kepp adding the distinct numbers in prefix as we go ahead in array.\\n\\nWe will have two loops in the first approach, for each outer loop we will create an suffix list, in the inner list we will traverse the array for all elements to the right of index i for which we are calculating the and and keep adding distinct numbers in suffix list.\\n\\nDO upvote if you like the solution!\\n \\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        ans=[]\\n        prefix=set()\\n        for i in range(len(nums)):\\n            prefix.add(nums[i])\\n            suffix=set()\\n            for j in range(i+1,len(nums)):\\n                suffix.add(nums[j])\\n\\n            l=len(prefix)-len(suffix)\\n            ans.append(l)\\n\\n        \\n        return ans\\n                \\n        \\n```\\n\\n# The second approach\\nHere too we are essentially doing the same thing just we are leveraging the use of python\\n\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        ans=[]\\n\\n        for i in range(len(nums)):\\n            ans.append(len(set(nums[:i+1]))-len(set(nums[i+1:])))\\n\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        ans=[]\\n        prefix=set()\\n        for i in range(len(nums)):\\n            prefix.add(nums[i])\\n            suffix=set()\\n            for j in range(i+1,len(nums)):\\n                suffix.add(nums[j])\\n\\n            l=len(prefix)-len(suffix)\\n            ans.append(l)\\n\\n        \\n        return ans\\n                \\n        \\n```\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        ans=[]\\n\\n        for i in range(len(nums)):\\n            ans.append(len(set(nums[:i+1]))-len(set(nums[i+1:])))\\n\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923262,
                "title": "easy-java-solution-without-set-3ms-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int len = nums.length;\\n        int[] ld = new int[len];\\n        boolean[] ldMap = new boolean[51];\\n        int[] rd = new int[len];\\n        boolean[] rdMap = new boolean[51];\\n        \\n        int distincts = 0;\\n        for(int i = 0; i<len; i++) {\\n            if(!ldMap[nums[i]]) {\\n                distincts += 1;\\n                ldMap[nums[i]] = true;\\n            }\\n            ld[i] = distincts;\\n        }\\n\\n        distincts = 0;\\n        for(int i = len-1; i>=0; i--) {\\n            rd[i] = distincts;\\n            if(!rdMap[nums[i]]) {\\n                distincts += 1;\\n                rdMap[nums[i]] = true;\\n            }\\n        }\\n\\n        int[] res = new int[len];\\n        for(int i=0; i<len; i++ ) {\\n            res[i] = ld[i] - rd[i] ;\\n        }\\n        return res;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int len = nums.length;\\n        int[] ld = new int[len];\\n        boolean[] ldMap = new boolean[51];\\n        int[] rd = new int[len];\\n        boolean[] rdMap = new boolean[51];\\n        \\n        int distincts = 0;\\n        for(int i = 0; i<len; i++) {\\n            if(!ldMap[nums[i]]) {\\n                distincts += 1;\\n                ldMap[nums[i]] = true;\\n            }\\n            ld[i] = distincts;\\n        }\\n\\n        distincts = 0;\\n        for(int i = len-1; i>=0; i--) {\\n            rd[i] = distincts;\\n            if(!rdMap[nums[i]]) {\\n                distincts += 1;\\n                rdMap[nums[i]] = true;\\n            }\\n        }\\n\\n        int[] res = new int[len];\\n        for(int i=0; i<len; i++ ) {\\n            res[i] = ld[i] - rd[i] ;\\n        }\\n        return res;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921559,
                "title": "c-solution-using-function-and-map",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        vector<int>v;\\n        for(int i=0;i<nums.size();i++){\\n            int c1=cal_count(nums,0,i);\\n            int c2=cal_count(nums,i+1,nums.size()-1);\\n            v.push_back(c1-c2);\\n        }\\n        return v;\\n    }\\n\\n    int cal_count(vector<int>& nums, int start,int end){\\n        int n;\\n        map<int,int>m;\\n        for(int i=start;i<=end;i++){\\n         if(m.count(nums[i])!=1){\\n             n++;\\n         }\\n         m[nums[i]]=1;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        vector<int>v;\\n        for(int i=0;i<nums.size();i++){\\n            int c1=cal_count(nums,0,i);\\n            int c2=cal_count(nums,i+1,nums.size()-1);\\n            v.push_back(c1-c2);\\n        }\\n        return v;\\n    }\\n\\n    int cal_count(vector<int>& nums, int start,int end){\\n        int n;\\n        map<int,int>m;\\n        for(int i=start;i<=end;i++){\\n         if(m.count(nums[i])!=1){\\n             n++;\\n         }\\n         m[nums[i]]=1;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919056,
                "title": "python-beats-100-in-runtime-86-in-memory",
                "content": "![image](https://assets.leetcode.com/users/images/bc974491-0c21-44c2-8b63-1da1fb98c870_1692206350.833026.jpeg)\\n![image](https://assets.leetcode.com/users/images/0d03b75b-58ee-4f1d-94ed-7028703bb67d_1692206351.17603.jpeg)\\n",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/bc974491-0c21-44c2-8b63-1da1fb98c870_1692206350.833026.jpeg)\\n![image](https://assets.leetcode.com/users/images/0d03b75b-58ee-4f1d-94ed-7028703bb67d_1692206351.17603.jpeg)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3918580,
                "title": "python-easy-solution-using-slicing",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def distinctDifferenceArray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        res = []\\n        for i in range(len(nums)):\\n            prefix = len(set(nums[i+1:]))\\n            suffix = len(set(nums[:i+1]))\\n\\n            res.append(suffix-prefix)\\n        \\n        return res\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def distinctDifferenceArray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        res = []\\n        for i in range(len(nums)):\\n            prefix = len(set(nums[i+1:]))\\n            suffix = len(set(nums[:i+1]))\\n\\n            res.append(suffix-prefix)\\n        \\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917159,
                "title": "ruby-one-liner",
                "content": "```\\n# @param {Integer[]} nums\\n# @return {Integer[]}\\ndef distinct_difference_array(nums)\\n  (0...nums.size).map{|i| nums[0..i].uniq.size - nums[i + 1...].uniq.size}\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} nums\\n# @return {Integer[]}\\ndef distinct_difference_array(nums)\\n  (0...nums.size).map{|i| nums[0..i].uniq.size - nums[i + 1...].uniq.size}\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3911828,
                "title": "python-solution-using-slices",
                "content": "# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        result: List[int] = []\\n        for index in range(len(nums)):\\n            diff = len(set(nums[0:index + 1])) - len(set(nums[index + 1:]))\\n            result.append(diff)\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        result: List[int] = []\\n        for index in range(len(nums)):\\n            diff = len(set(nums[0:index + 1])) - len(set(nums[index + 1:]))\\n            result.append(diff)\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911719,
                "title": "rust-solution-using-hashsets",
                "content": "# Functional Code\\n```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn distinct_difference_array(nums: Vec<i32>) -> Vec<i32> {\\n        (0..nums.len())\\n            .map(|index| {\\n                let prefix = nums\\n                    .iter()\\n                    .enumerate()\\n                    .filter(|(i, _v)| *i <= index)\\n                    .map(|(_, &v)| v)\\n                    .collect::<HashSet<i32>>()\\n                    .len() as i32;\\n                let suffix = nums\\n                    .iter()\\n                    .skip(index + 1)\\n                    .map(|&v| v)\\n                    .collect::<HashSet<i32>>()\\n                    .len() as i32;\\n                prefix - suffix\\n            })\\n            .collect::<Vec<i32>>()\\n    }\\n}\\n```\\n\\n# Code using For Loops\\n```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn distinct_difference_array_1(nums: Vec<i32>) -> Vec<i32> {\\n        let mut result = vec![];\\n        for index in 0..nums.len() {\\n            let (mut prefix, mut suffix) = (HashSet::new(), HashSet::new());\\n            for (i, num) in nums.iter().enumerate() {\\n                if i <= index {\\n                    prefix.insert(num);\\n                    continue;\\n                }\\n                suffix.insert(num);\\n            }\\n            let diff = prefix.len() as i32 - suffix.len() as i32;\\n            result.push(diff);\\n        }\\n        result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn distinct_difference_array(nums: Vec<i32>) -> Vec<i32> {\\n        (0..nums.len())\\n            .map(|index| {\\n                let prefix = nums\\n                    .iter()\\n                    .enumerate()\\n                    .filter(|(i, _v)| *i <= index)\\n                    .map(|(_, &v)| v)\\n                    .collect::<HashSet<i32>>()\\n                    .len() as i32;\\n                let suffix = nums\\n                    .iter()\\n                    .skip(index + 1)\\n                    .map(|&v| v)\\n                    .collect::<HashSet<i32>>()\\n                    .len() as i32;\\n                prefix - suffix\\n            })\\n            .collect::<Vec<i32>>()\\n    }\\n}\\n```\n```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn distinct_difference_array_1(nums: Vec<i32>) -> Vec<i32> {\\n        let mut result = vec![];\\n        for index in 0..nums.len() {\\n            let (mut prefix, mut suffix) = (HashSet::new(), HashSet::new());\\n            for (i, num) in nums.iter().enumerate() {\\n                if i <= index {\\n                    prefix.insert(num);\\n                    continue;\\n                }\\n                suffix.insert(num);\\n            }\\n            let diff = prefix.len() as i32 - suffix.len() as i32;\\n            result.push(diff);\\n        }\\n        result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3911089,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* distinctDifferenceArray(int* nums, int N, int* returnSize){\\n    int *fre = (int*)calloc(51, sizeof(int));\\n    int *prefix = (int*)calloc(51, sizeof(int));\\n    int *ans = (int*)malloc(N * sizeof(int));\\n\\n    *returnSize = N;\\n    int count = 0;\\n    int pre = 0;\\n    \\n    for(int i = 0; i < N; i++){\\n        if(fre[nums[i]] == 0){\\n        count++;\\n        }\\n        fre[nums[i]]++;\\n    }\\n    \\n    for(int i = 0; i < N; i++){\\n\\n        if(prefix[nums[i]] == 0){\\n            pre++;\\n            prefix[nums[i]]++;\\n        }\\n        if(fre[nums[i]] - 1 == 0){\\n            count--;\\n        }        \\n        fre[nums[i]]--;\\n\\n        ans[i] = pre - count;\\n    }\\n\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* distinctDifferenceArray(int* nums, int N, int* returnSize){\\n    int *fre = (int*)calloc(51, sizeof(int));\\n    int *prefix = (int*)calloc(51, sizeof(int));\\n    int *ans = (int*)malloc(N * sizeof(int));\\n\\n    *returnSize = N;\\n    int count = 0;\\n    int pre = 0;\\n    \\n    for(int i = 0; i < N; i++){\\n        if(fre[nums[i]] == 0){\\n        count++;\\n        }\\n        fre[nums[i]]++;\\n    }\\n    \\n    for(int i = 0; i < N; i++){\\n\\n        if(prefix[nums[i]] == 0){\\n            pre++;\\n            prefix[nums[i]]++;\\n        }\\n        if(fre[nums[i]] - 1 == 0){\\n            count--;\\n        }        \\n        fre[nums[i]]--;\\n\\n        ans[i] = pre - count;\\n    }\\n\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3908561,
                "title": "how-can-i-optimize-this-further",
                "content": "\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int res[]=new int[nums.length];\\n       Set<Integer> set1=new HashSet<>();\\n       Set<Integer> set2=new HashSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            for(int p=0;p<=i;p++){\\n                set1.add(nums[p]);\\n            }\\n            for(int j=i+1;j<nums.length;j++){\\n                \\n                set2.add(nums[j]);\\n                // System.out.println(set);\\n\\n            }\\n            // int s=set.size();\\n            // System.out.println(s);\\n            res[i]=set1.size()-set2.size();\\n            // System.out.println(res[i]);\\n            set1.clear();set2.clear();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int res[]=new int[nums.length];\\n       Set<Integer> set1=new HashSet<>();\\n       Set<Integer> set2=new HashSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            for(int p=0;p<=i;p++){\\n                set1.add(nums[p]);\\n            }\\n            for(int j=i+1;j<nums.length;j++){\\n                \\n                set2.add(nums[j]);\\n                // System.out.println(set);\\n\\n            }\\n            // int s=set.size();\\n            // System.out.println(s);\\n            res[i]=set1.size()-set2.size();\\n            // System.out.println(res[i]);\\n            set1.clear();set2.clear();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905519,
                "title": "easy-solution-beats-90-hashmap-explained",
                "content": "\\n## Approach Explanation\\n\\nFirst traverse through the entire array and store the frequency in the suffix map and on Second traversal increase the count in the prefix map and also decrease the count in suffix map.If frequency of that element becomes zero in suffix map ,then remove it and take difference of the two maps size and store it in the answer array! \\n\\n## Code \\n\\n```java\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int[] ans = new int[nums.length];\\n        HashMap<Integer, Integer> prefix = new HashMap<>();\\n        HashMap<Integer, Integer> suffix = new HashMap<>();\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            suffix.put(nums[i], suffix.getOrDefault(nums[i], 0) + 1);\\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            prefix.put(nums[i], prefix.getOrDefault(nums[i], 0) + 1);\\n            suffix.put(nums[i], suffix.getOrDefault(nums[i], 0) - 1);\\n            if (suffix.get(nums[i]) == 0) {\\n                suffix.remove(nums[i]);\\n            }\\n            ans[i] = prefix.size() - suffix.size();\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```java\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int[] ans = new int[nums.length];\\n        HashMap<Integer, Integer> prefix = new HashMap<>();\\n        HashMap<Integer, Integer> suffix = new HashMap<>();\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            suffix.put(nums[i], suffix.getOrDefault(nums[i], 0) + 1);\\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            prefix.put(nums[i], prefix.getOrDefault(nums[i], 0) + 1);\\n            suffix.put(nums[i], suffix.getOrDefault(nums[i], 0) - 1);\\n            if (suffix.get(nums[i]) == 0) {\\n                suffix.remove(nums[i]);\\n            }\\n            ans[i] = prefix.size() - suffix.size();\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903189,
                "title": "beats-easy-beginner-friendly-solution-simple-and-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        HashSet<Integer>h1= new HashSet();\\n        HashSet<Integer>h2= new HashSet();\\n        int n=nums.length;\\n        int[] p=new int[n];\\n        int[] s=new int[n];\\n        int[] ans=new int[n];\\n        for(int i=0;i<n;i++){\\n            if(!h1.contains(nums[i])){\\n                h1.add(nums[i]);\\n            }\\n            p[i]=h1.size();\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            if(!h2.contains(nums[i])){\\n                h2.add(nums[i]);\\n            }\\n            s[i]=h2.size();\\n        }\\n        for(int i=0;i<n-1;i++){\\n            \\n            ans[i]=p[i]-s[i+1];\\n        }\\n        ans[n-1]=p[n-1];\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        HashSet<Integer>h1= new HashSet();\\n        HashSet<Integer>h2= new HashSet();\\n        int n=nums.length;\\n        int[] p=new int[n];\\n        int[] s=new int[n];\\n        int[] ans=new int[n];\\n        for(int i=0;i<n;i++){\\n            if(!h1.contains(nums[i])){\\n                h1.add(nums[i]);\\n            }\\n            p[i]=h1.size();\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            if(!h2.contains(nums[i])){\\n                h2.add(nums[i]);\\n            }\\n            s[i]=h2.size();\\n        }\\n        for(int i=0;i<n-1;i++){\\n            \\n            ans[i]=p[i]-s[i+1];\\n        }\\n        ans[n-1]=p[n-1];\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889070,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n       int n = nums.length;\\n       int[] res = new int[n];\\n       for(int i=0;i<n;i++)\\n       {\\n           HashSet<Integer> hs = new HashSet<>();\\n           for(int j=0;j<=i;j++)\\n           {\\n               hs.add(nums[j]);\\n           }\\n           HashSet<Integer> js = new HashSet<>();\\n           for(int j=i+1;j<n;j++)\\n           {\\n               js.add(nums[j]);\\n           }\\n           res[i] = hs.size()-js.size();\\n       }\\n       return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n       int n = nums.length;\\n       int[] res = new int[n];\\n       for(int i=0;i<n;i++)\\n       {\\n           HashSet<Integer> hs = new HashSet<>();\\n           for(int j=0;j<=i;j++)\\n           {\\n               hs.add(nums[j]);\\n           }\\n           HashSet<Integer> js = new HashSet<>();\\n           for(int j=i+1;j<n;j++)\\n           {\\n               js.add(nums[j]);\\n           }\\n           res[i] = hs.size()-js.size();\\n       }\\n       return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886135,
                "title": "easy-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int[] ans=new int[nums.length];\\n        int n=nums.length-1;\\n        for(int i=0;i<=n;i++){\\n            int prefix=count(0,nums,i);\\n            int suffix=count(i+1,nums,n);\\n            ans[i]=prefix-suffix;\\n        }\\n        return ans;\\n    }\\n    public int count(int start,int[] nums,int end){\\n        int count=0;\\n         boolean[] num=new boolean[1000001];\\n         for(int i=start;i<=end;i++){\\n             if(!num[nums[i]]){\\n                 num[nums[i]]=true;\\n                 count++;\\n             }\\n         }\\n         return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int[] ans=new int[nums.length];\\n        int n=nums.length-1;\\n        for(int i=0;i<=n;i++){\\n            int prefix=count(0,nums,i);\\n            int suffix=count(i+1,nums,n);\\n            ans[i]=prefix-suffix;\\n        }\\n        return ans;\\n    }\\n    public int count(int start,int[] nums,int end){\\n        int count=0;\\n         boolean[] num=new boolean[1000001];\\n         for(int i=start;i<=end;i++){\\n             if(!num[nums[i]]){\\n                 num[nums[i]]=true;\\n                 count++;\\n             }\\n         }\\n         return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884358,
                "title": "python-one-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSet can helps to get distinct elements\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n\\n        return [len(set(nums[:i+1]))-len(set(nums[i+1:])) for i in range(len(nums))]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n\\n        return [len(set(nums[:i+1]))-len(set(nums[i+1:])) for i in range(len(nums))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884089,
                "title": "python-simple-solution-using-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        out = []\\n        for i in range(len(nums)):\\n            out.append(len(set(nums[:i+1])) - len(set(nums[i+1:])))\\n\\n        return out\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        out = []\\n        for i in range(len(nums)):\\n            out.append(len(set(nums[:i+1])) - len(set(nums[i+1:])))\\n\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879566,
                "title": "prefix-suffix",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n\\n        ans=[]\\n\\n        for i in range (0,len(nums)):\\n\\n            a = set(nums[:i+1])\\n            b = set(nums[i+1:])\\n\\n            c = len(a) - len(b)\\n\\n            ans.append(c)\\n        \\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n\\n        ans=[]\\n\\n        for i in range (0,len(nums)):\\n\\n            a = set(nums[:i+1])\\n            b = set(nums[i+1:])\\n\\n            c = len(a) - len(b)\\n\\n            ans.append(c)\\n        \\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876833,
                "title": "find-the-distinct-difference",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        diff=[]\\n        for i in range(len(nums)):\\n            diff.append(len(set([nums[j] for j in range(i+1)]))-len(set([nums[j] for j in range(i+1,len(nums))])))\\n        return diff\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        diff=[]\\n        for i in range(len(nums)):\\n            diff.append(len(set([nums[j] for j in range(i+1)]))-len(set([nums[j] for j in range(i+1,len(nums))])))\\n        return diff\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876176,
                "title": "masum-code-c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        unordered_map<int,int>suff,puff;\\n        vector<int>ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            suff[nums[i]]++;\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            suff[nums[i]]--;\\n            puff[nums[i]]++;\\n            if(suff[nums[i]]==0)\\n            {\\n                suff.erase(nums[i]);\\n            }\\n            ans.push_back(puff.size()-suff.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        unordered_map<int,int>suff,puff;\\n        vector<int>ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            suff[nums[i]]++;\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            suff[nums[i]]--;\\n            puff[nums[i]]++;\\n            if(suff[nums[i]]==0)\\n            {\\n                suff.erase(nums[i]);\\n            }\\n            ans.push_back(puff.size()-suff.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3875509,
                "title": "java-simple-but-fastest-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n      int leftCount = 0, \\n          rightCount = 0, \\n          n = nums.length;\\n          \\n      int[] table = new int[51], \\n            table2 = new int[51],\\n            result = new int[n];\\n\\n      for(int i = 0; i < n; i++){\\n          table[nums[i]]++;\\n          if(table[nums[i]] == 1) rightCount++;\\n      }\\n\\n      for(int i = 0; i < n; i++){\\n          table[nums[i]]--;\\n          table2[nums[i]]++;\\n          if(table[nums[i]] == 0) rightCount--;\\n          if(table2[nums[i]] == 1) leftCount++;\\n\\n          result[i] = leftCount - rightCount;\\n      }\\n\\n      return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n      int leftCount = 0, \\n          rightCount = 0, \\n          n = nums.length;\\n          \\n      int[] table = new int[51], \\n            table2 = new int[51],\\n            result = new int[n];\\n\\n      for(int i = 0; i < n; i++){\\n          table[nums[i]]++;\\n          if(table[nums[i]] == 1) rightCount++;\\n      }\\n\\n      for(int i = 0; i < n; i++){\\n          table[nums[i]]--;\\n          table2[nums[i]]++;\\n          if(table[nums[i]] == 0) rightCount--;\\n          if(table2[nums[i]] == 1) leftCount++;\\n\\n          result[i] = leftCount - rightCount;\\n      }\\n\\n      return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873486,
                "title": "python-o-n-beats-100",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def distinctDifferenceArray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        lfreq, rfreq = {nums[0]: 1}, {}\\n        ldist, rdist = 1, 0\\n        for i in range(1, len(nums)):\\n            if nums[i] in rfreq:\\n                rfreq[nums[i]] += 1\\n            else:\\n                rfreq[nums[i]] = 1\\n                rdist += 1\\n        r = [ldist-rdist]\\n\\n        for i in range(1, len(nums)):\\n            if rfreq[nums[i]] == 1:\\n                rfreq[nums[i]] -= 1\\n                rdist -= 1\\n            if rfreq[nums[i]] > 1:\\n                rfreq[nums[i]] -= 1\\n\\n            if nums[i] in lfreq:\\n                lfreq[nums[i]] += 1\\n            else:\\n                lfreq[nums[i]] = 1\\n                ldist += 1\\n            r.append(ldist - rdist)\\n        return r\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution(object):\\n    def distinctDifferenceArray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        lfreq, rfreq = {nums[0]: 1}, {}\\n        ldist, rdist = 1, 0\\n        for i in range(1, len(nums)):\\n            if nums[i] in rfreq:\\n                rfreq[nums[i]] += 1\\n            else:\\n                rfreq[nums[i]] = 1\\n                rdist += 1\\n        r = [ldist-rdist]\\n\\n        for i in range(1, len(nums)):\\n            if rfreq[nums[i]] == 1:\\n                rfreq[nums[i]] -= 1\\n                rdist -= 1\\n            if rfreq[nums[i]] > 1:\\n                rfreq[nums[i]] -= 1\\n\\n            if nums[i] in lfreq:\\n                lfreq[nums[i]] += 1\\n            else:\\n                lfreq[nums[i]] = 1\\n                ldist += 1\\n            r.append(ldist - rdist)\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3870681,
                "title": "kotlin-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    fun distinctDifferenceArray(nums: IntArray): IntArray {\\n        var setLeft = mutableSetOf<Int>()\\n        var setRight = mutableSetOf<Int>()\\n        var arrLeft = IntArray(nums.size){0}\\n        var arrRight = IntArray(nums.size){0}\\n        var countLeft = 1\\n        var countRight = 0\\n        setLeft.add(nums[0])\\n        arrLeft[0] = countLeft\\n\\n        for (i in 1 until nums.size) {\\n            if (!setLeft.contains(nums[i])) {\\n                setLeft.add(nums[i])\\n                countLeft++\\n            }\\n            arrLeft[i] = countLeft\\n\\n            if (!setRight.contains(nums[nums.size - i])) {\\n                setRight.add(nums[nums.size - i])\\n                countRight++\\n            }\\n            arrRight[nums.size - i - 1] = countRight\\n        }\\n\\n        for (i in 0 until nums.size) {\\n            nums[i] = arrLeft[i] - arrRight[i]\\n        }\\n\\n        return nums\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun distinctDifferenceArray(nums: IntArray): IntArray {\\n        var setLeft = mutableSetOf<Int>()\\n        var setRight = mutableSetOf<Int>()\\n        var arrLeft = IntArray(nums.size){0}\\n        var arrRight = IntArray(nums.size){0}\\n        var countLeft = 1\\n        var countRight = 0\\n        setLeft.add(nums[0])\\n        arrLeft[0] = countLeft\\n\\n        for (i in 1 until nums.size) {\\n            if (!setLeft.contains(nums[i])) {\\n                setLeft.add(nums[i])\\n                countLeft++\\n            }\\n            arrLeft[i] = countLeft\\n\\n            if (!setRight.contains(nums[nums.size - i])) {\\n                setRight.add(nums[nums.size - i])\\n                countRight++\\n            }\\n            arrRight[nums.size - i - 1] = countRight\\n        }\\n\\n        for (i in 0 until nums.size) {\\n            nums[i] = arrLeft[i] - arrRight[i]\\n        }\\n\\n        return nums\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3868352,
                "title": "python3-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        ans = []\\n        for i in range(len(nums)):\\n            prefix = len(set(nums[:i+1]))\\n            suffix = len(set(nums[i+1:]))\\n\\n            ans.append(prefix - suffix)\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        ans = []\\n        for i in range(len(nums)):\\n            prefix = len(set(nums[:i+1]))\\n            suffix = len(set(nums[i+1:]))\\n\\n            ans.append(prefix - suffix)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866483,
                "title": "easy-to-understand-using-hash-set-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.io.*;\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] n) {\\n         int b[]=new int[n.length];\\n\\t      HashSet<Integer> pre= new HashSet<Integer>();\\n\\t      HashSet<Integer> suf= new HashSet<Integer>();\\n\\t    for(int i=0;i<n.length;i++)\\n\\t    {\\n\\t         for(int j=0;j<=i;j++)\\n\\t         {\\n\\t             pre.add(n[j]);\\n\\t         }\\n\\t         for(int k=i+1;k<n.length;k++)\\n\\t         {\\n\\t             suf.add(n[k]);\\n\\t         }\\n\\t        b[i]=pre.size()-suf.size();\\n\\t         pre.clear();\\n\\t         suf.clear();\\n\\t    }\\n        return b;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.io.*;\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] n) {\\n         int b[]=new int[n.length];\\n\\t      HashSet<Integer> pre= new HashSet<Integer>();\\n\\t      HashSet<Integer> suf= new HashSet<Integer>();\\n\\t    for(int i=0;i<n.length;i++)\\n\\t    {\\n\\t         for(int j=0;j<=i;j++)\\n\\t         {\\n\\t             pre.add(n[j]);\\n\\t         }\\n\\t         for(int k=i+1;k<n.length;k++)\\n\\t         {\\n\\t             suf.add(n[k]);\\n\\t         }\\n\\t        b[i]=pre.size()-suf.size();\\n\\t         pre.clear();\\n\\t         suf.clear();\\n\\t    }\\n        return b;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865767,
                "title": "c-99-faster-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(|hashTable|)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\tvector<int> distinctDifferenceArray(vector<int>& nums) {\\n\\n\\t\\tint inputSize = nums.size();\\n\\n\\t\\tif(inputSize == 1){\\n\\t\\t\\treturn {1};\\n\\t\\t}\\n\\n\\t\\tbool hash[51] = {false};\\n\\n\\t\\tvector<int> ans(inputSize,0);\\n\\n\\t\\tans[0] = 1;\\n\\t\\thash[nums[0]] = true;\\n\\n\\n\\t\\tfor (int i = 1; i < inputSize; ++i)\\n\\t\\t{\\n\\t\\t\\tif(hash[nums[i]]){\\n\\t\\t\\t\\tans[i] = ans[i-1];\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tans[i] = ans[i-1] + 1;\\n\\t\\t\\t\\thash[nums[i]] = true;\\n\\t\\t\\t}\\t\\n\\t\\t} \\n\\n\\t\\tint loopVar = 1;\\n\\n\\t\\tfor (int i = 0; i < 51; ++i)\\n\\t\\t{\\n\\t\\t\\thash[i] = false;\\n\\t\\t}\\n\\n\\t\\thash[nums[inputSize-1]] = true;\\n\\n\\t\\tfor (int i = inputSize-2; i >= 0; --i)\\n\\t\\t{\\n\\t\\t\\tans[i] -= loopVar;\\n\\t\\t\\tif(!hash[nums[i]]){\\n\\t\\t\\t\\tloopVar++;\\n\\t\\t\\t\\thash[nums[i]] = true;\\n\\t\\t\\t}\\t\\n\\t\\t} \\n\\n\\t\\treturn ans;\\n\\n\\t}\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tvector<int> distinctDifferenceArray(vector<int>& nums) {\\n\\n\\t\\tint inputSize = nums.size();\\n\\n\\t\\tif(inputSize == 1){\\n\\t\\t\\treturn {1};\\n\\t\\t}\\n\\n\\t\\tbool hash[51] = {false};\\n\\n\\t\\tvector<int> ans(inputSize,0);\\n\\n\\t\\tans[0] = 1;\\n\\t\\thash[nums[0]] = true;\\n\\n\\n\\t\\tfor (int i = 1; i < inputSize; ++i)\\n\\t\\t{\\n\\t\\t\\tif(hash[nums[i]]){\\n\\t\\t\\t\\tans[i] = ans[i-1];\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tans[i] = ans[i-1] + 1;\\n\\t\\t\\t\\thash[nums[i]] = true;\\n\\t\\t\\t}\\t\\n\\t\\t} \\n\\n\\t\\tint loopVar = 1;\\n\\n\\t\\tfor (int i = 0; i < 51; ++i)\\n\\t\\t{\\n\\t\\t\\thash[i] = false;\\n\\t\\t}\\n\\n\\t\\thash[nums[inputSize-1]] = true;\\n\\n\\t\\tfor (int i = inputSize-2; i >= 0; --i)\\n\\t\\t{\\n\\t\\t\\tans[i] -= loopVar;\\n\\t\\t\\tif(!hash[nums[i]]){\\n\\t\\t\\t\\tloopVar++;\\n\\t\\t\\t\\thash[nums[i]] = true;\\n\\t\\t\\t}\\t\\n\\t\\t} \\n\\n\\t\\treturn ans;\\n\\n\\t}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862771,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] DistinctDifferenceArray(int[] nums) {\\n        int n= nums.Length;\\n        int [] arr= new int[nums.Length];\\n        for(int i =0;i<n ;i++)\\n        {\\n            int count1 = Helper(nums,0,i);\\n            int count2 = Helper(nums,i+1,n-1);\\n            arr[i]= count1-count2;\\n        }\\n\\n        return arr;\\n    }\\n    public int Helper(int[] nums,int start, int end)\\n    {\\n        HashSet<int> hs = new HashSet<int>();\\n        for(int i =start ;i<=end ;i++)\\n        {\\n            hs.Add(nums[i]);\\n        }\\n\\n        return hs.Count();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] DistinctDifferenceArray(int[] nums) {\\n        int n= nums.Length;\\n        int [] arr= new int[nums.Length];\\n        for(int i =0;i<n ;i++)\\n        {\\n            int count1 = Helper(nums,0,i);\\n            int count2 = Helper(nums,i+1,n-1);\\n            arr[i]= count1-count2;\\n        }\\n\\n        return arr;\\n    }\\n    public int Helper(int[] nums,int start, int end)\\n    {\\n        HashSet<int> hs = new HashSet<int>();\\n        for(int i =start ;i<=end ;i++)\\n        {\\n            hs.Add(nums[i]);\\n        }\\n\\n        return hs.Count();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861488,
                "title": "pythonsimplecode3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        l=[]\\n        for i in range(1,len(nums)+1):\\n            x=len(set(nums[:i]))-len(set(nums[i:]))\\n            l.append(x)\\n        return l\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        l=[]\\n        for i in range(1,len(nums)+1):\\n            x=len(set(nums[:i]))-len(set(nums[i:]))\\n            l.append(x)\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858660,
                "title": "java-solution-2-solution-0-n-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        Set<Integer> left = new HashSet<>();\\n        Set<Integer> right = new HashSet<>();\\n        int len = nums.length;\\n        int rightEle[] = new int[len];\\n        int[] ans = new int[len];\\n\\n        rightEle[len-1] = 0;\\n        for(int i=len-2; i>=0; i--){\\n            right.add(nums[i+1]);\\n            rightEle[i] = right.size();\\n        }\\n        for(int i=0; i<len; i++){\\n            left.add(nums[i]);\\n            ans[i] = left.size() - rightEle[i];\\n        }\\n       return ans;\\n    }\\n}\\n\\n// \\n\\n\\n    //     int ans[] = new int[nums.length];\\n    //     Set<Integer> set = new HashSet<>();\\n    //     int count = 0;\\n    //     for(int i=0; i<nums.length; i++){\\n    //         set.add(nums[i]);\\n    //         count = rightNums(nums,i);\\n    //         ans[i] = set.size() - count;\\n    //     }\\n    //     return ans;\\n    // }\\n    //     public int rightNums(int[] nums, int j){\\n    //     Set<Integer> right = new HashSet<>();\\n    //     right.clear();\\n    //     for(int i=j+1; i<nums.length; i++){\\n    //         right.add(nums[i]);\\n    //     }\\n    //     return right.size();\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        Set<Integer> left = new HashSet<>();\\n        Set<Integer> right = new HashSet<>();\\n        int len = nums.length;\\n        int rightEle[] = new int[len];\\n        int[] ans = new int[len];\\n\\n        rightEle[len-1] = 0;\\n        for(int i=len-2; i>=0; i--){\\n            right.add(nums[i+1]);\\n            rightEle[i] = right.size();\\n        }\\n        for(int i=0; i<len; i++){\\n            left.add(nums[i]);\\n            ans[i] = left.size() - rightEle[i];\\n        }\\n       return ans;\\n    }\\n}\\n\\n// \\n\\n\\n    //     int ans[] = new int[nums.length];\\n    //     Set<Integer> set = new HashSet<>();\\n    //     int count = 0;\\n    //     for(int i=0; i<nums.length; i++){\\n    //         set.add(nums[i]);\\n    //         count = rightNums(nums,i);\\n    //         ans[i] = set.size() - count;\\n    //     }\\n    //     return ans;\\n    // }\\n    //     public int rightNums(int[] nums, int j){\\n    //     Set<Integer> right = new HashSet<>();\\n    //     right.clear();\\n    //     for(int i=j+1; i<nums.length; i++){\\n    //         right.add(nums[i]);\\n    //     }\\n    //     return right.size();\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850607,
                "title": "better-understandable-solution-that-beats-96-of-the-solutions",
                "content": "# Intuition\\nHere we need to obtain a resultant list which contains the values that it should be the count of the unique elements from the left side getting subtracted from the count of unique element from the right side.\\n\\n# Approach\\nDeclared a list with the length same as the length of the given list then iterate over the list and for each iteration we have the value of x as the element from beginning of the given list to the current index+1 because then only we will get the value beginning to the index after that y contains the values from index+1 to the end of the given list.These x and y should be a set to neglect the duplicate values from it.Finally append the difference between the length of x ad y.After the whole iteration return the rersultant list.\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        result=[]*len(nums)\\n        for i in range(len(nums)):\\n            x=set(nums[:i+1])\\n            y=set(nums[i+1:len(nums)])\\n            result.append(len(x)-len(y))\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        result=[]*len(nums)\\n        for i in range(len(nums)):\\n            x=set(nums[:i+1])\\n            y=set(nums[i+1:len(nums)])\\n            result.append(len(x)-len(y))\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848966,
                "title": "beats-100-of-users-for-both-memory-and-speed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func distinctDifferenceArray(_ nums: [Int]) -> [Int] {\\n            \\n\\n        var distinctDiff = [Int]()\\n\\n        for (i, num1) in nums.enumerated(){\\n            var numsPrefix = [Int]()\\n            var numsSuffix = [Int]()\\n            for(j, num2) in nums.enumerated(){\\n                if(j <= i && !numsPrefix.contains(num2)){\\n                    numsPrefix.append(num2)\\n                } else if(j > i && !numsSuffix.contains(num2)){\\n                    numsSuffix.append(num2)\\n                }\\n            }\\n            var diff = numsPrefix.count - numsSuffix.count\\n            distinctDiff.append(diff)\\n        }\\n        return distinctDiff\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func distinctDifferenceArray(_ nums: [Int]) -> [Int] {\\n            \\n\\n        var distinctDiff = [Int]()\\n\\n        for (i, num1) in nums.enumerated(){\\n            var numsPrefix = [Int]()\\n            var numsSuffix = [Int]()\\n            for(j, num2) in nums.enumerated(){\\n                if(j <= i && !numsPrefix.contains(num2)){\\n                    numsPrefix.append(num2)\\n                } else if(j > i && !numsSuffix.contains(num2)){\\n                    numsSuffix.append(num2)\\n                }\\n            }\\n            var diff = numsPrefix.count - numsSuffix.count\\n            distinctDiff.append(diff)\\n        }\\n        return distinctDiff\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848421,
                "title": "simple-java-solution-using-map-and-set-without-nested-loops-o-n",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int[] diff = new int[nums.length];\\n\\n        Set<Integer> leftDistinctNumbers = new HashSet<>();\\n        Map<Integer, Integer> rightOccurencesByNumber = new HashMap<>();\\n        for (int num : nums){\\n            rightOccurencesByNumber.compute(num, (k,v) -> (v == null) ? 1 : v+1);\\n        }\\n\\n        for (int i = 0; i < nums.length; i++){\\n            leftDistinctNumbers.add(nums[i]);\\n            rightOccurencesByNumber.compute(nums[i], (k,v) -> v-1);\\n            rightOccurencesByNumber.remove(nums[i], 0);\\n            diff[i] = leftDistinctNumbers.size()-rightOccurencesByNumber.size();\\n        }\\n\\n        return diff;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int[] diff = new int[nums.length];\\n\\n        Set<Integer> leftDistinctNumbers = new HashSet<>();\\n        Map<Integer, Integer> rightOccurencesByNumber = new HashMap<>();\\n        for (int num : nums){\\n            rightOccurencesByNumber.compute(num, (k,v) -> (v == null) ? 1 : v+1);\\n        }\\n\\n        for (int i = 0; i < nums.length; i++){\\n            leftDistinctNumbers.add(nums[i]);\\n            rightOccurencesByNumber.compute(nums[i], (k,v) -> v-1);\\n            rightOccurencesByNumber.remove(nums[i], 0);\\n            diff[i] = leftDistinctNumbers.size()-rightOccurencesByNumber.size();\\n        }\\n\\n        return diff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847274,
                "title": "easy-and-understandable-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        map<int ,int>suffix ,prefix ;\\n        vector<int> ans;\\n\\n        for(auto it:nums){\\n            suffix[it]++;\\n        }\\n        for(auto it:nums){\\n            prefix[it]++;\\n            suffix[it]--;\\n            if(suffix[it]==0){\\n                suffix.erase(it);\\n             }\\n         ans.push_back(prefix.size()-suffix.size());\\n        }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        map<int ,int>suffix ,prefix ;\\n        vector<int> ans;\\n\\n        for(auto it:nums){\\n            suffix[it]++;\\n        }\\n        for(auto it:nums){\\n            prefix[it]++;\\n            suffix[it]--;\\n            if(suffix[it]==0){\\n                suffix.erase(it);\\n             }\\n         ans.push_back(prefix.size()-suffix.size());\\n        }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845978,
                "title": "solution-using-sets-and-arrays-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n      int arr1[]=new int[nums.length];\\n      int arr2[]=new int[nums.length];\\n      for(int i=0;i<nums.length;i++){\\n          Set<Integer>set=new HashSet<>();\\n          for(int j=i+1;j<nums.length;j++){\\n              set.add(nums[j]);\\n          }\\n          arr1[i]=set.size();\\n      }\\n      for(int i=0;i<nums.length;i++){\\n          Set<Integer>set=new HashSet<>();\\n          for(int j=0;j<=i;j++){\\n              set.add(nums[j]);\\n          }\\n          arr2[i]=set.size();\\n      }\\n      for(int i=0;i<arr1.length;i++){\\n          nums[i]=arr2[i]-arr1[i];\\n      }\\n      return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n      int arr1[]=new int[nums.length];\\n      int arr2[]=new int[nums.length];\\n      for(int i=0;i<nums.length;i++){\\n          Set<Integer>set=new HashSet<>();\\n          for(int j=i+1;j<nums.length;j++){\\n              set.add(nums[j]);\\n          }\\n          arr1[i]=set.size();\\n      }\\n      for(int i=0;i<nums.length;i++){\\n          Set<Integer>set=new HashSet<>();\\n          for(int j=0;j<=i;j++){\\n              set.add(nums[j]);\\n          }\\n          arr2[i]=set.size();\\n      }\\n      for(int i=0;i<arr1.length;i++){\\n          nums[i]=arr2[i]-arr1[i];\\n      }\\n      return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840978,
                "title": "java-3ms-beats-100",
                "content": "# Intuition\\nCount distinct (not unique!) elements from left and right sides. Compute the `diff` array.\\n\\n# Approach\\nUse arrays to track distinct elements. Use a `for` loop.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n\\n        int n = nums.length;\\n\\n        int[] distinctElementsPrefix = new int[n + 1];\\n        int[] prefixCounts = new int[51];\\n        int curNumDistinctElementsPrefix = 0;\\n\\n        int[] distinctElementsSuffix = new int[n + 1];\\n        int[] suffixCounts = new int[51];\\n        int curNumDistinctElementsSuffix = 0;\\n\\n        for (int i = 0, j = nums.length - 1; i < nums.length; ++i, --j) {\\n            ++prefixCounts[nums[i]];\\n            if (prefixCounts[nums[i]] == 1) {\\n                ++curNumDistinctElementsPrefix;\\n            }\\n            distinctElementsPrefix[i] = curNumDistinctElementsPrefix;\\n\\n            ++suffixCounts[nums[j]];\\n            if (suffixCounts[nums[j]] == 1) {\\n                ++curNumDistinctElementsSuffix;\\n            }\\n            distinctElementsSuffix[j] = curNumDistinctElementsSuffix;\\n        }\\n\\n        int[] diff = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            diff[i] = distinctElementsPrefix[i] - distinctElementsSuffix[i + 1];\\n        }\\n        return diff;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n\\n        int n = nums.length;\\n\\n        int[] distinctElementsPrefix = new int[n + 1];\\n        int[] prefixCounts = new int[51];\\n        int curNumDistinctElementsPrefix = 0;\\n\\n        int[] distinctElementsSuffix = new int[n + 1];\\n        int[] suffixCounts = new int[51];\\n        int curNumDistinctElementsSuffix = 0;\\n\\n        for (int i = 0, j = nums.length - 1; i < nums.length; ++i, --j) {\\n            ++prefixCounts[nums[i]];\\n            if (prefixCounts[nums[i]] == 1) {\\n                ++curNumDistinctElementsPrefix;\\n            }\\n            distinctElementsPrefix[i] = curNumDistinctElementsPrefix;\\n\\n            ++suffixCounts[nums[j]];\\n            if (suffixCounts[nums[j]] == 1) {\\n                ++curNumDistinctElementsSuffix;\\n            }\\n            distinctElementsSuffix[j] = curNumDistinctElementsSuffix;\\n        }\\n\\n        int[] diff = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            diff[i] = distinctElementsPrefix[i] - distinctElementsSuffix[i + 1];\\n        }\\n        return diff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839030,
                "title": "simple-set-solution-js-ts",
                "content": "# Intuition\\nI have seen all the solutions in which they are creating new set everytime inside loop. But we will only need to create new set everytime for right side but for the left we can just add.\\n\\n# Code\\n```\\nfunction distinctDifferenceArray(nums: number[]): number[] {\\n    let leftSet = new Set<number>();\\n\\n    return nums.map((num,index)=>{\\n        leftSet.add(num);\\n        let rightSet = new Set<number>(nums.slice(index+1));\\n        return leftSet.size-rightSet.size;\\n    })\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction distinctDifferenceArray(nums: number[]): number[] {\\n    let leftSet = new Set<number>();\\n\\n    return nums.map((num,index)=>{\\n        leftSet.add(num);\\n        let rightSet = new Set<number>(nums.slice(index+1));\\n        return leftSet.size-rightSet.size;\\n    })\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3835380,
                "title": "php",
                "content": "![Screen Shot 2023-07-29 at 3.48.08 PM.png](https://assets.leetcode.com/users/images/b699e709-52f7-4786-b01d-b9f99bc8a313_1690660113.0529652.png)\\n\\n\\n# Code\\n```\\nclass Solution\\n{\\n\\n  /**\\n   * @param Integer[] $nums\\n   * @return Integer[]\\n   */\\n  public function distinctDifferenceArray($nums)\\n  {\\n    $diff = [];\\n    for ($i = 1; $i <= count($nums); $i++) {\\n      $prefix = array_slice($nums, 0, $i);\\n      $sufix = array_slice($nums, $i);\\n\\n      $diff[] = count(array_unique($prefix)) - count(array_unique($sufix));\\n    }\\n    return $diff;\\n  }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution\\n{\\n\\n  /**\\n   * @param Integer[] $nums\\n   * @return Integer[]\\n   */\\n  public function distinctDifferenceArray($nums)\\n  {\\n    $diff = [];\\n    for ($i = 1; $i <= count($nums); $i++) {\\n      $prefix = array_slice($nums, 0, $i);\\n      $sufix = array_slice($nums, $i);\\n\\n      $diff[] = count(array_unique($prefix)) - count(array_unique($sufix));\\n    }\\n    return $diff;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834921,
                "title": "with-explanation-comments-time-xx-ms-98-97-space-xx-mb-89-9",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        \\n        vector<int> ans;\\n        int n=nums.size();\\n\\n        for(int i=0;i<nums.size();i++){\\n           set<int> pre, aft;\\n        \\n            for(int j=0;j<=i;j++)\\n                pre.insert(nums[j]);\\n\\n            for(int k=i+1;k<n;k++)\\n                aft.insert(nums[k]);\\n\\n            ans.push_back(pre.size()-aft.size());\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        \\n        vector<int> ans;\\n        int n=nums.size();\\n\\n        for(int i=0;i<nums.size();i++){\\n           set<int> pre, aft;\\n        \\n            for(int j=0;j<=i;j++)\\n                pre.insert(nums[j]);\\n\\n            for(int k=i+1;k<n;k++)\\n                aft.insert(nums[k]);\\n\\n            ans.push_back(pre.size()-aft.size());\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825110,
                "title": "beats-90-single-for-loop-solution-using-sets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intitution here is to slice nums array into prefix (0...k) and suffix (k+1...n-1). Convert the prefix and suffix array into a set to remove duplicate elements. The difference of size between prefix and suffix sets can be pushed into a new array. Repea the above mentioned solution from 0 to length-1 of the array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar distinctDifferenceArray = function(nums) {\\n    let res = [];\\n    var num_len = nums.length;\\n    for(let k=0; k<num_len; k++){\\n        res.push(\\n            new Set(nums.slice(0,k+1)).size - new Set(nums.slice(k+1)).size\\n        )\\n    }\\n    return res\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar distinctDifferenceArray = function(nums) {\\n    let res = [];\\n    var num_len = nums.length;\\n    for(let k=0; k<num_len; k++){\\n        res.push(\\n            new Set(nums.slice(0,k+1)).size - new Set(nums.slice(k+1)).size\\n        )\\n    }\\n    return res\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3813907,
                "title": "java-solution-easy-method",
                "content": "# Intuition\\nNeed to search distinct number\\n# Approach\\nUsed HashSet here and transversed...\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            Set<Integer> set1 = new HashSet<>();\\n            Set<Integer> set2 = new HashSet<>();\\n            for(int j=0;j<=i;j++){\\n                set1.add(nums[j]);\\n            }\\n            for(int j=i+1;j<nums.length;j++){\\n                set2.add(nums[j]);\\n            }\\n            arr[i]=set1.size()-set2.size();\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            Set<Integer> set1 = new HashSet<>();\\n            Set<Integer> set2 = new HashSet<>();\\n            for(int j=0;j<=i;j++){\\n                set1.add(nums[j]);\\n            }\\n            for(int j=i+1;j<nums.length;j++){\\n                set2.add(nums[j]);\\n            }\\n            arr[i]=set1.size()-set2.size();\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3811715,
                "title": "my-c-with-two-heap-heap-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* distinctDifferenceArray(int* nums, int numsSize, int* returnSize){\\n    int* temp = malloc(sizeof(int)*51);\\n    int* pre_temp = malloc(sizeof(int)*51);\\n    int* ret = malloc(sizeof(int)*numsSize);\\n    *returnSize = numsSize;\\n    int i;\\n    for(i=0;i<51;i++){\\n        temp[i] = 0;\\n        pre_temp[i] = 0;\\n    }\\n    int suffix = 0;\\n    for(i=0;i<numsSize;i++){\\n        if(!temp[nums[i]])\\n            suffix++;\\n        temp[nums[i]]++;\\n    }\\n\\n    int prefix = 0;\\n    for(i=0;i<numsSize;i++){\\n        if(!pre_temp[nums[i]])\\n            prefix++;\\n        pre_temp[nums[i]]++;\\n        temp[nums[i]]--;\\n        if(!temp[nums[i]])\\n            suffix--;\\n        ret[i] = prefix - suffix;\\n    }\\n\\n    free(temp);\\n    free(pre_temp);\\n    return ret;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* distinctDifferenceArray(int* nums, int numsSize, int* returnSize){\\n    int* temp = malloc(sizeof(int)*51);\\n    int* pre_temp = malloc(sizeof(int)*51);\\n    int* ret = malloc(sizeof(int)*numsSize);\\n    *returnSize = numsSize;\\n    int i;\\n    for(i=0;i<51;i++){\\n        temp[i] = 0;\\n        pre_temp[i] = 0;\\n    }\\n    int suffix = 0;\\n    for(i=0;i<numsSize;i++){\\n        if(!temp[nums[i]])\\n            suffix++;\\n        temp[nums[i]]++;\\n    }\\n\\n    int prefix = 0;\\n    for(i=0;i<numsSize;i++){\\n        if(!pre_temp[nums[i]])\\n            prefix++;\\n        pre_temp[nums[i]]++;\\n        temp[nums[i]]--;\\n        if(!temp[nums[i]])\\n            suffix--;\\n        ret[i] = prefix - suffix;\\n    }\\n\\n    free(temp);\\n    free(pre_temp);\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3810203,
                "title": "simple-o-n-java-solution-using-2-hashmaps",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        \\n        int n = nums.length;\\n        int[]res = new int[n];\\n\\n        Map<Integer,Integer>pre = new HashMap<>();\\n        Map<Integer,Integer>suff = new HashMap<>();\\n\\n        for(int a: nums){\\n            pre.put(a,pre.getOrDefault(a,0)+1);\\n        }\\n        \\n        int i =0;\\n        for(int a: nums){\\n            suff.put(a,suff.getOrDefault(a,0)+1);\\n            int val = pre.get(a);\\n            if(val -1 == 0)\\n                pre.remove(a);\\n            else\\n                pre.put(a,val-1);\\n            \\n            res[i++] = suff.size()-pre.size();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        \\n        int n = nums.length;\\n        int[]res = new int[n];\\n\\n        Map<Integer,Integer>pre = new HashMap<>();\\n        Map<Integer,Integer>suff = new HashMap<>();\\n\\n        for(int a: nums){\\n            pre.put(a,pre.getOrDefault(a,0)+1);\\n        }\\n        \\n        int i =0;\\n        for(int a: nums){\\n            suff.put(a,suff.getOrDefault(a,0)+1);\\n            int val = pre.get(a);\\n            if(val -1 == 0)\\n                pre.remove(a);\\n            else\\n                pre.put(a,val-1);\\n            \\n            res[i++] = suff.size()-pre.size();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807449,
                "title": "bit-optimised-naive-solution-90-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        ans = [0] * len(nums)\\n        pre, suf = [], nums[::-1]\\n        for i, n in enumerate(nums):\\n            pre.append(n)\\n            suf.pop()\\n            ans[i] = len(set(pre))-len(set(suf))\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        ans = [0] * len(nums)\\n        pre, suf = [], nums[::-1]\\n        for i, n in enumerate(nums):\\n            pre.append(n)\\n            suf.pop()\\n            ans[i] = len(set(pre))-len(set(suf))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3806374,
                "title": "one-liner-beats-92-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        return [len(set(nums[:i+1]))-len(set(nums[i+1:])) for i in range(len(nums))]\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        return [len(set(nums[:i+1]))-len(set(nums[i+1:])) for i in range(len(nums))]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799222,
                "title": "solution-using-two-sets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>ans(n,0);\\n        for(int i = 0;i<n;i++)\\n        {\\n            unordered_set<int>s1(nums.begin(),nums.begin()+i+1);\\n            unordered_set<int>s2(nums.begin()+i+1,nums.end());\\n            ans[i]=s1.size()-s2.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>ans(n,0);\\n        for(int i = 0;i<n;i++)\\n        {\\n            unordered_set<int>s1(nums.begin(),nums.begin()+i+1);\\n            unordered_set<int>s2(nums.begin()+i+1,nums.end());\\n            ans[i]=s1.size()-s2.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798405,
                "title": "js-simple-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar distinctDifferenceArray = function(nums) {\\n    const res = [];\\n    for(let i=0;i<nums.length;i++) {\\n        const lSet = new Set(); // count of distinct left items\\n        const rSet = new Set(); // count of distinct right items\\n\\n        for(let j=i;j>-1;j--) {\\n            lSet.add(nums[j]); // counting left items\\n        }\\n\\n        for(let k=i+1;k<nums.length;k++) {\\n            rSet.add(nums[k]); // counting right items\\n        }\\n\\n        res[i] = lSet.size - rSet.size; // calculating difference\\n    }\\n\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar distinctDifferenceArray = function(nums) {\\n    const res = [];\\n    for(let i=0;i<nums.length;i++) {\\n        const lSet = new Set(); // count of distinct left items\\n        const rSet = new Set(); // count of distinct right items\\n\\n        for(let j=i;j>-1;j--) {\\n            lSet.add(nums[j]); // counting left items\\n        }\\n\\n        for(let k=i+1;k<nums.length;k++) {\\n            rSet.add(nums[k]); // counting right items\\n        }\\n\\n        res[i] = lSet.size - rSet.size; // calculating difference\\n    }\\n\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3797302,
                "title": "kotlin-solution-with-map",
                "content": "# Code\\n```\\nclass Solution {\\n    fun distinctDifferenceArray(nums: IntArray): IntArray {\\n        val prefixMap = mutableMapOf<Int,Int>()\\n        val suffixMap = mutableMapOf<Int,Int>()\\n        val result = IntArray(nums.size)\\n\\n        nums.forEach {\\n            suffixMap[it] = suffixMap.getOrDefault(it, 0) + 1\\n        }\\n\\n        nums.forEachIndexed { i, num ->\\n            prefixMap[num] = prefixMap.getOrDefault(num, 0) + 1\\n            suffixMap[num] = suffixMap.getOrDefault(num, 0) - 1\\n\\n            if (suffixMap[num] == 0)\\n                suffixMap.remove(num)\\n\\n            result[i] = prefixMap.size - suffixMap.size\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    fun distinctDifferenceArray(nums: IntArray): IntArray {\\n        val prefixMap = mutableMapOf<Int,Int>()\\n        val suffixMap = mutableMapOf<Int,Int>()\\n        val result = IntArray(nums.size)\\n\\n        nums.forEach {\\n            suffixMap[it] = suffixMap.getOrDefault(it, 0) + 1\\n        }\\n\\n        nums.forEachIndexed { i, num ->\\n            prefixMap[num] = prefixMap.getOrDefault(num, 0) + 1\\n            suffixMap[num] = suffixMap.getOrDefault(num, 0) - 1\\n\\n            if (suffixMap[num] == 0)\\n                suffixMap.remove(num)\\n\\n            result[i] = prefixMap.size - suffixMap.size\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797052,
                "title": "best-solution-to-clear-your-concepts-from-basic",
                "content": "# Intuition\\nDivide the array in two parts(prefix and postfix)\\n\\n# Approach\\nTo find distinct elements use set() function and use len() to find length of distinct elements array\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        lst=[]\\n        for i in range(len(nums)):\\n            pre = len(set(nums[0:i+1]))\\n            post = len(set(nums[i+1::]))\\n            lst.append(pre-post)\\n        return lst\\n            \\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        lst=[]\\n        for i in range(len(nums)):\\n            pre = len(set(nums[0:i+1]))\\n            post = len(set(nums[i+1::]))\\n            lst.append(pre-post)\\n        return lst\\n            \\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796359,
                "title": "find-the-distinct-difference-array-by-hashsets",
                "content": "# Intuition\\nmaking two seperate function of prefix and suffix and couting the distict occurence. \\n \\n\\n# Approach\\n making two seperate function of prefix and suffix .\\n\\n# Complexity\\n- Time complexity:\\n  O(N^2)\\n\\n- Space complexity:\\n-  O(N)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public static int[] distinctDifferenceArray(int[] nums) {\\n        int[] numbersArray = new int[nums.length];\\n\\n        for(int i=0 ;i<nums.length;i++){\\n            int sum1 = prefix(nums,i);\\n            int sum2 = suffix(nums,i);\\n            int ans = sum1-sum2;\\n            numbersArray[i]=ans;\\n        }\\n        return numbersArray ;\\n              \\n    }\\n\\n    public static int prefix(int[] nums,int mid){\\n\\n        HashSet<Integer> numbers = new HashSet<>();\\n        int count =0;\\n        for(int i=mid;i>=0;i--){\\n            if(!numbers.contains(nums[i])){\\n\\n                numbers.add(nums[i]);  \\n                count++;   \\n            }\\n        }       \\n        return count;    \\n\\n    }\\n    public static int suffix(int[] nums,int mid){\\n\\n        HashSet<Integer> numbers2 = new HashSet<>();\\n        \\n        int count =0;\\n        for(int i=mid+1;i<nums.length;i++){\\n\\n            if(!numbers2.contains(nums[i])){\\n\\n                numbers2.add(nums[i]);\\n                count++;\\n\\n            }          \\n        }\\n                \\n        return count;\\n\\n}\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int[] distinctDifferenceArray(int[] nums) {\\n        int[] numbersArray = new int[nums.length];\\n\\n        for(int i=0 ;i<nums.length;i++){\\n            int sum1 = prefix(nums,i);\\n            int sum2 = suffix(nums,i);\\n            int ans = sum1-sum2;\\n            numbersArray[i]=ans;\\n        }\\n        return numbersArray ;\\n              \\n    }\\n\\n    public static int prefix(int[] nums,int mid){\\n\\n        HashSet<Integer> numbers = new HashSet<>();\\n        int count =0;\\n        for(int i=mid;i>=0;i--){\\n            if(!numbers.contains(nums[i])){\\n\\n                numbers.add(nums[i]);  \\n                count++;   \\n            }\\n        }       \\n        return count;    \\n\\n    }\\n    public static int suffix(int[] nums,int mid){\\n\\n        HashSet<Integer> numbers2 = new HashSet<>();\\n        \\n        int count =0;\\n        for(int i=mid+1;i<nums.length;i++){\\n\\n            if(!numbers2.contains(nums[i])){\\n\\n                numbers2.add(nums[i]);\\n                count++;\\n\\n            }          \\n        }\\n                \\n        return count;\\n\\n}\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796225,
                "title": "two-dictionaries-80-speed",
                "content": "![image.png](https://assets.leetcode.com/users/images/0f2778b5-beff-4c57-bf3d-10f0bc6eb620_1689931288.902618.png)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        left = defaultdict(int)\\n        right = Counter(nums)\\n        ans = [0] * len(nums)\\n        for i, n in enumerate(nums):\\n            left[n] += 1\\n            right[n] -= 1\\n            if right[n] == 0:\\n                right.pop(n)\\n            ans[i] = len(left) - len(right)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        left = defaultdict(int)\\n        right = Counter(nums)\\n        ans = [0] * len(nums)\\n        for i, n in enumerate(nums):\\n            left[n] += 1\\n            right[n] -= 1\\n            if right[n] == 0:\\n                right.pop(n)\\n            ans[i] = len(left) - len(right)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794001,
                "title": "simple-c-solution-unordered-set-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPush previous elements in a previous_set and leading elements in another set and push their difference of size in a vector.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPush nums\\' elemets from 0 to i(inclusive) in prev (unordered_set) and the other i+1 till nums.size()(exclusive) in ah (another unordered_set). Then push the prev.size()-ah.size() in sol.\\nReturn sol\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        vector<int> sol;\\n        for(int u=0; u<nums.size(); u++){\\n            int i=u, j=u;\\n            unordered_set<int> prev;\\n            unordered_set<int> ah;\\n            for(int k=0; k<=i; k++){\\n                prev.insert(nums[k]);\\n            }for(int k=j+1; k<nums.size(); k++){\\n                ah.insert(nums[k]);\\n            }sol.push_back(prev.size()-ah.size());\\n        }\\n\\n        return sol;\\n    }\\n};\\n```\\n`\\nif(like) upvote++ ;p\\n`",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        vector<int> sol;\\n        for(int u=0; u<nums.size(); u++){\\n            int i=u, j=u;\\n            unordered_set<int> prev;\\n            unordered_set<int> ah;\\n            for(int k=0; k<=i; k++){\\n                prev.insert(nums[k]);\\n            }for(int k=j+1; k<nums.size(); k++){\\n                ah.insert(nums[k]);\\n            }sol.push_back(prev.size()-ah.size());\\n        }\\n\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789724,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {        \\n        Set<Integer> uniqueSet =new HashSet<>();\\n        int n = nums.length -1;\\n        int suffix[] =new int [nums.length];\\n        for(int i = n ; i > 0 ; i--)\\n        {\\n            uniqueSet.add(nums[i]);\\n            suffix[i] = uniqueSet.size();           \\n        }\\n\\n        uniqueSet.clear();\\n        int [] ans = new int [nums.length];\\n        for( int i = 0; i < n ; i++)\\n        {\\n            uniqueSet.add(nums[i]);\\n            ans[i] = uniqueSet.size() - suffix[i + 1];\\n        }\\n        uniqueSet.add(nums[n]);\\n        ans[n] = uniqueSet.size();\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {        \\n        Set<Integer> uniqueSet =new HashSet<>();\\n        int n = nums.length -1;\\n        int suffix[] =new int [nums.length];\\n        for(int i = n ; i > 0 ; i--)\\n        {\\n            uniqueSet.add(nums[i]);\\n            suffix[i] = uniqueSet.size();           \\n        }\\n\\n        uniqueSet.clear();\\n        int [] ans = new int [nums.length];\\n        for( int i = 0; i < n ; i++)\\n        {\\n            uniqueSet.add(nums[i]);\\n            ans[i] = uniqueSet.size() - suffix[i + 1];\\n        }\\n        uniqueSet.add(nums[n]);\\n        ans[n] = uniqueSet.size();\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782151,
                "title": "simple-java-set-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] arr) {\\n        Set s1= new HashSet();\\n\\tSet s2= new HashSet();\\n        int[] arr1= new int[arr.length];\\n        int count=0;\\n        int s=0;\\n        while(s<arr.length) {\\n        \\ts1.clear();\\n        \\ts2.clear();\\n        \\tfor(int i=0;i<=s;i++) {\\n        \\t\\ts1.add(arr[i]);\\n        \\t}\\n        \\tfor(int i=s+1;i<arr.length;i++) {\\n        \\t\\ts2.add(arr[i]);\\n        \\t}\\n        \\tarr1[s]= s1.size()-s2.size();\\n        \\ts++;\\n        }\\n        \\n        return arr1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] arr) {\\n        Set s1= new HashSet();\\n\\tSet s2= new HashSet();\\n        int[] arr1= new int[arr.length];\\n        int count=0;\\n        int s=0;\\n        while(s<arr.length) {\\n        \\ts1.clear();\\n        \\ts2.clear();\\n        \\tfor(int i=0;i<=s;i++) {\\n        \\t\\ts1.add(arr[i]);\\n        \\t}\\n        \\tfor(int i=s+1;i<arr.length;i++) {\\n        \\t\\ts2.add(arr[i]);\\n        \\t}\\n        \\tarr1[s]= s1.size()-s2.size();\\n        \\ts++;\\n        }\\n        \\n        return arr1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781755,
                "title": "find-the-distinct-difference-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int cpre = 0;\\n        int spre = 0;\\n        int[]  arr = new int[nums.length];\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            cpre = distinct(0,i-1,nums);\\n            spre = distinct(i,nums.length-1,nums);\\n            arr[i-1] = cpre-spre;\\n        }\\n        cpre = distinct(0,nums.length-1,nums);\\n        arr[nums.length-1]= cpre-0;\\n        return arr;\\n    }\\n    public int distinct(int i,int j,int[] nums)\\n    {\\n        HashSet<Integer> hm = new HashSet<Integer>();\\n        for(int l=i;l<=j;l++)\\n        {\\n            hm.add(nums[l]);\\n        }\\n        return hm.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int cpre = 0;\\n        int spre = 0;\\n        int[]  arr = new int[nums.length];\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            cpre = distinct(0,i-1,nums);\\n            spre = distinct(i,nums.length-1,nums);\\n            arr[i-1] = cpre-spre;\\n        }\\n        cpre = distinct(0,nums.length-1,nums);\\n        arr[nums.length-1]= cpre-0;\\n        return arr;\\n    }\\n    public int distinct(int i,int j,int[] nums)\\n    {\\n        HashSet<Integer> hm = new HashSet<Integer>();\\n        for(int l=i;l<=j;l++)\\n        {\\n            hm.add(nums[l]);\\n        }\\n        return hm.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775287,
                "title": "java-easy-solution-using-set-referenced-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI got the reference of this code from him.\\n[https://leetcode.com/VIJAY626404/]()\\nThanks.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int diff[] = new int [nums.length];\\n\\n        for(int i=0;i<nums.length;i++){\\n            Set<Integer> prefix=new HashSet<>();\\n            for(int j=0;j<=i;j++){\\n                prefix.add(nums[j]);\\n            }\\n\\n            Set<Integer> suffix=new HashSet<>();\\n            for(int j=i+1;j<nums.length;j++){\\n                suffix.add(nums[j]);\\n            }\\n\\n            diff[i]=prefix.size()-suffix.size();\\n        }\\n        return diff;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int diff[] = new int [nums.length];\\n\\n        for(int i=0;i<nums.length;i++){\\n            Set<Integer> prefix=new HashSet<>();\\n            for(int j=0;j<=i;j++){\\n                prefix.add(nums[j]);\\n            }\\n\\n            Set<Integer> suffix=new HashSet<>();\\n            for(int j=i+1;j<nums.length;j++){\\n                suffix.add(nums[j]);\\n            }\\n\\n            diff[i]=prefix.size()-suffix.size();\\n        }\\n        return diff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775038,
                "title": "python-one-liner-list-comprehension-slicing",
                "content": "# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        return [len(set(nums[:i+1])) - len(set(nums[i+1:])) for i in range(len(nums))]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        return [len(set(nums[:i+1])) - len(set(nums[i+1:])) for i in range(len(nums))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774143,
                "title": "simple-solution-using-hashset",
                "content": "# Intuition\\nSince we want to have a difference of left and right entities of an ith element, it is advisable to maintain two separate arrays one to the left of ith (here ith element is included in left side) and other to the right of ith element to make things simpler and easy to operate on.\\n\\n# Approach\\nSince we want count of unique elements it is intuitive to use a hashset, so use a hashset first from left end and keep storing the result in your leftDis array, similarly do it from right end.\\nAnd finally take the differences in a separate array( you can use either of leftDis or rightDis array also to store final result, you can skip using third array).\\n\\n# Complexity\\n- Time complexity:\\nSince every element is visited twice at max.\\nTC is 2*n which is O(N).\\n\\n- Space complexity:\\nWe have used 2 or 3 arrays of N size.\\nSo space complexity also becomes O(N).\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n       HashSet<Integer> hs = new HashSet<>();\\n       int[] leftDis = new int[nums.length];\\n       int[] rightDis = new int[nums.length];\\n\\n       for(int i=0; i<nums.length; i++){\\n           hs.add(nums[i]);\\n           leftDis[i]=hs.size();\\n        }\\n\\n        //refresh the same array as a new one for rightside.\\n        hs = new HashSet<Integer>();\\n\\n        hs.add(nums[nums.length-1]);\\n\\n        for(int i=nums.length-2; i>=0; i--){\\n            rightDis[i]=hs.size();\\n            hs.add(nums[i]);            \\n        }\\n\\n        int[] ans = new int[nums.length];\\n\\n        for(int i=0; i<nums.length; i++){\\n            ans[i]=leftDis[i]-rightDis[i];\\n        }\\n\\n        return ans; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n       HashSet<Integer> hs = new HashSet<>();\\n       int[] leftDis = new int[nums.length];\\n       int[] rightDis = new int[nums.length];\\n\\n       for(int i=0; i<nums.length; i++){\\n           hs.add(nums[i]);\\n           leftDis[i]=hs.size();\\n        }\\n\\n        //refresh the same array as a new one for rightside.\\n        hs = new HashSet<Integer>();\\n\\n        hs.add(nums[nums.length-1]);\\n\\n        for(int i=nums.length-2; i>=0; i--){\\n            rightDis[i]=hs.size();\\n            hs.add(nums[i]);            \\n        }\\n\\n        int[] ans = new int[nums.length];\\n\\n        for(int i=0; i<nums.length; i++){\\n            ans[i]=leftDis[i]-rightDis[i];\\n        }\\n\\n        return ans; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773527,
                "title": "simple-and-easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        res=[]\\n        difference=0\\n        for i in range(len(nums)):\\n            difference = len(set(nums[:i + 1]))-len(set(nums[i + 1:]))\\n            res.append(difference)\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        res=[]\\n        difference=0\\n        for i in range(len(nums)):\\n            difference = len(set(nums[:i + 1]))-len(set(nums[i + 1:]))\\n            res.append(difference)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3770766,
                "title": "c-clean-and-easy-solution",
                "content": "We use 2 arrasy to record the prefix disctinct and suffix distinct for each.\\nTo do that, we simply use 2 maps to do that.\\n\\n\\'\\'\\'\\n\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> res(n), pre(n), suff(n);\\n        map<int, int> p, s;\\n        // build the prefix array first;\\n        for (int i=0; i<nums.size(); ++i) {\\n            p[nums[i]]++;\\n            pre[i] = p.size();\\n        }\\n        // build the suffix array first;\\n        for (int i=nums.size()-1; i>=0; --i) {\\n            suff[i] = s.size();\\n            s[nums[i]]++;\\n        }\\n        // now, build the result;\\n        for (int i=0; i<nums.size(); ++i) {\\n            res[i] = pre[i] - suff[i];\\n        }\\n        \\n        return res;\\n    }\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "We use 2 arrasy to record the prefix disctinct and suffix distinct for each.\\nTo do that, we simply use 2 maps to do that.\\n\\n\\'\\'\\'\\n\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> res(n), pre(n), suff(n);\\n        map<int, int> p, s;\\n        // build the prefix array first;\\n        for (int i=0; i<nums.size(); ++i) {\\n            p[nums[i]]++;\\n            pre[i] = p.size();\\n        }\\n        // build the suffix array first;\\n        for (int i=nums.size()-1; i>=0; --i) {\\n            suff[i] = s.size();\\n            s[nums[i]]++;\\n        }\\n        // now, build the result;\\n        for (int i=0; i<nums.size(); ++i) {\\n            res[i] = pre[i] - suff[i];\\n        }\\n        \\n        return res;\\n    }\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 3766523,
                "title": "simple-javascript-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar distinctDifferenceArray = function(nums) {\\n    let result = []\\n    for (let i = 0; i < nums.length; i++) {\\n      const leading = nums.slice(0, i + 1)\\n      const trailing = nums.slice(i + 1)\\n      result.push(new Set(leading).size - new Set(trailing).size)\\n    }\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar distinctDifferenceArray = function(nums) {\\n    let result = []\\n    for (let i = 0; i < nums.length; i++) {\\n      const leading = nums.slice(0, i + 1)\\n      const trailing = nums.slice(i + 1)\\n      result.push(new Set(leading).size - new Set(trailing).size)\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3761735,
                "title": "java-o-n-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n        if(map.containsKey(nums[i])){\\n            map.put(nums[i], map.get(nums[i])+1);\\n        }else{\\n            map.put(nums[i], 1);\\n        }\\n        }\\n        int[] ans = new int[nums.length];\\n        HashMap<Integer, Integer> prefix = new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            //adding current element to prefix\\n            if(prefix.containsKey(nums[i])){\\n                prefix.put(nums[i], prefix.get(nums[i])+1);\\n            }else{\\n                prefix.put(nums[i], 1);\\n            }\\n            // removing current element from suffix\\n            if(map.get(nums[i]) == 1){\\n                map.remove(nums[i]);\\n            }else{\\n                map.put(nums[i], map.get(nums[i]) - 1);\\n            }\\n            // take difference\\n            ans[i] = prefix.size()-map.size();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n        if(map.containsKey(nums[i])){\\n            map.put(nums[i], map.get(nums[i])+1);\\n        }else{\\n            map.put(nums[i], 1);\\n        }\\n        }\\n        int[] ans = new int[nums.length];\\n        HashMap<Integer, Integer> prefix = new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            //adding current element to prefix\\n            if(prefix.containsKey(nums[i])){\\n                prefix.put(nums[i], prefix.get(nums[i])+1);\\n            }else{\\n                prefix.put(nums[i], 1);\\n            }\\n            // removing current element from suffix\\n            if(map.get(nums[i]) == 1){\\n                map.remove(nums[i]);\\n            }else{\\n                map.put(nums[i], map.get(nums[i]) - 1);\\n            }\\n            // take difference\\n            ans[i] = prefix.size()-map.size();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757255,
                "title": "very-very-easy-jebasraja",
                "content": "# Intuition:\\u2764\\uFE0FKARUNYA UNIVERSITY::ACCENTURE\\u2764\\uFE0F\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int[] distinctDifferenceArray(int[] nums) \\n    {\\n        HashSet<Integer> set = new HashSet<>();\\n\\t\\n\\t \\n\\t \\n\\t int numberofdistinct=0;\\n\\t \\n\\t int[] prefix=new int[nums.length];\\n\\t int[] suffix=new int[nums.length];\\n\\t //prefix\\n\\t for (int i=0;i<nums.length;i++ ) \\n\\t  {\\n\\t    for (int j=0;j<=i;j++)\\n\\t    {\\n\\t           if (set.contains(nums[j])==true)\\n\\t           {\\n\\t               \\n\\t           }\\n\\t           else\\n\\t           {\\n\\t              numberofdistinct++;\\n\\t              set.add(nums[j]);\\n\\t           }\\n\\t           \\n\\t    }\\n\\t    prefix[i]=numberofdistinct;\\n\\t    numberofdistinct=0;\\n\\t    set.clear();\\n\\t  }\\n\\t  numberofdistinct=0;\\n\\t  set.clear();\\n\\t  \\n\\t  \\n\\t  //SUFFIX\\n\\t  for (int i=0;i<nums.length;i++)\\n\\t  {\\n\\t      for (int j=i+1;j<nums.length;j++)\\n\\t      {\\n\\t          if (set.contains(nums[j])==true)\\n\\t           {\\n\\t               \\n\\t           }\\n\\t           else\\n\\t           {\\n\\t               numberofdistinct++;\\n\\t               set.add(nums[j]);\\n\\t           }\\n\\t      }\\n\\t     suffix[i]=numberofdistinct; \\n\\t    numberofdistinct=0;\\n\\t    set.clear();   \\n\\t  }\\n\\t  \\n\\t  \\n\\t  \\n\\t// System.out.println(\"_______prefix output__________\");\\n\\t  for (int k=0;k<prefix.length;k++)\\n\\t  {\\n\\t     // System.out.println(\"prefix \"+prefix[k]+\"suffix \"+suffix[k]);\\n\\t  \\n\\t     nums[k]= prefix[k]-suffix[k];\\n\\t  }\\n\\t\\n   return nums;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int[] distinctDifferenceArray(int[] nums) \\n    {\\n        HashSet<Integer> set = new HashSet<>();\\n\\t\\n\\t \\n\\t \\n\\t int numberofdistinct=0;\\n\\t \\n\\t int[] prefix=new int[nums.length];\\n\\t int[] suffix=new int[nums.length];\\n\\t //prefix\\n\\t for (int i=0;i<nums.length;i++ ) \\n\\t  {\\n\\t    for (int j=0;j<=i;j++)\\n\\t    {\\n\\t           if (set.contains(nums[j])==true)\\n\\t           {\\n\\t               \\n\\t           }\\n\\t           else\\n\\t           {\\n\\t              numberofdistinct++;\\n\\t              set.add(nums[j]);\\n\\t           }\\n\\t           \\n\\t    }\\n\\t    prefix[i]=numberofdistinct;\\n\\t    numberofdistinct=0;\\n\\t    set.clear();\\n\\t  }\\n\\t  numberofdistinct=0;\\n\\t  set.clear();\\n\\t  \\n\\t  \\n\\t  //SUFFIX\\n\\t  for (int i=0;i<nums.length;i++)\\n\\t  {\\n\\t      for (int j=i+1;j<nums.length;j++)\\n\\t      {\\n\\t          if (set.contains(nums[j])==true)\\n\\t           {\\n\\t               \\n\\t           }\\n\\t           else\\n\\t           {\\n\\t               numberofdistinct++;\\n\\t               set.add(nums[j]);\\n\\t           }\\n\\t      }\\n\\t     suffix[i]=numberofdistinct; \\n\\t    numberofdistinct=0;\\n\\t    set.clear();   \\n\\t  }\\n\\t  \\n\\t  \\n\\t  \\n\\t// System.out.println(\"_______prefix output__________\");\\n\\t  for (int k=0;k<prefix.length;k++)\\n\\t  {\\n\\t     // System.out.println(\"prefix \"+prefix[k]+\"suffix \"+suffix[k]);\\n\\t  \\n\\t     nums[k]= prefix[k]-suffix[k];\\n\\t  }\\n\\t\\n   return nums;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753131,
                "title": "easiest-code-using-set",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> ans(n);\\n\\n        set<int> s;\\n        for(int i=0; i<nums.size(); i++){\\n            s.insert(nums[i]);\\n\\n            set<int> s2;\\n            for(int j=n-1; j>i; j--){\\n                s2.insert(nums[j]);\\n            }\\n\\n            ans[i] = s.size() - s2.size();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> ans(n);\\n\\n        set<int> s;\\n        for(int i=0; i<nums.size(); i++){\\n            s.insert(nums[i]);\\n\\n            set<int> s2;\\n            for(int j=n-1; j>i; j--){\\n                s2.insert(nums[j]);\\n            }\\n\\n            ans[i] = s.size() - s2.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1889359,
                "content": [
                    {
                        "username": "assassinyogesh",
                        "content": "i dont know is example 2 is wrong here  "
                    },
                    {
                        "username": "LukeGirvan",
                        "content": "its distinct elements so you must use a set to eliminate duplicates otherwise all answers for arrays of length 5 would have to be [-3,-1,1,3,5]. "
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "In the input\\n\\nnums = [3,2,3,4,2]\\n\\nFor index i = 3, there are 3 distinct elements in the prefix and 1 distinct element in the suffix. Thus, diff[3] = 3 - 1 = 2.\\n\\nhow for i = 3 there are 3 distinct elements before i = 3 there is [3,2,3] so distinct element should be 2 right \\n\\nor am i missing something here?\\n"
                    },
                    {
                        "username": "daujo3036",
                        "content": "i is inclusive here... so 3,2,3 & 4 will also be considered."
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yes, You are right."
                    },
                    {
                        "username": "mohitdbst",
                        "content": "bro , here if you notice the test cases clearly you can observe  that when we are counting or making array of distinct for prefix we are counting the element first and then adding that in the prefix array, where as when we are doing the same activity for suffix we are adding the count of distinct elements so far first and then considering the element on the current index. that\\'s y it\\'s happening like this. \\nyou can refer my sol. below:\\n\\nvector<int> distinctDifferenceArray(vector<int>& nums) {\\n        vector<int>pre;\\n        unordered_map<int,int>mp;\\n        for(auto e:nums){\\n            mp[e]++;\\n            pre.push_back(mp.size());\\n        }\\n        mp.clear();\\n        vector<int>suf(nums.size());\\n        for(int i = nums.size()-1;i>=0;i--){\\n            int e = nums[i];\\n            suf[i] = mp.size();\\n            mp[e]++;\\n        }\\n\\n        vector<int>ans;\\n        for(int i = 0;i<nums.size();i++){\\n            ans.push_back(pre[i]-suf[i]);\\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "amitjha00",
                        "content": " as mentioned in the question we have to count distinct element for prefix from 0 index to i index not i-1 index so the distinct element for index 3 in prefix are [3 2 4].\n\nAnd for suffix we have to count distinct element from i+1 index (means 4th index) to last index so the suffix are [2] for index 3.\n\nso 3-1 = 2. "
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@Shubham Kumar](/walkytalkyshubham) In prefix we count all the elements preceeding as well as the element itself but in suffix only the suceeding elements. So, for index 3 in [3,2,3,4,2], we have only 3 elements in prefix [3,2,3,4] and only 1 in suffix [2]. So diff is 3 - 1 = 2. Hope it helps!"
                    },
                    {
                        "username": "Rivo11",
                        "content": "I did a for loop and i used Len function inside it ..to get the length of the set in the left and righ ..so the complexity is o(n^2) typically but i get a very high time effiency approx to 100% in time ... so my question can i solve it in only one path o(n) ?"
                    },
                    {
                        "username": "mohitdbst",
                        "content": " here if you notice the test cases clearly you can observe that when we are counting or making array of distinct for prefix we are counting the element first and then adding that in the prefix array, where as when we are doing the same activity for suffix we are adding the count of distinct elements so far first and then considering the element on the current index. that's y it's happening like this.\nyou can refer my sol. below:\n\n `    vector<int> distinctDifferenceArray(vector<int>& nums) {\n        vector<int>pre;\n        unordered_map<int,int>mp;\n        for(auto e:nums){\n            mp[e]++;\n            pre.push_back(mp.size());\n        }\n        mp.clear();\n        vector<int>suf(nums.size());\n        for(int i = nums.size()-1;i>=0;i--){\n            int e = nums[i];\n            suf[i] = mp.size();\n            mp[e]++;\n        }\n        vector<int>ans;\n        for(int i = 0;i<nums.size();i++){\n            ans.push_back(pre[i]-suf[i]);\n        }\n        return ans;\n    }`\n\nJust add a new line after every semicolon"
                    }
                ]
            },
            {
                "id": 1886840,
                "content": [
                    {
                        "username": "assassinyogesh",
                        "content": "i dont know is example 2 is wrong here  "
                    },
                    {
                        "username": "LukeGirvan",
                        "content": "its distinct elements so you must use a set to eliminate duplicates otherwise all answers for arrays of length 5 would have to be [-3,-1,1,3,5]. "
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "In the input\\n\\nnums = [3,2,3,4,2]\\n\\nFor index i = 3, there are 3 distinct elements in the prefix and 1 distinct element in the suffix. Thus, diff[3] = 3 - 1 = 2.\\n\\nhow for i = 3 there are 3 distinct elements before i = 3 there is [3,2,3] so distinct element should be 2 right \\n\\nor am i missing something here?\\n"
                    },
                    {
                        "username": "daujo3036",
                        "content": "i is inclusive here... so 3,2,3 & 4 will also be considered."
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yes, You are right."
                    },
                    {
                        "username": "mohitdbst",
                        "content": "bro , here if you notice the test cases clearly you can observe  that when we are counting or making array of distinct for prefix we are counting the element first and then adding that in the prefix array, where as when we are doing the same activity for suffix we are adding the count of distinct elements so far first and then considering the element on the current index. that\\'s y it\\'s happening like this. \\nyou can refer my sol. below:\\n\\nvector<int> distinctDifferenceArray(vector<int>& nums) {\\n        vector<int>pre;\\n        unordered_map<int,int>mp;\\n        for(auto e:nums){\\n            mp[e]++;\\n            pre.push_back(mp.size());\\n        }\\n        mp.clear();\\n        vector<int>suf(nums.size());\\n        for(int i = nums.size()-1;i>=0;i--){\\n            int e = nums[i];\\n            suf[i] = mp.size();\\n            mp[e]++;\\n        }\\n\\n        vector<int>ans;\\n        for(int i = 0;i<nums.size();i++){\\n            ans.push_back(pre[i]-suf[i]);\\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "amitjha00",
                        "content": " as mentioned in the question we have to count distinct element for prefix from 0 index to i index not i-1 index so the distinct element for index 3 in prefix are [3 2 4].\n\nAnd for suffix we have to count distinct element from i+1 index (means 4th index) to last index so the suffix are [2] for index 3.\n\nso 3-1 = 2. "
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@Shubham Kumar](/walkytalkyshubham) In prefix we count all the elements preceeding as well as the element itself but in suffix only the suceeding elements. So, for index 3 in [3,2,3,4,2], we have only 3 elements in prefix [3,2,3,4] and only 1 in suffix [2]. So diff is 3 - 1 = 2. Hope it helps!"
                    },
                    {
                        "username": "Rivo11",
                        "content": "I did a for loop and i used Len function inside it ..to get the length of the set in the left and righ ..so the complexity is o(n^2) typically but i get a very high time effiency approx to 100% in time ... so my question can i solve it in only one path o(n) ?"
                    },
                    {
                        "username": "mohitdbst",
                        "content": " here if you notice the test cases clearly you can observe that when we are counting or making array of distinct for prefix we are counting the element first and then adding that in the prefix array, where as when we are doing the same activity for suffix we are adding the count of distinct elements so far first and then considering the element on the current index. that's y it's happening like this.\nyou can refer my sol. below:\n\n `    vector<int> distinctDifferenceArray(vector<int>& nums) {\n        vector<int>pre;\n        unordered_map<int,int>mp;\n        for(auto e:nums){\n            mp[e]++;\n            pre.push_back(mp.size());\n        }\n        mp.clear();\n        vector<int>suf(nums.size());\n        for(int i = nums.size()-1;i>=0;i--){\n            int e = nums[i];\n            suf[i] = mp.size();\n            mp[e]++;\n        }\n        vector<int>ans;\n        for(int i = 0;i<nums.size();i++){\n            ans.push_back(pre[i]-suf[i]);\n        }\n        return ans;\n    }`\n\nJust add a new line after every semicolon"
                    }
                ]
            },
            {
                "id": 2056019,
                "content": [
                    {
                        "username": "assassinyogesh",
                        "content": "i dont know is example 2 is wrong here  "
                    },
                    {
                        "username": "LukeGirvan",
                        "content": "its distinct elements so you must use a set to eliminate duplicates otherwise all answers for arrays of length 5 would have to be [-3,-1,1,3,5]. "
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "In the input\\n\\nnums = [3,2,3,4,2]\\n\\nFor index i = 3, there are 3 distinct elements in the prefix and 1 distinct element in the suffix. Thus, diff[3] = 3 - 1 = 2.\\n\\nhow for i = 3 there are 3 distinct elements before i = 3 there is [3,2,3] so distinct element should be 2 right \\n\\nor am i missing something here?\\n"
                    },
                    {
                        "username": "daujo3036",
                        "content": "i is inclusive here... so 3,2,3 & 4 will also be considered."
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yes, You are right."
                    },
                    {
                        "username": "mohitdbst",
                        "content": "bro , here if you notice the test cases clearly you can observe  that when we are counting or making array of distinct for prefix we are counting the element first and then adding that in the prefix array, where as when we are doing the same activity for suffix we are adding the count of distinct elements so far first and then considering the element on the current index. that\\'s y it\\'s happening like this. \\nyou can refer my sol. below:\\n\\nvector<int> distinctDifferenceArray(vector<int>& nums) {\\n        vector<int>pre;\\n        unordered_map<int,int>mp;\\n        for(auto e:nums){\\n            mp[e]++;\\n            pre.push_back(mp.size());\\n        }\\n        mp.clear();\\n        vector<int>suf(nums.size());\\n        for(int i = nums.size()-1;i>=0;i--){\\n            int e = nums[i];\\n            suf[i] = mp.size();\\n            mp[e]++;\\n        }\\n\\n        vector<int>ans;\\n        for(int i = 0;i<nums.size();i++){\\n            ans.push_back(pre[i]-suf[i]);\\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "amitjha00",
                        "content": " as mentioned in the question we have to count distinct element for prefix from 0 index to i index not i-1 index so the distinct element for index 3 in prefix are [3 2 4].\n\nAnd for suffix we have to count distinct element from i+1 index (means 4th index) to last index so the suffix are [2] for index 3.\n\nso 3-1 = 2. "
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@Shubham Kumar](/walkytalkyshubham) In prefix we count all the elements preceeding as well as the element itself but in suffix only the suceeding elements. So, for index 3 in [3,2,3,4,2], we have only 3 elements in prefix [3,2,3,4] and only 1 in suffix [2]. So diff is 3 - 1 = 2. Hope it helps!"
                    },
                    {
                        "username": "Rivo11",
                        "content": "I did a for loop and i used Len function inside it ..to get the length of the set in the left and righ ..so the complexity is o(n^2) typically but i get a very high time effiency approx to 100% in time ... so my question can i solve it in only one path o(n) ?"
                    },
                    {
                        "username": "mohitdbst",
                        "content": " here if you notice the test cases clearly you can observe that when we are counting or making array of distinct for prefix we are counting the element first and then adding that in the prefix array, where as when we are doing the same activity for suffix we are adding the count of distinct elements so far first and then considering the element on the current index. that's y it's happening like this.\nyou can refer my sol. below:\n\n `    vector<int> distinctDifferenceArray(vector<int>& nums) {\n        vector<int>pre;\n        unordered_map<int,int>mp;\n        for(auto e:nums){\n            mp[e]++;\n            pre.push_back(mp.size());\n        }\n        mp.clear();\n        vector<int>suf(nums.size());\n        for(int i = nums.size()-1;i>=0;i--){\n            int e = nums[i];\n            suf[i] = mp.size();\n            mp[e]++;\n        }\n        vector<int>ans;\n        for(int i = 0;i<nums.size();i++){\n            ans.push_back(pre[i]-suf[i]);\n        }\n        return ans;\n    }`\n\nJust add a new line after every semicolon"
                    }
                ]
            },
            {
                "id": 1889757,
                "content": [
                    {
                        "username": "assassinyogesh",
                        "content": "i dont know is example 2 is wrong here  "
                    },
                    {
                        "username": "LukeGirvan",
                        "content": "its distinct elements so you must use a set to eliminate duplicates otherwise all answers for arrays of length 5 would have to be [-3,-1,1,3,5]. "
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "In the input\\n\\nnums = [3,2,3,4,2]\\n\\nFor index i = 3, there are 3 distinct elements in the prefix and 1 distinct element in the suffix. Thus, diff[3] = 3 - 1 = 2.\\n\\nhow for i = 3 there are 3 distinct elements before i = 3 there is [3,2,3] so distinct element should be 2 right \\n\\nor am i missing something here?\\n"
                    },
                    {
                        "username": "daujo3036",
                        "content": "i is inclusive here... so 3,2,3 & 4 will also be considered."
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yes, You are right."
                    },
                    {
                        "username": "mohitdbst",
                        "content": "bro , here if you notice the test cases clearly you can observe  that when we are counting or making array of distinct for prefix we are counting the element first and then adding that in the prefix array, where as when we are doing the same activity for suffix we are adding the count of distinct elements so far first and then considering the element on the current index. that\\'s y it\\'s happening like this. \\nyou can refer my sol. below:\\n\\nvector<int> distinctDifferenceArray(vector<int>& nums) {\\n        vector<int>pre;\\n        unordered_map<int,int>mp;\\n        for(auto e:nums){\\n            mp[e]++;\\n            pre.push_back(mp.size());\\n        }\\n        mp.clear();\\n        vector<int>suf(nums.size());\\n        for(int i = nums.size()-1;i>=0;i--){\\n            int e = nums[i];\\n            suf[i] = mp.size();\\n            mp[e]++;\\n        }\\n\\n        vector<int>ans;\\n        for(int i = 0;i<nums.size();i++){\\n            ans.push_back(pre[i]-suf[i]);\\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "amitjha00",
                        "content": " as mentioned in the question we have to count distinct element for prefix from 0 index to i index not i-1 index so the distinct element for index 3 in prefix are [3 2 4].\n\nAnd for suffix we have to count distinct element from i+1 index (means 4th index) to last index so the suffix are [2] for index 3.\n\nso 3-1 = 2. "
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@Shubham Kumar](/walkytalkyshubham) In prefix we count all the elements preceeding as well as the element itself but in suffix only the suceeding elements. So, for index 3 in [3,2,3,4,2], we have only 3 elements in prefix [3,2,3,4] and only 1 in suffix [2]. So diff is 3 - 1 = 2. Hope it helps!"
                    },
                    {
                        "username": "Rivo11",
                        "content": "I did a for loop and i used Len function inside it ..to get the length of the set in the left and righ ..so the complexity is o(n^2) typically but i get a very high time effiency approx to 100% in time ... so my question can i solve it in only one path o(n) ?"
                    },
                    {
                        "username": "mohitdbst",
                        "content": " here if you notice the test cases clearly you can observe that when we are counting or making array of distinct for prefix we are counting the element first and then adding that in the prefix array, where as when we are doing the same activity for suffix we are adding the count of distinct elements so far first and then considering the element on the current index. that's y it's happening like this.\nyou can refer my sol. below:\n\n `    vector<int> distinctDifferenceArray(vector<int>& nums) {\n        vector<int>pre;\n        unordered_map<int,int>mp;\n        for(auto e:nums){\n            mp[e]++;\n            pre.push_back(mp.size());\n        }\n        mp.clear();\n        vector<int>suf(nums.size());\n        for(int i = nums.size()-1;i>=0;i--){\n            int e = nums[i];\n            suf[i] = mp.size();\n            mp[e]++;\n        }\n        vector<int>ans;\n        for(int i = 0;i<nums.size();i++){\n            ans.push_back(pre[i]-suf[i]);\n        }\n        return ans;\n    }`\n\nJust add a new line after every semicolon"
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum OR",
        "question_content": "<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> of length <code>n</code> and an integer <code>k</code>. In an operation, you can choose an element and multiply it by <code>2</code>.</p>\n\n<p>Return <em>the maximum possible value of </em><code>nums[0] | nums[1] | ... | nums[n - 1]</code> <em>that can be obtained after applying the operation on nums at most </em><code>k</code><em> times</em>.</p>\n\n<p>Note that <code>a | b</code> denotes the <strong>bitwise or</strong> between two integers <code>a</code> and <code>b</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [12,9], k = 1\n<strong>Output:</strong> 30\n<strong>Explanation:</strong> If we apply the operation to index 1, our new array nums will be equal to [12,18]. Thus, we return the bitwise or of 12 and 18, which is 30.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [8,1,2], k = 2\n<strong>Output:</strong> 35\n<strong>Explanation:</strong> If we apply the operation twice on index 0, we yield a new array of [32,1,2]. Thus, we return 32|1|2 = 35.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 15</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3520285,
                "title": "easiest-solution-prefix-suffix-c",
                "content": "#### IMPORTANT\\nYou can watch the biggest sliding window series on entire internet just using single template by clicking my profile icon and checking my youtube channel link from the bio. ( I bet you can solve any sliding window question on leetcode after watching the series do share you thoughts on the same.)\\nThankyou and happy leetcoding. \\n## **INTUTION:**\\n* Just calculate prefix OR (at each index prefix OR will contain OR of all its previous element) and suffix OR ( at each index suffix OR will contain OR of all its next elements.)\\n\\n* Now if you are lets say standing at current position then you have to find maximum OR value of taking\\nOR of each value but after apply operation (multiply by 2 k times) then you have OR value of all elements\\njust before of this current index is in prefix array and OR value of all element next to this index in suffix array.\\n\\n* So just check current number by multiplying by 2k times that whether it is generating maximum answer.\\n\\n#### **Let\\'s take the test case: [12,9] and k=1**\\n   Prefix is: 0 12 13 \\n   Suffix is: 13 9 0 \\n   P= 2  (P=2*K)\\n   \\n   On calculating --> \\n \\n**for (int i = 0; i < n; i++) {\\n        res = max(res, pre[i] | (nums[i] * p) | suf[i + 1]); \\n\\t\\t// res=max(res,(OR of all numbers before this index) * (current num multiplied with 2k times) * OR of all number after this index) //\\n    }**\\n\\t\\n  res= 0 If current num is multiped by 2 k times then answer will be= 25\\n  res= 25 If current num is multiped by 2 k times then answer will be= 30\\n  \\n####  **Let\\'s take the test case: [8,1,2] and k=2**\\n  Prefix is: 0 8 9 11 \\n Suffix is: 11 3 2 0 \\n P= 4  (P=2*k)\\n \\n   On calculating --> \\n \\n**for (int i = 0; i < n; i++) {\\n        res = max(res, pre[i] | (nums[i] * p) | suf[i + 1]);\\n    }**\\n res= 0 If current num is multiped by 2 k times then answer will be= 35\\n res= 35 If current num is multiped by 2 k times then answer will be= 14\\n res= 35 If current num is multiped by 2 k times then answer will be= 9\\n\\nso take maximum res value as answer.\\n\\n**NOTE\\uD83D\\uDCDD:**  Some people are confused that whe multiply only current number with 2k times. It may be possible that we can get max answer by spreading multiply of 2 means you can multiply by 2 with multiple numbers why only to just one number.\\n \\n Dear your doubt is genuine but let you think that when we get maximum OR value\\n \\n* OR value is directly proportional to the  greater we have a number. \\n\\n* Now suppose nums=[8,1,2] and k=2 if you think that instead of multiplying by 2k times you can multiply other numbers also means multiply one 2 by 8 another 2 by other number from 1 and 2 but you are wrong here you have to think critically here that I am raising each number to its maximum value by multiplying by 2k times and i am doing it for each number so the number which is generating maximum OR will be our final answer.\\n\\n* Actually 2k is also a number and we can maximise OR value if this 2k value is making a number maximum in our array.\\n\\t\\n\\n```\\nlong long maximumOr(vector<int>& nums, int k) {\\n    int n = nums.size();\\n    vector<long long> pre(n + 1, 0); // Stores prefix bitwise OR values\\n    vector<long long> suf(n + 1, 0); // Stores suffix bitwise OR values\\n    pre[0] = 0;\\n    suf[n] = 0;\\n    long long res = 0;\\n    long long p = 1; // Used to calculate the power of 2, equivalent to x^k\\n    p = p << k; // Left shift k positions to calculate 2^k\\n\\n    // Calculate prefix bitwise OR values\\n    for (int i = 0; i < n; i++) {\\n        pre[i + 1] = pre[i] | nums[i];\\n    }\\n\\n    // Calculate suffix bitwise OR values\\n    for (int i = n - 1; i >= 0; i--) {\\n        suf[i] = suf[i + 1] | nums[i];\\n    }\\n\\n    // Find the maximum result by iterating through the numbers\\n    for (int i = 0; i < n; i++) {\\n//\\tcout<<\"res= \"<<res<< \" If current num is multiped by 2 k times then answer will be= \"<<(pre[i] | (nums[i] * p) | suf[i + 1])<<endl; \\n        res = max(res, pre[i] | (nums[i] * p) | suf[i + 1]);\\n    }\\n\\n    return res;\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nlong long maximumOr(vector<int>& nums, int k) {\\n    int n = nums.size();\\n    vector<long long> pre(n + 1, 0); // Stores prefix bitwise OR values\\n    vector<long long> suf(n + 1, 0); // Stores suffix bitwise OR values\\n    pre[0] = 0;\\n    suf[n] = 0;\\n    long long res = 0;\\n    long long p = 1; // Used to calculate the power of 2, equivalent to x^k\\n    p = p << k; // Left shift k positions to calculate 2^k\\n\\n    // Calculate prefix bitwise OR values\\n    for (int i = 0; i < n; i++) {\\n        pre[i + 1] = pre[i] | nums[i];\\n    }\\n\\n    // Calculate suffix bitwise OR values\\n    for (int i = n - 1; i >= 0; i--) {\\n        suf[i] = suf[i + 1] | nums[i];\\n    }\\n\\n    // Find the maximum result by iterating through the numbers\\n    for (int i = 0; i < n; i++) {\\n//\\tcout<<\"res= \"<<res<< \" If current num is multiped by 2 k times then answer will be= \"<<(pre[i] | (nums[i] * p) | suf[i + 1])<<endl; \\n        res = max(res, pre[i] | (nums[i] * p) | suf[i + 1]);\\n    }\\n\\n    return res;\\n}\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3520412,
                "title": "explained-very-simple-easy-to-understand-solution",
                "content": "<b>Up vote if you like the solution </b>\\n# Approach \\n1. Evaluate 2^k\\n2. Then calculate prefix & suffix bit wise value and store it\\n3. check each number by multiplying 2^k, if it has max ans or not.\\n\\nQ. Why this works :\\nAns :  When we multiply a number by 2 then this equal to shifting the values to the left by 1 places. \\nSo to have a largest value we should shift a single number to the k number of times which end up with max value possible.\\nnow we don\\'t know exactly which value to shift k times, so we check the same for all possible numbers and keep tracking the max value.\\n\\n# Code\\n```\\n\\n    long long maximumOr(vector<int>& nums, int k) {\\n        long long ans = 0, mul = 1;\\n        vector<long long> pre(nums.size(), 0), suf(nums.size(), 0);\\n        pre[0] = nums[0]; suf[nums.size()-1] = nums.back();\\n        for( int i = 1; i < nums.size(); ++i) {\\n            pre[i] = pre[i-1] | nums[i];\\n            suf[nums.size() - i - 1] = suf[nums.size()-i] | nums[nums.size() - i - 1];\\n        }\\n        for(int i = 0; i < k; ++i){ mul *= 2; }\\n        for(int i = 0; i < nums.size(); ++i){\\n            long long x = nums[i]*mul;\\n            if(i-1 >= 0) x = x | pre[i-1];\\n            if(i+1 < nums.size()) x = x | suf[i+1];\\n            ans = max(ans, x);\\n        }\\n        return ans;\\n    }\\n\\n```\\n\\n<b> Here is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n    long long maximumOr(vector<int>& nums, int k) {\\n        long long ans = 0, mul = 1;\\n        vector<long long> pre(nums.size(), 0), suf(nums.size(), 0);\\n        pre[0] = nums[0]; suf[nums.size()-1] = nums.back();\\n        for( int i = 1; i < nums.size(); ++i) {\\n            pre[i] = pre[i-1] | nums[i];\\n            suf[nums.size() - i - 1] = suf[nums.size()-i] | nums[nums.size() - i - 1];\\n        }\\n        for(int i = 0; i < k; ++i){ mul *= 2; }\\n        for(int i = 0; i < nums.size(); ++i){\\n            long long x = nums[i]*mul;\\n            if(i-1 >= 0) x = x | pre[i-1];\\n            if(i+1 < nums.size()) x = x | suf[i+1];\\n            ans = max(ans, x);\\n        }\\n        return ans;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3520589,
                "title": "java-c-python-easy-one-pass",
                "content": "# **Intuition**\\nThe best plan is to double the same number `k` times\\nthis will shift the leftmost bit to left `k` bits.\\n<br>\\n\\n# **Explanation**\\n`right[i] = A[i + 1] * A[i + 2] * ... * A[n - 1]`\\n`left[i] = A[0] * A[1] * ... * A[i - 1]`\\n\\nSo the result for doubling `A[i]` is\\n`left[i] | A[i] << k | right[i]`.\\n\\nOne pass `A` and return the result.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\n```java\\n    public long maximumOr(int[] A, int k) {\\n        int n = A.length, right[] = new int[n], left = 0;\\n        long res = 0;\\n        for (int i = n - 2; i >= 0; --i) {\\n            right[i] = right[i + 1] | A[i + 1];\\n        }\\n        for (int i = 0; i < n; i++) {\\n            res = Math.max(res, left | (long)A[i] << k | right[i]);\\n            left |= A[i];\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    long long maximumOr(vector<int> &A, int k) {\\n        int n = A.size(), left = 0;\\n        vector<int> right(n);\\n        long res = 0;\\n        for (int i = n - 2; i >= 0; --i) {\\n            right[i] = right[i + 1] | A[i + 1];\\n        }\\n        for (int i = 0; i < n; i++) {\\n            res = max(res, left | (long)A[i] << k | right[i]);\\n            left |= A[i];\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def maximumOr(self, A: List[int], k: int) -> int:\\n        res, left, n = 0, 0, len(A)\\n        right = [0] * n\\n        for i in range(n - 2, -1, -1):\\n            right[i] = right[i + 1] | A[i + 1]\\n        for i in range(n):\\n            res = max(res, left | A[i] << k | right[i])\\n            left |= A[i]\\n        return res\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public long maximumOr(int[] A, int k) {\\n        int n = A.length, right[] = new int[n], left = 0;\\n        long res = 0;\\n        for (int i = n - 2; i >= 0; --i) {\\n            right[i] = right[i + 1] | A[i + 1];\\n        }\\n        for (int i = 0; i < n; i++) {\\n            res = Math.max(res, left | (long)A[i] << k | right[i]);\\n            left |= A[i];\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    long long maximumOr(vector<int> &A, int k) {\\n        int n = A.size(), left = 0;\\n        vector<int> right(n);\\n        long res = 0;\\n        for (int i = n - 2; i >= 0; --i) {\\n            right[i] = right[i + 1] | A[i + 1];\\n        }\\n        for (int i = 0; i < n; i++) {\\n            res = max(res, left | (long)A[i] << k | right[i]);\\n            left |= A[i];\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def maximumOr(self, A: List[int], k: int) -> int:\\n        res, left, n = 0, 0, len(A)\\n        right = [0] * n\\n        for i in range(n - 2, -1, -1):\\n            right[i] = right[i + 1] | A[i + 1]\\n        for i in range(n):\\n            res = max(res, left | A[i] << k | right[i])\\n            left |= A[i]\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3520489,
                "title": "o-1-space-keep-track-of-bits-super-simple-to-understand-and-detailed-explanation",
                "content": "Glossary:\\n- *bit set*: ith bit is set means the ith bit equals one \\n- *highest bit of a number*: highest `i` for which the ith bit is set (eg. in 1001 the highest bit is the 4th bit)\\n- *the OR* :  `nums[0] | nums[1] | ... | nums[n - 1]`, after one operation (not necessarily the final result)\\n\\n\\nExplanation\\n\\n1. When you do `nums[0] | nums[1] | ... | nums[n - 1]`, what you get as a result is a number which will have the `i`th bit set if any of `nums[i]` has this bit set.\\n2. We want to maximise the result. What does it mean? It means that we want to have all the higher bits as high as possible. So any solution that maximizes the higher bits will find the solution.\\n3. From point 2. **we can deduce what we need to multiply only one number `k` times**. Why?\\n     1.  Lets say bit `b` is the highest bit of all the numbers in `nums`.\\n     2.  Let\\'s say we picked a number (let\\'s call it `x`) from nums that has this highest bit and applied the first operation on it\\n     3.  This means that now the OR will have the highest bit = `b+1` \\n     4.  For the next operation, we have to to chose `x` again. Why? Because if we chose `x` again then the OR will have  `b+2` as the highest bit and it\\'s impossible have a higher OR by chosing another number than `x` (since the highest bit is `b` if you chose another one the OR will have max `b+1` as the highest bit)\\n     5.  Repeat the same logic `k` times\\n\\n4. Now that we deduced that we just have to pick one number and double it `k` times, the question becomes way easier. You simply have to **iterate through all numbers and chose the one for which the answer will be the highest** (we also deduced that it is one of the numbers that has the max highest bit, but we don\\'t need this info)\\n5. Now the only remaining problem is how to we compute OR in an efficient way? \\n    1. From point 1., we can simply iterate on each number and fill an array keeping track if bit `b` is set or not\\n    2. We can precompute the OR bits by filling this array. Computing the value of OR is easy, we just convert the array to a number\\n    3. When we multiply a number by `2^k` we simply shift its bits `k` positions higher, then we can get the result of chosing this number by adding its bits to the array.\\n    4. Now there is one last trick. In 3. since we shift `num` we could by mistake consider a bit of its initial value as being set, but it was maybe the only number that had this bit. We just have to slightly modify our array to store the count of numbers having this bit. Then before shifting we decrease the count of this bit. If this count == 0 in the array it means this bit is not set.\\n\\n\\n```\\nclass Solution {\\n    // normally the worst case would be 10^9 * 2^ 15, so 45 bits max but I put more just in case (so that we can handle any long)\\n\\tprivate static final int MAX_BITS = 63;\\n\\n    public long maximumOr(int[] nums, int k) {\\n\\t\\n\\t\\t// precompute the array of bits\\n\\t\\t// originalBits[i] = how many elements in nums have bit i set to one\\n        int[] originalBits = new int[MAX_BITS];\\n        for (int num : nums) {\\n            for(int i = 0; num > 0; i++){\\n                if(num%2 == 1) originalBits[i]++;\\n                num /= 2;\\n            }\\n        }\\n\\n        long max = 0;\\n        for (int num : nums) {\\n            int[] bits = Arrays.copyOf(originalBits, MAX_BITS);\\n             for(int i = 0; num > 0; i++){\\n                if(num%2 == 1){ // if ith bit set\\n\\t\\t\\t\\t\\t// remove its old value\\n                    bits[i]--;\\n\\t\\t\\t\\t\\t// add its new one\\n                    bits[i+k]++;\\n                }\\n                num /= 2;\\n            }\\n\\t\\t\\t// convert bits to a number\\n            long result = 0;\\n            for (int i = 0; i < MAX_BITS; i++) {\\n                if(bits[i] > 0) result += (1L << i);\\n            }\\n            max = Math.max(result, max);\\n        }\\n\\n        return max;\\n\\n    }\\n}\\n```\\n\\nTime complexity : `O(n)` since we simply iterate on `nums`\\nSpace complexity: `O(1)` We only use one array of constant size\\n\\n\\n# Note \\nFollowing the discussion with @dinar below, from point 2. you can solve it with a different algorithm (but same complexity) by iterating on the bits and filtering out candidates that wouldn\\'t produce the highest bits in the answer. \\n\\t<details>\\n\\t<summary>Reveal alternative solution</summary>\\n```\\nclass Solution {\\n\\n    private int bitAt(int num, int i){\\n        return (num >> i) & 1;\\n    }\\n\\n    public long maximumOr(int[] nums, int k) {\\n        // small improvement to limit the number of bits to check\\n        // we could also iterate first over all numbers to see what is the actual highest bit\\n        int MAX_BITS = 30 +k;\\n\\n        Set<Integer> candidates = new HashSet<>();\\n\\n        // precompute the array of bits\\n        int[] bits = new int[MAX_BITS];\\n        for (int num : nums) {\\n            candidates.add(num);\\n            for(int i = 0; num > 0; i++){\\n                if(num%2 == 1) bits[i]++;\\n                num /= 2;\\n            }\\n        }\\n\\n        for (int i = MAX_BITS - 1; i >= 0; i--) {\\n            Set<Integer> withBit = new HashSet<>();\\n            long bitMask =  i >= k ?\\n                    1L << (i-k) : // looking for a bit in position i-k\\n                    i << 31; // mask impossible to match\\n            for (Integer candidate : candidates) {\\n                if((bitMask & candidate) > 0) withBit.add(candidate);\\n                else {\\n                    // we look if this bit would be set in the final result with this candidate shifted\\n                    if(bits[i] - bitAt(candidate, i) > 0) withBit.add(candidate);\\n                }\\n            }\\n\\n            // if withBit.size = 0, no candidate better than the others for this bit, so we keep all the previous candidates\\n            if(withBit.size() >= 1){\\n                candidates = withBit;\\n            }\\n\\n            if(candidates.size() == 1) break;  // we can stop early we found a unique winner\\n        }\\n\\n        // take an random candidate from all the ones that provide the maximum\\n        int winner = candidates.iterator().next();\\n\\n        for(int i = 0; winner > 0; i++){\\n            if(winner%2 == 1){ // if ith bit set\\n                // remove its old value\\n                bits[i]--;\\n                // add its new one\\n                bits[i+k]++;\\n            }\\n            winner /= 2;\\n        }\\n        // convert bits to a number\\n        long result = 0;\\n        for (int i = 0; i < MAX_BITS; i++) {\\n            if(bits[i] > 0) result += (1L << i);\\n        }\\n\\n\\n        return result;\\n\\n    }\\n```\\n\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // normally the worst case would be 10^9 * 2^ 15, so 45 bits max but I put more just in case (so that we can handle any long)\\n\\tprivate static final int MAX_BITS = 63;\\n\\n    public long maximumOr(int[] nums, int k) {\\n\\t\\n\\t\\t// precompute the array of bits\\n\\t\\t// originalBits[i] = how many elements in nums have bit i set to one\\n        int[] originalBits = new int[MAX_BITS];\\n        for (int num : nums) {\\n            for(int i = 0; num > 0; i++){\\n                if(num%2 == 1) originalBits[i]++;\\n                num /= 2;\\n            }\\n        }\\n\\n        long max = 0;\\n        for (int num : nums) {\\n            int[] bits = Arrays.copyOf(originalBits, MAX_BITS);\\n             for(int i = 0; num > 0; i++){\\n                if(num%2 == 1){ // if ith bit set\\n\\t\\t\\t\\t\\t// remove its old value\\n                    bits[i]--;\\n\\t\\t\\t\\t\\t// add its new one\\n                    bits[i+k]++;\\n                }\\n                num /= 2;\\n            }\\n\\t\\t\\t// convert bits to a number\\n            long result = 0;\\n            for (int i = 0; i < MAX_BITS; i++) {\\n                if(bits[i] > 0) result += (1L << i);\\n            }\\n            max = Math.max(result, max);\\n        }\\n\\n        return max;\\n\\n    }\\n}\\n```\n```\\nclass Solution {\\n\\n    private int bitAt(int num, int i){\\n        return (num >> i) & 1;\\n    }\\n\\n    public long maximumOr(int[] nums, int k) {\\n        // small improvement to limit the number of bits to check\\n        // we could also iterate first over all numbers to see what is the actual highest bit\\n        int MAX_BITS = 30 +k;\\n\\n        Set<Integer> candidates = new HashSet<>();\\n\\n        // precompute the array of bits\\n        int[] bits = new int[MAX_BITS];\\n        for (int num : nums) {\\n            candidates.add(num);\\n            for(int i = 0; num > 0; i++){\\n                if(num%2 == 1) bits[i]++;\\n                num /= 2;\\n            }\\n        }\\n\\n        for (int i = MAX_BITS - 1; i >= 0; i--) {\\n            Set<Integer> withBit = new HashSet<>();\\n            long bitMask =  i >= k ?\\n                    1L << (i-k) : // looking for a bit in position i-k\\n                    i << 31; // mask impossible to match\\n            for (Integer candidate : candidates) {\\n                if((bitMask & candidate) > 0) withBit.add(candidate);\\n                else {\\n                    // we look if this bit would be set in the final result with this candidate shifted\\n                    if(bits[i] - bitAt(candidate, i) > 0) withBit.add(candidate);\\n                }\\n            }\\n\\n            // if withBit.size = 0, no candidate better than the others for this bit, so we keep all the previous candidates\\n            if(withBit.size() >= 1){\\n                candidates = withBit;\\n            }\\n\\n            if(candidates.size() == 1) break;  // we can stop early we found a unique winner\\n        }\\n\\n        // take an random candidate from all the ones that provide the maximum\\n        int winner = candidates.iterator().next();\\n\\n        for(int i = 0; winner > 0; i++){\\n            if(winner%2 == 1){ // if ith bit set\\n                // remove its old value\\n                bits[i]--;\\n                // add its new one\\n                bits[i+k]++;\\n            }\\n            winner /= 2;\\n        }\\n        // convert bits to a number\\n        long result = 0;\\n        for (int i = 0; i < MAX_BITS; i++) {\\n            if(bits[i] > 0) result += (1L << i);\\n        }\\n\\n\\n        return result;\\n\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521223,
                "title": "c-java-python-intuition-with-explanation-proof-of-why-time-o-n",
                "content": "# Intuition\\nMultiply by $2$ means left shift by $1$. We can left shift some numbers but at most $k$ times in total. To maximize the result we should generate set bits in the most significant part of numbers.\\n\\nTake this array\\n```\\n 5 - 000000000101\\n 6 - 000000000110\\n 9 - 000000001001\\n20 - 000000010100\\n23 - 000000010111\\n```\\nTo maximize the result, we should pick the numbers having their Left Most Set Bit (LMSB) farthest among all elements. $20$ and $23$ have their LMSB maximum among all elements. We should try to shift $20$ or $23$, $k$ times combined. Like shift $20$ $x$ times and shift $23$ $k-x$ times.\\n\\n---\\n\\nBut still why is shifting only one number $k$ times is more optimal?\\n- Suppose $k=5$ and we shifted $20$, $5$ times and LMSB went further $5$ steps on the left.\\nThe modified array becomes:\\n```\\n  5 - 000000000101\\n  6 - 000000000110\\n  9 - 000000001001\\n640 - 001010000000\\n 23 - 000000010111\\n```\\nThe LMSB of $640$ is $2^9=512$ so Bitwise-OR of array will be atleast $2^9$. It can be more depending upon other less significant bits.\\n`ans >= 001000000000 (512)`\\n- Now let\\'s say we don\\'t give all $k$ moves to a single number. Since, we are not giving all $k$ moves to single number, we will never be able to generate $2^9$ set bit in any number. And even if somehow we generate all lower set bits $2^8, 2^7, 2^6, ...$ by distributing $k$ moves to different numbers, answer will still be less than $2^9$.\\n$2^8 + 2^7 + 2^6 + ... + 2^0 = 2^9 - 1 < 2^9$\\n\\nTherefore, giving all $k$ moves to single element (that too having largest LMSB) is the most optimal.\\n\\n# Approach\\n- Shift each number $k$ times and calculate Bitwise-OR.\\n- To make this fast, pre-compute Bitwise-OR of elements before it (prefix) and after it (suffix).\\n- Take maximum of them.\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        long long result = 0;\\n        vector<int> prefix(n + 1), suffix(n + 1);\\n        for (int i = 1; i < n; i++) {\\n            prefix[i] = prefix[i - 1] | nums[i - 1];\\n            suffix[n - i - 1] = suffix[n - i] | nums[n - i];\\n        }\\n        for (int i = 0; i < n; i++) {\\n            result = max(result, prefix[i] | ((long long)nums[i] << k) | suffix[i]);\\n        }\\n        return result;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        int n = nums.length;\\n        long result = 0;\\n        int[] prefix = new int[n + 1];\\n        int[] suffix = new int[n + 1];\\n        for (int i = 1; i < n; i++) {\\n            prefix[i] = prefix[i - 1] | nums[i - 1];\\n            suffix[n - i - 1] = suffix[n - i] | nums[n - i];\\n        }\\n        for (int i = 0; i < n; i++) {\\n            result = Math.max(result, prefix[i] | ((long)nums[i] << k) | suffix[i]);\\n        }\\n        return result;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        n, result = len(nums), 0\\n        prefix, suffix = [0] * (n + 1), [0] * (n + 1)\\n        for i in range(1, n):\\n            prefix[i] = prefix[i - 1] | nums[i - 1]\\n            suffix[n - i - 1] = suffix[n - i] | nums[n - i]\\n        for i in range(n):\\n            result = max(result, prefix[i] | (nums[i] << k) | suffix[i])\\n        return result\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Bit Manipulation",
                    "Prefix Sum"
                ],
                "code": "```\\n 5 - 000000000101\\n 6 - 000000000110\\n 9 - 000000001001\\n20 - 000000010100\\n23 - 000000010111\\n```\n```\\n  5 - 000000000101\\n  6 - 000000000110\\n  9 - 000000001001\\n640 - 001010000000\\n 23 - 000000010111\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        long long result = 0;\\n        vector<int> prefix(n + 1), suffix(n + 1);\\n        for (int i = 1; i < n; i++) {\\n            prefix[i] = prefix[i - 1] | nums[i - 1];\\n            suffix[n - i - 1] = suffix[n - i] | nums[n - i];\\n        }\\n        for (int i = 0; i < n; i++) {\\n            result = max(result, prefix[i] | ((long long)nums[i] << k) | suffix[i]);\\n        }\\n        return result;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        int n = nums.length;\\n        long result = 0;\\n        int[] prefix = new int[n + 1];\\n        int[] suffix = new int[n + 1];\\n        for (int i = 1; i < n; i++) {\\n            prefix[i] = prefix[i - 1] | nums[i - 1];\\n            suffix[n - i - 1] = suffix[n - i] | nums[n - i];\\n        }\\n        for (int i = 0; i < n; i++) {\\n            result = Math.max(result, prefix[i] | ((long)nums[i] << k) | suffix[i]);\\n        }\\n        return result;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        n, result = len(nums), 0\\n        prefix, suffix = [0] * (n + 1), [0] * (n + 1)\\n        for i in range(1, n):\\n            prefix[i] = prefix[i - 1] | nums[i - 1]\\n            suffix[n - i - 1] = suffix[n - i] | nums[n - i]\\n        for i in range(n):\\n            result = max(result, prefix[i] | (nums[i] << k) | suffix[i])\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520799,
                "title": "step-by-step-explanation-best-solution",
                "content": "# Intuition\\n1. We start with the most significant bit (30th bit assuming the maximum value of elements in `nums` is less than 2^30) and iterate downwards.\\n2. In each iteration, we count the number of elements in `nums` that have the current bit set to 1.\\n3. If the count is greater than `k` or if setting the current bit to 1 results in a value less than the current maximum value, we skip this bit.\\n4. Otherwise, we update the maximum value by setting the current bit to 1 and subtract the count from `k`.\\n5. We continue this process for each bit in descending order until we have exhausted `k` operations or iterated through all the bits.\\n6. Finally, we return the maximum value obtained.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize a variable named `max_val` to store the maximum possible value.\\n2. Initialize a variable named `mask` to 0. This mask will help us keep track of the significant bits in the numbers.\\n3. Iterate from the 30th bit (assuming the maximum value of nums elements is less than 2^30) to 0 in descending order. In each iteration, perform the following steps:\\n    - Initialize a variable named `count` to 0. This variable will keep track of how many numbers in nums have the current bit set to 1.\\n    - Iterate through each number in the nums array. If the bit at the current position is set to 1, increment the count variable.\\n    - If count is greater than k or if (mask | (1 << bit)) is less than max_val, continue to the next iteration.\\n    - Update max_val to (max_val | (1 << bit)).\\n    - Subtract count from k.\\n    - Set the bit at the current position in the mask to 1.\\n4. Return the value of max_val as the maximum possible value.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n    int n=nums.size();\\nlong long pre[n + 1], suf[n + 1];\\n    long long sol, pow = 1;\\n     for (int i = 0; i < k; i++){\\n        pow*=2;\\n     }\\n \\n    pre[0] = 0;\\n    for (int i = 0; i < n; i++){\\n        pre[i + 1] = pre[i] | nums[i];\\n    }\\n     suf[n] = 0;\\n    for (int i = n - 1; i >= 0; i--){\\n        suf[i] = suf[i + 1] | nums[i];\\n    }\\n     sol= 0;\\n    for (int i = 0; i < n; i++)\\n        sol = max(sol, pre[i] | (nums[i] * pow) | suf[i + 1]);\\n \\n    return sol;    \\n    }\\n};\\n```\\n![images.jpeg](https://assets.leetcode.com/users/images/8bc4223f-1602-420a-9c6b-853f5f198c6f_1683999525.4729867.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n    int n=nums.size();\\nlong long pre[n + 1], suf[n + 1];\\n    long long sol, pow = 1;\\n     for (int i = 0; i < k; i++){\\n        pow*=2;\\n     }\\n \\n    pre[0] = 0;\\n    for (int i = 0; i < n; i++){\\n        pre[i + 1] = pre[i] | nums[i];\\n    }\\n     suf[n] = 0;\\n    for (int i = n - 1; i >= 0; i--){\\n        suf[i] = suf[i + 1] | nums[i];\\n    }\\n     sol= 0;\\n    for (int i = 0; i < n; i++)\\n        sol = max(sol, pre[i] | (nums[i] * pow) | suf[i + 1]);\\n \\n    return sol;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520248,
                "title": "java-easy-with-explanation",
                "content": "# Approach\\nTo solve this problem, we can use the approach of calculating prefix and suffix sums. For each element in the array, we can calculate the maximum possible value of nums[0] | nums[1] | ... | nums[n - 1] by multiplying it by 2^k and bitwise ORing it with the prefix sum of the elements before it and the suffix sum of the elements after it.\\n\\nHere\\'s the step-by-step algorithm:\\n\\n1. Calculate the prefix sum of the array. For each index i, the prefix sum prefix[i] is equal to the bitwise OR of all elements nums[0] | nums[1] | ... | nums[i].\\n\\n2. Calculate the suffix sum of the array. For each index i, the suffix sum suffix[i] is equal to the bitwise OR of all elements nums[i] | nums[i+1] | ... | nums[n-1].\\n\\n3. For each index i in the array, calculate the maximum possible value of nums[0] | nums[1] | ... | nums[n - 1] by multiplying nums[i] by 2^k and bitwise ORing it with prefix[i-1] and suffix[i+1]. Take the maximum value obtained from all indices.\\n\\n4. Return the maximum value obtained in step 3.\\n\\n# Complexity\\n- Time complexity:\\nO(N);\\n\\n- Space complexity:\\nO(N);\\n\\n# Code\\n```\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] prefix = new int[n];\\n        int[] suffix = new int[n];\\n        \\n        prefix[0] = nums[0];\\n        for (int i = 1; i < n; i++) {\\n            prefix[i] = prefix[i-1] | nums[i];\\n        }\\n        \\n        suffix[n-1] = nums[n-1];\\n        for (int i = n-2; i >= 0; i--) {\\n            suffix[i] = suffix[i+1] | nums[i];\\n        }\\n        \\n        long maxOr = 0;\\n        for (int i = 0; i < n; i++) {\\n            long or = ((long) nums[i]) * (1L << k) | (i > 0 ? prefix[i-1] : 0) | (i < n-1 ? suffix[i+1] : 0);\\n            maxOr = Math.max(maxOr, or);\\n        }\\n        \\n        return maxOr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] prefix = new int[n];\\n        int[] suffix = new int[n];\\n        \\n        prefix[0] = nums[0];\\n        for (int i = 1; i < n; i++) {\\n            prefix[i] = prefix[i-1] | nums[i];\\n        }\\n        \\n        suffix[n-1] = nums[n-1];\\n        for (int i = n-2; i >= 0; i--) {\\n            suffix[i] = suffix[i+1] | nums[i];\\n        }\\n        \\n        long maxOr = 0;\\n        for (int i = 0; i < n; i++) {\\n            long or = ((long) nums[i]) * (1L << k) | (i > 0 ? prefix[i-1] : 0) | (i < n-1 ? suffix[i+1] : 0);\\n            maxOr = Math.max(maxOr, or);\\n        }\\n        \\n        return maxOr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520332,
                "title": "easy-segment-tree-approach-intuitive-solution-c-code",
                "content": "# Intuition\\nSince its a range query and update so we should think of Segment tree approach\\n# Approach\\nSince its given that we can multiply the array elements by 2, it indirectly means that we can right shift the array elements k times.\\nNow,\\nFirstly we should think how many values should be affected by the operation?\\nSo the answer to this is it is always optimal to right shift that value which has the most significant bit as leftmost as possible then the other elements\\n\\nSo to do so,\\nWe build the segment tree for Bitwise OR operation and for each value we right shift that particular element k times and check for the maximum value\\n\\n# Complexity\\n- Time complexity:\\nO(n*logn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n#define ll long long\\n#include <vector>\\nusing namespace std;\\n\\nclass SegmentTree {\\nprivate:\\n    vector<ll> tree;\\n    ll n;\\n    \\npublic:\\n    SegmentTree(ll sz) {\\n        n = sz;\\n        tree.resize(4*n);\\n    }\\n    \\n    void update(ll idx, ll val) {\\n        updateUtil(1, 0, n-1, idx, val);\\n    }\\n    \\n    ll query(int l, int r) {\\n        return queryUtil(1, 0, n-1, l, r);\\n    }\\n    \\nprivate:\\n    void updateUtil(ll node, ll start, ll end, ll idx, ll val) {\\n        if (start == end) {\\n            tree[node] = val;\\n        } else {\\n            ll mid = (start + end) / 2;\\n            if (idx <= mid) {\\n                updateUtil(2*node, start, mid, idx, val);\\n            } else {\\n                updateUtil(2*node+1, mid+1, end, idx, val);\\n            }\\n            tree[node] = tree[2*node] | tree[2*node+1];\\n        }\\n    }\\n    \\n    ll queryUtil(ll node, ll start, ll end, ll l, ll r) {\\n        if (r < start || end < l) {\\n            return 0;\\n        }\\n        if (l <= start && end <= r) {\\n            return tree[node];\\n        }\\n        ll mid = (start + end) / 2;\\n        ll orLeft = queryUtil(2*node, start, mid, l, r);\\n        ll orRight = queryUtil(2*node+1, mid+1, end, l, r);\\n        return orLeft | orRight;\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        ll n=nums.size();\\n            SegmentTree st(n);\\n         for (int i = 0; i < n; i++) {\\n        st.update(i, nums[i]);\\n        }\\n        \\n        ll ans=0;\\n        for(int i=0;i<n;i++){\\n            int val=nums[i];\\n            st.update(i,((1ll * val) << k));\\n            ll anss=st.query(0,n-1);\\n            ans=max(ans,anss);\\n            st.update(i,val);\\n        }\\n        \\n        \\n        return ans;\\n        \\n\\n    }\\n};\\n```\\n\\nPlease UPVOTE it you liked my solution :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\n#include <vector>\\nusing namespace std;\\n\\nclass SegmentTree {\\nprivate:\\n    vector<ll> tree;\\n    ll n;\\n    \\npublic:\\n    SegmentTree(ll sz) {\\n        n = sz;\\n        tree.resize(4*n);\\n    }\\n    \\n    void update(ll idx, ll val) {\\n        updateUtil(1, 0, n-1, idx, val);\\n    }\\n    \\n    ll query(int l, int r) {\\n        return queryUtil(1, 0, n-1, l, r);\\n    }\\n    \\nprivate:\\n    void updateUtil(ll node, ll start, ll end, ll idx, ll val) {\\n        if (start == end) {\\n            tree[node] = val;\\n        } else {\\n            ll mid = (start + end) / 2;\\n            if (idx <= mid) {\\n                updateUtil(2*node, start, mid, idx, val);\\n            } else {\\n                updateUtil(2*node+1, mid+1, end, idx, val);\\n            }\\n            tree[node] = tree[2*node] | tree[2*node+1];\\n        }\\n    }\\n    \\n    ll queryUtil(ll node, ll start, ll end, ll l, ll r) {\\n        if (r < start || end < l) {\\n            return 0;\\n        }\\n        if (l <= start && end <= r) {\\n            return tree[node];\\n        }\\n        ll mid = (start + end) / 2;\\n        ll orLeft = queryUtil(2*node, start, mid, l, r);\\n        ll orRight = queryUtil(2*node+1, mid+1, end, l, r);\\n        return orLeft | orRight;\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        ll n=nums.size();\\n            SegmentTree st(n);\\n         for (int i = 0; i < n; i++) {\\n        st.update(i, nums[i]);\\n        }\\n        \\n        ll ans=0;\\n        for(int i=0;i<n;i++){\\n            int val=nums[i];\\n            st.update(i,((1ll * val) << k));\\n            ll anss=st.query(0,n-1);\\n            ans=max(ans,anss);\\n            st.update(i,val);\\n        }\\n        \\n        \\n        return ans;\\n        \\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3520271,
                "title": "dynamic-programming-not-working-solution-using-prefix-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis approach is not working for test case -> 6,9,8 and k = 1\\nthe ans should be 31 and my code is giving 30... \\nto get answer we multiply 8 by 2 so array will be [6,9,16]\\n\\nthe dp code is not taking 9|16 (25) as return value instead it is taking 18|8 (26) which is wrong.\\nthis is happening because we are maximising our answer in aur recursive code and it is taking 26 as our final value instead of 25 (which gives us the right answer).\\n\\n\\n# Wrong Code\\n```\\nclass Solution {\\n    \\n    long long dp[100009][20];\\n\\n    /// to calculate the power of 2\\n    long long cal(int id){\\n        long long val = 1LL;\\n        while(id--){\\n            val*=(2LL);\\n        }\\n        return val;\\n    }\\n    \\n    long long rec(vector<int> &arr,int id,int k){\\n        if(id>=arr.size())\\n            return 0;\\n        if(dp[id][k]!=-1)\\n            return dp[id][k];\\n        long long ans = 0;\\n        /// how many times should I multiply arr[id] with 2....\\n        for(int i = 0;i<=k;i++){\\n            ans = max(ans,(cal(i)*arr[id])|(rec(arr,id+1,k-i)));\\n        }\\n        \\n        return dp[id][k] = ans;\\n        \\n    }\\n    \\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        memset(dp,-1,sizeof(dp));\\n        return rec(nums,0,k);\\n    }\\n};\\n```\\n\\n\\n# Correct Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        long long ans = 0;\\n        vector<long long> suff(nums.size()+1);\\n        long long curr = 0;\\n        for(int i=nums.size()-1;i>=0;i--){\\n            curr|=nums[i];\\n            suff[i] = curr;\\n        }\\n\\n        curr = 0;\\n\\n        for(int i=0;i<nums.size();i++){\\n            long long temp = curr;\\n            temp |= (nums[i]*(1LL<<k));\\n            ans = max(ans,(temp)|(suff[i+1]));\\n            curr |= nums[i];\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    long long dp[100009][20];\\n\\n    /// to calculate the power of 2\\n    long long cal(int id){\\n        long long val = 1LL;\\n        while(id--){\\n            val*=(2LL);\\n        }\\n        return val;\\n    }\\n    \\n    long long rec(vector<int> &arr,int id,int k){\\n        if(id>=arr.size())\\n            return 0;\\n        if(dp[id][k]!=-1)\\n            return dp[id][k];\\n        long long ans = 0;\\n        /// how many times should I multiply arr[id] with 2....\\n        for(int i = 0;i<=k;i++){\\n            ans = max(ans,(cal(i)*arr[id])|(rec(arr,id+1,k-i)));\\n        }\\n        \\n        return dp[id][k] = ans;\\n        \\n    }\\n    \\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        memset(dp,-1,sizeof(dp));\\n        return rec(nums,0,k);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        long long ans = 0;\\n        vector<long long> suff(nums.size()+1);\\n        long long curr = 0;\\n        for(int i=nums.size()-1;i>=0;i--){\\n            curr|=nums[i];\\n            suff[i] = curr;\\n        }\\n\\n        curr = 0;\\n\\n        for(int i=0;i<nums.size();i++){\\n            long long temp = curr;\\n            temp |= (nums[i]*(1LL<<k));\\n            ans = max(ans,(temp)|(suff[i+1]));\\n            curr |= nums[i];\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520198,
                "title": "python-simple-greedy-o-n-time-o-1-memory",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        cur = 0\\n        saved = 0\\n        for num in nums:\\n            saved |= num & cur\\n            cur |= num\\n        \\n        max_num = 0\\n        \\n        for num in nums:\\n            max_num = max(max_num, saved | (cur & ~num) | num << k)\\n        return max_num\\n        \\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        cur = 0\\n        saved = 0\\n        for num in nums:\\n            saved |= num & cur\\n            cur |= num\\n        \\n        max_num = 0\\n        \\n        for num in nums:\\n            max_num = max(max_num, saved | (cur & ~num) | num << k)\\n        return max_num\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522634,
                "title": "prefix-suffix-detailed-explaination",
                "content": "```\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        n, res = len(nums), 0\\n        pre, suf = [0] * n, [0] * n\\n        # calculate the prefix OR \\n        for i in range(n - 1): pre[i + 1] = pre[i] | nums[i]\\n        # calculate the suffix OR\\n        for i in range(n - 1, 0, -1): suf[i - 1] = suf[i] | nums[i]\\n        # iterate each number\\n        # we apply k operations on nums[i], i.e. shift k bits to the left\\n        # why not applying on multiple numbers? \\n        # first in binary format, multiplying a number by 2 is shifting 1 bit to the left\\n        # e.g. 0010 (2) -> 0100 (4)\\n        # e.g. 0101 (5) -> 1010 (10)\\n        # second, in OR operation, we wish there is a 1 as left as possible\\n        # which produces the greater value\\n        # hence, we apply on the same number to achieve the max value\\n        # which produces the max OR value\\n        # now we calculate nums[0] | nums[1] | ... | nums[n - 1]\\n        # by utilising the prefix OR and suffix OR\\n        # the reason is simple\\n        # we precompute the result instead of calculate the OR values on each iteration\\n        for i in range(n): res = max(res, pre[i] | nums[i] << k | suf[i])\\n        return res\\n```\\n\\n**p.s. Join us on the LeetCode The Hard Way Discord Study Group for timely discussion! Link in bio.**",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        n, res = len(nums), 0\\n        pre, suf = [0] * n, [0] * n\\n        # calculate the prefix OR \\n        for i in range(n - 1): pre[i + 1] = pre[i] | nums[i]\\n        # calculate the suffix OR\\n        for i in range(n - 1, 0, -1): suf[i - 1] = suf[i] | nums[i]\\n        # iterate each number\\n        # we apply k operations on nums[i], i.e. shift k bits to the left\\n        # why not applying on multiple numbers? \\n        # first in binary format, multiplying a number by 2 is shifting 1 bit to the left\\n        # e.g. 0010 (2) -> 0100 (4)\\n        # e.g. 0101 (5) -> 1010 (10)\\n        # second, in OR operation, we wish there is a 1 as left as possible\\n        # which produces the greater value\\n        # hence, we apply on the same number to achieve the max value\\n        # which produces the max OR value\\n        # now we calculate nums[0] | nums[1] | ... | nums[n - 1]\\n        # by utilising the prefix OR and suffix OR\\n        # the reason is simple\\n        # we precompute the result instead of calculate the OR values on each iteration\\n        for i in range(n): res = max(res, pre[i] | nums[i] << k | suf[i])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520264,
                "title": "easy-c-using-prefix-and-suffix-sum",
                "content": "# Intuition\\nWe have to check on each element weather we can give multiply it for k times. Multiplying single element k time will give more larger result.\\n\\n# Approach\\nwe will store prefix and suffix or of each index in order to minimise time complexity.\\n\\nafter that we can iterate on each index multifly it with 2 for k times and take new or (pre[i] | val | suf[i+1]) it will give the or of array. we will store maximum in ret variable.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    long long maximumOr(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        int x=2;\\n        vector<long long>pre(n+1,0),suff(n+1,0);\\n        long long res, po = 1;\\n \\n\\n        for (int i = 0; i < k; i++){\\n            po *= x;\\n        }\\n        \\n \\n        for (int i = 0; i < n; i++){\\n            pre[i + 1] = pre[i] | nums[i];\\n        }\\n        \\n        suff[n] = 0;\\n        for (int i = n - 1; i >= 0; i--){\\n            suff[i] = suff[i + 1] | nums[i];\\n        }\\n        \\n        res = 0;\\n        for (int i = 0; i < n; i++){\\n            res = max(res, pre[i] | (nums[i] * po) | suff[i + 1]);\\n        }\\n        \\n \\n        return res;\\n    }\\n};\\n```\\n\\nPLEASEEE UPVOTEE IF IT HELPSS",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long maximumOr(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        int x=2;\\n        vector<long long>pre(n+1,0),suff(n+1,0);\\n        long long res, po = 1;\\n \\n\\n        for (int i = 0; i < k; i++){\\n            po *= x;\\n        }\\n        \\n \\n        for (int i = 0; i < n; i++){\\n            pre[i + 1] = pre[i] | nums[i];\\n        }\\n        \\n        suff[n] = 0;\\n        for (int i = n - 1; i >= 0; i--){\\n            suff[i] = suff[i + 1] | nums[i];\\n        }\\n        \\n        res = 0;\\n        for (int i = 0; i < n; i++){\\n            res = max(res, pre[i] | (nums[i] * po) | suff[i + 1]);\\n        }\\n        \\n \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521026,
                "title": "suffix-prefix-c-easy-to-understnad",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size(),i;\\n        if(n==1)return ((nums[0]*1LL)<<k);\\n        vector<int> p(n,0),s(n,0);\\n        p[0] = nums[0];\\n        for(i = 1; i < n; i++){\\n            p[i] = (p[i-1]|nums[i]);\\n        }\\n        s[n-1] = nums[n-1];\\n        for(i = n-2; i >=0; i--){\\n            s[i] = (s[i+1]|nums[i]);\\n        }\\n        long long int ans = 0;\\n        for(int i = 0; i < n; i++){\\n            if(i==0){\\n                ans = max(ans,((nums[i]*1LL)<<k)|s[i+1]);\\n            }else if(i==n-1){\\n                ans = max(ans,((nums[i]*1LL)<<k)|p[i-1]);\\n            }else{\\n                ans = max(ans,((nums[i]*1LL)<<k)|s[i+1]|p[i-1]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size(),i;\\n        if(n==1)return ((nums[0]*1LL)<<k);\\n        vector<int> p(n,0),s(n,0);\\n        p[0] = nums[0];\\n        for(i = 1; i < n; i++){\\n            p[i] = (p[i-1]|nums[i]);\\n        }\\n        s[n-1] = nums[n-1];\\n        for(i = n-2; i >=0; i--){\\n            s[i] = (s[i+1]|nums[i]);\\n        }\\n        long long int ans = 0;\\n        for(int i = 0; i < n; i++){\\n            if(i==0){\\n                ans = max(ans,((nums[i]*1LL)<<k)|s[i+1]);\\n            }else if(i==n-1){\\n                ans = max(ans,((nums[i]*1LL)<<k)|p[i-1]);\\n            }else{\\n                ans = max(ans,((nums[i]*1LL)<<k)|s[i+1]|p[i-1]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520238,
                "title": "wa-on-new-testcases-try-all-ways-bottom-up-top-down-dp-try-all-ways-c-java",
                "content": "**Idea:**\\nKnapSack -> Pick or not pick\\nPick, how many times we can multiply current number by 2, then do `OR`\\nSkip, just do `OR` and move to next\\n\\nC++\\n**Top Down**\\n```\\n// TC: O(N * K * K)\\n// SC: O(N * K)\\n#define ll long long\\nclass Solution {\\n    ll memo[100001][16];\\n\\n    ll rec(vector<int> &arr, int i, int k){\\n        if(i == arr.size()) return 0;\\n        if(memo[i][k] !=- 1) return memo[i][k];\\n        \\n        ll maxi = arr[i] | rec(arr, i + 1, k);;\\n        \\n        for(ll j = 1; j <= k; j++){\\n            ll value = arr[i];        \\n            ll cur = (value << j); // it equals to value * pow(2, j)\\n                \\n            maxi = max(maxi, cur | rec(arr, i + 1, k - j));\\n        }\\n        return memo[i][k] = maxi;\\n    }\\npublic:\\n    long long maximumOr(vector<int>& arr, int k){\\n        memset(memo, -1, sizeof(memo));\\n        return rec(arr, 0, k);\\n    }\\n};\\n```\\n**Bottom Up**\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& arr, int k){\\n        int n = arr.size();\\n        ll dp[n + 1][k + 1];\\n        \\n        for(int i = n; i >= 0; i--){\\n            for(int j = 0; j < k + 1; j++){\\n                if(i == n){\\n                    dp[i][j] = 0;\\n                    continue;\\n                }\\n                \\n                ll maxi = arr[i] | dp[i + 1][j];\\n        \\n                for(ll l = 1; l <= j; l++){\\n                    ll value = arr[i];        \\n                    ll cur = (value << l);\\n\\n                    maxi = max(maxi, cur | dp[i + 1][j - l]);\\n                }\\n                dp[i][j] = maxi;\\n            }\\n        }\\n        return dp[0][k];\\n    }\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        long[][] memo = new long[nums.length][k + 1];\\n        for (int i = 0; i < nums.length; i++) {\\n            Arrays.fill(memo[i], -1);\\n        }\\n        return rec(nums, 0, k, memo);\\n    }\\n    \\n    private long rec(int[] nums, int i, int k, long[][] memo) {\\n        if (i == nums.length) {\\n            return 0;\\n        }\\n        if (memo[i][k] != -1) {\\n            return memo[i][k];\\n        }\\n        \\n        long maxi = nums[i] | rec(nums, i + 1, k, memo);\\n        \\n        for (int j = 1; j <= k; j++) {\\n            long value = nums[i];\\n            long cur = (value << j);\\n            maxi = Math.max(maxi, cur | rec(nums, i + 1, k - j, memo));\\n        }\\n        memo[i][k] = maxi;\\n        return maxi;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n// TC: O(N * K * K)\\n// SC: O(N * K)\\n#define ll long long\\nclass Solution {\\n    ll memo[100001][16];\\n\\n    ll rec(vector<int> &arr, int i, int k){\\n        if(i == arr.size()) return 0;\\n        if(memo[i][k] !=- 1) return memo[i][k];\\n        \\n        ll maxi = arr[i] | rec(arr, i + 1, k);;\\n        \\n        for(ll j = 1; j <= k; j++){\\n            ll value = arr[i];        \\n            ll cur = (value << j); // it equals to value * pow(2, j)\\n                \\n            maxi = max(maxi, cur | rec(arr, i + 1, k - j));\\n        }\\n        return memo[i][k] = maxi;\\n    }\\npublic:\\n    long long maximumOr(vector<int>& arr, int k){\\n        memset(memo, -1, sizeof(memo));\\n        return rec(arr, 0, k);\\n    }\\n};\\n```\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& arr, int k){\\n        int n = arr.size();\\n        ll dp[n + 1][k + 1];\\n        \\n        for(int i = n; i >= 0; i--){\\n            for(int j = 0; j < k + 1; j++){\\n                if(i == n){\\n                    dp[i][j] = 0;\\n                    continue;\\n                }\\n                \\n                ll maxi = arr[i] | dp[i + 1][j];\\n        \\n                for(ll l = 1; l <= j; l++){\\n                    ll value = arr[i];        \\n                    ll cur = (value << l);\\n\\n                    maxi = max(maxi, cur | dp[i + 1][j - l]);\\n                }\\n                dp[i][j] = maxi;\\n            }\\n        }\\n        return dp[0][k];\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        long[][] memo = new long[nums.length][k + 1];\\n        for (int i = 0; i < nums.length; i++) {\\n            Arrays.fill(memo[i], -1);\\n        }\\n        return rec(nums, 0, k, memo);\\n    }\\n    \\n    private long rec(int[] nums, int i, int k, long[][] memo) {\\n        if (i == nums.length) {\\n            return 0;\\n        }\\n        if (memo[i][k] != -1) {\\n            return memo[i][k];\\n        }\\n        \\n        long maxi = nums[i] | rec(nums, i + 1, k, memo);\\n        \\n        for (int j = 1; j <= k; j++) {\\n            long value = nums[i];\\n            long cur = (value << j);\\n            maxi = Math.max(maxi, cur | rec(nums, i + 1, k - j, memo));\\n        }\\n        memo[i][k] = maxi;\\n        return maxi;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535414,
                "title": "python-3-7-lines-w-explanation-t-m-100-82",
                "content": "Here\\'s the plan:\\n1. We determine the maximum number of bits for elements in`nums`.\\n2. We compile those elements in`nums`that have the maximum number of bits (`n`) in the array`cands`. (The answer will be determined by left-shifting one of these elements.)\\n3. We iterate through`nums`, keeping track of the bits seen (`bits`) and bits seen more than once (`extraBits`). \\n\\n4. We assess which element`c`of`cands`provides the *maximum or* after left-shifting`k`bits by: (a) xoring the bits of`c`from`bits`; (b) unioning the bits of`c << k`to`bits`to reflect the left-shifting of `c`; and (c) unioning the bits of`extraBits`to`bits`to replace bits incorrectly removed by the xoring. \\n\\n.\\n```\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n\\n        bits, extraBits, mx, cands = 0, 0, 0, []\\n        n = 1<<int(log2(max(nums)))                 # <-- 1)\\n\\n        for num in nums:\\n            if num >= n: cands.append(num)          # <-- 2)\\n\\n            extraBits|= num&bits                    # <-- 3)\\n            bits|= num                              #\\n            \\n        return max(bits^c |                         # <-- 4a)\\n                   c << k |                         # <-- 4b)\\n                   extraBits for c in cands)        # <-- 4c)\\n```\\n[https://leetcode.com/problems/maximum-or/submissions/952181068/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n\\n        bits, extraBits, mx, cands = 0, 0, 0, []\\n        n = 1<<int(log2(max(nums)))                 # <-- 1)\\n\\n        for num in nums:\\n            if num >= n: cands.append(num)          # <-- 2)\\n\\n            extraBits|= num&bits                    # <-- 3)\\n            bits|= num                              #\\n            \\n        return max(bits^c |                         # <-- 4a)\\n                   c << k |                         # <-- 4b)\\n                   extraBits for c in cands)        # <-- 4c)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520315,
                "title": "using-prefix-method-c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe know that there should be only one number that should be multipled by 2^k as every time we multiply a number by 2 there will be shift in a bit of that number, so that number became larger and larger.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe use prefix  and postfix arrays to store **OR** of numbers before and after for a number\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size(); \\n        vector<int> pre(n, 0), post(n, 0); \\n        \\n        for(int i=1; i<n; i++) pre[i] = (pre[i-1] | nums[i-1]); \\n        for(int i = n-2; i>=0; i--) post[i] = (post[i+1] | nums[i+1]); \\n        \\n        long long res = 0; \\n        \\n        for(int i=0; i<n; i++){\\n            long long num = nums[i]; \\n            num *= pow(2, k); \\n            res = max(res, pre[i]|num|post[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size(); \\n        vector<int> pre(n, 0), post(n, 0); \\n        \\n        for(int i=1; i<n; i++) pre[i] = (pre[i-1] | nums[i-1]); \\n        for(int i = n-2; i>=0; i--) post[i] = (post[i+1] | nums[i+1]); \\n        \\n        long long res = 0; \\n        \\n        for(int i=0; i<n; i++){\\n            long long num = nums[i]; \\n            num *= pow(2, k); \\n            res = max(res, pre[i]|num|post[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520247,
                "title": "python-greedy",
                "content": "# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        counter = [0]*32\\n        for num in nums:\\n            for i in range(32):\\n                counter[i] += num & 1\\n                num = num >> 1\\n        res = 0\\n        for j, num in enumerate(nums):\\n            tmp = num\\n            for i in range(32):\\n                counter[i] -= tmp & 1\\n                tmp = tmp >> 1\\n            tmpres = 0\\n            for i in range(32):\\n                tmpres += (counter[i] > 0)*(1<<i)\\n            tmpres = tmpres | (num << k)\\n            res = max(res, tmpres)\\n            tmp = num\\n            for i in range(32):\\n                counter[i] += tmp & 1\\n                tmp = tmp >> 1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        counter = [0]*32\\n        for num in nums:\\n            for i in range(32):\\n                counter[i] += num & 1\\n                num = num >> 1\\n        res = 0\\n        for j, num in enumerate(nums):\\n            tmp = num\\n            for i in range(32):\\n                counter[i] -= tmp & 1\\n                tmp = tmp >> 1\\n            tmpres = 0\\n            for i in range(32):\\n                tmpres += (counter[i] > 0)*(1<<i)\\n            tmpres = tmpres | (num << k)\\n            res = max(res, tmpres)\\n            tmp = num\\n            for i in range(32):\\n                counter[i] += tmp & 1\\n                tmp = tmp >> 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520231,
                "title": "cpp-very-easy-solution-no-dp",
                "content": "\\n#### Intuition:\\n* Intuition of this problem is little bit tricky\\n* In this question we need to do k operations on any elements. In an operation, we choose an element and `multiply it by 2`. \\n* Above information says in one operation we `shift all bits to left by 1` -> `2 * num == (num << 1)` \\n* In our solution we just do `all operation on only one element` because we shift all bits left sides by k times then our answer is maximise.\\n\\n----\\n    \\n#### Approach:\\n* We check one by one element shifing k times left\\n* Claculate maximum result\\n\\n----\\n\\n# Complexity\\n- Time complexity: $$O(n * 70)$$\\n- Space complexity: $$O(70)$$\\n\\n----\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        vector<int> freq(70, 0);\\n        \\n        // count the number of set bit at perticular pos\\n        for(auto &x : nums) {\\n            for(int i = 0; i < 32; i++) \\n                if(x & (1ll << i)) freq[i]++;\\n        }\\n        \\n        \\n        long long int ans = 0;\\n        for(auto &x : nums) {\\n        // here we shift bits left side by k times\\n            for(int i = 0; i < 32; i++)\\n                if(x & (1ll << i)) {\\n                    freq[i]--;\\n                    freq[i + k]++;\\n                }\\n        // here calculate the result after shifting bits left side\\n            long long int cur = 0;\\n            for(int i = 0; i < 64; i++) {\\n                cur = cur + ((freq[i] ? 1ll : 0ll) << i); // cur = cur + (freq[i] ? 1ll : 0ll) * pow(2, i);\\n            }\\n        // store maximum answer \\n            ans = max(cur, ans);\\n            \\n        // set all bits initial state\\n            for(int i = 0; i < 32; i++) \\n                if(x & (1ll << i)) {\\n                    freq[i]++;\\n                    freq[i + k]--;\\n                }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```\\nHope this helps \\uD83D\\uDE04.\\n\\n----\\n> If you helpful, please upvote \\uD83D\\uDD3C\\uD83D\\uDD3C",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        vector<int> freq(70, 0);\\n        \\n        // count the number of set bit at perticular pos\\n        for(auto &x : nums) {\\n            for(int i = 0; i < 32; i++) \\n                if(x & (1ll << i)) freq[i]++;\\n        }\\n        \\n        \\n        long long int ans = 0;\\n        for(auto &x : nums) {\\n        // here we shift bits left side by k times\\n            for(int i = 0; i < 32; i++)\\n                if(x & (1ll << i)) {\\n                    freq[i]--;\\n                    freq[i + k]++;\\n                }\\n        // here calculate the result after shifting bits left side\\n            long long int cur = 0;\\n            for(int i = 0; i < 64; i++) {\\n                cur = cur + ((freq[i] ? 1ll : 0ll) << i); // cur = cur + (freq[i] ? 1ll : 0ll) * pow(2, i);\\n            }\\n        // store maximum answer \\n            ans = max(cur, ans);\\n            \\n        // set all bits initial state\\n            for(int i = 0; i < 32; i++) \\n                if(x & (1ll << i)) {\\n                    freq[i]++;\\n                    freq[i + k]--;\\n                }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3530237,
                "title": "cpp-solution-using-prefix-or-and-suffix-or",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& l, int k) {\\n        vector<long long> nums(l.size());\\n        int n = nums.size();\\n        for (int i = 0; i < n; i++) nums[i] = l[i];\\n        vector<int> pr(n), sf(n);\\n        pr[0] = nums[0];\\n        sf[n-1]=nums[n-1];\\n        for (int i = 1; i < n; i++) \\n            pr[i] = pr[i - 1] | nums[i];\\n        for (int i = n - 2; i >= 0; i--) \\n            sf[i] = sf[i + 1] | nums[i];\\n        nums.insert(nums.begin(), 0);\\n        pr.insert(pr.begin(), 0);\\n        sf.insert(sf.begin(), 0);\\n        pr.push_back(0);\\n        sf.push_back(0);\\n        for (int i = 1; i < n + 1; i++) {\\n            nums[i] = nums[i] * pow(2, k);\\n        }\\n        long long ans = INT_MIN;\\n        for (int i = 1; i < n + 1; i++) {\\n            long long x = nums[i] | pr[i - 1] | sf[i + 1];\\n            ans = max(ans, x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& l, int k) {\\n        vector<long long> nums(l.size());\\n        int n = nums.size();\\n        for (int i = 0; i < n; i++) nums[i] = l[i];\\n        vector<int> pr(n), sf(n);\\n        pr[0] = nums[0];\\n        sf[n-1]=nums[n-1];\\n        for (int i = 1; i < n; i++) \\n            pr[i] = pr[i - 1] | nums[i];\\n        for (int i = n - 2; i >= 0; i--) \\n            sf[i] = sf[i + 1] | nums[i];\\n        nums.insert(nums.begin(), 0);\\n        pr.insert(pr.begin(), 0);\\n        sf.insert(sf.begin(), 0);\\n        pr.push_back(0);\\n        sf.push_back(0);\\n        for (int i = 1; i < n + 1; i++) {\\n            nums[i] = nums[i] * pow(2, k);\\n        }\\n        long long ans = INT_MIN;\\n        for (int i = 1; i < n + 1; i++) {\\n            long long x = nums[i] | pr[i - 1] | sf[i + 1];\\n            ans = max(ans, x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526016,
                "title": "greedy-and-prefix-or",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nYou need to put all k to one element to make sure the lest most 1;\\nHowever, the element is not necessary the largest element, eg:\\n[100000001,\\n100000010,\\n100]\\nk = 1,\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(N)\\n# Code\\n```\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        int n = nums.length, pre[] = new int[n], post[] = new int[n];\\n        long res = 0L;\\n        for (int i = 1; i < n; i++) {\\n            // pre[i] is the prefix or for i, nums[0] | ... | nums[i - 1]\\n            pre[i] = pre[i - 1] | nums[i - 1]; \\n            // post[i] is the suffix or for i, nums[i + 1] | ... | nums[n - 1]\\n            post[n - 1 - i] = post[n - 1 - i + 1] | nums[n - 1 - i + 1];\\n        }\\n        for (int i = 0; i < n; i++) {\\n            res = Math.max(res, pre[i] | (long) nums[i] << k | post[i]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        int n = nums.length, pre[] = new int[n], post[] = new int[n];\\n        long res = 0L;\\n        for (int i = 1; i < n; i++) {\\n            // pre[i] is the prefix or for i, nums[0] | ... | nums[i - 1]\\n            pre[i] = pre[i - 1] | nums[i - 1]; \\n            // post[i] is the suffix or for i, nums[i + 1] | ... | nums[n - 1]\\n            post[n - 1 - i] = post[n - 1 - i + 1] | nums[n - 1 - i + 1];\\n        }\\n        for (int i = 0; i < n; i++) {\\n            res = Math.max(res, pre[i] | (long) nums[i] << k | post[i]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524921,
                "title": "python-elegant-short-o-n-prefix-sum",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n\\n        right = [0] * n\\n        for i in reversed(range(n - 1)):\\n            right[i] = right[i + 1] | nums[i + 1]\\n\\n        left = [0] * n\\n        for i in range(1, n):\\n            left[i] = left[i - 1] | nums[i - 1]\\n\\n        return max(\\n            l | (num << k) | r\\n            for l, num, r in zip(left, nums, right)\\n        )\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n\\n        right = [0] * n\\n        for i in reversed(range(n - 1)):\\n            right[i] = right[i + 1] | nums[i + 1]\\n\\n        left = [0] * n\\n        for i in range(1, n):\\n            left[i] = left[i - 1] | nums[i - 1]\\n\\n        return max(\\n            l | (num << k) | r\\n            for l, num, r in zip(left, nums, right)\\n        )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522424,
                "title": "java-prefix-suffix",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        if(nums.length == 1) {\\n            return (long)nums[0] << k;\\n        }\\n\\n        long[] prefix = new long[nums.length];\\n        prefix[0] = nums[0];\\n\\n        for(int i = 1; i < nums.length; i++) {\\n            prefix[i] = prefix[i-1] | (long)nums[i];\\n        }\\n\\n        long[] suffix = new long[nums.length];\\n        suffix[nums.length - 1] = nums[nums.length - 1];\\n\\n        for(int i = nums.length - 2; i >= 0; i--) {\\n            suffix[i] = suffix[i+1] | (long)nums[i];\\n        }\\n\\n        long ans = Math.max(((long)nums[0] << k) | suffix[1], ((long)nums[nums.length - 1] << k) | prefix[nums.length - 2]);\\n\\n        for(int i = 1; i < nums.length - 1; i++) {\\n            long n = ((long)nums[i] << k) | prefix[i-1] | suffix[i+1];\\n            ans = Math.max(ans, n);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        if(nums.length == 1) {\\n            return (long)nums[0] << k;\\n        }\\n\\n        long[] prefix = new long[nums.length];\\n        prefix[0] = nums[0];\\n\\n        for(int i = 1; i < nums.length; i++) {\\n            prefix[i] = prefix[i-1] | (long)nums[i];\\n        }\\n\\n        long[] suffix = new long[nums.length];\\n        suffix[nums.length - 1] = nums[nums.length - 1];\\n\\n        for(int i = nums.length - 2; i >= 0; i--) {\\n            suffix[i] = suffix[i+1] | (long)nums[i];\\n        }\\n\\n        long ans = Math.max(((long)nums[0] << k) | suffix[1], ((long)nums[nums.length - 1] << k) | prefix[nums.length - 2]);\\n\\n        for(int i = 1; i < nums.length - 1; i++) {\\n            long n = ((long)nums[i] << k) | prefix[i-1] | suffix[i+1];\\n            ans = Math.max(ans, n);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520617,
                "title": "c-why-my-code-was-not-working-don-t-use-or-instead-of",
                "content": "From today onwards,i\\'ll remember or == || \\nfor logic **or** always **|**\\nvery disappointed :(\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll memo[100001][16];\\n   long long rec(int i,int j,vector<int>&nums,int k)\\n   {\\n       if(i>=nums.size()) return 0;\\n       if(memo[i][j] !=- 1) return memo[i][j];\\n       \\n       long long with=0;\\n       long long without=0;\\n       without=nums[i] or rec(i+1,j,nums,k) ;\\n       for(int a=1;a<=j;a++)\\n       {\\n           if(j-a>=0)\\n           {\\n               long long temp = rec(i+1,j-a,nums,k) ;\\n               ll cur=(ll)nums[i]*pow(2,a) ;\\n               temp =temp or cur;\\n               // cout<<i<<\" : \"<<a<<\" \"<<temp<<endl;\\n               with=max(temp,with);\\n           }   \\n       }\\n      \\n       // cout<<i<<\" : \"<<j<<\" :: \"<<with<<\" \"<<without<<endl;\\n       return memo[i][j]=max(with,without);\\n   }\\n   long long maximumOr(vector<int>& nums, int k) {\\n       memset(memo, -1, sizeof(memo));\\n       return rec(0,k,nums,k);\\n   }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll memo[100001][16];\\n   long long rec(int i,int j,vector<int>&nums,int k)\\n   {\\n       if(i>=nums.size()) return 0;\\n       if(memo[i][j] !=- 1) return memo[i][j];\\n       \\n       long long with=0;\\n       long long without=0;\\n       without=nums[i] or rec(i+1,j,nums,k) ;\\n       for(int a=1;a<=j;a++)\\n       {\\n           if(j-a>=0)\\n           {\\n               long long temp = rec(i+1,j-a,nums,k) ;\\n               ll cur=(ll)nums[i]*pow(2,a) ;\\n               temp =temp or cur;\\n               // cout<<i<<\" : \"<<a<<\" \"<<temp<<endl;\\n               with=max(temp,with);\\n           }   \\n       }\\n      \\n       // cout<<i<<\" : \"<<j<<\" :: \"<<with<<\" \"<<without<<endl;\\n       return memo[i][j]=max(with,without);\\n   }\\n   long long maximumOr(vector<int>& nums, int k) {\\n       memset(memo, -1, sizeof(memo));\\n       return rec(0,k,nums,k);\\n   }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3520505,
                "title": "js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDon\\'t forget to use BigInt. That\\'s why I didn\\'t get it right in the contest.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar maximumOr = function(nums, k) {\\n   let n = nums.length;\\n    let prev = [0n];\\n    let post = [0n];\\n    for (let i = 0; i < n; i++) prev.push(prev[prev.length - 1] | BigInt(nums[i]))\\n    for (let i = n - 1; i >= 0; i--) post.push(post[post.length - 1] | BigInt(nums[i]));\\n    let res = 0n;\\n    for (let i = 0; i < n; i++) {\\n        let cur = BigInt(nums[i]);\\n        let v = cur * BigInt(2 ** k) | prev[i] | post[n - i - 1];\\n        if (v > res) {\\n            res = v;\\n        }\\n    }\\n    return Number(res);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar maximumOr = function(nums, k) {\\n   let n = nums.length;\\n    let prev = [0n];\\n    let post = [0n];\\n    for (let i = 0; i < n; i++) prev.push(prev[prev.length - 1] | BigInt(nums[i]))\\n    for (let i = n - 1; i >= 0; i--) post.push(post[post.length - 1] | BigInt(nums[i]));\\n    let res = 0n;\\n    for (let i = 0; i < n; i++) {\\n        let cur = BigInt(nums[i]);\\n        let v = cur * BigInt(2 ** k) | prev[i] | post[n - i - 1];\\n        if (v > res) {\\n            res = v;\\n        }\\n    }\\n    return Number(res);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3520474,
                "title": "max-bits-from-multiple-numbers-or-bits-from-any-number-not-in-current-number-or-num-lsh-k",
                "content": "- Time complexity: $O(n)$ - we iterate over nums twice\\n- Space complexity: $O(1)$ - we use constant auxiliary memory with 6 temporary variables\\n```golang []\\nfunc maximumOr(nums []int, k int) int64 {\\n    // O(n) - determine bits that appear in multiple numbers and those that appear in any number\\n    appearsInMultiple := 0\\n    appearsInAny := 0\\n    for _, num := range nums {\\n        appearsInMultiple |= appearsInAny & num\\n        appearsInAny |= num\\n    }\\n\\n    // O(n) - determine maximum number we can form by taking\\n    // bits that appear in multiple numbers, bits that appear\\n    // in any number that don\\'t appear in current num, and bits\\n    // we get from LSH of current num by k\\n    max := int64(appearsInAny)\\n    for _, num := range nums {\\n        n := int64(appearsInMultiple) | int64(appearsInAny & ^num) | int64(num) << k\\n        if n > max {\\n            max = n\\n        }\\n    }\\n\\n    return max\\n}\\n```\\n```python3 []\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        # O(n) - determine bits that appear in multiple numbers and those\\n        # that appear in any number\\n        appearsInMultiple = 0\\n        appearsInAny = 0\\n        for num in nums:\\n            appearsInMultiple |= appearsInAny & num\\n            appearsInAny |= num\\n\\n        # O(n) - determine maximum number we can form by taking\\n        # bits that appear in multiple numbers, bits that appear\\n        # in any number that don\\'t appear in current num, and bits\\n        # we get from LSH of current num by k\\n        maximum = appearsInAny\\n        for num in nums:\\n            maximum = max(maximum, appearsInMultiple | appearsInAny & ~num | num << k)\\n\\n        return maximum\\n```\\n```typescript []\\nconst maximumOr = (nums: number[], k: number): number => {\\n    // O(n) - determine bits that appear in multiple numbers and those\\n    // that appear in any number\\n    let appearsInMultiple = 0n, appearsInAny = 0n\\n    for (let num of nums) {\\n        appearsInMultiple |= appearsInAny & BigInt(num)\\n        appearsInAny |= BigInt(num)\\n    }\\n\\n    // O(n) - determine maximum number we can form by taking\\n    // bits that appear in multiple numbers, bits that appear\\n    // in any number that don\\'t appear in current num, and bits\\n    // we get from LSH of current num by k\\n    let maximum = appearsInAny\\n    for (let num of nums) {\\n        const n = appearsInMultiple | appearsInAny & ~BigInt(num) | BigInt(num) << BigInt(k)\\n        if (n > maximum) {\\n            maximum = n\\n        }\\n    }\\n\\n    return Number(maximum)\\n}\\n```\\n```javascript []\\nconst maximumOr = (nums, k) => {\\n    // O(n) - determine bits that appear in multiple numbers and those\\n    // that appear in any number\\n    let appearsInMultiple = 0n, appearsInAny = 0n\\n    for (let num of nums) {\\n        appearsInMultiple |= appearsInAny & BigInt(num)\\n        appearsInAny |= BigInt(num)\\n    }\\n\\n    // O(n) - determine maximum number we can form by taking\\n    // bits that appear in multiple numbers, bits that appear\\n    // in any number that don\\'t appear in current num, and bits\\n    // we get from LSH of current num by k\\n    let maximum = appearsInAny\\n    for (let num of nums) {\\n        const n = appearsInMultiple | appearsInAny & ~BigInt(num) | BigInt(num) << BigInt(k)\\n        if (n > maximum) {\\n            maximum = n\\n        }\\n    }\\n\\n    return Number(maximum)\\n}\\n```\\n\\nSolutions for other problems in biweekly contest 104:\\n\\n- [2678. Number of Senior Citizens\\n](/problems/number-of-senior-citizens/solutions/3520347/go-extract-11th-12th-character-and-check-if-60/)\\n- [2679. Sum in a Matrix\\n](/problems/sum-in-a-matrix/solutions/3520365/go-sort-rows-in-onm-log-m-time-then-determine-max-per-column/)",
                "solutionTags": [
                    "Python3",
                    "JavaScript",
                    "Go",
                    "TypeScript"
                ],
                "code": "```golang []\\nfunc maximumOr(nums []int, k int) int64 {\\n    // O(n) - determine bits that appear in multiple numbers and those that appear in any number\\n    appearsInMultiple := 0\\n    appearsInAny := 0\\n    for _, num := range nums {\\n        appearsInMultiple |= appearsInAny & num\\n        appearsInAny |= num\\n    }\\n\\n    // O(n) - determine maximum number we can form by taking\\n    // bits that appear in multiple numbers, bits that appear\\n    // in any number that don\\'t appear in current num, and bits\\n    // we get from LSH of current num by k\\n    max := int64(appearsInAny)\\n    for _, num := range nums {\\n        n := int64(appearsInMultiple) | int64(appearsInAny & ^num) | int64(num) << k\\n        if n > max {\\n            max = n\\n        }\\n    }\\n\\n    return max\\n}\\n```\n```python3 []\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        # O(n) - determine bits that appear in multiple numbers and those\\n        # that appear in any number\\n        appearsInMultiple = 0\\n        appearsInAny = 0\\n        for num in nums:\\n            appearsInMultiple |= appearsInAny & num\\n            appearsInAny |= num\\n\\n        # O(n) - determine maximum number we can form by taking\\n        # bits that appear in multiple numbers, bits that appear\\n        # in any number that don\\'t appear in current num, and bits\\n        # we get from LSH of current num by k\\n        maximum = appearsInAny\\n        for num in nums:\\n            maximum = max(maximum, appearsInMultiple | appearsInAny & ~num | num << k)\\n\\n        return maximum\\n```\n```typescript []\\nconst maximumOr = (nums: number[], k: number): number => {\\n    // O(n) - determine bits that appear in multiple numbers and those\\n    // that appear in any number\\n    let appearsInMultiple = 0n, appearsInAny = 0n\\n    for (let num of nums) {\\n        appearsInMultiple |= appearsInAny & BigInt(num)\\n        appearsInAny |= BigInt(num)\\n    }\\n\\n    // O(n) - determine maximum number we can form by taking\\n    // bits that appear in multiple numbers, bits that appear\\n    // in any number that don\\'t appear in current num, and bits\\n    // we get from LSH of current num by k\\n    let maximum = appearsInAny\\n    for (let num of nums) {\\n        const n = appearsInMultiple | appearsInAny & ~BigInt(num) | BigInt(num) << BigInt(k)\\n        if (n > maximum) {\\n            maximum = n\\n        }\\n    }\\n\\n    return Number(maximum)\\n}\\n```\n```javascript []\\nconst maximumOr = (nums, k) => {\\n    // O(n) - determine bits that appear in multiple numbers and those\\n    // that appear in any number\\n    let appearsInMultiple = 0n, appearsInAny = 0n\\n    for (let num of nums) {\\n        appearsInMultiple |= appearsInAny & BigInt(num)\\n        appearsInAny |= BigInt(num)\\n    }\\n\\n    // O(n) - determine maximum number we can form by taking\\n    // bits that appear in multiple numbers, bits that appear\\n    // in any number that don\\'t appear in current num, and bits\\n    // we get from LSH of current num by k\\n    let maximum = appearsInAny\\n    for (let num of nums) {\\n        const n = appearsInMultiple | appearsInAny & ~BigInt(num) | BigInt(num) << BigInt(k)\\n        if (n > maximum) {\\n            maximum = n\\n        }\\n    }\\n\\n    return Number(maximum)\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520278,
                "title": "simple-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        int n = nums.length;\\n        long[] prefix = new long[n];\\n        long[] suffix = new long[n];\\n        prefix[0] = 0;\\n        suffix[n-1] = 0;\\n        for(int i= 1;i<n;i++)\\n        {\\n            prefix[i] = prefix[i-1]|nums[i-1];\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            suffix[i] = suffix[i+1]|nums[i+1];\\n        }\\n        long max =0;\\n        for(int i=0;i<n;i++)\\n        {\\n            long val = prefix[i]|suffix[i];\\n            long v = nums[i]*(long)Math.pow(2,k);\\n            max = Math.max(max,val|v);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        int n = nums.length;\\n        long[] prefix = new long[n];\\n        long[] suffix = new long[n];\\n        prefix[0] = 0;\\n        suffix[n-1] = 0;\\n        for(int i= 1;i<n;i++)\\n        {\\n            prefix[i] = prefix[i-1]|nums[i-1];\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            suffix[i] = suffix[i+1]|nums[i+1];\\n        }\\n        long max =0;\\n        for(int i=0;i<n;i++)\\n        {\\n            long val = prefix[i]|suffix[i];\\n            long v = nums[i]*(long)Math.pow(2,k);\\n            max = Math.max(max,val|v);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951445,
                "title": "why-num-k-explanation-simple-easy-step-by-step-thinking-process-easy-prefix-sum-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe start by checking the binary representation of the numbers.\\n\\nLet\\'s take an example: \\n\\n`nums = [1,2], k = 2`\\n\\nWe write the numbers in their binary represenations.\\n\\n1 -> `1` | 2 -> `10`\\n\\n**Observation 1:** The maximum number that can be made is by multiplying the number with maximum number of bits in it\\'s binary representation.\\n\\nIn this example, we have k = 2, We have 3 cases:\\n- We use both operations for `idx: 0` then we will convert 1 (`1`) -> 4 (`100`) and our result will be `4 | 2 = 6`\\n- We use one operation for `idx: 0` and the second one for `idx: 1` then we will convert 1 (`1`) -> 2 (`10`) and 2 (`10`) -> 4 (`100`) and our result will be `2 | 4 = 6`\\n- We use both for `idx: 1` then we will convert 2 (`10`) -> 8 (`1000`) and our result will be `1 | 8 = 9`\\n\\nIt can be observed that performing the operations on the number which has highest number of bits can give us the maximum result, which is `9` for this example.\\n\\nHere\\'s the second case what if we have multiple numbers sharing the maximum number of bits.\\n\\nLet\\'s take an example again:\\n\\n`nums = [12,9], k = 2`\\n\\nHere we have 12 -> `1100` and 9 -> `1001`\\n\\nBoth of them have maximum number of bits which is 4. Here we have k = 2.\\n\\n - Supose we apply first operation on `idx: 0` then it will become 12 (`1100`) -> 24 (`11000`) and the other number would be 9 (`1001`)\\n - Now we only applied one operation and we still have one operation left (initially `k=2`)\\n - Now our array is `[24, 9]`\\n - Now we can see that 24 (`11000`) has maximum number of bits and according to the `Observation 1`, applying all operations on it will give us the maximum result for the array -> `[24, 9]`\\n - After apply the rest of the operations on `24` our array becomes `[48, 9]` our final result becomes `48 | 9 = 57`\\n\\nNow we apply the same thing we `idx: 1`\\n- Apply one operation then it will become 9 (`1001`) -> 18 (`10010`).\\n- Our new array is `[12, 18]`\\n- Now we can see that 18 (`10010`) has maximum number of bits and according to the `Observation 1`, applying all operations on it will give us the maximum result for the array -> `[12, 18]`\\n- After apply the rest of the operations on `18` our array becomes `[12, 36]` our final result becomes `12 | 36 = 44`\\n\\nNow our final answer for the array `[12, 9]` and `k=2` will be the maximum of `57` and `44` which is `57`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Base Case: If the size of the input is `1` we can just return `nums[0]*k`\\n- Now we loop over the input array and for each index we use all the operations on the current index that is `nums[idx]*k`\\nTo calculate the answer for this index, we also need the OR of the rest of the elements. For this we use prefix and suffix array.\\n- We build the prefix and suffix array.\\n```\\n        vector<long long> pref(n+1), suff(n+1);\\n        \\n\\n        for (int i = 0; i < n; i++) {\\n            pref[i + 1] = pref[i] | nums[i];\\n        }\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            suff[i] = suff[i + 1] | nums[i];\\n        }\\n```\\n- To calucalte the answer for the current index we have three thing to consider `pref[i]`, `nums[idx]*k` and `suff[i+1]`.\\n- The result for current index will be `pref[i] | nums[idx] * k | suff[i+1]`\\n- Our final answer will be the maximum of the results we get from each index.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n- Here we are computing prefix OR on the fly.\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n\\n    long long maximumOr(vector<int> &nums, int k) {\\n        int n = nums.size();\\n        if(n == 1)\\n            return nums[0]*1LL << k;\\n\\n        vector<ll> suff(n+1);\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            suff[i] = suff[i + 1] | nums[i];\\n        }\\n\\n        int preOR = 0;\\n\\n        ll ans = 0;\\n        for(int i =0; i < n; i++) {\\n            ll curr = nums[i]*1LL << k;\\n            ll tmp = preOR | curr | suff[i+1];\\n            preOR |= nums[i];\\n            ans = max(ans, tmp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Prefix Sum"
                ],
                "code": "```\\n        vector<long long> pref(n+1), suff(n+1);\\n        \\n\\n        for (int i = 0; i < n; i++) {\\n            pref[i + 1] = pref[i] | nums[i];\\n        }\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            suff[i] = suff[i + 1] | nums[i];\\n        }\\n```\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n\\n    long long maximumOr(vector<int> &nums, int k) {\\n        int n = nums.size();\\n        if(n == 1)\\n            return nums[0]*1LL << k;\\n\\n        vector<ll> suff(n+1);\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            suff[i] = suff[i + 1] | nums[i];\\n        }\\n\\n        int preOR = 0;\\n\\n        ll ans = 0;\\n        for(int i =0; i < n; i++) {\\n            ll curr = nums[i]*1LL << k;\\n            ll tmp = preOR | curr | suff[i+1];\\n            preOR |= nums[i];\\n            ans = max(ans, tmp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693068,
                "title": "bit-manipulation-approach-tc-o-n-sc-o-1-java-solution-clean-code",
                "content": "# Intuition\\nLet `n = nums.length`\\nLet\\'s assume $k = 1$. We can multiply each number by $2$ one-by-one and for each we will calculate `nums[0] | nums[1] | ... | nums[n - 1]`. The answer will be maximum among all of this.\\nNow let\\'s say $k \\\\gt 1$. For each $k$ we have $n$ choices to pick. But rathar then picking other element, it is always better to pick an element which was giving maximum answer for $k = 1$ and multiply it further for $k - 1$ times and take maximum for answer.\\nSo, in general we can multiply each number by $2^k$ one-by-one and for each we will calculate `nums[0] | nums[1] | ... | nums[n - 1]`. The answer will be maximum among all of this.\\n\\n# Approach\\n- Store the total bitcount for each index from $0$ to $63$ in `bits` array. (this array will be used to calculate `nums[0] | nums[1] | ... | nums[n - 1]` in nearly $O(1)$ time)\\n- For each `t` in `nums`\\n    - Remove the actual bitcount of `t` from `bits` array\\n    - Multiply it by $2$\\n    - Add the new bitcount in `bits` array. if bitcount at this index is > 0 then add it the `curr` answer\\n    - Remove the new bitcount and add the actual one to get back to original state\\n- Take maximum of `curr` for each `t` \\n\\n# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        long bits[] = new long[64];\\n        for(int i = 0;i < nums.length;i++){\\n            for(int j = 0;j < 64;j++){\\n                bits[j] += (((long)nums[i] >> j) & 1);\\n            }\\n        }\\n        long max = 0;\\n        for(int i = 0;i < nums.length;i++){\\n            long t = nums[i];\\n            for(int j = 0;j < 64;j++){\\n                bits[j] -= ((t >> j) & 1); // removing actual bitcount\\n            }\\n            t *= (1L << k);\\n            long curr = 0;\\n            for(int j = 0;j < 64;j++){\\n                bits[j] += ((t >> j) & 1); // adding new bitcount\\n                if(bits[j] > 0) curr |= (1L << j);\\n                bits[j] -= ((t >> j) & 1); // removing new bitcount\\n                bits[j] += (((long)nums[i] >> j) & 1); // adding actual bitcount\\n            }\\n            max = Math.max(max,curr);\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\n# Upvote if you like it \\uD83D\\uDC4D\\uD83D\\uDC4D",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```java\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        long bits[] = new long[64];\\n        for(int i = 0;i < nums.length;i++){\\n            for(int j = 0;j < 64;j++){\\n                bits[j] += (((long)nums[i] >> j) & 1);\\n            }\\n        }\\n        long max = 0;\\n        for(int i = 0;i < nums.length;i++){\\n            long t = nums[i];\\n            for(int j = 0;j < 64;j++){\\n                bits[j] -= ((t >> j) & 1); // removing actual bitcount\\n            }\\n            t *= (1L << k);\\n            long curr = 0;\\n            for(int j = 0;j < 64;j++){\\n                bits[j] += ((t >> j) & 1); // adding new bitcount\\n                if(bits[j] > 0) curr |= (1L << j);\\n                bits[j] -= ((t >> j) & 1); // removing new bitcount\\n                bits[j] += (((long)nums[i] >> j) & 1); // adding actual bitcount\\n            }\\n            max = Math.max(max,curr);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541244,
                "title": "prefix-or-suffix-or-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        long long mul = 1<<k;\\n        int n = nums.size();\\n        vector<int> pre(n),suf(n);\\n        pre[0] = nums[0];\\n        suf[n-1] = nums[n-1];\\n        for(int i = 1;i < n;i++){\\n            pre[i] = nums[i] | pre[i-1];\\n            suf[n-1-i] = nums[n-i-1] | suf[n-i];\\n        }\\n        long long ans = 0;\\n        long long temp = 0;\\n        for(int i = 0;i < n;i++){\\n            temp = mul*nums[i];\\n            if(i-1 >= 0){\\n                temp = temp | pre[i-1];\\n            }\\n            if(i+1 < n){\\n                temp = temp | suf[i+1];\\n            }\\n            ans = max(temp,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Bit Manipulation",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        long long mul = 1<<k;\\n        int n = nums.size();\\n        vector<int> pre(n),suf(n);\\n        pre[0] = nums[0];\\n        suf[n-1] = nums[n-1];\\n        for(int i = 1;i < n;i++){\\n            pre[i] = nums[i] | pre[i-1];\\n            suf[n-1-i] = nums[n-i-1] | suf[n-i];\\n        }\\n        long long ans = 0;\\n        long long temp = 0;\\n        for(int i = 0;i < n;i++){\\n            temp = mul*nums[i];\\n            if(i-1 >= 0){\\n                temp = temp | pre[i-1];\\n            }\\n            if(i+1 < n){\\n                temp = temp | suf[i+1];\\n            }\\n            ans = max(temp,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529994,
                "title": "beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        int len = nums.length;\\n        long pre[] = new long[len + 1];\\n        long suf[] = new long[len + 1];\\n        long res = 0, pow = 1;\\n        for(int i = 0; i < k; i++) {\\n            pow *= 2;\\n        }\\n        pre[0] = 0;\\n        for(int i = 0; i < len; i++) pre[i + 1] = pre[i] | nums[i];\\n        \\n        suf[0] = 0;\\n        for(int i = len - 1; i >= 0; i--) suf[i] = suf[i + 1] | nums[i];\\n        \\n        for(int i = 0; i < len; i++) res = Math.max(res, pre[i] | (nums[i] * pow) | suf[i + 1]);\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        int len = nums.length;\\n        long pre[] = new long[len + 1];\\n        long suf[] = new long[len + 1];\\n        long res = 0, pow = 1;\\n        for(int i = 0; i < k; i++) {\\n            pow *= 2;\\n        }\\n        pre[0] = 0;\\n        for(int i = 0; i < len; i++) pre[i + 1] = pre[i] | nums[i];\\n        \\n        suf[0] = 0;\\n        for(int i = len - 1; i >= 0; i--) suf[i] = suf[i + 1] | nums[i];\\n        \\n        for(int i = 0; i < len; i++) res = Math.max(res, pre[i] | (nums[i] * pow) | suf[i + 1]);\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528482,
                "title": "rust-python-linear-with-full-math-proof-no-handwaving-only-math",
                "content": "# Math proof\\n\\nHere by the size of number I mean a lengh of its binary representation. For example `1011101` has size of `7`.\\n\\nLets assume that we have an array of numbers where one number has the size of `n` and all other numbers have the size of at most `n - 1`. And now we have `k` operations. Here I will prove that the best way to use them is to apply them all to the number of size `n`.\\n\\nTo prove this let\\'s see \\n 1. What is the minimum number we can achieve by applying k operations to max size number.\\n 2. What is the maximum or of numbers we can achive by applying k to other numbers\\n 3. Show that 1 > 2\\n\\n**1)** It will be $2^{n + k}$ (if we assume that our max-size number is one with all zeroes).\\n**2)** We can see that the maximum will be achived if all other numbers consist of only ones. So `111..1` where the number of ones is `n-1` which is $2^{n} - 1$. No matter what we do, with our `k` operations we can\\'t achieve the or of all numbers higher than $2^{n + k} - 1$\\n**3)** So it is clear that 1 > 2 and therefore we proved that in this case we need to apply all operations to max-size value.\\n\\nNow lets assume that there are `x` elements of max-size and `y`  elements of of smaller size. It is easy to see that you should not use any operations on smaller size elements. This is because if you used even only one operation on smaller size element, you end up with `x+1` max-size elements and `y-1` smaller size elements but have left `k-1` operations.\\n\\nSo we end up with a situation where we have `k` operations and all number of the same size $n$ and need to decided how we should use those operations. And similar to beginning proof we can show that the minimum number that we can achieve by applying all operations to one number is $2^{n + k}$ and the maximum number in all other cases are $2^{n + k} - 1$\\n\\n\\n\\n# Solution\\n\\nSo we showed that we need to find which number we need to multiply by $2^k$ to get the maximum or. How can we efficiently do this? For example if we want to efficintly multiply k-th number.\\n\\n$A_0, ... A_{k-1}, A_k, A_{k+1}, ... A_n$\\n\\nThe answer will be `prefix_or[A[0..k-1]] | (A[k] * 2^k) | suffix_or[A[k+1..n]]`\\n\\nSo this can be done in $O(1)$ for every element, by precomputing `prefix_or` and `suffix_or`.\\n\\n# Complexity\\n\\nWe iterate over an array 3 times and use 2 additional arrays.\\n\\n- Time complexity: $O(n)$\\n- Space complexity: $O(n)$\\n\\n# Code\\n\\n```Rust []\\nimpl Solution {\\n  pub fn maximum_or(nums: Vec<i32>, k: i32) -> i64 {\\n    let (mult, n) = (1 << k as u64, nums.len());\\n    let mut prefix_or = vec![0; n + 1];\\n    for i in 0 .. n {\\n      prefix_or[i + 1] = prefix_or[i] | nums[i] as u64;\\n    }\\n\\n    let mut suffix_or = vec![0; n + 1];\\n    for i in (0 .. n).rev() {\\n      suffix_or[i] = suffix_or[i + 1] | nums[i] as u64;\\n    }\\n\\n    let mut res = 0;\\n    for i in 0 .. n {\\n      res = res.max(prefix_or[i] | suffix_or[i + 1] | (nums[i] as u64 * mult));\\n    }\\n    return res as i64;\\n  }\\n}\\n```\\n```python []\\nclass Solution:\\n  def maximumOr(self, nums: List[int], k: int) -> int:\\n    mult, n = 1 << k, len(nums)\\n\\n    prefix_or = [0] * (n + 1)\\n    for i in range(n):\\n      prefix_or[i + 1] = prefix_or[i] | nums[i]\\n    \\n    suffix_or = [0] * (n + 1)\\n    for i in range(n - 1, -1, -1):\\n      suffix_or[i] = suffix_or[i + 1] | nums[i]\\n\\n    res = 0\\n    for i in range(n):\\n      res = max(res, prefix_or[i] | suffix_or[i + 1] | (nums[i] * mult))\\n    return res\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Rust"
                ],
                "code": "```Rust []\\nimpl Solution {\\n  pub fn maximum_or(nums: Vec<i32>, k: i32) -> i64 {\\n    let (mult, n) = (1 << k as u64, nums.len());\\n    let mut prefix_or = vec![0; n + 1];\\n    for i in 0 .. n {\\n      prefix_or[i + 1] = prefix_or[i] | nums[i] as u64;\\n    }\\n\\n    let mut suffix_or = vec![0; n + 1];\\n    for i in (0 .. n).rev() {\\n      suffix_or[i] = suffix_or[i + 1] | nums[i] as u64;\\n    }\\n\\n    let mut res = 0;\\n    for i in 0 .. n {\\n      res = res.max(prefix_or[i] | suffix_or[i + 1] | (nums[i] as u64 * mult));\\n    }\\n    return res as i64;\\n  }\\n}\\n```\n```python []\\nclass Solution:\\n  def maximumOr(self, nums: List[int], k: int) -> int:\\n    mult, n = 1 << k, len(nums)\\n\\n    prefix_or = [0] * (n + 1)\\n    for i in range(n):\\n      prefix_or[i + 1] = prefix_or[i] | nums[i]\\n    \\n    suffix_or = [0] * (n + 1)\\n    for i in range(n - 1, -1, -1):\\n      suffix_or[i] = suffix_or[i + 1] | nums[i]\\n\\n    res = 0\\n    for i in range(n):\\n      res = max(res, prefix_or[i] | suffix_or[i + 1] | (nums[i] * mult))\\n    return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523277,
                "title": "easy-prefix-and-suffix-approach-beats-88",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        long long ans = 0;\\n        vector<long long> prefix(n+1, 0);\\n        vector<long long> suffix(n+1, 0);\\n        long long temp = 1 << k;\\n        \\n        for(int i = 0; i < n; i++){\\n            prefix[i+1] = nums[i] | prefix[i];\\n        }\\n        for(int i = n-1; i >= 0; i--){\\n            suffix[i] = nums[i] | suffix[i+1];\\n        }\\n        \\n        for(int i = 0; i < n; i++){\\n            ans = max((prefix[i] | suffix[i+1] | temp*nums[i]), ans);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        long long ans = 0;\\n        vector<long long> prefix(n+1, 0);\\n        vector<long long> suffix(n+1, 0);\\n        long long temp = 1 << k;\\n        \\n        for(int i = 0; i < n; i++){\\n            prefix[i+1] = nums[i] | prefix[i];\\n        }\\n        for(int i = n-1; i >= 0; i--){\\n            suffix[i] = nums[i] | suffix[i+1];\\n        }\\n        \\n        for(int i = 0; i < n; i++){\\n            ans = max((prefix[i] | suffix[i+1] | temp*nums[i]), ans);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521515,
                "title": "python-prefix-suffix",
                "content": "I checked several solutions and created my own to see if I understood them correctly.\\nThe idea is here to find number with the highest `bit_length` and save the value at `max_bit` and numbers at `max_bit_list`. Meanwhile also find bitwise OR for all other numbers ans keep them in `ans`.\\nBecuase we want the maximum bitwise OR we want to shift left numbers `k` times. Thus we shift every numbers from `max_bit_list` and keep total maximum of OR operation.\\n\\n```\\nfrom operator import ior\\n\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        \\n        max_bit = 0\\n        max_bit_list = []\\n        ans = 0\\n        for n in nums:\\n            n_bits = n.bit_length()\\n            if n_bits > max_bit:\\n                max_bit_list.append(ans)\\n                ans = reduce(ior, max_bit_list)\\n                max_bit_list = [n,]\\n                max_bit = n_bits\\n            elif n_bits == max_bit:\\n                max_bit_list.append(n)\\n            else:\\n                ans |= n\\n        \\n        prefix = [0] * (len(max_bit_list))\\n        suffix = [0] * (len(max_bit_list))\\n        \\n        for i in range(1, len(max_bit_list)):\\n            prefix[i] = prefix[i - 1] | max_bit_list[i - 1]\\n        \\n        for i in range(len(max_bit_list) - 1, 0, -1):\\n            suffix[i - 1] = suffix[i] | max_bit_list[i]\\n\\n        ans2 = 0\\n        \\n        for i in range(len(max_bit_list)):\\n            ans2 = max(ans2, ans | prefix[i] | max_bit_list[i] << k | suffix[i])\\n            \\n        return ans2\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom operator import ior\\n\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        \\n        max_bit = 0\\n        max_bit_list = []\\n        ans = 0\\n        for n in nums:\\n            n_bits = n.bit_length()\\n            if n_bits > max_bit:\\n                max_bit_list.append(ans)\\n                ans = reduce(ior, max_bit_list)\\n                max_bit_list = [n,]\\n                max_bit = n_bits\\n            elif n_bits == max_bit:\\n                max_bit_list.append(n)\\n            else:\\n                ans |= n\\n        \\n        prefix = [0] * (len(max_bit_list))\\n        suffix = [0] * (len(max_bit_list))\\n        \\n        for i in range(1, len(max_bit_list)):\\n            prefix[i] = prefix[i - 1] | max_bit_list[i - 1]\\n        \\n        for i in range(len(max_bit_list) - 1, 0, -1):\\n            suffix[i - 1] = suffix[i] | max_bit_list[i]\\n\\n        ans2 = 0\\n        \\n        for i in range(len(max_bit_list)):\\n            ans2 = max(ans2, ans | prefix[i] | max_bit_list[i] << k | suffix[i])\\n            \\n        return ans2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521401,
                "title": "easiest-dynamic-programming-solution-c",
                "content": "What you have to do is  basically check if all different combinations of number when multiplied with 2 give the maximum bitwise OR or they do not.\\nSimple knapsack solution.\\nTime Complexity is (K* K* N)\\nSpace Complexity is (K*N)\\n```\\nclass Solution {\\npublic:\\n    long long dp[100005][16];\\n    long long recur(vector<int> &nums,int k,int index){\\n        if(index==nums.size())return 0;\\n        if(dp[index][k]!=-1)return dp[index][k];\\n        long long count = 1;\\n        long long maxx = 0;\\n        for(int i = 0; i<=k; i++){\\n            maxx = max(maxx,(nums[index]*count)|recur(nums,k-i,index+1));\\n            count*=2;\\n        }\\n        return dp[index][k] = maxx;\\n    }\\n    long long maximumOr(vector<int>& nums, int k) {\\n        memset(dp,-1,sizeof(dp));\\n        return recur(nums,k,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[100005][16];\\n    long long recur(vector<int> &nums,int k,int index){\\n        if(index==nums.size())return 0;\\n        if(dp[index][k]!=-1)return dp[index][k];\\n        long long count = 1;\\n        long long maxx = 0;\\n        for(int i = 0; i<=k; i++){\\n            maxx = max(maxx,(nums[index]*count)|recur(nums,k-i,index+1));\\n            count*=2;\\n        }\\n        return dp[index][k] = maxx;\\n    }\\n    long long maximumOr(vector<int>& nums, int k) {\\n        memset(dp,-1,sizeof(dp));\\n        return recur(nums,k,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521271,
                "title": "o-45n-simple",
                "content": "Make an array counting how many times each bit is in a number.\\nThen simply loop through each number n and compute what would happen if we doubled it k times. \\nFor each bit i to count, either \\n(1) B[i]>1 (will count for sure no matter what is done to n)\\n(2) B[i]=1 and (1<<i)&n=0 (changing n won\\'t change B[i])\\n(3) B[i]=0 but (n<<k)&(1<<i), doubling n k times will make it count.\\nSince n goes up to 10^9 which is less than 2^30, and k<=15, we go up to 45. \\n```\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        B = [0 for _ in range(45)]\\n        \\n        for n in nums:\\n            for i in range(30):\\n\\t\\t\\t    if (1<<i)&n: B[i]+=1\\n        \\n        ret = 0\\n        for n in nums:            \\n            Sn = 0\\n            for i in range(45):\\n                if B[i]>1: Sn+=(1<<i)\\n                elif B[i]==1 and (1<<i)&n==0: Sn+=(1<<i)\\n                elif (n<<k)&(1<<i): Sn+=(1<<i)\\n                    \\n            ret = max(ret,Sn)\\n        return ret\\n```",
                "solutionTags": [],
                "code": "```\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        B = [0 for _ in range(45)]\\n        \\n        for n in nums:\\n            for i in range(30):\\n\\t\\t\\t    if (1<<i)&n: B[i]+=1\\n        \\n        ret = 0\\n        for n in nums:            \\n            Sn = 0\\n            for i in range(45):\\n                if B[i]>1: Sn+=(1<<i)\\n                elif B[i]==1 and (1<<i)&n==0: Sn+=(1<<i)\\n                elif (n<<k)&(1<<i): Sn+=(1<<i)\\n                    \\n            ret = max(ret,Sn)\\n        return ret\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3521079,
                "title": "bit-operation-easy-solution",
                "content": "The key observation is that you should apply all the operations to any one of the element.\\nWhy?  Any 2^i is greater than the sum of all 2^(0 to i-1)\\nor (2^i> 2^(i-1)+2^(i-2).....+ 2^0), \\nso we will multiply any number k times, so that we get the highest set bit and thus the highest sum.\\n\\nSolution- We will check for every index by applying all the k operations at that index and then find the max resultant OR.\\n\\nTime Complexity: O(N * 50)\\nSpace Complexity: O(50)\\n\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        long long ans=0;\\n        vector<int> bit(50,0);\\n        for(auto x:nums) {\\n            for(int i=0;i<31;i++) {\\n                if(x&(1<<i)) \\n                    bit[i]++;\\n            }\\n        }\\n        for(auto x:nums) {\\n            vector<int> temp=bit;\\n            for(int i=0;i<31;i++) {\\n                if(x&(1<<i)) \\n                    temp[i+k]++,temp[i]--;\\n            }\\n            long long num=0;\\n            for(auto i=0;i<50;i++) \\n                if(temp[i]) num+=(1LL<<i);\\n            if(num>ans) ans=num;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\nHappy Coding",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        long long ans=0;\\n        vector<int> bit(50,0);\\n        for(auto x:nums) {\\n            for(int i=0;i<31;i++) {\\n                if(x&(1<<i)) \\n                    bit[i]++;\\n            }\\n        }\\n        for(auto x:nums) {\\n            vector<int> temp=bit;\\n            for(int i=0;i<31;i++) {\\n                if(x&(1<<i)) \\n                    temp[i+k]++,temp[i]--;\\n            }\\n            long long num=0;\\n            for(auto i=0;i<50;i++) \\n                if(temp[i]) num+=(1LL<<i);\\n            if(num>ans) ans=num;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520909,
                "title": "prefix-suffix-with-intuitiion-why-to-increase-only-one-element-why-not-spread-it",
                "content": "# Intuition\\n1. or operation\\n2. k is very small\\n3. multiply with 2 -> left shifting\\n\\ncorrect statement multiplying the number with left most msb is most benificial as it will make the or more bigger as it has MSB at.\\n\\nnow there can be multiple numbers with left most msbs. We have to choose one of them. \\nWhich one will be best option to choose ?\\n- the one which after choosing if done an OR with rest of the numbers will give max OR result / will have lesser \\nimposition of bits\\n\\nwhy not spread k accross multiple numbers with left most msb? \\n- even if we do k-1 with a number and 1 with another then we are reducing the or potentially by 2^k.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\n        vector<long long> prefixOr(n, 0), suffixOr(n, 0);\\n\\n        for (int i = 1; i < n; i++) {\\n            prefixOr[i] = (prefixOr[i-1]|nums[i-1]);\\n        } \\n\\n        for (int i = n-2; i >= 0; i--) {\\n            suffixOr[i] = (suffixOr[i+1]|nums[i+1]);\\n        }\\n\\n        long long p = pow(2,k);\\n        long long ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            ans = max(ans, (prefixOr[i]|suffixOr[i])|(nums[i]*p));\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\n        vector<long long> prefixOr(n, 0), suffixOr(n, 0);\\n\\n        for (int i = 1; i < n; i++) {\\n            prefixOr[i] = (prefixOr[i-1]|nums[i-1]);\\n        } \\n\\n        for (int i = n-2; i >= 0; i--) {\\n            suffixOr[i] = (suffixOr[i+1]|nums[i+1]);\\n        }\\n\\n        long long p = pow(2,k);\\n        long long ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            ans = max(ans, (prefixOr[i]|suffixOr[i])|(nums[i]*p));\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520776,
                "title": "easy-solution-with-sc-tc-intution",
                "content": "\\n# Intution\\n  1. We do k operations on ONE picked element => This is because if a number is picked and a operation is done once it is giving max result , then this means doing it k times maximisesour ans (we are left shifing each time)\\n2. Why not maximum element picked give correct ans?\\n        \\n    ->eg: \\n        12: 1 1 0 0\\n         9: 1 0 0 1\\n        \\n        24: 1 1 0 0 0      12:   1 1 0 0\\n        9:    1 0 0 1      18: 1 0 0 1 0 \\n        25                 30\\n        So, In case numbers are in NOT very far from each , we cant pick the the greatest . We have to TRY Each element\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$ \\n\\n- Space complexity:\\n$$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        long long ans = 0,p = 1;\\n        vector<long long> prefix_or(n,0),suffix_or(n,0);\\n\\n        p = p<<k;\\n\\n        prefix_or[0] = nums[0];\\n        for(int i=1;i<n;i++){\\n            prefix_or[i] = prefix_or[i-1]|nums[i];\\n        }\\n        suffix_or[n-1] = nums[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            suffix_or[i] = suffix_or[i+1]|nums[i];\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            long long small_ans =  (i>=1?prefix_or[i-1]:0)|(i<=n-2?suffix_or[i+1]:0)|(nums[i]*p);\\n            ans = max(ans,small_ans);\\n        }\\n\\n        return ans;\\n\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        long long ans = 0,p = 1;\\n        vector<long long> prefix_or(n,0),suffix_or(n,0);\\n\\n        p = p<<k;\\n\\n        prefix_or[0] = nums[0];\\n        for(int i=1;i<n;i++){\\n            prefix_or[i] = prefix_or[i-1]|nums[i];\\n        }\\n        suffix_or[n-1] = nums[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            suffix_or[i] = suffix_or[i+1]|nums[i];\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            long long small_ans =  (i>=1?prefix_or[i-1]:0)|(i<=n-2?suffix_or[i+1]:0)|(nums[i]*p);\\n            ans = max(ans,small_ans);\\n        }\\n\\n        return ans;\\n\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520747,
                "title": "prefix-or-current-element-or-suffix",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<long long>pOR(n),sOR(n);\\n        pOR[0]=nums[0];\\n        sOR[n-1]=nums[n-1];\\n        \\n        for(int i=1;i<nums.size();i++)\\n        {\\n            pOR[i]=pOR[i-1] | nums[i];\\n        }\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            sOR[i]=sOR[i+1] | nums[i];\\n        }\\n        \\n        long long ans=0;\\n        int kk;\\n        for(int i=0;i<n;i++)\\n        {\\n            kk=k;\\n            long long p;\\n            if(i==0) \\n                p=0;\\n            else \\n                p=pOR[i-1];\\n            \\n            long long s;\\n            if(i==n-1) \\n                s=0;\\n            else \\n                s=sOR[i+1];\\n            \\n            long long x=nums[i];\\n            while(kk--)\\n            {\\n                x*=2;\\n            }\\n            \\n            long long cor=p;\\n            cor = cor | x;\\n            cor = cor | s;\\n            ans=max(ans,cor);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n# ***PLS UPVOTE***",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<long long>pOR(n),sOR(n);\\n        pOR[0]=nums[0];\\n        sOR[n-1]=nums[n-1];\\n        \\n        for(int i=1;i<nums.size();i++)\\n        {\\n            pOR[i]=pOR[i-1] | nums[i];\\n        }\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            sOR[i]=sOR[i+1] | nums[i];\\n        }\\n        \\n        long long ans=0;\\n        int kk;\\n        for(int i=0;i<n;i++)\\n        {\\n            kk=k;\\n            long long p;\\n            if(i==0) \\n                p=0;\\n            else \\n                p=pOR[i-1];\\n            \\n            long long s;\\n            if(i==n-1) \\n                s=0;\\n            else \\n                s=sOR[i+1];\\n            \\n            long long x=nums[i];\\n            while(kk--)\\n            {\\n                x*=2;\\n            }\\n            \\n            long long cor=p;\\n            cor = cor | x;\\n            cor = cor | s;\\n            ans=max(ans,cor);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520678,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        long long ans = 0;\\n        long long aur = 0;\\n        vector<int> setbit(34, 0);\\n        for (int j = 0; j < nums.size(); j++){\\n            aur |= nums[j];\\n            int count = 0;\\n            int temp = nums[j];\\n            while(temp){\\n                if(temp % 2){\\n                    setbit[count]++;\\n                }\\n                temp /= 2;\\n                count++;\\n            }\\n        }\\n        for (int i = 0; i < nums.size(); i++){\\n            long long orr = aur;\\n            long long x = nums[i] * pow(2, k);\\n            int count = 0;\\n            int temp = nums[i];\\n            while(temp){\\n                if(temp % 2){\\n                    if(setbit[count] == 1){\\n                        orr ^= (long long)pow(2, count);\\n                    }\\n                }\\n                temp /= 2;\\n                count++;\\n            }\\n            orr |= x;\\n            ans = max(ans, orr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        long long ans = 0;\\n        long long aur = 0;\\n        vector<int> setbit(34, 0);\\n        for (int j = 0; j < nums.size(); j++){\\n            aur |= nums[j];\\n            int count = 0;\\n            int temp = nums[j];\\n            while(temp){\\n                if(temp % 2){\\n                    setbit[count]++;\\n                }\\n                temp /= 2;\\n                count++;\\n            }\\n        }\\n        for (int i = 0; i < nums.size(); i++){\\n            long long orr = aur;\\n            long long x = nums[i] * pow(2, k);\\n            int count = 0;\\n            int temp = nums[i];\\n            while(temp){\\n                if(temp % 2){\\n                    if(setbit[count] == 1){\\n                        orr ^= (long long)pow(2, count);\\n                    }\\n                }\\n                temp /= 2;\\n                count++;\\n            }\\n            orr |= x;\\n            ans = max(ans, orr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520627,
                "title": "easy-cpp-solution-using-prefix-sufix",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\no(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long helper(long long value , int k){\\n        while(k--){\\n            value*=(long long) 2;\\n        }\\n        return (long long)value;\\n    }\\n    long long maximumOr(vector<int>& nums, int k) {\\n       \\n        int n = nums.size();\\n        if(n == 1 ) return helper(nums[0],k);\\n       \\n        vector<int>prefix(n);\\n        vector<int>sufix(n);\\n\\n        prefix[0] = nums[0];\\n        sufix[n-1] = nums[n-1];\\n\\n        for(int i = 1 ; i<n; i++) \\n            prefix[i] = (nums[i]) | prefix[i-1];\\n        \\n        for(int i = n-2 ; i>= 0 ; i--) \\n            sufix[i] = (nums[i]) | sufix[i+1];\\n      \\n         long long maxi =  maxi = (helper(nums[0],k)) | sufix[1];\\n         maxi = max((helper(nums[n-1],k)) | prefix[n-2] , maxi);     \\n            \\n        for(int i = 1 ; i< n - 1 ; i++)  \\n             maxi = max(maxi, prefix[i-1] | sufix[i+1] |(helper(nums[i],k)) );\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long helper(long long value , int k){\\n        while(k--){\\n            value*=(long long) 2;\\n        }\\n        return (long long)value;\\n    }\\n    long long maximumOr(vector<int>& nums, int k) {\\n       \\n        int n = nums.size();\\n        if(n == 1 ) return helper(nums[0],k);\\n       \\n        vector<int>prefix(n);\\n        vector<int>sufix(n);\\n\\n        prefix[0] = nums[0];\\n        sufix[n-1] = nums[n-1];\\n\\n        for(int i = 1 ; i<n; i++) \\n            prefix[i] = (nums[i]) | prefix[i-1];\\n        \\n        for(int i = n-2 ; i>= 0 ; i--) \\n            sufix[i] = (nums[i]) | sufix[i+1];\\n      \\n         long long maxi =  maxi = (helper(nums[0],k)) | sufix[1];\\n         maxi = max((helper(nums[n-1],k)) | prefix[n-2] , maxi);     \\n            \\n        for(int i = 1 ; i< n - 1 ; i++)  \\n             maxi = max(maxi, prefix[i-1] | sufix[i+1] |(helper(nums[i],k)) );\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520586,
                "title": "easy-c-solution-prefix-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n) overall\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        long long p[n + 1], s[n + 1];\\n\\xA0\\xA0\\xA0     long long so, pow = 1;\\n\\xA0\\xA0\\xA0\\xA0 for (int i = 0; i < k; i++){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 pow*=2;\\n\\xA0\\xA0\\xA0\\xA0 }\\n\\n\\xA0\\xA0\\xA0 p[0] = 0;\\n\\xA0\\xA0\\xA0 for (int i = 0; i < n; i++){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 p[i + 1] = p[i] | nums[i];\\n\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0 s[n] = 0;\\n\\xA0\\xA0\\xA0 for (int i = n - 1; i >= 0; i--){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 s[i] = s[i + 1] | nums[i];\\n\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0 so= 0;\\n\\xA0\\xA0\\xA0 for (int i = 0; i < n; i++)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 so = max(so, p[i] | (nums[i] * pow) | s[i + 1]);\\n\\n\\xA0\\xA0\\xA0 return so;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        long long p[n + 1], s[n + 1];\\n\\xA0\\xA0\\xA0     long long so, pow = 1;\\n\\xA0\\xA0\\xA0\\xA0 for (int i = 0; i < k; i++){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 pow*=2;\\n\\xA0\\xA0\\xA0\\xA0 }\\n\\n\\xA0\\xA0\\xA0 p[0] = 0;\\n\\xA0\\xA0\\xA0 for (int i = 0; i < n; i++){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 p[i + 1] = p[i] | nums[i];\\n\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0 s[n] = 0;\\n\\xA0\\xA0\\xA0 for (int i = n - 1; i >= 0; i--){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 s[i] = s[i + 1] | nums[i];\\n\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0 so= 0;\\n\\xA0\\xA0\\xA0 for (int i = 0; i < n; i++)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 so = max(so, p[i] | (nums[i] * pow) | s[i + 1]);\\n\\n\\xA0\\xA0\\xA0 return so;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520585,
                "title": "rust-counting-the-bits",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince k <= 15, we can only select one number to apply all the operations. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nimpl Solution {\\n    pub fn maximum_or(nums: Vec<i32>, k: i32) -> i64 {\\n        let mut count= vec![0; 32];\\n\\n        for a in &nums {\\n            let (mut a, mut i) = (*a, 0);\\n            while a > 0 {\\n                count[i] += a % 2;\\n                a /= 2;\\n                i += 1;\\n            }\\n        }\\n\\n        let mut ret = 0;\\n\\n        for a in nums {\\n            let mut t = 0;\\n            for i in 0 .. 32 {\\n                if count[i] == 0 { continue }\\n                if count[i] == 1 && a & (1 << i as i64) > 0 { continue }\\n                t |= 1 << (i as i64);\\n            }\\n            t |= ((a as i64) << (k as i64));   \\n            ret = ret.max(t);\\n        }\\n\\n        ret\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn maximum_or(nums: Vec<i32>, k: i32) -> i64 {\\n        let mut count= vec![0; 32];\\n\\n        for a in &nums {\\n            let (mut a, mut i) = (*a, 0);\\n            while a > 0 {\\n                count[i] += a % 2;\\n                a /= 2;\\n                i += 1;\\n            }\\n        }\\n\\n        let mut ret = 0;\\n\\n        for a in nums {\\n            let mut t = 0;\\n            for i in 0 .. 32 {\\n                if count[i] == 0 { continue }\\n                if count[i] == 1 && a & (1 << i as i64) > 0 { continue }\\n                t |= 1 << (i as i64);\\n            }\\n            t |= ((a as i64) << (k as i64));   \\n            ret = ret.max(t);\\n        }\\n\\n        ret\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3520522,
                "title": "prefix-and-suffix-array-bitwise-or-simple-and-easy-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        if len(nums)==1:\\n            return nums[0]*(2**k)\\n        sufix = []\\n        prefix = []\\n        sufix.append(nums[0])\\n        prefix.append(nums[-1])\\n\\n        for i in range(1,len(nums)):\\n            sufix.append(sufix[-1]|nums[i])\\n        \\n        for i in range(len(nums)-2,-1,-1):\\n            prefix.append(prefix[-1]|nums[i])\\n        prefix = prefix[::-1]\\n\\n        n = 2**k\\n        res=[]\\n        for i in range(len(nums)):\\n            if i == 0:\\n                res.append(nums[i]*n|prefix[i+1])\\n            elif i == len(nums)-1:\\n                res.append(nums[i]*n|sufix[-2])\\n            else:\\n                res.append(nums[i]*n|sufix[i-1]|prefix[i+1])\\n        return max(res)\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        if len(nums)==1:\\n            return nums[0]*(2**k)\\n        sufix = []\\n        prefix = []\\n        sufix.append(nums[0])\\n        prefix.append(nums[-1])\\n\\n        for i in range(1,len(nums)):\\n            sufix.append(sufix[-1]|nums[i])\\n        \\n        for i in range(len(nums)-2,-1,-1):\\n            prefix.append(prefix[-1]|nums[i])\\n        prefix = prefix[::-1]\\n\\n        n = 2**k\\n        res=[]\\n        for i in range(len(nums)):\\n            if i == 0:\\n                res.append(nums[i]*n|prefix[i+1])\\n            elif i == len(nums)-1:\\n                res.append(nums[i]*n|sufix[-2])\\n            else:\\n                res.append(nums[i]*n|sufix[i-1]|prefix[i+1])\\n        return max(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520509,
                "title": "c-most-easy-intuitive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> pref(n,0);\\n        vector<int> suff(n,0);\\n        pref[0]=nums[0];\\n        suff[n-1]=nums[n-1];\\n        for(int i=1;i<n;i++)\\n            pref[i]=pref[i-1]|nums[i];\\n        for(int i=n-2;i>=0;i--)\\n            suff[i]=suff[i+1]|nums[i];\\n        long long ans=LONG_MIN;\\n        if(n==1)\\n        {\\n            while(k--)\\n                nums[0]=nums[0]<<1;\\n            return nums[0];\\n        }\\n        ll z1=nums[0];\\n        ll x1=k;\\n        while(x1--)\\n            z1=z1<<1;\\n        ans=max(ans,z1|suff[1]);\\n        ll z2=nums[n-1];\\n        ll x2=k;\\n        while(x2--)\\n            z2=z2<<1;\\n        ans=max(ans,z2|pref[n-2]);\\n        for(int i=1;i<n-1;i++)\\n        {\\n            long long x=k,z=nums[i];\\n            while(x--)\\n            z=z<<1;\\n            ans=max(ans,pref[i-1]|z|suff[i+1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> pref(n,0);\\n        vector<int> suff(n,0);\\n        pref[0]=nums[0];\\n        suff[n-1]=nums[n-1];\\n        for(int i=1;i<n;i++)\\n            pref[i]=pref[i-1]|nums[i];\\n        for(int i=n-2;i>=0;i--)\\n            suff[i]=suff[i+1]|nums[i];\\n        long long ans=LONG_MIN;\\n        if(n==1)\\n        {\\n            while(k--)\\n                nums[0]=nums[0]<<1;\\n            return nums[0];\\n        }\\n        ll z1=nums[0];\\n        ll x1=k;\\n        while(x1--)\\n            z1=z1<<1;\\n        ans=max(ans,z1|suff[1]);\\n        ll z2=nums[n-1];\\n        ll x2=k;\\n        while(x2--)\\n            z2=z2<<1;\\n        ans=max(ans,z2|pref[n-2]);\\n        for(int i=1;i<n-1;i++)\\n        {\\n            long long x=k,z=nums[i];\\n            while(x--)\\n            z=z<<1;\\n            ans=max(ans,pref[i-1]|z|suff[i+1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520452,
                "title": "prefix-and-suffix-or",
                "content": "# Code\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        ll val = 1, n = size(nums);\\n        for(int i=1; i<=k; ++i) val *= 2;\\n        vector<ll> pre(n),suff(n);\\n        pre[0] = nums[0];\\n        suff[n-1] = nums[n-1];\\n        for(int i=1; i<n; ++i) pre[i] = pre[i-1] | nums[i];\\n        for(int i=n-2; i>=0; --i) suff[i] = suff[i+1] | nums[i];\\n        ll ans = 0;\\n        for(int i=0; i<n; ++i){\\n            ll x = 0;\\n            if(i>0) x=pre[i-1];\\n            if(i != n-1) x |= suff[i+1];\\n            x |= (nums[i]*1ll*val);\\n            ans = max(ans,x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Suffix Array",
                    "Prefix Sum",
                    "Bitmask"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        ll val = 1, n = size(nums);\\n        for(int i=1; i<=k; ++i) val *= 2;\\n        vector<ll> pre(n),suff(n);\\n        pre[0] = nums[0];\\n        suff[n-1] = nums[n-1];\\n        for(int i=1; i<n; ++i) pre[i] = pre[i-1] | nums[i];\\n        for(int i=n-2; i>=0; --i) suff[i] = suff[i+1] | nums[i];\\n        ll ans = 0;\\n        for(int i=0; i<n; ++i){\\n            ll x = 0;\\n            if(i>0) x=pre[i-1];\\n            if(i != n-1) x |= suff[i+1];\\n            x |= (nums[i]*1ll*val);\\n            ans = max(ans,x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520405,
                "title": "c-using-precomputation",
                "content": "# Complexity\\n- Time complexity:`O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:`O(n)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    // check current element is creating maximum OR or not\\n    long long checkForCurrent(long long curr , int k){\\n        \\n        while(k--) curr *= 2;\\n        \\n        return curr;\\n    }\\n    \\n    long long maximumOr(vector<int>& nums, int k) {\\n        \\n        // input array length\\n        int n = nums.size();\\n        \\n        // result & current OR\\n        long long max_Or = 0 , curr = 0;\\n        \\n        // create prefix OR\\n        vector<int>pre(n);\\n        pre[0] = nums[0];\\n        \\n        for(int i=1;i<n;i++) pre[i] = pre[i-1] | nums[i];\\n        \\n        \\n        // create suffix OR\\n        vector<int>suf(n);\\n        suf[n-1] = nums[n-1];\\n        \\n        for(int i=n-2;i>=0;i--) suf[i] = suf[i+1] | nums[i];\\n\\n        \\n        // if array contains only 1 element\\n        if(n == 1) return checkForCurrent(nums[0],k);\\n        \\n        // check for first element\\n        curr = checkForCurrent(nums[0],k) | suf[1];  \\n        max_Or = max(curr,max_Or);\\n            \\n\\n        // check for last element\\n        curr = checkForCurrent(nums[n-1],k) | pre[n-2];  \\n        max_Or = max(curr,max_Or);\\n        \\n        // check for remaining element\\n        for(int i=1;i<n-1;i++){\\n            \\n            curr = checkForCurrent(nums[i],k);\\n            \\n            curr = suf[i+1] | pre[i-1] | curr;\\n            max_Or = max(curr,max_Or);\\n            \\n        }\\n        \\n        // result maximum OR\\n        return max_Or;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // check current element is creating maximum OR or not\\n    long long checkForCurrent(long long curr , int k){\\n        \\n        while(k--) curr *= 2;\\n        \\n        return curr;\\n    }\\n    \\n    long long maximumOr(vector<int>& nums, int k) {\\n        \\n        // input array length\\n        int n = nums.size();\\n        \\n        // result & current OR\\n        long long max_Or = 0 , curr = 0;\\n        \\n        // create prefix OR\\n        vector<int>pre(n);\\n        pre[0] = nums[0];\\n        \\n        for(int i=1;i<n;i++) pre[i] = pre[i-1] | nums[i];\\n        \\n        \\n        // create suffix OR\\n        vector<int>suf(n);\\n        suf[n-1] = nums[n-1];\\n        \\n        for(int i=n-2;i>=0;i--) suf[i] = suf[i+1] | nums[i];\\n\\n        \\n        // if array contains only 1 element\\n        if(n == 1) return checkForCurrent(nums[0],k);\\n        \\n        // check for first element\\n        curr = checkForCurrent(nums[0],k) | suf[1];  \\n        max_Or = max(curr,max_Or);\\n            \\n\\n        // check for last element\\n        curr = checkForCurrent(nums[n-1],k) | pre[n-2];  \\n        max_Or = max(curr,max_Or);\\n        \\n        // check for remaining element\\n        for(int i=1;i<n-1;i++){\\n            \\n            curr = checkForCurrent(nums[i],k);\\n            \\n            curr = suf[i+1] | pre[i-1] | curr;\\n            max_Or = max(curr,max_Or);\\n            \\n        }\\n        \\n        // result maximum OR\\n        return max_Or;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520307,
                "title": "prefix-and-suffix-arrays",
                "content": "# Intuition\\n1. Make a Prefix OR & Suffix OR array.\\n2. Now try to traverse the array and maximise the \\n```prefix[i-1] | nums[i]*2^k | suffix[i+1]```,\\n\\nthat means for each ```nums[i]``` we\\'re multiplying it with `2^k` ORing it with `prefix[i-1]` and `suffix[i+1]`, and checking if this `nums[i]` is giving us the Maximum Or.\\n\\n**Solve the 2nd example for better intution.**\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        int n = nums.length;\\n        \\n        long[] pref = new long[n], suff = new long[n];\\n        pref[0] = nums[0]; suff[n-1] = nums[n-1];\\n\\n        for(int i=1; i<n; i++){\\n            pref[i] = (pref[i-1] | nums[i]);\\n        }\\n        \\n        for(int i=n-2; i>=0; i--){\\n            suff[i] = (suff[i+1] | nums[i]);\\n        }\\n        \\n        long res = 0, mult = 1 << k;\\n        //mult = 2^k\\n        \\n        for(int i=0; i<n; i++){\\n            //temp = nums[i]*2^k\\n\\n            long temp = (long) mult * nums[i];\\n\\n            if(i-1 >= 0){\\n                //temp = temp | pref[i-1];\\n                temp |= pref[i-1];\\n            }\\n            \\n            if(i+1 < n){\\n                //temp = temp | suff[i+1];\\n                temp |= suff[i+1];\\n            }\\n            \\n            res = Math.max(temp, res);\\n        }\\n                \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```prefix[i-1] | nums[i]*2^k | suffix[i+1]```\n```nums[i]```\n```\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        int n = nums.length;\\n        \\n        long[] pref = new long[n], suff = new long[n];\\n        pref[0] = nums[0]; suff[n-1] = nums[n-1];\\n\\n        for(int i=1; i<n; i++){\\n            pref[i] = (pref[i-1] | nums[i]);\\n        }\\n        \\n        for(int i=n-2; i>=0; i--){\\n            suff[i] = (suff[i+1] | nums[i]);\\n        }\\n        \\n        long res = 0, mult = 1 << k;\\n        //mult = 2^k\\n        \\n        for(int i=0; i<n; i++){\\n            //temp = nums[i]*2^k\\n\\n            long temp = (long) mult * nums[i];\\n\\n            if(i-1 >= 0){\\n                //temp = temp | pref[i-1];\\n                temp |= pref[i-1];\\n            }\\n            \\n            if(i+1 < n){\\n                //temp = temp | suff[i+1];\\n                temp |= suff[i+1];\\n            }\\n            \\n            res = Math.max(temp, res);\\n        }\\n                \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520265,
                "title": "prefix-and-suffix-array-in-python",
                "content": "# Approach\\nFor every num in the nums array, we will multiply num by 2^k, and keep a track of the bitwise OR of all the array elements taken together. To perform this computation optimally, we keep a prefix and a suffix array.\\n    `prefix[i] = bitwise OR of elements at index 0 to i-1.`\\n    `suffix[i] = bitwise OR of elements at index i+1 to n-1.`\\n\\nThe reason why we are multiplying a single element by 2^k instead of multiple elements is simple. If we spread out the k over multiple elements, our max OR will not be multiplied by the most optimal multiplicative factor that it could have been.  \\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:        \\n        pre = [0]\\n        or_val = 0\\n        for num in nums:\\n            or_val |= num\\n            pre.append(or_val)\\n        pre.pop()\\n\\n        suf = [0]\\n        or_val = 0\\n        for idx in range(len(nums) - 1, -1, -1):\\n            num = nums[idx]\\n            or_val |= num\\n            suf.append(or_val)\\n        suf.pop()\\n        suf.reverse()\\n\\n        max_or = 0\\n        for idx in range(len(nums)):\\n            num = nums[idx] << k\\n            prefix = pre[idx]\\n            suffix = suf[idx]\\n\\n            max_or = max(max_or, num | prefix | suffix)\\n\\n        return (max_or)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:        \\n        pre = [0]\\n        or_val = 0\\n        for num in nums:\\n            or_val |= num\\n            pre.append(or_val)\\n        pre.pop()\\n\\n        suf = [0]\\n        or_val = 0\\n        for idx in range(len(nums) - 1, -1, -1):\\n            num = nums[idx]\\n            or_val |= num\\n            suf.append(or_val)\\n        suf.pop()\\n        suf.reverse()\\n\\n        max_or = 0\\n        for idx in range(len(nums)):\\n            num = nums[idx] << k\\n            prefix = pre[idx]\\n            suffix = suf[idx]\\n\\n            max_or = max(max_or, num | prefix | suffix)\\n\\n        return (max_or)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520262,
                "title": "easy-to-understand-solution-prefix-suffix",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll mypow(ll a, ll b) {\\nll res = 1;\\nwhile (b > 0) {\\nif (b & 1)\\nres = res * a*1ll;\\na = a * a*1ll;\\nb >>= 1;\\n}\\nreturn res;\\n}\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        ll x=0;\\n        if(n==1) return 1ll*nums[0]*mypow(2,k);\\n        vector<ll> pre(n,0),suf(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n           \\n            if(i==0)\\n                pre[i]=nums[i];\\n            else\\n            pre[i]=pre[i-1]|nums[i];\\n        }\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(i==n-1)\\n                suf[i]=nums[i];\\n            else\\n                suf[i]=suf[i+1]|nums[i];\\n        }\\n        ll ans=0;\\n       for(int i=0;i<n;i++)\\n       {\\n           ll x=1ll*nums[i]*1ll*mypow(2,k);\\n           if(i==0)\\n           {\\n               ans=max(ans,x|suf[i+1]);\\n           }\\n           else if(i==n-1)\\n           {\\n               ans=max(ans,x|pre[i-1]);\\n           }\\n           else\\n           {\\n               ans=max(ans,x|pre[i-1]|suf[i+1]);\\n           }\\n       }\\n       return ans; \\n     \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll mypow(ll a, ll b) {\\nll res = 1;\\nwhile (b > 0) {\\nif (b & 1)\\nres = res * a*1ll;\\na = a * a*1ll;\\nb >>= 1;\\n}\\nreturn res;\\n}\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        ll x=0;\\n        if(n==1) return 1ll*nums[0]*mypow(2,k);\\n        vector<ll> pre(n,0),suf(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n           \\n            if(i==0)\\n                pre[i]=nums[i];\\n            else\\n            pre[i]=pre[i-1]|nums[i];\\n        }\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(i==n-1)\\n                suf[i]=nums[i];\\n            else\\n                suf[i]=suf[i+1]|nums[i];\\n        }\\n        ll ans=0;\\n       for(int i=0;i<n;i++)\\n       {\\n           ll x=1ll*nums[i]*1ll*mypow(2,k);\\n           if(i==0)\\n           {\\n               ans=max(ans,x|suf[i+1]);\\n           }\\n           else if(i==n-1)\\n           {\\n               ans=max(ans,x|pre[i-1]);\\n           }\\n           else\\n           {\\n               ans=max(ans,x|pre[i-1]|suf[i+1]);\\n           }\\n       }\\n       return ans; \\n     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520205,
                "title": "python-3-prefix-suffix",
                "content": "```\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        bitwiseOr = lambda x, y: x | y\\n        \\n        forward = list(accumulate(nums, bitwiseOr))\\n        backward = list(accumulate(nums[ : : -1], bitwiseOr))[ : : -1]\\n        \\n        forward = [0] + forward[ : -1]\\n        backward = backward[1 : ] + [0]\\n        \\n        res = 0\\n        \\n        for i in range(len(nums)):\\n            total = forward[i] | backward[i]\\n            t = nums[i] * pow(2, k)\\n            \\n            res = max(res, total | t)\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        bitwiseOr = lambda x, y: x | y\\n        \\n        forward = list(accumulate(nums, bitwiseOr))\\n        backward = list(accumulate(nums[ : : -1], bitwiseOr))[ : : -1]\\n        \\n        forward = [0] + forward[ : -1]\\n        backward = backward[1 : ] + [0]\\n        \\n        res = 0\\n        \\n        for i in range(len(nums)):\\n            total = forward[i] | backward[i]\\n            t = nums[i] * pow(2, k)\\n            \\n            res = max(res, total | t)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4098158,
                "title": "space-o-1-no-prefix-or-suffix",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\np1: bitwiseOR of all elements\\np2: bitwiseOR of elements, but every bit occured at least 2 times\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int p1 = 0, p2 = 0;\\n        for(const auto num : nums) {\\n            p2 |= p1 & num;\\n            p1 |= num;\\n        }\\n        long long maxn = 0;\\n        for(const auto num : nums) {\\n            long long t = num;\\n            t = (t << k) | p1 - num | p2;\\n            if(maxn < t) {\\n                maxn = t;\\n            }\\n        }\\n        return maxn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int p1 = 0, p2 = 0;\\n        for(const auto num : nums) {\\n            p2 |= p1 & num;\\n            p1 |= num;\\n        }\\n        long long maxn = 0;\\n        for(const auto num : nums) {\\n            long long t = num;\\n            t = (t << k) | p1 - num | p2;\\n            if(maxn < t) {\\n                maxn = t;\\n            }\\n        }\\n        return maxn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3959657,
                "title": "greedy-runing-sum",
                "content": "**2 pass**\\n**time: `O(N)`; space: `O(N)`**\\n```\\nlong long maximumOr(vector<int>& n, int k) \\n{\\n\\tint d[100001]{};\\n\\tfor(int i(size(n)-1); i>=0; --i)\\n\\t\\td[i] = d[i+1]|n[i];\\n\\n\\tlong long out{};\\n\\tfor(int i{}, t{}; i<size(n); ++i)\\n\\t\\tout = max(out, t | 1ll*n[i]<<k | d[i+1]),\\n\\t\\tt |= n[i];\\n\\treturn out; \\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nlong long maximumOr(vector<int>& n, int k) \\n{\\n\\tint d[100001]{};\\n\\tfor(int i(size(n)-1); i>=0; --i)\\n\\t\\td[i] = d[i+1]|n[i];\\n\\n\\tlong long out{};\\n\\tfor(int i{}, t{}; i<size(n); ++i)\\n\\t\\tout = max(out, t | 1ll*n[i]<<k | d[i+1]),\\n\\t\\tt |= n[i];\\n\\treturn out; \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3907726,
                "title": "c-python-prefix-sum-solution-with-explanation",
                "content": "### greedy\\nk operations should be used on one numbers.\\nSo, enumerate each number and use k operations on a number.\\ncalculate suffix or array first, \\nand traverse ```nums```, caculate prefix or and do  k operations on each number to find max answer.\\n```0 | x = x```\\ntc is O(n), sc is O(n).\\n\\n### python\\n```python\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        suffix = [0] * (len(nums) + 1)\\n        for i in range(len(nums)-1,-1,-1): suffix[i] = suffix[i+1] | nums[i]\\n        \\n        ans = 0\\n        prefix = 0\\n        for i, x in enumerate(nums):\\n            cur = x << k | prefix | suffix[i+1]\\n            ans = ans if ans > cur else cur\\n            prefix |= x\\n        return ans\\n            \\n        \\n```\\n\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        vector<int> suffix (nums.size() + 1, 0);\\n        for (int i = nums.size() - 1; i >= 0; i+=1) suffix[i] = suffix[i+1] | nums[i];\\n        long long ans = 0, prefix = 0, cur;\\n        for (int i = 0; i < nums.size(); i+=1) {\\n            ans = max(ans, nums[i] << k | prefix | suffix[i+1]);\\n            prefix |= nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```nums```\n```0 | x = x```\n```python\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        suffix = [0] * (len(nums) + 1)\\n        for i in range(len(nums)-1,-1,-1): suffix[i] = suffix[i+1] | nums[i]\\n        \\n        ans = 0\\n        prefix = 0\\n        for i, x in enumerate(nums):\\n            cur = x << k | prefix | suffix[i+1]\\n            ans = ans if ans > cur else cur\\n            prefix |= x\\n        return ans\\n            \\n        \\n```\n```cpp\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        vector<int> suffix (nums.size() + 1, 0);\\n        for (int i = nums.size() - 1; i >= 0; i+=1) suffix[i] = suffix[i+1] | nums[i];\\n        long long ans = 0, prefix = 0, cur;\\n        for (int i = 0; i < nums.size(); i+=1) {\\n            ans = max(ans, nums[i] << k | prefix | suffix[i+1]);\\n            prefix |= nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843556,
                "title": "100-beating-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        int len = nums.length;\\n        long pre[] = new long[len + 1];\\n        long suf[] = new long[len + 1];\\n        long max = 0, pow = 1;\\n        for(int i = 0; i < k; i++) {\\n            pow *= 2;\\n        }\\n        pre[0] = 0;\\n        for(int i = 0; i < len; i++) pre[i + 1] = pre[i] | nums[i];\\n        \\n        suf[0] = 0;\\n        for(int i = len - 1; i >= 0; i--) suf[i] = suf[i + 1] | nums[i];\\n        \\n        for(int i = 0; i < len; i++) max = Math.max(max, pre[i] | (nums[i] * pow) | suf[i + 1]);\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        int len = nums.length;\\n        long pre[] = new long[len + 1];\\n        long suf[] = new long[len + 1];\\n        long max = 0, pow = 1;\\n        for(int i = 0; i < k; i++) {\\n            pow *= 2;\\n        }\\n        pre[0] = 0;\\n        for(int i = 0; i < len; i++) pre[i + 1] = pre[i] | nums[i];\\n        \\n        suf[0] = 0;\\n        for(int i = len - 1; i >= 0; i--) suf[i] = suf[i + 1] | nums[i];\\n        \\n        for(int i = 0; i < len; i++) max = Math.max(max, pre[i] | (nums[i] * pow) | suf[i + 1]);\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783588,
                "title": "python-solution-in-o-n-times-and-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is find maximum value of or-operations to arr after apply at most k times multiply by 2 for any items in arr.\\nmutilpy 2 to a number means, the number double, also means add 1 bit to left in binary:\\nif 11001 after *2 got: 111001\\nwe want maximum value that means we must got as much higher 1 bits as possible:\\nHow? just select one number and multply 2 by k times, get longgest binary as possible\\nWhy? if we use 2 numbers:a b, one increment x binary(x>0 and x<k), anther increment k-x binary, totaly not longger than just increment one of larger one\\n# so solution is try every item in nums, multipy it by pow(2,k), and | operate with other elements, record max-values so far.\\n# we can do or operations for array-elements in linear time, if we use prefixs and suffixs keep tracking:\\neg if arr=[a,b,c,d]\\nprefixs[0]=a prefixs[1]=a|b prefixs[2]=a|b|c prefixs[3]=a|b|c|d\\nsuffixs[0]=a|b|c|d suffixs[1]=b|c|d suffixs[2]=c|d suffixs[3]=d\\nso for value c in index 2:\\nf(c)=prefixs[1]|c*pow(2,k)|suffixs[2]\\nans=ans(f(c),ans)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maximumOr(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        def _shift(n,k):\\n            return pow(2,k)*n\\n        \\n        if len(nums)==1:return  _shift(nums[0],k)\\n        prefixs,suffixs=[0]*len(nums),[0]*len(nums)\\n        prefixs[0],suffixs[-1],ans=nums[0],nums[-1],0\\n        for i in range(1,len(nums)):prefixs[i]=prefixs[i-1]|nums[i]\\n        for i in range(len(nums)-2,-1,-1):suffixs[i]=suffixs[i+1]|nums[i]\\n        for i in range(len(nums)):\\n            if i==0:ans=max(ans,suffixs[i+1]|_shift(nums[i],k))\\n            elif i==len(nums)-1:ans=max(ans,prefixs[i-1]|_shift(nums[i],k))\\n            else:ans=max(ans,prefixs[i-1]|_shift(nums[i],k)|suffixs[i+1])\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maximumOr(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        def _shift(n,k):\\n            return pow(2,k)*n\\n        \\n        if len(nums)==1:return  _shift(nums[0],k)\\n        prefixs,suffixs=[0]*len(nums),[0]*len(nums)\\n        prefixs[0],suffixs[-1],ans=nums[0],nums[-1],0\\n        for i in range(1,len(nums)):prefixs[i]=prefixs[i-1]|nums[i]\\n        for i in range(len(nums)-2,-1,-1):suffixs[i]=suffixs[i+1]|nums[i]\\n        for i in range(len(nums)):\\n            if i==0:ans=max(ans,suffixs[i+1]|_shift(nums[i],k))\\n            elif i==len(nums)-1:ans=max(ans,prefixs[i-1]|_shift(nums[i],k))\\n            else:ans=max(ans,prefixs[i-1]|_shift(nums[i],k)|suffixs[i+1])\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738450,
                "title": "bit-manipulation-c-tc-o-n-sc-o-n",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n       int n = nums.size();\\n\\n       vector<long long> suffix(n, 0);\\n\\n       for (int idx = n - 2; idx >= 0; idx--) {\\n           suffix[idx] = suffix[idx + 1] | nums[idx + 1];\\n       }\\n        \\n       long long prefix = 0, maxOr = 0;\\n       int multFactor = 1 << k;\\n\\n       for (int idx = 0; idx < n; idx++) {\\n            maxOr = max(maxOr, prefix | (long long) nums[idx] * multFactor | suffix[idx]);\\n            \\n           prefix = prefix | nums[idx];\\n       }\\n\\n       return maxOr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n       int n = nums.size();\\n\\n       vector<long long> suffix(n, 0);\\n\\n       for (int idx = n - 2; idx >= 0; idx--) {\\n           suffix[idx] = suffix[idx + 1] | nums[idx + 1];\\n       }\\n        \\n       long long prefix = 0, maxOr = 0;\\n       int multFactor = 1 << k;\\n\\n       for (int idx = 0; idx < n; idx++) {\\n            maxOr = max(maxOr, prefix | (long long) nums[idx] * multFactor | suffix[idx]);\\n            \\n           prefix = prefix | nums[idx];\\n       }\\n\\n       return maxOr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724789,
                "title": "c-prefix-suffix-shift-1-k",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        long long ans=0,mul=1<<k;\\n        vector<long> pre(size(nums),0),suf(size(nums),0);\\n        pre[0]=nums[0];\\n        suf[size(nums)-1]=nums[size(nums)-1];\\n        for(int i=1;i<size(nums);++i){\\n            pre[i]=pre[i-1]|nums[i];\\n            suf[size(nums)-i-1]=suf[size(nums)-i]|nums[size(nums)-i-1];\\n        }\\n        for(int i=0;i<size(nums);++i){\\n            long long t=nums[i]*mul;\\n            if(i>0)t|=pre[i-1];\\n            if(i<size(nums)-1)t|=suf[i+1];\\n            ans=max(ans,t);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        long long ans=0,mul=1<<k;\\n        vector<long> pre(size(nums),0),suf(size(nums),0);\\n        pre[0]=nums[0];\\n        suf[size(nums)-1]=nums[size(nums)-1];\\n        for(int i=1;i<size(nums);++i){\\n            pre[i]=pre[i-1]|nums[i];\\n            suf[size(nums)-i-1]=suf[size(nums)-i]|nums[size(nums)-i-1];\\n        }\\n        for(int i=0;i<size(nums);++i){\\n            long long t=nums[i]*mul;\\n            if(i>0)t|=pre[i-1];\\n            if(i<size(nums)-1)t|=suf[i+1];\\n            ans=max(ans,t);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680179,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n         vector<long long>prefix(nums.size()+1,0);\\n         vector<long long>suffix(nums.size()+1,0);\\n         long long ans=-1e9;\\n         for(int i=0;i<nums.size();i++){\\n             prefix[i+1]=prefix[i]|nums[i];\\n         }\\n         for(int i=nums.size()-1;i>=0;i--){\\n             suffix[i]=suffix[i+1]|nums[i];\\n         }\\n         for(int i=0;i<nums.size();i++){\\n             ans=max(ans,prefix[i]|suffix[i+1]|((long long)pow(2,k)*(long long)nums[i]));\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n         vector<long long>prefix(nums.size()+1,0);\\n         vector<long long>suffix(nums.size()+1,0);\\n         long long ans=-1e9;\\n         for(int i=0;i<nums.size();i++){\\n             prefix[i+1]=prefix[i]|nums[i];\\n         }\\n         for(int i=nums.size()-1;i>=0;i--){\\n             suffix[i]=suffix[i+1]|nums[i];\\n         }\\n         for(int i=0;i<nums.size();i++){\\n             ans=max(ans,prefix[i]|suffix[i+1]|((long long)pow(2,k)*(long long)nums[i]));\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643863,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo solve this problem, we can use the approach of calculating prefix and suffix sums. For each element in the array, we can calculate the maximum possible value of nums[0] | nums[1] | ... | nums[n - 1] by multiplying it by 2^k and bitwise ORing it with the prefix sum of the elements before it and the suffix sum of the elements after it.\\n\\nHere\\'s the step-by-step algorithm:\\n\\nCalculate the prefix sum of the array. For each index i, the prefix sum prefix[i] is equal to the bitwise OR of all elements nums[0] | nums[1] | ... | nums[i].\\n\\nCalculate the suffix sum of the array. For each index i, the suffix sum suffix[i] is equal to the bitwise OR of all elements nums[i] | nums[i+1] | ... | nums[n-1].\\n\\nFor each index i in the array, calculate the maximum possible value of nums[0] | nums[1] | ... | nums[n - 1] by multiplying nums[i] by 2^k and bitwise ORing it with prefix[i-1] and suffix[i+1]. Take the maximum value obtained from all indices.\\n\\nReturn the maximum value obtained in step 3.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N);\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(N);\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] prefix = new int[n];\\n        int[] suffix = new int[n];\\n        \\n        prefix[0] = nums[0];\\n        for (int i = 1; i < n; i++) {\\n            prefix[i] = prefix[i-1] | nums[i];\\n        }\\n        \\n        suffix[n-1] = nums[n-1];\\n        for (int i = n-2; i >= 0; i--) {\\n            suffix[i] = suffix[i+1] | nums[i];\\n        }\\n        \\n        long maxOr = 0;\\n        for (int i = 0; i < n; i++) {\\n            long or = ((long) nums[i]) * (1L << k) | (i > 0 ? prefix[i-1] : 0) | (i < n-1 ? suffix[i+1] : 0);\\n            maxOr = Math.max(maxOr, or);\\n        }\\n        \\n        return maxOr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] prefix = new int[n];\\n        int[] suffix = new int[n];\\n        \\n        prefix[0] = nums[0];\\n        for (int i = 1; i < n; i++) {\\n            prefix[i] = prefix[i-1] | nums[i];\\n        }\\n        \\n        suffix[n-1] = nums[n-1];\\n        for (int i = n-2; i >= 0; i--) {\\n            suffix[i] = suffix[i+1] | nums[i];\\n        }\\n        \\n        long maxOr = 0;\\n        for (int i = 0; i < n; i++) {\\n            long or = ((long) nums[i]) * (1L << k) | (i > 0 ? prefix[i-1] : 0) | (i < n-1 ? suffix[i+1] : 0);\\n            maxOr = Math.max(maxOr, or);\\n        }\\n        \\n        return maxOr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641203,
                "title": "try-k-operations-on-every-number",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nit can be seen that if we are to apply k operations of left shift ( ie; multiply by 2) on any number and make the or (nums)->maximum possible then we should try to make one maximum number in it bcz even one max no in nums will make or(num)->maximum since 1 || 0->1 . now that means applying k operations to the maximum no will be beneficial as it will make the greatest possible no among all with k shifts.\\ngreater no means having msb as lft as possible but if we talk specifically about the lsb than there can be more than one no having their lsb\\'s at the same bit position(there we can not choose simply the highest among them) and here some factors to choose the right no come into play bcz we need to see which no has its k set bits as left as possible that will come to left after k operations\\nand how many previosly set bits in right side become unset after applying the operations to a part no int the result.\\nbcz of these things either we can come up with some way of taking care of all these peculiarities and choose the best one on which to apply operatrions or try evry possible no shifting them to its left k times . \\n \\n\\n---\\n**NOW WHY ALL K OPERATIONS SHOULD BE APPLIED TO JUST ONE NUMBER?**\\nbcz imagine among some big numbers (having leftest msb\\'s) we choose some no and shift it to left 1 time now it becomes clearly the one and only greatest no who have lsb to the leftest possiblr position so no doubt its best to apply k-1 operation to this no only.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(k x n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n**PLS UPVOTE IF IT HELPED**\\n# c++\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        long long ans=INT_MIN;\\n        int n=nums.size();\\n        vector<int> pre(n);\\n        vector<int> suf(n);\\n        pre[0]=nums[0];\\n        suf[n-1]=nums[n-1];\\n        int i=1;\\n        int j=n-2;\\n        for(;i<n;i++,j--){\\n            pre[i]=nums[i] | pre[i-1];\\n            suf[j]=nums[j] | suf[j+1];\\n        }\\n        for(int i=0;i<n;i++){\\n            long long res=nums[i];\\n            int cnt=k;\\n            while(cnt--){\\n                res<<=1;\\n            }\\n            if(i>0){\\n                res|=pre[i-1];\\n            }\\n            if(i<n-1){\\n                res|=suf[i+1];\\n            }\\n            ans=max(ans,res);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# java\\n```\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        long ans=Integer.MIN_VALUE;\\n        int n=nums.length;\\n        int[] pre=new int[n];\\n        int[] suf=new int[n];\\n        pre[0]=nums[0];\\n        suf[n-1]=nums[n-1];\\n        int i=1;\\n        int j=n-2;\\n        for(;i<n;i++,j--){\\n            pre[i]=nums[i] | pre[i-1];\\n            suf[j]=nums[j] | suf[j+1];\\n        }\\n        for(i=0;i<n;i++){\\n            long res=nums[i];\\n            int cnt=k;\\n            while(cnt-->0){\\n                res<<=1;\\n            }\\n            if(i>0){\\n                res|=pre[i-1];\\n            }\\n            if(i<n-1){\\n                res|=suf[i+1];\\n            }\\n            ans=Math.max(ans,res);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        long long ans=INT_MIN;\\n        int n=nums.size();\\n        vector<int> pre(n);\\n        vector<int> suf(n);\\n        pre[0]=nums[0];\\n        suf[n-1]=nums[n-1];\\n        int i=1;\\n        int j=n-2;\\n        for(;i<n;i++,j--){\\n            pre[i]=nums[i] | pre[i-1];\\n            suf[j]=nums[j] | suf[j+1];\\n        }\\n        for(int i=0;i<n;i++){\\n            long long res=nums[i];\\n            int cnt=k;\\n            while(cnt--){\\n                res<<=1;\\n            }\\n            if(i>0){\\n                res|=pre[i-1];\\n            }\\n            if(i<n-1){\\n                res|=suf[i+1];\\n            }\\n            ans=max(ans,res);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        long ans=Integer.MIN_VALUE;\\n        int n=nums.length;\\n        int[] pre=new int[n];\\n        int[] suf=new int[n];\\n        pre[0]=nums[0];\\n        suf[n-1]=nums[n-1];\\n        int i=1;\\n        int j=n-2;\\n        for(;i<n;i++,j--){\\n            pre[i]=nums[i] | pre[i-1];\\n            suf[j]=nums[j] | suf[j+1];\\n        }\\n        for(i=0;i<n;i++){\\n            long res=nums[i];\\n            int cnt=k;\\n            while(cnt-->0){\\n                res<<=1;\\n            }\\n            if(i>0){\\n                res|=pre[i-1];\\n            }\\n            if(i<n-1){\\n                res|=suf[i+1];\\n            }\\n            ans=Math.max(ans,res);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613790,
                "title": "java-easy-approah",
                "content": "\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        int n = 32;\\n        //find max \\n        int max = nums[0];\\n        for(int num:nums){\\n            max = Math.max(max,num);\\n        }\\n        int m = findbits(max);\\n        // System.out.println(n);\\n        List<Integer> list = new ArrayList();\\n        long ans = 0;\\n        for(int num:nums){\\n            if(findbits(num)==m){\\n                list.add(num);\\n            }\\n            else{\\n                ans = ans | num;\\n            }\\n        }\\n        long Ans = 0;\\n        int count[] = new int[n];\\n        for(int i=0; i<list.size(); i++){\\n            int temp = list.get(i);\\n            for(int j=n-1; j>=0; j--){\\n                count[j] += temp&1;\\n                temp=temp>>1;\\n            }\\n        }\\n        for(int i=0; i<list.size(); i++){\\n            int temp = list.get(i);\\n            for(int j=n-1; j>=0; j--){\\n                count[j] -= temp&1;\\n                temp>>=1;\\n            }\\n            long ans2 = 0;\\n            for(int j=0; j<n; j++){\\n                ans2 = ans2<<1;\\n                ans2 = ans2|(count[j]>=1?1:0);\\n            }\\n            \\n            temp = list.get(i);\\n            for(int j=n-1; j>=0; j--){\\n                count[j] += temp&1;\\n                temp=temp>>1;\\n            }\\n            Ans = Math.max(Ans, ans | ans2 | ((long)list.get(i)<<k));\\n        }\\n        return Ans;\\n    }\\n    int findbits(int num){\\n        int len = 0;\\n        while(num!=0){\\n            num = num>>1;\\n            len++;\\n        }\\n        return len;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        int n = 32;\\n        //find max \\n        int max = nums[0];\\n        for(int num:nums){\\n            max = Math.max(max,num);\\n        }\\n        int m = findbits(max);\\n        // System.out.println(n);\\n        List<Integer> list = new ArrayList();\\n        long ans = 0;\\n        for(int num:nums){\\n            if(findbits(num)==m){\\n                list.add(num);\\n            }\\n            else{\\n                ans = ans | num;\\n            }\\n        }\\n        long Ans = 0;\\n        int count[] = new int[n];\\n        for(int i=0; i<list.size(); i++){\\n            int temp = list.get(i);\\n            for(int j=n-1; j>=0; j--){\\n                count[j] += temp&1;\\n                temp=temp>>1;\\n            }\\n        }\\n        for(int i=0; i<list.size(); i++){\\n            int temp = list.get(i);\\n            for(int j=n-1; j>=0; j--){\\n                count[j] -= temp&1;\\n                temp>>=1;\\n            }\\n            long ans2 = 0;\\n            for(int j=0; j<n; j++){\\n                ans2 = ans2<<1;\\n                ans2 = ans2|(count[j]>=1?1:0);\\n            }\\n            \\n            temp = list.get(i);\\n            for(int j=n-1; j>=0; j--){\\n                count[j] += temp&1;\\n                temp=temp>>1;\\n            }\\n            Ans = Math.max(Ans, ans | ans2 | ((long)list.get(i)<<k));\\n        }\\n        return Ans;\\n    }\\n    int findbits(int num){\\n        int len = 0;\\n        while(num!=0){\\n            num = num>>1;\\n            len++;\\n        }\\n        return len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3562127,
                "title": "easiest-clean-c-code",
                "content": "### LinkedIn profile : https://www.linkedin.com/in/aditya-jhunjhunwala-51b586195/\\n# Complexity\\n- Time complexity:\\n**O(n)**\\n\\n- Space complexity:\\n**O(n)**\\n\\n# Code\\n### Please Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        long maxi = 0,prefixSum = 0,suffixSum = 0;\\n        vector<long> prefixOR(n+2),suffixOR(n+2);\\n        for(int i = 1 ; i <= n ; i++){\\n            prefixSum |= nums[i-1];\\n            prefixOR[i] = prefixSum;\\n        }\\n        for(int i = n ; i > 0 ; i--){\\n            suffixSum |= nums[i-1];\\n            suffixOR[i] = suffixSum;\\n        }\\n        for(int i = 1 ; i <= n ; i++)\\n            maxi = max(maxi , prefixOR[i-1] | suffixOR[i+1] | ((long)nums[i-1] * (1 << k)));\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Bit Manipulation",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        long maxi = 0,prefixSum = 0,suffixSum = 0;\\n        vector<long> prefixOR(n+2),suffixOR(n+2);\\n        for(int i = 1 ; i <= n ; i++){\\n            prefixSum |= nums[i-1];\\n            prefixOR[i] = prefixSum;\\n        }\\n        for(int i = n ; i > 0 ; i--){\\n            suffixSum |= nums[i-1];\\n            suffixOR[i] = suffixSum;\\n        }\\n        for(int i = 1 ; i <= n ; i++)\\n            maxi = max(maxi , prefixOR[i-1] | suffixOR[i+1] | ((long)nums[i-1] * (1 << k)));\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3560889,
                "title": "c-solution-beats-93-75-bit-manipulation-approach",
                "content": "```c\\nlong long maximumOr(int* nums, int numsSize, int k){\\n    int union_nums = 0, intersection = 0;\\n    for (int i = 0; i < numsSize; i++) {\\n        intersection |= union_nums & nums[i];\\n        union_nums |= nums[i];\\n    }\\n    long long maxOr = 0;\\n    for (int i = 0; i < numsSize; i++) {\\n        maxOr = fmax(maxOr, union_nums ^ nums[i] | intersection |((long long)nums[i] << k));\\n    }\\n    return maxOr;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```c\\nlong long maximumOr(int* nums, int numsSize, int k){\\n    int union_nums = 0, intersection = 0;\\n    for (int i = 0; i < numsSize; i++) {\\n        intersection |= union_nums & nums[i];\\n        union_nums |= nums[i];\\n    }\\n    long long maxOr = 0;\\n    for (int i = 0; i < numsSize; i++) {\\n        maxOr = fmax(maxOr, union_nums ^ nums[i] | intersection |((long long)nums[i] << k));\\n    }\\n    return maxOr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3548277,
                "title": "simple-prefix-and-suffix-solution-in-o-n",
                "content": "# Intuition\\nWe can observer that multiplying by 2 will add one more 0 at right hand side in binary representation of number (e.g 6 -> 110 now multiply 6 by 2 which become 12 -> 1100). So it means left most set bit will move towards left so its contribution in ans will increase. Therefore it will always give maximum value when we keep multiplying a number continuosly by 2 i.e. k times. **But how to find which number to multiply by 2 k-times?** So check by iterating over each number. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Step 1:** Make a sufix and prefix array where prefix[i] will store bitwise or of all value from 0.....i and sufix[i] will store bitwise or of all value from n-1 to i.\\n**Step2:** Now iterate over each value of nums and multipy it by 2 k times and and do bitwise or of prefix[i-1], nums[i]*2^k, sufix[i+1]. And update ans variable if it is more than current value of ans.\\n**Step3:** return ans.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    long long maximumOr(vector<int>& nums, int k) {\\n        ll ans = LLONG_MIN;\\n        int n = nums.size();\\n        vector<int> prefx(n), sufx(n);\\n        prefx[0]=nums[0];\\n        sufx[n-1]=nums[n-1];\\n        for(int i=1;i<n;i++){\\n            prefx[i]= (nums[i]|prefx[i-1]);\\n            sufx[n-1-i] = (nums[n-1-i]|sufx[n-i]);\\n        }\\n        for(int i=0;i<n;i++){\\n            ll l =0, r=0;\\n            if(i>0){\\n              l = prefx[i-1];\\n            }\\n            if(i+1<n){\\n                r=  sufx[i+1];\\n            }\\n            ll newVal = nums[i];\\n            ll temp = (newVal<<k);\\n            ans = max(ans, ((temp|l)|r));\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    long long maximumOr(vector<int>& nums, int k) {\\n        ll ans = LLONG_MIN;\\n        int n = nums.size();\\n        vector<int> prefx(n), sufx(n);\\n        prefx[0]=nums[0];\\n        sufx[n-1]=nums[n-1];\\n        for(int i=1;i<n;i++){\\n            prefx[i]= (nums[i]|prefx[i-1]);\\n            sufx[n-1-i] = (nums[n-1-i]|sufx[n-i]);\\n        }\\n        for(int i=0;i<n;i++){\\n            ll l =0, r=0;\\n            if(i>0){\\n              l = prefx[i-1];\\n            }\\n            if(i+1<n){\\n                r=  sufx[i+1];\\n            }\\n            ll newVal = nums[i];\\n            ll temp = (newVal<<k);\\n            ans = max(ans, ((temp|l)|r));\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547351,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        int n = nums.length;\\n        long[] suffix = new long[n];\\n        for(int i = n - 2; i >= 0; i--)\\n        {\\n            suffix[i] = suffix[i + 1] | nums[i + 1];\\n        }\\n        long prefix = 0;\\n        long maxi = Integer.MIN_VALUE;\\n        for(int i = 0; i < n; i++)\\n        {\\n            long totval = ((long)nums[i] << k ) | suffix[i] | prefix;\\n            maxi = Math.max(maxi, totval);\\n            prefix = prefix | nums[i];\\n        }\\n        return maxi;\\n    }\\n}\\n/*\\n12           9        3      ==> nums array(Step 1)\\n9|3         3|0       0      ==> suffix OR array(Step 2)\\n0          12|0      12|9    ==> prefix OR array(Step 3) \\n9|3|0      12|0|3    12|9|0  ==> OR of all elements except current index(Step2 | Step3)\\n*/\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        int n = nums.length;\\n        long[] suffix = new long[n];\\n        for(int i = n - 2; i >= 0; i--)\\n        {\\n            suffix[i] = suffix[i + 1] | nums[i + 1];\\n        }\\n        long prefix = 0;\\n        long maxi = Integer.MIN_VALUE;\\n        for(int i = 0; i < n; i++)\\n        {\\n            long totval = ((long)nums[i] << k ) | suffix[i] | prefix;\\n            maxi = Math.max(maxi, totval);\\n            prefix = prefix | nums[i];\\n        }\\n        return maxi;\\n    }\\n}\\n/*\\n12           9        3      ==> nums array(Step 1)\\n9|3         3|0       0      ==> suffix OR array(Step 2)\\n0          12|0      12|9    ==> prefix OR array(Step 3) \\n9|3|0      12|0|3    12|9|0  ==> OR of all elements except current index(Step2 | Step3)\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545408,
                "title": "using-prefix-and-suffix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)+o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<long long >p(n,0),s(n,0);\\n        p[0]=0;\\n        s[n-1]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            p[i]=p[i-1]|nums[i-1];\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            s[i]=s[i+1]|nums[i+1];\\n        }\\n        long long  z=0;\\n        for(int i=0;i<n;i++)\\n        {   long long c=pow(2,k);\\n            long long a=p[i]|s[i]|(c*nums[i]);\\n            z=max(z,a);\\n        }\\n        return z;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<long long >p(n,0),s(n,0);\\n        p[0]=0;\\n        s[n-1]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            p[i]=p[i-1]|nums[i-1];\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            s[i]=s[i+1]|nums[i+1];\\n        }\\n        long long  z=0;\\n        for(int i=0;i<n;i++)\\n        {   long long c=pow(2,k);\\n            long long a=p[i]|s[i]|(c*nums[i]);\\n            z=max(z,a);\\n        }\\n        return z;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544374,
                "title": "c-easy-approach",
                "content": "JUST DO OPERATION ON ONLY ONE OF ANY NUMBER , REST EXPLAINATION IS IN COMMENTS \\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void help(vector<int>&set,long long i){\\n        //to make record of set bits of i\\n        int j=0;\\n        while(i){\\n            if(i&1){\\n                set[j]++;\\n            }\\n            i/=2;\\n            j++;            \\n        }\\n        return ;\\n    }\\n    void reduce(vector<int>&set,long long temp){\\n        //to remove the record of set bits of i\\n        int j=0;\\n        while(temp){\\n            if(temp&1){\\n                set[j]--;\\n            }\\n            temp/=2;\\n            j++;\\n        }\\n        return ;\\n    }\\n    long long maximumOr(vector<int>& nums, int k) {\\n        vector<int> set(64,0);\\n        int n=nums.size();\\n\\n        for(int i=0;i<n;i++)           help(set,nums[i]);\\n        //to store record of all the numbers\\n   \\n        long long ans=0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            reduce(set,nums[i]);    //remove the current record of nums[i]  and instead add record of nums[i]*(2^k)\\n\\n\\n            long long temp=nums[i]*pow(2,k);\\n            help(set,temp);\\n\\n            //now evaluating the result of or operation \\n            long long cur=0;\\n            for(int i=0;i<64;i++){\\n                if(set[i]>0)    cur+=pow(2,i);\\n            }\\n\\n            //undo changes in set vector to proceed in next iteration\\n            reduce(set,temp);\\n            help(set,nums[i]);\\n            //store the answer\\n            ans=max(ans,cur);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\ndo upvote if its worth it \\uD83D\\uDC4D\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void help(vector<int>&set,long long i){\\n        //to make record of set bits of i\\n        int j=0;\\n        while(i){\\n            if(i&1){\\n                set[j]++;\\n            }\\n            i/=2;\\n            j++;            \\n        }\\n        return ;\\n    }\\n    void reduce(vector<int>&set,long long temp){\\n        //to remove the record of set bits of i\\n        int j=0;\\n        while(temp){\\n            if(temp&1){\\n                set[j]--;\\n            }\\n            temp/=2;\\n            j++;\\n        }\\n        return ;\\n    }\\n    long long maximumOr(vector<int>& nums, int k) {\\n        vector<int> set(64,0);\\n        int n=nums.size();\\n\\n        for(int i=0;i<n;i++)           help(set,nums[i]);\\n        //to store record of all the numbers\\n   \\n        long long ans=0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            reduce(set,nums[i]);    //remove the current record of nums[i]  and instead add record of nums[i]*(2^k)\\n\\n\\n            long long temp=nums[i]*pow(2,k);\\n            help(set,temp);\\n\\n            //now evaluating the result of or operation \\n            long long cur=0;\\n            for(int i=0;i<64;i++){\\n                if(set[i]>0)    cur+=pow(2,i);\\n            }\\n\\n            //undo changes in set vector to proceed in next iteration\\n            reduce(set,temp);\\n            help(set,nums[i]);\\n            //store the answer\\n            ans=max(ans,cur);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544287,
                "title": "java-c-python-prefix-suffix",
                "content": "Java\\n```\\nclass Solution {\\n    public long maximumOr(List<Integer> nums, int k) {\\n        long ans = 0;\\n        long mul = 1;\\n        \\n        List<Long> pre = new ArrayList<>(Collections.nCopies(nums.size(), 0L));\\n        List<Long> suf = new ArrayList<>(Collections.nCopies(nums.size(), 0L));\\n        \\n        pre.set(0, nums.get(0));\\n        suf.set(nums.size() - 1, nums.get(nums.size() - 1));\\n\\n        for (int i = 1; i < nums.size(); ++i) {\\n            pre.set(i, pre.get(i - 1) | nums.get(i));\\n            suf.set(nums.size() - i - 1, suf.get(nums.size() - i) | nums.get(nums.size() - i - 1));\\n        }\\n\\n        for (int i = 0; i < k; ++i) {\\n            mul *= 2;\\n        }\\n\\n        for (int i = 0; i < nums.size(); ++i) {\\n            long x = nums.get(i) * mul;\\n\\n            if (i - 1 >= 0)\\n                x = x | pre.get(i - 1);\\n\\n            if (i + 1 < nums.size())\\n                x = x | suf.get(i + 1);\\n\\n            ans = Math.max(ans, x);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\\nC++\\n```\\nclass Solution {\\n    public long maximumOr(List<Integer> nums, int k) {\\n        long ans = 0;\\n        long mul = 1;\\n        \\n        List<Long> pre = new ArrayList<>(Collections.nCopies(nums.size(), 0L));\\n        List<Long> suf = new ArrayList<>(Collections.nCopies(nums.size(), 0L));\\n        \\n        pre.set(0, nums.get(0));\\n        suf.set(nums.size() - 1, nums.get(nums.size() - 1));\\n\\n        for (int i = 1; i < nums.size(); ++i) {\\n            pre.set(i, pre.get(i - 1) | nums.get(i));\\n            suf.set(nums.size() - i - 1, suf.get(nums.size() - i) | nums.get(nums.size() - i - 1));\\n        }\\n\\n        for (int i = 0; i < k; ++i) {\\n            mul *= 2;\\n        }\\n\\n        for (int i = 0; i < nums.size(); ++i) {\\n            long x = nums.get(i) * mul;\\n\\n            if (i - 1 >= 0)\\n                x = x | pre.get(i - 1);\\n\\n            if (i + 1 < nums.size())\\n                x = x | suf.get(i + 1);\\n\\n            ans = Math.max(ans, x);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\\nPython\\n```\\nclass Solution:\\n    def maximumOr(self, nums, k):\\n        ans = 0\\n        mul = 1\\n\\n        pre = [0] * len(nums)\\n        suf = [0] * len(nums)\\n\\n        pre[0] = nums[0]\\n        suf[-1] = nums[-1]\\n\\n        for i in range(1, len(nums)):\\n            pre[i] = pre[i - 1] | nums[i]\\n            suf[-i - 1] = suf[-i] | nums[-i - 1]\\n\\n        for i in range(k):\\n            mul *= 2\\n\\n        for i in range(len(nums)):\\n            x = nums[i] * mul\\n\\n            if i - 1 >= 0:\\n                x = x | pre[i - 1]\\n\\n            if i + 1 < len(nums):\\n                x = x | suf[i + 1]\\n\\n            ans = max(ans, x)\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumOr(List<Integer> nums, int k) {\\n        long ans = 0;\\n        long mul = 1;\\n        \\n        List<Long> pre = new ArrayList<>(Collections.nCopies(nums.size(), 0L));\\n        List<Long> suf = new ArrayList<>(Collections.nCopies(nums.size(), 0L));\\n        \\n        pre.set(0, nums.get(0));\\n        suf.set(nums.size() - 1, nums.get(nums.size() - 1));\\n\\n        for (int i = 1; i < nums.size(); ++i) {\\n            pre.set(i, pre.get(i - 1) | nums.get(i));\\n            suf.set(nums.size() - i - 1, suf.get(nums.size() - i) | nums.get(nums.size() - i - 1));\\n        }\\n\\n        for (int i = 0; i < k; ++i) {\\n            mul *= 2;\\n        }\\n\\n        for (int i = 0; i < nums.size(); ++i) {\\n            long x = nums.get(i) * mul;\\n\\n            if (i - 1 >= 0)\\n                x = x | pre.get(i - 1);\\n\\n            if (i + 1 < nums.size())\\n                x = x | suf.get(i + 1);\\n\\n            ans = Math.max(ans, x);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public long maximumOr(List<Integer> nums, int k) {\\n        long ans = 0;\\n        long mul = 1;\\n        \\n        List<Long> pre = new ArrayList<>(Collections.nCopies(nums.size(), 0L));\\n        List<Long> suf = new ArrayList<>(Collections.nCopies(nums.size(), 0L));\\n        \\n        pre.set(0, nums.get(0));\\n        suf.set(nums.size() - 1, nums.get(nums.size() - 1));\\n\\n        for (int i = 1; i < nums.size(); ++i) {\\n            pre.set(i, pre.get(i - 1) | nums.get(i));\\n            suf.set(nums.size() - i - 1, suf.get(nums.size() - i) | nums.get(nums.size() - i - 1));\\n        }\\n\\n        for (int i = 0; i < k; ++i) {\\n            mul *= 2;\\n        }\\n\\n        for (int i = 0; i < nums.size(); ++i) {\\n            long x = nums.get(i) * mul;\\n\\n            if (i - 1 >= 0)\\n                x = x | pre.get(i - 1);\\n\\n            if (i + 1 < nums.size())\\n                x = x | suf.get(i + 1);\\n\\n            ans = Math.max(ans, x);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def maximumOr(self, nums, k):\\n        ans = 0\\n        mul = 1\\n\\n        pre = [0] * len(nums)\\n        suf = [0] * len(nums)\\n\\n        pre[0] = nums[0]\\n        suf[-1] = nums[-1]\\n\\n        for i in range(1, len(nums)):\\n            pre[i] = pre[i - 1] | nums[i]\\n            suf[-i - 1] = suf[-i] | nums[-i - 1]\\n\\n        for i in range(k):\\n            mul *= 2\\n\\n        for i in range(len(nums)):\\n            x = nums[i] * mul\\n\\n            if i - 1 >= 0:\\n                x = x | pre[i - 1]\\n\\n            if i + 1 < len(nums):\\n                x = x | suf[i + 1]\\n\\n            ans = max(ans, x)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532038,
                "title": "javascript-ltr-rtl-without-bigint-x2-faster-than-the-fastest-bigint",
                "content": "**First**\\nTo obtain the maximum possible value \\u2014 we should apply all the k operations on a single number `x << k`, because if we share `k` between elements the total shift will be smaller\\n\\n```\\n         k=2      k=2\\n       share   single\\n\\u2014\\u2014\\u2014 \\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014 \\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\n101     1010    10100\\n 10      100       10\\n```\\n**Second**\\nFrom left to right we calculate prefix OR\\'s.\\nFrom right to left we calculate suffix OR\\'s.\\n\\n**Third**\\nTo perform OR for all elements `<= 1e9` and one element `> 1e9` we should split the lement to the sum\\n```\\nnums[0] = 999997022 base 10\\nnums[0] * 2 ** 14 = 16383951208448 base 10\\n                  = 11101110011010101111100101111000000000000000 base 2\\nnums[0] * 2 ** 14 % (1 << 30)   = 101111100101111000000000000000 base 2\\nnums[0] * 2 ** 14 -                   \\nnums[0] * 2 ** 14 % (1 << 30)\\n                  = 11101110011010000000000000000000000000000000 base 2\\n```\\n\\n# Code\\n```\\nvar maximumOr = function(nums, k) {\\n  const n = nums.length;\\n\\n  const pre = new Array(n);\\n  pre[0] = nums[0];\\n  pre[-1] = 0;\\n  for (let i = 1; i < n; i++) {\\n    pre[i] = nums[i] | pre[i-1];\\n  }\\n\\n  const suf = new Array(n+1);\\n  suf[n-1] = nums[n-1];\\n  suf[n] = 0;\\n  for (let i = n-2; i > 0; i--) {\\n    suf[i] = nums[i] | suf[i+1];\\n  }\\n\\n  let max = -Infinity;\\n  const f = 2 ** k;\\n  const mod = 1 << 30;\\n  for (let i = 0; i < n; i++) {\\n    const x = nums[i] * f;\\n    const rest = x % mod;\\n    max = Math.max(\\n      max,\\n      (x - rest) + (pre[i-1] | suf[i+1] | rest)\\n    )\\n  }\\n\\n  return max\\n};\\n```\\n\\n# Complexity\\nTime complexity: O(n) since we simply iterate on nums 3 times\\nSpace complexity: O(n) we store prefix ans suffix values\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Prefix Sum"
                ],
                "code": "```\\n         k=2      k=2\\n       share   single\\n\\u2014\\u2014\\u2014 \\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014 \\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\n101     1010    10100\\n 10      100       10\\n```\n```\\nnums[0] = 999997022 base 10\\nnums[0] * 2 ** 14 = 16383951208448 base 10\\n                  = 11101110011010101111100101111000000000000000 base 2\\nnums[0] * 2 ** 14 % (1 << 30)   = 101111100101111000000000000000 base 2\\nnums[0] * 2 ** 14 -                   \\nnums[0] * 2 ** 14 % (1 << 30)\\n                  = 11101110011010000000000000000000000000000000 base 2\\n```\n```\\nvar maximumOr = function(nums, k) {\\n  const n = nums.length;\\n\\n  const pre = new Array(n);\\n  pre[0] = nums[0];\\n  pre[-1] = 0;\\n  for (let i = 1; i < n; i++) {\\n    pre[i] = nums[i] | pre[i-1];\\n  }\\n\\n  const suf = new Array(n+1);\\n  suf[n-1] = nums[n-1];\\n  suf[n] = 0;\\n  for (let i = n-2; i > 0; i--) {\\n    suf[i] = nums[i] | suf[i+1];\\n  }\\n\\n  let max = -Infinity;\\n  const f = 2 ** k;\\n  const mod = 1 << 30;\\n  for (let i = 0; i < n; i++) {\\n    const x = nums[i] * f;\\n    const rest = x % mod;\\n    max = Math.max(\\n      max,\\n      (x - rest) + (pre[i-1] | suf[i+1] | rest)\\n    )\\n  }\\n\\n  return max\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530669,
                "title": "math-dp-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        int l = nums.length;\\n        long [] dp = new long[l];\\n        long [] dp2 = new long[l];\\n        for(int i = 1;i<l;i++)dp[i] = dp[i-1] | (long)nums[i-1];\\n        for(int i = l-2;i>=0;i--)dp2[i] = dp2[i + 1] | (long)nums[i + 1];\\n        long max = Long.MIN_VALUE;\\n        for(int i =0;i<l;i++){\\n            long check = nums[i]<<k;\\n            max = Math.max(check | dp[i] | dp2[i],max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        int l = nums.length;\\n        long [] dp = new long[l];\\n        long [] dp2 = new long[l];\\n        for(int i = 1;i<l;i++)dp[i] = dp[i-1] | (long)nums[i-1];\\n        for(int i = l-2;i>=0;i--)dp2[i] = dp2[i + 1] | (long)nums[i + 1];\\n        long max = Long.MIN_VALUE;\\n        for(int i =0;i<l;i++){\\n            long check = nums[i]<<k;\\n            max = Math.max(check | dp[i] | dp2[i],max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3530333,
                "title": "python-prefix-suffix-o-n",
                "content": "1. To maximize, we need to do all operations on a single number, and that number should have the highest length in its binary representation. We denote that length by `l`.\\n2. `prefix_or[i]` is the prefix or of `nums[:i]`, and `suffix_or[i]` is the suffix or of `nums[i+1:]`.\\nFor every `a` in `nums`, if the binary of `a` has length `l`, we calculate the value and compare the value to `ans`, and keep the bigger one.\\n```\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        prefix_or = [0]*n\\n        po = 0\\n        for i in range(1, n):\\n            po |= nums[i-1]\\n            prefix_or[i] = po\\n        so = 0\\n        suffix_or = [0]*n\\n        for i in range(n-2, -1, -1):\\n            so |= nums[i+1]\\n            suffix_or[i] = so\\n        \\n        l = len(bin(max(nums)))\\n        ans = 0\\n        for i, a in enumerate(nums):\\n            if len(bin(a)) == l:\\n                ans = max(ans, (a << k) | prefix_or[i] | suffix_or[i])\\n        return ans\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "1. To maximize, we need to do all operations on a single number, and that number should have the highest length in its binary representation. We denote that length by `l`.\\n2. `prefix_or[i]` is the prefix or of `nums[:i]`, and `suffix_or[i]` is the suffix or of `nums[i+1:]`.\\nFor every `a` in `nums`, if the binary of `a` has length `l`, we calculate the value and compare the value to `ans`, and keep the bigger one.\\n```\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        prefix_or = [0]*n\\n        po = 0\\n        for i in range(1, n):\\n            po |= nums[i-1]\\n            prefix_or[i] = po\\n        so = 0\\n        suffix_or = [0]*n\\n        for i in range(n-2, -1, -1):\\n            so |= nums[i+1]\\n            suffix_or[i] = so\\n        \\n        l = len(bin(max(nums)))\\n        ans = 0\\n        for i, a in enumerate(nums):\\n            if len(bin(a)) == l:\\n                ans = max(ans, (a << k) | prefix_or[i] | suffix_or[i])\\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 3530181,
                "title": "using-suffix-and-prefix-or-of-array-elements",
                "content": "# Intuition\\nuse prefix and suffix array for storing OR values of previous and next elements.<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\ncalculate the maximum bw each possibility.<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO( n )<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO( 2n )<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        \\n        long ans=0;\\n        int n=nums.length;\\n\\n        long[] pre=new long[n+1];\\n        long[] suff=new long[n+1];\\n\\n        Arrays.fill(pre,0); //prefix array of OR operation\\n        Arrays.fill(suff,0); //suffix array of OR operation\\n\\n        long p=1;\\n        p=p<<k;     //power of 2 after left shifting by k\\n\\n        for(int i=0;i<n;i++){\\n            pre[i+1]=pre[i]|nums[i];\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            suff[i]=suff[i+1]|nums[i];\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            ans=Math.max(ans,pre[i]|(p*nums[i])|suff[i+1]);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        \\n        long ans=0;\\n        int n=nums.length;\\n\\n        long[] pre=new long[n+1];\\n        long[] suff=new long[n+1];\\n\\n        Arrays.fill(pre,0); //prefix array of OR operation\\n        Arrays.fill(suff,0); //suffix array of OR operation\\n\\n        long p=1;\\n        p=p<<k;     //power of 2 after left shifting by k\\n\\n        for(int i=0;i<n;i++){\\n            pre[i+1]=pre[i]|nums[i];\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            suff[i]=suff[i+1]|nums[i];\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            ans=Math.max(ans,pre[i]|(p*nums[i])|suff[i+1]);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529885,
                "title": "simple-linear-time-solution-using-prefix-bitwise-or-array-and-suffix-bitwise-or-array",
                "content": "# Intuition\\nFirst problem is which number should be multiplied how many times the solution is multiply a single number k times to get the maximum result but now question is which number to be multiplied k times how to know that? we tried the biggest number but that doesn\\'t work that means greedy failed so we try each and every number that is we will multiply each number k times with 2 and find the or of the whole array and whichever gives maximum result we return it.\\n\\n# Approach\\nWe can mutliply each number k times but calculating the or of the whole array for each time will increase the time complexity at max to 10^5 * 10^5 , we cannot get rid of the first 10^5 but the next we calculate the prefix of or till that index and suffix of bitwise or for each index like this we  don\\'t need the calculate everytime.\\nthis solves our issue.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        // Read solution\\n        int n=nums.size();\\n        vector<long long > pre(n+1,0);\\n        vector<long long > suf(n+1,0);\\n        long long res=0;\\n        long long p=1; \\n        p=p<<k; // instead of multiplying the no with k times with 2 we calculated a value which is 2^k and then we will multiply it with any choosen num directly\\n        // calculating the prefix or till that index\\n        for(int i=0;i<n;i++) pre[i+1]=pre[i] | nums[i];\\n         // calculating the suffix or for each index\\n        for(int i=n-1;i>=0;i--) suf[i]=suf[i+1] | nums[i];\\n         \\n        for(int i=0;i<n;i++){\\n            res=max(res,(pre[i] | (nums[i]*p) | suf[i+1]));\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        // Read solution\\n        int n=nums.size();\\n        vector<long long > pre(n+1,0);\\n        vector<long long > suf(n+1,0);\\n        long long res=0;\\n        long long p=1; \\n        p=p<<k; // instead of multiplying the no with k times with 2 we calculated a value which is 2^k and then we will multiply it with any choosen num directly\\n        // calculating the prefix or till that index\\n        for(int i=0;i<n;i++) pre[i+1]=pre[i] | nums[i];\\n         // calculating the suffix or for each index\\n        for(int i=n-1;i>=0;i--) suf[i]=suf[i+1] | nums[i];\\n         \\n        for(int i=0;i<n;i++){\\n            res=max(res,(pre[i] | (nums[i]*p) | suf[i+1]));\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529695,
                "title": "java-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        int n = nums.length;\\n        long[] pre = new long[n+1];    \\n        long[] suf = new long[n+1];\\n        for(int i = 1; i<n; i++)\\n        {\\n            pre[i] = pre[i-1] | (long)nums[i-1];\\n        }\\n        for(int i = n-1; i>=0; i--)\\n        {\\n            suf[i] = suf[i+1] | (long)nums[i];\\n        }\\n        long ans = 0;\\n        for(int i = 0; i<n; i++)\\n        {\\n            long curr = (long)nums[i] << k;\\n            long temp = pre[i] | curr | suf[i+1];\\n            ans = temp > ans ? temp : ans;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        int n = nums.length;\\n        long[] pre = new long[n+1];    \\n        long[] suf = new long[n+1];\\n        for(int i = 1; i<n; i++)\\n        {\\n            pre[i] = pre[i-1] | (long)nums[i-1];\\n        }\\n        for(int i = n-1; i>=0; i--)\\n        {\\n            suf[i] = suf[i+1] | (long)nums[i];\\n        }\\n        long ans = 0;\\n        for(int i = 0; i<n; i++)\\n        {\\n            long curr = (long)nums[i] << k;\\n            long temp = pre[i] | curr | suf[i+1];\\n            ans = temp > ans ? temp : ans;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529027,
                "title": "boolean-algebra-o-1-mem-fast-and-elegant-without-arrays-extra-solution",
                "content": "# TL;DR\\n``` java []\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        int union = 0;\\n        int intersection = 0;\\n        for (int n: nums) {\\n            intersection |= union & n;\\n            union |= n;\\n        }\\n        long maxOr = 0;\\n        for (int n: nums) {\\n            maxOr = Math.max(maxOr, union & ~n | intersection | ((long) n << k)); \\n        }\\n        return maxOr;\\n    }\\n}\\n```\\n``` cpp []\\nclass Solution {\\npublic:\\n    long maximumOr(std::vector<int>& nums, int k) {\\n        int _union = 0;\\n        int intersection = 0;\\n        for (int n : nums) {\\n            intersection |= _union & n;\\n            _union |= n;\\n        }\\n        long maxOr = 0;\\n        for (int n : nums) {\\n            maxOr = std::max(maxOr, (_union & ~n | intersection | ((long) n << k)));\\n        }\\n        return maxOr;\\n    }\\n};\\n```\\n``` python []\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        union = 0\\n        intersection = 0\\n        for n in nums:\\n            intersection |= union & n\\n            union |= n\\n        max_or = 0\\n        for n in nums:\\n            max_or = max(max_or, union & ~n | intersection | (n << k))\\n        return max_or\\n```\\n\\n--- \\n#### \\u26A0\\uFE0F Don\\'t forget to upvote if you like this solution. \\uD83D\\uDE43\\n---\\n\\n\\n# Approach\\n\\nFirst, we calculate the bitwise OR of all numbers (`union`) and the bitwise OR of the intersection of each number with the current `union` (`intersection`). `intersection` represents the bits that are set by at least two numbers from `nums`. \\n> Note: It could seem a little tricky, but what we just do is for each `n` check it\\'s bits intersection with union of all of the previous ones and add it to our `intersection` using OR. In the end we\\'ll have only bits which are set at least in 2 numbers.\\n\\nThen, we iterate over each number `n` in `nums`. For each `n`, we calculate a possible result using the formula: `union & ~n | intersection | (n << k)`. \\n- `union & ~n`: first, we need to extract the number `n` from the overall bitwise OR, but doing that we possibly could affect bits of other numbers overlapped with `n`.\\n- `| intersection`: so we should put back the bits of the numbers. \\n- `| (n << k)`: and now we can calculate new value for the `n` and bitwise OR it.\\n\\nNow we just have to choose the biggest value from our new possible result for the `n` and the previous one.\\n\\nThis approach ensures that we consider all possible numbers to multiply and all possible bits to set, aiming to maximize the overall bitwise OR.\\n\\n# Complexity Analysis\\n\\n- **Time Complexity**: The time complexity is $$O(n)$$, where $$n$$ is the number of elements in `nums`. This is because we iterate over `nums` twice: once to calculate `union` and `intersection`, and once to calculate `maxOr`.\\n\\n- **Space Complexity**: The space complexity is $$O(1)$$, as we only use a few variables to store the intermediate and final results.\\n\\n---\\n# Example\\n\\nConsider `nums = [10, 8, 3]` and `k = 2`. \\n\\nFirst, let\\'s represent the numbers in binary:\\n\\n- `10` in binary is `1010`\\n- `8` in binary is `1000`\\n- `3` in binary is `11`\\n\\n## Step 1: Calculate `union` and `intersection`\\n\\nWe initialize `union` and `intersection` to `0`.\\n\\nThen, for each number `n` in `nums`:\\n\\n- `n = 10`: `union` becomes `1010`, and `intersection` remains `0` (since there\\'s no overlap with the previous `union`).\\n\\n- `n = 8`: `union` is still `1010`, and `intersection` becomes `1000` (since `1010` overlaps with `1000`).\\n\\n- `n = 3`: `union` becomes `1011`, and `intersection` becomes `1010` (since `1010` overlaps with `11`).\\n\\nAt the end of this step, `union` is `1011` and `intersection` is `1010`.\\n\\n## Step 2: Calculate `maxOr`\\n\\nWe initialize `maxOr` to `0`.\\n\\nThen, for each number `n` in `nums`:\\n\\n- `n = 3`: The possible result is `1011 & 1100 | 1010 | 1100` = `1000 | 1010 | 1100` = `1110`. This is greater than `maxOr`, so we update `maxOr` tp `1110`.\\n\\n- `n = 10`: The possible result is `union & ~n | intersection | ((long) n << k)` = `1011 & 0101 | 1010 | 101000` = `1 | 1010 | 101000` = `101011`. Since this is greater than `maxOr`, we update `maxOr` to `101011`.\\n\\n- `n = 8`: The possible result is `1011 & 111 | 1010 | 100000` = `11 | 1010 | 100000` = `101011`. This is equal to `maxOr`.\\n\\nAt the end of this step, `maxOr` is `101011` in binary, which corresponds to `43` in decimal.\\n\\nTherefore, the maximum possible value of `nums[0] | nums[1] | ... | nums[n - 1]` after applying the operation at most `k` times is `43`.\\n\\n---\\n\\n# P.S.\\n\\n### \\uD83C\\uDF81 Standard solution, but with a single suffix array:\\n``` java []\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        var suffix = new int[nums.length + 1];\\n        for (int i = nums.length - 2; i >= 0; i--) {\\n            suffix[i] = suffix[i + 1] | nums[i + 1];\\n        }\\n        var res = 0L;\\n        var prefix = 0;\\n        var kp = 1 << k;\\n        for(int i = 0; i < nums.length; i++) {\\n            res = Math.max(res, prefix | ((long) nums[i] * kp) | suffix[i]);\\n            prefix = prefix | nums[i];\\n        }\\n        return res;\\n    }\\n}\\n```\\n``` cpp []\\nclass Solution {\\npublic:\\n    long maximumOr(std::vector<int>& nums, int k) {\\n        std::vector<int> suffix(nums.size() + 1, 0);\\n        for (int i = nums.size() - 2; i >= 0; i--) {\\n            suffix[i] = suffix[i + 1] | nums[i + 1];\\n        }\\n        long res = 0;\\n        int prefix = 0;\\n        int kp = 1 << k;\\n        for(int i = 0; i < nums.size(); i++) {\\n            res = std::max(res, (prefix | (long) nums[i] * kp) | suffix[i]);\\n            prefix = prefix | nums[i];\\n        }\\n        return res;\\n    }\\n};\\n```\\n``` python []\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        suffix = [0] * (len(nums) + 1)\\n        for i in range(len(nums) - 2, -1, -1):\\n            suffix[i] = suffix[i + 1] | nums[i + 1]\\n        res = 0\\n        prefix = 0\\n        kp = 1 << k\\n        for i in range(len(nums)):\\n            res = max(res, prefix | (nums[i] * kp) | suffix[i])\\n            prefix = prefix | nums[i]\\n        return res\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "``` java []\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        int union = 0;\\n        int intersection = 0;\\n        for (int n: nums) {\\n            intersection |= union & n;\\n            union |= n;\\n        }\\n        long maxOr = 0;\\n        for (int n: nums) {\\n            maxOr = Math.max(maxOr, union & ~n | intersection | ((long) n << k)); \\n        }\\n        return maxOr;\\n    }\\n}\\n```\n``` cpp []\\nclass Solution {\\npublic:\\n    long maximumOr(std::vector<int>& nums, int k) {\\n        int _union = 0;\\n        int intersection = 0;\\n        for (int n : nums) {\\n            intersection |= _union & n;\\n            _union |= n;\\n        }\\n        long maxOr = 0;\\n        for (int n : nums) {\\n            maxOr = std::max(maxOr, (_union & ~n | intersection | ((long) n << k)));\\n        }\\n        return maxOr;\\n    }\\n};\\n```\n``` python []\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        union = 0\\n        intersection = 0\\n        for n in nums:\\n            intersection |= union & n\\n            union |= n\\n        max_or = 0\\n        for n in nums:\\n            max_or = max(max_or, union & ~n | intersection | (n << k))\\n        return max_or\\n```\n``` java []\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        var suffix = new int[nums.length + 1];\\n        for (int i = nums.length - 2; i >= 0; i--) {\\n            suffix[i] = suffix[i + 1] | nums[i + 1];\\n        }\\n        var res = 0L;\\n        var prefix = 0;\\n        var kp = 1 << k;\\n        for(int i = 0; i < nums.length; i++) {\\n            res = Math.max(res, prefix | ((long) nums[i] * kp) | suffix[i]);\\n            prefix = prefix | nums[i];\\n        }\\n        return res;\\n    }\\n}\\n```\n``` cpp []\\nclass Solution {\\npublic:\\n    long maximumOr(std::vector<int>& nums, int k) {\\n        std::vector<int> suffix(nums.size() + 1, 0);\\n        for (int i = nums.size() - 2; i >= 0; i--) {\\n            suffix[i] = suffix[i + 1] | nums[i + 1];\\n        }\\n        long res = 0;\\n        int prefix = 0;\\n        int kp = 1 << k;\\n        for(int i = 0; i < nums.size(); i++) {\\n            res = std::max(res, (prefix | (long) nums[i] * kp) | suffix[i]);\\n            prefix = prefix | nums[i];\\n        }\\n        return res;\\n    }\\n};\\n```\n``` python []\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        suffix = [0] * (len(nums) + 1)\\n        for i in range(len(nums) - 2, -1, -1):\\n            suffix[i] = suffix[i + 1] | nums[i + 1]\\n        res = 0\\n        prefix = 0\\n        kp = 1 << k\\n        for i in range(len(nums)):\\n            res = max(res, prefix | (nums[i] * kp) | suffix[i])\\n            prefix = prefix | nums[i]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528755,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8  The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master) Precompute the prefix and suffix bitwise-OR of the input array `A` from `L`eft-to-right and `R`ight-to-left correspondingly. Then consider each `i`<sup>th</sup> candidate `cand` value to be bit-shifted left by `K`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun maximumOr(A: IntArray, K: Int): Long {\\n        var N = A.size\\n        var (L, R) = Pair(A.copyOf(), A.copyOf())\\n        for (i in 1 until N) {\\n            var j = N - 1 - i\\n            L[i] = L[i] or L[i - 1]\\n            R[j] = R[j] or R[j + 1]\\n        }\\n        var best = 0L\\n        for (i in 0 until N) {\\n            var cand = (if (0 <= i - 1) L[i - 1] else 0).toLong() or (A[i].toLong() shl K) or (if (i + 1 < N) R[i + 1] else 0).toLong()\\n            best = Math.max(best, cand)\\n        }\\n        return best\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet maximumOr = (A, K, N = A.length, L = [...A], R = [...A], best = BigInt(0)) => {\\n    for (let i = 1; i < N; ++i) {\\n        let j = N - 1 - i;\\n        L[i] |= L[i - 1];\\n        R[j] |= R[j + 1];\\n    }\\n    for (let i = 0; i < N; ++i) {\\n        let cand = BigInt(0 <= i - 1 ? L[i - 1] : 0) | (BigInt(A[i]) << BigInt(K)) | BigInt(i + 1 < N ? R[i + 1] : 0);\\n        if (best < cand)\\n            best = cand;\\n    }\\n    return Number(best);\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def maximumOr(self, A: List[int], K: int, best = 0) -> int:\\n        N = len(A)\\n        L, R = A[:], A[:]\\n        for i in range(1, N):\\n            j = N - 1 - i\\n            L[i] |= L[i - 1]\\n            R[j] |= R[j + 1]\\n        for i in range(N):\\n            cand = (L[i - 1] if 0 <= i - 1 else 0) | (A[i] << K) | (R[i + 1] if i + 1 < N else 0)\\n            best = max(best, cand)\\n        return best\\n```\\n\\n*Rust*\\n```\\nuse std::cmp::max;\\nimpl Solution {\\n    pub fn maximum_or(A: Vec<i32>, K: i32) -> i64 {\\n        let N = A.len();\\n        let (mut L, mut R) = (A.clone(), A.clone());\\n        for i in 1..N {\\n            let j = N - 1 - i;\\n            L[i] |= L[i - 1];\\n            R[j] |= R[j + 1];\\n        }\\n        let mut best = 0i64;\\n        for i in 0..N {\\n            let cand = (if 0 <= i as i32 - 1 { L[i - 1] } else { 0 }) as i64 | ((A[i] as i64) << K) | (if i + 1 < N { R[i + 1 ] } else { 0 }) as i64;\\n            best = max(best, cand);\\n        }\\n        best\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using LL = long long;\\n    LL maximumOr(VI& A, int K, LL best = 0) {\\n        int N = A.size();\\n        auto L{ A }, R{ A };\\n        for (auto i{ 1 }; i < N; ++i) {\\n            auto j = N - 1 - i;\\n            L[i] |= L[i - 1];\\n            R[j] |= R[j + 1];\\n        }\\n        for (auto i{ 0 }; i < N; ++i) {\\n            auto cand = (0 <= i - 1 ? L[i - 1] : 0) | (LL(A[i]) << K) | (i + 1 < N ? R[i + 1] : 0);\\n            best = max(best, cand);\\n        }\\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun maximumOr(A: IntArray, K: Int): Long {\\n        var N = A.size\\n        var (L, R) = Pair(A.copyOf(), A.copyOf())\\n        for (i in 1 until N) {\\n            var j = N - 1 - i\\n            L[i] = L[i] or L[i - 1]\\n            R[j] = R[j] or R[j + 1]\\n        }\\n        var best = 0L\\n        for (i in 0 until N) {\\n            var cand = (if (0 <= i - 1) L[i - 1] else 0).toLong() or (A[i].toLong() shl K) or (if (i + 1 < N) R[i + 1] else 0).toLong()\\n            best = Math.max(best, cand)\\n        }\\n        return best\\n    }\\n}\\n```\n```\\nlet maximumOr = (A, K, N = A.length, L = [...A], R = [...A], best = BigInt(0)) => {\\n    for (let i = 1; i < N; ++i) {\\n        let j = N - 1 - i;\\n        L[i] |= L[i - 1];\\n        R[j] |= R[j + 1];\\n    }\\n    for (let i = 0; i < N; ++i) {\\n        let cand = BigInt(0 <= i - 1 ? L[i - 1] : 0) | (BigInt(A[i]) << BigInt(K)) | BigInt(i + 1 < N ? R[i + 1] : 0);\\n        if (best < cand)\\n            best = cand;\\n    }\\n    return Number(best);\\n};\\n```\n```\\nclass Solution:\\n    def maximumOr(self, A: List[int], K: int, best = 0) -> int:\\n        N = len(A)\\n        L, R = A[:], A[:]\\n        for i in range(1, N):\\n            j = N - 1 - i\\n            L[i] |= L[i - 1]\\n            R[j] |= R[j + 1]\\n        for i in range(N):\\n            cand = (L[i - 1] if 0 <= i - 1 else 0) | (A[i] << K) | (R[i + 1] if i + 1 < N else 0)\\n            best = max(best, cand)\\n        return best\\n```\n```\\nuse std::cmp::max;\\nimpl Solution {\\n    pub fn maximum_or(A: Vec<i32>, K: i32) -> i64 {\\n        let N = A.len();\\n        let (mut L, mut R) = (A.clone(), A.clone());\\n        for i in 1..N {\\n            let j = N - 1 - i;\\n            L[i] |= L[i - 1];\\n            R[j] |= R[j + 1];\\n        }\\n        let mut best = 0i64;\\n        for i in 0..N {\\n            let cand = (if 0 <= i as i32 - 1 { L[i - 1] } else { 0 }) as i64 | ((A[i] as i64) << K) | (if i + 1 < N { R[i + 1 ] } else { 0 }) as i64;\\n            best = max(best, cand);\\n        }\\n        best\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using LL = long long;\\n    LL maximumOr(VI& A, int K, LL best = 0) {\\n        int N = A.size();\\n        auto L{ A }, R{ A };\\n        for (auto i{ 1 }; i < N; ++i) {\\n            auto j = N - 1 - i;\\n            L[i] |= L[i - 1];\\n            R[j] |= R[j + 1];\\n        }\\n        for (auto i{ 0 }; i < N; ++i) {\\n            auto cand = (0 <= i - 1 ? L[i - 1] : 0) | (LL(A[i]) << K) | (i + 1 < N ? R[i + 1] : 0);\\n            best = max(best, cand);\\n        }\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3527061,
                "title": "kotlin-o-n-using-prefix-suffix-explanation",
                "content": "# Approach\\nWe don\\'t need to check all possibilities, for example trying to double different numbers differerent times etc. We can observe that the max value we can get is by shifting any `nums[i]` by `k` times and taking the ***bitwise or*** with all the numbers ***left*** and ***right*** to it.\\n\\nWe can precompute the suffix bitwise or values for each index, and have a running prefix bitwise or sum, to make our code faster & simpler.\\n\\nWe then just have to do one traversal to compute the max value.\\n\\n\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    fun maximumOr(nums: IntArray, k: Int): Long {\\n        var suffix = IntArray(nums.size).apply {\\n            for (i in nums.lastIndex - 1 downTo 0)\\n                this[i] = this[i + 1] or nums[i + 1]\\n        }\\n\\n        var prefix = 0L\\n        var max = 0L\\n        for (i in 0..nums.lastIndex) {\\n            val num = nums[i].toLong()\\n            max = maxOf(\\n                max,\\n                prefix or (num shl k) or suffix[i].toLong()\\n            )\\n            prefix = prefix or num\\n        }\\n\\n        return max\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun maximumOr(nums: IntArray, k: Int): Long {\\n        var suffix = IntArray(nums.size).apply {\\n            for (i in nums.lastIndex - 1 downTo 0)\\n                this[i] = this[i + 1] or nums[i + 1]\\n        }\\n\\n        var prefix = 0L\\n        var max = 0L\\n        for (i in 0..nums.lastIndex) {\\n            val num = nums[i].toLong()\\n            max = maxOf(\\n                max,\\n                prefix or (num shl k) or suffix[i].toLong()\\n            )\\n            prefix = prefix or num\\n        }\\n\\n        return max\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526805,
                "title": "c-solution-explained-prefix-and-suffix",
                "content": "**C++:**\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        long long ans = 0;\\n        vector<long long> pre(n + 1, 0);  // Stores prefix OR values\\n        vector<long long> suf(n + 1, 0);  // Stores suffix OR values\\n\\n        // Calculate prefix OR values\\n        for (int i = 0; i < n; i++) {\\n            pre[i + 1] = pre[i] | nums[i];\\n        }\\n\\n        // Calculate suffix OR values\\n        for (int i = n - 1; i >= 0; i--) {\\n            suf[i] = suf[i + 1] | nums[i];\\n        }\\n\\n        // Iterate through each element of the array\\n        for (int i = 0; i < n; i++) {\\n            long long num = nums[i];\\n\\n            // Apply the operation on the element k times\\n            for (int j = 0; j < k; j++) {\\n                num = num * 2;  // Multiply the element by 2\\n            }\\n\\n            // Calculate the maximum OR value considering the current element\\n            ans = max(ans, pre[i] | num | suf[i + 1]);\\n        }\\n\\n        return ans;  // Return the maximum OR value\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        long long ans = 0;\\n        vector<long long> pre(n + 1, 0);  // Stores prefix OR values\\n        vector<long long> suf(n + 1, 0);  // Stores suffix OR values\\n\\n        // Calculate prefix OR values\\n        for (int i = 0; i < n; i++) {\\n            pre[i + 1] = pre[i] | nums[i];\\n        }\\n\\n        // Calculate suffix OR values\\n        for (int i = n - 1; i >= 0; i--) {\\n            suf[i] = suf[i + 1] | nums[i];\\n        }\\n\\n        // Iterate through each element of the array\\n        for (int i = 0; i < n; i++) {\\n            long long num = nums[i];\\n\\n            // Apply the operation on the element k times\\n            for (int j = 0; j < k; j++) {\\n                num = num * 2;  // Multiply the element by 2\\n            }\\n\\n            // Calculate the maximum OR value considering the current element\\n            ans = max(ans, pre[i] | num | suf[i + 1]);\\n        }\\n\\n        return ans;  // Return the maximum OR value\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526276,
                "title": "c-t-c-o-n-s-c-o-n-beginner-friendly-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI hope its clear that we have to multiply 2 ,k times to the same element in order to get max OR of the vector.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI have kept track of OR of all elements before and after a number in given vector using two vectors Prefix and Suffix,then for every index i maximum of `(nums[i]*pow(2,k))|prefix[i-1]|suffix[i+1]` is kept.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n  O(N),N=nums.size();\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N),N=nums.size();\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        vector<long long> prefix(nums.size()),suffix(nums.size());\\n        long long num=0;\\n        for(int i=0;i<nums.size();i++){\\n            num=nums[i]|num;\\n            prefix[i]=num;\\n        }\\n        num=0;\\n        for(int i=nums.size()-1;i>=0;i--){\\n            num=nums[i]|num;\\n            suffix[i]=num;\\n        }\\n        long long maxi=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n                long long var=nums[i]*(long long)(pow(2,k));\\n                if(i!=0)var=var|prefix[i-1];\\n                if(i!=nums.size()-1)var=var|suffix[i+1];\\n                maxi=max(maxi,var);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        vector<long long> prefix(nums.size()),suffix(nums.size());\\n        long long num=0;\\n        for(int i=0;i<nums.size();i++){\\n            num=nums[i]|num;\\n            prefix[i]=num;\\n        }\\n        num=0;\\n        for(int i=nums.size()-1;i>=0;i--){\\n            num=nums[i]|num;\\n            suffix[i]=num;\\n        }\\n        long long maxi=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n                long long var=nums[i]*(long long)(pow(2,k));\\n                if(i!=0)var=var|prefix[i-1];\\n                if(i!=nums.size()-1)var=var|suffix[i+1];\\n                maxi=max(maxi,var);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525519,
                "title": "prefix-or-suffix-or-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        if (n==1) return nums[0]<<k;\\n        vector<long long> prefix(n);\\n        vector<long long> suffix(n);\\n        prefix[0]=nums[0];\\n        for (int i=1;i<n;i++)\\n          prefix[i]=prefix[i-1]|nums[i];\\n        suffix[n-1]=nums[n-1];\\n        for (int i=n-2;i>=0;i--)\\n          suffix[i]=suffix[i+1]|nums[i];\\n        long long res=0;\\n        for (int i=0;i<n;i++)\\n        {\\n            if (i==0)\\n                res=max(res,((long long)nums[i]<<k)|(suffix[i+1]));\\n            else if (i==n-1)\\n                res=max(res,((long long)nums[i]<<k)|(prefix[i-1]));\\n            else\\n                res=max(res,((long long)nums[i]<<k)|(suffix[i+1]|prefix[i-1]));\\n        }\\n        return res;\\n\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        if (n==1) return nums[0]<<k;\\n        vector<long long> prefix(n);\\n        vector<long long> suffix(n);\\n        prefix[0]=nums[0];\\n        for (int i=1;i<n;i++)\\n          prefix[i]=prefix[i-1]|nums[i];\\n        suffix[n-1]=nums[n-1];\\n        for (int i=n-2;i>=0;i--)\\n          suffix[i]=suffix[i+1]|nums[i];\\n        long long res=0;\\n        for (int i=0;i<n;i++)\\n        {\\n            if (i==0)\\n                res=max(res,((long long)nums[i]<<k)|(suffix[i+1]));\\n            else if (i==n-1)\\n                res=max(res,((long long)nums[i]<<k)|(prefix[i-1]));\\n            else\\n                res=max(res,((long long)nums[i]<<k)|(suffix[i+1]|prefix[i-1]));\\n        }\\n        return res;\\n\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524952,
                "title": "maximum-or-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe give all the 2s to the number whose or can give the max answer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe create a prefix array storing the or\\'s of nums.\\nwe also create a suffix array storing the or\\'s of nums.\\n\\nnext we cal the max answer (max or).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<long long> pre(n+1,0);\\n        vector<long long> suf(n+1,0);\\n\\n        long long ans=0;\\n        long long y=1<<k;\\n\\n        pre[0] = 0;\\n        suf[n] = 0;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            pre[i+1] = pre[i] | nums[i];\\n        }\\n\\n        for(int i=n-1;i>=0;i--){\\n            suf[i] = suf[i+1] | nums[i];\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            ans = max(ans, pre[i] | nums[i]*y | suf[i+1] );\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<long long> pre(n+1,0);\\n        vector<long long> suf(n+1,0);\\n\\n        long long ans=0;\\n        long long y=1<<k;\\n\\n        pre[0] = 0;\\n        suf[n] = 0;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            pre[i+1] = pre[i] | nums[i];\\n        }\\n\\n        for(int i=n-1;i>=0;i--){\\n            suf[i] = suf[i+1] | nums[i];\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            ans = max(ans, pre[i] | nums[i]*y | suf[i+1] );\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524385,
                "title": "python-3-line-solution-prefix-suffix",
                "content": "```\\ndef maximumOr(self, nums: List[int], k: int) -> int:\\n    s1 = [0]+list(accumulate(nums, ior))\\n    s2 = list(accumulate(nums[::-1], ior))[::-1]+[0]\\n    return max(s1[i]|(nums[i]<<k)|s2[i+1] for i in range(len(nums)))\\n```",
                "solutionTags": [],
                "code": "```\\ndef maximumOr(self, nums: List[int], k: int) -> int:\\n    s1 = [0]+list(accumulate(nums, ior))\\n    s2 = list(accumulate(nums[::-1], ior))[::-1]+[0]\\n    return max(s1[i]|(nums[i]<<k)|s2[i+1] for i in range(len(nums)))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3524282,
                "title": "python3-solution-using-bitwise-operations-only",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can consider calculating the final solution without modifying anything during the first pass. In the second pass, for each number X, we can remove the effect of that number, compute the effect of that number X multiplied by 2 \"k\" times, and record the running maximum.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn order the remove the effect of each number, we would need to know if there are any bits that show up more than once. (eg. 12 (1101) and 9 (1001) have repeating bits at first and last position. Hence, when trying to remove 12 from the total result, we need to ensure that the bits at 1001 are still there.)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        total = 0\\n        extras = 0 #bits that show up multiple times\\n        for num in nums:\\n            extras |= num & total\\n            total |= num\\n\\n        res = 0\\n        for num in nums:\\n            original = total\\n            total -= num # remove bits of currrent number\\n            total |= num << k # add new number shifted k times\\n            total |= extras # add back \"extra\" bits that show up more than once\\n            res = max(res, total)\\n            total = original\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        total = 0\\n        extras = 0 #bits that show up multiple times\\n        for num in nums:\\n            extras |= num & total\\n            total |= num\\n\\n        res = 0\\n        for num in nums:\\n            original = total\\n            total -= num # remove bits of currrent number\\n            total |= num << k # add new number shifted k times\\n            total |= extras # add back \"extra\" bits that show up more than once\\n            res = max(res, total)\\n            total = original\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523909,
                "title": "hash-table-and-bit-manipulation-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- use count as dict to store 32 bit numbers\\n- as or operation need to use temp to deduct n as bits\\n- use greedy to brute force all cases, k use for one number is better for split to others\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(32 * n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        # use count as dict to store 32 bit numbers\\n        count = [0] * 32\\n        # count all bit numbers\\n        for n in nums:\\n            for i in range(32):\\n                if n >> i & 1:\\n                    count[i] += 1\\n\\n        ans = 0\\n        for n in nums:\\n            # as or operation need to use temp to deduct n as bits\\n            temp = count.copy()\\n            for i in range(32):\\n                if n >> i & 1:\\n                    temp[i] -= 1\\n                \\n            res = 0\\n            for i in range(32):\\n                if temp[i]:\\n                    res += 1 << i\\n            # use greedy to brute force all cases\\n            res |= n << k\\n            ans = max(ans, res)\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        # use count as dict to store 32 bit numbers\\n        count = [0] * 32\\n        # count all bit numbers\\n        for n in nums:\\n            for i in range(32):\\n                if n >> i & 1:\\n                    count[i] += 1\\n\\n        ans = 0\\n        for n in nums:\\n            # as or operation need to use temp to deduct n as bits\\n            temp = count.copy()\\n            for i in range(32):\\n                if n >> i & 1:\\n                    temp[i] -= 1\\n                \\n            res = 0\\n            for i in range(32):\\n                if temp[i]:\\n                    res += 1 << i\\n            # use greedy to brute force all cases\\n            res |= n << k\\n            ans = max(ans, res)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523646,
                "title": "scala-concise-functional-solution-using-scanleft-scanright",
                "content": "# Code\\n```\\nobject Solution {\\n  def maximumOr(nums: Array[Int], k: Int): Long = {\\n    val prefixOr = nums.scanLeft(0L)(_ | _)\\n    val suffixOr = nums.scanRight(0L)(_ | _)\\n    nums.indices.map(i => prefixOr(i) | (nums(i).toLong << k) | suffixOr(i + 1)).max\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def maximumOr(nums: Array[Int], k: Int): Long = {\\n    val prefixOr = nums.scanLeft(0L)(_ | _)\\n    val suffixOr = nums.scanRight(0L)(_ | _)\\n    nums.indices.map(i => prefixOr(i) | (nums(i).toLong << k) | suffixOr(i + 1)).max\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3523455,
                "title": "beats-100-time-compexity-and-memory-prefix-surfix-simpe-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse prefix and surfix inorder to reduce the time complexity.\\n\\n \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nruntime : 6ms\\nBeats : 100%\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nspace : 58.9\\nbeats : 100%\\n# Code\\n```\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        long n = (long)Math.pow(2,k);\\n        if(nums.length<=1){\\n            return nums[0]*n ;\\n        }\\n        long pre [] = new long[nums.length];\\n        long sur [] = new long[nums.length];\\n        // long n = (long)Math.pow(2,k);\\n        long ans = 0;\\n        pre[0] = nums[0];\\n        sur[nums.length-1] = nums[nums.length-1];\\n        \\n        for(int i = 1;i<pre.length;i++){\\n            pre[i] = pre[i-1] | nums[i];\\n        }\\n        \\n        for(int i = sur.length-2;i>=0;i--){\\n            sur[i] = sur[i+1] | nums[i];\\n        } \\n        \\n        for(int i =0;i<nums.length;i++){\\n            long a = 0;\\n            if(i==0){\\n                a = (nums[i]*n) | sur[i+1];\\n            }else if(i==nums.length-1){\\n                a = (nums[i]*n) | pre[i-1];\\n            }else{\\n                a = (nums[i]*n) | pre[i-1] | sur[i+1];\\n            } \\n            ans = (long)Math.max(ans,a);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        long n = (long)Math.pow(2,k);\\n        if(nums.length<=1){\\n            return nums[0]*n ;\\n        }\\n        long pre [] = new long[nums.length];\\n        long sur [] = new long[nums.length];\\n        // long n = (long)Math.pow(2,k);\\n        long ans = 0;\\n        pre[0] = nums[0];\\n        sur[nums.length-1] = nums[nums.length-1];\\n        \\n        for(int i = 1;i<pre.length;i++){\\n            pre[i] = pre[i-1] | nums[i];\\n        }\\n        \\n        for(int i = sur.length-2;i>=0;i--){\\n            sur[i] = sur[i+1] | nums[i];\\n        } \\n        \\n        for(int i =0;i<nums.length;i++){\\n            long a = 0;\\n            if(i==0){\\n                a = (nums[i]*n) | sur[i+1];\\n            }else if(i==nums.length-1){\\n                a = (nums[i]*n) | pre[i-1];\\n            }else{\\n                a = (nums[i]*n) | pre[i-1] | sur[i+1];\\n            } \\n            ans = (long)Math.max(ans,a);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523430,
                "title": "c-o-n-time-space-previous-and-subsequent-xor",
                "content": "# Intuition\\n- A previous xor preXor[i] contains all previous numbers\\' xor;\\n- A subsequent xor subXor[i] contains all subsequent numbers xor;\\n- preXor[i] | subXor[i] = xor of all numbers except nums[i];\\n- If shifting nums[i]\\'s bits 1 time makes the max xor, then nums[i] must has the highest \\'1\\' bit, therefore, all k shifts should be performed on nums[i].\\n\\n# Approach\\nCalculate preXor;\\nCalculate subXor;\\nFor nums[i], shift nums[i], and xor with preXor[i] and subXor[i], keep the biggest result as the answer.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        vector<int> preXor(nums.size(), 0); // All previous numbers xor.\\n        vector<int> subXor(nums.size(), 0); // All subsequent numbers xor.\\n        \\n        for(int i = 1; i < preXor.size(); ++i){\\n            preXor[i] = preXor[i - 1] | nums[i - 1];\\n        }\\n\\n        for(int i = subXor.size() - 2; i >= 0; --i){\\n            subXor[i] = subXor[i + 1] | nums[i + 1];\\n        }\\n\\n        long long answer = 0;\\n        for(int i = 0; i < nums.size(); ++i){\\n            // 1. preXor[i] | subXor[i] = xor of all numbers except nums[i]\\n            // 2. if shifting nums[i]\\'s bits 1 time makes the max xor, then nums[i] must has the highest \\'1\\' bit, therefore, all k shifts should be on nums[i].\\n            answer = max(answer, (nums[i] * 1ll << k) | preXor[i] | subXor[i]); \\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        vector<int> preXor(nums.size(), 0); // All previous numbers xor.\\n        vector<int> subXor(nums.size(), 0); // All subsequent numbers xor.\\n        \\n        for(int i = 1; i < preXor.size(); ++i){\\n            preXor[i] = preXor[i - 1] | nums[i - 1];\\n        }\\n\\n        for(int i = subXor.size() - 2; i >= 0; --i){\\n            subXor[i] = subXor[i + 1] | nums[i + 1];\\n        }\\n\\n        long long answer = 0;\\n        for(int i = 0; i < nums.size(); ++i){\\n            // 1. preXor[i] | subXor[i] = xor of all numbers except nums[i]\\n            // 2. if shifting nums[i]\\'s bits 1 time makes the max xor, then nums[i] must has the highest \\'1\\' bit, therefore, all k shifts should be on nums[i].\\n            answer = max(answer, (nums[i] * 1ll << k) | preXor[i] | subXor[i]); \\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522812,
                "title": "c-solution-using-prefix-and-suffix-or-map",
                "content": "# Approach:\\n\\nIn the question as it is given that, we need to fnd the **Maximum bitwise OR** for the array.\\nNow, for this question , the maximum solution exits if and only if we are manipulating the single element.\\nNow for each elements( index ), we will find the prefix OR and the suffix OR using MAP\\nAnd then, while traversing through the whole array, we will just keep on updating the value of the elements as elements * pow(2, k), and then check for the OR  value.\\nand keep on updating the value of the maxx( the result )\\n\\n---\\n**And I was thinking of applying DP on this probleam. 0_o**\\n\\n----\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        vector<long long>pre;\\n        vector<long long>suff;\\n\\n        long long c=0;\\n        map<long , long>mp;\\n        for(long long i=0;i<nums.size();i++)\\n        {\\n            mp[i]=c;\\n            c=c|nums[i];\\n        }\\n        // mp-> will be pointing to the prefix OR of all the prev elements\\n\\n        c=0;\\n        map<long long , long long>mp1;\\n        for(long long i=nums.size()-1;i>=0;i--)\\n        {\\n            mp1[i]=c;\\n            c=c|nums[i];\\n        }\\n        long long maxx=0;\\n        // mp1-> will be pointing towards the suffix OR of the forward elements\\n        long long l=pow(2, k);\\n        for(long long i=0;i<nums.size();i++)\\n        {\\n            long long g=mp[i]|mp1[i];\\n            g=g|(l*nums[i]);\\n            if(g>maxx)\\n            maxx=g;\\n\\n        }\\n        return maxx;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        vector<long long>pre;\\n        vector<long long>suff;\\n\\n        long long c=0;\\n        map<long , long>mp;\\n        for(long long i=0;i<nums.size();i++)\\n        {\\n            mp[i]=c;\\n            c=c|nums[i];\\n        }\\n        // mp-> will be pointing to the prefix OR of all the prev elements\\n\\n        c=0;\\n        map<long long , long long>mp1;\\n        for(long long i=nums.size()-1;i>=0;i--)\\n        {\\n            mp1[i]=c;\\n            c=c|nums[i];\\n        }\\n        long long maxx=0;\\n        // mp1-> will be pointing towards the suffix OR of the forward elements\\n        long long l=pow(2, k);\\n        for(long long i=0;i<nums.size();i++)\\n        {\\n            long long g=mp[i]|mp1[i];\\n            g=g|(l*nums[i]);\\n            if(g>maxx)\\n            maxx=g;\\n\\n        }\\n        return maxx;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522470,
                "title": "c-prefix-suffix",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$ \\n\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\n```\\npublic class Solution \\n{\\n    public long MaximumOr(int[] nums, int k)\\n    {\\n        int n = nums.Length;\\n        long[] prefix = new long[n];\\n        long[] suffix = new long[n];\\n\\n        for (int i = 1; i < n; i++)\\n        {\\n            prefix[i] = prefix[i - 1] | nums[i-1];\\n        }\\n\\n        for (int i = n - 2; i >= 0; i--)\\n        {\\n            suffix[i] = suffix[i + 1] | nums[i+1];\\n        }\\n\\n        long result = 0;\\n        long power = (int)Math.Pow(2,k);\\n        for (int i = 0; i < n; i++)\\n        {\\n            result = Math.Max(result, prefix[i] | (nums[i] * power) | suffix[i]);\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public long MaximumOr(int[] nums, int k)\\n    {\\n        int n = nums.Length;\\n        long[] prefix = new long[n];\\n        long[] suffix = new long[n];\\n\\n        for (int i = 1; i < n; i++)\\n        {\\n            prefix[i] = prefix[i - 1] | nums[i-1];\\n        }\\n\\n        for (int i = n - 2; i >= 0; i--)\\n        {\\n            suffix[i] = suffix[i + 1] | nums[i+1];\\n        }\\n\\n        long result = 0;\\n        long power = (int)Math.Pow(2,k);\\n        for (int i = 0; i < n; i++)\\n        {\\n            result = Math.Max(result, prefix[i] | (nums[i] * power) | suffix[i]);\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522402,
                "title": "beats-100-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        nums=sorted(nums,reverse=True)\\n        cur = 0\\n        saved = 0\\n        for num in nums:\\n            saved |= num & cur\\n            cur |= num\\n        max_num = 0\\n        prev=0\\n        count=0\\n        for num in nums:\\n            count+=1\\n            max_num = saved | (cur^num) | num << k\\n            if(prev<=max_num):\\n                prev=max_num\\n            else:\\n                break\\n        return prev\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        nums=sorted(nums,reverse=True)\\n        cur = 0\\n        saved = 0\\n        for num in nums:\\n            saved |= num & cur\\n            cur |= num\\n        max_num = 0\\n        prev=0\\n        count=0\\n        for num in nums:\\n            count+=1\\n            max_num = saved | (cur^num) | num << k\\n            if(prev<=max_num):\\n                prev=max_num\\n            else:\\n                break\\n        return prev\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521811,
                "title": "no-need-to-move-multiple-numbers-no-need-to-consider-k-moves",
                "content": "# Intuition\\nThis question asks for the max OR result. The answer is ways moving the number with biggest bit for the max k times. No need to consider <k moves. And no need to move multiple numbers. Only move one single number.\\nWhich one single number to move? Just try them all.\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        counter = [0]*32\\n        for v in nums:\\n            for i in range(32):\\n                counter[i]+=(v>>i) & 1\\n        res = 0\\n        for v in nums:\\n            cur = v<<k\\n            for i in range(32):\\n                cnt = counter[i]-((v>>i) & 1)\\n                cur |= (cnt>0)<<i\\n            res = max(res,cur)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        counter = [0]*32\\n        for v in nums:\\n            for i in range(32):\\n                counter[i]+=(v>>i) & 1\\n        res = 0\\n        for v in nums:\\n            cur = v<<k\\n            for i in range(32):\\n                cnt = counter[i]-((v>>i) & 1)\\n                cur |= (cnt>0)<<i\\n            res = max(res,cur)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521781,
                "title": "c-bit-manipulation",
                "content": "```\\n\\tpublic long MaximumOr(int[] nums, int k) {\\n        var digits = new int[32];\\n        var ors = new long[nums.Length];\\n        long res = 0;\\n        for (int i = 0; i < 32; i++) {\\n            foreach (var num in nums) {\\n                digits[i] += (num >> i) & 1;\\n            }\\n        }\\n        for (int i = 0; i < nums.Length; i++) {\\n            var or = 0;\\n            for (int j = 0; j < 32; j++) {\\n                if (digits[j] - ((nums[i] >> j) & 1) < 1) continue;\\n                or += 1 << j;\\n            }\\n            ors[i] = or;\\n        }\\n        for (int i = 0; i < nums.Length; i++)\\n            res = Math.Max(res, ors[i] | (long)nums[i] << k);\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic long MaximumOr(int[] nums, int k) {\\n        var digits = new int[32];\\n        var ors = new long[nums.Length];\\n        long res = 0;\\n        for (int i = 0; i < 32; i++) {\\n            foreach (var num in nums) {\\n                digits[i] += (num >> i) & 1;\\n            }\\n        }\\n        for (int i = 0; i < nums.Length; i++) {\\n            var or = 0;\\n            for (int j = 0; j < 32; j++) {\\n                if (digits[j] - ((nums[i] >> j) & 1) < 1) continue;\\n                or += 1 << j;\\n            }\\n            ors[i] = or;\\n        }\\n        for (int i = 0; i < nums.Length; i++)\\n            res = Math.Max(res, ors[i] | (long)nums[i] << k);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3521698,
                "title": "java-easy-to-understand-prefix-suffix",
                "content": "```\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        long[] prefix = new long[nums.length + 1];\\n        long[] suffix = new long[nums.length + 1];\\n        for(int i = 0; i < nums.length; i++) prefix[i + 1] = prefix[i] | nums[i];\\n        for(int i = nums.length - 1; i >= 0; i--) suffix[i] = suffix[i + 1] | nums[i];\\n        long max = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            max = Math.max(max, prefix[i] | suffix[i + 1] | (nums[i]*1L << k));\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        long[] prefix = new long[nums.length + 1];\\n        long[] suffix = new long[nums.length + 1];\\n        for(int i = 0; i < nums.length; i++) prefix[i + 1] = prefix[i] | nums[i];\\n        for(int i = nums.length - 1; i >= 0; i--) suffix[i] = suffix[i + 1] | nums[i];\\n        long max = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            max = Math.max(max, prefix[i] | suffix[i + 1] | (nums[i]*1L << k));\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521610,
                "title": "c-prefix-suffix-or",
                "content": "```C []\\nint64_t maximumOr(int* nums, int numsSize, int k){\\n\\tint prefixOr[numsSize];\\n\\tprefixOr[0] = nums[0];\\n\\tfor (int i = 1; i < numsSize; i += 1){\\n\\t\\tprefixOr[i] = prefixOr[i - 1] | nums[i];\\n\\t}\\n\\n\\tint suffixOr[numsSize];\\n\\tsuffixOr[numsSize - 1] = nums[numsSize - 1];\\n\\tfor (int i = numsSize - 2; i >= 0; i -= 1){\\n\\t\\tsuffixOr[i] = suffixOr[i + 1] | nums[i];\\n\\t}\\n\\n\\tint64_t max = 0;\\n\\n\\tfor (int i = 0; i < numsSize; i += 1){\\n\\t\\tconst int64_t cur = (\\n\\t\\t\\t( (i - 1 >= 0)? (prefixOr[i - 1]) : (0) ) | \\n\\t\\t\\t( (int64_t)nums[i] << k ) | \\n\\t\\t\\t( (i + 1 < numsSize)? (suffixOr[i + 1]) : (0) )\\n\\t\\t);\\n\\t\\tif (cur > max){\\n\\t\\t\\tmax = cur;\\n\\t\\t}\\n\\t}\\n\\n\\treturn max;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C []\\nint64_t maximumOr(int* nums, int numsSize, int k){\\n\\tint prefixOr[numsSize];\\n\\tprefixOr[0] = nums[0];\\n\\tfor (int i = 1; i < numsSize; i += 1){\\n\\t\\tprefixOr[i] = prefixOr[i - 1] | nums[i];\\n\\t}\\n\\n\\tint suffixOr[numsSize];\\n\\tsuffixOr[numsSize - 1] = nums[numsSize - 1];\\n\\tfor (int i = numsSize - 2; i >= 0; i -= 1){\\n\\t\\tsuffixOr[i] = suffixOr[i + 1] | nums[i];\\n\\t}\\n\\n\\tint64_t max = 0;\\n\\n\\tfor (int i = 0; i < numsSize; i += 1){\\n\\t\\tconst int64_t cur = (\\n\\t\\t\\t( (i - 1 >= 0)? (prefixOr[i - 1]) : (0) ) | \\n\\t\\t\\t( (int64_t)nums[i] << k ) | \\n\\t\\t\\t( (i + 1 < numsSize)? (suffixOr[i + 1]) : (0) )\\n\\t\\t);\\n\\t\\tif (cur > max){\\n\\t\\t\\tmax = cur;\\n\\t\\t}\\n\\t}\\n\\n\\treturn max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3521596,
                "title": "python-simple-two-sweeps-explained",
                "content": "A simple solution is just try every number of the array, compute the final OR value after shift the number `k` times to the left. During the process, we remember the maximum values and find the solution.\\n\\nThe problem becomes how to compute the OR value of the array efficently.\\nWe can split the array into three sections:\\n* section 1: nums[0] ... nums[idx - 1]\\n* section 2: nums[idx]\\n* section 3: nums[idx + 1] ... nums[n]\\n\\nIf we know the OR value of section 1 and section 3, we can easily compute the final OR of the array.\\n\\n**Sweep 1**: we compute the backward OR value of the array from last number to each index, this can help us know the OR value of section 3.\\n\\n**Sweep 2**: we compute the forward OR value of the array from the first number to each index, and this helps us know the OR value of the section 1.\\n\\nSee the code below:\\n\\n```\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        # backward sweep to compute the running OR from n-1 to idx\\n        backward_or = [0] * (n + 1)\\n        idx, ror = n - 1, 0\\n        while idx >= 0:\\n            ror |= nums[idx]\\n            backward_or[idx] = ror\\n            idx -= 1\\n        \\n        # forward sweep to get the OR value of the array if we pick nums[i] shifting k times\\n        ans, forward_or = 0, 0\\n        for i in range(n):\\n            t = forward_or | backward_or[i + 1] | (nums[i] << k)\\n            ans = max(ans, t)\\n            forward_or |= nums[i]\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        # backward sweep to compute the running OR from n-1 to idx\\n        backward_or = [0] * (n + 1)\\n        idx, ror = n - 1, 0\\n        while idx >= 0:\\n            ror |= nums[idx]\\n            backward_or[idx] = ror\\n            idx -= 1\\n        \\n        # forward sweep to get the OR value of the array if we pick nums[i] shifting k times\\n        ans, forward_or = 0, 0\\n        for i in range(n):\\n            t = forward_or | backward_or[i + 1] | (nums[i] << k)\\n            ans = max(ans, t)\\n            forward_or |= nums[i]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521455,
                "title": "c-prefix-and-suffix-bitwise-or",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<long long> suffix(n + 1);\\n        suffix[n - 1] = nums[n - 1];\\n        for(int i = n - 2; i >= 0; i--) {\\n            suffix[i] = suffix[i + 1] | nums[i];\\n        }\\n        long long ans = 0, prefix = 0;\\n        for(int i = 0; i < n; i++) {\\n            long long val = prefix | ((long long)nums[i] << k) | suffix[i + 1];\\n            ans = max(ans, val);\\n            prefix = prefix | nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<long long> suffix(n + 1);\\n        suffix[n - 1] = nums[n - 1];\\n        for(int i = n - 2; i >= 0; i--) {\\n            suffix[i] = suffix[i + 1] | nums[i];\\n        }\\n        long long ans = 0, prefix = 0;\\n        for(int i = 0; i < n; i++) {\\n            long long val = prefix | ((long long)nums[i] << k) | suffix[i + 1];\\n            ans = max(ans, val);\\n            prefix = prefix | nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521393,
                "title": "c-greedy-2-bitwise-passes-constant-space-no-prefix-suffix-156ms-83-2mb",
                "content": "This is a fascinating one; we might be tempted to just multiply the larger number, but the first example already shows that it is not the most efficient strategy, since we might get all but one bits that are already covered by other numbers or anyway less than what we would get from multiply other numbers.\\n\\nFor example, for `12` (`1100` in binary) and `9` (`1001` in binary), we woul have the two scenarios with `k == 1`:\\n\\n```cpp\\n11000 // 24, multiplying 12\\n01001\\n-----\\n11001 // 25, after ORing\\n\\n\\n01100\\n10010 // 18, multiplying 9\\n-----\\n11110 // 30, after ORing\\n```\\n\\nSo, while we now know there is not super-quick way to figure out which number is more suited to the multiplication, we can prove that we can go greedy and only always multiply the same number; for example, in the following example, with `k == 4`, the two alternatives worth considering would be:\\n\\n```cpp\\n11000000 // 192, multiplying 12 by 2 4 times\\n00001001\\n-----\\n11001001 // 201, after ORing\\n\\n\\n00001100\\n10010000 // 144, multiplying 9 by 2 4 times\\n-----\\n10011100 // 156, after ORing\\n```\\n\\nThere is no way that we might get any larger number other than concentrating all our multiplications in only one, since we would get smaller most significant (ie: leftmost) bits that way (for example, multiplying each one by `2` twice, we would get `110000` and `100100`, which are clearly inferior).\\n\\nNow, what we need to do, is to try each possible number; but can we do so efficiently?\\n\\nThe answer is yes; and we can do in constant space too - unlike most other solutions I spotted here (at least reading the titles), I did not bother building prefix and suffix arrays, but just computed the overall ORed value of reducing `nums` with that bitwise operator (which I called `tot`), for starters.\\n\\nFrom there, we can derive the value we would have had without ORing a specific number `n` by removing the `1` bits that are unique to `n`.\\n\\nFor example, if we had:\\n\\n```cpp\\n011101100001\\n100110100010\\n110110000001\\n010010001001\\n------------\\n111111001011 // ORed total\\n```\\n\\nWe can now compute what would have been the total ORed value without the first number `11101100001` seeing that it is the only one having the seventh and tenth least significant (ie: rightmost) bits flagged to `1`. In other words `001001000000` is a set of bits unique to the first digit and we remove it from the ORed total, we can get what would have been the value of ORing all the other numbers and we can easily do so with a XOR:\\n\\n```cpp\\n001001000000 // bits unique to the first number\\n  |  |       // the ones that are just 0s in all the other columns\\n011101100001\\n100110100010\\n110110000001\\n010010001001\\n------------\\n111111001011 // ORed total\\n\\n111111001011 // XORing\\n001001000000\\n------------\\n110110001011 // value we would get ORing all numbers but the first\\n```\\n\\nRinse and repeat for each number and we can compute what values multiplied by `2` `k` times and ORed with the rest would give us the largest value.\\n\\nNow, to code all of this, let\\'s start with our usual support variables:\\n* `tot` will store our overall ORed total;\\n* `tmp` and `copyN` will store copy of `tot` and the number we are parsing respectively, in the second loop;\\n* `res` is our usual result variable, preset to `0` (the lowest value we can get if `nums` does not have a single bit flagged on);\\n* `bits` will be our frequency map for each bit, just to know which bits are unique to each number; granted, given the range we would only need `30` cells, but I liked the round digit;\\n* `pos` will help us to know which bit we are writing in when mapping their frequence.\\n\\nIn our first loop, for each value `n` in `nums`, we will:\\n* update `tot` ORing `n` into it;\\n* reset `pos` to `0`;\\n* parse each bit of `n`, looping `while` `n != 0` and:\\n    * if the current least significant bit is active (ie: `n & 1`), we will increase the frequency of the bit at the current position (ie: `bits[pos]`) by `1`;\\n    * preparing for the next iteration, we will advance `pos` by `1`;\\n    * we will shave the least significant digit from `n`, right shifting the number by `1` position (ie: `n >>= 1`).\\n\\nIn our second loop, again for each `n` in `nums`, we will:\\n* copy `tot` into `tmp`;\\n* copy `n` into `copyN`;\\n* reset `pos` to `0`;\\n* parse each bit of `n`, looping `while` `n != 0` and:\\n    * if the current least significant bit is active (ie: `n & 1`) and it was the only time we encountered it (ie: `bits[pos] == 1`), we will flip it to `0` in `tmp` with a XOR operation (ie: `tmp ^= (1 << pos)`);\\n    * preparing for the next iteration, we will advance `pos` by `1`;\\n    * we will shave the least significant digit from `n`, right shifting the number by `1` position (ie: `n >>= 1`).\\n* update `res` to be the maximum between its current value and the result of all the numbers but `copyN` ORed (ie: `tmp`) ORed by `copyN` multiplied by `2` `k` times (ie: `copyN << k`).\\n\\nFinally, we can `return` `res` :)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        // support variables\\n        long long tot = 0, tmp, copyN, res = 0;\\n        int bits[32] = {0}, pos;\\n        // computing tot and populating bits\\n        for (int n: nums) {\\n            tot |= n;\\n            pos = 0;\\n            while (n) {\\n                if (n & 1) bits[pos]++;\\n                pos++;\\n                n >>= 1;\\n            }\\n        }\\n        // trying each number\\n        for (int n: nums) {\\n            tmp = tot, copyN = n;\\n            pos = 0;\\n            while (n) {\\n                if ((n & 1) && bits[pos] == 1) tmp ^= (1 << pos);\\n                pos++;\\n                n >>= 1;\\n            }\\n            res = max(res, tmp | (copyN << k));\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nCan we do better? Bien s\\xFBr!\\n\\nWe can proceed as before with the first loop, then, right at the end of it, we can iterate `bits` and create a bitmask of `uniqueBits`.\\n\\nThen we have two case:\\n* if there are no unique bits (ie: `uniqueBits == 0`), we will just try to OR the value of every number `n` shifted `k` times to `tot` and `return` the largest one we can get;\\n* if we have them, we can loop like in the previous loop, but at a much faster pace, creating a `bitmask` of unique bits presents in each number `n` (ie: `n & uniqueBits`) and then XOR it away from `tot`, computing `res` as before, just faster.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n\\n```cpp\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        // support variables\\n        long long tot = 0, tmp, res = 0, uniqueBits = 0, bitmask;\\n        int bits[32] = {0}, pos;\\n        // computing tot and populating bits\\n        for (int n: nums) {\\n            tot |= n;\\n            pos = 0;\\n            while (n) {\\n                if (n & 1) bits[pos]++;\\n                pos++;\\n                n >>= 1;\\n            }\\n        }\\n        // populating uniqueBits\\n        for (int i = 0, currBit = 1; i < 31; i++, currBit <<= 1) {\\n            if (bits[i] == 1) uniqueBits |= currBit;\\n        }\\n        // edge case: no unique bits, so we just greedily get the biggest number we can\\n        if (!uniqueBits) {\\n            for (long long n: nums) res = max(res, tot | (n << k));\\n        }\\n        // trying each number\\n        for (long long n: nums) {\\n            bitmask = n & uniqueBits, tmp = tot ^ bitmask;\\n            res = max(res, tmp | (n << k));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```cpp\\n11000 // 24, multiplying 12\\n01001\\n-----\\n11001 // 25, after ORing\\n\\n\\n01100\\n10010 // 18, multiplying 9\\n-----\\n11110 // 30, after ORing\\n```\n```cpp\\n11000000 // 192, multiplying 12 by 2 4 times\\n00001001\\n-----\\n11001001 // 201, after ORing\\n\\n\\n00001100\\n10010000 // 144, multiplying 9 by 2 4 times\\n-----\\n10011100 // 156, after ORing\\n```\n```cpp\\n011101100001\\n100110100010\\n110110000001\\n010010001001\\n------------\\n111111001011 // ORed total\\n```\n```cpp\\n001001000000 // bits unique to the first number\\n  |  |       // the ones that are just 0s in all the other columns\\n011101100001\\n100110100010\\n110110000001\\n010010001001\\n------------\\n111111001011 // ORed total\\n\\n111111001011 // XORing\\n001001000000\\n------------\\n110110001011 // value we would get ORing all numbers but the first\\n```\n```cpp\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        // support variables\\n        long long tot = 0, tmp, copyN, res = 0;\\n        int bits[32] = {0}, pos;\\n        // computing tot and populating bits\\n        for (int n: nums) {\\n            tot |= n;\\n            pos = 0;\\n            while (n) {\\n                if (n & 1) bits[pos]++;\\n                pos++;\\n                n >>= 1;\\n            }\\n        }\\n        // trying each number\\n        for (int n: nums) {\\n            tmp = tot, copyN = n;\\n            pos = 0;\\n            while (n) {\\n                if ((n & 1) && bits[pos] == 1) tmp ^= (1 << pos);\\n                pos++;\\n                n >>= 1;\\n            }\\n            res = max(res, tmp | (copyN << k));\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        // support variables\\n        long long tot = 0, tmp, res = 0, uniqueBits = 0, bitmask;\\n        int bits[32] = {0}, pos;\\n        // computing tot and populating bits\\n        for (int n: nums) {\\n            tot |= n;\\n            pos = 0;\\n            while (n) {\\n                if (n & 1) bits[pos]++;\\n                pos++;\\n                n >>= 1;\\n            }\\n        }\\n        // populating uniqueBits\\n        for (int i = 0, currBit = 1; i < 31; i++, currBit <<= 1) {\\n            if (bits[i] == 1) uniqueBits |= currBit;\\n        }\\n        // edge case: no unique bits, so we just greedily get the biggest number we can\\n        if (!uniqueBits) {\\n            for (long long n: nums) res = max(res, tot | (n << k));\\n        }\\n        // trying each number\\n        for (long long n: nums) {\\n            bitmask = n & uniqueBits, tmp = tot ^ bitmask;\\n            res = max(res, tmp | (n << k));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521349,
                "title": "python3-two-counters-constant-space-lots-of-bit-hacks",
                "content": "# Disclaimer\\nI wasn\\'t able to crack this question during the contest; I figured out the trick but wasn\\'t able to implement it nor rigorously prove why it works. Other solutions do a good job with the proof so I\\'ll just explain my intuition down below.\\n\\n# Trick\\nWe want to find the maximal array OR (`nums[0] | nums[1] | ... | nums[n - 1]`), where we can multiply by 2 any values (possibly different ones) in the array, for a total of k multiplications. Immediately, because we\\'re multiplying by 2 and trying to maximize a bitwise operation, we should realize that multiplying by 2 is equivalent to a single left shift.\\n\\nIt also turns out that it\\'s best to select only one value to be shifted k times. This makes sense because, by shifting say the largest value k times, we can achieve a really big single value to be used in our array OR operation. However, choosing the maximum value in the array doesn\\'t necessarily work (see the given example [12, 9]).\\n\\n# Algorithm\\nA correct algorthm will do the following:\\n1. Figure out the candidates to be shifted (one pass)\\n2. For each number in the array (second pass)\\n  a. If the number is a candidate, do the below\\n  b. Compute the OR of the array, discluding the candidate; `curr_removed`\\n  c. Compute the candidate, shifted left `k` times; `shifted`\\n  d. Set the result to be the larger between the result and `shifted | curr_removed`\\n\\nYou\\'ll notice that this approach would run in quadratic time since we\\'re recomputing the array OR not including the candidate each time. Because the same bit can be included multiple times, we need to be smart about this, which is explained in the implementation.\\n\\n# Implementation + Bithacks\\nSince we need to compute the array OR quickly and need only to simulate removing a single candidate, it makes sense to precompute this in a single pass for constant lookup later. However, it\\'s not entirely clear exactly how to remove a candidate from an array OR from a first glance. If we re-think the array OR, we\\'ll notice that it\\'s equal to an OR of two components:\\n\\n`array OR = bits_appearing_exactly_once | bits_appearing_two_or_more_times`\\n\\nSo, in our first pass that computes the candidates to be shifted, we can also compute the two bitsets as well (`once` and `two_or_more`).\\n\\nNote that calculating the above bitsets can be done using only bit operations in an iterative way, for each number `curr = nums[i]`. Note that the order of how we\\'re calculating `two_or_more` and `once` matters.\\n\\n`two_or_more = two_or_more | (once & curr)`.\\n- Doing `two_or_more | ...` indicates we\\'re keeping the current bits set two or more times, as desired.\\n- `once & curr` keeps bits that have appeared exactly once and are present in `curr`, which is equal to the bits that appear exactly twice within `curr`.\\n\\n`once = ~two_or_more & (once | curr)`\\n- `~two_or_more & ...` means that we\\'re using our updated `two_or_more` and making it so that any bits that are set in it **are cleared** in our computation of `once`\\n- `once | curr` simply tracks bits that had appeared once and possibly new bits present in `curr`.\\n\\nWith `once` and `two_or_more` computed, simulating the removal of a candidate from the array OR is more straightforward:\\n`array OR with candidate shifted = two_or_more | (once & ~curr) | (curr << k)`\\n- The bits in `two_or_more` are kept because removing of the bits in `curr` wouldn\\'t have affected the presence of these bits when calculating the rest of the array OR\\n- `once & ~curr` keeps the bits appearing once while also simulating the removal of the bits set in `curr`\\n- `curr << k` left shifts `curr` the required number of times.\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        # maximumOr calculation: the best result should be the maximal value of:\\n        # OR(nums[i], i != j) | nums[j] << k, for each j. Not too sure why.\\n        # Compute bit counts efficiently in first pass      \\n        once, two_or_more = 0, 0 # track bits appearing exactly one time, bits appearing two+ times\\n        highest_bit = 0 # only need to promote the numbers with the highest bit set\\n        for curr in nums:\\n            highest_bit = max(highest_bit, curr.bit_length()) # track highest bit set using built-in bit_length\\n            two_or_more_next = two_or_more | ( # keep current two or more\\n                once & curr\\n            )\\n            two_or_more = two_or_more_next # things that have appeared 2+ times updated            \\n            once_next = ~two_or_more & ( # zero out things appearing two/more times using updated two/more\\n                once | # things that have appeared once are kept\\n                curr   # curr in binary = things that have appeared once\\n            )\\n\\n            once = once_next\\n\\n        # maximumOr calculation\\n        res = 0\\n        for curr in nums:\\n            if curr.bit_length() != highest_bit: # not a candidate for promotion\\n                continue\\n            shifted = curr << k\\n            curr_removed = once & ~curr # clear curr from once\\n            cand = two_or_more | shifted | curr_removed\\n            res = max(res, cand)\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        # maximumOr calculation: the best result should be the maximal value of:\\n        # OR(nums[i], i != j) | nums[j] << k, for each j. Not too sure why.\\n        # Compute bit counts efficiently in first pass      \\n        once, two_or_more = 0, 0 # track bits appearing exactly one time, bits appearing two+ times\\n        highest_bit = 0 # only need to promote the numbers with the highest bit set\\n        for curr in nums:\\n            highest_bit = max(highest_bit, curr.bit_length()) # track highest bit set using built-in bit_length\\n            two_or_more_next = two_or_more | ( # keep current two or more\\n                once & curr\\n            )\\n            two_or_more = two_or_more_next # things that have appeared 2+ times updated            \\n            once_next = ~two_or_more & ( # zero out things appearing two/more times using updated two/more\\n                once | # things that have appeared once are kept\\n                curr   # curr in binary = things that have appeared once\\n            )\\n\\n            once = once_next\\n\\n        # maximumOr calculation\\n        res = 0\\n        for curr in nums:\\n            if curr.bit_length() != highest_bit: # not a candidate for promotion\\n                continue\\n            shifted = curr << k\\n            curr_removed = once & ~curr # clear curr from once\\n            cand = two_or_more | shifted | curr_removed\\n            res = max(res, cand)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521335,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long int\\nclass Solution {\\npublic:\\n//     long long maxOR(vector<long long> &arr, int k, int x){\\n        \\n//     }\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<ll> arr(n);\\n        \\n        for(int i = 0; i<n; i++){\\n            arr[i] = nums[i];\\n        }\\n        long long preSum[n+1], suffSum[n+1];\\n        long long res = 0;\\n        \\n        \\n        \\n        preSum[0] = 0;\\n        for(int i = 0; i<n; i++){\\n            preSum[i+1] = preSum[i] | arr[i];\\n        }\\n        \\n        suffSum[n-1] = 0;\\n        for(int i = n-2; i >= 0; i--){\\n            suffSum[i] = suffSum[i+1] | arr[i+1];\\n        }\\n        \\n        long long curr = 0;\\n        for(int i = 0; i<n; i++){\\n            curr = preSum[i] | suffSum[i] | (1<<k)*arr[i];\\n            res = max(res, curr);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n//     long long maxOR(vector<long long> &arr, int k, int x){\\n        \\n//     }\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<ll> arr(n);\\n        \\n        for(int i = 0; i<n; i++){\\n            arr[i] = nums[i];\\n        }\\n        long long preSum[n+1], suffSum[n+1];\\n        long long res = 0;\\n        \\n        \\n        \\n        preSum[0] = 0;\\n        for(int i = 0; i<n; i++){\\n            preSum[i+1] = preSum[i] | arr[i];\\n        }\\n        \\n        suffSum[n-1] = 0;\\n        for(int i = n-2; i >= 0; i--){\\n            suffSum[i] = suffSum[i+1] | arr[i+1];\\n        }\\n        \\n        long long curr = 0;\\n        for(int i = 0; i<n; i++){\\n            curr = preSum[i] | suffSum[i] | (1<<k)*arr[i];\\n            res = max(res, curr);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521301,
                "title": "prefix-suffix-or-sequence-shifting-operation-y-k-and-comparison-python",
                "content": "**Idea**: Partial Sequence and Comparison \\n\\n`Multiplying a number y by 2` is equivalent to `adding a tailing 0 in its binary form`.\\nTherefore, we need to push the number with the most significant 1 bit as left as\\npossible by doing `y << k`. As there might be multiple numbers with the same most siginificant 1 bit, we need comparison.\\n\\nIn Eg-1, `12 = 1100; 9 = 1001`. The two numbers have the same most significant 1 bit position, \\nthat is the leading 1. So we compare the results by doing `12 << 1 and 9 << 1`.\\nHere it turns out the result yielded by doing 9 << 1 is larger: `30 = 11110`.\\nOne can check the result yielded by doing `12 << 1 is 24 = 11001`.\\n\\n\\nIn Eg-2, `8 = 1000, 1 = 0001, 2 = 0010`. The number 8 has the most significant 1 bit.\\nSo we do: `8 << k`\\n\\nTherefore, to get the maximal result, we just need to try doing `y << k` for each number in\\nthe list, computing the corresponding bitwise OR result, and return the max of them.\\nTo accelerate we could use prefix `OR` result and suffix `OR` result.\\n\\n```\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        \\n        # step-1 compute the prefix or and suffix or results\\n        n = len(nums)\\n        prefix_or = [0] * n\\n        prefix_or[0] = nums[0]\\n        suffix_or = [0] * n\\n        suffix_or[n-1] = nums[n-1]\\n        for i in range(1, n):\\n            prefix_or[i] = prefix_or[i-1] | nums[i]\\n        for i in range(n-2, -1, -1):\\n            suffix_or[i] = suffix_or[i+1] | nums[i]\\n        \\n        # step-2 comparison\\n        res = 0\\n        for i in range(n):\\n            pre, suf = 0, 0\\n            if i > 0:\\n                pre = prefix_or[i-1]\\n            if i < n-1:\\n                suf = suffix_or[i+1]\\n            res = max(res, pre | suf | (nums[i] << k)) # comparison\\n        \\n        return res\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        \\n        # step-1 compute the prefix or and suffix or results\\n        n = len(nums)\\n        prefix_or = [0] * n\\n        prefix_or[0] = nums[0]\\n        suffix_or = [0] * n\\n        suffix_or[n-1] = nums[n-1]\\n        for i in range(1, n):\\n            prefix_or[i] = prefix_or[i-1] | nums[i]\\n        for i in range(n-2, -1, -1):\\n            suffix_or[i] = suffix_or[i+1] | nums[i]\\n        \\n        # step-2 comparison\\n        res = 0\\n        for i in range(n):\\n            pre, suf = 0, 0\\n            if i > 0:\\n                pre = prefix_or[i-1]\\n            if i < n-1:\\n                suf = suffix_or[i+1]\\n            res = max(res, pre | suf | (nums[i] << k)) # comparison\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521239,
                "title": "java-o-n-suffix-sum",
                "content": "# Intuition\\nThe most tricky point is to understnad that the biggiest result of `nums[0] | nums[1]...`  will be in case all `k` shift left will be done for one number, becase `1` bits will take the most left postions and `or` operation on such number will return the max value.\\n\\nWe just need to check all numbers to find witch one shift operation must be applied.\\nAt this point task become quite similar to [238](https://leetcode.com/problems/product-of-array-except-self/)\\nWe need to precalculate suffix sum (`or` operation in this task instead of tipical `+`) to avoid O(n^2) complexity. \\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        int[] right = new int[nums.length + 1];\\n        for (int i=nums.length - 1; i>=0; i--) {\\n            right[i] = right[i + 1] | nums[i];\\n        }\\n\\n        long max = 0;\\n        int curr = 0;\\n        for (int i=0; i<nums.length; i++) {\\n            long local = (((long) nums[i]) << k) | curr | right[i + 1];\\n        \\n            max = Math.max(max, local);\\n            curr |= nums[i];\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        int[] right = new int[nums.length + 1];\\n        for (int i=nums.length - 1; i>=0; i--) {\\n            right[i] = right[i + 1] | nums[i];\\n        }\\n\\n        long max = 0;\\n        int curr = 0;\\n        for (int i=0; i<nums.length; i++) {\\n            long local = (((long) nums[i]) << k) | curr | right[i + 1];\\n        \\n            max = Math.max(max, local);\\n            curr |= nums[i];\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521158,
                "title": "solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<long long> pre(n+1,0);\\n        vector<long long> suf(n+1,0);\\n\\n        long long res=0;\\n        long long r=1;\\n        r=r<<k;\\n        \\n        pre[0]=0;\\n        suf[n]=0;\\n\\n        for(int i=0;i<n;i++){\\n            pre[i+1]=pre[i]|nums[i];\\n        }\\n\\n        for(int i=n-1;i>=0;i--){\\n            suf[i]=suf[i+1]|nums[i];\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            res=max(res, pre[i] | (nums[i]*r) | suf[i+1]);\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<long long> pre(n+1,0);\\n        vector<long long> suf(n+1,0);\\n\\n        long long res=0;\\n        long long r=1;\\n        r=r<<k;\\n        \\n        pre[0]=0;\\n        suf[n]=0;\\n\\n        for(int i=0;i<n;i++){\\n            pre[i+1]=pre[i]|nums[i];\\n        }\\n\\n        for(int i=n-1;i>=0;i--){\\n            suf[i]=suf[i+1]|nums[i];\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            res=max(res, pre[i] | (nums[i]*r) | suf[i+1]);\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521146,
                "title": "simple-dp-approach-java",
                "content": "\\n# Approach\\n Optimised dp,\\n where dp[i][j] is maximum OR after using j operation till index i\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        long dp[] = new long[k+1];\\n        long tmp[] = new long[k+1];\\n       \\n        for(long xx:nums){\\n            for(int i=0;i<=k;i++){\\n                long max=0;\\n                for(int j=0;j<=i;j++){\\n                    max = Math.max(max, (xx<<j)|dp[i-j] );\\n                }\\n                tmp[i] = max;\\n            }\\n            dp = tmp;\\n            tmp = new long[k+1];\\n        }\\n        return dp[k];\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        long dp[] = new long[k+1];\\n        long tmp[] = new long[k+1];\\n       \\n        for(long xx:nums){\\n            for(int i=0;i<=k;i++){\\n                long max=0;\\n                for(int j=0;j<=i;j++){\\n                    max = Math.max(max, (xx<<j)|dp[i-j] );\\n                }\\n                tmp[i] = max;\\n            }\\n            dp = tmp;\\n            tmp = new long[k+1];\\n        }\\n        return dp[k];\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521116,
                "title": "go-lang-prefix-suffix-approach",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$, we store a prefix and suffix array.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc max(a int, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\nfunc maximumOr(nums []int, k int) int64 {\\n\\tmultipler := math.Pow(float64(2), float64(k))\\n\\tmaxVal := 0\\n\\tpreFix := make([]int, len(nums))\\n\\tsufFix := make([]int, len(nums))\\n\\n\\tfor i := 1; i < len(preFix); i++ {\\n\\t\\tpreFix[i] = preFix[i-1] | nums[i-1]\\n\\t}\\n\\tfor i := len(sufFix) - 2; i >= 0; i-- {\\n\\t\\tsufFix[i] = sufFix[i+1] | nums[i+1]\\n\\t}\\n\\tfor i := 0; i < len(nums); i++ {\\n\\n\\t\\tmaxVal = max(maxVal, preFix[i]|nums[i]*int(multipler)|sufFix[i])\\n\\t}\\n\\treturn int64(maxVal)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc max(a int, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\nfunc maximumOr(nums []int, k int) int64 {\\n\\tmultipler := math.Pow(float64(2), float64(k))\\n\\tmaxVal := 0\\n\\tpreFix := make([]int, len(nums))\\n\\tsufFix := make([]int, len(nums))\\n\\n\\tfor i := 1; i < len(preFix); i++ {\\n\\t\\tpreFix[i] = preFix[i-1] | nums[i-1]\\n\\t}\\n\\tfor i := len(sufFix) - 2; i >= 0; i-- {\\n\\t\\tsufFix[i] = sufFix[i+1] | nums[i+1]\\n\\t}\\n\\tfor i := 0; i < len(nums); i++ {\\n\\n\\t\\tmaxVal = max(maxVal, preFix[i]|nums[i]*int(multipler)|sufFix[i])\\n\\t}\\n\\treturn int64(maxVal)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3521059,
                "title": "prefix-suffix-step-by-step-explained-left-shift-single-element",
                "content": "# Intuition\\nWe have to left shift the elements with most significant bits \\nif we shift single element k times then the most significant bit will left shift by k bits.\\n\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nlets say we have elements below and k is 3\\n8 12 15 3\\n1000\\n1100\\n1111\\n0011\\n\\nWay to solve is shift the 3 elements (8, 12, 15) \\nIf we choose single element then most significant bit will be 4th + k ( k = 3)\\n\\nWe cant say which one of this will give the correct ans\\n  `   prefix[i] - ORs of elements 0,1,2 ... i,`\\n        `    suffix[i]  - ORs of elements i,i+1...n-1; `\\n\\nfor all nums with most significant bit present, do\\n   ` (nums[i] *  pow(2, k)) | pref[i-1] | suf[i+1] `\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int pow(int a, int b)\\n    {\\n        if(b==0)\\n            return 1;\\n        int x = pow(a,b/2);\\n\\n        if(b%2)\\n            return x*x*a;\\n        return x*x;\\n    }\\n\\n    long long maximumOr(vector<int>& nums, int k) {\\n        long long ans = 0 , cur = 0;\\n        int n = nums.size(), p = pow(2,k);\\n        sort(nums.begin(), nums.end());\\n\\n        int maxBits = ceil( log2(nums[n-1] + 1.0));\\n        //cout << maxBits << endl;\\n        vector<int> pref(n), suf(n);\\n\\n        pref[0] = nums[0]; suf[n-1] = nums[n-1]; \\n        for(int i=1; i<n; i++)\\n             pref[i] = pref[i-1] | nums[i];\\n        \\n        for(int i=n-2; i>=0; i--)\\n            suf[i] = suf[i+1] | nums[i];\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            int bits = ceil( log2(nums[i] + 1.0));\\n            cur = 0;\\n            if(bits == maxBits)\\n            {     \\n                if(i)\\n                    cur =  pref[i-1];\\n                if(i != n-1)\\n                    cur = cur | suf[i+1];\\n                cur = cur | (long long)nums[i] * p;\\n                ans = max(ans, cur);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Bit Manipulation",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int pow(int a, int b)\\n    {\\n        if(b==0)\\n            return 1;\\n        int x = pow(a,b/2);\\n\\n        if(b%2)\\n            return x*x*a;\\n        return x*x;\\n    }\\n\\n    long long maximumOr(vector<int>& nums, int k) {\\n        long long ans = 0 , cur = 0;\\n        int n = nums.size(), p = pow(2,k);\\n        sort(nums.begin(), nums.end());\\n\\n        int maxBits = ceil( log2(nums[n-1] + 1.0));\\n        //cout << maxBits << endl;\\n        vector<int> pref(n), suf(n);\\n\\n        pref[0] = nums[0]; suf[n-1] = nums[n-1]; \\n        for(int i=1; i<n; i++)\\n             pref[i] = pref[i-1] | nums[i];\\n        \\n        for(int i=n-2; i>=0; i--)\\n            suf[i] = suf[i+1] | nums[i];\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            int bits = ceil( log2(nums[i] + 1.0));\\n            cur = 0;\\n            if(bits == maxBits)\\n            {     \\n                if(i)\\n                    cur =  pref[i-1];\\n                if(i != n-1)\\n                    cur = cur | suf[i+1];\\n                cur = cur | (long long)nums[i] * p;\\n                ans = max(ans, cur);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3521050,
                "title": "python-3-give-k-to-single-number-needs-optimization",
                "content": "```\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        \\n        # max number is 10 ** 9 and k is 15, so array size is 30 + 15\\n        d = [0] * 45\\n        for num in nums:\\n            for i in range(30):\\n                if num & (1 << i): d[i] += 1\\n        \\n        \\n        # give all k ops to a single number\\n        ans = 0\\n        for num in set(nums):\\n            tmp_d = d[:]\\n            for i in range(30):\\n                if num & (1 << i): \\n                    tmp_d[i] -= 1\\n                    tmp_d[i+k] += 1      \\n\\t\\t\\t# calculate the OR result\\n            tmp = 0\\n            for i in range(45):\\n                if tmp_d[i] > 0:\\n                    tmp += 1 << i\\n            \\n            ans = max(ans, tmp)\\n        \\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        \\n        # max number is 10 ** 9 and k is 15, so array size is 30 + 15\\n        d = [0] * 45\\n        for num in nums:\\n            for i in range(30):\\n                if num & (1 << i): d[i] += 1\\n        \\n        \\n        # give all k ops to a single number\\n        ans = 0\\n        for num in set(nums):\\n            tmp_d = d[:]\\n            for i in range(30):\\n                if num & (1 << i): \\n                    tmp_d[i] -= 1\\n                    tmp_d[i+k] += 1      \\n\\t\\t\\t# calculate the OR result\\n            tmp = 0\\n            for i in range(45):\\n                if tmp_d[i] > 0:\\n                    tmp += 1 << i\\n            \\n            ans = max(ans, tmp)\\n        \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 3521049,
                "title": "prefix-suffix",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int index = 0;\\n        int n = nums.size();\\n        vector<long long> prefix(n+2,0) , suffix(n+2,0);\\n        for(int i=1;i<=n;i++) prefix[i] = prefix[i-1] | nums[i-1];\\n        for(int i=n;i>=1;i--) suffix[i] = suffix[i+1] | nums[i-1];\\n        long long maxi = 0;\\n        for(int i=1;i<=n;i++){\\n            long long num = nums[i-1];\\n            long long orr = prefix[i-1] | (num << k) | suffix[i+1];\\n            maxi = max(maxi,orr);\\n        }\\n        return maxi;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int index = 0;\\n        int n = nums.size();\\n        vector<long long> prefix(n+2,0) , suffix(n+2,0);\\n        for(int i=1;i<=n;i++) prefix[i] = prefix[i-1] | nums[i-1];\\n        for(int i=n;i>=1;i--) suffix[i] = suffix[i+1] | nums[i-1];\\n        long long maxi = 0;\\n        for(int i=1;i<=n;i++){\\n            long long num = nums[i-1];\\n            long long orr = prefix[i-1] | (num << k) | suffix[i+1];\\n            maxi = max(maxi,orr);\\n        }\\n        return maxi;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521032,
                "title": "bit-operation-solution-easy-to-understand-beats-100",
                "content": "# Intuition\\nTo obtain the max value, we should do `k` opeations on **only one element**.\\n\\nSo the question becomes **which element** we should choose to operate on, in order to obtain the max value.\\n\\nThink what if the question is not to obtain the max `OR` of all the element, but the max **sum** of all the element? We can sum up all the numbers, say `sum`; and then for each element `n`, calculate `sum - n + (n << k)`, choose the max one.\\n\\nBut what\\'s the inverse operation of `OR`? In this case, we need only to *un-OR* **only one** element, so we can **keep track of which bits appear only once, and which bits appear more than twice**; for each *un-OR* operation, **clear the bits which only appear once**.\\n\\n# Approach\\nAfter describing the *un-OR* operation, we can come up with the approach: calculate the `OR` of all the elements, say, `overall_or`; for each element `n`, calculate the value of (`overall_or` *un_OR* `n`) OR `n << k`, and return the maximum value. \\n\\n# Complexity\\n- Time complexity: $\\\\mathcal{O}(n)$, since we iterate over `nums` twice, once for `OR`, once for calculate the reqired value.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $\\\\mathcal{O}(1)$, since we only keep track of which bits appear more than once, and which appear more than twice.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntypedef long long ll;\\ntypedef pair<ll, ll> pll;\\n\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        // p.first is the overall_or\\n        // p.second is the bits which appear more than once\\n        pll p{0, 0};\\n        for (ll n: nums) {\\n            ll x = n & p.first; // those bits must appear more than onc\\n            p.first |= n; // overall_or\\n            p.second |= x; // bits appear more than once\\n        }\\n        ll result = 0;\\n        for (ll n: nums) {\\n            // (n & ~p.second) are bits that appear only once\\n            result = max(result, ((p.first & ~(n & ~p.second)) | (n << k)));\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\ntypedef long long ll;\\ntypedef pair<ll, ll> pll;\\n\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        // p.first is the overall_or\\n        // p.second is the bits which appear more than once\\n        pll p{0, 0};\\n        for (ll n: nums) {\\n            ll x = n & p.first; // those bits must appear more than onc\\n            p.first |= n; // overall_or\\n            p.second |= x; // bits appear more than once\\n        }\\n        ll result = 0;\\n        for (ll n: nums) {\\n            // (n & ~p.second) are bits that appear only once\\n            result = max(result, ((p.first & ~(n & ~p.second)) | (n << k)));\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521024,
                "title": "simple-with-remembering-repeated-bits-for-all-array-or",
                "content": "# Intuition & Approach\\nThe idea is to calculate the OR of all the values from `nums` in `total` and bits that are repeated more than once in `reps`. Then in each iteration over `nums`, we can calculate the OR for the array with 1 number edit. If the bit is set in `reps` then it should persist otherwise should be unset.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n * m)$$\\n\\n- Space complexity: $$O(m)$$\\n\\n- Where:\\n$$n$$ is length of the array,\\n$$m$$ is maximum size required to store all the bits, i.e. 64\\n\\n\\n# Code\\n```\\nlong long maximumOr(vector<int>& nums, int k) {\\n    long long res = numeric_limits<long long>::min();\\n    bitset<numeric_limits<long long>::digits> total, reps;\\n    for (int n : nums) {\\n        bitset<numeric_limits<int>::digits> bits(n);\\n        for (size_t i = 0; i < bits.size(); ++i) {\\n            if (bits[i] && total[i] && !reps[i]) reps[i] = true;\\n            if (bits[i] && !total[i]) total[i] = true;\\n        }\\n    }\\n    for (int n : nums) {\\n        bitset<numeric_limits<long long>::digits> n_bits(n);\\n        bitset<numeric_limits<long long>::digits> cur(total);\\n        for (size_t i = 0; i < n_bits.size(); ++i)\\n            if (n_bits[i] && !reps[i]) cur[i] = false;\\n        n_bits <<= k;\\n        cur |= n_bits;\\n        res = max(res, (long long)cur.to_ullong());\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nlong long maximumOr(vector<int>& nums, int k) {\\n    long long res = numeric_limits<long long>::min();\\n    bitset<numeric_limits<long long>::digits> total, reps;\\n    for (int n : nums) {\\n        bitset<numeric_limits<int>::digits> bits(n);\\n        for (size_t i = 0; i < bits.size(); ++i) {\\n            if (bits[i] && total[i] && !reps[i]) reps[i] = true;\\n            if (bits[i] && !total[i]) total[i] = true;\\n        }\\n    }\\n    for (int n : nums) {\\n        bitset<numeric_limits<long long>::digits> n_bits(n);\\n        bitset<numeric_limits<long long>::digits> cur(total);\\n        for (size_t i = 0; i < n_bits.size(); ++i)\\n            if (n_bits[i] && !reps[i]) cur[i] = false;\\n        n_bits <<= k;\\n        cur |= n_bits;\\n        res = max(res, (long long)cur.to_ullong());\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3521007,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        cur = 0\\n        saved = 0\\n        for num in nums:\\n            saved |= num & cur\\n            cur |= num\\n        \\n        max_num = 0\\n        \\n        for num in nums:\\n            max_num = max(max_num, saved | (cur & ~num) | num << k)\\n        return max_num\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        cur = 0\\n        saved = 0\\n        for num in nums:\\n            saved |= num & cur\\n            cur |= num\\n        \\n        max_num = 0\\n        \\n        for num in nums:\\n            max_num = max(max_num, saved | (cur & ~num) | num << k)\\n        return max_num\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520996,
                "title": "dynamic-programming-solution",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    private lateinit var dpCache: Array<LongArray>\\n    private lateinit var mem: LongArray\\n\\n    private fun doFind(nums: IntArray, index: Int, k: Int): Long {\\n        if(index >= nums.size) {\\n            return 0L\\n        }\\n        if(dpCache[index][k] != -1L) {\\n            return dpCache[index][k]\\n        }\\n        if(k == 0) {\\n            dpCache[index][k] = mem[index]\\n            return mem[index]\\n        }\\n        var r = 0L\\n        var m = 1L\\n        val ni = nums[index].toLong()\\n        for(i in 0 .. k) {\\n            val c = ni * m\\n            if(c < ni) {\\n                break\\n            }\\n            r = maxOf(r, (c or doFind(nums, index+1, k-i)))\\n            m *= 2L\\n        }\\n        dpCache[index][k] = r\\n        return r\\n    }\\n\\n    fun maximumOr(nums: IntArray, k: Int): Long {\\n        dpCache = Array<LongArray>(nums.size+1) { LongArray(k+1) { -1 }}\\n        mem = LongArray(nums.size) { 0 }\\n        for(i in nums.size-1 downTo 0) {\\n            mem[i] = nums[i].toLong() or (if(i+1 <= nums.size-1) mem[i+1] else 0L)\\n        }\\n        return doFind(nums, 0, k)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n\\n    private lateinit var dpCache: Array<LongArray>\\n    private lateinit var mem: LongArray\\n\\n    private fun doFind(nums: IntArray, index: Int, k: Int): Long {\\n        if(index >= nums.size) {\\n            return 0L\\n        }\\n        if(dpCache[index][k] != -1L) {\\n            return dpCache[index][k]\\n        }\\n        if(k == 0) {\\n            dpCache[index][k] = mem[index]\\n            return mem[index]\\n        }\\n        var r = 0L\\n        var m = 1L\\n        val ni = nums[index].toLong()\\n        for(i in 0 .. k) {\\n            val c = ni * m\\n            if(c < ni) {\\n                break\\n            }\\n            r = maxOf(r, (c or doFind(nums, index+1, k-i)))\\n            m *= 2L\\n        }\\n        dpCache[index][k] = r\\n        return r\\n    }\\n\\n    fun maximumOr(nums: IntArray, k: Int): Long {\\n        dpCache = Array<LongArray>(nums.size+1) { LongArray(k+1) { -1 }}\\n        mem = LongArray(nums.size) { 0 }\\n        for(i in nums.size-1 downTo 0) {\\n            mem[i] = nums[i].toLong() or (if(i+1 <= nums.size-1) mem[i+1] else 0L)\\n        }\\n        return doFind(nums, 0, k)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520986,
                "title": "adhoc-solution-o-n-easy-elegant-with-explanation",
                "content": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n\\t\\t// we have try each number to mutiply by 2 and with k times, because or operation is directly propotional to the biggest number , then we have to try each number to make it big..\\n        int n = nums.size();\\n        ll pre[n],suf[n];\\n        memset(pre,0,sizeof(pre));\\n        memset(suf,0,sizeof(suf));\\n        pre[0]=nums[0];\\n        for(int i=1;i<n;i++)\\n            pre[i] = pre[i-1] | nums[i];\\n        suf[n-1]=nums[n-1];\\n        for(int i=n-2;i>=0;i--)\\n            suf[i] = suf[i+1] | nums[i];\\n        \\n        ll ans=0;\\n        // consider for all the indexes;\\n        for(int i=0;i<n;i++){\\n            ll preOR = (i-1>=0?pre[i-1]:0);\\n            ll sufOR = (i+1<n?suf[i+1]:0);\\n            ll val = nums[i]*pow(2,k)*1LL;\\n            // cout<<preOR<<\" \"<<sufOR<<\" \"<<nums[i]*k<<\"\\\\n\";\\n            ans = max(ans,preOR | sufOR | val);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n\\t\\t// we have try each number to mutiply by 2 and with k times, because or operation is directly propotional to the biggest number , then we have to try each number to make it big..\\n        int n = nums.size();\\n        ll pre[n],suf[n];\\n        memset(pre,0,sizeof(pre));\\n        memset(suf,0,sizeof(suf));\\n        pre[0]=nums[0];\\n        for(int i=1;i<n;i++)\\n            pre[i] = pre[i-1] | nums[i];\\n        suf[n-1]=nums[n-1];\\n        for(int i=n-2;i>=0;i--)\\n            suf[i] = suf[i+1] | nums[i];\\n        \\n        ll ans=0;\\n        // consider for all the indexes;\\n        for(int i=0;i<n;i++){\\n            ll preOR = (i-1>=0?pre[i-1]:0);\\n            ll sufOR = (i+1<n?suf[i+1]:0);\\n            ll val = nums[i]*pow(2,k)*1LL;\\n            // cout<<preOR<<\" \"<<sufOR<<\" \"<<nums[i]*k<<\"\\\\n\";\\n            ans = max(ans,preOR | sufOR | val);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3520983,
                "title": "c-or-via-bit-count",
                "content": "- Only consider shift numbers with `hightest bit` set\\n- Implement `OR` by `bit counting`, to have O(1) time `OR`-ing all numbers with update on one number due to shift\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        long long bitmask[48] = {};\\n        for(int i = 0; i < 48; ++i) \\n            bitmask[i] = 1LL << i;\\n        \\n        vector<int> bitcount(48, 0);\\n        for(auto n : nums) {\\n            for(int i = 0; i < 32; ++i) \\n                if(n & bitmask[i])\\n                    bitcount[i]++;\\n        }\\n\\n        int highestbit = 1 << int(log2(*max_element(nums.begin(), nums.end())));\\n        long long ans = 0;\\n        for(int i = 0; i < nums.size(); ++i) {\\n            if(nums[i] & highestbit) {\\n                vector<int> bitcount2(bitcount);\\n                for(int j = 0; j < 32; ++j) {\\n                    if(nums[i] & bitmask[j]) {\\n                        bitcount2[j]--;\\n                        bitcount2[j+k]++;\\n                    }\\n                }\\n                long long cur = 0;\\n                for(int i = 0; i < 48; ++i)\\n                    if(bitcount2[i])\\n                        cur |= bitmask[i];\\n                \\n                ans = max(ans, cur);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        long long bitmask[48] = {};\\n        for(int i = 0; i < 48; ++i) \\n            bitmask[i] = 1LL << i;\\n        \\n        vector<int> bitcount(48, 0);\\n        for(auto n : nums) {\\n            for(int i = 0; i < 32; ++i) \\n                if(n & bitmask[i])\\n                    bitcount[i]++;\\n        }\\n\\n        int highestbit = 1 << int(log2(*max_element(nums.begin(), nums.end())));\\n        long long ans = 0;\\n        for(int i = 0; i < nums.size(); ++i) {\\n            if(nums[i] & highestbit) {\\n                vector<int> bitcount2(bitcount);\\n                for(int j = 0; j < 32; ++j) {\\n                    if(nums[i] & bitmask[j]) {\\n                        bitcount2[j]--;\\n                        bitcount2[j+k]++;\\n                    }\\n                }\\n                long long cur = 0;\\n                for(int i = 0; i < 48; ++i)\\n                    if(bitcount2[i])\\n                        cur |= bitmask[i];\\n                \\n                ans = max(ans, cur);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520970,
                "title": "solution-with-dynamic-programming-and-prefix-suffix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n   /* long long  find(vector<int>&arr, int k)\\n{\\n        int n=arr.size();\\n        \\n        \\n        \\n    long long preSum[n + 1], \\n        \\n        \\n        suffSum[n + 1];\\n    long long res;\\n        long long pow1=pow(2,k);\\n      \\n      preSum[0] = 0;\\n    for (int i = 0; i < n; i++)\\n        preSum[i + 1] = preSum[i] | arr[i];\\n \\n   \\n    suffSum[n] = 0;\\n    for (int i = n - 1; i >= 0; i--)\\n        suffSum[i] = suffSum[i + 1] | arr[i];\\n \\n    \\n    res = 0*1LL;\\n    for (int i = 0; i < n; i++)\\n        res = max(res, preSum[i] | (long long )(arr[i] * pow1) | suffSum[i + 1]);\\n \\n    return res;\\n} */\\nlong long int find(int i,vector<int>&nums,vector<vector<long long >>&dp,int k){\\n  if(i>=nums.size() )return 0;\\n  long long  ans=0;\\n  if(dp[i][k]!=-1)return dp[i][k];\\n  for(int ii=0;ii<=k;ii++){\\n    long long p=pow(2,ii);\\n     ans=max(ans,(nums[i]*p) |find(i+1,nums,dp,k-ii));\\n  }\\n  return dp[i][k]=ans;\\n}\\n    long long maximumOr(vector<int>& nums, int k) {\\n       int n =nums.size();\\n      vector<vector<long long >>dp(n+1,vector<long long >(k+1,-1));\\n      return find(0,nums,dp,k);\\n    }\\n};\\n```# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   /* long long  find(vector<int>&arr, int k)\\n{\\n        int n=arr.size();\\n        \\n        \\n        \\n    long long preSum[n + 1], \\n        \\n        \\n        suffSum[n + 1];\\n    long long res;\\n        long long pow1=pow(2,k);\\n      \\n      preSum[0] = 0;\\n    for (int i = 0; i < n; i++)\\n        preSum[i + 1] = preSum[i] | arr[i];\\n \\n   \\n    suffSum[n] = 0;\\n    for (int i = n - 1; i >= 0; i--)\\n        suffSum[i] = suffSum[i + 1] | arr[i];\\n \\n    \\n    res = 0*1LL;\\n    for (int i = 0; i < n; i++)\\n        res = max(res, preSum[i] | (long long )(arr[i] * pow1) | suffSum[i + 1]);\\n \\n    return res;\\n} */\\nlong long int find(int i,vector<int>&nums,vector<vector<long long >>&dp,int k){\\n  if(i>=nums.size() )return 0;\\n  long long  ans=0;\\n  if(dp[i][k]!=-1)return dp[i][k];\\n  for(int ii=0;ii<=k;ii++){\\n    long long p=pow(2,ii);\\n     ans=max(ans,(nums[i]*p) |find(i+1,nums,dp,k-ii));\\n  }\\n  return dp[i][k]=ans;\\n}\\n    long long maximumOr(vector<int>& nums, int k) {\\n       int n =nums.size();\\n      vector<vector<long long >>dp(n+1,vector<long long >(k+1,-1));\\n      return find(0,nums,dp,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   /* long long  find(vector<int>&arr, int k)\\n{\\n        int n=arr.size();\\n        \\n        \\n        \\n    long long preSum[n + 1], \\n        \\n        \\n        suffSum[n + 1];\\n    long long res;\\n        long long pow1=pow(2,k);\\n      \\n      preSum[0] = 0;\\n    for (int i = 0; i < n; i++)\\n        preSum[i + 1] = preSum[i] | arr[i];\\n \\n   \\n    suffSum[n] = 0;\\n    for (int i = n - 1; i >= 0; i--)\\n        suffSum[i] = suffSum[i + 1] | arr[i];\\n \\n    \\n    res = 0*1LL;\\n    for (int i = 0; i < n; i++)\\n        res = max(res, preSum[i] | (long long )(arr[i] * pow1) | suffSum[i + 1]);\\n \\n    return res;\\n} */\\nlong long int find(int i,vector<int>&nums,vector<vector<long long >>&dp,int k){\\n  if(i>=nums.size() )return 0;\\n  long long  ans=0;\\n  if(dp[i][k]!=-1)return dp[i][k];\\n  for(int ii=0;ii<=k;ii++){\\n    long long p=pow(2,ii);\\n     ans=max(ans,(nums[i]*p) |find(i+1,nums,dp,k-ii));\\n  }\\n  return dp[i][k]=ans;\\n}\\n    long long maximumOr(vector<int>& nums, int k) {\\n       int n =nums.size();\\n      vector<vector<long long >>dp(n+1,vector<long long >(k+1,-1));\\n      return find(0,nums,dp,k);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n   /* long long  find(vector<int>&arr, int k)\\n{\\n        int n=arr.size();\\n        \\n        \\n        \\n    long long preSum[n + 1], \\n        \\n        \\n        suffSum[n + 1];\\n    long long res;\\n        long long pow1=pow(2,k);\\n      \\n      preSum[0] = 0;\\n    for (int i = 0; i < n; i++)\\n        preSum[i + 1] = preSum[i] | arr[i];\\n \\n   \\n    suffSum[n] = 0;\\n    for (int i = n - 1; i >= 0; i--)\\n        suffSum[i] = suffSum[i + 1] | arr[i];\\n \\n    \\n    res = 0*1LL;\\n    for (int i = 0; i < n; i++)\\n        res = max(res, preSum[i] | (long long )(arr[i] * pow1) | suffSum[i + 1]);\\n \\n    return res;\\n} */\\nlong long int find(int i,vector<int>&nums,vector<vector<long long >>&dp,int k){\\n  if(i>=nums.size() )return 0;\\n  long long  ans=0;\\n  if(dp[i][k]!=-1)return dp[i][k];\\n  for(int ii=0;ii<=k;ii++){\\n    long long p=pow(2,ii);\\n     ans=max(ans,(nums[i]*p) |find(i+1,nums,dp,k-ii));\\n  }\\n  return dp[i][k]=ans;\\n}\\n    long long maximumOr(vector<int>& nums, int k) {\\n       int n =nums.size();\\n      vector<vector<long long >>dp(n+1,vector<long long >(k+1,-1));\\n      return find(0,nums,dp,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520960,
                "title": "python-prefix-suffix-sum",
                "content": "# Intuition\\n\\ntry DP but got TLE :(\\n```py\\nclass Solution:\\n    def maximumOr(self, nums: List[int], K: int) -> int:\\n        n = len(nums)\\n\\n        nums = [0] + nums\\n        dp = [[0]*(K+1) for _ in range(n+1)]\\n        \\n        res = 0\\n        for i in range(1, n+1):\\n            for k in range(K+1):\\n                for prevk in range(k+1):\\n                    dp[i][k] = max(dp[i][k], dp[i-1][prevk] | (nums[i]<<(k-prevk)))\\n                \\n        return dp[n][K]\\n```\\n\\nthe most important idea is that we don\\'t need to try all possible operation set.\\n\\nthe optimal way is using all the operations to **one** nums[i].\\nthen we just calculate every possible OR sum by doing `(nums[i]<<k) | nums[j]` where `0 <= j < n and j != i`. choose maximum as answer.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```py\\nclass Solution:\\n    def maximumOr(self, nums: List[int], K: int) -> int:\\n        n = len(nums)\\n\\n        prefix = [0] * (n+1)\\n        for i in range(1, n+1):\\n            prefix[i] = prefix[i-1] | nums[i-1]\\n        \\n        suffix = [0] * (n+1)\\n        for i in range(n-1, -1, -1):\\n            suffix[i] = suffix[i+1] | nums[i]\\n\\n        res = 0\\n        for i in range(n):\\n            curr = nums[i]<<K\\n            \\n            # for j in range(i):\\n            #     curr |= nums[j]\\n            curr |= prefix[i]\\n            \\n            # for j in range(i+1, n):\\n            #     curr |= nums[j]\\n            curr |= suffix[i+1]\\n\\n            res = max(res, curr)\\n        return res        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```py\\nclass Solution:\\n    def maximumOr(self, nums: List[int], K: int) -> int:\\n        n = len(nums)\\n\\n        nums = [0] + nums\\n        dp = [[0]*(K+1) for _ in range(n+1)]\\n        \\n        res = 0\\n        for i in range(1, n+1):\\n            for k in range(K+1):\\n                for prevk in range(k+1):\\n                    dp[i][k] = max(dp[i][k], dp[i-1][prevk] | (nums[i]<<(k-prevk)))\\n                \\n        return dp[n][K]\\n```\n```py\\nclass Solution:\\n    def maximumOr(self, nums: List[int], K: int) -> int:\\n        n = len(nums)\\n\\n        prefix = [0] * (n+1)\\n        for i in range(1, n+1):\\n            prefix[i] = prefix[i-1] | nums[i-1]\\n        \\n        suffix = [0] * (n+1)\\n        for i in range(n-1, -1, -1):\\n            suffix[i] = suffix[i+1] | nums[i]\\n\\n        res = 0\\n        for i in range(n):\\n            curr = nums[i]<<K\\n            \\n            # for j in range(i):\\n            #     curr |= nums[j]\\n            curr |= prefix[i]\\n            \\n            # for j in range(i+1, n):\\n            #     curr |= nums[j]\\n            curr |= suffix[i+1]\\n\\n            res = max(res, curr)\\n        return res        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520940,
                "title": "easy-c-solution",
                "content": "# Explanation(Dry Run) of code with example: \\nSuppose we have the following input:\\nnums = [3, 10, 5, 8]\\nk = 2\\n\\n**Step 1:**\\nInitialize ans = 0 and mul = 1.\\nInitialize pre = [0, 0, 0, 0] and suf = [0, 0, 0, 0].\\n\\n**Step 2:**\\nCalculate prefix OR values:\\npre[0] = nums[0] = 3\\npre[1] = pre[0] | nums[1] = 3 | 10 = 11\\npre[2] = pre[1] | nums[2] = 11 | 5 = 15\\npre[3] = pre[2] | nums[3] = 15 | 8 = 15\\nSo, pre = [3, 11, 15, 15].\\n\\nCalculate suffix OR values:\\nsuf[3] = nums[3] = 8\\nsuf[2] = suf[3] | nums[2] = 8 | 5 = 13\\nsuf[1] = suf[2] | nums[1] = 13 | 10 = 15\\nsuf[0] = suf[1] | nums[0] = 15 | 3 = 15\\nSo, suf = [15, 15, 13, 15].\\n\\n**Step 3:**\\nCalculate mul:\\nSince k = 2, we need to calculate 2^2 = 4.\\nSo, mul = 1 * 2 * 2 = 4.\\n\\n**Step 4:**\\nIterate over each element in the nums array:\\n\\nFor i = 0:\\nx = nums[0] * mul = 3 * 4 = 12.\\nSince i - 1 < 0, we skip the left-side OR operation.\\nx = x | suf[i + 1] = 12 | 15 = 15.\\nans = max(ans, x) = max(0, 15) = 15.\\n\\nFor i = 1:\\nx = nums[1] * mul = 10 * 4 = 40.\\nx = x | pre[i - 1] = 40 | pre[0] = 40 | 3 = 43.\\nx = x | suf[i + 1] = 43 | 13 = 47.\\nans = max(ans, x) = max(15, 47) = 47.\\n\\nFor i = 2:\\nx = nums[2] * mul = 5 * 4 = 20.\\nx = x | pre[i - 1] = 20 | pre[1] = 20 | 11 = 31.\\nx = x | suf[i + 1] = 31 | 15 = 31.\\nans = max(ans, x) = max(47, 31) = 47.\\n\\nFor i = 3:\\nx = nums[3] * mul = 8 * 4 = 32.\\nx = x | pre[i - 1] = 32 | pre[2] = 32 | 15 = 47.\\nSince i + 1 >= nums.size(), we skip the right-side OR operation.\\nans = max(ans, x) = max(47, 47) = 47.\\n\\n**Step 5:**\\nReturn ans = 47, which is the maximum OR value.\\nSo, the maximum OR value of\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n    long long ans = 0, mul = 1;\\n\\n    // Initialize two vectors to store the prefix and suffix OR values of the array elements\\n    vector<long long> pre(nums.size(), 0), suf(nums.size(), 0);\\n\\n    // Calculate prefix OR values\\n    pre[0] = nums[0];\\n    for (int i = 1; i < nums.size(); ++i) {\\n        pre[i] = pre[i - 1] | nums[i];\\n    }\\n\\n    // Calculate suffix OR values\\n    suf[nums.size() - 1] = nums.back();\\n    for (int i = nums.size() - 2; i >= 0; --i) {\\n        suf[i] = suf[i + 1] | nums[i];\\n    }\\n\\n    // Calculate the power of 2 (2^k)\\n    for (int i = 0; i < k; ++i) {\\n        mul *= 2;\\n    }\\n\\n    // Iterate over each element in the array\\n    for (int i = 0; i < nums.size(); ++i) {\\n        long long x = nums[i] * mul;\\n\\n        // Check if there is a valid element on the left side to consider in the OR operation\\n        if (i - 1 >= 0) {\\n            x = x | pre[i - 1];\\n        }\\n\\n        // Check if there is a valid element on the right side to consider in the OR operation\\n        if (i + 1 < nums.size()) {\\n            x = x | suf[i + 1];\\n        }\\n\\n        // Update the maximum value found so far\\n        ans = max(ans, x);\\n    }\\n\\n    return ans;\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n    long long ans = 0, mul = 1;\\n\\n    // Initialize two vectors to store the prefix and suffix OR values of the array elements\\n    vector<long long> pre(nums.size(), 0), suf(nums.size(), 0);\\n\\n    // Calculate prefix OR values\\n    pre[0] = nums[0];\\n    for (int i = 1; i < nums.size(); ++i) {\\n        pre[i] = pre[i - 1] | nums[i];\\n    }\\n\\n    // Calculate suffix OR values\\n    suf[nums.size() - 1] = nums.back();\\n    for (int i = nums.size() - 2; i >= 0; --i) {\\n        suf[i] = suf[i + 1] | nums[i];\\n    }\\n\\n    // Calculate the power of 2 (2^k)\\n    for (int i = 0; i < k; ++i) {\\n        mul *= 2;\\n    }\\n\\n    // Iterate over each element in the array\\n    for (int i = 0; i < nums.size(); ++i) {\\n        long long x = nums[i] * mul;\\n\\n        // Check if there is a valid element on the left side to consider in the OR operation\\n        if (i - 1 >= 0) {\\n            x = x | pre[i - 1];\\n        }\\n\\n        // Check if there is a valid element on the right side to consider in the OR operation\\n        if (i + 1 < nums.size()) {\\n            x = x | suf[i + 1];\\n        }\\n\\n        // Update the maximum value found so far\\n        ans = max(ans, x);\\n    }\\n\\n    return ans;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520894,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <limits.h>\\n\\nlong long maximumOr(int* nums, int numsSize, int k) {\\n    long long ans = 0, mul = 1;\\n    long long *pre = (long long*)malloc(numsSize * sizeof(long long));\\n    long long *suf = (long long*)malloc(numsSize * sizeof(long long));\\n    pre[0] = nums[0];\\n    suf[numsSize - 1] = nums[numsSize - 1];\\n    for (int i = 1; i < numsSize; ++i) {\\n        pre[i] = pre[i - 1] | nums[i];\\n        suf[numsSize - i - 1] = suf[numsSize - i] | nums[numsSize - i - 1];\\n    }\\n    for (int i = 0; i < k; ++i) {\\n        mul *= 2;\\n    }\\n    for (int i = 0; i < numsSize; ++i) {\\n        long long x = nums[i] * mul;\\n        if (i - 1 >= 0) x = x | pre[i - 1];\\n        if (i + 1 < numsSize) x = x | suf[i + 1];\\n        ans = ans > x ? ans : x;\\n    }\\n    free(pre);\\n    free(suf);\\n    return ans;\\n}\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <limits.h>\\n\\nlong long maximumOr(int* nums, int numsSize, int k) {\\n    long long ans = 0, mul = 1;\\n    long long *pre = (long long*)malloc(numsSize * sizeof(long long));\\n    long long *suf = (long long*)malloc(numsSize * sizeof(long long));\\n    pre[0] = nums[0];\\n    suf[numsSize - 1] = nums[numsSize - 1];\\n    for (int i = 1; i < numsSize; ++i) {\\n        pre[i] = pre[i - 1] | nums[i];\\n        suf[numsSize - i - 1] = suf[numsSize - i] | nums[numsSize - i - 1];\\n    }\\n    for (int i = 0; i < k; ++i) {\\n        mul *= 2;\\n    }\\n    for (int i = 0; i < numsSize; ++i) {\\n        long long x = nums[i] * mul;\\n        if (i - 1 >= 0) x = x | pre[i - 1];\\n        if (i + 1 < numsSize) x = x | suf[i + 1];\\n        ans = ans > x ? ans : x;\\n    }\\n    free(pre);\\n    free(suf);\\n    return ans;\\n}\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3520867,
                "title": "easy-c-both-ways",
                "content": "# Approach\\n- the trick is for each number we have k choices. if we select first choice then k-1 choices left for rest the elements\\n- and this way if suppose i = 2 then (k-2 and index+1) will give me the maximum \"or\" value\\n- and we just expolring all the possible ways and return the best. but we are doing this in a good manner (due to dynamic programing).\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n* k *k) = O(n) // becuase k max value will be 15 so we can say O(n) time.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n) for the dp array and if you use top down then O(n) extra space for call stack\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    long long maxResult(vector<int>&nums, int k, int index, vector<vector<long long>>&dp){\\n        if(index >= nums.size()) return 0;\\n        if(dp[index][k] != -1) return dp[index][k];\\n        long long ans = INT_MIN;\\n        for(int i = 0; i<=k; i++) ans = max(ans, (long long)nums[index]*(1<<i) | maxResult(nums, k-i, index+1, dp));\\n        \\n        return dp[index][k] = ans;\\n    \\n    }\\n\\n    long long solveTab(vector<int>&nums, int k){\\n      int n = nums.size();\\n      vector<vector<long long>>dp(n+1, vector<long long>(k+1, 0));\\n\\n      for(int i = n-1; i>-1; i--){\\n          for(int j = k; j>-1; j--){\\n            long long ans = INT_MIN;\\n            for(int l = 0; l<=j; l++)\\n              ans = max(ans, (long long)nums[i]*(1<<l) | dp[i+1][j-l]);\\n            dp[i][j] = ans;\\n          }\\n      }\\n\\n      return dp[0][k];\\n\\n    }\\n        \\n    long long maximumOr(vector<int>& nums, int k) {\\n        //int n = nums.size();\\n        //vector<vector<long long>>dp(n+1, vector<long long>(k+1, -1));\\n        //return maxResult(nums, k, 0, dp);\\n        return solveTab(nums, k);\\n    }\\n};\\n```\\n\\n# Please upvote and comment",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long maxResult(vector<int>&nums, int k, int index, vector<vector<long long>>&dp){\\n        if(index >= nums.size()) return 0;\\n        if(dp[index][k] != -1) return dp[index][k];\\n        long long ans = INT_MIN;\\n        for(int i = 0; i<=k; i++) ans = max(ans, (long long)nums[index]*(1<<i) | maxResult(nums, k-i, index+1, dp));\\n        \\n        return dp[index][k] = ans;\\n    \\n    }\\n\\n    long long solveTab(vector<int>&nums, int k){\\n      int n = nums.size();\\n      vector<vector<long long>>dp(n+1, vector<long long>(k+1, 0));\\n\\n      for(int i = n-1; i>-1; i--){\\n          for(int j = k; j>-1; j--){\\n            long long ans = INT_MIN;\\n            for(int l = 0; l<=j; l++)\\n              ans = max(ans, (long long)nums[i]*(1<<l) | dp[i+1][j-l]);\\n            dp[i][j] = ans;\\n          }\\n      }\\n\\n      return dp[0][k];\\n\\n    }\\n        \\n    long long maximumOr(vector<int>& nums, int k) {\\n        //int n = nums.size();\\n        //vector<vector<long long>>dp(n+1, vector<long long>(k+1, -1));\\n        //return maxResult(nums, k, 0, dp);\\n        return solveTab(nums, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520851,
                "title": "c-solution",
                "content": "# Code\\n```\\nlong long max(long long a,long long b){\\n    return a>b?a:b;\\n}\\nlong long maximumOr(int* nums, int numsSize, int k){\\n    long long *pre = calloc(numsSize+1,sizeof(long long));\\n    long long *suf =calloc(numsSize+1,sizeof(long long));\\n    for(int i=0;i<numsSize;i++) pre[i+1]=pre[i]|nums[i];\\n    // printf(\"ok\");\\n    for(int i=numsSize-1;i>=0;i--) suf[i]=suf[i+1]|nums[i];\\n    long long temp = 1<<k;\\n    long long res=0;\\n    \\n    for(int i=0;i<numsSize;i++){\\n        res=max(res,pre[i]|(temp*nums[i])|suf[i+1]);\\n    }\\n    free(suf);\\n    free(pre);\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nlong long max(long long a,long long b){\\n    return a>b?a:b;\\n}\\nlong long maximumOr(int* nums, int numsSize, int k){\\n    long long *pre = calloc(numsSize+1,sizeof(long long));\\n    long long *suf =calloc(numsSize+1,sizeof(long long));\\n    for(int i=0;i<numsSize;i++) pre[i+1]=pre[i]|nums[i];\\n    // printf(\"ok\");\\n    for(int i=numsSize-1;i>=0;i--) suf[i]=suf[i+1]|nums[i];\\n    long long temp = 1<<k;\\n    long long res=0;\\n    \\n    for(int i=0;i<numsSize;i++){\\n        res=max(res,pre[i]|(temp*nums[i])|suf[i+1]);\\n    }\\n    free(suf);\\n    free(pre);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3520850,
                "title": "easy-dp-solution-with-memoization",
                "content": "# Intuition\\nIntution is simple... Let\\'s try out every combination! We of course do this using a recursive approach and then apply memoization to it.\\n\\n# Approach\\nThere is only one part in the code that needs explanation, rest of code is self-explanatory. That part is :  \\n```\\n for (int ii = 0; ii <= k; ii++) {\\n        long long opt = ((long long)nums[i] << ii) | solve(i + 1, nums, k - ii);\\n        ans = max(ans, opt);\\n    }\\n```\\nHere we are traversing each index, then we try out every value of K for element at every index.\\n# Complexity\\nSince it has two states :\\n- Time complexity:\\n   O(n*k)\\n\\nThe dp table has dimensions of 100005 * 20 :\\n- Space complexity:\\n   O(n*k)\\n# Code\\n```\\nclass Solution {\\npublic:\\nlong long  dp[100005][20];\\n\\nlong long solve(int i, vector<int>& nums, int k) {\\n    if (i == nums.size()) {\\n        return 0;\\n    }\\n    if (dp[i][k] != -1) {\\n        return dp[i][k];\\n    }\\n\\n    long long ans = -1;\\n    for (int ii = 0; ii <= k; ii++) {\\n        long long opt = ((long long)nums[i] << ii) | solve(i + 1, nums, k - ii);\\n        ans = max(ans, opt);\\n    }\\n\\n    return dp[i][k] = ans;\\n}\\n\\nlong long maximumOr(vector<int>& nums, int k) {\\n    memset(dp, -1, sizeof(dp));\\n    return solve(0, nums, k);\\n}\\n\\n\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n for (int ii = 0; ii <= k; ii++) {\\n        long long opt = ((long long)nums[i] << ii) | solve(i + 1, nums, k - ii);\\n        ans = max(ans, opt);\\n    }\\n```\n```\\nclass Solution {\\npublic:\\nlong long  dp[100005][20];\\n\\nlong long solve(int i, vector<int>& nums, int k) {\\n    if (i == nums.size()) {\\n        return 0;\\n    }\\n    if (dp[i][k] != -1) {\\n        return dp[i][k];\\n    }\\n\\n    long long ans = -1;\\n    for (int ii = 0; ii <= k; ii++) {\\n        long long opt = ((long long)nums[i] << ii) | solve(i + 1, nums, k - ii);\\n        ans = max(ans, opt);\\n    }\\n\\n    return dp[i][k] = ans;\\n}\\n\\nlong long maximumOr(vector<int>& nums, int k) {\\n    memset(dp, -1, sizeof(dp));\\n    return solve(0, nums, k);\\n}\\n\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520808,
                "title": "c-kinda-greedy",
                "content": "After trying several examples i noticed that if you multiply say any of the element with 2, in order to get the maximum OR you will have to keep on multiplying the same element rest k-1 times because essentially you are shifting the most significant bit right.\\n\\nso for an element at index i we do (nums[i]*(1<<k)) and OR it with the left 0 --> i-1 element and right i+1 --> n-1 element\\n\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        long long s = 0, res = 0, t = 1<<k;\\n        int n = nums.size();\\n        vector<int> l = nums,r = nums;\\n        \\n        for(int i=1; i<n; ++i) l[i] |= l[i-1];\\n        for(int i=n-2; i>=0; --i) r[i] |= r[i+1];\\n        \\n        for(int i=0; i<nums.size(); ++i){\\n            int x = i+1 > n-1 ? 0 : r[i+1], y = i-1 < 0 ? 0 : l[i-1];\\n            res = max(res,(nums[i]*t | x | y));\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        long long s = 0, res = 0, t = 1<<k;\\n        int n = nums.size();\\n        vector<int> l = nums,r = nums;\\n        \\n        for(int i=1; i<n; ++i) l[i] |= l[i-1];\\n        for(int i=n-2; i>=0; --i) r[i] |= r[i+1];\\n        \\n        for(int i=0; i<nums.size(); ++i){\\n            int x = i+1 > n-1 ? 0 : r[i+1], y = i-1 < 0 ? 0 : l[i-1];\\n            res = max(res,(nums[i]*t | x | y));\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520806,
                "title": "100-fast-prefix-and-suffix-array-easy-to-understand",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        long long ans=1;\\n        if(nums.size()==1){\\n            while(k!=0){\\n                ans=ans*2;\\n                k--;\\n            }\\n            ans=ans*nums[0];\\n            return ans;\\n        }\\n           sort(nums.begin(),nums.end());\\n            vector<long long> pref;\\n            vector<long long> suff;\\n            pref.push_back(0);\\n            suff.push_back(0);\\n            long long in=0;\\n            for(int i=0;i<nums.size()-1;i++){\\n                in=in|nums[i];\\n                pref.push_back(in);\\n            }\\n            long long in1=0;\\n            for(int i=0;i<nums.size()-1;i++){\\n                in1=in1|nums[nums.size()-1-i];\\n                suff.push_back(in1);\\n            }\\n            long long answer=0;\\n            for(int i=0;i<nums.size();i++){\\n                long long a=nums[i];\\n                for(int i=0;i<k;i++){\\n                    a=a*2;\\n                }\\n                a=a|pref[i];\\n                a=a|suff[suff.size()-1-i];\\n                answer=max(answer,a);\\n            }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Suffix Array",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        long long ans=1;\\n        if(nums.size()==1){\\n            while(k!=0){\\n                ans=ans*2;\\n                k--;\\n            }\\n            ans=ans*nums[0];\\n            return ans;\\n        }\\n           sort(nums.begin(),nums.end());\\n            vector<long long> pref;\\n            vector<long long> suff;\\n            pref.push_back(0);\\n            suff.push_back(0);\\n            long long in=0;\\n            for(int i=0;i<nums.size()-1;i++){\\n                in=in|nums[i];\\n                pref.push_back(in);\\n            }\\n            long long in1=0;\\n            for(int i=0;i<nums.size()-1;i++){\\n                in1=in1|nums[nums.size()-1-i];\\n                suff.push_back(in1);\\n            }\\n            long long answer=0;\\n            for(int i=0;i<nums.size();i++){\\n                long long a=nums[i];\\n                for(int i=0;i<k;i++){\\n                    a=a*2;\\n                }\\n                a=a|pref[i];\\n                a=a|suff[suff.size()-1-i];\\n                answer=max(answer,a);\\n            }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520774,
                "title": "c-prefix-suffix-solution-and-dp-solution-on-bit",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    using ll = long long;\\n    ll dp[100002][17];\\n        ll binpow(ll m,unsigned long long n){\\n        if(n == 0)return 1;\\n        long long p = binpow(m,n/2);\\n        p = p*p;\\n        if(n%2 ==0)return p;\\n        return m*p;\\n    }\\n    ll f(int ind,int k,vector<int>&arr){\\n        if(ind == arr.size())return 0;\\n        \\n        if(dp[ind][k]!=-1)return dp[ind][k];\\n        \\n        ll ans = 0;\\n        for(int j=0;j<=k;j++){//i can do k operations\\n            ans = max(ans,(1LL*arr[ind]*binpow(2,j))|f(ind+1,k-j,arr));\\n            //apply simple dp......means multiply nums[ind] j times by 2 and cheek further the maximum or what i can get from here\\n        }\\n        return dp[ind][k] = ans;\\n    }\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        ll ans = 0;\\n        int n = nums.size();\\n        ll p = 1;\\n        for(int i=0;i<k;i++)p = p*2;\\n        vector<ll> pref(n+1);\\n        vector<ll> suff(n+1);\\n        pref[0] = 0;\\n        suff[n] = 0;\\n        for(int i=1;i<=n;i++){\\n            pref[i] = pref[i-1]|nums[i-1];\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            suff[i] = suff[i+1]|nums[i];\\n        }\\n        ans = (p*nums[0])|suff[1];\\n        for(int i=0;i<n;i++){\\n            ll k = (pref[i]|(p*nums[i])|suff[i+1]);\\n            ans = max(ans,k);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    using ll = long long;\\n    ll dp[100002][17];\\n        ll binpow(ll m,unsigned long long n){\\n        if(n == 0)return 1;\\n        long long p = binpow(m,n/2);\\n        p = p*p;\\n        if(n%2 ==0)return p;\\n        return m*p;\\n    }\\n    ll f(int ind,int k,vector<int>&arr){\\n        if(ind == arr.size())return 0;\\n        \\n        if(dp[ind][k]!=-1)return dp[ind][k];\\n        \\n        ll ans = 0;\\n        for(int j=0;j<=k;j++){//i can do k operations\\n            ans = max(ans,(1LL*arr[ind]*binpow(2,j))|f(ind+1,k-j,arr));\\n            //apply simple dp......means multiply nums[ind] j times by 2 and cheek further the maximum or what i can get from here\\n        }\\n        return dp[ind][k] = ans;\\n    }\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        ll ans = 0;\\n        int n = nums.size();\\n        ll p = 1;\\n        for(int i=0;i<k;i++)p = p*2;\\n        vector<ll> pref(n+1);\\n        vector<ll> suff(n+1);\\n        pref[0] = 0;\\n        suff[n] = 0;\\n        for(int i=1;i<=n;i++){\\n            pref[i] = pref[i-1]|nums[i-1];\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            suff[i] = suff[i+1]|nums[i];\\n        }\\n        ans = (p*nums[0])|suff[1];\\n        for(int i=0;i<n;i++){\\n            ll k = (pref[i]|(p*nums[i])|suff[i+1]);\\n            ans = max(ans,k);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520763,
                "title": "clean-c-solution-o-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n=nums.size();\\n       int m=*max_element(nums.begin(),nums.end());\\n        int b=log2(m);\\n       vector<long long> pr(n);\\n         vector<long long> pl(n);\\n        pl[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            pl[i]=pl[i-1]|nums[i];\\n        }\\n        pr[n-1]=nums[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            pr[i]=pr[i+1]|nums[i];\\n        }\\n        long long ans=INT_MIN;\\n        long long res;\\n        for(int i=0;i<n;i++ ){\\n            \\n            if((int)log2(nums[i])==b){\\n                \\n                res=nums[i]*pow(2,k);\\n                if(i>0)\\n                    res=res|pl[i-1];\\n                if(i<(n-1))\\n                    res=res|res|pr[i+1];\\n                \\n                ans=max(res,ans);\\n                \\n            }\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n=nums.size();\\n       int m=*max_element(nums.begin(),nums.end());\\n        int b=log2(m);\\n       vector<long long> pr(n);\\n         vector<long long> pl(n);\\n        pl[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            pl[i]=pl[i-1]|nums[i];\\n        }\\n        pr[n-1]=nums[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            pr[i]=pr[i+1]|nums[i];\\n        }\\n        long long ans=INT_MIN;\\n        long long res;\\n        for(int i=0;i<n;i++ ){\\n            \\n            if((int)log2(nums[i])==b){\\n                \\n                res=nums[i]*pow(2,k);\\n                if(i>0)\\n                    res=res|pl[i-1];\\n                if(i<(n-1))\\n                    res=res|res|pr[i+1];\\n                \\n                ans=max(res,ans);\\n                \\n            }\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520718,
                "title": "100-bit-solution-using-prefix-suffix-sum-with-step-by-step-explaination",
                "content": "# Intuition\\nThe given code finds the maximum bitwise OR value of a subarray of length k in the given array $$arr$$. \\n\\n# Approach\\n-  The approach is to divide the subarray into three parts: a prefix, a suffix, and a middle part. The prefix and suffix arrays are used to store the bitwise OR of elements from the start and end of the subarray respectively. The middle part is calculated by multiplying the element at each index by x^k and finding the bitwise OR of the resulting array.\\n-  The prefix sum array preSum and suffix sum array suffSum of length n+1. It then calculates the prefix sum by iterating over the array arr and storing the bitwise OR of the elements seen so far in the preSum array. Similarly, it calculates the suffix sum by iterating over the array arr in reverse order and storing the bitwise OR of the elements seen so far in the suffSum array.\\n```\\nres = Math.max(res, preSum[i] | (arr[i] * pow) | suffSum[i + 1]);\\n```\\n\\n- This line calculates the bitwise OR of three values: preSum[i], (arr[i] * pow), and suffSum[i + 1]. It then takes the maximum value of all such bitwise ORs, and stores it in the variable res.\\n\\n- To understand why these three values are being ORed, we need to understand how the maximum bitwise OR value is being computed. The given problem asks us to find the maximum possible value of (a[i] | a[j]) * 2^k for any two indices i and j in the input array arr.\\n\\n- To compute this value, we can divide it into three parts:\\n\\n- The bitwise OR of a[i] and a[j]\\nThe power of 2^k\\nMultiplying the above two values\\nWe can then compute the maximum possible value of this expression by considering all possible pairs of indices i and j. However, this approach would take O(n^2) time, which is too slow for large values of n.\\n\\n- Instead, we can use a prefix sum and suffix sum approach to compute the bitwise OR of a[i] with all the elements to the left of i, and all the elements to the right of i, respectively. This gives us the values of preSum[i] and suffSum[i+1], respectively.\\n\\n- We can then compute the maximum possible value of (a[i] | a[j]) * 2^k by considering all pairs of indices (i, j), where i is to the left of j. This is equivalent to computing the maximum value of (preSum[i] | (arr[j] * pow) | suffSum[j+1]), for all values of i and j.\\n\\n- Therefore, the given for loop computes the maximum possible value of (a[i] | a[j]) * 2^k for all possible pairs of indices i and j, and returns it as the final result.\\n\\n# Complexity\\n- Time complexity: **O[N]**\\nThe time complexity of the given code is O(n), where n is the length of the input array arr. This is because the code iterates over the array arr three times (once for prefix bitwise OR, once for suffix bitwise OR, and once to find the maximum OR value), which takes O(n) time each time.\\n\\n- Space complexity: **0[N]**\\nThe space complexity of the code is O(n), as it creates two arrays preSum[] and suffSum[] of length n+1 each, which store the prefix and suffix bitwise OR values respectively. In addition, it uses three variables x, n, and res which take constant space, and one variable pow which takes O(logk) space. However, since k is a constant value (i.e., 2), the space complexity can be simplified to O(n).\\n\\n# Code\\n```\\nclass Solution {\\n    public long maximumOr(int[] arr, int k) \\n    {\\n        //here x is given that always fixed\\n        int x = 2;\\n        int n = arr.length;\\n\\n        long preSum[] = new long[n + 1];\\n        long suffSum[] = new long[n + 1];\\n        long res = 0, pow = 1;\\n \\n        // Compute x^k\\n        for (int i = 0; i < k; i++)\\n            pow *= x;\\n \\n        // Find prefix bitwise OR\\n        preSum[0] = 0;\\n        for (int i = 0; i < n; i++)\\n            preSum[i + 1] = preSum[i] | arr[i];\\n \\n        // Find suffix bitwise OR\\n        suffSum[n] = 0;\\n        for (int i = n - 1; i >= 0; i--)\\n            suffSum[i] = suffSum[i + 1] | arr[i];\\n \\n        // Find maximum OR value\\n        res = 0;\\n        for (int i = 0; i < n; i++)\\n            res = Math.max(res, preSum[i] |\\n                (arr[i] * pow) | suffSum[i + 1]);\\n \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nres = Math.max(res, preSum[i] | (arr[i] * pow) | suffSum[i + 1]);\\n```\n```\\nclass Solution {\\n    public long maximumOr(int[] arr, int k) \\n    {\\n        //here x is given that always fixed\\n        int x = 2;\\n        int n = arr.length;\\n\\n        long preSum[] = new long[n + 1];\\n        long suffSum[] = new long[n + 1];\\n        long res = 0, pow = 1;\\n \\n        // Compute x^k\\n        for (int i = 0; i < k; i++)\\n            pow *= x;\\n \\n        // Find prefix bitwise OR\\n        preSum[0] = 0;\\n        for (int i = 0; i < n; i++)\\n            preSum[i + 1] = preSum[i] | arr[i];\\n \\n        // Find suffix bitwise OR\\n        suffSum[n] = 0;\\n        for (int i = n - 1; i >= 0; i--)\\n            suffSum[i] = suffSum[i + 1] | arr[i];\\n \\n        // Find maximum OR value\\n        res = 0;\\n        for (int i = 0; i < n; i++)\\n            res = Math.max(res, preSum[i] |\\n                (arr[i] * pow) | suffSum[i + 1]);\\n \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520699,
                "title": "optimization-suffix-prefix",
                "content": "\\r\\n# Code\\r\\n```\\r\\nclass Solution:\\r\\n    def maximumOr(self, A: List[int], k: int) -> int:\\r\\n        A.sort(reverse=True)\\r\\n        res, left, n = 0, 0, len(A)\\r\\n        right = [0] * n\\r\\n        for i in range(n - 2, -1, -1):\\r\\n            right[i] = right[i + 1] | A[i + 1]\\r\\n        a=len(bin(A[0]))\\r\\n        for i in range(n):\\r\\n            if a>len(bin(A[i])):\\r\\n                break\\r\\n            res = max(res, left | A[i] << k | right[i])\\r\\n            left |= A[i]\\r\\n        return res\\r\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\r\\nclass Solution:\\r\\n    def maximumOr(self, A: List[int], k: int) -> int:\\r\\n        A.sort(reverse=True)\\r\\n        res, left, n = 0, 0, len(A)\\r\\n        right = [0] * n\\r\\n        for i in range(n - 2, -1, -1):\\r\\n            right[i] = right[i + 1] | A[i + 1]\\r\\n        a=len(bin(A[0]))\\r\\n        for i in range(n):\\r\\n            if a>len(bin(A[i])):\\r\\n                break\\r\\n            res = max(res, left | A[i] << k | right[i])\\r\\n            left |= A[i]\\r\\n        return res\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520674,
                "title": "easy-cpp-using-prefix-and-suffix-brute-force",
                "content": "# Bruteforce Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Traverse all the nums and multiple every element k times and check for the maximum(ans). For this, consider prefix and suffix arrays which avoid recomputing OR for entire nums.\\nFor example,\\nnums = [8,1,2], k = 2\\nprefix = [8,9,11]\\nsuffix = [11,3,2]\\ni=0 : val = nums[0] multiple k times i.e,32\\nres = prefix[. . i] | val | suffix[i . .]\\nres at i=0: 32|suffix[1] i.e, OR of entire nums after updating nums[i] k times\\nSimilarly for i=1: res = prefix[0] |val| suffix[2]\\nSimilarly for i=2: res = prefix[1] | val\\nAnswer = max(res)**\\n\\n- **Time complexity: O(n*k)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        long long ans=0,n=nums.size();\\n        int a[n],b[n],i,x=0;\\n        for(i=n-1;i>=0;i--) {\\n            x|=nums[i]; a[i]=x; // SUFFIX\\n        }\\n        x=0;\\n        for(i=0;i<n;i++) {\\n            x|=nums[i]; b[i]=x; // PREFIX\\n        }\\n        for(i=0;i<n;i++) {\\n            long long res=0,p=nums[i],q=k;\\n            if(i>0) res|=b[i-1];\\n            while(q--) p*=2;\\n            res|=p;\\n            if(i<n-1) res|=a[i+1];\\n            ans=max(ans,res);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```\\nUpvote \\uD83D\\uDC4D\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        long long ans=0,n=nums.size();\\n        int a[n],b[n],i,x=0;\\n        for(i=n-1;i>=0;i--) {\\n            x|=nums[i]; a[i]=x; // SUFFIX\\n        }\\n        x=0;\\n        for(i=0;i<n;i++) {\\n            x|=nums[i]; b[i]=x; // PREFIX\\n        }\\n        for(i=0;i<n;i++) {\\n            long long res=0,p=nums[i],q=k;\\n            if(i>0) res|=b[i-1];\\n            while(q--) p*=2;\\n            res|=p;\\n            if(i<n-1) res|=a[i+1];\\n            ans=max(ans,res);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nUpvote \\uD83D\\uDC4D\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520646,
                "title": "easy-c-code-with-prefix-and-suffix-or",
                "content": "# Intuition\\nWe have to multiply by 2 to only one number k times. so we can multiply 2 (k times) for each number one by one, and then take OR of whole array and maximize answer.\\n\\n# Approach\\nWe have to multiply 2^k(multiply 2 k times) to each number one by one and maximize answer. for doing this brute force solution goes O(N^2). for O(N) time complexity we can use prefix and sufffix OR of the array, by doing this we can calculate OR of whole array where one changing element (i.e. the element we have multiplied by 2^k) in O(1) time complexity.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& num, int k) {\\n        vector<ll> nums;\\n        for(int i=0; i<num.size(); i++) nums.push_back(num[i]);\\n        long long ans=0;\\n        int n=nums.size();\\n        vector<ll> fronto=nums;\\n        vector<ll> backo=nums;\\n        for(int i=1; i<n; i++) fronto[i]|=fronto[i-1];\\n        for(int i=n-2; i>=0; i--) backo[i]|=backo[i+1];\\n        for(int i=0; i<n; i++){\\n            long long val=nums[i];\\n            val<<=k;\\n            ll cur=val;\\n            if(i>0) cur|=fronto[i-1];\\n            if(i<n-1) cur|=backo[i+1];\\n            ans=max(ans, cur);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& num, int k) {\\n        vector<ll> nums;\\n        for(int i=0; i<num.size(); i++) nums.push_back(num[i]);\\n        long long ans=0;\\n        int n=nums.size();\\n        vector<ll> fronto=nums;\\n        vector<ll> backo=nums;\\n        for(int i=1; i<n; i++) fronto[i]|=fronto[i-1];\\n        for(int i=n-2; i>=0; i--) backo[i]|=backo[i+1];\\n        for(int i=0; i<n; i++){\\n            long long val=nums[i];\\n            val<<=k;\\n            ll cur=val;\\n            if(i>0) cur|=fronto[i-1];\\n            if(i<n-1) cur|=backo[i+1];\\n            ans=max(ans, cur);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520630,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  long long maximumOr(const vector<int> &nums, const int k) {\\n    const int n = static_cast<int>(nums.size());\\n    int right[n + 1];\\n    right[n] = 0;\\n    for (int i = n - 1; i > -1; --i) {\\n      right[i] = right[i + 1] | nums[i];\\n    }\\n    \\n    long long ret = 0;\\n    int left = 0;\\n    for (int i = 0; i < n; ++i) {\\n      ret = max(ret, (left | (static_cast<long long>(nums[i]) << k) | right[i + 1]));\\n      left |= nums[i];\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  long long maximumOr(const vector<int> &nums, const int k) {\\n    const int n = static_cast<int>(nums.size());\\n    int right[n + 1];\\n    right[n] = 0;\\n    for (int i = n - 1; i > -1; --i) {\\n      right[i] = right[i + 1] | nums[i];\\n    }\\n    \\n    long long ret = 0;\\n    int left = 0;\\n    for (int i = 0; i < n; ++i) {\\n      ret = max(ret, (left | (static_cast<long long>(nums[i]) << k) | right[i + 1]));\\n      left |= nums[i];\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520596,
                "title": "c-easy-solution-using-prefix-suffix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust think of a solution in which we need to find the biggest element in which a biggest power of 2 so that it can be doulbed and will give the max result.\\nIf there is more than one element of max power of 2 then we need to calculate all having same power using prefix sum .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>&v, int k) {\\n        int n = v.size(),c,maxi = -1,ct=0;\\n        long long ans=0;\\n        \\n        sort(v.begin(),v.end(),greater<int>());\\n        vector<long long> dp1(n,0),dp2(n,0),ds(n,0);\\n        dp1[0] = v[0];\\n        dp2[n-1] = v[n-1];\\n        for(int i=1;i<n;++i)\\n        {\\n            dp1[i] = dp1[i-1] | v[i];\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            dp2[i] = dp2[i+1] | v[i];\\n        }\\n        \\n        for(int i=0;i<n;++i)\\n        {\\n            int p = v[i];\\n            if(v[i]!=1)\\n                c = log2(p);\\n            if(p==1)\\n                c=0;\\n            if(c==maxi)\\n            {\\n                ct++;\\n            }\\n            if(c>maxi)\\n            {\\n                maxi  =c;\\n                ct=1;\\n            }\\n        }\\n        // cout<<maxi<<\" \"<<ct<<endl;\\n        if(ct==1)\\n        {\\n            while(k--)\\n                v[0] = 2*v[0];\\n            for(int i=0;i<n;++i)\\n                ans = ans|v[i];\\n        }\\n        else\\n        {\\n            long long res = -1;\\n            for(int i=0;i<ct;++i)\\n            {\\n                long long int cd =v[i];\\n                int dc = k;\\n                // cout<<dc<<endl;\\n                while(dc>0)\\n                {\\n                    cd = cd*2;\\n                    dc--;\\n                }\\n                \\n                // cout<<cd<<endl;\\n                long long tk = cd,left =0,right=0;\\n               \\n                if(i>0)\\n                    left = dp1[i-1];\\n                if(i<n-1)\\n                    right = dp2[i+1];\\n                tk = tk | left | right;\\n                res = max(res,tk);    \\n                // cout<<left<<\" \"<<right<<\" \"<<res<<endl;\\n            }\\n            ans  = res;\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>&v, int k) {\\n        int n = v.size(),c,maxi = -1,ct=0;\\n        long long ans=0;\\n        \\n        sort(v.begin(),v.end(),greater<int>());\\n        vector<long long> dp1(n,0),dp2(n,0),ds(n,0);\\n        dp1[0] = v[0];\\n        dp2[n-1] = v[n-1];\\n        for(int i=1;i<n;++i)\\n        {\\n            dp1[i] = dp1[i-1] | v[i];\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            dp2[i] = dp2[i+1] | v[i];\\n        }\\n        \\n        for(int i=0;i<n;++i)\\n        {\\n            int p = v[i];\\n            if(v[i]!=1)\\n                c = log2(p);\\n            if(p==1)\\n                c=0;\\n            if(c==maxi)\\n            {\\n                ct++;\\n            }\\n            if(c>maxi)\\n            {\\n                maxi  =c;\\n                ct=1;\\n            }\\n        }\\n        // cout<<maxi<<\" \"<<ct<<endl;\\n        if(ct==1)\\n        {\\n            while(k--)\\n                v[0] = 2*v[0];\\n            for(int i=0;i<n;++i)\\n                ans = ans|v[i];\\n        }\\n        else\\n        {\\n            long long res = -1;\\n            for(int i=0;i<ct;++i)\\n            {\\n                long long int cd =v[i];\\n                int dc = k;\\n                // cout<<dc<<endl;\\n                while(dc>0)\\n                {\\n                    cd = cd*2;\\n                    dc--;\\n                }\\n                \\n                // cout<<cd<<endl;\\n                long long tk = cd,left =0,right=0;\\n               \\n                if(i>0)\\n                    left = dp1[i-1];\\n                if(i<n-1)\\n                    right = dp2[i+1];\\n                tk = tk | left | right;\\n                res = max(res,tk);    \\n                // cout<<left<<\" \"<<right<<\" \"<<res<<endl;\\n            }\\n            ans  = res;\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3520584,
                "title": "java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        int n=nums.length;\\n        \\n        long[] pre=new long[n+1];\\n        long[] suff=new long[n+1];\\n        \\n        long res=0,pow=1;\\n        \\n        for(int i=0;i<k;i++){\\n            pow*=2;\\n        }\\n        \\n        pre[0]=0;\\n        for(int i=0;i<n;i++){\\n            pre[i+1]=pre[i] | nums[i];\\n        }\\n        suff[n]=0;\\n        for(int i=n-1;i>=0;i--){\\n            suff[i]=suff[i+1] | nums[i];\\n        }\\n        res=0;\\n        for(int i=0;i<n;i++){\\n            res=Math.max(res,pre[i]|(nums[i]*pow|suff[i+1]));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        int n=nums.length;\\n        \\n        long[] pre=new long[n+1];\\n        long[] suff=new long[n+1];\\n        \\n        long res=0,pow=1;\\n        \\n        for(int i=0;i<k;i++){\\n            pow*=2;\\n        }\\n        \\n        pre[0]=0;\\n        for(int i=0;i<n;i++){\\n            pre[i+1]=pre[i] | nums[i];\\n        }\\n        suff[n]=0;\\n        for(int i=n-1;i>=0;i--){\\n            suff[i]=suff[i+1] | nums[i];\\n        }\\n        res=0;\\n        for(int i=0;i<n;i++){\\n            res=Math.max(res,pre[i]|(nums[i]*pow|suff[i+1]));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520581,
                "title": "prefix-and-suffix",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n0(n * k)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        long long ans = 0;\\n        int n = nums.size();\\n        vector<long long> pre(n,0);\\n        vector<long long> suf(n,0);\\n        pre[0] = nums[0];\\n        suf[n - 1] = nums[n - 1];\\n        for(int i = 1;i < n;++i)\\n        {\\n            pre[i] = pre[i - 1] | nums[i];\\n        }\\n        for(int i = n - 2;i >= 0;--i)\\n        {\\n            suf[i] = suf[i + 1] | nums[i];\\n        }\\n        for(int i = 1;i < n - 1;++i)\\n        {\\n            long long curr = nums[i];\\n            curr = curr << k;\\n            long long tempans = pre[i - 1] | curr | suf[i + 1];\\n            ans = max(ans,tempans);\\n        }\\n        long long first = nums[0];\\n        long long last = nums[n - 1];\\n        first = first << k;\\n        last = last << k;\\n        long long a1 = first;\\n        long long a2 = last;\\n        if(n > 1)\\n        {\\n            a1 = a1 | suf[1];\\n            a2 = a2 | pre[n - 2];\\n        }\\n        ans = max(ans,max(a1,a2));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        long long ans = 0;\\n        int n = nums.size();\\n        vector<long long> pre(n,0);\\n        vector<long long> suf(n,0);\\n        pre[0] = nums[0];\\n        suf[n - 1] = nums[n - 1];\\n        for(int i = 1;i < n;++i)\\n        {\\n            pre[i] = pre[i - 1] | nums[i];\\n        }\\n        for(int i = n - 2;i >= 0;--i)\\n        {\\n            suf[i] = suf[i + 1] | nums[i];\\n        }\\n        for(int i = 1;i < n - 1;++i)\\n        {\\n            long long curr = nums[i];\\n            curr = curr << k;\\n            long long tempans = pre[i - 1] | curr | suf[i + 1];\\n            ans = max(ans,tempans);\\n        }\\n        long long first = nums[0];\\n        long long last = nums[n - 1];\\n        first = first << k;\\n        last = last << k;\\n        long long a1 = first;\\n        long long a2 = last;\\n        if(n > 1)\\n        {\\n            a1 = a1 | suf[1];\\n            a2 = a2 | pre[n - 2];\\n        }\\n        ans = max(ans,max(a1,a2));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520573,
                "title": "prefix-or",
                "content": "I first solved this problem by trying to find the best number to double for each iteration of `k`.\\n\\nWrong Answer.\\n\\nThen I realize that you just need to pick one number and double it `k` times. \\n\\n**C++**\\n```cpp\\nlong long maximumOr(vector<int>& nums, int k) {\\n    vector<int> pref_or{0};\\n    partial_sum(begin(nums), end(nums), back_inserter(pref_or), bit_or<>());\\n    long long res = 0, suf_or = 0;\\n    for (int i = nums.size() - 1; i >= 0; suf_or |= nums[i--])\\n        res = max(res, pref_or[i] | ((long long)nums[i] << k) | suf_or);\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nlong long maximumOr(vector<int>& nums, int k) {\\n    vector<int> pref_or{0};\\n    partial_sum(begin(nums), end(nums), back_inserter(pref_or), bit_or<>());\\n    long long res = 0, suf_or = 0;\\n    for (int i = nums.size() - 1; i >= 0; suf_or |= nums[i--])\\n        res = max(res, pref_or[i] | ((long long)nums[i] << k) | suf_or);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3520552,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumOr(self, nums, k):\\n        n, max_val = len(nums), 0\\n\\n        prefix, suffix = [0]*n, [0]*n\\n\\n        prefix[0], suffix[n-1] = nums[0], nums[n-1]\\n\\n        for i in range(1,n):\\n            prefix[i] = nums[i]|prefix[i-1]\\n\\n        for i in range(n-2,-1,-1):\\n            suffix[i] = nums[i]|suffix[i+1]\\n\\n        for i in range(0,n):\\n            temp = (1<<k)*nums[i]\\n\\n            if i-1 >= 0:\\n                temp = temp|prefix[i-1]\\n\\n            if i+1 < n:\\n                temp = temp|suffix[i+1]\\n\\n            max_val = max(max_val,temp)\\n\\n        return max_val\\n\\n\\n\\n\\n        \\n\\n        \\n        \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumOr(self, nums, k):\\n        n, max_val = len(nums), 0\\n\\n        prefix, suffix = [0]*n, [0]*n\\n\\n        prefix[0], suffix[n-1] = nums[0], nums[n-1]\\n\\n        for i in range(1,n):\\n            prefix[i] = nums[i]|prefix[i-1]\\n\\n        for i in range(n-2,-1,-1):\\n            suffix[i] = nums[i]|suffix[i+1]\\n\\n        for i in range(0,n):\\n            temp = (1<<k)*nums[i]\\n\\n            if i-1 >= 0:\\n                temp = temp|prefix[i-1]\\n\\n            if i+1 < n:\\n                temp = temp|suffix[i+1]\\n\\n            max_val = max(max_val,temp)\\n\\n        return max_val\\n\\n\\n\\n\\n        \\n\\n        \\n        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520550,
                "title": "prefixsum-and-suffixsum-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        long long res = 0;\\n        int n = nums.size();\\n        vector<int> pre(n+1);\\n        vector<int> suf(n+1);\\n        pre[0] = nums[0];\\n        suf[n-1] = nums[n-1];\\n        for(int i=1; i<n; i++) {\\n            pre[i] = pre[i-1] | nums[i];\\n        }\\n        for(int i=n-2; i>=0; i--) {\\n            suf[i] = suf[i+1] | nums[i];\\n        }\\n        long long p = 1;\\n        p<<=k;\\n        for(int i=0; i<n; i++) {\\n            if(i==0) res = max(res,(nums[0]*p) | suf[1]);\\n            else if(i==n-1) res = max(res,(nums[n-1]*p) | pre[n-2]); \\n            else res = max(res, pre[i-1] | (nums[i] * p) | suf[i+1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        long long res = 0;\\n        int n = nums.size();\\n        vector<int> pre(n+1);\\n        vector<int> suf(n+1);\\n        pre[0] = nums[0];\\n        suf[n-1] = nums[n-1];\\n        for(int i=1; i<n; i++) {\\n            pre[i] = pre[i-1] | nums[i];\\n        }\\n        for(int i=n-2; i>=0; i--) {\\n            suf[i] = suf[i+1] | nums[i];\\n        }\\n        long long p = 1;\\n        p<<=k;\\n        for(int i=0; i<n; i++) {\\n            if(i==0) res = max(res,(nums[0]*p) | suf[1]);\\n            else if(i==n-1) res = max(res,(nums[n-1]*p) | pre[n-2]); \\n            else res = max(res, pre[i-1] | (nums[i] * p) | suf[i+1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520511,
                "title": "please-suggest-correction-in-this-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt passes all base test cases , but not accepted when submitted.\\nError : Time limite exceeded\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom functools import reduce\\nclass Solution(object):\\n    def maximumOr(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        op = []\\n        sub_nums =[]\\n        for i in range(len(nums)):\\n            a = nums[i]\\n            kk = nums[i]\\n            #print(a)\\n            #print(nums)\\n            for i in range(k):\\n                a *=2\\n            sub_nums = []\\n            for i in nums:\\n                sub_nums.append(i)\\n            if len(sub_nums)>0:\\n                sub_nums.remove(kk)\\n                sub_nums.append(a)\\n            bit_or = reduce(lambda x,y:x|y, sub_nums)\\n            #print(sub_nums)\\n            op.append(bit_or)\\n        if len(op)>0:\\n            return max(op)\\n        return -1\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom functools import reduce\\nclass Solution(object):\\n    def maximumOr(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        op = []\\n        sub_nums =[]\\n        for i in range(len(nums)):\\n            a = nums[i]\\n            kk = nums[i]\\n            #print(a)\\n            #print(nums)\\n            for i in range(k):\\n                a *=2\\n            sub_nums = []\\n            for i in nums:\\n                sub_nums.append(i)\\n            if len(sub_nums)>0:\\n                sub_nums.remove(kk)\\n                sub_nums.append(a)\\n            bit_or = reduce(lambda x,y:x|y, sub_nums)\\n            #print(sub_nums)\\n            op.append(bit_or)\\n        if len(op)>0:\\n            return max(op)\\n        return -1\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520487,
                "title": "c-memoization-dp",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long solveMemo(vector<int> &arr,int ind,int k, vector<vector<long long>> &dp){\\n        if(ind>=arr.size())\\n            return 0;\\n        if(dp[ind][k]!=-1)\\n            return dp[ind][k];\\n        long long ans = 0;\\n\\n        for(int i = 0; i<=k; i++){\\n            ans = max(ans,((1LL << i)*arr[ind])|(solveMemo(arr,ind+1,k-i, dp)));\\n        }\\n        \\n        return dp[ind][k] = ans;\\n    }\\n    \\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n+1, vector<long long>(k+1, -1));\\n        return solveMemo(nums, 0, k, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long solveMemo(vector<int> &arr,int ind,int k, vector<vector<long long>> &dp){\\n        if(ind>=arr.size())\\n            return 0;\\n        if(dp[ind][k]!=-1)\\n            return dp[ind][k];\\n        long long ans = 0;\\n\\n        for(int i = 0; i<=k; i++){\\n            ans = max(ans,((1LL << i)*arr[ind])|(solveMemo(arr,ind+1,k-i, dp)));\\n        }\\n        \\n        return dp[ind][k] = ans;\\n    }\\n    \\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n+1, vector<long long>(k+1, -1));\\n        return solveMemo(nums, 0, k, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520481,
                "title": "bitmanipulation-math-c",
                "content": "# Complexity\\n- Time complexity: O(32*N)\\n\\n- Space complexity: O(32*N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        long long ans=0;\\n        if(nums.size()==1){\\n            ans=nums[0];\\n            while(k--){\\n                ans*=2;\\n            }\\n            return ans;\\n        }\\n        long long sum=0;\\n        for(auto it:nums){\\n            sum=(sum|it);\\n        }\\n        int dp[nums.size()][32];\\n        memset(dp,0,sizeof(dp));\\n        for(int i=0; i<32; i++){\\n            for(int j=0; j<nums.size(); j++){\\n                if((nums[j]&(1<<i))){\\n                    if(j!=0)\\n                    dp[j][i]=1+dp[j-1][i];\\n                    else dp[j][i]=1;\\n                }\\n                else{\\n                    if(j!=0)\\n                    dp[j][i]=dp[j-1][i];\\n                }\\n            }\\n        }\\n        string t=\"\";\\n        while(sum>0){\\n            t+=char(sum%2+\\'0\\');\\n            sum/=2;\\n        }\\n        cout<<t<<\" \"; \\n        int n=nums.size()-1;\\n        for(int i=0; i<nums.size(); i++){\\n            string s=\"\";\\n            for(int j=0; j<32; j++){\\n                if(j>=t.length()) break;\\n                if(t[j]==\\'0\\'){\\n                    s+=t[j];\\n                }\\n                else{\\n                    if(!(nums[i]&(1<<j))) s+=t[j];\\n                    else{\\n                    if(dp[n][j]>1){\\n                        s+=\"1\";\\n                    }\\n                    else s+=\"0\";\\n                    }\\n                }\\n            }\\n            long long dks=1;\\n            cout<<s<<\" \";\\n            long long ans1=0;\\n            for(int j=0; j<s.length(); j++){\\n                ans1+=dks*(s[j]-\\'0\\');\\n                dks*=2;\\n            }\\n            int k1=k;\\n            long long j=nums[i];\\n            while(k1--){\\n                j*=2;\\n            }\\n            ans1=(ans1|j);\\n            ans=max(ans,ans1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        long long ans=0;\\n        if(nums.size()==1){\\n            ans=nums[0];\\n            while(k--){\\n                ans*=2;\\n            }\\n            return ans;\\n        }\\n        long long sum=0;\\n        for(auto it:nums){\\n            sum=(sum|it);\\n        }\\n        int dp[nums.size()][32];\\n        memset(dp,0,sizeof(dp));\\n        for(int i=0; i<32; i++){\\n            for(int j=0; j<nums.size(); j++){\\n                if((nums[j]&(1<<i))){\\n                    if(j!=0)\\n                    dp[j][i]=1+dp[j-1][i];\\n                    else dp[j][i]=1;\\n                }\\n                else{\\n                    if(j!=0)\\n                    dp[j][i]=dp[j-1][i];\\n                }\\n            }\\n        }\\n        string t=\"\";\\n        while(sum>0){\\n            t+=char(sum%2+\\'0\\');\\n            sum/=2;\\n        }\\n        cout<<t<<\" \"; \\n        int n=nums.size()-1;\\n        for(int i=0; i<nums.size(); i++){\\n            string s=\"\";\\n            for(int j=0; j<32; j++){\\n                if(j>=t.length()) break;\\n                if(t[j]==\\'0\\'){\\n                    s+=t[j];\\n                }\\n                else{\\n                    if(!(nums[i]&(1<<j))) s+=t[j];\\n                    else{\\n                    if(dp[n][j]>1){\\n                        s+=\"1\";\\n                    }\\n                    else s+=\"0\";\\n                    }\\n                }\\n            }\\n            long long dks=1;\\n            cout<<s<<\" \";\\n            long long ans1=0;\\n            for(int j=0; j<s.length(); j++){\\n                ans1+=dks*(s[j]-\\'0\\');\\n                dks*=2;\\n            }\\n            int k1=k;\\n            long long j=nums[i];\\n            while(k1--){\\n                j*=2;\\n            }\\n            ans1=(ans1|j);\\n            ans=max(ans,ans1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3520466,
                "title": "easy-solution-no-arrays-only-bitwise-operations",
                "content": "# Intuition\\nJust build two ints - one with all numbers OR\\'ed, another only with those bits set which are found at least in two input numbers. Then, for every number we can unset it\\'s bits from `or` and add all bits set in `dbl_or` (only bits in 2+ number from input) to quickly get result or OR\\'ing of all the other number.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1) additional space\\n\\n# Code\\n```\\n// pub struct Solution;\\n\\nimpl Solution {\\n    pub fn maximum_or(nums: Vec<i32>, k: i32) -> i64 {\\n        let mut or = 0;\\n        let mut dbl_or = 0;\\n\\n        for num in &nums {\\n            dbl_or |= (*num & or);\\n            or |= *num;\\n        }\\n\\n        let mut best = 0;\\n        for num in nums {\\n            best = best.max(\\n                (or & !num | dbl_or) as i64 \\n                    | ((num as i64) << k as usize)\\n            );\\n        }\\n\\n        best\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n// pub struct Solution;\\n\\nimpl Solution {\\n    pub fn maximum_or(nums: Vec<i32>, k: i32) -> i64 {\\n        let mut or = 0;\\n        let mut dbl_or = 0;\\n\\n        for num in &nums {\\n            dbl_or |= (*num & or);\\n            or |= *num;\\n        }\\n\\n        let mut best = 0;\\n        for num in nums {\\n            best = best.max(\\n                (or & !num | dbl_or) as i64 \\n                    | ((num as i64) << k as usize)\\n            );\\n        }\\n\\n        best\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3520464,
                "title": "prefix-or",
                "content": "# Intuition\\nYou either multiply a given number by $2^k$ or you don\\'t touch it.\\n\\n# Approach\\nCompute prefix and suffix or of the array. The idea is that $\\\\text{prefix}[i]$ is equal to $\\\\text{nums}[0] \\\\lor \\\\text{nums}[1] \\\\lor \\\\dots \\\\lor \\\\text{nums}[i]$. You get the idea for the suffix array.\\n\\nThen, iterate over all the numbers, the candidate solution for this index is given by:\\n$$\\\\text{prefix}[i-1] \\\\lor (2^k * \\\\text{nums}[i]) \\\\lor \\\\text{suffix}[i+1]$$\\n\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n\\n- Space complexity: $O(n)$\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n\\n        def prefix_or(nums):\\n            prefix = [nums[0]]\\n            for e in nums[1:]:\\n                val = prefix[-1] | e\\n                prefix.append(val)\\n            return prefix\\n        \\n        prefix = prefix_or(nums)\\n        suffix = prefix_or(nums[::-1])[::-1]\\n\\n        multiplier = 1 << k\\n\\n        def f(i):\\n            v = nums[i] * multiplier\\n            p = 0 if i == 0 else prefix[i - 1]\\n            s = 0 if i == len(nums) - 1 else suffix[i + 1]\\n            return v | p | s\\n\\n        ans = 0\\n        for i in range(len(nums)):\\n            ans = max(ans, f(i))\\n\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n\\n        def prefix_or(nums):\\n            prefix = [nums[0]]\\n            for e in nums[1:]:\\n                val = prefix[-1] | e\\n                prefix.append(val)\\n            return prefix\\n        \\n        prefix = prefix_or(nums)\\n        suffix = prefix_or(nums[::-1])[::-1]\\n\\n        multiplier = 1 << k\\n\\n        def f(i):\\n            v = nums[i] * multiplier\\n            p = 0 if i == 0 else prefix[i - 1]\\n            s = 0 if i == len(nums) - 1 else suffix[i + 1]\\n            return v | p | s\\n\\n        ans = 0\\n        for i in range(len(nums)):\\n            ans = max(ans, f(i))\\n\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520443,
                "title": "direct-computation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is convex. It is always best to apply the operation (multiply one value on the list by 2) to just one value the maximum allowed number of times, that is k times.\\n\\nThe problem is determining which value. The first example in the statement of the problem shows that it does not have to be the largest value.\\n\\nSince the number of items is at most $10^5$, it is enough to compute the potential answer in constant time for each.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere are at most around 30 bits to consider, since $10^9 \\\\sim 2^{30}$. For each bit, we record the total number of times it appears in some number on the list.\\nTo compute the OR of all the numbers on the list except $nums_i$, we consider the total number of times each bit appears (which we only need to compute once), minus the number of times that bit appears in $nums_i$ (which can be 0 or 1). If after the subtraction it\\'s still there, then it should appear in the OR.\\nThen we take the OR with $nums_i\\\\cdot 2^k = nums_i<<k$. This is the candidate answer for $nums_i$. We compare all possibilities and select the largest.\\n\\nOf course, this solution can be further optimized: for example, if a bit appears at least twice, then we don\\'t need to perform the subtraction described above, because we know it\\'ll still be there anyway.\\n\\n# Complexity\\n- Time complexity: $O(n)$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        array=[0]*32\\n        lists=[]\\n        for n in nums:\\n            lst=[]\\n            while n:\\n                lst.append(n&1)\\n                n>>=1\\n            for i, l in enumerate(lst):\\n                array[i]+=l\\n            lists.append(lst)\\n        ans=0\\n        for i, n in enumerate(nums):\\n            array2=array.copy()\\n            for j, l in enumerate(lists[i]):\\n                array2[j]-=l\\n            s=0\\n            p=1\\n            for a in array2:\\n                s|=p if a!=0 else 0\\n                p<<=1\\n            s|=n<<k\\n            if s>ans:\\n                ans=s\\n        return ans      \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        array=[0]*32\\n        lists=[]\\n        for n in nums:\\n            lst=[]\\n            while n:\\n                lst.append(n&1)\\n                n>>=1\\n            for i, l in enumerate(lst):\\n                array[i]+=l\\n            lists.append(lst)\\n        ans=0\\n        for i, n in enumerate(nums):\\n            array2=array.copy()\\n            for j, l in enumerate(lists[i]):\\n                array2[j]-=l\\n            s=0\\n            p=1\\n            for a in array2:\\n                s|=p if a!=0 else 0\\n                p<<=1\\n            s|=n<<k\\n            if s>ans:\\n                ans=s\\n        return ans      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520439,
                "title": "c-prefix-and-suffix-or-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<long long>prefsum(n+1),suffsum(n+1);\\n        long long pow=1,res=0;\\n        prefsum[0]=0;\\n        suffsum[n]=0;\\n        for(int i=0;i<k;i++){\\n            pow*=2;\\n        }\\n        for(int i=0;i<n;i++){\\n            prefsum[i+1]=prefsum[i]|nums[i];\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            suffsum[i]=suffsum[i+1]|nums[i];\\n        }\\n        for(int i=0;i<n;i++){\\n            res=max(res,prefsum[i]|(nums[i]*pow)|suffsum[i+1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<long long>prefsum(n+1),suffsum(n+1);\\n        long long pow=1,res=0;\\n        prefsum[0]=0;\\n        suffsum[n]=0;\\n        for(int i=0;i<k;i++){\\n            pow*=2;\\n        }\\n        for(int i=0;i<n;i++){\\n            prefsum[i+1]=prefsum[i]|nums[i];\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            suffsum[i]=suffsum[i+1]|nums[i];\\n        }\\n        for(int i=0;i<n;i++){\\n            res=max(res,prefsum[i]|(nums[i]*pow)|suffsum[i+1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520435,
                "title": "c",
                "content": "```\\nusing LL = long long ;\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size() ;\\n        sort(nums.begin(), nums.end()) ;\\n        reverse(nums.begin(), nums.end()) ;\\n        LL ans = 0 ;\\n        for(int i = 0; i < n; i++){\\n            LL ret = ((LL)nums[i] << k) ;\\n            for(int j = 0; j < n; j++){\\n                if(j == i)\\n                    continue ;\\n                ret |= nums[j] ;\\n            }\\n            if(ans > ret)\\n                break ;\\n            ans = max(ans, ret) ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nusing LL = long long ;\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size() ;\\n        sort(nums.begin(), nums.end()) ;\\n        reverse(nums.begin(), nums.end()) ;\\n        LL ans = 0 ;\\n        for(int i = 0; i < n; i++){\\n            LL ret = ((LL)nums[i] << k) ;\\n            for(int j = 0; j < n; j++){\\n                if(j == i)\\n                    continue ;\\n                ret |= nums[j] ;\\n            }\\n            if(ans > ret)\\n                break ;\\n            ans = max(ans, ret) ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520421,
                "title": "python-greedy-shift-k-operations-for-one-element",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        left = [nums[0]] * len(nums)\\n        for i in range(1, len(nums)):\\n            left[i] = left[i - 1] | nums[i]\\n            \\n        right = [nums[-1]] * len(nums)\\n        for i in range(len(nums) - 2, -1, -1):\\n            right[i] = right[i + 1] | nums[i]\\n            \\n        ans = 0\\n        for i in range(len(nums)):\\n            l = 0 if i == 0 else left[i - 1]\\n            r = 0 if i == len(nums) - 1 else right[i + 1]\\n            ans = max(ans, l | (nums[i] << k) | r)\\n            \\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumOr(self, nums: List[int], k: int) -> int:\\n        left = [nums[0]] * len(nums)\\n        for i in range(1, len(nums)):\\n            left[i] = left[i - 1] | nums[i]\\n            \\n        right = [nums[-1]] * len(nums)\\n        for i in range(len(nums) - 2, -1, -1):\\n            right[i] = right[i + 1] | nums[i]\\n            \\n        ans = 0\\n        for i in range(len(nums)):\\n            l = 0 if i == 0 else left[i - 1]\\n            r = 0 if i == len(nums) - 1 else right[i + 1]\\n            ans = max(ans, l | (nums[i] << k) | r)\\n            \\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520377,
                "title": "simple-dp-memoization",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nj represent the number of time the operation is performed at a[i]\\nRest is easy to self explanatory.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long f(int i, int k, vector<int>& nums,vector<vector<long long>>&dp)\\n    {\\n        if(i==-1) return 0;\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        long long ans = 0;\\n        for(int j=0;j<=k;j++)\\n            ans = max(ans,(1ll*nums[i]<<j) | 1ll*f(i-1,k-j,nums,dp));\\n        return dp[i][k] = ans;\\n    }\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n,vector<long long>(k+1,-1));\\n       return f(n-1,k,nums,dp);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long f(int i, int k, vector<int>& nums,vector<vector<long long>>&dp)\\n    {\\n        if(i==-1) return 0;\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        long long ans = 0;\\n        for(int j=0;j<=k;j++)\\n            ans = max(ans,(1ll*nums[i]<<j) | 1ll*f(i-1,k-j,nums,dp));\\n        return dp[i][k] = ans;\\n    }\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n,vector<long long>(k+1,-1));\\n       return f(n-1,k,nums,dp);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520376,
                "title": "huh-this-is-some-killer-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        int[] arr = new int[65];\\n        \\n        for(int num : nums){\\n            String bin = Integer.toBinaryString(num);\\n            int j = 0;\\n            for(int i=bin.length()-1;i>=0;i--){\\n                arr[j++] += (bin.charAt(i)-\\'0\\');\\n            }\\n        }\\n        \\n        long max = 0;\\n        for(long num : nums){\\n            String bin = Long.toBinaryString(num);\\n            int j = 0;\\n            for(int i=bin.length()-1;i>=0;i--){\\n                arr[j++] -= (bin.charAt(i)-\\'0\\');\\n            }\\n            long temp = num<<k;\\n\\n            String bin2 = Long.toBinaryString(temp);\\n            j=0;\\n            for(int i=bin2.length()-1;i>=0;i--){\\n                arr[j++] += (bin2.charAt(i)-\\'0\\');\\n            }\\n\\n            max = Math.max(max, helper(arr));\\n            \\n            j=0;\\n            for(int i=bin2.length()-1;i>=0;i--){\\n                arr[j++] -= (bin2.charAt(i)-\\'0\\');\\n            }\\n            j=0;\\n            for(int i=bin.length()-1;i>=0;i--){\\n            arr[j++] += (bin.charAt(i)-\\'0\\');\\n            }\\n        }\\n        \\n        return max; \\n        \\n    }\\n    \\n    private long helper(int[] arr){\\n        long n = 1;\\n        long num = 0;\\n        for(int ele : arr) {\\n            if (ele>0) num += n;\\n            n *= 2;\\n        }\\n        \\n        return num;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        int[] arr = new int[65];\\n        \\n        for(int num : nums){\\n            String bin = Integer.toBinaryString(num);\\n            int j = 0;\\n            for(int i=bin.length()-1;i>=0;i--){\\n                arr[j++] += (bin.charAt(i)-\\'0\\');\\n            }\\n        }\\n        \\n        long max = 0;\\n        for(long num : nums){\\n            String bin = Long.toBinaryString(num);\\n            int j = 0;\\n            for(int i=bin.length()-1;i>=0;i--){\\n                arr[j++] -= (bin.charAt(i)-\\'0\\');\\n            }\\n            long temp = num<<k;\\n\\n            String bin2 = Long.toBinaryString(temp);\\n            j=0;\\n            for(int i=bin2.length()-1;i>=0;i--){\\n                arr[j++] += (bin2.charAt(i)-\\'0\\');\\n            }\\n\\n            max = Math.max(max, helper(arr));\\n            \\n            j=0;\\n            for(int i=bin2.length()-1;i>=0;i--){\\n                arr[j++] -= (bin2.charAt(i)-\\'0\\');\\n            }\\n            j=0;\\n            for(int i=bin.length()-1;i>=0;i--){\\n            arr[j++] += (bin.charAt(i)-\\'0\\');\\n            }\\n        }\\n        \\n        return max; \\n        \\n    }\\n    \\n    private long helper(int[] arr){\\n        long n = 1;\\n        long num = 0;\\n        for(int ele : arr) {\\n            if (ele>0) num += n;\\n            n *= 2;\\n        }\\n        \\n        return num;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520351,
                "title": "c-easy-solution-prefix-concept",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\t// int mod=1e9+7;\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<long long> left(n);\\n        vector<long long> right(n);\\n        left[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n        \\tleft[i]= (left[i-1]|nums[i]);\\n        }\\n        right[n-1]=nums.back();\\n        for(int i=n-2;i>=0;i--){\\n        \\tright[i]= (right[i+1]|nums[i]);\\n        }\\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n        \\tlong long no = nums[i];\\n        \\tfor(int j=0;j<k;j++) {\\n        \\t\\tno = (no*2);\\n        \\t}\\n        \\tlong long l=0 , r=0;\\n        \\tif(i-1>=0) l=left[i-1];\\n        \\tif(i+1<n) r=right[i+1];\\n        \\tlong long temp = (no|l);\\n        \\ttemp = (temp|r);\\n        \\tans= max(ans , temp);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\t// int mod=1e9+7;\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<long long> left(n);\\n        vector<long long> right(n);\\n        left[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n        \\tleft[i]= (left[i-1]|nums[i]);\\n        }\\n        right[n-1]=nums.back();\\n        for(int i=n-2;i>=0;i--){\\n        \\tright[i]= (right[i+1]|nums[i]);\\n        }\\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n        \\tlong long no = nums[i];\\n        \\tfor(int j=0;j<k;j++) {\\n        \\t\\tno = (no*2);\\n        \\t}\\n        \\tlong long l=0 , r=0;\\n        \\tif(i-1>=0) l=left[i-1];\\n        \\tif(i+1<n) r=right[i+1];\\n        \\tlong long temp = (no|l);\\n        \\ttemp = (temp|r);\\n        \\tans= max(ans , temp);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520349,
                "title": "java-easy-understanding",
                "content": "```\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        int n = nums.length;\\n        int pfL[] = new int[n];\\n        int pfR[] = new int[n];\\n        for(int i=0,j=n-1; i<n ; i++,j--){\\n            if(i==0){\\n                pfL[i] = 0;\\n                pfR[j] = 0;\\n            }\\n            else{\\n                pfL[i] = pfL[i-1] | nums[i-1];\\n                pfR[j] = pfR[j+1] | nums[j+1];\\n            }\\n        }\\n        long max = Integer.MIN_VALUE;\\n        for(int i=0 ; i<n ; i++){\\n            long temp = calc(nums[i],k);\\n            long res = 0;\\n            if(i==0){\\n                res = temp | pfR[i];\\n            }\\n            else if(i==n-1){\\n                res = temp | pfL[i];\\n            }\\n            else{\\n                res = pfL[i] | temp | pfR[i];\\n            }\\n            max = Math.max(max,res);\\n        }\\n        return max;\\n    }\\n    \\n    public long calc(int num, int k){\\n        long ans = num;\\n        for(int i=0 ; i<k ; i++){\\n            ans *= 2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        int n = nums.length;\\n        int pfL[] = new int[n];\\n        int pfR[] = new int[n];\\n        for(int i=0,j=n-1; i<n ; i++,j--){\\n            if(i==0){\\n                pfL[i] = 0;\\n                pfR[j] = 0;\\n            }\\n            else{\\n                pfL[i] = pfL[i-1] | nums[i-1];\\n                pfR[j] = pfR[j+1] | nums[j+1];\\n            }\\n        }\\n        long max = Integer.MIN_VALUE;\\n        for(int i=0 ; i<n ; i++){\\n            long temp = calc(nums[i],k);\\n            long res = 0;\\n            if(i==0){\\n                res = temp | pfR[i];\\n            }\\n            else if(i==n-1){\\n                res = temp | pfL[i];\\n            }\\n            else{\\n                res = pfL[i] | temp | pfR[i];\\n            }\\n            max = Math.max(max,res);\\n        }\\n        return max;\\n    }\\n    \\n    public long calc(int num, int k){\\n        long ans = num;\\n        for(int i=0 ; i<k ; i++){\\n            ans *= 2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520311,
                "title": "greedy-java",
                "content": "\\nDue to problem constraints, **the best strategy is to select a single number from the array and shift it by K.** To achieve this efficiently, we should precompute the array\\'s results without any shifts. For each element, we subtract it from the precomputed result and apply a K-shift using the bitwise OR operation to update the result. However, one issue arises since the bitwise OR operation is a destructive operation, and we cannot reverse it for a single number. Therefore, we need to manually perform bit counting by utilizing the update method.\\n\\n```\\nclass Solution {\\n    void update(int[] bits, int n, int op) {\\n        for (int i = 0; i < bits.length; ++i) {\\n            if ((n & (1 L << i)) != 0) {\\n                bits[i] += op;\\n            }\\n        }\\n    }\\n\\n    int toInt(int[] bits) {\\n        int r = 0;\\n        for (int i = 0; i < bits.length; ++i) {\\n            if (bits[i] > 0) {\\n                r |= 1 << i;\\n            }\\n        }\\n        return r;\\n    }\\n\\n    public long maximumOr(int[] nums, int k) {\\n        int[] bits = new int[32];\\n        for (int n: nums) {\\n            update(bits, n, 1);\\n        }\\n        long r = toInt(bits);\\n        for (int n: nums) {\\n            update(bits, n, -1);\\n            long m = toInt(bits);\\n            m |= (long) n << k;\\n            r = Math.max(r, m);\\n            update(bits, n, 1);\\n        }\\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    void update(int[] bits, int n, int op) {\\n        for (int i = 0; i < bits.length; ++i) {\\n            if ((n & (1 L << i)) != 0) {\\n                bits[i] += op;\\n            }\\n        }\\n    }\\n\\n    int toInt(int[] bits) {\\n        int r = 0;\\n        for (int i = 0; i < bits.length; ++i) {\\n            if (bits[i] > 0) {\\n                r |= 1 << i;\\n            }\\n        }\\n        return r;\\n    }\\n\\n    public long maximumOr(int[] nums, int k) {\\n        int[] bits = new int[32];\\n        for (int n: nums) {\\n            update(bits, n, 1);\\n        }\\n        long r = toInt(bits);\\n        for (int n: nums) {\\n            update(bits, n, -1);\\n            long m = toInt(bits);\\n            m |= (long) n << k;\\n            r = Math.max(r, m);\\n            update(bits, n, 1);\\n        }\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1892515,
                "content": [
                    {
                        "username": "Andrei-Paval",
                        "content": "Can someone explain why is it optimal to apply all the k operations on the same element? \\nWhy isn\\'t it possible, in some cases, to obtain a larger value for the bitwise OR of all the elements by distributing the operations on multiple elements?"
                    },
                    {
                        "username": "mciobanu",
                        "content": "[@daren](/daren) I looked at the description, thought a little, and started wondering how could this be a \"medium\" problem, as you can easily run into overflows and have many options to shift multiple numbers. Then I looked at the hints and they were \"obviously wrong\". Then I checked the discussions, which made me look at the signature, and I finally realized that the answer takes 64 bits. I feel that the description should have mentioned this and stand on its own, without you needing to check the signature. Am I wrong?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we will get left set bits "
                    },
                    {
                        "username": "gaurav621",
                        "content": "you only need to choose element which have left most set bit (so that you can left-shit that element k time and get max result), now you can get conflits like 9(1001) and 12(1100) and need to choose only one because once you perform left shift on it, it will be the left most set bit. So, now you need to perform rest (k-1) operation on that chosen element only.\n\nYou can solve this question with logic - (prefixOR | suffixOR | left most set bit elements * pow(2, k)) and take the max one."
                    },
                    {
                        "username": "daren",
                        "content": "i think it becomes obvious if they set the signature of the C++ function as:\n\nlong long maximumOr(vector \\<long long\\>& nums, int k)\n\notherwise its not clear, if you shift an int 15 times, does it become negative? do bits drop off the top end? "
                    },
                    {
                        "username": "ishaandixit18",
                        "content": "Hey [@Andrei Paval](/Andrei-Paval), I solved the problem using multiple operations on multiple numbers . The ans was still same and the time complexity is O(n * k). I think that greedily multiplying every number results in an optimal solution as multiplying a number by 2 ,k times will give a large result as mentioned by [@Aman Saini](/aman1320)."
                    },
                    {
                        "username": "aman1320",
                        "content": "Multiplying single element k time will give more larger result."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@Lee_fan_Ak_The_Boss](/Lee_fan_Ak_The_Boss) I want this power to get such kind of intuition."
                    },
                    {
                        "username": "ishaandixit18",
                        "content": "Exactly, that is my doubt as well. Why can\\'t I apply two operations to two different numbers?"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "you have to store prefix and suffix bitwise or operation at each index....and then not need to do k operation just take n = 2**k and mulitply n with each element of nums and perform the bitwise OR operation using stored sufix and perfix array...and Done it"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "The Reason behind applying all the k operations on the same element is\\nshifting\\nat each operation we are shifting and hence the number doubles so it is beneficial to double the maximum number at a point because it will increase the required output.\\n\\nAs soon as you applied the opeartion once on an element it will become double and you should keep applying the same operation on it again and again till k so that you can get maximum of it.\\nI hope you got it ! \\u2764\\uFE0F\\u2764\\uFE0F"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "But why this approach is failing on one testcase.\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n, vector<long long>(k+1, -1));\\n        return solve(nums, n-1, k, dp);\\n    }\\n    \\n    long long solve(vector<int>& nums, int ind, int k, vector<vector<long long>>& dp){\\n        if(ind < 0) return 0;\\n        if(dp[ind][k] != -1)    return dp[ind][k];\\n            \\n        long long pick = -1, temp = nums[ind], p = k;\\n        while(p > 0){\\n            p--;\\n            temp = temp*2;\\n            pick = max(pick, (temp | solve(nums, ind-1, p, dp))); \\n        }\\n        long long notPick = (nums[ind] | solve(nums, ind-1, k, dp));\\n        return dp[ind][k] = max(pick, notPick);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "sylvex",
                        "content": "such a pain not come up with prefix solution...\\nI used priority queue , passed the first few cases, and it failed..."
                    },
                    {
                        "username": "ranjeet_kumar7",
                        "content": "can any one tell why it is applying the k operation on 1 index of example 1 means why not applying on 0 index if we are geting the maximum value 24+9=33"
                    },
                    {
                        "username": "nandunk",
                        "content": "then we will get 25 only"
                    },
                    {
                        "username": "gaurav621",
                        "content": "you have to calculate OR of elements not sum of elements.. and 24 | 9 = 25 "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Tricky one :)**\\n\\nI like it"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "why is the dp solution not correct?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@heisenberg_44](/heisenberg_44) Just a guess!"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "[@heisenberg280](/heisenberg280) hehe you got good taste.how did you know i was indian?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Hamare naam k saath saath stats be aage piche hai :xD"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "Can anyone tell me why this approach is failing.\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n, vector<long long>(k+1, -1));\\n        return solve(nums, n-1, k, dp);\\n    }\\n    \\n    long long solve(vector<int>& nums, int ind, int k, vector<vector<long long>>& dp){\\n        if(ind < 0) return 0;\\n        if(dp[ind][k] != -1)    return dp[ind][k];\\n            \\n        long long pick = -1, temp = nums[ind], p = k;\\n        while(p > 0){\\n            p--;\\n            temp = temp*2;\\n            pick = max(pick, (temp | solve(nums, ind-1, p, dp))); \\n        }\\n        long long notPick = (nums[ind] | solve(nums, ind-1, k, dp));\\n        return dp[ind][k] = max(pick, notPick);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "sleepingonee",
                        "content": "New testcase nums=[974,816] k=2 cancelled my contest result. Ouch"
                    },
                    {
                        "username": "annahung",
                        "content": "I can understand why we should apply all the k operations on the same element. \\nHowever, I cannot understand why iterating k times and each time find the max OR result will yield wrong answer...\\n\\nFor example:\\n[10, 11], k = 2\\n\\nThe correct answer is to operate on 11.\\n\\nBut if we iterating 2 times:\\nAt first time: \\noperate on 10:\\n10100\\n  1011\\n--------\\n11111\\n\\noperate on 11:\\n  1010\\n10110\\n-------\\n11110\\n\\nThen we will choose to operate at on 10. And this will yield a wrong answer....\\n"
                    },
                    {
                        "username": "MuditK_57",
                        "content": "Why my solution is giving wrong answer? \n\nclass Solution {\npublic:\n        \n\n    void update(vector<long long>& prefix,vector<long long>& suffix,vector<long long>& nums){\n        int n=nums.size();\n        for(int i=1;i<n;i++)\n            prefix[i]=nums[i-1]|prefix[i-1];\n        for(int i=n-2;i>=0;i--)\n            suffix[i]=suffix[i+1]|nums[i+1];\n        return ;\n    }\n    \n    long long maximumOr(vector<int>& num, int k) {\n        long long po=1;\n        long long x=2;\n        for(int i=1;i<=k;i++)\n            po*=x;\n        long long ans=0;\n        int n=num.size();\n        vector<long long>nums(n,0);\n        for(int i=0;i<n;i++)\n            nums[i]=num[i];\n        vector<long long>prefix(n,0),suffix(n,0);\n        for(int i=1;i<n;i++)\n            prefix[i]=nums[i-1]|prefix[i-1];\n        for(int i=n-2;i>=0;i--)\n            suffix[i]=suffix[i+1]|nums[i+1];\n        int pos=0;\n        long long m=LONG_MIN;\n        for(int i=0;i<n;i++){\n            long long temp=((nums[i]*2)|prefix[i])|suffix[i];\n            if(temp>m){\n                m=temp;\n                pos=i;\n            }\n        }\n        nums[pos]=nums[pos]*po;\n        for(int i=0;i<n;i++)\n            ans=ans|nums[i];\n        return ans;\n    }\n};\n"
                    }
                ]
            },
            {
                "id": 1892741,
                "content": [
                    {
                        "username": "Andrei-Paval",
                        "content": "Can someone explain why is it optimal to apply all the k operations on the same element? \\nWhy isn\\'t it possible, in some cases, to obtain a larger value for the bitwise OR of all the elements by distributing the operations on multiple elements?"
                    },
                    {
                        "username": "mciobanu",
                        "content": "[@daren](/daren) I looked at the description, thought a little, and started wondering how could this be a \"medium\" problem, as you can easily run into overflows and have many options to shift multiple numbers. Then I looked at the hints and they were \"obviously wrong\". Then I checked the discussions, which made me look at the signature, and I finally realized that the answer takes 64 bits. I feel that the description should have mentioned this and stand on its own, without you needing to check the signature. Am I wrong?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we will get left set bits "
                    },
                    {
                        "username": "gaurav621",
                        "content": "you only need to choose element which have left most set bit (so that you can left-shit that element k time and get max result), now you can get conflits like 9(1001) and 12(1100) and need to choose only one because once you perform left shift on it, it will be the left most set bit. So, now you need to perform rest (k-1) operation on that chosen element only.\n\nYou can solve this question with logic - (prefixOR | suffixOR | left most set bit elements * pow(2, k)) and take the max one."
                    },
                    {
                        "username": "daren",
                        "content": "i think it becomes obvious if they set the signature of the C++ function as:\n\nlong long maximumOr(vector \\<long long\\>& nums, int k)\n\notherwise its not clear, if you shift an int 15 times, does it become negative? do bits drop off the top end? "
                    },
                    {
                        "username": "ishaandixit18",
                        "content": "Hey [@Andrei Paval](/Andrei-Paval), I solved the problem using multiple operations on multiple numbers . The ans was still same and the time complexity is O(n * k). I think that greedily multiplying every number results in an optimal solution as multiplying a number by 2 ,k times will give a large result as mentioned by [@Aman Saini](/aman1320)."
                    },
                    {
                        "username": "aman1320",
                        "content": "Multiplying single element k time will give more larger result."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@Lee_fan_Ak_The_Boss](/Lee_fan_Ak_The_Boss) I want this power to get such kind of intuition."
                    },
                    {
                        "username": "ishaandixit18",
                        "content": "Exactly, that is my doubt as well. Why can\\'t I apply two operations to two different numbers?"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "you have to store prefix and suffix bitwise or operation at each index....and then not need to do k operation just take n = 2**k and mulitply n with each element of nums and perform the bitwise OR operation using stored sufix and perfix array...and Done it"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "The Reason behind applying all the k operations on the same element is\\nshifting\\nat each operation we are shifting and hence the number doubles so it is beneficial to double the maximum number at a point because it will increase the required output.\\n\\nAs soon as you applied the opeartion once on an element it will become double and you should keep applying the same operation on it again and again till k so that you can get maximum of it.\\nI hope you got it ! \\u2764\\uFE0F\\u2764\\uFE0F"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "But why this approach is failing on one testcase.\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n, vector<long long>(k+1, -1));\\n        return solve(nums, n-1, k, dp);\\n    }\\n    \\n    long long solve(vector<int>& nums, int ind, int k, vector<vector<long long>>& dp){\\n        if(ind < 0) return 0;\\n        if(dp[ind][k] != -1)    return dp[ind][k];\\n            \\n        long long pick = -1, temp = nums[ind], p = k;\\n        while(p > 0){\\n            p--;\\n            temp = temp*2;\\n            pick = max(pick, (temp | solve(nums, ind-1, p, dp))); \\n        }\\n        long long notPick = (nums[ind] | solve(nums, ind-1, k, dp));\\n        return dp[ind][k] = max(pick, notPick);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "sylvex",
                        "content": "such a pain not come up with prefix solution...\\nI used priority queue , passed the first few cases, and it failed..."
                    },
                    {
                        "username": "ranjeet_kumar7",
                        "content": "can any one tell why it is applying the k operation on 1 index of example 1 means why not applying on 0 index if we are geting the maximum value 24+9=33"
                    },
                    {
                        "username": "nandunk",
                        "content": "then we will get 25 only"
                    },
                    {
                        "username": "gaurav621",
                        "content": "you have to calculate OR of elements not sum of elements.. and 24 | 9 = 25 "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Tricky one :)**\\n\\nI like it"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "why is the dp solution not correct?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@heisenberg_44](/heisenberg_44) Just a guess!"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "[@heisenberg280](/heisenberg280) hehe you got good taste.how did you know i was indian?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Hamare naam k saath saath stats be aage piche hai :xD"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "Can anyone tell me why this approach is failing.\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n, vector<long long>(k+1, -1));\\n        return solve(nums, n-1, k, dp);\\n    }\\n    \\n    long long solve(vector<int>& nums, int ind, int k, vector<vector<long long>>& dp){\\n        if(ind < 0) return 0;\\n        if(dp[ind][k] != -1)    return dp[ind][k];\\n            \\n        long long pick = -1, temp = nums[ind], p = k;\\n        while(p > 0){\\n            p--;\\n            temp = temp*2;\\n            pick = max(pick, (temp | solve(nums, ind-1, p, dp))); \\n        }\\n        long long notPick = (nums[ind] | solve(nums, ind-1, k, dp));\\n        return dp[ind][k] = max(pick, notPick);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "sleepingonee",
                        "content": "New testcase nums=[974,816] k=2 cancelled my contest result. Ouch"
                    },
                    {
                        "username": "annahung",
                        "content": "I can understand why we should apply all the k operations on the same element. \\nHowever, I cannot understand why iterating k times and each time find the max OR result will yield wrong answer...\\n\\nFor example:\\n[10, 11], k = 2\\n\\nThe correct answer is to operate on 11.\\n\\nBut if we iterating 2 times:\\nAt first time: \\noperate on 10:\\n10100\\n  1011\\n--------\\n11111\\n\\noperate on 11:\\n  1010\\n10110\\n-------\\n11110\\n\\nThen we will choose to operate at on 10. And this will yield a wrong answer....\\n"
                    },
                    {
                        "username": "MuditK_57",
                        "content": "Why my solution is giving wrong answer? \n\nclass Solution {\npublic:\n        \n\n    void update(vector<long long>& prefix,vector<long long>& suffix,vector<long long>& nums){\n        int n=nums.size();\n        for(int i=1;i<n;i++)\n            prefix[i]=nums[i-1]|prefix[i-1];\n        for(int i=n-2;i>=0;i--)\n            suffix[i]=suffix[i+1]|nums[i+1];\n        return ;\n    }\n    \n    long long maximumOr(vector<int>& num, int k) {\n        long long po=1;\n        long long x=2;\n        for(int i=1;i<=k;i++)\n            po*=x;\n        long long ans=0;\n        int n=num.size();\n        vector<long long>nums(n,0);\n        for(int i=0;i<n;i++)\n            nums[i]=num[i];\n        vector<long long>prefix(n,0),suffix(n,0);\n        for(int i=1;i<n;i++)\n            prefix[i]=nums[i-1]|prefix[i-1];\n        for(int i=n-2;i>=0;i--)\n            suffix[i]=suffix[i+1]|nums[i+1];\n        int pos=0;\n        long long m=LONG_MIN;\n        for(int i=0;i<n;i++){\n            long long temp=((nums[i]*2)|prefix[i])|suffix[i];\n            if(temp>m){\n                m=temp;\n                pos=i;\n            }\n        }\n        nums[pos]=nums[pos]*po;\n        for(int i=0;i<n;i++)\n            ans=ans|nums[i];\n        return ans;\n    }\n};\n"
                    }
                ]
            },
            {
                "id": 1892460,
                "content": [
                    {
                        "username": "Andrei-Paval",
                        "content": "Can someone explain why is it optimal to apply all the k operations on the same element? \\nWhy isn\\'t it possible, in some cases, to obtain a larger value for the bitwise OR of all the elements by distributing the operations on multiple elements?"
                    },
                    {
                        "username": "mciobanu",
                        "content": "[@daren](/daren) I looked at the description, thought a little, and started wondering how could this be a \"medium\" problem, as you can easily run into overflows and have many options to shift multiple numbers. Then I looked at the hints and they were \"obviously wrong\". Then I checked the discussions, which made me look at the signature, and I finally realized that the answer takes 64 bits. I feel that the description should have mentioned this and stand on its own, without you needing to check the signature. Am I wrong?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we will get left set bits "
                    },
                    {
                        "username": "gaurav621",
                        "content": "you only need to choose element which have left most set bit (so that you can left-shit that element k time and get max result), now you can get conflits like 9(1001) and 12(1100) and need to choose only one because once you perform left shift on it, it will be the left most set bit. So, now you need to perform rest (k-1) operation on that chosen element only.\n\nYou can solve this question with logic - (prefixOR | suffixOR | left most set bit elements * pow(2, k)) and take the max one."
                    },
                    {
                        "username": "daren",
                        "content": "i think it becomes obvious if they set the signature of the C++ function as:\n\nlong long maximumOr(vector \\<long long\\>& nums, int k)\n\notherwise its not clear, if you shift an int 15 times, does it become negative? do bits drop off the top end? "
                    },
                    {
                        "username": "ishaandixit18",
                        "content": "Hey [@Andrei Paval](/Andrei-Paval), I solved the problem using multiple operations on multiple numbers . The ans was still same and the time complexity is O(n * k). I think that greedily multiplying every number results in an optimal solution as multiplying a number by 2 ,k times will give a large result as mentioned by [@Aman Saini](/aman1320)."
                    },
                    {
                        "username": "aman1320",
                        "content": "Multiplying single element k time will give more larger result."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@Lee_fan_Ak_The_Boss](/Lee_fan_Ak_The_Boss) I want this power to get such kind of intuition."
                    },
                    {
                        "username": "ishaandixit18",
                        "content": "Exactly, that is my doubt as well. Why can\\'t I apply two operations to two different numbers?"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "you have to store prefix and suffix bitwise or operation at each index....and then not need to do k operation just take n = 2**k and mulitply n with each element of nums and perform the bitwise OR operation using stored sufix and perfix array...and Done it"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "The Reason behind applying all the k operations on the same element is\\nshifting\\nat each operation we are shifting and hence the number doubles so it is beneficial to double the maximum number at a point because it will increase the required output.\\n\\nAs soon as you applied the opeartion once on an element it will become double and you should keep applying the same operation on it again and again till k so that you can get maximum of it.\\nI hope you got it ! \\u2764\\uFE0F\\u2764\\uFE0F"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "But why this approach is failing on one testcase.\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n, vector<long long>(k+1, -1));\\n        return solve(nums, n-1, k, dp);\\n    }\\n    \\n    long long solve(vector<int>& nums, int ind, int k, vector<vector<long long>>& dp){\\n        if(ind < 0) return 0;\\n        if(dp[ind][k] != -1)    return dp[ind][k];\\n            \\n        long long pick = -1, temp = nums[ind], p = k;\\n        while(p > 0){\\n            p--;\\n            temp = temp*2;\\n            pick = max(pick, (temp | solve(nums, ind-1, p, dp))); \\n        }\\n        long long notPick = (nums[ind] | solve(nums, ind-1, k, dp));\\n        return dp[ind][k] = max(pick, notPick);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "sylvex",
                        "content": "such a pain not come up with prefix solution...\\nI used priority queue , passed the first few cases, and it failed..."
                    },
                    {
                        "username": "ranjeet_kumar7",
                        "content": "can any one tell why it is applying the k operation on 1 index of example 1 means why not applying on 0 index if we are geting the maximum value 24+9=33"
                    },
                    {
                        "username": "nandunk",
                        "content": "then we will get 25 only"
                    },
                    {
                        "username": "gaurav621",
                        "content": "you have to calculate OR of elements not sum of elements.. and 24 | 9 = 25 "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Tricky one :)**\\n\\nI like it"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "why is the dp solution not correct?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@heisenberg_44](/heisenberg_44) Just a guess!"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "[@heisenberg280](/heisenberg280) hehe you got good taste.how did you know i was indian?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Hamare naam k saath saath stats be aage piche hai :xD"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "Can anyone tell me why this approach is failing.\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n, vector<long long>(k+1, -1));\\n        return solve(nums, n-1, k, dp);\\n    }\\n    \\n    long long solve(vector<int>& nums, int ind, int k, vector<vector<long long>>& dp){\\n        if(ind < 0) return 0;\\n        if(dp[ind][k] != -1)    return dp[ind][k];\\n            \\n        long long pick = -1, temp = nums[ind], p = k;\\n        while(p > 0){\\n            p--;\\n            temp = temp*2;\\n            pick = max(pick, (temp | solve(nums, ind-1, p, dp))); \\n        }\\n        long long notPick = (nums[ind] | solve(nums, ind-1, k, dp));\\n        return dp[ind][k] = max(pick, notPick);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "sleepingonee",
                        "content": "New testcase nums=[974,816] k=2 cancelled my contest result. Ouch"
                    },
                    {
                        "username": "annahung",
                        "content": "I can understand why we should apply all the k operations on the same element. \\nHowever, I cannot understand why iterating k times and each time find the max OR result will yield wrong answer...\\n\\nFor example:\\n[10, 11], k = 2\\n\\nThe correct answer is to operate on 11.\\n\\nBut if we iterating 2 times:\\nAt first time: \\noperate on 10:\\n10100\\n  1011\\n--------\\n11111\\n\\noperate on 11:\\n  1010\\n10110\\n-------\\n11110\\n\\nThen we will choose to operate at on 10. And this will yield a wrong answer....\\n"
                    },
                    {
                        "username": "MuditK_57",
                        "content": "Why my solution is giving wrong answer? \n\nclass Solution {\npublic:\n        \n\n    void update(vector<long long>& prefix,vector<long long>& suffix,vector<long long>& nums){\n        int n=nums.size();\n        for(int i=1;i<n;i++)\n            prefix[i]=nums[i-1]|prefix[i-1];\n        for(int i=n-2;i>=0;i--)\n            suffix[i]=suffix[i+1]|nums[i+1];\n        return ;\n    }\n    \n    long long maximumOr(vector<int>& num, int k) {\n        long long po=1;\n        long long x=2;\n        for(int i=1;i<=k;i++)\n            po*=x;\n        long long ans=0;\n        int n=num.size();\n        vector<long long>nums(n,0);\n        for(int i=0;i<n;i++)\n            nums[i]=num[i];\n        vector<long long>prefix(n,0),suffix(n,0);\n        for(int i=1;i<n;i++)\n            prefix[i]=nums[i-1]|prefix[i-1];\n        for(int i=n-2;i>=0;i--)\n            suffix[i]=suffix[i+1]|nums[i+1];\n        int pos=0;\n        long long m=LONG_MIN;\n        for(int i=0;i<n;i++){\n            long long temp=((nums[i]*2)|prefix[i])|suffix[i];\n            if(temp>m){\n                m=temp;\n                pos=i;\n            }\n        }\n        nums[pos]=nums[pos]*po;\n        for(int i=0;i<n;i++)\n            ans=ans|nums[i];\n        return ans;\n    }\n};\n"
                    }
                ]
            },
            {
                "id": 1893723,
                "content": [
                    {
                        "username": "Andrei-Paval",
                        "content": "Can someone explain why is it optimal to apply all the k operations on the same element? \\nWhy isn\\'t it possible, in some cases, to obtain a larger value for the bitwise OR of all the elements by distributing the operations on multiple elements?"
                    },
                    {
                        "username": "mciobanu",
                        "content": "[@daren](/daren) I looked at the description, thought a little, and started wondering how could this be a \"medium\" problem, as you can easily run into overflows and have many options to shift multiple numbers. Then I looked at the hints and they were \"obviously wrong\". Then I checked the discussions, which made me look at the signature, and I finally realized that the answer takes 64 bits. I feel that the description should have mentioned this and stand on its own, without you needing to check the signature. Am I wrong?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we will get left set bits "
                    },
                    {
                        "username": "gaurav621",
                        "content": "you only need to choose element which have left most set bit (so that you can left-shit that element k time and get max result), now you can get conflits like 9(1001) and 12(1100) and need to choose only one because once you perform left shift on it, it will be the left most set bit. So, now you need to perform rest (k-1) operation on that chosen element only.\n\nYou can solve this question with logic - (prefixOR | suffixOR | left most set bit elements * pow(2, k)) and take the max one."
                    },
                    {
                        "username": "daren",
                        "content": "i think it becomes obvious if they set the signature of the C++ function as:\n\nlong long maximumOr(vector \\<long long\\>& nums, int k)\n\notherwise its not clear, if you shift an int 15 times, does it become negative? do bits drop off the top end? "
                    },
                    {
                        "username": "ishaandixit18",
                        "content": "Hey [@Andrei Paval](/Andrei-Paval), I solved the problem using multiple operations on multiple numbers . The ans was still same and the time complexity is O(n * k). I think that greedily multiplying every number results in an optimal solution as multiplying a number by 2 ,k times will give a large result as mentioned by [@Aman Saini](/aman1320)."
                    },
                    {
                        "username": "aman1320",
                        "content": "Multiplying single element k time will give more larger result."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@Lee_fan_Ak_The_Boss](/Lee_fan_Ak_The_Boss) I want this power to get such kind of intuition."
                    },
                    {
                        "username": "ishaandixit18",
                        "content": "Exactly, that is my doubt as well. Why can\\'t I apply two operations to two different numbers?"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "you have to store prefix and suffix bitwise or operation at each index....and then not need to do k operation just take n = 2**k and mulitply n with each element of nums and perform the bitwise OR operation using stored sufix and perfix array...and Done it"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "The Reason behind applying all the k operations on the same element is\\nshifting\\nat each operation we are shifting and hence the number doubles so it is beneficial to double the maximum number at a point because it will increase the required output.\\n\\nAs soon as you applied the opeartion once on an element it will become double and you should keep applying the same operation on it again and again till k so that you can get maximum of it.\\nI hope you got it ! \\u2764\\uFE0F\\u2764\\uFE0F"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "But why this approach is failing on one testcase.\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n, vector<long long>(k+1, -1));\\n        return solve(nums, n-1, k, dp);\\n    }\\n    \\n    long long solve(vector<int>& nums, int ind, int k, vector<vector<long long>>& dp){\\n        if(ind < 0) return 0;\\n        if(dp[ind][k] != -1)    return dp[ind][k];\\n            \\n        long long pick = -1, temp = nums[ind], p = k;\\n        while(p > 0){\\n            p--;\\n            temp = temp*2;\\n            pick = max(pick, (temp | solve(nums, ind-1, p, dp))); \\n        }\\n        long long notPick = (nums[ind] | solve(nums, ind-1, k, dp));\\n        return dp[ind][k] = max(pick, notPick);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "sylvex",
                        "content": "such a pain not come up with prefix solution...\\nI used priority queue , passed the first few cases, and it failed..."
                    },
                    {
                        "username": "ranjeet_kumar7",
                        "content": "can any one tell why it is applying the k operation on 1 index of example 1 means why not applying on 0 index if we are geting the maximum value 24+9=33"
                    },
                    {
                        "username": "nandunk",
                        "content": "then we will get 25 only"
                    },
                    {
                        "username": "gaurav621",
                        "content": "you have to calculate OR of elements not sum of elements.. and 24 | 9 = 25 "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Tricky one :)**\\n\\nI like it"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "why is the dp solution not correct?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@heisenberg_44](/heisenberg_44) Just a guess!"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "[@heisenberg280](/heisenberg280) hehe you got good taste.how did you know i was indian?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Hamare naam k saath saath stats be aage piche hai :xD"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "Can anyone tell me why this approach is failing.\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n, vector<long long>(k+1, -1));\\n        return solve(nums, n-1, k, dp);\\n    }\\n    \\n    long long solve(vector<int>& nums, int ind, int k, vector<vector<long long>>& dp){\\n        if(ind < 0) return 0;\\n        if(dp[ind][k] != -1)    return dp[ind][k];\\n            \\n        long long pick = -1, temp = nums[ind], p = k;\\n        while(p > 0){\\n            p--;\\n            temp = temp*2;\\n            pick = max(pick, (temp | solve(nums, ind-1, p, dp))); \\n        }\\n        long long notPick = (nums[ind] | solve(nums, ind-1, k, dp));\\n        return dp[ind][k] = max(pick, notPick);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "sleepingonee",
                        "content": "New testcase nums=[974,816] k=2 cancelled my contest result. Ouch"
                    },
                    {
                        "username": "annahung",
                        "content": "I can understand why we should apply all the k operations on the same element. \\nHowever, I cannot understand why iterating k times and each time find the max OR result will yield wrong answer...\\n\\nFor example:\\n[10, 11], k = 2\\n\\nThe correct answer is to operate on 11.\\n\\nBut if we iterating 2 times:\\nAt first time: \\noperate on 10:\\n10100\\n  1011\\n--------\\n11111\\n\\noperate on 11:\\n  1010\\n10110\\n-------\\n11110\\n\\nThen we will choose to operate at on 10. And this will yield a wrong answer....\\n"
                    },
                    {
                        "username": "MuditK_57",
                        "content": "Why my solution is giving wrong answer? \n\nclass Solution {\npublic:\n        \n\n    void update(vector<long long>& prefix,vector<long long>& suffix,vector<long long>& nums){\n        int n=nums.size();\n        for(int i=1;i<n;i++)\n            prefix[i]=nums[i-1]|prefix[i-1];\n        for(int i=n-2;i>=0;i--)\n            suffix[i]=suffix[i+1]|nums[i+1];\n        return ;\n    }\n    \n    long long maximumOr(vector<int>& num, int k) {\n        long long po=1;\n        long long x=2;\n        for(int i=1;i<=k;i++)\n            po*=x;\n        long long ans=0;\n        int n=num.size();\n        vector<long long>nums(n,0);\n        for(int i=0;i<n;i++)\n            nums[i]=num[i];\n        vector<long long>prefix(n,0),suffix(n,0);\n        for(int i=1;i<n;i++)\n            prefix[i]=nums[i-1]|prefix[i-1];\n        for(int i=n-2;i>=0;i--)\n            suffix[i]=suffix[i+1]|nums[i+1];\n        int pos=0;\n        long long m=LONG_MIN;\n        for(int i=0;i<n;i++){\n            long long temp=((nums[i]*2)|prefix[i])|suffix[i];\n            if(temp>m){\n                m=temp;\n                pos=i;\n            }\n        }\n        nums[pos]=nums[pos]*po;\n        for(int i=0;i<n;i++)\n            ans=ans|nums[i];\n        return ans;\n    }\n};\n"
                    }
                ]
            },
            {
                "id": 1893562,
                "content": [
                    {
                        "username": "Andrei-Paval",
                        "content": "Can someone explain why is it optimal to apply all the k operations on the same element? \\nWhy isn\\'t it possible, in some cases, to obtain a larger value for the bitwise OR of all the elements by distributing the operations on multiple elements?"
                    },
                    {
                        "username": "mciobanu",
                        "content": "[@daren](/daren) I looked at the description, thought a little, and started wondering how could this be a \"medium\" problem, as you can easily run into overflows and have many options to shift multiple numbers. Then I looked at the hints and they were \"obviously wrong\". Then I checked the discussions, which made me look at the signature, and I finally realized that the answer takes 64 bits. I feel that the description should have mentioned this and stand on its own, without you needing to check the signature. Am I wrong?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we will get left set bits "
                    },
                    {
                        "username": "gaurav621",
                        "content": "you only need to choose element which have left most set bit (so that you can left-shit that element k time and get max result), now you can get conflits like 9(1001) and 12(1100) and need to choose only one because once you perform left shift on it, it will be the left most set bit. So, now you need to perform rest (k-1) operation on that chosen element only.\n\nYou can solve this question with logic - (prefixOR | suffixOR | left most set bit elements * pow(2, k)) and take the max one."
                    },
                    {
                        "username": "daren",
                        "content": "i think it becomes obvious if they set the signature of the C++ function as:\n\nlong long maximumOr(vector \\<long long\\>& nums, int k)\n\notherwise its not clear, if you shift an int 15 times, does it become negative? do bits drop off the top end? "
                    },
                    {
                        "username": "ishaandixit18",
                        "content": "Hey [@Andrei Paval](/Andrei-Paval), I solved the problem using multiple operations on multiple numbers . The ans was still same and the time complexity is O(n * k). I think that greedily multiplying every number results in an optimal solution as multiplying a number by 2 ,k times will give a large result as mentioned by [@Aman Saini](/aman1320)."
                    },
                    {
                        "username": "aman1320",
                        "content": "Multiplying single element k time will give more larger result."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@Lee_fan_Ak_The_Boss](/Lee_fan_Ak_The_Boss) I want this power to get such kind of intuition."
                    },
                    {
                        "username": "ishaandixit18",
                        "content": "Exactly, that is my doubt as well. Why can\\'t I apply two operations to two different numbers?"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "you have to store prefix and suffix bitwise or operation at each index....and then not need to do k operation just take n = 2**k and mulitply n with each element of nums and perform the bitwise OR operation using stored sufix and perfix array...and Done it"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "The Reason behind applying all the k operations on the same element is\\nshifting\\nat each operation we are shifting and hence the number doubles so it is beneficial to double the maximum number at a point because it will increase the required output.\\n\\nAs soon as you applied the opeartion once on an element it will become double and you should keep applying the same operation on it again and again till k so that you can get maximum of it.\\nI hope you got it ! \\u2764\\uFE0F\\u2764\\uFE0F"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "But why this approach is failing on one testcase.\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n, vector<long long>(k+1, -1));\\n        return solve(nums, n-1, k, dp);\\n    }\\n    \\n    long long solve(vector<int>& nums, int ind, int k, vector<vector<long long>>& dp){\\n        if(ind < 0) return 0;\\n        if(dp[ind][k] != -1)    return dp[ind][k];\\n            \\n        long long pick = -1, temp = nums[ind], p = k;\\n        while(p > 0){\\n            p--;\\n            temp = temp*2;\\n            pick = max(pick, (temp | solve(nums, ind-1, p, dp))); \\n        }\\n        long long notPick = (nums[ind] | solve(nums, ind-1, k, dp));\\n        return dp[ind][k] = max(pick, notPick);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "sylvex",
                        "content": "such a pain not come up with prefix solution...\\nI used priority queue , passed the first few cases, and it failed..."
                    },
                    {
                        "username": "ranjeet_kumar7",
                        "content": "can any one tell why it is applying the k operation on 1 index of example 1 means why not applying on 0 index if we are geting the maximum value 24+9=33"
                    },
                    {
                        "username": "nandunk",
                        "content": "then we will get 25 only"
                    },
                    {
                        "username": "gaurav621",
                        "content": "you have to calculate OR of elements not sum of elements.. and 24 | 9 = 25 "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Tricky one :)**\\n\\nI like it"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "why is the dp solution not correct?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@heisenberg_44](/heisenberg_44) Just a guess!"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "[@heisenberg280](/heisenberg280) hehe you got good taste.how did you know i was indian?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Hamare naam k saath saath stats be aage piche hai :xD"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "Can anyone tell me why this approach is failing.\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n, vector<long long>(k+1, -1));\\n        return solve(nums, n-1, k, dp);\\n    }\\n    \\n    long long solve(vector<int>& nums, int ind, int k, vector<vector<long long>>& dp){\\n        if(ind < 0) return 0;\\n        if(dp[ind][k] != -1)    return dp[ind][k];\\n            \\n        long long pick = -1, temp = nums[ind], p = k;\\n        while(p > 0){\\n            p--;\\n            temp = temp*2;\\n            pick = max(pick, (temp | solve(nums, ind-1, p, dp))); \\n        }\\n        long long notPick = (nums[ind] | solve(nums, ind-1, k, dp));\\n        return dp[ind][k] = max(pick, notPick);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "sleepingonee",
                        "content": "New testcase nums=[974,816] k=2 cancelled my contest result. Ouch"
                    },
                    {
                        "username": "annahung",
                        "content": "I can understand why we should apply all the k operations on the same element. \\nHowever, I cannot understand why iterating k times and each time find the max OR result will yield wrong answer...\\n\\nFor example:\\n[10, 11], k = 2\\n\\nThe correct answer is to operate on 11.\\n\\nBut if we iterating 2 times:\\nAt first time: \\noperate on 10:\\n10100\\n  1011\\n--------\\n11111\\n\\noperate on 11:\\n  1010\\n10110\\n-------\\n11110\\n\\nThen we will choose to operate at on 10. And this will yield a wrong answer....\\n"
                    },
                    {
                        "username": "MuditK_57",
                        "content": "Why my solution is giving wrong answer? \n\nclass Solution {\npublic:\n        \n\n    void update(vector<long long>& prefix,vector<long long>& suffix,vector<long long>& nums){\n        int n=nums.size();\n        for(int i=1;i<n;i++)\n            prefix[i]=nums[i-1]|prefix[i-1];\n        for(int i=n-2;i>=0;i--)\n            suffix[i]=suffix[i+1]|nums[i+1];\n        return ;\n    }\n    \n    long long maximumOr(vector<int>& num, int k) {\n        long long po=1;\n        long long x=2;\n        for(int i=1;i<=k;i++)\n            po*=x;\n        long long ans=0;\n        int n=num.size();\n        vector<long long>nums(n,0);\n        for(int i=0;i<n;i++)\n            nums[i]=num[i];\n        vector<long long>prefix(n,0),suffix(n,0);\n        for(int i=1;i<n;i++)\n            prefix[i]=nums[i-1]|prefix[i-1];\n        for(int i=n-2;i>=0;i--)\n            suffix[i]=suffix[i+1]|nums[i+1];\n        int pos=0;\n        long long m=LONG_MIN;\n        for(int i=0;i<n;i++){\n            long long temp=((nums[i]*2)|prefix[i])|suffix[i];\n            if(temp>m){\n                m=temp;\n                pos=i;\n            }\n        }\n        nums[pos]=nums[pos]*po;\n        for(int i=0;i<n;i++)\n            ans=ans|nums[i];\n        return ans;\n    }\n};\n"
                    }
                ]
            },
            {
                "id": 1897118,
                "content": [
                    {
                        "username": "Andrei-Paval",
                        "content": "Can someone explain why is it optimal to apply all the k operations on the same element? \\nWhy isn\\'t it possible, in some cases, to obtain a larger value for the bitwise OR of all the elements by distributing the operations on multiple elements?"
                    },
                    {
                        "username": "mciobanu",
                        "content": "[@daren](/daren) I looked at the description, thought a little, and started wondering how could this be a \"medium\" problem, as you can easily run into overflows and have many options to shift multiple numbers. Then I looked at the hints and they were \"obviously wrong\". Then I checked the discussions, which made me look at the signature, and I finally realized that the answer takes 64 bits. I feel that the description should have mentioned this and stand on its own, without you needing to check the signature. Am I wrong?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we will get left set bits "
                    },
                    {
                        "username": "gaurav621",
                        "content": "you only need to choose element which have left most set bit (so that you can left-shit that element k time and get max result), now you can get conflits like 9(1001) and 12(1100) and need to choose only one because once you perform left shift on it, it will be the left most set bit. So, now you need to perform rest (k-1) operation on that chosen element only.\n\nYou can solve this question with logic - (prefixOR | suffixOR | left most set bit elements * pow(2, k)) and take the max one."
                    },
                    {
                        "username": "daren",
                        "content": "i think it becomes obvious if they set the signature of the C++ function as:\n\nlong long maximumOr(vector \\<long long\\>& nums, int k)\n\notherwise its not clear, if you shift an int 15 times, does it become negative? do bits drop off the top end? "
                    },
                    {
                        "username": "ishaandixit18",
                        "content": "Hey [@Andrei Paval](/Andrei-Paval), I solved the problem using multiple operations on multiple numbers . The ans was still same and the time complexity is O(n * k). I think that greedily multiplying every number results in an optimal solution as multiplying a number by 2 ,k times will give a large result as mentioned by [@Aman Saini](/aman1320)."
                    },
                    {
                        "username": "aman1320",
                        "content": "Multiplying single element k time will give more larger result."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@Lee_fan_Ak_The_Boss](/Lee_fan_Ak_The_Boss) I want this power to get such kind of intuition."
                    },
                    {
                        "username": "ishaandixit18",
                        "content": "Exactly, that is my doubt as well. Why can\\'t I apply two operations to two different numbers?"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "you have to store prefix and suffix bitwise or operation at each index....and then not need to do k operation just take n = 2**k and mulitply n with each element of nums and perform the bitwise OR operation using stored sufix and perfix array...and Done it"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "The Reason behind applying all the k operations on the same element is\\nshifting\\nat each operation we are shifting and hence the number doubles so it is beneficial to double the maximum number at a point because it will increase the required output.\\n\\nAs soon as you applied the opeartion once on an element it will become double and you should keep applying the same operation on it again and again till k so that you can get maximum of it.\\nI hope you got it ! \\u2764\\uFE0F\\u2764\\uFE0F"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "But why this approach is failing on one testcase.\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n, vector<long long>(k+1, -1));\\n        return solve(nums, n-1, k, dp);\\n    }\\n    \\n    long long solve(vector<int>& nums, int ind, int k, vector<vector<long long>>& dp){\\n        if(ind < 0) return 0;\\n        if(dp[ind][k] != -1)    return dp[ind][k];\\n            \\n        long long pick = -1, temp = nums[ind], p = k;\\n        while(p > 0){\\n            p--;\\n            temp = temp*2;\\n            pick = max(pick, (temp | solve(nums, ind-1, p, dp))); \\n        }\\n        long long notPick = (nums[ind] | solve(nums, ind-1, k, dp));\\n        return dp[ind][k] = max(pick, notPick);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "sylvex",
                        "content": "such a pain not come up with prefix solution...\\nI used priority queue , passed the first few cases, and it failed..."
                    },
                    {
                        "username": "ranjeet_kumar7",
                        "content": "can any one tell why it is applying the k operation on 1 index of example 1 means why not applying on 0 index if we are geting the maximum value 24+9=33"
                    },
                    {
                        "username": "nandunk",
                        "content": "then we will get 25 only"
                    },
                    {
                        "username": "gaurav621",
                        "content": "you have to calculate OR of elements not sum of elements.. and 24 | 9 = 25 "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Tricky one :)**\\n\\nI like it"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "why is the dp solution not correct?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@heisenberg_44](/heisenberg_44) Just a guess!"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "[@heisenberg280](/heisenberg280) hehe you got good taste.how did you know i was indian?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Hamare naam k saath saath stats be aage piche hai :xD"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "Can anyone tell me why this approach is failing.\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n, vector<long long>(k+1, -1));\\n        return solve(nums, n-1, k, dp);\\n    }\\n    \\n    long long solve(vector<int>& nums, int ind, int k, vector<vector<long long>>& dp){\\n        if(ind < 0) return 0;\\n        if(dp[ind][k] != -1)    return dp[ind][k];\\n            \\n        long long pick = -1, temp = nums[ind], p = k;\\n        while(p > 0){\\n            p--;\\n            temp = temp*2;\\n            pick = max(pick, (temp | solve(nums, ind-1, p, dp))); \\n        }\\n        long long notPick = (nums[ind] | solve(nums, ind-1, k, dp));\\n        return dp[ind][k] = max(pick, notPick);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "sleepingonee",
                        "content": "New testcase nums=[974,816] k=2 cancelled my contest result. Ouch"
                    },
                    {
                        "username": "annahung",
                        "content": "I can understand why we should apply all the k operations on the same element. \\nHowever, I cannot understand why iterating k times and each time find the max OR result will yield wrong answer...\\n\\nFor example:\\n[10, 11], k = 2\\n\\nThe correct answer is to operate on 11.\\n\\nBut if we iterating 2 times:\\nAt first time: \\noperate on 10:\\n10100\\n  1011\\n--------\\n11111\\n\\noperate on 11:\\n  1010\\n10110\\n-------\\n11110\\n\\nThen we will choose to operate at on 10. And this will yield a wrong answer....\\n"
                    },
                    {
                        "username": "MuditK_57",
                        "content": "Why my solution is giving wrong answer? \n\nclass Solution {\npublic:\n        \n\n    void update(vector<long long>& prefix,vector<long long>& suffix,vector<long long>& nums){\n        int n=nums.size();\n        for(int i=1;i<n;i++)\n            prefix[i]=nums[i-1]|prefix[i-1];\n        for(int i=n-2;i>=0;i--)\n            suffix[i]=suffix[i+1]|nums[i+1];\n        return ;\n    }\n    \n    long long maximumOr(vector<int>& num, int k) {\n        long long po=1;\n        long long x=2;\n        for(int i=1;i<=k;i++)\n            po*=x;\n        long long ans=0;\n        int n=num.size();\n        vector<long long>nums(n,0);\n        for(int i=0;i<n;i++)\n            nums[i]=num[i];\n        vector<long long>prefix(n,0),suffix(n,0);\n        for(int i=1;i<n;i++)\n            prefix[i]=nums[i-1]|prefix[i-1];\n        for(int i=n-2;i>=0;i--)\n            suffix[i]=suffix[i+1]|nums[i+1];\n        int pos=0;\n        long long m=LONG_MIN;\n        for(int i=0;i<n;i++){\n            long long temp=((nums[i]*2)|prefix[i])|suffix[i];\n            if(temp>m){\n                m=temp;\n                pos=i;\n            }\n        }\n        nums[pos]=nums[pos]*po;\n        for(int i=0;i<n;i++)\n            ans=ans|nums[i];\n        return ans;\n    }\n};\n"
                    }
                ]
            },
            {
                "id": 1897061,
                "content": [
                    {
                        "username": "Andrei-Paval",
                        "content": "Can someone explain why is it optimal to apply all the k operations on the same element? \\nWhy isn\\'t it possible, in some cases, to obtain a larger value for the bitwise OR of all the elements by distributing the operations on multiple elements?"
                    },
                    {
                        "username": "mciobanu",
                        "content": "[@daren](/daren) I looked at the description, thought a little, and started wondering how could this be a \"medium\" problem, as you can easily run into overflows and have many options to shift multiple numbers. Then I looked at the hints and they were \"obviously wrong\". Then I checked the discussions, which made me look at the signature, and I finally realized that the answer takes 64 bits. I feel that the description should have mentioned this and stand on its own, without you needing to check the signature. Am I wrong?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we will get left set bits "
                    },
                    {
                        "username": "gaurav621",
                        "content": "you only need to choose element which have left most set bit (so that you can left-shit that element k time and get max result), now you can get conflits like 9(1001) and 12(1100) and need to choose only one because once you perform left shift on it, it will be the left most set bit. So, now you need to perform rest (k-1) operation on that chosen element only.\n\nYou can solve this question with logic - (prefixOR | suffixOR | left most set bit elements * pow(2, k)) and take the max one."
                    },
                    {
                        "username": "daren",
                        "content": "i think it becomes obvious if they set the signature of the C++ function as:\n\nlong long maximumOr(vector \\<long long\\>& nums, int k)\n\notherwise its not clear, if you shift an int 15 times, does it become negative? do bits drop off the top end? "
                    },
                    {
                        "username": "ishaandixit18",
                        "content": "Hey [@Andrei Paval](/Andrei-Paval), I solved the problem using multiple operations on multiple numbers . The ans was still same and the time complexity is O(n * k). I think that greedily multiplying every number results in an optimal solution as multiplying a number by 2 ,k times will give a large result as mentioned by [@Aman Saini](/aman1320)."
                    },
                    {
                        "username": "aman1320",
                        "content": "Multiplying single element k time will give more larger result."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@Lee_fan_Ak_The_Boss](/Lee_fan_Ak_The_Boss) I want this power to get such kind of intuition."
                    },
                    {
                        "username": "ishaandixit18",
                        "content": "Exactly, that is my doubt as well. Why can\\'t I apply two operations to two different numbers?"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "you have to store prefix and suffix bitwise or operation at each index....and then not need to do k operation just take n = 2**k and mulitply n with each element of nums and perform the bitwise OR operation using stored sufix and perfix array...and Done it"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "The Reason behind applying all the k operations on the same element is\\nshifting\\nat each operation we are shifting and hence the number doubles so it is beneficial to double the maximum number at a point because it will increase the required output.\\n\\nAs soon as you applied the opeartion once on an element it will become double and you should keep applying the same operation on it again and again till k so that you can get maximum of it.\\nI hope you got it ! \\u2764\\uFE0F\\u2764\\uFE0F"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "But why this approach is failing on one testcase.\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n, vector<long long>(k+1, -1));\\n        return solve(nums, n-1, k, dp);\\n    }\\n    \\n    long long solve(vector<int>& nums, int ind, int k, vector<vector<long long>>& dp){\\n        if(ind < 0) return 0;\\n        if(dp[ind][k] != -1)    return dp[ind][k];\\n            \\n        long long pick = -1, temp = nums[ind], p = k;\\n        while(p > 0){\\n            p--;\\n            temp = temp*2;\\n            pick = max(pick, (temp | solve(nums, ind-1, p, dp))); \\n        }\\n        long long notPick = (nums[ind] | solve(nums, ind-1, k, dp));\\n        return dp[ind][k] = max(pick, notPick);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "sylvex",
                        "content": "such a pain not come up with prefix solution...\\nI used priority queue , passed the first few cases, and it failed..."
                    },
                    {
                        "username": "ranjeet_kumar7",
                        "content": "can any one tell why it is applying the k operation on 1 index of example 1 means why not applying on 0 index if we are geting the maximum value 24+9=33"
                    },
                    {
                        "username": "nandunk",
                        "content": "then we will get 25 only"
                    },
                    {
                        "username": "gaurav621",
                        "content": "you have to calculate OR of elements not sum of elements.. and 24 | 9 = 25 "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Tricky one :)**\\n\\nI like it"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "why is the dp solution not correct?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@heisenberg_44](/heisenberg_44) Just a guess!"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "[@heisenberg280](/heisenberg280) hehe you got good taste.how did you know i was indian?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Hamare naam k saath saath stats be aage piche hai :xD"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "Can anyone tell me why this approach is failing.\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n, vector<long long>(k+1, -1));\\n        return solve(nums, n-1, k, dp);\\n    }\\n    \\n    long long solve(vector<int>& nums, int ind, int k, vector<vector<long long>>& dp){\\n        if(ind < 0) return 0;\\n        if(dp[ind][k] != -1)    return dp[ind][k];\\n            \\n        long long pick = -1, temp = nums[ind], p = k;\\n        while(p > 0){\\n            p--;\\n            temp = temp*2;\\n            pick = max(pick, (temp | solve(nums, ind-1, p, dp))); \\n        }\\n        long long notPick = (nums[ind] | solve(nums, ind-1, k, dp));\\n        return dp[ind][k] = max(pick, notPick);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "sleepingonee",
                        "content": "New testcase nums=[974,816] k=2 cancelled my contest result. Ouch"
                    },
                    {
                        "username": "annahung",
                        "content": "I can understand why we should apply all the k operations on the same element. \\nHowever, I cannot understand why iterating k times and each time find the max OR result will yield wrong answer...\\n\\nFor example:\\n[10, 11], k = 2\\n\\nThe correct answer is to operate on 11.\\n\\nBut if we iterating 2 times:\\nAt first time: \\noperate on 10:\\n10100\\n  1011\\n--------\\n11111\\n\\noperate on 11:\\n  1010\\n10110\\n-------\\n11110\\n\\nThen we will choose to operate at on 10. And this will yield a wrong answer....\\n"
                    },
                    {
                        "username": "MuditK_57",
                        "content": "Why my solution is giving wrong answer? \n\nclass Solution {\npublic:\n        \n\n    void update(vector<long long>& prefix,vector<long long>& suffix,vector<long long>& nums){\n        int n=nums.size();\n        for(int i=1;i<n;i++)\n            prefix[i]=nums[i-1]|prefix[i-1];\n        for(int i=n-2;i>=0;i--)\n            suffix[i]=suffix[i+1]|nums[i+1];\n        return ;\n    }\n    \n    long long maximumOr(vector<int>& num, int k) {\n        long long po=1;\n        long long x=2;\n        for(int i=1;i<=k;i++)\n            po*=x;\n        long long ans=0;\n        int n=num.size();\n        vector<long long>nums(n,0);\n        for(int i=0;i<n;i++)\n            nums[i]=num[i];\n        vector<long long>prefix(n,0),suffix(n,0);\n        for(int i=1;i<n;i++)\n            prefix[i]=nums[i-1]|prefix[i-1];\n        for(int i=n-2;i>=0;i--)\n            suffix[i]=suffix[i+1]|nums[i+1];\n        int pos=0;\n        long long m=LONG_MIN;\n        for(int i=0;i<n;i++){\n            long long temp=((nums[i]*2)|prefix[i])|suffix[i];\n            if(temp>m){\n                m=temp;\n                pos=i;\n            }\n        }\n        nums[pos]=nums[pos]*po;\n        for(int i=0;i<n;i++)\n            ans=ans|nums[i];\n        return ans;\n    }\n};\n"
                    }
                ]
            },
            {
                "id": 1895907,
                "content": [
                    {
                        "username": "Andrei-Paval",
                        "content": "Can someone explain why is it optimal to apply all the k operations on the same element? \\nWhy isn\\'t it possible, in some cases, to obtain a larger value for the bitwise OR of all the elements by distributing the operations on multiple elements?"
                    },
                    {
                        "username": "mciobanu",
                        "content": "[@daren](/daren) I looked at the description, thought a little, and started wondering how could this be a \"medium\" problem, as you can easily run into overflows and have many options to shift multiple numbers. Then I looked at the hints and they were \"obviously wrong\". Then I checked the discussions, which made me look at the signature, and I finally realized that the answer takes 64 bits. I feel that the description should have mentioned this and stand on its own, without you needing to check the signature. Am I wrong?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we will get left set bits "
                    },
                    {
                        "username": "gaurav621",
                        "content": "you only need to choose element which have left most set bit (so that you can left-shit that element k time and get max result), now you can get conflits like 9(1001) and 12(1100) and need to choose only one because once you perform left shift on it, it will be the left most set bit. So, now you need to perform rest (k-1) operation on that chosen element only.\n\nYou can solve this question with logic - (prefixOR | suffixOR | left most set bit elements * pow(2, k)) and take the max one."
                    },
                    {
                        "username": "daren",
                        "content": "i think it becomes obvious if they set the signature of the C++ function as:\n\nlong long maximumOr(vector \\<long long\\>& nums, int k)\n\notherwise its not clear, if you shift an int 15 times, does it become negative? do bits drop off the top end? "
                    },
                    {
                        "username": "ishaandixit18",
                        "content": "Hey [@Andrei Paval](/Andrei-Paval), I solved the problem using multiple operations on multiple numbers . The ans was still same and the time complexity is O(n * k). I think that greedily multiplying every number results in an optimal solution as multiplying a number by 2 ,k times will give a large result as mentioned by [@Aman Saini](/aman1320)."
                    },
                    {
                        "username": "aman1320",
                        "content": "Multiplying single element k time will give more larger result."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@Lee_fan_Ak_The_Boss](/Lee_fan_Ak_The_Boss) I want this power to get such kind of intuition."
                    },
                    {
                        "username": "ishaandixit18",
                        "content": "Exactly, that is my doubt as well. Why can\\'t I apply two operations to two different numbers?"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "you have to store prefix and suffix bitwise or operation at each index....and then not need to do k operation just take n = 2**k and mulitply n with each element of nums and perform the bitwise OR operation using stored sufix and perfix array...and Done it"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "The Reason behind applying all the k operations on the same element is\\nshifting\\nat each operation we are shifting and hence the number doubles so it is beneficial to double the maximum number at a point because it will increase the required output.\\n\\nAs soon as you applied the opeartion once on an element it will become double and you should keep applying the same operation on it again and again till k so that you can get maximum of it.\\nI hope you got it ! \\u2764\\uFE0F\\u2764\\uFE0F"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "But why this approach is failing on one testcase.\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n, vector<long long>(k+1, -1));\\n        return solve(nums, n-1, k, dp);\\n    }\\n    \\n    long long solve(vector<int>& nums, int ind, int k, vector<vector<long long>>& dp){\\n        if(ind < 0) return 0;\\n        if(dp[ind][k] != -1)    return dp[ind][k];\\n            \\n        long long pick = -1, temp = nums[ind], p = k;\\n        while(p > 0){\\n            p--;\\n            temp = temp*2;\\n            pick = max(pick, (temp | solve(nums, ind-1, p, dp))); \\n        }\\n        long long notPick = (nums[ind] | solve(nums, ind-1, k, dp));\\n        return dp[ind][k] = max(pick, notPick);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "sylvex",
                        "content": "such a pain not come up with prefix solution...\\nI used priority queue , passed the first few cases, and it failed..."
                    },
                    {
                        "username": "ranjeet_kumar7",
                        "content": "can any one tell why it is applying the k operation on 1 index of example 1 means why not applying on 0 index if we are geting the maximum value 24+9=33"
                    },
                    {
                        "username": "nandunk",
                        "content": "then we will get 25 only"
                    },
                    {
                        "username": "gaurav621",
                        "content": "you have to calculate OR of elements not sum of elements.. and 24 | 9 = 25 "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Tricky one :)**\\n\\nI like it"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "why is the dp solution not correct?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@heisenberg_44](/heisenberg_44) Just a guess!"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "[@heisenberg280](/heisenberg280) hehe you got good taste.how did you know i was indian?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Hamare naam k saath saath stats be aage piche hai :xD"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "Can anyone tell me why this approach is failing.\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n, vector<long long>(k+1, -1));\\n        return solve(nums, n-1, k, dp);\\n    }\\n    \\n    long long solve(vector<int>& nums, int ind, int k, vector<vector<long long>>& dp){\\n        if(ind < 0) return 0;\\n        if(dp[ind][k] != -1)    return dp[ind][k];\\n            \\n        long long pick = -1, temp = nums[ind], p = k;\\n        while(p > 0){\\n            p--;\\n            temp = temp*2;\\n            pick = max(pick, (temp | solve(nums, ind-1, p, dp))); \\n        }\\n        long long notPick = (nums[ind] | solve(nums, ind-1, k, dp));\\n        return dp[ind][k] = max(pick, notPick);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "sleepingonee",
                        "content": "New testcase nums=[974,816] k=2 cancelled my contest result. Ouch"
                    },
                    {
                        "username": "annahung",
                        "content": "I can understand why we should apply all the k operations on the same element. \\nHowever, I cannot understand why iterating k times and each time find the max OR result will yield wrong answer...\\n\\nFor example:\\n[10, 11], k = 2\\n\\nThe correct answer is to operate on 11.\\n\\nBut if we iterating 2 times:\\nAt first time: \\noperate on 10:\\n10100\\n  1011\\n--------\\n11111\\n\\noperate on 11:\\n  1010\\n10110\\n-------\\n11110\\n\\nThen we will choose to operate at on 10. And this will yield a wrong answer....\\n"
                    },
                    {
                        "username": "MuditK_57",
                        "content": "Why my solution is giving wrong answer? \n\nclass Solution {\npublic:\n        \n\n    void update(vector<long long>& prefix,vector<long long>& suffix,vector<long long>& nums){\n        int n=nums.size();\n        for(int i=1;i<n;i++)\n            prefix[i]=nums[i-1]|prefix[i-1];\n        for(int i=n-2;i>=0;i--)\n            suffix[i]=suffix[i+1]|nums[i+1];\n        return ;\n    }\n    \n    long long maximumOr(vector<int>& num, int k) {\n        long long po=1;\n        long long x=2;\n        for(int i=1;i<=k;i++)\n            po*=x;\n        long long ans=0;\n        int n=num.size();\n        vector<long long>nums(n,0);\n        for(int i=0;i<n;i++)\n            nums[i]=num[i];\n        vector<long long>prefix(n,0),suffix(n,0);\n        for(int i=1;i<n;i++)\n            prefix[i]=nums[i-1]|prefix[i-1];\n        for(int i=n-2;i>=0;i--)\n            suffix[i]=suffix[i+1]|nums[i+1];\n        int pos=0;\n        long long m=LONG_MIN;\n        for(int i=0;i<n;i++){\n            long long temp=((nums[i]*2)|prefix[i])|suffix[i];\n            if(temp>m){\n                m=temp;\n                pos=i;\n            }\n        }\n        nums[pos]=nums[pos]*po;\n        for(int i=0;i<n;i++)\n            ans=ans|nums[i];\n        return ans;\n    }\n};\n"
                    }
                ]
            },
            {
                "id": 1894706,
                "content": [
                    {
                        "username": "Andrei-Paval",
                        "content": "Can someone explain why is it optimal to apply all the k operations on the same element? \\nWhy isn\\'t it possible, in some cases, to obtain a larger value for the bitwise OR of all the elements by distributing the operations on multiple elements?"
                    },
                    {
                        "username": "mciobanu",
                        "content": "[@daren](/daren) I looked at the description, thought a little, and started wondering how could this be a \"medium\" problem, as you can easily run into overflows and have many options to shift multiple numbers. Then I looked at the hints and they were \"obviously wrong\". Then I checked the discussions, which made me look at the signature, and I finally realized that the answer takes 64 bits. I feel that the description should have mentioned this and stand on its own, without you needing to check the signature. Am I wrong?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we will get left set bits "
                    },
                    {
                        "username": "gaurav621",
                        "content": "you only need to choose element which have left most set bit (so that you can left-shit that element k time and get max result), now you can get conflits like 9(1001) and 12(1100) and need to choose only one because once you perform left shift on it, it will be the left most set bit. So, now you need to perform rest (k-1) operation on that chosen element only.\n\nYou can solve this question with logic - (prefixOR | suffixOR | left most set bit elements * pow(2, k)) and take the max one."
                    },
                    {
                        "username": "daren",
                        "content": "i think it becomes obvious if they set the signature of the C++ function as:\n\nlong long maximumOr(vector \\<long long\\>& nums, int k)\n\notherwise its not clear, if you shift an int 15 times, does it become negative? do bits drop off the top end? "
                    },
                    {
                        "username": "ishaandixit18",
                        "content": "Hey [@Andrei Paval](/Andrei-Paval), I solved the problem using multiple operations on multiple numbers . The ans was still same and the time complexity is O(n * k). I think that greedily multiplying every number results in an optimal solution as multiplying a number by 2 ,k times will give a large result as mentioned by [@Aman Saini](/aman1320)."
                    },
                    {
                        "username": "aman1320",
                        "content": "Multiplying single element k time will give more larger result."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@Lee_fan_Ak_The_Boss](/Lee_fan_Ak_The_Boss) I want this power to get such kind of intuition."
                    },
                    {
                        "username": "ishaandixit18",
                        "content": "Exactly, that is my doubt as well. Why can\\'t I apply two operations to two different numbers?"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "you have to store prefix and suffix bitwise or operation at each index....and then not need to do k operation just take n = 2**k and mulitply n with each element of nums and perform the bitwise OR operation using stored sufix and perfix array...and Done it"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "The Reason behind applying all the k operations on the same element is\\nshifting\\nat each operation we are shifting and hence the number doubles so it is beneficial to double the maximum number at a point because it will increase the required output.\\n\\nAs soon as you applied the opeartion once on an element it will become double and you should keep applying the same operation on it again and again till k so that you can get maximum of it.\\nI hope you got it ! \\u2764\\uFE0F\\u2764\\uFE0F"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "But why this approach is failing on one testcase.\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n, vector<long long>(k+1, -1));\\n        return solve(nums, n-1, k, dp);\\n    }\\n    \\n    long long solve(vector<int>& nums, int ind, int k, vector<vector<long long>>& dp){\\n        if(ind < 0) return 0;\\n        if(dp[ind][k] != -1)    return dp[ind][k];\\n            \\n        long long pick = -1, temp = nums[ind], p = k;\\n        while(p > 0){\\n            p--;\\n            temp = temp*2;\\n            pick = max(pick, (temp | solve(nums, ind-1, p, dp))); \\n        }\\n        long long notPick = (nums[ind] | solve(nums, ind-1, k, dp));\\n        return dp[ind][k] = max(pick, notPick);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "sylvex",
                        "content": "such a pain not come up with prefix solution...\\nI used priority queue , passed the first few cases, and it failed..."
                    },
                    {
                        "username": "ranjeet_kumar7",
                        "content": "can any one tell why it is applying the k operation on 1 index of example 1 means why not applying on 0 index if we are geting the maximum value 24+9=33"
                    },
                    {
                        "username": "nandunk",
                        "content": "then we will get 25 only"
                    },
                    {
                        "username": "gaurav621",
                        "content": "you have to calculate OR of elements not sum of elements.. and 24 | 9 = 25 "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Tricky one :)**\\n\\nI like it"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "why is the dp solution not correct?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@heisenberg_44](/heisenberg_44) Just a guess!"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "[@heisenberg280](/heisenberg280) hehe you got good taste.how did you know i was indian?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Hamare naam k saath saath stats be aage piche hai :xD"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "Can anyone tell me why this approach is failing.\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n, vector<long long>(k+1, -1));\\n        return solve(nums, n-1, k, dp);\\n    }\\n    \\n    long long solve(vector<int>& nums, int ind, int k, vector<vector<long long>>& dp){\\n        if(ind < 0) return 0;\\n        if(dp[ind][k] != -1)    return dp[ind][k];\\n            \\n        long long pick = -1, temp = nums[ind], p = k;\\n        while(p > 0){\\n            p--;\\n            temp = temp*2;\\n            pick = max(pick, (temp | solve(nums, ind-1, p, dp))); \\n        }\\n        long long notPick = (nums[ind] | solve(nums, ind-1, k, dp));\\n        return dp[ind][k] = max(pick, notPick);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "sleepingonee",
                        "content": "New testcase nums=[974,816] k=2 cancelled my contest result. Ouch"
                    },
                    {
                        "username": "annahung",
                        "content": "I can understand why we should apply all the k operations on the same element. \\nHowever, I cannot understand why iterating k times and each time find the max OR result will yield wrong answer...\\n\\nFor example:\\n[10, 11], k = 2\\n\\nThe correct answer is to operate on 11.\\n\\nBut if we iterating 2 times:\\nAt first time: \\noperate on 10:\\n10100\\n  1011\\n--------\\n11111\\n\\noperate on 11:\\n  1010\\n10110\\n-------\\n11110\\n\\nThen we will choose to operate at on 10. And this will yield a wrong answer....\\n"
                    },
                    {
                        "username": "MuditK_57",
                        "content": "Why my solution is giving wrong answer? \n\nclass Solution {\npublic:\n        \n\n    void update(vector<long long>& prefix,vector<long long>& suffix,vector<long long>& nums){\n        int n=nums.size();\n        for(int i=1;i<n;i++)\n            prefix[i]=nums[i-1]|prefix[i-1];\n        for(int i=n-2;i>=0;i--)\n            suffix[i]=suffix[i+1]|nums[i+1];\n        return ;\n    }\n    \n    long long maximumOr(vector<int>& num, int k) {\n        long long po=1;\n        long long x=2;\n        for(int i=1;i<=k;i++)\n            po*=x;\n        long long ans=0;\n        int n=num.size();\n        vector<long long>nums(n,0);\n        for(int i=0;i<n;i++)\n            nums[i]=num[i];\n        vector<long long>prefix(n,0),suffix(n,0);\n        for(int i=1;i<n;i++)\n            prefix[i]=nums[i-1]|prefix[i-1];\n        for(int i=n-2;i>=0;i--)\n            suffix[i]=suffix[i+1]|nums[i+1];\n        int pos=0;\n        long long m=LONG_MIN;\n        for(int i=0;i<n;i++){\n            long long temp=((nums[i]*2)|prefix[i])|suffix[i];\n            if(temp>m){\n                m=temp;\n                pos=i;\n            }\n        }\n        nums[pos]=nums[pos]*po;\n        for(int i=0;i<n;i++)\n            ans=ans|nums[i];\n        return ans;\n    }\n};\n"
                    }
                ]
            },
            {
                "id": 1893311,
                "content": [
                    {
                        "username": "Andrei-Paval",
                        "content": "Can someone explain why is it optimal to apply all the k operations on the same element? \\nWhy isn\\'t it possible, in some cases, to obtain a larger value for the bitwise OR of all the elements by distributing the operations on multiple elements?"
                    },
                    {
                        "username": "mciobanu",
                        "content": "[@daren](/daren) I looked at the description, thought a little, and started wondering how could this be a \"medium\" problem, as you can easily run into overflows and have many options to shift multiple numbers. Then I looked at the hints and they were \"obviously wrong\". Then I checked the discussions, which made me look at the signature, and I finally realized that the answer takes 64 bits. I feel that the description should have mentioned this and stand on its own, without you needing to check the signature. Am I wrong?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we will get left set bits "
                    },
                    {
                        "username": "gaurav621",
                        "content": "you only need to choose element which have left most set bit (so that you can left-shit that element k time and get max result), now you can get conflits like 9(1001) and 12(1100) and need to choose only one because once you perform left shift on it, it will be the left most set bit. So, now you need to perform rest (k-1) operation on that chosen element only.\n\nYou can solve this question with logic - (prefixOR | suffixOR | left most set bit elements * pow(2, k)) and take the max one."
                    },
                    {
                        "username": "daren",
                        "content": "i think it becomes obvious if they set the signature of the C++ function as:\n\nlong long maximumOr(vector \\<long long\\>& nums, int k)\n\notherwise its not clear, if you shift an int 15 times, does it become negative? do bits drop off the top end? "
                    },
                    {
                        "username": "ishaandixit18",
                        "content": "Hey [@Andrei Paval](/Andrei-Paval), I solved the problem using multiple operations on multiple numbers . The ans was still same and the time complexity is O(n * k). I think that greedily multiplying every number results in an optimal solution as multiplying a number by 2 ,k times will give a large result as mentioned by [@Aman Saini](/aman1320)."
                    },
                    {
                        "username": "aman1320",
                        "content": "Multiplying single element k time will give more larger result."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@Lee_fan_Ak_The_Boss](/Lee_fan_Ak_The_Boss) I want this power to get such kind of intuition."
                    },
                    {
                        "username": "ishaandixit18",
                        "content": "Exactly, that is my doubt as well. Why can\\'t I apply two operations to two different numbers?"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "you have to store prefix and suffix bitwise or operation at each index....and then not need to do k operation just take n = 2**k and mulitply n with each element of nums and perform the bitwise OR operation using stored sufix and perfix array...and Done it"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "The Reason behind applying all the k operations on the same element is\\nshifting\\nat each operation we are shifting and hence the number doubles so it is beneficial to double the maximum number at a point because it will increase the required output.\\n\\nAs soon as you applied the opeartion once on an element it will become double and you should keep applying the same operation on it again and again till k so that you can get maximum of it.\\nI hope you got it ! \\u2764\\uFE0F\\u2764\\uFE0F"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "But why this approach is failing on one testcase.\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n, vector<long long>(k+1, -1));\\n        return solve(nums, n-1, k, dp);\\n    }\\n    \\n    long long solve(vector<int>& nums, int ind, int k, vector<vector<long long>>& dp){\\n        if(ind < 0) return 0;\\n        if(dp[ind][k] != -1)    return dp[ind][k];\\n            \\n        long long pick = -1, temp = nums[ind], p = k;\\n        while(p > 0){\\n            p--;\\n            temp = temp*2;\\n            pick = max(pick, (temp | solve(nums, ind-1, p, dp))); \\n        }\\n        long long notPick = (nums[ind] | solve(nums, ind-1, k, dp));\\n        return dp[ind][k] = max(pick, notPick);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "sylvex",
                        "content": "such a pain not come up with prefix solution...\\nI used priority queue , passed the first few cases, and it failed..."
                    },
                    {
                        "username": "ranjeet_kumar7",
                        "content": "can any one tell why it is applying the k operation on 1 index of example 1 means why not applying on 0 index if we are geting the maximum value 24+9=33"
                    },
                    {
                        "username": "nandunk",
                        "content": "then we will get 25 only"
                    },
                    {
                        "username": "gaurav621",
                        "content": "you have to calculate OR of elements not sum of elements.. and 24 | 9 = 25 "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Tricky one :)**\\n\\nI like it"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "why is the dp solution not correct?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@heisenberg_44](/heisenberg_44) Just a guess!"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "[@heisenberg280](/heisenberg280) hehe you got good taste.how did you know i was indian?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Hamare naam k saath saath stats be aage piche hai :xD"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "Can anyone tell me why this approach is failing.\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n, vector<long long>(k+1, -1));\\n        return solve(nums, n-1, k, dp);\\n    }\\n    \\n    long long solve(vector<int>& nums, int ind, int k, vector<vector<long long>>& dp){\\n        if(ind < 0) return 0;\\n        if(dp[ind][k] != -1)    return dp[ind][k];\\n            \\n        long long pick = -1, temp = nums[ind], p = k;\\n        while(p > 0){\\n            p--;\\n            temp = temp*2;\\n            pick = max(pick, (temp | solve(nums, ind-1, p, dp))); \\n        }\\n        long long notPick = (nums[ind] | solve(nums, ind-1, k, dp));\\n        return dp[ind][k] = max(pick, notPick);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "sleepingonee",
                        "content": "New testcase nums=[974,816] k=2 cancelled my contest result. Ouch"
                    },
                    {
                        "username": "annahung",
                        "content": "I can understand why we should apply all the k operations on the same element. \\nHowever, I cannot understand why iterating k times and each time find the max OR result will yield wrong answer...\\n\\nFor example:\\n[10, 11], k = 2\\n\\nThe correct answer is to operate on 11.\\n\\nBut if we iterating 2 times:\\nAt first time: \\noperate on 10:\\n10100\\n  1011\\n--------\\n11111\\n\\noperate on 11:\\n  1010\\n10110\\n-------\\n11110\\n\\nThen we will choose to operate at on 10. And this will yield a wrong answer....\\n"
                    },
                    {
                        "username": "MuditK_57",
                        "content": "Why my solution is giving wrong answer? \n\nclass Solution {\npublic:\n        \n\n    void update(vector<long long>& prefix,vector<long long>& suffix,vector<long long>& nums){\n        int n=nums.size();\n        for(int i=1;i<n;i++)\n            prefix[i]=nums[i-1]|prefix[i-1];\n        for(int i=n-2;i>=0;i--)\n            suffix[i]=suffix[i+1]|nums[i+1];\n        return ;\n    }\n    \n    long long maximumOr(vector<int>& num, int k) {\n        long long po=1;\n        long long x=2;\n        for(int i=1;i<=k;i++)\n            po*=x;\n        long long ans=0;\n        int n=num.size();\n        vector<long long>nums(n,0);\n        for(int i=0;i<n;i++)\n            nums[i]=num[i];\n        vector<long long>prefix(n,0),suffix(n,0);\n        for(int i=1;i<n;i++)\n            prefix[i]=nums[i-1]|prefix[i-1];\n        for(int i=n-2;i>=0;i--)\n            suffix[i]=suffix[i+1]|nums[i+1];\n        int pos=0;\n        long long m=LONG_MIN;\n        for(int i=0;i<n;i++){\n            long long temp=((nums[i]*2)|prefix[i])|suffix[i];\n            if(temp>m){\n                m=temp;\n                pos=i;\n            }\n        }\n        nums[pos]=nums[pos]*po;\n        for(int i=0;i<n;i++)\n            ans=ans|nums[i];\n        return ans;\n    }\n};\n"
                    }
                ]
            },
            {
                "id": 1892515,
                "content": [
                    {
                        "username": "Andrei-Paval",
                        "content": "Can someone explain why is it optimal to apply all the k operations on the same element? \\nWhy isn\\'t it possible, in some cases, to obtain a larger value for the bitwise OR of all the elements by distributing the operations on multiple elements?"
                    },
                    {
                        "username": "mciobanu",
                        "content": "[@daren](/daren) I looked at the description, thought a little, and started wondering how could this be a \"medium\" problem, as you can easily run into overflows and have many options to shift multiple numbers. Then I looked at the hints and they were \"obviously wrong\". Then I checked the discussions, which made me look at the signature, and I finally realized that the answer takes 64 bits. I feel that the description should have mentioned this and stand on its own, without you needing to check the signature. Am I wrong?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we will get left set bits "
                    },
                    {
                        "username": "gaurav621",
                        "content": "you only need to choose element which have left most set bit (so that you can left-shit that element k time and get max result), now you can get conflits like 9(1001) and 12(1100) and need to choose only one because once you perform left shift on it, it will be the left most set bit. So, now you need to perform rest (k-1) operation on that chosen element only.\n\nYou can solve this question with logic - (prefixOR | suffixOR | left most set bit elements * pow(2, k)) and take the max one."
                    },
                    {
                        "username": "daren",
                        "content": "i think it becomes obvious if they set the signature of the C++ function as:\n\nlong long maximumOr(vector \\<long long\\>& nums, int k)\n\notherwise its not clear, if you shift an int 15 times, does it become negative? do bits drop off the top end? "
                    },
                    {
                        "username": "ishaandixit18",
                        "content": "Hey [@Andrei Paval](/Andrei-Paval), I solved the problem using multiple operations on multiple numbers . The ans was still same and the time complexity is O(n * k). I think that greedily multiplying every number results in an optimal solution as multiplying a number by 2 ,k times will give a large result as mentioned by [@Aman Saini](/aman1320)."
                    },
                    {
                        "username": "aman1320",
                        "content": "Multiplying single element k time will give more larger result."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@Lee_fan_Ak_The_Boss](/Lee_fan_Ak_The_Boss) I want this power to get such kind of intuition."
                    },
                    {
                        "username": "ishaandixit18",
                        "content": "Exactly, that is my doubt as well. Why can\\'t I apply two operations to two different numbers?"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "you have to store prefix and suffix bitwise or operation at each index....and then not need to do k operation just take n = 2**k and mulitply n with each element of nums and perform the bitwise OR operation using stored sufix and perfix array...and Done it"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "The Reason behind applying all the k operations on the same element is\\nshifting\\nat each operation we are shifting and hence the number doubles so it is beneficial to double the maximum number at a point because it will increase the required output.\\n\\nAs soon as you applied the opeartion once on an element it will become double and you should keep applying the same operation on it again and again till k so that you can get maximum of it.\\nI hope you got it ! \\u2764\\uFE0F\\u2764\\uFE0F"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "But why this approach is failing on one testcase.\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n, vector<long long>(k+1, -1));\\n        return solve(nums, n-1, k, dp);\\n    }\\n    \\n    long long solve(vector<int>& nums, int ind, int k, vector<vector<long long>>& dp){\\n        if(ind < 0) return 0;\\n        if(dp[ind][k] != -1)    return dp[ind][k];\\n            \\n        long long pick = -1, temp = nums[ind], p = k;\\n        while(p > 0){\\n            p--;\\n            temp = temp*2;\\n            pick = max(pick, (temp | solve(nums, ind-1, p, dp))); \\n        }\\n        long long notPick = (nums[ind] | solve(nums, ind-1, k, dp));\\n        return dp[ind][k] = max(pick, notPick);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "sylvex",
                        "content": "such a pain not come up with prefix solution...\\nI used priority queue , passed the first few cases, and it failed..."
                    },
                    {
                        "username": "ranjeet_kumar7",
                        "content": "can any one tell why it is applying the k operation on 1 index of example 1 means why not applying on 0 index if we are geting the maximum value 24+9=33"
                    },
                    {
                        "username": "nandunk",
                        "content": "then we will get 25 only"
                    },
                    {
                        "username": "gaurav621",
                        "content": "you have to calculate OR of elements not sum of elements.. and 24 | 9 = 25 "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Tricky one :)**\\n\\nI like it"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "why is the dp solution not correct?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@heisenberg_44](/heisenberg_44) Just a guess!"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "[@heisenberg280](/heisenberg280) hehe you got good taste.how did you know i was indian?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Hamare naam k saath saath stats be aage piche hai :xD"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "Can anyone tell me why this approach is failing.\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n, vector<long long>(k+1, -1));\\n        return solve(nums, n-1, k, dp);\\n    }\\n    \\n    long long solve(vector<int>& nums, int ind, int k, vector<vector<long long>>& dp){\\n        if(ind < 0) return 0;\\n        if(dp[ind][k] != -1)    return dp[ind][k];\\n            \\n        long long pick = -1, temp = nums[ind], p = k;\\n        while(p > 0){\\n            p--;\\n            temp = temp*2;\\n            pick = max(pick, (temp | solve(nums, ind-1, p, dp))); \\n        }\\n        long long notPick = (nums[ind] | solve(nums, ind-1, k, dp));\\n        return dp[ind][k] = max(pick, notPick);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "sleepingonee",
                        "content": "New testcase nums=[974,816] k=2 cancelled my contest result. Ouch"
                    },
                    {
                        "username": "annahung",
                        "content": "I can understand why we should apply all the k operations on the same element. \\nHowever, I cannot understand why iterating k times and each time find the max OR result will yield wrong answer...\\n\\nFor example:\\n[10, 11], k = 2\\n\\nThe correct answer is to operate on 11.\\n\\nBut if we iterating 2 times:\\nAt first time: \\noperate on 10:\\n10100\\n  1011\\n--------\\n11111\\n\\noperate on 11:\\n  1010\\n10110\\n-------\\n11110\\n\\nThen we will choose to operate at on 10. And this will yield a wrong answer....\\n"
                    },
                    {
                        "username": "MuditK_57",
                        "content": "Why my solution is giving wrong answer? \n\nclass Solution {\npublic:\n        \n\n    void update(vector<long long>& prefix,vector<long long>& suffix,vector<long long>& nums){\n        int n=nums.size();\n        for(int i=1;i<n;i++)\n            prefix[i]=nums[i-1]|prefix[i-1];\n        for(int i=n-2;i>=0;i--)\n            suffix[i]=suffix[i+1]|nums[i+1];\n        return ;\n    }\n    \n    long long maximumOr(vector<int>& num, int k) {\n        long long po=1;\n        long long x=2;\n        for(int i=1;i<=k;i++)\n            po*=x;\n        long long ans=0;\n        int n=num.size();\n        vector<long long>nums(n,0);\n        for(int i=0;i<n;i++)\n            nums[i]=num[i];\n        vector<long long>prefix(n,0),suffix(n,0);\n        for(int i=1;i<n;i++)\n            prefix[i]=nums[i-1]|prefix[i-1];\n        for(int i=n-2;i>=0;i--)\n            suffix[i]=suffix[i+1]|nums[i+1];\n        int pos=0;\n        long long m=LONG_MIN;\n        for(int i=0;i<n;i++){\n            long long temp=((nums[i]*2)|prefix[i])|suffix[i];\n            if(temp>m){\n                m=temp;\n                pos=i;\n            }\n        }\n        nums[pos]=nums[pos]*po;\n        for(int i=0;i<n;i++)\n            ans=ans|nums[i];\n        return ans;\n    }\n};\n"
                    }
                ]
            },
            {
                "id": 1892741,
                "content": [
                    {
                        "username": "Andrei-Paval",
                        "content": "Can someone explain why is it optimal to apply all the k operations on the same element? \\nWhy isn\\'t it possible, in some cases, to obtain a larger value for the bitwise OR of all the elements by distributing the operations on multiple elements?"
                    },
                    {
                        "username": "mciobanu",
                        "content": "[@daren](/daren) I looked at the description, thought a little, and started wondering how could this be a \"medium\" problem, as you can easily run into overflows and have many options to shift multiple numbers. Then I looked at the hints and they were \"obviously wrong\". Then I checked the discussions, which made me look at the signature, and I finally realized that the answer takes 64 bits. I feel that the description should have mentioned this and stand on its own, without you needing to check the signature. Am I wrong?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we will get left set bits "
                    },
                    {
                        "username": "gaurav621",
                        "content": "you only need to choose element which have left most set bit (so that you can left-shit that element k time and get max result), now you can get conflits like 9(1001) and 12(1100) and need to choose only one because once you perform left shift on it, it will be the left most set bit. So, now you need to perform rest (k-1) operation on that chosen element only.\n\nYou can solve this question with logic - (prefixOR | suffixOR | left most set bit elements * pow(2, k)) and take the max one."
                    },
                    {
                        "username": "daren",
                        "content": "i think it becomes obvious if they set the signature of the C++ function as:\n\nlong long maximumOr(vector \\<long long\\>& nums, int k)\n\notherwise its not clear, if you shift an int 15 times, does it become negative? do bits drop off the top end? "
                    },
                    {
                        "username": "ishaandixit18",
                        "content": "Hey [@Andrei Paval](/Andrei-Paval), I solved the problem using multiple operations on multiple numbers . The ans was still same and the time complexity is O(n * k). I think that greedily multiplying every number results in an optimal solution as multiplying a number by 2 ,k times will give a large result as mentioned by [@Aman Saini](/aman1320)."
                    },
                    {
                        "username": "aman1320",
                        "content": "Multiplying single element k time will give more larger result."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@Lee_fan_Ak_The_Boss](/Lee_fan_Ak_The_Boss) I want this power to get such kind of intuition."
                    },
                    {
                        "username": "ishaandixit18",
                        "content": "Exactly, that is my doubt as well. Why can\\'t I apply two operations to two different numbers?"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "you have to store prefix and suffix bitwise or operation at each index....and then not need to do k operation just take n = 2**k and mulitply n with each element of nums and perform the bitwise OR operation using stored sufix and perfix array...and Done it"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "The Reason behind applying all the k operations on the same element is\\nshifting\\nat each operation we are shifting and hence the number doubles so it is beneficial to double the maximum number at a point because it will increase the required output.\\n\\nAs soon as you applied the opeartion once on an element it will become double and you should keep applying the same operation on it again and again till k so that you can get maximum of it.\\nI hope you got it ! \\u2764\\uFE0F\\u2764\\uFE0F"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "But why this approach is failing on one testcase.\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n, vector<long long>(k+1, -1));\\n        return solve(nums, n-1, k, dp);\\n    }\\n    \\n    long long solve(vector<int>& nums, int ind, int k, vector<vector<long long>>& dp){\\n        if(ind < 0) return 0;\\n        if(dp[ind][k] != -1)    return dp[ind][k];\\n            \\n        long long pick = -1, temp = nums[ind], p = k;\\n        while(p > 0){\\n            p--;\\n            temp = temp*2;\\n            pick = max(pick, (temp | solve(nums, ind-1, p, dp))); \\n        }\\n        long long notPick = (nums[ind] | solve(nums, ind-1, k, dp));\\n        return dp[ind][k] = max(pick, notPick);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "sylvex",
                        "content": "such a pain not come up with prefix solution...\\nI used priority queue , passed the first few cases, and it failed..."
                    },
                    {
                        "username": "ranjeet_kumar7",
                        "content": "can any one tell why it is applying the k operation on 1 index of example 1 means why not applying on 0 index if we are geting the maximum value 24+9=33"
                    },
                    {
                        "username": "nandunk",
                        "content": "then we will get 25 only"
                    },
                    {
                        "username": "gaurav621",
                        "content": "you have to calculate OR of elements not sum of elements.. and 24 | 9 = 25 "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Tricky one :)**\\n\\nI like it"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "why is the dp solution not correct?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@heisenberg_44](/heisenberg_44) Just a guess!"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "[@heisenberg280](/heisenberg280) hehe you got good taste.how did you know i was indian?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Hamare naam k saath saath stats be aage piche hai :xD"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "Can anyone tell me why this approach is failing.\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n, vector<long long>(k+1, -1));\\n        return solve(nums, n-1, k, dp);\\n    }\\n    \\n    long long solve(vector<int>& nums, int ind, int k, vector<vector<long long>>& dp){\\n        if(ind < 0) return 0;\\n        if(dp[ind][k] != -1)    return dp[ind][k];\\n            \\n        long long pick = -1, temp = nums[ind], p = k;\\n        while(p > 0){\\n            p--;\\n            temp = temp*2;\\n            pick = max(pick, (temp | solve(nums, ind-1, p, dp))); \\n        }\\n        long long notPick = (nums[ind] | solve(nums, ind-1, k, dp));\\n        return dp[ind][k] = max(pick, notPick);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "sleepingonee",
                        "content": "New testcase nums=[974,816] k=2 cancelled my contest result. Ouch"
                    },
                    {
                        "username": "annahung",
                        "content": "I can understand why we should apply all the k operations on the same element. \\nHowever, I cannot understand why iterating k times and each time find the max OR result will yield wrong answer...\\n\\nFor example:\\n[10, 11], k = 2\\n\\nThe correct answer is to operate on 11.\\n\\nBut if we iterating 2 times:\\nAt first time: \\noperate on 10:\\n10100\\n  1011\\n--------\\n11111\\n\\noperate on 11:\\n  1010\\n10110\\n-------\\n11110\\n\\nThen we will choose to operate at on 10. And this will yield a wrong answer....\\n"
                    },
                    {
                        "username": "MuditK_57",
                        "content": "Why my solution is giving wrong answer? \n\nclass Solution {\npublic:\n        \n\n    void update(vector<long long>& prefix,vector<long long>& suffix,vector<long long>& nums){\n        int n=nums.size();\n        for(int i=1;i<n;i++)\n            prefix[i]=nums[i-1]|prefix[i-1];\n        for(int i=n-2;i>=0;i--)\n            suffix[i]=suffix[i+1]|nums[i+1];\n        return ;\n    }\n    \n    long long maximumOr(vector<int>& num, int k) {\n        long long po=1;\n        long long x=2;\n        for(int i=1;i<=k;i++)\n            po*=x;\n        long long ans=0;\n        int n=num.size();\n        vector<long long>nums(n,0);\n        for(int i=0;i<n;i++)\n            nums[i]=num[i];\n        vector<long long>prefix(n,0),suffix(n,0);\n        for(int i=1;i<n;i++)\n            prefix[i]=nums[i-1]|prefix[i-1];\n        for(int i=n-2;i>=0;i--)\n            suffix[i]=suffix[i+1]|nums[i+1];\n        int pos=0;\n        long long m=LONG_MIN;\n        for(int i=0;i<n;i++){\n            long long temp=((nums[i]*2)|prefix[i])|suffix[i];\n            if(temp>m){\n                m=temp;\n                pos=i;\n            }\n        }\n        nums[pos]=nums[pos]*po;\n        for(int i=0;i<n;i++)\n            ans=ans|nums[i];\n        return ans;\n    }\n};\n"
                    }
                ]
            },
            {
                "id": 1892460,
                "content": [
                    {
                        "username": "Andrei-Paval",
                        "content": "Can someone explain why is it optimal to apply all the k operations on the same element? \\nWhy isn\\'t it possible, in some cases, to obtain a larger value for the bitwise OR of all the elements by distributing the operations on multiple elements?"
                    },
                    {
                        "username": "mciobanu",
                        "content": "[@daren](/daren) I looked at the description, thought a little, and started wondering how could this be a \"medium\" problem, as you can easily run into overflows and have many options to shift multiple numbers. Then I looked at the hints and they were \"obviously wrong\". Then I checked the discussions, which made me look at the signature, and I finally realized that the answer takes 64 bits. I feel that the description should have mentioned this and stand on its own, without you needing to check the signature. Am I wrong?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we will get left set bits "
                    },
                    {
                        "username": "gaurav621",
                        "content": "you only need to choose element which have left most set bit (so that you can left-shit that element k time and get max result), now you can get conflits like 9(1001) and 12(1100) and need to choose only one because once you perform left shift on it, it will be the left most set bit. So, now you need to perform rest (k-1) operation on that chosen element only.\n\nYou can solve this question with logic - (prefixOR | suffixOR | left most set bit elements * pow(2, k)) and take the max one."
                    },
                    {
                        "username": "daren",
                        "content": "i think it becomes obvious if they set the signature of the C++ function as:\n\nlong long maximumOr(vector \\<long long\\>& nums, int k)\n\notherwise its not clear, if you shift an int 15 times, does it become negative? do bits drop off the top end? "
                    },
                    {
                        "username": "ishaandixit18",
                        "content": "Hey [@Andrei Paval](/Andrei-Paval), I solved the problem using multiple operations on multiple numbers . The ans was still same and the time complexity is O(n * k). I think that greedily multiplying every number results in an optimal solution as multiplying a number by 2 ,k times will give a large result as mentioned by [@Aman Saini](/aman1320)."
                    },
                    {
                        "username": "aman1320",
                        "content": "Multiplying single element k time will give more larger result."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@Lee_fan_Ak_The_Boss](/Lee_fan_Ak_The_Boss) I want this power to get such kind of intuition."
                    },
                    {
                        "username": "ishaandixit18",
                        "content": "Exactly, that is my doubt as well. Why can\\'t I apply two operations to two different numbers?"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "you have to store prefix and suffix bitwise or operation at each index....and then not need to do k operation just take n = 2**k and mulitply n with each element of nums and perform the bitwise OR operation using stored sufix and perfix array...and Done it"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "The Reason behind applying all the k operations on the same element is\\nshifting\\nat each operation we are shifting and hence the number doubles so it is beneficial to double the maximum number at a point because it will increase the required output.\\n\\nAs soon as you applied the opeartion once on an element it will become double and you should keep applying the same operation on it again and again till k so that you can get maximum of it.\\nI hope you got it ! \\u2764\\uFE0F\\u2764\\uFE0F"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "But why this approach is failing on one testcase.\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n, vector<long long>(k+1, -1));\\n        return solve(nums, n-1, k, dp);\\n    }\\n    \\n    long long solve(vector<int>& nums, int ind, int k, vector<vector<long long>>& dp){\\n        if(ind < 0) return 0;\\n        if(dp[ind][k] != -1)    return dp[ind][k];\\n            \\n        long long pick = -1, temp = nums[ind], p = k;\\n        while(p > 0){\\n            p--;\\n            temp = temp*2;\\n            pick = max(pick, (temp | solve(nums, ind-1, p, dp))); \\n        }\\n        long long notPick = (nums[ind] | solve(nums, ind-1, k, dp));\\n        return dp[ind][k] = max(pick, notPick);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "sylvex",
                        "content": "such a pain not come up with prefix solution...\\nI used priority queue , passed the first few cases, and it failed..."
                    },
                    {
                        "username": "ranjeet_kumar7",
                        "content": "can any one tell why it is applying the k operation on 1 index of example 1 means why not applying on 0 index if we are geting the maximum value 24+9=33"
                    },
                    {
                        "username": "nandunk",
                        "content": "then we will get 25 only"
                    },
                    {
                        "username": "gaurav621",
                        "content": "you have to calculate OR of elements not sum of elements.. and 24 | 9 = 25 "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Tricky one :)**\\n\\nI like it"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "why is the dp solution not correct?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@heisenberg_44](/heisenberg_44) Just a guess!"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "[@heisenberg280](/heisenberg280) hehe you got good taste.how did you know i was indian?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Hamare naam k saath saath stats be aage piche hai :xD"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "Can anyone tell me why this approach is failing.\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n, vector<long long>(k+1, -1));\\n        return solve(nums, n-1, k, dp);\\n    }\\n    \\n    long long solve(vector<int>& nums, int ind, int k, vector<vector<long long>>& dp){\\n        if(ind < 0) return 0;\\n        if(dp[ind][k] != -1)    return dp[ind][k];\\n            \\n        long long pick = -1, temp = nums[ind], p = k;\\n        while(p > 0){\\n            p--;\\n            temp = temp*2;\\n            pick = max(pick, (temp | solve(nums, ind-1, p, dp))); \\n        }\\n        long long notPick = (nums[ind] | solve(nums, ind-1, k, dp));\\n        return dp[ind][k] = max(pick, notPick);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "sleepingonee",
                        "content": "New testcase nums=[974,816] k=2 cancelled my contest result. Ouch"
                    },
                    {
                        "username": "annahung",
                        "content": "I can understand why we should apply all the k operations on the same element. \\nHowever, I cannot understand why iterating k times and each time find the max OR result will yield wrong answer...\\n\\nFor example:\\n[10, 11], k = 2\\n\\nThe correct answer is to operate on 11.\\n\\nBut if we iterating 2 times:\\nAt first time: \\noperate on 10:\\n10100\\n  1011\\n--------\\n11111\\n\\noperate on 11:\\n  1010\\n10110\\n-------\\n11110\\n\\nThen we will choose to operate at on 10. And this will yield a wrong answer....\\n"
                    },
                    {
                        "username": "MuditK_57",
                        "content": "Why my solution is giving wrong answer? \n\nclass Solution {\npublic:\n        \n\n    void update(vector<long long>& prefix,vector<long long>& suffix,vector<long long>& nums){\n        int n=nums.size();\n        for(int i=1;i<n;i++)\n            prefix[i]=nums[i-1]|prefix[i-1];\n        for(int i=n-2;i>=0;i--)\n            suffix[i]=suffix[i+1]|nums[i+1];\n        return ;\n    }\n    \n    long long maximumOr(vector<int>& num, int k) {\n        long long po=1;\n        long long x=2;\n        for(int i=1;i<=k;i++)\n            po*=x;\n        long long ans=0;\n        int n=num.size();\n        vector<long long>nums(n,0);\n        for(int i=0;i<n;i++)\n            nums[i]=num[i];\n        vector<long long>prefix(n,0),suffix(n,0);\n        for(int i=1;i<n;i++)\n            prefix[i]=nums[i-1]|prefix[i-1];\n        for(int i=n-2;i>=0;i--)\n            suffix[i]=suffix[i+1]|nums[i+1];\n        int pos=0;\n        long long m=LONG_MIN;\n        for(int i=0;i<n;i++){\n            long long temp=((nums[i]*2)|prefix[i])|suffix[i];\n            if(temp>m){\n                m=temp;\n                pos=i;\n            }\n        }\n        nums[pos]=nums[pos]*po;\n        for(int i=0;i<n;i++)\n            ans=ans|nums[i];\n        return ans;\n    }\n};\n"
                    }
                ]
            },
            {
                "id": 1893723,
                "content": [
                    {
                        "username": "Andrei-Paval",
                        "content": "Can someone explain why is it optimal to apply all the k operations on the same element? \\nWhy isn\\'t it possible, in some cases, to obtain a larger value for the bitwise OR of all the elements by distributing the operations on multiple elements?"
                    },
                    {
                        "username": "mciobanu",
                        "content": "[@daren](/daren) I looked at the description, thought a little, and started wondering how could this be a \"medium\" problem, as you can easily run into overflows and have many options to shift multiple numbers. Then I looked at the hints and they were \"obviously wrong\". Then I checked the discussions, which made me look at the signature, and I finally realized that the answer takes 64 bits. I feel that the description should have mentioned this and stand on its own, without you needing to check the signature. Am I wrong?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we will get left set bits "
                    },
                    {
                        "username": "gaurav621",
                        "content": "you only need to choose element which have left most set bit (so that you can left-shit that element k time and get max result), now you can get conflits like 9(1001) and 12(1100) and need to choose only one because once you perform left shift on it, it will be the left most set bit. So, now you need to perform rest (k-1) operation on that chosen element only.\n\nYou can solve this question with logic - (prefixOR | suffixOR | left most set bit elements * pow(2, k)) and take the max one."
                    },
                    {
                        "username": "daren",
                        "content": "i think it becomes obvious if they set the signature of the C++ function as:\n\nlong long maximumOr(vector \\<long long\\>& nums, int k)\n\notherwise its not clear, if you shift an int 15 times, does it become negative? do bits drop off the top end? "
                    },
                    {
                        "username": "ishaandixit18",
                        "content": "Hey [@Andrei Paval](/Andrei-Paval), I solved the problem using multiple operations on multiple numbers . The ans was still same and the time complexity is O(n * k). I think that greedily multiplying every number results in an optimal solution as multiplying a number by 2 ,k times will give a large result as mentioned by [@Aman Saini](/aman1320)."
                    },
                    {
                        "username": "aman1320",
                        "content": "Multiplying single element k time will give more larger result."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@Lee_fan_Ak_The_Boss](/Lee_fan_Ak_The_Boss) I want this power to get such kind of intuition."
                    },
                    {
                        "username": "ishaandixit18",
                        "content": "Exactly, that is my doubt as well. Why can\\'t I apply two operations to two different numbers?"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "you have to store prefix and suffix bitwise or operation at each index....and then not need to do k operation just take n = 2**k and mulitply n with each element of nums and perform the bitwise OR operation using stored sufix and perfix array...and Done it"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "The Reason behind applying all the k operations on the same element is\\nshifting\\nat each operation we are shifting and hence the number doubles so it is beneficial to double the maximum number at a point because it will increase the required output.\\n\\nAs soon as you applied the opeartion once on an element it will become double and you should keep applying the same operation on it again and again till k so that you can get maximum of it.\\nI hope you got it ! \\u2764\\uFE0F\\u2764\\uFE0F"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "But why this approach is failing on one testcase.\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n, vector<long long>(k+1, -1));\\n        return solve(nums, n-1, k, dp);\\n    }\\n    \\n    long long solve(vector<int>& nums, int ind, int k, vector<vector<long long>>& dp){\\n        if(ind < 0) return 0;\\n        if(dp[ind][k] != -1)    return dp[ind][k];\\n            \\n        long long pick = -1, temp = nums[ind], p = k;\\n        while(p > 0){\\n            p--;\\n            temp = temp*2;\\n            pick = max(pick, (temp | solve(nums, ind-1, p, dp))); \\n        }\\n        long long notPick = (nums[ind] | solve(nums, ind-1, k, dp));\\n        return dp[ind][k] = max(pick, notPick);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "sylvex",
                        "content": "such a pain not come up with prefix solution...\\nI used priority queue , passed the first few cases, and it failed..."
                    },
                    {
                        "username": "ranjeet_kumar7",
                        "content": "can any one tell why it is applying the k operation on 1 index of example 1 means why not applying on 0 index if we are geting the maximum value 24+9=33"
                    },
                    {
                        "username": "nandunk",
                        "content": "then we will get 25 only"
                    },
                    {
                        "username": "gaurav621",
                        "content": "you have to calculate OR of elements not sum of elements.. and 24 | 9 = 25 "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Tricky one :)**\\n\\nI like it"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "why is the dp solution not correct?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@heisenberg_44](/heisenberg_44) Just a guess!"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "[@heisenberg280](/heisenberg280) hehe you got good taste.how did you know i was indian?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Hamare naam k saath saath stats be aage piche hai :xD"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "Can anyone tell me why this approach is failing.\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n, vector<long long>(k+1, -1));\\n        return solve(nums, n-1, k, dp);\\n    }\\n    \\n    long long solve(vector<int>& nums, int ind, int k, vector<vector<long long>>& dp){\\n        if(ind < 0) return 0;\\n        if(dp[ind][k] != -1)    return dp[ind][k];\\n            \\n        long long pick = -1, temp = nums[ind], p = k;\\n        while(p > 0){\\n            p--;\\n            temp = temp*2;\\n            pick = max(pick, (temp | solve(nums, ind-1, p, dp))); \\n        }\\n        long long notPick = (nums[ind] | solve(nums, ind-1, k, dp));\\n        return dp[ind][k] = max(pick, notPick);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "sleepingonee",
                        "content": "New testcase nums=[974,816] k=2 cancelled my contest result. Ouch"
                    },
                    {
                        "username": "annahung",
                        "content": "I can understand why we should apply all the k operations on the same element. \\nHowever, I cannot understand why iterating k times and each time find the max OR result will yield wrong answer...\\n\\nFor example:\\n[10, 11], k = 2\\n\\nThe correct answer is to operate on 11.\\n\\nBut if we iterating 2 times:\\nAt first time: \\noperate on 10:\\n10100\\n  1011\\n--------\\n11111\\n\\noperate on 11:\\n  1010\\n10110\\n-------\\n11110\\n\\nThen we will choose to operate at on 10. And this will yield a wrong answer....\\n"
                    },
                    {
                        "username": "MuditK_57",
                        "content": "Why my solution is giving wrong answer? \n\nclass Solution {\npublic:\n        \n\n    void update(vector<long long>& prefix,vector<long long>& suffix,vector<long long>& nums){\n        int n=nums.size();\n        for(int i=1;i<n;i++)\n            prefix[i]=nums[i-1]|prefix[i-1];\n        for(int i=n-2;i>=0;i--)\n            suffix[i]=suffix[i+1]|nums[i+1];\n        return ;\n    }\n    \n    long long maximumOr(vector<int>& num, int k) {\n        long long po=1;\n        long long x=2;\n        for(int i=1;i<=k;i++)\n            po*=x;\n        long long ans=0;\n        int n=num.size();\n        vector<long long>nums(n,0);\n        for(int i=0;i<n;i++)\n            nums[i]=num[i];\n        vector<long long>prefix(n,0),suffix(n,0);\n        for(int i=1;i<n;i++)\n            prefix[i]=nums[i-1]|prefix[i-1];\n        for(int i=n-2;i>=0;i--)\n            suffix[i]=suffix[i+1]|nums[i+1];\n        int pos=0;\n        long long m=LONG_MIN;\n        for(int i=0;i<n;i++){\n            long long temp=((nums[i]*2)|prefix[i])|suffix[i];\n            if(temp>m){\n                m=temp;\n                pos=i;\n            }\n        }\n        nums[pos]=nums[pos]*po;\n        for(int i=0;i<n;i++)\n            ans=ans|nums[i];\n        return ans;\n    }\n};\n"
                    }
                ]
            },
            {
                "id": 1893562,
                "content": [
                    {
                        "username": "Andrei-Paval",
                        "content": "Can someone explain why is it optimal to apply all the k operations on the same element? \\nWhy isn\\'t it possible, in some cases, to obtain a larger value for the bitwise OR of all the elements by distributing the operations on multiple elements?"
                    },
                    {
                        "username": "mciobanu",
                        "content": "[@daren](/daren) I looked at the description, thought a little, and started wondering how could this be a \"medium\" problem, as you can easily run into overflows and have many options to shift multiple numbers. Then I looked at the hints and they were \"obviously wrong\". Then I checked the discussions, which made me look at the signature, and I finally realized that the answer takes 64 bits. I feel that the description should have mentioned this and stand on its own, without you needing to check the signature. Am I wrong?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we will get left set bits "
                    },
                    {
                        "username": "gaurav621",
                        "content": "you only need to choose element which have left most set bit (so that you can left-shit that element k time and get max result), now you can get conflits like 9(1001) and 12(1100) and need to choose only one because once you perform left shift on it, it will be the left most set bit. So, now you need to perform rest (k-1) operation on that chosen element only.\n\nYou can solve this question with logic - (prefixOR | suffixOR | left most set bit elements * pow(2, k)) and take the max one."
                    },
                    {
                        "username": "daren",
                        "content": "i think it becomes obvious if they set the signature of the C++ function as:\n\nlong long maximumOr(vector \\<long long\\>& nums, int k)\n\notherwise its not clear, if you shift an int 15 times, does it become negative? do bits drop off the top end? "
                    },
                    {
                        "username": "ishaandixit18",
                        "content": "Hey [@Andrei Paval](/Andrei-Paval), I solved the problem using multiple operations on multiple numbers . The ans was still same and the time complexity is O(n * k). I think that greedily multiplying every number results in an optimal solution as multiplying a number by 2 ,k times will give a large result as mentioned by [@Aman Saini](/aman1320)."
                    },
                    {
                        "username": "aman1320",
                        "content": "Multiplying single element k time will give more larger result."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@Lee_fan_Ak_The_Boss](/Lee_fan_Ak_The_Boss) I want this power to get such kind of intuition."
                    },
                    {
                        "username": "ishaandixit18",
                        "content": "Exactly, that is my doubt as well. Why can\\'t I apply two operations to two different numbers?"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "you have to store prefix and suffix bitwise or operation at each index....and then not need to do k operation just take n = 2**k and mulitply n with each element of nums and perform the bitwise OR operation using stored sufix and perfix array...and Done it"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "The Reason behind applying all the k operations on the same element is\\nshifting\\nat each operation we are shifting and hence the number doubles so it is beneficial to double the maximum number at a point because it will increase the required output.\\n\\nAs soon as you applied the opeartion once on an element it will become double and you should keep applying the same operation on it again and again till k so that you can get maximum of it.\\nI hope you got it ! \\u2764\\uFE0F\\u2764\\uFE0F"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "But why this approach is failing on one testcase.\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n, vector<long long>(k+1, -1));\\n        return solve(nums, n-1, k, dp);\\n    }\\n    \\n    long long solve(vector<int>& nums, int ind, int k, vector<vector<long long>>& dp){\\n        if(ind < 0) return 0;\\n        if(dp[ind][k] != -1)    return dp[ind][k];\\n            \\n        long long pick = -1, temp = nums[ind], p = k;\\n        while(p > 0){\\n            p--;\\n            temp = temp*2;\\n            pick = max(pick, (temp | solve(nums, ind-1, p, dp))); \\n        }\\n        long long notPick = (nums[ind] | solve(nums, ind-1, k, dp));\\n        return dp[ind][k] = max(pick, notPick);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "sylvex",
                        "content": "such a pain not come up with prefix solution...\\nI used priority queue , passed the first few cases, and it failed..."
                    },
                    {
                        "username": "ranjeet_kumar7",
                        "content": "can any one tell why it is applying the k operation on 1 index of example 1 means why not applying on 0 index if we are geting the maximum value 24+9=33"
                    },
                    {
                        "username": "nandunk",
                        "content": "then we will get 25 only"
                    },
                    {
                        "username": "gaurav621",
                        "content": "you have to calculate OR of elements not sum of elements.. and 24 | 9 = 25 "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Tricky one :)**\\n\\nI like it"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "why is the dp solution not correct?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@heisenberg_44](/heisenberg_44) Just a guess!"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "[@heisenberg280](/heisenberg280) hehe you got good taste.how did you know i was indian?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Hamare naam k saath saath stats be aage piche hai :xD"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "Can anyone tell me why this approach is failing.\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n, vector<long long>(k+1, -1));\\n        return solve(nums, n-1, k, dp);\\n    }\\n    \\n    long long solve(vector<int>& nums, int ind, int k, vector<vector<long long>>& dp){\\n        if(ind < 0) return 0;\\n        if(dp[ind][k] != -1)    return dp[ind][k];\\n            \\n        long long pick = -1, temp = nums[ind], p = k;\\n        while(p > 0){\\n            p--;\\n            temp = temp*2;\\n            pick = max(pick, (temp | solve(nums, ind-1, p, dp))); \\n        }\\n        long long notPick = (nums[ind] | solve(nums, ind-1, k, dp));\\n        return dp[ind][k] = max(pick, notPick);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "sleepingonee",
                        "content": "New testcase nums=[974,816] k=2 cancelled my contest result. Ouch"
                    },
                    {
                        "username": "annahung",
                        "content": "I can understand why we should apply all the k operations on the same element. \\nHowever, I cannot understand why iterating k times and each time find the max OR result will yield wrong answer...\\n\\nFor example:\\n[10, 11], k = 2\\n\\nThe correct answer is to operate on 11.\\n\\nBut if we iterating 2 times:\\nAt first time: \\noperate on 10:\\n10100\\n  1011\\n--------\\n11111\\n\\noperate on 11:\\n  1010\\n10110\\n-------\\n11110\\n\\nThen we will choose to operate at on 10. And this will yield a wrong answer....\\n"
                    },
                    {
                        "username": "MuditK_57",
                        "content": "Why my solution is giving wrong answer? \n\nclass Solution {\npublic:\n        \n\n    void update(vector<long long>& prefix,vector<long long>& suffix,vector<long long>& nums){\n        int n=nums.size();\n        for(int i=1;i<n;i++)\n            prefix[i]=nums[i-1]|prefix[i-1];\n        for(int i=n-2;i>=0;i--)\n            suffix[i]=suffix[i+1]|nums[i+1];\n        return ;\n    }\n    \n    long long maximumOr(vector<int>& num, int k) {\n        long long po=1;\n        long long x=2;\n        for(int i=1;i<=k;i++)\n            po*=x;\n        long long ans=0;\n        int n=num.size();\n        vector<long long>nums(n,0);\n        for(int i=0;i<n;i++)\n            nums[i]=num[i];\n        vector<long long>prefix(n,0),suffix(n,0);\n        for(int i=1;i<n;i++)\n            prefix[i]=nums[i-1]|prefix[i-1];\n        for(int i=n-2;i>=0;i--)\n            suffix[i]=suffix[i+1]|nums[i+1];\n        int pos=0;\n        long long m=LONG_MIN;\n        for(int i=0;i<n;i++){\n            long long temp=((nums[i]*2)|prefix[i])|suffix[i];\n            if(temp>m){\n                m=temp;\n                pos=i;\n            }\n        }\n        nums[pos]=nums[pos]*po;\n        for(int i=0;i<n;i++)\n            ans=ans|nums[i];\n        return ans;\n    }\n};\n"
                    }
                ]
            },
            {
                "id": 1897118,
                "content": [
                    {
                        "username": "Andrei-Paval",
                        "content": "Can someone explain why is it optimal to apply all the k operations on the same element? \\nWhy isn\\'t it possible, in some cases, to obtain a larger value for the bitwise OR of all the elements by distributing the operations on multiple elements?"
                    },
                    {
                        "username": "mciobanu",
                        "content": "[@daren](/daren) I looked at the description, thought a little, and started wondering how could this be a \"medium\" problem, as you can easily run into overflows and have many options to shift multiple numbers. Then I looked at the hints and they were \"obviously wrong\". Then I checked the discussions, which made me look at the signature, and I finally realized that the answer takes 64 bits. I feel that the description should have mentioned this and stand on its own, without you needing to check the signature. Am I wrong?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we will get left set bits "
                    },
                    {
                        "username": "gaurav621",
                        "content": "you only need to choose element which have left most set bit (so that you can left-shit that element k time and get max result), now you can get conflits like 9(1001) and 12(1100) and need to choose only one because once you perform left shift on it, it will be the left most set bit. So, now you need to perform rest (k-1) operation on that chosen element only.\n\nYou can solve this question with logic - (prefixOR | suffixOR | left most set bit elements * pow(2, k)) and take the max one."
                    },
                    {
                        "username": "daren",
                        "content": "i think it becomes obvious if they set the signature of the C++ function as:\n\nlong long maximumOr(vector \\<long long\\>& nums, int k)\n\notherwise its not clear, if you shift an int 15 times, does it become negative? do bits drop off the top end? "
                    },
                    {
                        "username": "ishaandixit18",
                        "content": "Hey [@Andrei Paval](/Andrei-Paval), I solved the problem using multiple operations on multiple numbers . The ans was still same and the time complexity is O(n * k). I think that greedily multiplying every number results in an optimal solution as multiplying a number by 2 ,k times will give a large result as mentioned by [@Aman Saini](/aman1320)."
                    },
                    {
                        "username": "aman1320",
                        "content": "Multiplying single element k time will give more larger result."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@Lee_fan_Ak_The_Boss](/Lee_fan_Ak_The_Boss) I want this power to get such kind of intuition."
                    },
                    {
                        "username": "ishaandixit18",
                        "content": "Exactly, that is my doubt as well. Why can\\'t I apply two operations to two different numbers?"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "you have to store prefix and suffix bitwise or operation at each index....and then not need to do k operation just take n = 2**k and mulitply n with each element of nums and perform the bitwise OR operation using stored sufix and perfix array...and Done it"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "The Reason behind applying all the k operations on the same element is\\nshifting\\nat each operation we are shifting and hence the number doubles so it is beneficial to double the maximum number at a point because it will increase the required output.\\n\\nAs soon as you applied the opeartion once on an element it will become double and you should keep applying the same operation on it again and again till k so that you can get maximum of it.\\nI hope you got it ! \\u2764\\uFE0F\\u2764\\uFE0F"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "But why this approach is failing on one testcase.\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n, vector<long long>(k+1, -1));\\n        return solve(nums, n-1, k, dp);\\n    }\\n    \\n    long long solve(vector<int>& nums, int ind, int k, vector<vector<long long>>& dp){\\n        if(ind < 0) return 0;\\n        if(dp[ind][k] != -1)    return dp[ind][k];\\n            \\n        long long pick = -1, temp = nums[ind], p = k;\\n        while(p > 0){\\n            p--;\\n            temp = temp*2;\\n            pick = max(pick, (temp | solve(nums, ind-1, p, dp))); \\n        }\\n        long long notPick = (nums[ind] | solve(nums, ind-1, k, dp));\\n        return dp[ind][k] = max(pick, notPick);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "sylvex",
                        "content": "such a pain not come up with prefix solution...\\nI used priority queue , passed the first few cases, and it failed..."
                    },
                    {
                        "username": "ranjeet_kumar7",
                        "content": "can any one tell why it is applying the k operation on 1 index of example 1 means why not applying on 0 index if we are geting the maximum value 24+9=33"
                    },
                    {
                        "username": "nandunk",
                        "content": "then we will get 25 only"
                    },
                    {
                        "username": "gaurav621",
                        "content": "you have to calculate OR of elements not sum of elements.. and 24 | 9 = 25 "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Tricky one :)**\\n\\nI like it"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "why is the dp solution not correct?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@heisenberg_44](/heisenberg_44) Just a guess!"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "[@heisenberg280](/heisenberg280) hehe you got good taste.how did you know i was indian?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Hamare naam k saath saath stats be aage piche hai :xD"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "Can anyone tell me why this approach is failing.\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n, vector<long long>(k+1, -1));\\n        return solve(nums, n-1, k, dp);\\n    }\\n    \\n    long long solve(vector<int>& nums, int ind, int k, vector<vector<long long>>& dp){\\n        if(ind < 0) return 0;\\n        if(dp[ind][k] != -1)    return dp[ind][k];\\n            \\n        long long pick = -1, temp = nums[ind], p = k;\\n        while(p > 0){\\n            p--;\\n            temp = temp*2;\\n            pick = max(pick, (temp | solve(nums, ind-1, p, dp))); \\n        }\\n        long long notPick = (nums[ind] | solve(nums, ind-1, k, dp));\\n        return dp[ind][k] = max(pick, notPick);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "sleepingonee",
                        "content": "New testcase nums=[974,816] k=2 cancelled my contest result. Ouch"
                    },
                    {
                        "username": "annahung",
                        "content": "I can understand why we should apply all the k operations on the same element. \\nHowever, I cannot understand why iterating k times and each time find the max OR result will yield wrong answer...\\n\\nFor example:\\n[10, 11], k = 2\\n\\nThe correct answer is to operate on 11.\\n\\nBut if we iterating 2 times:\\nAt first time: \\noperate on 10:\\n10100\\n  1011\\n--------\\n11111\\n\\noperate on 11:\\n  1010\\n10110\\n-------\\n11110\\n\\nThen we will choose to operate at on 10. And this will yield a wrong answer....\\n"
                    },
                    {
                        "username": "MuditK_57",
                        "content": "Why my solution is giving wrong answer? \n\nclass Solution {\npublic:\n        \n\n    void update(vector<long long>& prefix,vector<long long>& suffix,vector<long long>& nums){\n        int n=nums.size();\n        for(int i=1;i<n;i++)\n            prefix[i]=nums[i-1]|prefix[i-1];\n        for(int i=n-2;i>=0;i--)\n            suffix[i]=suffix[i+1]|nums[i+1];\n        return ;\n    }\n    \n    long long maximumOr(vector<int>& num, int k) {\n        long long po=1;\n        long long x=2;\n        for(int i=1;i<=k;i++)\n            po*=x;\n        long long ans=0;\n        int n=num.size();\n        vector<long long>nums(n,0);\n        for(int i=0;i<n;i++)\n            nums[i]=num[i];\n        vector<long long>prefix(n,0),suffix(n,0);\n        for(int i=1;i<n;i++)\n            prefix[i]=nums[i-1]|prefix[i-1];\n        for(int i=n-2;i>=0;i--)\n            suffix[i]=suffix[i+1]|nums[i+1];\n        int pos=0;\n        long long m=LONG_MIN;\n        for(int i=0;i<n;i++){\n            long long temp=((nums[i]*2)|prefix[i])|suffix[i];\n            if(temp>m){\n                m=temp;\n                pos=i;\n            }\n        }\n        nums[pos]=nums[pos]*po;\n        for(int i=0;i<n;i++)\n            ans=ans|nums[i];\n        return ans;\n    }\n};\n"
                    }
                ]
            },
            {
                "id": 1897061,
                "content": [
                    {
                        "username": "Andrei-Paval",
                        "content": "Can someone explain why is it optimal to apply all the k operations on the same element? \\nWhy isn\\'t it possible, in some cases, to obtain a larger value for the bitwise OR of all the elements by distributing the operations on multiple elements?"
                    },
                    {
                        "username": "mciobanu",
                        "content": "[@daren](/daren) I looked at the description, thought a little, and started wondering how could this be a \"medium\" problem, as you can easily run into overflows and have many options to shift multiple numbers. Then I looked at the hints and they were \"obviously wrong\". Then I checked the discussions, which made me look at the signature, and I finally realized that the answer takes 64 bits. I feel that the description should have mentioned this and stand on its own, without you needing to check the signature. Am I wrong?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we will get left set bits "
                    },
                    {
                        "username": "gaurav621",
                        "content": "you only need to choose element which have left most set bit (so that you can left-shit that element k time and get max result), now you can get conflits like 9(1001) and 12(1100) and need to choose only one because once you perform left shift on it, it will be the left most set bit. So, now you need to perform rest (k-1) operation on that chosen element only.\n\nYou can solve this question with logic - (prefixOR | suffixOR | left most set bit elements * pow(2, k)) and take the max one."
                    },
                    {
                        "username": "daren",
                        "content": "i think it becomes obvious if they set the signature of the C++ function as:\n\nlong long maximumOr(vector \\<long long\\>& nums, int k)\n\notherwise its not clear, if you shift an int 15 times, does it become negative? do bits drop off the top end? "
                    },
                    {
                        "username": "ishaandixit18",
                        "content": "Hey [@Andrei Paval](/Andrei-Paval), I solved the problem using multiple operations on multiple numbers . The ans was still same and the time complexity is O(n * k). I think that greedily multiplying every number results in an optimal solution as multiplying a number by 2 ,k times will give a large result as mentioned by [@Aman Saini](/aman1320)."
                    },
                    {
                        "username": "aman1320",
                        "content": "Multiplying single element k time will give more larger result."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@Lee_fan_Ak_The_Boss](/Lee_fan_Ak_The_Boss) I want this power to get such kind of intuition."
                    },
                    {
                        "username": "ishaandixit18",
                        "content": "Exactly, that is my doubt as well. Why can\\'t I apply two operations to two different numbers?"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "you have to store prefix and suffix bitwise or operation at each index....and then not need to do k operation just take n = 2**k and mulitply n with each element of nums and perform the bitwise OR operation using stored sufix and perfix array...and Done it"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "The Reason behind applying all the k operations on the same element is\\nshifting\\nat each operation we are shifting and hence the number doubles so it is beneficial to double the maximum number at a point because it will increase the required output.\\n\\nAs soon as you applied the opeartion once on an element it will become double and you should keep applying the same operation on it again and again till k so that you can get maximum of it.\\nI hope you got it ! \\u2764\\uFE0F\\u2764\\uFE0F"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "But why this approach is failing on one testcase.\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n, vector<long long>(k+1, -1));\\n        return solve(nums, n-1, k, dp);\\n    }\\n    \\n    long long solve(vector<int>& nums, int ind, int k, vector<vector<long long>>& dp){\\n        if(ind < 0) return 0;\\n        if(dp[ind][k] != -1)    return dp[ind][k];\\n            \\n        long long pick = -1, temp = nums[ind], p = k;\\n        while(p > 0){\\n            p--;\\n            temp = temp*2;\\n            pick = max(pick, (temp | solve(nums, ind-1, p, dp))); \\n        }\\n        long long notPick = (nums[ind] | solve(nums, ind-1, k, dp));\\n        return dp[ind][k] = max(pick, notPick);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "sylvex",
                        "content": "such a pain not come up with prefix solution...\\nI used priority queue , passed the first few cases, and it failed..."
                    },
                    {
                        "username": "ranjeet_kumar7",
                        "content": "can any one tell why it is applying the k operation on 1 index of example 1 means why not applying on 0 index if we are geting the maximum value 24+9=33"
                    },
                    {
                        "username": "nandunk",
                        "content": "then we will get 25 only"
                    },
                    {
                        "username": "gaurav621",
                        "content": "you have to calculate OR of elements not sum of elements.. and 24 | 9 = 25 "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Tricky one :)**\\n\\nI like it"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "why is the dp solution not correct?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@heisenberg_44](/heisenberg_44) Just a guess!"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "[@heisenberg280](/heisenberg280) hehe you got good taste.how did you know i was indian?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Hamare naam k saath saath stats be aage piche hai :xD"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "Can anyone tell me why this approach is failing.\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n, vector<long long>(k+1, -1));\\n        return solve(nums, n-1, k, dp);\\n    }\\n    \\n    long long solve(vector<int>& nums, int ind, int k, vector<vector<long long>>& dp){\\n        if(ind < 0) return 0;\\n        if(dp[ind][k] != -1)    return dp[ind][k];\\n            \\n        long long pick = -1, temp = nums[ind], p = k;\\n        while(p > 0){\\n            p--;\\n            temp = temp*2;\\n            pick = max(pick, (temp | solve(nums, ind-1, p, dp))); \\n        }\\n        long long notPick = (nums[ind] | solve(nums, ind-1, k, dp));\\n        return dp[ind][k] = max(pick, notPick);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "sleepingonee",
                        "content": "New testcase nums=[974,816] k=2 cancelled my contest result. Ouch"
                    },
                    {
                        "username": "annahung",
                        "content": "I can understand why we should apply all the k operations on the same element. \\nHowever, I cannot understand why iterating k times and each time find the max OR result will yield wrong answer...\\n\\nFor example:\\n[10, 11], k = 2\\n\\nThe correct answer is to operate on 11.\\n\\nBut if we iterating 2 times:\\nAt first time: \\noperate on 10:\\n10100\\n  1011\\n--------\\n11111\\n\\noperate on 11:\\n  1010\\n10110\\n-------\\n11110\\n\\nThen we will choose to operate at on 10. And this will yield a wrong answer....\\n"
                    },
                    {
                        "username": "MuditK_57",
                        "content": "Why my solution is giving wrong answer? \n\nclass Solution {\npublic:\n        \n\n    void update(vector<long long>& prefix,vector<long long>& suffix,vector<long long>& nums){\n        int n=nums.size();\n        for(int i=1;i<n;i++)\n            prefix[i]=nums[i-1]|prefix[i-1];\n        for(int i=n-2;i>=0;i--)\n            suffix[i]=suffix[i+1]|nums[i+1];\n        return ;\n    }\n    \n    long long maximumOr(vector<int>& num, int k) {\n        long long po=1;\n        long long x=2;\n        for(int i=1;i<=k;i++)\n            po*=x;\n        long long ans=0;\n        int n=num.size();\n        vector<long long>nums(n,0);\n        for(int i=0;i<n;i++)\n            nums[i]=num[i];\n        vector<long long>prefix(n,0),suffix(n,0);\n        for(int i=1;i<n;i++)\n            prefix[i]=nums[i-1]|prefix[i-1];\n        for(int i=n-2;i>=0;i--)\n            suffix[i]=suffix[i+1]|nums[i+1];\n        int pos=0;\n        long long m=LONG_MIN;\n        for(int i=0;i<n;i++){\n            long long temp=((nums[i]*2)|prefix[i])|suffix[i];\n            if(temp>m){\n                m=temp;\n                pos=i;\n            }\n        }\n        nums[pos]=nums[pos]*po;\n        for(int i=0;i<n;i++)\n            ans=ans|nums[i];\n        return ans;\n    }\n};\n"
                    }
                ]
            },
            {
                "id": 1895907,
                "content": [
                    {
                        "username": "Andrei-Paval",
                        "content": "Can someone explain why is it optimal to apply all the k operations on the same element? \\nWhy isn\\'t it possible, in some cases, to obtain a larger value for the bitwise OR of all the elements by distributing the operations on multiple elements?"
                    },
                    {
                        "username": "mciobanu",
                        "content": "[@daren](/daren) I looked at the description, thought a little, and started wondering how could this be a \"medium\" problem, as you can easily run into overflows and have many options to shift multiple numbers. Then I looked at the hints and they were \"obviously wrong\". Then I checked the discussions, which made me look at the signature, and I finally realized that the answer takes 64 bits. I feel that the description should have mentioned this and stand on its own, without you needing to check the signature. Am I wrong?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we will get left set bits "
                    },
                    {
                        "username": "gaurav621",
                        "content": "you only need to choose element which have left most set bit (so that you can left-shit that element k time and get max result), now you can get conflits like 9(1001) and 12(1100) and need to choose only one because once you perform left shift on it, it will be the left most set bit. So, now you need to perform rest (k-1) operation on that chosen element only.\n\nYou can solve this question with logic - (prefixOR | suffixOR | left most set bit elements * pow(2, k)) and take the max one."
                    },
                    {
                        "username": "daren",
                        "content": "i think it becomes obvious if they set the signature of the C++ function as:\n\nlong long maximumOr(vector \\<long long\\>& nums, int k)\n\notherwise its not clear, if you shift an int 15 times, does it become negative? do bits drop off the top end? "
                    },
                    {
                        "username": "ishaandixit18",
                        "content": "Hey [@Andrei Paval](/Andrei-Paval), I solved the problem using multiple operations on multiple numbers . The ans was still same and the time complexity is O(n * k). I think that greedily multiplying every number results in an optimal solution as multiplying a number by 2 ,k times will give a large result as mentioned by [@Aman Saini](/aman1320)."
                    },
                    {
                        "username": "aman1320",
                        "content": "Multiplying single element k time will give more larger result."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@Lee_fan_Ak_The_Boss](/Lee_fan_Ak_The_Boss) I want this power to get such kind of intuition."
                    },
                    {
                        "username": "ishaandixit18",
                        "content": "Exactly, that is my doubt as well. Why can\\'t I apply two operations to two different numbers?"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "you have to store prefix and suffix bitwise or operation at each index....and then not need to do k operation just take n = 2**k and mulitply n with each element of nums and perform the bitwise OR operation using stored sufix and perfix array...and Done it"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "The Reason behind applying all the k operations on the same element is\\nshifting\\nat each operation we are shifting and hence the number doubles so it is beneficial to double the maximum number at a point because it will increase the required output.\\n\\nAs soon as you applied the opeartion once on an element it will become double and you should keep applying the same operation on it again and again till k so that you can get maximum of it.\\nI hope you got it ! \\u2764\\uFE0F\\u2764\\uFE0F"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "But why this approach is failing on one testcase.\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n, vector<long long>(k+1, -1));\\n        return solve(nums, n-1, k, dp);\\n    }\\n    \\n    long long solve(vector<int>& nums, int ind, int k, vector<vector<long long>>& dp){\\n        if(ind < 0) return 0;\\n        if(dp[ind][k] != -1)    return dp[ind][k];\\n            \\n        long long pick = -1, temp = nums[ind], p = k;\\n        while(p > 0){\\n            p--;\\n            temp = temp*2;\\n            pick = max(pick, (temp | solve(nums, ind-1, p, dp))); \\n        }\\n        long long notPick = (nums[ind] | solve(nums, ind-1, k, dp));\\n        return dp[ind][k] = max(pick, notPick);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "sylvex",
                        "content": "such a pain not come up with prefix solution...\\nI used priority queue , passed the first few cases, and it failed..."
                    },
                    {
                        "username": "ranjeet_kumar7",
                        "content": "can any one tell why it is applying the k operation on 1 index of example 1 means why not applying on 0 index if we are geting the maximum value 24+9=33"
                    },
                    {
                        "username": "nandunk",
                        "content": "then we will get 25 only"
                    },
                    {
                        "username": "gaurav621",
                        "content": "you have to calculate OR of elements not sum of elements.. and 24 | 9 = 25 "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Tricky one :)**\\n\\nI like it"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "why is the dp solution not correct?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@heisenberg_44](/heisenberg_44) Just a guess!"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "[@heisenberg280](/heisenberg280) hehe you got good taste.how did you know i was indian?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Hamare naam k saath saath stats be aage piche hai :xD"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "Can anyone tell me why this approach is failing.\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n, vector<long long>(k+1, -1));\\n        return solve(nums, n-1, k, dp);\\n    }\\n    \\n    long long solve(vector<int>& nums, int ind, int k, vector<vector<long long>>& dp){\\n        if(ind < 0) return 0;\\n        if(dp[ind][k] != -1)    return dp[ind][k];\\n            \\n        long long pick = -1, temp = nums[ind], p = k;\\n        while(p > 0){\\n            p--;\\n            temp = temp*2;\\n            pick = max(pick, (temp | solve(nums, ind-1, p, dp))); \\n        }\\n        long long notPick = (nums[ind] | solve(nums, ind-1, k, dp));\\n        return dp[ind][k] = max(pick, notPick);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "sleepingonee",
                        "content": "New testcase nums=[974,816] k=2 cancelled my contest result. Ouch"
                    },
                    {
                        "username": "annahung",
                        "content": "I can understand why we should apply all the k operations on the same element. \\nHowever, I cannot understand why iterating k times and each time find the max OR result will yield wrong answer...\\n\\nFor example:\\n[10, 11], k = 2\\n\\nThe correct answer is to operate on 11.\\n\\nBut if we iterating 2 times:\\nAt first time: \\noperate on 10:\\n10100\\n  1011\\n--------\\n11111\\n\\noperate on 11:\\n  1010\\n10110\\n-------\\n11110\\n\\nThen we will choose to operate at on 10. And this will yield a wrong answer....\\n"
                    },
                    {
                        "username": "MuditK_57",
                        "content": "Why my solution is giving wrong answer? \n\nclass Solution {\npublic:\n        \n\n    void update(vector<long long>& prefix,vector<long long>& suffix,vector<long long>& nums){\n        int n=nums.size();\n        for(int i=1;i<n;i++)\n            prefix[i]=nums[i-1]|prefix[i-1];\n        for(int i=n-2;i>=0;i--)\n            suffix[i]=suffix[i+1]|nums[i+1];\n        return ;\n    }\n    \n    long long maximumOr(vector<int>& num, int k) {\n        long long po=1;\n        long long x=2;\n        for(int i=1;i<=k;i++)\n            po*=x;\n        long long ans=0;\n        int n=num.size();\n        vector<long long>nums(n,0);\n        for(int i=0;i<n;i++)\n            nums[i]=num[i];\n        vector<long long>prefix(n,0),suffix(n,0);\n        for(int i=1;i<n;i++)\n            prefix[i]=nums[i-1]|prefix[i-1];\n        for(int i=n-2;i>=0;i--)\n            suffix[i]=suffix[i+1]|nums[i+1];\n        int pos=0;\n        long long m=LONG_MIN;\n        for(int i=0;i<n;i++){\n            long long temp=((nums[i]*2)|prefix[i])|suffix[i];\n            if(temp>m){\n                m=temp;\n                pos=i;\n            }\n        }\n        nums[pos]=nums[pos]*po;\n        for(int i=0;i<n;i++)\n            ans=ans|nums[i];\n        return ans;\n    }\n};\n"
                    }
                ]
            },
            {
                "id": 1894706,
                "content": [
                    {
                        "username": "Andrei-Paval",
                        "content": "Can someone explain why is it optimal to apply all the k operations on the same element? \\nWhy isn\\'t it possible, in some cases, to obtain a larger value for the bitwise OR of all the elements by distributing the operations on multiple elements?"
                    },
                    {
                        "username": "mciobanu",
                        "content": "[@daren](/daren) I looked at the description, thought a little, and started wondering how could this be a \"medium\" problem, as you can easily run into overflows and have many options to shift multiple numbers. Then I looked at the hints and they were \"obviously wrong\". Then I checked the discussions, which made me look at the signature, and I finally realized that the answer takes 64 bits. I feel that the description should have mentioned this and stand on its own, without you needing to check the signature. Am I wrong?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we will get left set bits "
                    },
                    {
                        "username": "gaurav621",
                        "content": "you only need to choose element which have left most set bit (so that you can left-shit that element k time and get max result), now you can get conflits like 9(1001) and 12(1100) and need to choose only one because once you perform left shift on it, it will be the left most set bit. So, now you need to perform rest (k-1) operation on that chosen element only.\n\nYou can solve this question with logic - (prefixOR | suffixOR | left most set bit elements * pow(2, k)) and take the max one."
                    },
                    {
                        "username": "daren",
                        "content": "i think it becomes obvious if they set the signature of the C++ function as:\n\nlong long maximumOr(vector \\<long long\\>& nums, int k)\n\notherwise its not clear, if you shift an int 15 times, does it become negative? do bits drop off the top end? "
                    },
                    {
                        "username": "ishaandixit18",
                        "content": "Hey [@Andrei Paval](/Andrei-Paval), I solved the problem using multiple operations on multiple numbers . The ans was still same and the time complexity is O(n * k). I think that greedily multiplying every number results in an optimal solution as multiplying a number by 2 ,k times will give a large result as mentioned by [@Aman Saini](/aman1320)."
                    },
                    {
                        "username": "aman1320",
                        "content": "Multiplying single element k time will give more larger result."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@Lee_fan_Ak_The_Boss](/Lee_fan_Ak_The_Boss) I want this power to get such kind of intuition."
                    },
                    {
                        "username": "ishaandixit18",
                        "content": "Exactly, that is my doubt as well. Why can\\'t I apply two operations to two different numbers?"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "you have to store prefix and suffix bitwise or operation at each index....and then not need to do k operation just take n = 2**k and mulitply n with each element of nums and perform the bitwise OR operation using stored sufix and perfix array...and Done it"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "The Reason behind applying all the k operations on the same element is\\nshifting\\nat each operation we are shifting and hence the number doubles so it is beneficial to double the maximum number at a point because it will increase the required output.\\n\\nAs soon as you applied the opeartion once on an element it will become double and you should keep applying the same operation on it again and again till k so that you can get maximum of it.\\nI hope you got it ! \\u2764\\uFE0F\\u2764\\uFE0F"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "But why this approach is failing on one testcase.\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n, vector<long long>(k+1, -1));\\n        return solve(nums, n-1, k, dp);\\n    }\\n    \\n    long long solve(vector<int>& nums, int ind, int k, vector<vector<long long>>& dp){\\n        if(ind < 0) return 0;\\n        if(dp[ind][k] != -1)    return dp[ind][k];\\n            \\n        long long pick = -1, temp = nums[ind], p = k;\\n        while(p > 0){\\n            p--;\\n            temp = temp*2;\\n            pick = max(pick, (temp | solve(nums, ind-1, p, dp))); \\n        }\\n        long long notPick = (nums[ind] | solve(nums, ind-1, k, dp));\\n        return dp[ind][k] = max(pick, notPick);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "sylvex",
                        "content": "such a pain not come up with prefix solution...\\nI used priority queue , passed the first few cases, and it failed..."
                    },
                    {
                        "username": "ranjeet_kumar7",
                        "content": "can any one tell why it is applying the k operation on 1 index of example 1 means why not applying on 0 index if we are geting the maximum value 24+9=33"
                    },
                    {
                        "username": "nandunk",
                        "content": "then we will get 25 only"
                    },
                    {
                        "username": "gaurav621",
                        "content": "you have to calculate OR of elements not sum of elements.. and 24 | 9 = 25 "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Tricky one :)**\\n\\nI like it"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "why is the dp solution not correct?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@heisenberg_44](/heisenberg_44) Just a guess!"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "[@heisenberg280](/heisenberg280) hehe you got good taste.how did you know i was indian?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Hamare naam k saath saath stats be aage piche hai :xD"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "Can anyone tell me why this approach is failing.\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n, vector<long long>(k+1, -1));\\n        return solve(nums, n-1, k, dp);\\n    }\\n    \\n    long long solve(vector<int>& nums, int ind, int k, vector<vector<long long>>& dp){\\n        if(ind < 0) return 0;\\n        if(dp[ind][k] != -1)    return dp[ind][k];\\n            \\n        long long pick = -1, temp = nums[ind], p = k;\\n        while(p > 0){\\n            p--;\\n            temp = temp*2;\\n            pick = max(pick, (temp | solve(nums, ind-1, p, dp))); \\n        }\\n        long long notPick = (nums[ind] | solve(nums, ind-1, k, dp));\\n        return dp[ind][k] = max(pick, notPick);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "sleepingonee",
                        "content": "New testcase nums=[974,816] k=2 cancelled my contest result. Ouch"
                    },
                    {
                        "username": "annahung",
                        "content": "I can understand why we should apply all the k operations on the same element. \\nHowever, I cannot understand why iterating k times and each time find the max OR result will yield wrong answer...\\n\\nFor example:\\n[10, 11], k = 2\\n\\nThe correct answer is to operate on 11.\\n\\nBut if we iterating 2 times:\\nAt first time: \\noperate on 10:\\n10100\\n  1011\\n--------\\n11111\\n\\noperate on 11:\\n  1010\\n10110\\n-------\\n11110\\n\\nThen we will choose to operate at on 10. And this will yield a wrong answer....\\n"
                    },
                    {
                        "username": "MuditK_57",
                        "content": "Why my solution is giving wrong answer? \n\nclass Solution {\npublic:\n        \n\n    void update(vector<long long>& prefix,vector<long long>& suffix,vector<long long>& nums){\n        int n=nums.size();\n        for(int i=1;i<n;i++)\n            prefix[i]=nums[i-1]|prefix[i-1];\n        for(int i=n-2;i>=0;i--)\n            suffix[i]=suffix[i+1]|nums[i+1];\n        return ;\n    }\n    \n    long long maximumOr(vector<int>& num, int k) {\n        long long po=1;\n        long long x=2;\n        for(int i=1;i<=k;i++)\n            po*=x;\n        long long ans=0;\n        int n=num.size();\n        vector<long long>nums(n,0);\n        for(int i=0;i<n;i++)\n            nums[i]=num[i];\n        vector<long long>prefix(n,0),suffix(n,0);\n        for(int i=1;i<n;i++)\n            prefix[i]=nums[i-1]|prefix[i-1];\n        for(int i=n-2;i>=0;i--)\n            suffix[i]=suffix[i+1]|nums[i+1];\n        int pos=0;\n        long long m=LONG_MIN;\n        for(int i=0;i<n;i++){\n            long long temp=((nums[i]*2)|prefix[i])|suffix[i];\n            if(temp>m){\n                m=temp;\n                pos=i;\n            }\n        }\n        nums[pos]=nums[pos]*po;\n        for(int i=0;i<n;i++)\n            ans=ans|nums[i];\n        return ans;\n    }\n};\n"
                    }
                ]
            },
            {
                "id": 1893311,
                "content": [
                    {
                        "username": "Andrei-Paval",
                        "content": "Can someone explain why is it optimal to apply all the k operations on the same element? \\nWhy isn\\'t it possible, in some cases, to obtain a larger value for the bitwise OR of all the elements by distributing the operations on multiple elements?"
                    },
                    {
                        "username": "mciobanu",
                        "content": "[@daren](/daren) I looked at the description, thought a little, and started wondering how could this be a \"medium\" problem, as you can easily run into overflows and have many options to shift multiple numbers. Then I looked at the hints and they were \"obviously wrong\". Then I checked the discussions, which made me look at the signature, and I finally realized that the answer takes 64 bits. I feel that the description should have mentioned this and stand on its own, without you needing to check the signature. Am I wrong?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we will get left set bits "
                    },
                    {
                        "username": "gaurav621",
                        "content": "you only need to choose element which have left most set bit (so that you can left-shit that element k time and get max result), now you can get conflits like 9(1001) and 12(1100) and need to choose only one because once you perform left shift on it, it will be the left most set bit. So, now you need to perform rest (k-1) operation on that chosen element only.\n\nYou can solve this question with logic - (prefixOR | suffixOR | left most set bit elements * pow(2, k)) and take the max one."
                    },
                    {
                        "username": "daren",
                        "content": "i think it becomes obvious if they set the signature of the C++ function as:\n\nlong long maximumOr(vector \\<long long\\>& nums, int k)\n\notherwise its not clear, if you shift an int 15 times, does it become negative? do bits drop off the top end? "
                    },
                    {
                        "username": "ishaandixit18",
                        "content": "Hey [@Andrei Paval](/Andrei-Paval), I solved the problem using multiple operations on multiple numbers . The ans was still same and the time complexity is O(n * k). I think that greedily multiplying every number results in an optimal solution as multiplying a number by 2 ,k times will give a large result as mentioned by [@Aman Saini](/aman1320)."
                    },
                    {
                        "username": "aman1320",
                        "content": "Multiplying single element k time will give more larger result."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@Lee_fan_Ak_The_Boss](/Lee_fan_Ak_The_Boss) I want this power to get such kind of intuition."
                    },
                    {
                        "username": "ishaandixit18",
                        "content": "Exactly, that is my doubt as well. Why can\\'t I apply two operations to two different numbers?"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "you have to store prefix and suffix bitwise or operation at each index....and then not need to do k operation just take n = 2**k and mulitply n with each element of nums and perform the bitwise OR operation using stored sufix and perfix array...and Done it"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "The Reason behind applying all the k operations on the same element is\\nshifting\\nat each operation we are shifting and hence the number doubles so it is beneficial to double the maximum number at a point because it will increase the required output.\\n\\nAs soon as you applied the opeartion once on an element it will become double and you should keep applying the same operation on it again and again till k so that you can get maximum of it.\\nI hope you got it ! \\u2764\\uFE0F\\u2764\\uFE0F"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "But why this approach is failing on one testcase.\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n, vector<long long>(k+1, -1));\\n        return solve(nums, n-1, k, dp);\\n    }\\n    \\n    long long solve(vector<int>& nums, int ind, int k, vector<vector<long long>>& dp){\\n        if(ind < 0) return 0;\\n        if(dp[ind][k] != -1)    return dp[ind][k];\\n            \\n        long long pick = -1, temp = nums[ind], p = k;\\n        while(p > 0){\\n            p--;\\n            temp = temp*2;\\n            pick = max(pick, (temp | solve(nums, ind-1, p, dp))); \\n        }\\n        long long notPick = (nums[ind] | solve(nums, ind-1, k, dp));\\n        return dp[ind][k] = max(pick, notPick);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "sylvex",
                        "content": "such a pain not come up with prefix solution...\\nI used priority queue , passed the first few cases, and it failed..."
                    },
                    {
                        "username": "ranjeet_kumar7",
                        "content": "can any one tell why it is applying the k operation on 1 index of example 1 means why not applying on 0 index if we are geting the maximum value 24+9=33"
                    },
                    {
                        "username": "nandunk",
                        "content": "then we will get 25 only"
                    },
                    {
                        "username": "gaurav621",
                        "content": "you have to calculate OR of elements not sum of elements.. and 24 | 9 = 25 "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Tricky one :)**\\n\\nI like it"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "why is the dp solution not correct?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@heisenberg_44](/heisenberg_44) Just a guess!"
                    },
                    {
                        "username": "heisenberg_44",
                        "content": "[@heisenberg280](/heisenberg280) hehe you got good taste.how did you know i was indian?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Hamare naam k saath saath stats be aage piche hai :xD"
                    },
                    {
                        "username": "Samarth_Dengre",
                        "content": "Can anyone tell me why this approach is failing.\\n```\\nclass Solution {\\npublic:\\n    long long maximumOr(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n, vector<long long>(k+1, -1));\\n        return solve(nums, n-1, k, dp);\\n    }\\n    \\n    long long solve(vector<int>& nums, int ind, int k, vector<vector<long long>>& dp){\\n        if(ind < 0) return 0;\\n        if(dp[ind][k] != -1)    return dp[ind][k];\\n            \\n        long long pick = -1, temp = nums[ind], p = k;\\n        while(p > 0){\\n            p--;\\n            temp = temp*2;\\n            pick = max(pick, (temp | solve(nums, ind-1, p, dp))); \\n        }\\n        long long notPick = (nums[ind] | solve(nums, ind-1, k, dp));\\n        return dp[ind][k] = max(pick, notPick);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "sleepingonee",
                        "content": "New testcase nums=[974,816] k=2 cancelled my contest result. Ouch"
                    },
                    {
                        "username": "annahung",
                        "content": "I can understand why we should apply all the k operations on the same element. \\nHowever, I cannot understand why iterating k times and each time find the max OR result will yield wrong answer...\\n\\nFor example:\\n[10, 11], k = 2\\n\\nThe correct answer is to operate on 11.\\n\\nBut if we iterating 2 times:\\nAt first time: \\noperate on 10:\\n10100\\n  1011\\n--------\\n11111\\n\\noperate on 11:\\n  1010\\n10110\\n-------\\n11110\\n\\nThen we will choose to operate at on 10. And this will yield a wrong answer....\\n"
                    },
                    {
                        "username": "MuditK_57",
                        "content": "Why my solution is giving wrong answer? \n\nclass Solution {\npublic:\n        \n\n    void update(vector<long long>& prefix,vector<long long>& suffix,vector<long long>& nums){\n        int n=nums.size();\n        for(int i=1;i<n;i++)\n            prefix[i]=nums[i-1]|prefix[i-1];\n        for(int i=n-2;i>=0;i--)\n            suffix[i]=suffix[i+1]|nums[i+1];\n        return ;\n    }\n    \n    long long maximumOr(vector<int>& num, int k) {\n        long long po=1;\n        long long x=2;\n        for(int i=1;i<=k;i++)\n            po*=x;\n        long long ans=0;\n        int n=num.size();\n        vector<long long>nums(n,0);\n        for(int i=0;i<n;i++)\n            nums[i]=num[i];\n        vector<long long>prefix(n,0),suffix(n,0);\n        for(int i=1;i<n;i++)\n            prefix[i]=nums[i-1]|prefix[i-1];\n        for(int i=n-2;i>=0;i--)\n            suffix[i]=suffix[i+1]|nums[i+1];\n        int pos=0;\n        long long m=LONG_MIN;\n        for(int i=0;i<n;i++){\n            long long temp=((nums[i]*2)|prefix[i])|suffix[i];\n            if(temp>m){\n                m=temp;\n                pos=i;\n            }\n        }\n        nums[pos]=nums[pos]*po;\n        for(int i=0;i<n;i++)\n            ans=ans|nums[i];\n        return ans;\n    }\n};\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Lexicographically Smallest Palindrome",
        "question_content": "<p>You are given a string <code node=\"[object Object]\">s</code> consisting of <strong>lowercase English letters</strong>, and you are allowed to perform operations on it. In one operation, you can <strong>replace</strong> a character in <code node=\"[object Object]\">s</code> with another lowercase English letter.</p>\n\n<p>Your task is to make <code node=\"[object Object]\">s</code> a <strong>palindrome</strong> with the <strong>minimum</strong> <strong>number</strong> <strong>of operations</strong> possible. If there are <strong>multiple palindromes</strong> that can be <meta charset=\"utf-8\" />made using the <strong>minimum</strong> number of operations, <meta charset=\"utf-8\" />make the <strong>lexicographically smallest</strong> one.</p>\n\n<p>A string <code>a</code> is lexicographically smaller than a string <code>b</code> (of the same length) if in the first position where <code>a</code> and <code>b</code> differ, string <code>a</code> has a letter that appears earlier in the alphabet than the corresponding letter in <code>b</code>.</p>\n\n<p>Return <em>the resulting palindrome string.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;egcfe&quot;\n<strong>Output:</strong> &quot;efcfe&quot;\n<strong>Explanation:</strong> The minimum number of operations to make &quot;egcfe&quot; a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is &quot;efcfe&quot;, by changing &#39;g&#39;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abcd&quot;\n<strong>Output:</strong> &quot;abba&quot;\n<strong>Explanation:</strong> The minimum number of operations to make &quot;abcd&quot; a palindrome is 2, and the lexicographically smallest palindrome string we can get by modifying two characters is &quot;abba&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;seven&quot;\n<strong>Output:</strong> &quot;neven&quot;\n<strong>Explanation:</strong> The minimum number of operations to make &quot;seven&quot; a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is &quot;neven&quot;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s</code>&nbsp;consists of only lowercase English letters<b>.</b></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3546745,
                "title": "java-c-python-two-pointers",
                "content": "# **Explanation**\\nCompare each `s[i]` with its symmetrical postion in palindrome,\\nwhich is `s[n - 1 - i]`.\\n\\nTo make the lexicographically smallest palindrome,\\nwe make `s[i] = s[n - 1 - i] = min(s[i], s[n - i - 1])`\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\n```java\\n    public String makeSmallestPalindrome(String s) {\\n        int n = s.length();\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < n; i++)\\n            sb.append(Character.toString(Math.min(s.charAt(i), s.charAt(n - i - 1))));\\n        return sb.toString();\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    string makeSmallestPalindrome(string s) {\\n        int n = s.size();\\n        for (int i = 0; i < n; ++i)\\n            s[i] = s[n - 1 - i] = min(s[i], s[n - i - 1]);\\n        return s;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        return \\'\\'.join(map(min, zip(s, s[::-1])))\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public String makeSmallestPalindrome(String s) {\\n        int n = s.length();\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < n; i++)\\n            sb.append(Character.toString(Math.min(s.charAt(i), s.charAt(n - i - 1))));\\n        return sb.toString();\\n    }\\n```\n```cpp\\n    string makeSmallestPalindrome(string s) {\\n        int n = s.size();\\n        for (int i = 0; i < n; ++i)\\n            s[i] = s[n - 1 - i] = min(s[i], s[n - i - 1]);\\n        return s;\\n    }\\n```\n```py\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        return \\'\\'.join(map(min, zip(s, s[::-1])))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3546828,
                "title": "take-min-very-simple-and-easy-to-understand-solution",
                "content": "<b> Up vote if this solution helps</b>\\n# Approach\\nTake two iterator one from front and one from back.\\nThen take the min of s(front) & s(back) and set both s(front) and s(back) to the min value.\\n \\n# Code\\n```\\n    string makeSmallestPalindrome(string s) {\\n        int front = 0, back = s.size()-1;\\n        while(front <= s.size()/2){\\n            s[front] = min(s[front], s[back]);\\n            s[back] = s[front];\\n            front++; back--;\\n        }\\n        return s;\\n    }\\n```\\n\\n<b>Here is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    string makeSmallestPalindrome(string s) {\\n        int front = 0, back = s.size()-1;\\n        while(front <= s.size()/2){\\n            s[front] = min(s[front], s[back]);\\n            s[back] = s[front];\\n            front++; back--;\\n        }\\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3546744,
                "title": "java-easy-solution-8-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public String makeSmallestPalindrome(String s) {\\n    var c = s.toCharArray();\\n    int i = 0, j = c.length - 1;\\n    \\n    while (i < j) {\\n      if (c[i] < c [j])\\n        c[j--] = c[i++];\\n      else\\n        c[i++] = c[j--];\\n    }\\n    return new String(c);\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public String makeSmallestPalindrome(String s) {\\n    var c = s.toCharArray();\\n    int i = 0, j = c.length - 1;\\n    \\n    while (i < j) {\\n      if (c[i] < c [j])\\n        c[j--] = c[i++];\\n      else\\n        c[i++] = c[j--];\\n    }\\n    return new String(c);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547031,
                "title": "c-two-pointer-easy-to-understand",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n// <!-- UPVOTE IF THIS CODE IS HELP FULL FOR YOU\\n// IF ANY SUGGETION YOU CAN COMMENT HERE. -->\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int i = 0, j = s.length()-1;//make pointer index\\n        while(i<j){\\n            if(s[i] != s[j]){\\n                s[i] = s[j] = min(s[i],s[j]);//initialise i and j to min of (s[i],s[j]);\\n            }\\n            i++;j--;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\n// <!-- UPVOTE IF THIS CODE IS HELP FULL FOR YOU\\n// IF ANY SUGGETION YOU CAN COMMENT HERE. -->\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int i = 0, j = s.length()-1;//make pointer index\\n        while(i<j){\\n            if(s[i] != s[j]){\\n                s[i] = s[j] = min(s[i],s[j]);//initialise i and j to min of (s[i],s[j]);\\n            }\\n            i++;j--;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546754,
                "title": "day-416-two-pointers-0ms-100-python-java-c-explained",
                "content": "# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\n##### \\u2022\\tThe string is converted to a char array so that the characters can be accessed more easily.\\n##### \\u2022\\tTwo pointers are initialized to the beginning and end of the array.\\n##### \\u2022\\tA variable is initialized to keep track of the number of operations performed.\\n##### \\u2022\\tThe loop iterates until the left pointer reaches the right pointer.\\n##### \\u2022\\tInside the loop, the characters at the left and right pointers are compared.\\n##### \\u2022\\tIf the characters are not equal, then the smaller character is swapped with the larger character.\\n##### \\u2022\\tThe number of operations is incremented by 1.\\n##### \\u2022\\tIf the number of operations is 0, then the original string is returned.\\n##### \\u2022\\tOtherwise, a new string is created from the char array and returned.\\n\\n\\n\\n# Complexity\\n- Time complexity:o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n    char[] arr = s.toCharArray();\\n    int left = 0, right = arr.length - 1;\\n    int ops = 0;\\n    while (left < right) {\\n        if (arr[left] != arr[right]) {\\n            if (arr[left] > arr[right]) {\\n                arr[left] = arr[right];\\n            } else {\\n                arr[right] = arr[left];\\n            }\\n            ops++;\\n        }\\n        left++;\\n        right--;\\n    }\\n    if (ops == 0) {\\n        return s;\\n    }\\n    return new String(arr);\\n}\\n}\\n```\\n# C++ \\n```C++ \\nstring makeSmallestPalindrome(string s) {\\n  char arr[s.length()];\\n  for (int i = 0; i < s.length(); i++) {\\n    arr[i] = s[i];\\n  }\\n\\n  int left = 0, right = s.length() - 1;\\n  int ops = 0;\\n  while (left < right) {\\n    if (arr[left] != arr[right]) {\\n      if (arr[left] > arr[right]) {\\n        arr[left] = arr[right];\\n      } else {\\n        arr[right] = arr[left];\\n      }\\n      ops++;\\n    }\\n    left++;\\n    right--;\\n  }\\n\\n  if (ops == 0) {\\n    return s;\\n  }\\n\\n  string result = \"\";\\n  for (int i = 0; i < s.length(); i++) {\\n    result += arr[i];\\n  }\\n\\n  return result;\\n}\\n\\n```\\n# PY \\n\\n```\\ndef make_smallest_palindrome(s):\\n  arr = list(s)\\n  left = 0\\n  right = len(arr) - 1\\n  ops = 0\\n  while left < right:\\n    if arr[left] != arr[right]:\\n      if arr[left] > arr[right]:\\n        arr[left] = arr[right]\\n      else:\\n        arr[right] = arr[left]\\n      ops += 1\\n    left += 1\\n    right -= 1\\n\\n  if ops == 0:\\n    return s\\n\\n  result = \"\"\\n  for i in arr:\\n    result += i\\n\\n  return result\\n```\\n\\n\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/8bb0ed4d-d998-4778-8a6b-30bc8e97edfa_1684321488.7915804.webp)\\n\\n\\n![meme2.png](https://assets.leetcode.com/users/images/d588f492-3f95-45f6-8e4a-10d6069002a5_1680054021.7117147.png)\\n\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n\\u2B06 \\u2B06 \\u2B06 \\u2B06 \\u2B06 \\u2B06 \\u2B06 \\u2B06 \\u2B06",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n    char[] arr = s.toCharArray();\\n    int left = 0, right = arr.length - 1;\\n    int ops = 0;\\n    while (left < right) {\\n        if (arr[left] != arr[right]) {\\n            if (arr[left] > arr[right]) {\\n                arr[left] = arr[right];\\n            } else {\\n                arr[right] = arr[left];\\n            }\\n            ops++;\\n        }\\n        left++;\\n        right--;\\n    }\\n    if (ops == 0) {\\n        return s;\\n    }\\n    return new String(arr);\\n}\\n}\\n```\n```C++ \\nstring makeSmallestPalindrome(string s) {\\n  char arr[s.length()];\\n  for (int i = 0; i < s.length(); i++) {\\n    arr[i] = s[i];\\n  }\\n\\n  int left = 0, right = s.length() - 1;\\n  int ops = 0;\\n  while (left < right) {\\n    if (arr[left] != arr[right]) {\\n      if (arr[left] > arr[right]) {\\n        arr[left] = arr[right];\\n      } else {\\n        arr[right] = arr[left];\\n      }\\n      ops++;\\n    }\\n    left++;\\n    right--;\\n  }\\n\\n  if (ops == 0) {\\n    return s;\\n  }\\n\\n  string result = \"\";\\n  for (int i = 0; i < s.length(); i++) {\\n    result += arr[i];\\n  }\\n\\n  return result;\\n}\\n\\n```\n```\\ndef make_smallest_palindrome(s):\\n  arr = list(s)\\n  left = 0\\n  right = len(arr) - 1\\n  ops = 0\\n  while left < right:\\n    if arr[left] != arr[right]:\\n      if arr[left] > arr[right]:\\n        arr[left] = arr[right]\\n      else:\\n        arr[right] = arr[left]\\n      ops += 1\\n    left += 1\\n    right -= 1\\n\\n  if ops == 0:\\n    return s\\n\\n  result = \"\"\\n  for i in arr:\\n    result += i\\n\\n  return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549414,
                "title": "python-3-4-lines-w-explanation-an-example-t-m-82-71",
                "content": "```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:    #  Example: s = \\'sdnvnfe\\'\\n\\n        ans, n = list(s), len(s)                        # n = 7 ,  n//2 = 3\\n                                                        #         ans = [s, d, n, v, n, f, e]\\n        for i in range((n+1)//2): \\n                                                        #  i = 0: ans = [|e| ,d,n,v,n,f, |e|]\\n            ans[i]=ans[n-i-1] = min(ans[i],ans[n-i-1])  #  i = 1: ans = [e,|d|, n,v,n, |d|,e] \\n                                                        #  i = 2: ans = [e,d,|n|, v, |n|,d,e]\\n     \\n        return \\'\\'.join(ans)                             #  return ().join([e,d,n,v,n,d,e]) = \\'ednvnde\\'\\n```\\n[https://leetcode.com/problems/lexicographically-smallest-palindrome/submissions/954612212/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*), in which *N* ~`len(s)`.\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:    #  Example: s = \\'sdnvnfe\\'\\n\\n        ans, n = list(s), len(s)                        # n = 7 ,  n//2 = 3\\n                                                        #         ans = [s, d, n, v, n, f, e]\\n        for i in range((n+1)//2): \\n                                                        #  i = 0: ans = [|e| ,d,n,v,n,f, |e|]\\n            ans[i]=ans[n-i-1] = min(ans[i],ans[n-i-1])  #  i = 1: ans = [e,|d|, n,v,n, |d|,e] \\n                                                        #  i = 2: ans = [e,d,|n|, v, |n|,d,e]\\n     \\n        return \\'\\'.join(ans)                             #  return ().join([e,d,n,v,n,d,e]) = \\'ednvnde\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3895291,
                "title": "in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nRemoved the use of StringBuilder s1, as it was not necessary for the task. Instead, I directly manipulated the char array ch.\\nRemoved the unnecessary sorting of s1, as you only need to replace characters with the smaller of the two.\\nUsed (char) Math.min(ch[i], ch[j]) to determine the smaller character between ch[i] and ch[j].\\nChanged the loop condition to i < j to properly compare and replace characters.\\nThis corrected code should now correctly modify the given string s to create the smallest palindrome possible by replacing characters.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        char[] ch = s.toCharArray();\\n\\n        for (int i = 0, j = ch.length - 1; i < j; i++, j--) {\\n            if (ch[i] != ch[j]) {\\n                char smallerChar = (char) Math.min(ch[i], ch[j]);\\n                ch[i] = smallerChar;\\n                ch[j] = smallerChar;\\n            }\\n        }\\n\\n        return new String(ch);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        char[] ch = s.toCharArray();\\n\\n        for (int i = 0, j = ch.length - 1; i < j; i++, j--) {\\n            if (ch[i] != ch[j]) {\\n                char smallerChar = (char) Math.min(ch[i], ch[j]);\\n                ch[i] = smallerChar;\\n                ch[j] = smallerChar;\\n            }\\n        }\\n\\n        return new String(ch);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549244,
                "title": "python-elegant-short-o-n-4-lines",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        letters = list(s)\\n\\n        for i in range(len(s) // 2):\\n            letters[i] = letters[~i] = min(letters[i], letters[~i])\\n\\n        return \\'\\'.join(letters)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        letters = list(s)\\n\\n        for i in range(len(s) // 2):\\n            letters[i] = letters[~i] = min(letters[i], letters[~i])\\n\\n        return \\'\\'.join(letters)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546814,
                "title": "c-solution-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int left = 0;\\n        int right = s.length() - 1;\\n\\n        while (left < right) {\\n            if (s[left] != s[right]) {\\n                string modified1 = s;\\n                modified1[right] = s[left];\\n\\n                std::string modified2 = s;\\n                modified2[left] = s[right];\\n\\n                if (modified1 < modified2) {\\n                    s = modified1;\\n                } else {\\n                    s = modified2;\\n                }\\n            }\\n\\n            left++;\\n            right--;\\n        }\\n\\n        return s;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int left = 0;\\n        int right = s.length() - 1;\\n\\n        while (left < right) {\\n            if (s[left] != s[right]) {\\n                string modified1 = s;\\n                modified1[right] = s[left];\\n\\n                std::string modified2 = s;\\n                modified2[left] = s[right];\\n\\n                if (modified1 < modified2) {\\n                    s = modified1;\\n                } else {\\n                    s = modified2;\\n                }\\n            }\\n\\n            left++;\\n            right--;\\n        }\\n\\n        return s;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546780,
                "title": "easy-cpp-solution",
                "content": "\\n\\n# Code\\n```\\n#include <string>\\n#include <algorithm>\\n\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string str) {\\n        int start = 0;\\n        int end = str.length() - 1;\\n        char ch[str.length()];\\n        copy(str.begin(), str.end(), ch);\\n        \\n        while (start <= end) {\\n            if (ch[start] == ch[end]) {\\n                start++;\\n                end--;\\n            } else {\\n                int inder = ch[start] - \\'0\\';\\n                int jeet = ch[end] - \\'0\\';\\n                if (inder > jeet) {\\n                    ch[start] = ch[end];\\n                } else {\\n                    ch[end] = ch[start];\\n                }\\n                \\n                start++;\\n                end--;\\n            }\\n        }\\n        \\n        return string(ch, str.length());\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <string>\\n#include <algorithm>\\n\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string str) {\\n        int start = 0;\\n        int end = str.length() - 1;\\n        char ch[str.length()];\\n        copy(str.begin(), str.end(), ch);\\n        \\n        while (start <= end) {\\n            if (ch[start] == ch[end]) {\\n                start++;\\n                end--;\\n            } else {\\n                int inder = ch[start] - \\'0\\';\\n                int jeet = ch[end] - \\'0\\';\\n                if (inder > jeet) {\\n                    ch[start] = ch[end];\\n                } else {\\n                    ch[end] = ch[start];\\n                }\\n                \\n                start++;\\n                end--;\\n            }\\n        }\\n        \\n        return string(ch, str.length());\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3777491,
                "title": "simple-easy-to-understand-solution-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        char str[] = s.toCharArray();\\n        int i=0, j=s.length()-1;\\n        while(i<j){\\n            str[i] = (char)Math.min(str[i],str[j]);\\n            str[j]= str[i];\\n            i++;\\n            j--;\\n        }\\n        return new String(str);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        char str[] = s.toCharArray();\\n        int i=0, j=s.length()-1;\\n        while(i<j){\\n            str[i] = (char)Math.min(str[i],str[j]);\\n            str[j]= str[i];\\n            i++;\\n            j--;\\n        }\\n        return new String(str);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574517,
                "title": "python-simple-and-clean-beats-88",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n*This is an NFT*\\n\\n# Intuition\\nThe problem asks us to modify a given string `s` by performing operations on it. In one operation, we can replace a character in `s` with another lowercase English letter. Our task is to make `s` a palindrome with the minimum number of operations possible. If there are multiple palindromes that can be made using the minimum number of operations, we should make the lexicographically smallest one.\\n\\n# Approach\\n1. Convert the string `s` into a list of characters `s_list`.\\n\\n2. Initialize two pointers `l` and `r` at the start and end of the list respectively.\\n\\n3. Enter a while loop that runs until `l` is greater than or equal to `r`.\\n\\n4. Inside the loop, check if the character at index `l` is smaller than the character at index `r`. \\n\\n1. If it is, replace the character at index `r` with the character at index `l`.\\n\\n1. If the character at index `l` is greater than the character at index `r`, replace the character at index `l` with the character at index `r`.\\n\\n1. Increment `l` by 1 and decrement `r` by 1.\\n\\n1. After the loop ends, join the list back into a new string `new_s` and return it.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ where n is the length of string s.\\n- Space complexity: $$O(n)$$ where n is the length of string s.\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        s_list = list(s)\\n        l,r = 0, len(s_list)-1\\n        while l<r:\\n            if ord(s_list[l]) < ord(s_list[r]):\\n                s_list[r] = s_list[l]\\n            elif ord(s_list[l]) > ord(s_list[r]):\\n                s_list[l] = s_list[r]\\n            l+=1\\n            r-=1\\n        new_s = \\'\\'.join(s_list)\\n        return new_s        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        s_list = list(s)\\n        l,r = 0, len(s_list)-1\\n        while l<r:\\n            if ord(s_list[l]) < ord(s_list[r]):\\n                s_list[r] = s_list[l]\\n            elif ord(s_list[l]) > ord(s_list[r]):\\n                s_list[l] = s_list[r]\\n            l+=1\\n            r-=1\\n        new_s = \\'\\'.join(s_list)\\n        return new_s        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547540,
                "title": "diagram-image-explaination-c-full-optimized-2-ptr-well-explained",
                "content": "# Diagram\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n![code2flow_Gk6T30 (1).png](https://assets.leetcode.com/users/images/ae1522d1-3dc8-4459-981b-2f2ae9f9a7b2_1684650906.2661316.png)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nint i=0,j=s.length()-1;: Initialize two variables i and j to the start and end indices of the string respectively.\\n\\nwhile(i<j): While the indices i and j don\\'t cross each other, do the following:\\n\\nif(s[i]>s[j]): If the character at index i is greater than the character at index j, then replace the character at index i with the character at index j.\\n\\ns[i]=s[j];\\n\\nIncrement i and decrement j.\\n\\ni++;\\nj--;\\nelse: If the character at index i is less than or equal to the character at index j, then replace the character at index j with the character at index i.\\n\\ns[j]=s[i];\\n\\nIncrement i and decrement j.\\n\\ni++;\\nj--;\\nreturn s;: Return the modified string.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int i=0,j=s.length()-1;\\n        while(i<j)\\n        {\\n            if(s[i]>s[j])\\n            {\\n                s[i]=s[j];\\n                \\n                i++;\\n                j--;\\n            }\\n            else\\n            {\\n                s[j]=s[i];\\n                i++;\\n                j--;\\n            }\\n        }return s;\\n        \\n    }\\n};\\n```\\n![7abc56.jpg](https://assets.leetcode.com/users/images/275376dd-1a0c-4d7a-9d8e-1e79bdf27056_1684651072.6219082.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int i=0,j=s.length()-1;\\n        while(i<j)\\n        {\\n            if(s[i]>s[j])\\n            {\\n                s[i]=s[j];\\n                \\n                i++;\\n                j--;\\n            }\\n            else\\n            {\\n                s[j]=s[i];\\n                i++;\\n                j--;\\n            }\\n        }return s;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547083,
                "title": "python3-two-lines-use-smaller-characters",
                "content": "# Intuition\\nWe are checking pairs of characters: `s[i]` and `s[-i-1]` and replace them with the lexicograficaly smaller one of them.\\n\\n# Complexity\\n- Time complexity:\\n`O(N)`\\n\\n- Space complexity:\\n`O(N)`\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        pal=\\'\\'.join([min(a,b) for a,b in zip(s[:len(s)//2],s[::-1])])\\n        return pal + s[len(s)//2]*(len(s)%2) + pal[::-1]\\n```\\n# Code explanation in Python\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        n=len(s)\\n        pal=\\'\\'\\n        for a,b in zip(s[:n//2],s[::-1]):\\n            pal+=min(a,b)\\n        return pal + s[n//2]*(n%2) + pal[::-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        pal=\\'\\'.join([min(a,b) for a,b in zip(s[:len(s)//2],s[::-1])])\\n        return pal + s[len(s)//2]*(len(s)%2) + pal[::-1]\\n```\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        n=len(s)\\n        pal=\\'\\'\\n        for a,b in zip(s[:n//2],s[::-1]):\\n            pal+=min(a,b)\\n        return pal + s[n//2]*(n%2) + pal[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546827,
                "title": "easy-java-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust check forward and Backword elements are equal or Not. If Not then change bigger one to smaller one.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        int n = s.length();\\n        char[] str = new char[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            str[i] = s.charAt(i);\\n        }\\n        for(int i=0;i<n/2;i++)\\n        {\\n            if(str[i]!=str[n-i-1])\\n            {\\n                if((str[i]-\\'a\\')<(str[n-i-1]-\\'a\\'))\\n                {\\n                    str[n-i-1] = str[i];\\n                }\\n                else\\n                    str[i] = str[n-i-1];\\n            }\\n        }\\n        String st =\"\";\\n        for(int i=0;i<n;i++)\\n            st+=str[i];\\n        return st;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        int n = s.length();\\n        char[] str = new char[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            str[i] = s.charAt(i);\\n        }\\n        for(int i=0;i<n/2;i++)\\n        {\\n            if(str[i]!=str[n-i-1])\\n            {\\n                if((str[i]-\\'a\\')<(str[n-i-1]-\\'a\\'))\\n                {\\n                    str[n-i-1] = str[i];\\n                }\\n                else\\n                    str[i] = str[n-i-1];\\n            }\\n        }\\n        String st =\"\";\\n        for(int i=0;i<n;i++)\\n            st+=str[i];\\n        return st;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546758,
                "title": "short-clean-simple-java-solution",
                "content": "\\n```java []\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        for(int i=0; i<s.length()/2; i++){\\n            char c = (char)Math.min((int)s.charAt(i),(int)s.charAt(s.length()-1-i));\\n            s = s.substring(0,i) + c + s.substring(i+1,s.length()-i-1) + c + s.substring(s.length()-i);\\n        }\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        for(int i=0; i<s.length()/2; i++){\\n            char c = (char)Math.min((int)s.charAt(i),(int)s.charAt(s.length()-1-i));\\n            s = s.substring(0,i) + c + s.substring(i+1,s.length()-i-1) + c + s.substring(s.length()-i);\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788809,
                "title": "java-easy-solution-95-faster",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust check whether elements are equal in the first half and second half of the string. If not then change lexicographically bigger characters one to smaller ones.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n       var c = s.toCharArray();\\n       int i = 0, j = c.length - 1;\\n\\n       while(i < j) {\\n           if(c[i] < c[j])\\n              c[j --] = c[i ++];\\n           else\\n              c[i ++] = c[j --];\\n       } \\n       return new String(c);\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n       var c = s.toCharArray();\\n       int i = 0, j = c.length - 1;\\n\\n       while(i < j) {\\n           if(c[i] < c[j])\\n              c[j --] = c[i ++];\\n           else\\n              c[i ++] = c[j --];\\n       } \\n       return new String(c);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559914,
                "title": "transform",
                "content": "**C++**\\n```cpp\\nstring makeSmallestPalindrome(string s) {\\n    transform(begin(s), end(s), rbegin(s), begin(s), [](char a, char b){\\n        return min(a, b);\\n    });\\n    return s;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nstring makeSmallestPalindrome(string s) {\\n    transform(begin(s), end(s), rbegin(s), begin(s), [](char a, char b){\\n        return min(a, b);\\n    });\\n    return s;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3556253,
                "title": "easy-solution-in-java-8-ms-100-beats-fully-explained",
                "content": "\\n\\n# Approach\\n\\nTo solve the problem, we follow these steps:\\n\\n1. Convert the input string `s` into a character array `arr` for easy manipulation.\\n2. Determine the length of the array and store it in the variable `n`.\\n3. Iterate over the array from the beginning (`i = 0`) to the middle (`i < n / 2`).\\n4. Check if the characters at positions `i` and `j` (where `j = n - 1 - i`) are different.\\n5. If the characters are different, replace both characters with the lexicographically smaller one.\\n6. Finally, convert the modified character array `arr` back into a string and return it as the result.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        char[] arr = s.toCharArray();\\n        int n = arr.length;\\n        for(int i = 0, j = n - 1; i < n / 2; i++, j--)\\n            if(arr[i] != arr[j]){\\n                char smallOne = (char) Math.min(arr[i], arr[j]);\\n                arr[i] = arr[j] = smallOne;\\n            }\\n        return new String(arr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        char[] arr = s.toCharArray();\\n        int n = arr.length;\\n        for(int i = 0, j = n - 1; i < n / 2; i++, j--)\\n            if(arr[i] != arr[j]){\\n                char smallOne = (char) Math.min(arr[i], arr[j]);\\n                arr[i] = arr[j] = smallOne;\\n            }\\n        return new String(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550196,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        return \\'\\'.join(map(min,zip(s,s[::-1])))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        return \\'\\'.join(map(min,zip(s,s[::-1])))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547563,
                "title": "javascript-2697-lexicographically-smallest-palindrome",
                "content": "---\\n\\nWeekly Contest 346 solutions:\\n- Q1 - https://leetcode.com/problems/minimum-string-length-after-removing-substrings/solutions/3547566/javascript-2696-minimum-string-length-after-removing-substrings/\\n- Q2 - https://leetcode.com/problems/lexicographically-smallest-palindrome/solutions/3547563/javascript-2697-lexicographically-smallest-palindrome/\\n- Q3 - https://leetcode.com/problems/find-the-punishment-number-of-an-integer/solutions/3547553/javascript-2698-find-the-punishment-number-of-an-integer/\\n\\n---\\n\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst makeSmallestPalindrome = function (s) {\\n  const n = s.length\\n  s = s.split(\\'\\')\\n  const halfN = Math.trunc(n / 2)\\n  for (let i = 0; i < halfN; i++) {\\n    if (s[i] !== s[n - 1 - i]) {\\n      if (s[i] < s[n - 1 - i]) {\\n        s[n - 1 - i] = s[i]\\n      } else {\\n        s[i] = s[n - 1 - i]\\n      }\\n    }\\n  }\\n  return s.join(\\'\\')\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst makeSmallestPalindrome = function (s) {\\n  const n = s.length\\n  s = s.split(\\'\\')\\n  const halfN = Math.trunc(n / 2)\\n  for (let i = 0; i < halfN; i++) {\\n    if (s[i] !== s[n - 1 - i]) {\\n      if (s[i] < s[n - 1 - i]) {\\n        s[n - 1 - i] = s[i]\\n      } else {\\n        s[i] = s[n - 1 - i]\\n      }\\n    }\\n  }\\n  return s.join(\\'\\')\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3547388,
                "title": "easily-understandable-c-solution",
                "content": "# Intuition\\nJust try to make the (i)th and (l-1-i)th characters same with the given condition (The lower value charater shoulb be taken) #where l is the length of th string\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUse a for loop and iterate upto the middle and try to make the characters same with the given condition\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int l=s.length();\\n        for(int i=0;i<l/2;i++){\\n            if(s[i]!=s[l-1-i]){\\n                if(s[i]<s[l-1-i]){ //checking the ascii values of the \\n                                   // characters then making them same\\n                    s[l-1-i]=s[i];\\n                }\\n                else{\\n                    s[i]=s[l-1-i];\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int l=s.length();\\n        for(int i=0;i<l/2;i++){\\n            if(s[i]!=s[l-1-i]){\\n                if(s[i]<s[l-1-i]){ //checking the ascii values of the \\n                                   // characters then making them same\\n                    s[l-1-i]=s[i];\\n                }\\n                else{\\n                    s[i]=s[l-1-i];\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547028,
                "title": "simplest-of-all-solution-super-easy-to-understand",
                "content": "- Just compare front and back letters.\\n- If they are not equal then replace the larger letter with the smaller one.\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        for i in range(int(len(s)/2)):\\n            if s[i] != s[len(s)-i-1]:\\n                if s[i] < s[len(s)-i-1]:\\n                    s = s[:len(s)-i-1] + s[i] + s[len(s)-i:]\\n                else:\\n                    s = s[:i] + s[len(s)-i-1] + s[i+1:]\\n        return s\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        for i in range(int(len(s)/2)):\\n            if s[i] != s[len(s)-i-1]:\\n                if s[i] < s[len(s)-i-1]:\\n                    s = s[:len(s)-i-1] + s[i] + s[len(s)-i:]\\n                else:\\n                    s = s[:i] + s[len(s)-i-1] + s[i+1:]\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546839,
                "title": "two-pointers-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int l = 0, r = s.size() - 1;\\n        while(l < r) {\\n            if(s[l] != s[r]) {\\n                char c = min(s[l], s[r]);\\n                s[l] = s[r] = c;\\n            }\\n            l++, r--;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int l = 0, r = s.size() - 1;\\n        while(l < r) {\\n            if(s[l] != s[r]) {\\n                char c = min(s[l], s[r]);\\n                s[l] = s[r] = c;\\n            }\\n            l++, r--;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546717,
                "title": "c-easy-3-lines",
                "content": "\\n**<<<<UpVote**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int i=0,j=s.size()-1;\\n        while(i<j){\\n                if(s[i]<s[j]) s[j--]=s[i++];\\n                else s[i++]=s[j--];\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int i=0,j=s.size()-1;\\n        while(i<j){\\n                if(s[i]<s[j]) s[j--]=s[i++];\\n                else s[i++]=s[j--];\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897483,
                "title": "super-easy-solution-in-js-wow",
                "content": "\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar makeSmallestPalindrome = function(s) {\\n    let str = s.split(\\'\\')\\n    for(let i = s.length - 1, j = 0; i >= Math.ceil(s.length / 2); i--, j++) {\\n        if(str[i] < str[j]) {\\n            str[j] = str[i]\\n        } else {\\n            str[i] = str[j]\\n        }\\n    }\\n    return str.join(\\'\\')\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar makeSmallestPalindrome = function(s) {\\n    let str = s.split(\\'\\')\\n    for(let i = s.length - 1, j = 0; i >= Math.ceil(s.length / 2); i--, j++) {\\n        if(str[i] < str[j]) {\\n            str[j] = str[i]\\n        } else {\\n            str[i] = str[j]\\n        }\\n    }\\n    return str.join(\\'\\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3689476,
                "title": "c-easy",
                "content": "# Code\\n```\\npublic class Solution {\\n    public string MakeSmallestPalindrome(string s) {\\n        \\n        char[] sArr = s.ToArray();\\n\\n        for (int i = 0, j = s.Length - 1; j >= s.Length / 2; j--, i++)\\n        {\\n            if (s[i] != s[j])\\n            {\\n                if (s[i] < s[j])\\n                {\\n                    sArr[j] = s[i];\\n\\n                    continue;\\n                }\\n\\n                sArr[i] = s[j];\\n\\n            }\\n        }\\n\\n        return new string(sArr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string MakeSmallestPalindrome(string s) {\\n        \\n        char[] sArr = s.ToArray();\\n\\n        for (int i = 0, j = s.Length - 1; j >= s.Length / 2; j--, i++)\\n        {\\n            if (s[i] != s[j])\\n            {\\n                if (s[i] < s[j])\\n                {\\n                    sArr[j] = s[i];\\n\\n                    continue;\\n                }\\n\\n                sArr[i] = s[j];\\n\\n            }\\n        }\\n\\n        return new string(sArr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567588,
                "title": "simple-java-solution-for-beginners-9ms-beats-94-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        char arr[] = s.toCharArray();\\n        int i = 0;\\n        int j = arr.length - 1;\\n        while (i < j) {\\n            if (arr[i] < arr[j]) {\\n                arr[j--] = arr[i++];\\n            } else {\\n                arr[i++] = arr[j--];\\n            }\\n        }\\n    return new String(arr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        char arr[] = s.toCharArray();\\n        int i = 0;\\n        int j = arr.length - 1;\\n        while (i < j) {\\n            if (arr[i] < arr[j]) {\\n                arr[j--] = arr[i++];\\n            } else {\\n                arr[i++] = arr[j--];\\n            }\\n        }\\n    return new String(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563648,
                "title": "lexicographically-smallest-palindrome-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int i;\\n        for(i=0 ; i<s.length()/2 ; i++)\\n        {\\n            if(s[i]>s[s.length()-1-i])\\n            {\\n                s[i] = s[s.length()-1-i];\\n            }\\n            else\\n            {\\n                s[s.length()-1-i] = s[i];\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/69d30596-e4ec-4fc8-9dfd-f6573383ffd5_1685074084.2205186.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int i;\\n        for(i=0 ; i<s.length()/2 ; i++)\\n        {\\n            if(s[i]>s[s.length()-1-i])\\n            {\\n                s[i] = s[s.length()-1-i];\\n            }\\n            else\\n            {\\n                s[s.length()-1-i] = s[i];\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556492,
                "title": "java-one-pass",
                "content": "# Solution:\\n```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        int n = s.length();\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < n; i++) {\\n            sb.append((char) Math.min(s.charAt(i), s.charAt(n - i - 1)));\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n### Time complexity: $$O(n)$$",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        int n = s.length();\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < n; i++) {\\n            sb.append((char) Math.min(s.charAt(i), s.charAt(n - i - 1)));\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555937,
                "title": "python3-214-ms-16-5-mb",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 214 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 16.5 MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        before = 0\\n        after = len(s)-1\\n        l = [i for i in s]\\n        while before <= len(s)/2:\\n            l[before] = min(l[before], l[after])\\n            l[after] = l[before]\\n            before+=1\\n            after-=1\\n        return \"\".join(l)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        before = 0\\n        after = len(s)-1\\n        l = [i for i in s]\\n        while before <= len(s)/2:\\n            l[before] = min(l[before], l[after])\\n            l[after] = l[before]\\n            before+=1\\n            after-=1\\n        return \"\".join(l)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549800,
                "title": "replace-with-minimum",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int n = size(s);\\n        for(int i=0; i<=n/2; ++i){\\n            if(s[i] != s[n-i-1]){\\n                char e = min(s[i],s[n-i-1]);\\n                s[i] = e;\\n                s[n-i-1] = e;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int n = size(s);\\n        for(int i=0; i<=n/2; ++i){\\n            if(s[i] != s[n-i-1]){\\n                char e = min(s[i],s[n-i-1]);\\n                s[i] = e;\\n                s[n-i-1] = e;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548129,
                "title": "c-easy-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        string t = s;\\n        reverse(t.begin(), t.end());\\n        string ans = \"\";\\n        for(int i=0;i<s.length();i++){\\n            if(s[i] == t[i]){\\n                ans.push_back(s[i]);\\n            }\\n            else{\\n                char m = min(s[i], t[i]);\\n                ans.push_back(m);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        string t = s;\\n        reverse(t.begin(), t.end());\\n        string ans = \"\";\\n        for(int i=0;i<s.length();i++){\\n            if(s[i] == t[i]){\\n                ans.push_back(s[i]);\\n            }\\n            else{\\n                char m = min(s[i], t[i]);\\n                ans.push_back(m);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548050,
                "title": "simple-easy-javascript-solution-100-beats-51-7-mb-memory",
                "content": "# Code\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar makeSmallestPalindrome = function(s) {\\nlet newString = \"\"\\nfor(let i=0 ; i< s.length ; i ++){\\n    let firstWord = s.charAt(i);\\n    let lastWord = s.charAt(s.length -i - 1);\\n    if(firstWord!==lastWord){\\n        if(firstWord.charCodeAt(0)>lastWord.charCodeAt(0)){\\n            firstWord = lastWord\\n        }\\n    }\\n    newString = newString + firstWord \\n}\\nreturn(newString)\\n\\n  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar makeSmallestPalindrome = function(s) {\\nlet newString = \"\"\\nfor(let i=0 ; i< s.length ; i ++){\\n    let firstWord = s.charAt(i);\\n    let lastWord = s.charAt(s.length -i - 1);\\n    if(firstWord!==lastWord){\\n        if(firstWord.charCodeAt(0)>lastWord.charCodeAt(0)){\\n            firstWord = lastWord\\n        }\\n    }\\n    newString = newString + firstWord \\n}\\nreturn(newString)\\n\\n  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3547600,
                "title": "clean-py",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        r,l,s=len(s)-1,0,list(s)\\n        while r>l:\\n            if s[r]>s[l]:s[r]=s[l]\\n            else:s[l]=s[r]\\n            r-=1\\n            l+=1\\n        return \"\".join([i for i in s])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        r,l,s=len(s)-1,0,list(s)\\n        while r>l:\\n            if s[r]>s[l]:s[r]=s[l]\\n            else:s[l]=s[r]\\n            r-=1\\n            l+=1\\n        return \"\".join([i for i in s])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547259,
                "title": "c-o-n-solution-two-pointers",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach: Two Pointers\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        string ans = s; // because changing the given data is not good practice\\n        int i = 0, j = s.size() - 1;\\n        while(i < j) {\\n            if(ans[i] != ans[j]) {\\n                if(ans[i] < ans[j]) ans[j] = ans[i];\\n                else ans[i] = ans[j];\\n            }\\n            i++, j--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        string ans = s; // because changing the given data is not good practice\\n        int i = 0, j = s.size() - 1;\\n        while(i < j) {\\n            if(ans[i] != ans[j]) {\\n                if(ans[i] < ans[j]) ans[j] = ans[i];\\n                else ans[i] = ans[j];\\n            }\\n            i++, j--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547256,
                "title": "easy-and-simple-solution",
                "content": "\\n# Complexity\\n- Time complexity:$O(n/2)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) \\n    {\\n        int first=0;\\n        int last=s.length()-1;\\n        while(first<=last)\\n        {\\n            if(s[first]!=s[last])\\n            {\\n                char k=min(s[first],s[last]);\\n                s[first]=k;\\n                s[last]=k;\\n            }\\n            first++;\\n            last--;\\n            \\n        }\\n        return s;\\n    }\\n};\\n```\\n# upvote me if you like the solution comment if any doubts\\n![images.jpeg](https://assets.leetcode.com/users/images/2996b8fb-ec16-4502-b820-a3705727a230_1684646601.8691707.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) \\n    {\\n        int first=0;\\n        int last=s.length()-1;\\n        while(first<=last)\\n        {\\n            if(s[first]!=s[last])\\n            {\\n                char k=min(s[first],s[last]);\\n                s[first]=k;\\n                s[last]=k;\\n            }\\n            first++;\\n            last--;\\n            \\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547182,
                "title": "very-simple-c-solution-with-100-time-and-space-complexity",
                "content": "# Intuition\\nPlease UPVOTE if you LIKE the Solution and COMMENT your own Code and thoughts.\\n\\n# Approach\\nThese Type of Questions are Solved using Two pointers,\\nOne from Starting index i=0 and other from end r=size of string -1.\\n\\n# Complexity\\n- Time complexity:\\n100%\\n\\n- Space complexity:\\n100%\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int i=0,r=s.size()-1;\\n        while(i<r)\\n        {\\n            if(s[i]!=s[r])\\n            {\\n                s[i]=s[r]=(s[i]<s[r])?s[i]:s[r];\\n            }\\n            i++;\\n            r--;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int i=0,r=s.size()-1;\\n        while(i<r)\\n        {\\n            if(s[i]!=s[r])\\n            {\\n                s[i]=s[r]=(s[i]<s[r])?s[i]:s[r];\\n            }\\n            i++;\\n            r--;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547088,
                "title": "easiest-2-pointers-approach-short-code-explained",
                "content": "# Intuition\\nWe need to make the string palindrome. Thus we need to compare first and last indices.\\n\\n# Approach\\n- **(step 1)** Keep one index at beginning of string and other at the end.\\n- **(case 1)** Update the first index to the character at last index if last index character is alphabetically smaller.\\n- **(case 2)** Else update last index character to first index character.\\n- **(step 3)** Increment and decrement the first and last indexes.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int i=0, int j=s.size()-1; //Step 1\\n        while(i<j){\\n            if(s[i]<=s[j]) s[j]=s[i]; //Case 1\\n            else s[i]=s[j]; //Case 2\\n            i++,j--; //Step 3\\n        }\\n        return s;\\n    }\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int i=0, int j=s.size()-1; //Step 1\\n        while(i<j){\\n            if(s[i]<=s[j]) s[j]=s[i]; //Case 1\\n            else s[i]=s[j]; //Case 2\\n            i++,j--; //Step 3\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547048,
                "title": "simple-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int n=s.size();\\n        for(int i=0 ; i < n/2 ; i++){\\n            char a=s[i];\\n            char b=s[s.size()-i-1];\\n            char mini=min(a,b);\\n            s[i]=mini;\\n            s[s.size()-i-1]=mini;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int n=s.size();\\n        for(int i=0 ; i < n/2 ; i++){\\n            char a=s[i];\\n            char b=s[s.size()-i-1];\\n            char mini=min(a,b);\\n            s[i]=mini;\\n            s[s.size()-i-1]=mini;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547013,
                "title": "c-easiest-4-lines-of-code",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n/2)$$\\n\\n- Space complexity:$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        for(int i=0; i<s.size()/2; i++){\\n            if(s[i]!=s[s.size()-1-i]){\\n                (s[i]<s[s.size()-1-i])?s[s.size()-1-i]=s[i]:s[i]=s[s.size()-1-i];\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        for(int i=0; i<s.size()/2; i++){\\n            if(s[i]!=s[s.size()-1-i]){\\n                (s[i]<s[s.size()-1-i])?s[s.size()-1-i]=s[i]:s[i]=s[s.size()-1-i];\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547009,
                "title": "simple-two-pointer-solution-java",
                "content": "**Approach:** Take two pointers one at 0 index other at last-1 at each iteration replace the large character with smaller one in stringbuilder return the string at last.\\n```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        StringBuilder sb = new StringBuilder(s);\\n        int f=0,l=s.length()-1;\\n        while(f<l){\\n            if(s.charAt(f)>s.charAt(l)){\\n              sb.replace(f,f+1,s.charAt(l)+\"\");  \\n            }\\n            else sb.replace(l,l+1,s.charAt(f)+\"\");\\n            f++;\\n            l--;\\n        }\\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        StringBuilder sb = new StringBuilder(s);\\n        int f=0,l=s.length()-1;\\n        while(f<l){\\n            if(s.charAt(f)>s.charAt(l)){\\n              sb.replace(f,f+1,s.charAt(l)+\"\");  \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3547001,
                "title": "beats-100-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar makeSmallestPalindrome = function(s) {\\n    \\n     let rev = s.split(\"\").reverse().join(\"\");\\n        let str = \\'\\';\\n\\n        for(let i = 0 ; i < s.length ; i++)\\n            {\\n                const item1 = s[i];\\n                const item2 = rev[i];\\n\\n                if( item1 === item2 )\\n                {\\n                    str += item1;\\n                }\\n                else\\n                {\\n                    if(s.charCodeAt(i) < rev.charCodeAt(i))\\n                    {\\n                        str += item1;\\n                    }\\n                    else\\n                    {\\n                        str += item2;\\n                    }\\n                }\\n            }\\n    return str;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar makeSmallestPalindrome = function(s) {\\n    \\n     let rev = s.split(\"\").reverse().join(\"\");\\n        let str = \\'\\';\\n\\n        for(let i = 0 ; i < s.length ; i++)\\n            {\\n                const item1 = s[i];\\n                const item2 = rev[i];\\n\\n                if( item1 === item2 )\\n                {\\n                    str += item1;\\n                }\\n                else\\n                {\\n                    if(s.charCodeAt(i) < rev.charCodeAt(i))\\n                    {\\n                        str += item1;\\n                    }\\n                    else\\n                    {\\n                        str += item2;\\n                    }\\n                }\\n            }\\n    return str;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3546980,
                "title": "lexicographically-smallest-palindrome-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int i=0;\\n        int j=s.size()-1;\\n    \\n        while(i<j){\\n            if(s[i]!=s[j]){\\n                if(int(s[i])>int(s[j]))   s[i]=s[j];\\n                else    s[j]=s[i];\\n            }\\n            i++;\\n            j--;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int i=0;\\n        int j=s.size()-1;\\n    \\n        while(i<j){\\n            if(s[i]!=s[j]){\\n                if(int(s[i])>int(s[j]))   s[i]=s[j];\\n                else    s[j]=s[i];\\n            }\\n            i++;\\n            j--;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546961,
                "title": "easiest-java-solution-ever",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        char[] arr = s.toCharArray();\\n        int n = arr.length;\\n\\n        for (int i = 0; i < n / 2; i++) {\\n            int j = n - i - 1;\\n            if (arr[i] != arr[j]) {\\n                arr[j] = arr[i] < arr[j] ? arr[i] : arr[j];\\n                arr[i] = arr[j];\\n            }\\n        }\\n\\n        return new String(arr);\\n    }\\n}\\n```\\n`**UPVOTE PLEASE**``\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        char[] arr = s.toCharArray();\\n        int n = arr.length;\\n\\n        for (int i = 0; i < n / 2; i++) {\\n            int j = n - i - 1;\\n            if (arr[i] != arr[j]) {\\n                arr[j] = arr[i] < arr[j] ? arr[i] : arr[j];\\n                arr[i] = arr[j];\\n            }\\n        }\\n\\n        return new String(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546946,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTake the smallest from s[i] and s[n-i-1] for every index  (0 <= i < n/2)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int n = s.size();\\n        for(int i=0; i<n/2; i++)\\n        {\\n            if(s[i] > s[n-i-1]) s[i] = s[n-i-1];\\n            else s[n-i-1] = s[i];\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int n = s.size();\\n        for(int i=0; i<n/2; i++)\\n        {\\n            if(s[i] > s[n-i-1]) s[i] = s[n-i-1];\\n            else s[n-i-1] = s[i];\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546912,
                "title": "very-simple-and-easy-to-understand-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        def helper(s) :\\n            if len(s) <2 :\\n                return s\\n            \\n            \\n            if ord(s[0]) <= ord(s[-1]) :\\n                return s[0] + helper(s[1:len(s)-1]) +s[0]\\n            else :\\n                return s[-1]+helper(s[1:len(s)-1]) + s[-1]\\n        \\n            \\n        return helper(s)\\n                    \\n                \\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        def helper(s) :\\n            if len(s) <2 :\\n                return s\\n            \\n            \\n            if ord(s[0]) <= ord(s[-1]) :\\n                return s[0] + helper(s[1:len(s)-1]) +s[0]\\n            else :\\n                return s[-1]+helper(s[1:len(s)-1]) + s[-1]\\n        \\n            \\n        return helper(s)\\n                    \\n                \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546867,
                "title": "java-easy-solution-100-faster",
                "content": "\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n     \\n       char []ch=s.toCharArray();\\n       \\n        int i=0;\\n        int j=s.length()-1;\\n        while(i<=j)\\n        {\\n            if(ch[i]<ch[j])ch[j]=ch[i];\\n            else if(ch[i]>ch[j])ch[i]=ch[j];\\n            i++;\\n            j--;\\n        }\\n        StringBuilder S=new StringBuilder();\\n        for(char c:ch) S.append(c);\\n        \\n        return S.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n     \\n       char []ch=s.toCharArray();\\n       \\n        int i=0;\\n        int j=s.length()-1;\\n        while(i<=j)\\n        {\\n            if(ch[i]<ch[j])ch[j]=ch[i];\\n            else if(ch[i]>ch[j])ch[i]=ch[j];\\n            i++;\\n            j--;\\n        }\\n        StringBuilder S=new StringBuilder();\\n        for(char c:ch) S.append(c);\\n        \\n        return S.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546833,
                "title": "check-if-you-need-to-change-character-if-yes-change-to-smaller",
                "content": "# Intuition\\nCheck for every position until the half of the string, check if elements are the same:\\n - if yes, nothing to be done\\n - if no, modify one of them by changing it to a smaller character\\n\\n\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $O(n)$\\n\\n# Code\\n\\n```Rust []\\nimpl Solution {\\n  pub fn make_smallest_palindrome(s: String) -> String {\\n    let l = s.len();\\n    let mut s: Vec<char> = s.chars().collect();\\n    for i in 0 .. l / 2 {\\n      if s[i] != s[l - i - 1] {\\n        let v = s[i].min(s[l - i - 1]);\\n        s[i] = v;\\n        s[l - i - 1] = v;\\n      }\\n    }\\n\\n    return s.into_iter().collect();\\n  }\\n}\\n```\\n```python []\\nclass Solution:\\n  def makeSmallestPalindrome(self, s: str) -> str:\\n    s, l = list(s), len(s)\\n    for i in range(l // 2):\\n      if s[i] != s[l - i - 1]:\\n        c = min(s[i], s[l - i - 1])\\n        s[i], s[l - i - 1] = c, c\\n    \\n    return \\'\\'.join(s)\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Rust"
                ],
                "code": "```Rust []\\nimpl Solution {\\n  pub fn make_smallest_palindrome(s: String) -> String {\\n    let l = s.len();\\n    let mut s: Vec<char> = s.chars().collect();\\n    for i in 0 .. l / 2 {\\n      if s[i] != s[l - i - 1] {\\n        let v = s[i].min(s[l - i - 1]);\\n        s[i] = v;\\n        s[l - i - 1] = v;\\n      }\\n    }\\n\\n    return s.into_iter().collect();\\n  }\\n}\\n```\n```python []\\nclass Solution:\\n  def makeSmallestPalindrome(self, s: str) -> str:\\n    s, l = list(s), len(s)\\n    for i in range(l // 2):\\n      if s[i] != s[l - i - 1]:\\n        c = min(s[i], s[l - i - 1])\\n        s[i], s[l - i - 1] = c, c\\n    \\n    return \\'\\'.join(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546791,
                "title": "very-simple-and-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        \\n        \\n        string ans;\\n        while(i<j){\\n            if(s[i]!=s[j]){\\n                ans+=min(s[i],s[j]);\\n            }\\n            else{\\n                ans+=s[i];\\n            }\\n            i++;\\n            j--;\\n        }\\n        string q=ans;\\n        reverse(q.begin(),q.end());\\n        \\n        int n=s.size();\\n        if(n%2)ans+=s[n/2];\\n        ans+=q;\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        \\n        \\n        string ans;\\n        while(i<j){\\n            if(s[i]!=s[j]){\\n                ans+=min(s[i],s[j]);\\n            }\\n            else{\\n                ans+=s[i];\\n            }\\n            i++;\\n            j--;\\n        }\\n        string q=ans;\\n        reverse(q.begin(),q.end());\\n        \\n        int n=s.size();\\n        if(n%2)ans+=s[n/2];\\n        ans+=q;\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546785,
                "title": "java-o-n",
                "content": "``` java []\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        int i=0;\\n        int j=s.length()-1;\\n        char[] arr = s.toCharArray();\\n        while(i<=j){\\n            if(arr[i]!=arr[j]){\\n                arr[i] = arr[j] = (char) Math.min(arr[i],arr[j]);\\n            }\\n            i++;\\n            j--;\\n        }\\n        return new String(arr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java []\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        int i=0;\\n        int j=s.length()-1;\\n        char[] arr = s.toCharArray();\\n        while(i<=j){\\n            if(arr[i]!=arr[j]){\\n                arr[i] = arr[j] = (char) Math.min(arr[i],arr[j]);\\n            }\\n            i++;\\n            j--;\\n        }\\n        return new String(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546779,
                "title": "java",
                "content": "# Code\\n```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        char[] ch = s.toCharArray();\\n        int start = 0;\\n        int end = s.length() - 1;\\n        \\n        while(start <= end) {\\n            if(ch[start] != ch[end]) {\\n                if(ch[end] > ch[start]) {\\n                    ch[end] = ch[start];\\n                } else {\\n                    ch[start] = ch[end];\\n                }\\n            }\\n            start++;\\n            end--;\\n        }\\n        \\n        return String.valueOf(ch);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        char[] ch = s.toCharArray();\\n        int start = 0;\\n        int end = s.length() - 1;\\n        \\n        while(start <= end) {\\n            if(ch[start] != ch[end]) {\\n                if(ch[end] > ch[start]) {\\n                    ch[end] = ch[start];\\n                } else {\\n                    ch[start] = ch[end];\\n                }\\n            }\\n            start++;\\n            end--;\\n        }\\n        \\n        return String.valueOf(ch);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4094684,
                "title": "python3-two-pointers",
                "content": "\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        s = list(s) \\n        n = len(s)\\n        for i in range(n // 2):\\n            right = n - i - 1\\n            if s[i] < s[right]:\\n                s[right] = s[i]\\n            elif s[i] > s[right]:\\n                s[i] = s[right]\\n        return \"\".join(s)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        s = list(s) \\n        n = len(s)\\n        for i in range(n // 2):\\n            right = n - i - 1\\n            if s[i] < s[right]:\\n                s[right] = s[i]\\n            elif s[i] > s[right]:\\n                s[i] = s[right]\\n        return \"\".join(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085684,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n     public String makeSmallestPalindrome(String s) {\\n        StringBuilder str = new StringBuilder(s);\\n        int n = str.length();\\n        for (int i = 0; i <= str.length()/2; i++){\\n            if(str.charAt(i) != str.charAt(n-1-i)){\\n                if(str.charAt(i) > str.charAt(n-1-i)){\\n                    str.setCharAt(i, str.charAt(n-1-i));\\n                }else{\\n                    str.setCharAt(n-1-i, str.charAt(i));\\n                }\\n            }\\n        }\\n        return  str.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     public String makeSmallestPalindrome(String s) {\\n        StringBuilder str = new StringBuilder(s);\\n        int n = str.length();\\n        for (int i = 0; i <= str.length()/2; i++){\\n            if(str.charAt(i) != str.charAt(n-1-i)){\\n                if(str.charAt(i) > str.charAt(n-1-i)){\\n                    str.setCharAt(i, str.charAt(n-1-i));\\n                }else{\\n                    str.setCharAt(n-1-i, str.charAt(i));\\n                }\\n            }\\n        }\\n        return  str.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081062,
                "title": "my-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        for i in range(len(s)//2+1):\\n            if s[i]==s[-i-1]:\\n                continue\\n            else:\\n                if ord(s[-i-1])<ord(s[i]):\\n                    s=s[0:i]+s[-i-1]+s[i+1:]\\n                else:\\n                    if i!=0:\\n                        s=s[0:-i-1]+s[i]+s[-i:]\\n                    else:\\n                        s=s[0:-i-1]+s[i]\\n        return s\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        for i in range(len(s)//2+1):\\n            if s[i]==s[-i-1]:\\n                continue\\n            else:\\n                if ord(s[-i-1])<ord(s[i]):\\n                    s=s[0:i]+s[-i-1]+s[i+1:]\\n                else:\\n                    if i!=0:\\n                        s=s[0:-i-1]+s[i]+s[-i:]\\n                    else:\\n                        s=s[0:-i-1]+s[i]\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4076074,
                "title": "two-pointers-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        int i = 0, j = s.length()-1;\\n        char[] ch = s.toCharArray();\\n        while(i<j){\\n            if(ch[i] == ch[j]){\\n                i++;\\n                j--;\\n            }\\n            else{\\n                char c1 = ch[i];\\n                char c2 = ch[j];\\n                if(c1<c2)\\n                ch[j] = c1;\\n                else\\n                ch[i] = c2;\\n                i++;\\n                j--;\\n            }\\n        }\\n        return new String(ch);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        int i = 0, j = s.length()-1;\\n        char[] ch = s.toCharArray();\\n        while(i<j){\\n            if(ch[i] == ch[j]){\\n                i++;\\n                j--;\\n            }\\n            else{\\n                char c1 = ch[i];\\n                char c2 = ch[j];\\n                if(c1<c2)\\n                ch[j] = c1;\\n                else\\n                ch[i] = c2;\\n                i++;\\n                j--;\\n            }\\n        }\\n        return new String(ch);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068540,
                "title": "simple-java-solution-more-than-92-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        int i=0, j = s.length()-1;\\n        char[] arr = s.toCharArray();\\n        while(i < j){\\n            if(arr[i] < arr[j]){\\n                arr[j--] = arr[i++]; \\n            }\\n            else if(arr[j] < arr[i]){\\n                arr[i++] = arr[j--];\\n            }\\n            else{\\n                j--;\\n                i++;\\n            }\\n        }\\n        return String.valueOf(arr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        int i=0, j = s.length()-1;\\n        char[] arr = s.toCharArray();\\n        while(i < j){\\n            if(arr[i] < arr[j]){\\n                arr[j--] = arr[i++]; \\n            }\\n            else if(arr[j] < arr[i]){\\n                arr[i++] = arr[j--];\\n            }\\n            else{\\n                j--;\\n                i++;\\n            }\\n        }\\n        return String.valueOf(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064226,
                "title": "2697-lexicographically-smallest-palindrome",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n\\n        \\tint left = 0;\\n\\t\\tint right = s.length()-1;\\n\\t\\tchar[] ch = s.toCharArray();\\n\\t\\twhile(left<right) {\\n\\t\\t\\tif(ch[left]==ch[right]) {\\n\\t\\t\\t\\tleft ++;\\n\\t\\t\\t\\tright --;\\n\\t\\t\\t\\t\\n\\t\\t\\t}else {\\n\\t\\t\\t\\t//ch[left]=ch[right];\\n\\t\\t\\t\\tif(ch[left]<ch[right]) {\\n\\t\\t\\t\\t\\tch[right]=ch[left];\\n\\t\\t\\t\\t}else {\\n\\t\\t\\t\\t\\tch[left] = ch[right];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn new String(ch);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n\\n        \\tint left = 0;\\n\\t\\tint right = s.length()-1;\\n\\t\\tchar[] ch = s.toCharArray();\\n\\t\\twhile(left<right) {\\n\\t\\t\\tif(ch[left]==ch[right]) {\\n\\t\\t\\t\\tleft ++;\\n\\t\\t\\t\\tright --;\\n\\t\\t\\t\\t\\n\\t\\t\\t}else {\\n\\t\\t\\t\\t//ch[left]=ch[right];\\n\\t\\t\\t\\tif(ch[left]<ch[right]) {\\n\\t\\t\\t\\t\\tch[right]=ch[left];\\n\\t\\t\\t\\t}else {\\n\\t\\t\\t\\t\\tch[left] = ch[right];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn new String(ch);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063780,
                "title": "java-two-pointers-technique",
                "content": "# Intuition\\n<!-- Easy -->\\n\\n# Approach\\n<!-- Two Pointers technique -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- O[N] -->\\n\\n- Space complexity:\\n<!-- O[N] -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n\\n        char[] output = s.toCharArray();\\n        int left =0, right = output.length-1;\\n\\n        while(left<right){\\n            if(output[right]<output[left]){\\n                output[left] = output[right];\\n            }\\n             if(output[left]<output[right]){\\n                output[right] = output[left];\\n            }\\n            left++;\\n            right--;\\n        }\\n        return new String(output);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n\\n        char[] output = s.toCharArray();\\n        int left =0, right = output.length-1;\\n\\n        while(left<right){\\n            if(output[right]<output[left]){\\n                output[left] = output[right];\\n            }\\n             if(output[left]<output[right]){\\n                output[right] = output[left];\\n            }\\n            left++;\\n            right--;\\n        }\\n        return new String(output);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060013,
                "title": "using-string-builder-but-could-decrease-run-time-using-char-array-and-same-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i <s.length() ; i++) {\\n            sb.append(s.charAt(i));\\n        }\\n        int l=0,h=s.length()-1;\\n        while (h>l) {\\n            if (s.charAt(l) == s.charAt(h)) {\\n                sb.setCharAt(l, s.charAt(l));\\n                sb.setCharAt(h, s.charAt(h));\\n\\n            } else {\\n                if (s.charAt(l) - \\'0\\' > s.charAt(h) - \\'0\\') {\\n                    sb.setCharAt(l, s.charAt(h));\\n                    sb.setCharAt(h, s.charAt(h));\\n                } else {\\n                    sb.setCharAt(h, s.charAt(l));\\n                    sb.setCharAt(l, s.charAt(l));\\n                }\\n            }\\n            l++;\\n            h--;\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i <s.length() ; i++) {\\n            sb.append(s.charAt(i));\\n        }\\n        int l=0,h=s.length()-1;\\n        while (h>l) {\\n            if (s.charAt(l) == s.charAt(h)) {\\n                sb.setCharAt(l, s.charAt(l));\\n                sb.setCharAt(h, s.charAt(h));\\n\\n            } else {\\n                if (s.charAt(l) - \\'0\\' > s.charAt(h) - \\'0\\') {\\n                    sb.setCharAt(l, s.charAt(h));\\n                    sb.setCharAt(h, s.charAt(h));\\n                } else {\\n                    sb.setCharAt(h, s.charAt(l));\\n                    sb.setCharAt(l, s.charAt(l));\\n                }\\n            }\\n            l++;\\n            h--;\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047928,
                "title": "beats-85-in-place-approach",
                "content": "# Code\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar makeSmallestPalindrome = function(s) {\\n    let l = 0\\n    let r = s.length - 1\\n    s = s.split(\\'\\')\\n\\n    while(l < r) {\\n        if(s[l] != s[r]) {\\n            if(s[l] < s[r]) {\\n                s[r] = s[l]\\n            } else {\\n                s[l] = s[r]\\n            }\\n        }\\n        l++\\n        r--\\n    }\\n\\n    return s.join(\\'\\')\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar makeSmallestPalindrome = function(s) {\\n    let l = 0\\n    let r = s.length - 1\\n    s = s.split(\\'\\')\\n\\n    while(l < r) {\\n        if(s[l] != s[r]) {\\n            if(s[l] < s[r]) {\\n                s[r] = s[l]\\n            } else {\\n                s[l] = s[r]\\n            }\\n        }\\n        l++\\n        r--\\n    }\\n\\n    return s.join(\\'\\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4046316,
                "title": "brute-force-approch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n// if string is palindrome then return simple string s        \\n    if(isPalindrome(s)){\\n          return s;\\n        }\\n// else string is not palindrome then convert s to charactere Array \\n        else{\\n          char[]c=s.toCharArray();\\n          int left =0;\\n          int right =s.length()-1;\\n          while(left<right){\\n            if(c[left]!=c[right]){\\n// if left is not equal then we simply check minimum character and replace the minimum character where it is needed by using ternary operater//\\n\\n              char minChar = c[left]<c[right] ? c[left]:c[right];\\n              c[left]=minChar;\\n              c[right]=minChar;\\n            }\\n            left++;\\n            right--;\\n          }\\n          return new String(c);\\n        }\\n    }\\n // Here we check that string is palindrome or not\\n    public boolean isPalindrome(String s){\\n      int left =0;\\n      int right =s.length()-1;\\n      while(left<right){\\n        if(s.charAt(left)!=s.charAt(right)){\\n          return false;\\n        }\\n        left++;\\n        right--;\\n      }\\n      return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n// if string is palindrome then return simple string s        \\n    if(isPalindrome(s)){\\n          return s;\\n        }\\n// else string is not palindrome then convert s to charactere Array \\n        else{\\n          char[]c=s.toCharArray();\\n          int left =0;\\n          int right =s.length()-1;\\n          while(left<right){\\n            if(c[left]!=c[right]){\\n// if left is not equal then we simply check minimum character and replace the minimum character where it is needed by using ternary operater//\\n\\n              char minChar = c[left]<c[right] ? c[left]:c[right];\\n              c[left]=minChar;\\n              c[right]=minChar;\\n            }\\n            left++;\\n            right--;\\n          }\\n          return new String(c);\\n        }\\n    }\\n // Here we check that string is palindrome or not\\n    public boolean isPalindrome(String s){\\n      int left =0;\\n      int right =s.length()-1;\\n      while(left<right){\\n        if(s.charAt(left)!=s.charAt(right)){\\n          return false;\\n        }\\n        left++;\\n        right--;\\n      }\\n      return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042897,
                "title": "simple-and-easy-to-understand-cpp-solution-that-beats-100-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int i=0;\\n        while(i<s.length()/2)\\n        {\\n            char c1 = s[i];\\n            char c2 = s[s.length()-i-1];\\n            if(c1!=c2)\\n            {\\n                if(c1<c2)\\n                {\\n                    s[s.length()-i-1] = c1;\\n                }\\n                else\\n                {\\n                    s[i] = c2;\\n                }\\n            }\\n            i++;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int i=0;\\n        while(i<s.length()/2)\\n        {\\n            char c1 = s[i];\\n            char c2 = s[s.length()-i-1];\\n            if(c1!=c2)\\n            {\\n                if(c1<c2)\\n                {\\n                    s[s.length()-i-1] = c1;\\n                }\\n                else\\n                {\\n                    s[i] = c2;\\n                }\\n            }\\n            i++;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042394,
                "title": "typescript-javascript-straightforward-solution",
                "content": "ja# Code\\n```\\nfunction makeSmallestPalindrome(s: string): string {\\n    const arr = Array.from(s);\\n    const n = arr.length;\\n\\n    for (let i = 0; i < n / 2; i++) {\\n        let left = arr[i];\\n        let right = arr[n - i - 1];\\n\\n        if (left !== right) {\\n            if (left < right) {\\n                arr[n - i - 1] = left;\\n            } else {\\n                arr[i] = right;\\n            }\\n        }\\n    }\\n\\n    return arr.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction makeSmallestPalindrome(s: string): string {\\n    const arr = Array.from(s);\\n    const n = arr.length;\\n\\n    for (let i = 0; i < n / 2; i++) {\\n        let left = arr[i];\\n        let right = arr[n - i - 1];\\n\\n        if (left !== right) {\\n            if (left < right) {\\n                arr[n - i - 1] = left;\\n            } else {\\n                arr[i] = right;\\n            }\\n        }\\n    }\\n\\n    return arr.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4041229,
                "title": "maang-solution-two-pointers-python-beginner-friendly",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        a, b, word = 0, len(s) - 1, list(s)\\n        while a < b:\\n            if s[a] != s[b]:\\n                if s[a] < s[b]:\\n                    word[b] = word[a]\\n                else:\\n                    word[a] = s[b]\\n            a += 1\\n            b -= 1\\n        return \\'\\'.join(word)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        a, b, word = 0, len(s) - 1, list(s)\\n        while a < b:\\n            if s[a] != s[b]:\\n                if s[a] < s[b]:\\n                    word[b] = word[a]\\n                else:\\n                    word[a] = s[b]\\n            a += 1\\n            b -= 1\\n        return \\'\\'.join(word)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039699,
                "title": "python-using-list-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        splt=[]\\n        for chrt in s:\\n            splt.append(chrt)\\n        slen=len(splt)\\n        j=slen-1\\n        i=0\\n        strN=\\'\\'\\n        while i < j:\\n            strN =s\\n            if splt[i] !=splt[j]:\\n                if (ord(splt[i]) < ord(splt[j])):\\n                    splt[j]=splt[i]\\n                else:\\n                    splt[i] = splt[j]\\n            i+=1\\n            j-=1\\n        string= \"\".join(splt)\\n        return string\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        splt=[]\\n        for chrt in s:\\n            splt.append(chrt)\\n        slen=len(splt)\\n        j=slen-1\\n        i=0\\n        strN=\\'\\'\\n        while i < j:\\n            strN =s\\n            if splt[i] !=splt[j]:\\n                if (ord(splt[i]) < ord(splt[j])):\\n                    splt[j]=splt[i]\\n                else:\\n                    splt[i] = splt[j]\\n            i+=1\\n            j-=1\\n        string= \"\".join(splt)\\n        return string\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037534,
                "title": "very-easy-c-code",
                "content": "# Intuition\\nIf both the characters are same no need to change as it follows the condition of palindrome and if we encounter 2 different characters, than we can say that we will change the other character to the character which is smallest of both of them as we have to make lexicographically smallest palindrome\\n\\n# Approach\\n2 pointer approach\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1): constant time complexity as we have not used extra space.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n      int start=0,end=s.length()-1;\\n      while(start<=end){\\n        if(s[start]!=s[end]){\\n          char temp=min(s[start],s[end]);\\n          s[start]=temp;\\n          s[end]=temp;\\n        }\\n        start++;\\n        end--;\\n      }\\n      return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n      int start=0,end=s.length()-1;\\n      while(start<=end){\\n        if(s[start]!=s[end]){\\n          char temp=min(s[start],s[end]);\\n          s[start]=temp;\\n          s[end]=temp;\\n        }\\n        start++;\\n        end--;\\n      }\\n      return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027652,
                "title": "php-simple",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param String $s\\n     * @return String\\n     */\\n    function makeSmallestPalindrome($s) {\\n        $i = 0;\\n        $j = strlen($s) - 1;\\n\\n        while($i < $j) {\\n            $left = $s[$i];\\n            $right = $s[$j];\\n\\n            if ($left !== $right) {\\n                if ($left < $right) {\\n                    $s[$j] = $left;\\n                } else {\\n                    $s[$i] = $right;\\n                }\\n            }\\n\\n            $i++;\\n            $j--;\\n        }\\n   \\n        return $s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param String $s\\n     * @return String\\n     */\\n    function makeSmallestPalindrome($s) {\\n        $i = 0;\\n        $j = strlen($s) - 1;\\n\\n        while($i < $j) {\\n            $left = $s[$i];\\n            $right = $s[$j];\\n\\n            if ($left !== $right) {\\n                if ($left < $right) {\\n                    $s[$j] = $left;\\n                } else {\\n                    $s[$i] = $right;\\n                }\\n            }\\n\\n            $i++;\\n            $j--;\\n        }\\n   \\n        return $s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4025826,
                "title": "easy-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        string ans;\\n        int n = s.size();\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]!=s[n-1-i]){\\n                ans+=(s[i]<s[n-1-i]?s[i]:s[n-1-i]);\\n            }else{\\n                ans+=s[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        string ans;\\n        int n = s.size();\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]!=s[n-1-i]){\\n                ans+=(s[i]<s[n-1-i]?s[i]:s[n-1-i]);\\n            }else{\\n                ans+=s[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019115,
                "title": "easy-solution-for-beginners-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        \\tStringBuilder input = new StringBuilder();\\n        StringBuilder result = new StringBuilder();\\n        for(char c:s.toCharArray()) {\\n        \\tinput.append(c);\\n        }\\n        StringBuilder reversedInput = input.reverse();\\n        for(int i=0 ; i<s.length() ; i++ ) {\\n        \\tif(s.charAt(i) == reversedInput.charAt(i)) {\\n        \\t\\tresult.append(s.charAt(i));\\n        \\t\\t//System.out.println(result.toString());\\n        \\t}\\n        \\telse {\\n        \\t\\tif(s.charAt(i)>reversedInput.charAt(i)) {\\n        \\t\\t\\tresult.append(reversedInput.charAt(i));\\n        \\t\\t}\\n        \\t\\telse {\\n        \\t\\t\\tresult.append(s.charAt(i));\\n        \\t\\t}\\n        \\t}\\n        }\\n        return result.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        \\tStringBuilder input = new StringBuilder();\\n        StringBuilder result = new StringBuilder();\\n        for(char c:s.toCharArray()) {\\n        \\tinput.append(c);\\n        }\\n        StringBuilder reversedInput = input.reverse();\\n        for(int i=0 ; i<s.length() ; i++ ) {\\n        \\tif(s.charAt(i) == reversedInput.charAt(i)) {\\n        \\t\\tresult.append(s.charAt(i));\\n        \\t\\t//System.out.println(result.toString());\\n        \\t}\\n        \\telse {\\n        \\t\\tif(s.charAt(i)>reversedInput.charAt(i)) {\\n        \\t\\t\\tresult.append(reversedInput.charAt(i));\\n        \\t\\t}\\n        \\t\\telse {\\n        \\t\\t\\tresult.append(s.charAt(i));\\n        \\t\\t}\\n        \\t}\\n        }\\n        return result.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018258,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        l,r = 0 ,len(s) - 1\\n\\n        s = list(s)\\n\\n        while l <= r:\\n            if s[l] != s[r]:\\n                if s[l] < s[r]:\\n                    s[r] = s[l]\\n                else:\\n                    s[l] = s[r]\\n\\n            l += 1\\n            r -= 1\\n        \\n        s = \"\".join(s)\\n        return s\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        l,r = 0 ,len(s) - 1\\n\\n        s = list(s)\\n\\n        while l <= r:\\n            if s[l] != s[r]:\\n                if s[l] < s[r]:\\n                    s[r] = s[l]\\n                else:\\n                    s[l] = s[r]\\n\\n            l += 1\\n            r -= 1\\n        \\n        s = \"\".join(s)\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010089,
                "title": "simplest-java-solution-using-two-pointer-concept",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) \\n    {\\n        char ch[]=s.toCharArray();\\n        int i=0,j=s.length()-1;\\n        while(i<j)\\n        {\\n            if(ch[i]!=ch[j])\\n            {\\n                if(ch[i]<ch[j])\\n                {\\n                    ch[j]=ch[i];\\n                }\\n                else\\n                {\\n                    ch[i]=ch[j];\\n                }\\n            }\\n            i++;\\n            j--;\\n        }\\n        return String.valueOf(ch);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) \\n    {\\n        char ch[]=s.toCharArray();\\n        int i=0,j=s.length()-1;\\n        while(i<j)\\n        {\\n            if(ch[i]!=ch[j])\\n            {\\n                if(ch[i]<ch[j])\\n                {\\n                    ch[j]=ch[i];\\n                }\\n                else\\n                {\\n                    ch[i]=ch[j];\\n                }\\n            }\\n            i++;\\n            j--;\\n        }\\n        return String.valueOf(ch);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009022,
                "title": "two-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        s = list(s)\\n        l,r = 0, len(s)-1\\n        while l<r:\\n            if s[l] == s[r]:\\n                l+=1\\n                r-=1\\n            else:\\n                s[l] = min(s[l] , s[r])\\n                s[r] = min(s[l] , s[r])\\n                r-=1\\n                l+=1\\n                \\n        return \\'\\'.join(s)\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        s = list(s)\\n        l,r = 0, len(s)-1\\n        while l<r:\\n            if s[l] == s[r]:\\n                l+=1\\n                r-=1\\n            else:\\n                s[l] = min(s[l] , s[r])\\n                s[r] = min(s[l] , s[r])\\n                r-=1\\n                l+=1\\n                \\n        return \\'\\'.join(s)\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988314,
                "title": "97ms-beats-99-19-16-34mb-beats-87-73",
                "content": "# Intuition\\nwe\\'re mirroring the string, changing 1 char at a time in order for it to be alphabetically smaller \\n\\n# Approach\\ncreating an entirely new string is much faster than splitting the current one into a list and then joining it back\\n\\nso we\\'re just going to loop through the first half of the string, adding the smaller char between the current one, and its opposite on the other side of the middle point\\n\\nWe will then return the new string we\\'ve created, the middle char if the string has an odd number of chars, followed by the string reversed\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        ns = \"\"\\n        for i in range(len(s) // 2):\\n\\n            # the right char is smaller, take it\\n            if s[i] >= s[-i - 1]:\\n                ns += s[-i - 1]\\n                continue\\n\\n            # the left char is smaller\\n            ns += s[i]\\n\\n        # odd number of chars, take the middle char into account\\n        if len(s) % 2:\\n            return ns + s[(len(s) // 2)] + ns[::-1]\\n        return ns + ns[::-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        ns = \"\"\\n        for i in range(len(s) // 2):\\n\\n            # the right char is smaller, take it\\n            if s[i] >= s[-i - 1]:\\n                ns += s[-i - 1]\\n                continue\\n\\n            # the left char is smaller\\n            ns += s[i]\\n\\n        # odd number of chars, take the middle char into account\\n        if len(s) % 2:\\n            return ns + s[(len(s) // 2)] + ns[::-1]\\n        return ns + ns[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985299,
                "title": "beats-100-faster-c-easy-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n\\n        int st=0,e=s.size()-1;\\n        while(st<e){\\n            if(s[st]==s[e]){\\n                st++,e--;\\n            }\\n            else{\\n                s[st]>s[e] ? s[st]=s[e] : s[e]=s[st];\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n\\n        int st=0,e=s.size()-1;\\n        while(st<e){\\n            if(s[st]==s[e]){\\n                st++,e--;\\n            }\\n            else{\\n                s[st]>s[e] ? s[st]=s[e] : s[e]=s[st];\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984774,
                "title": "solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        z=\\'abcdefghijklmnopqrstuvwxyz\\'\\n        y=\\'\\'\\n        a=[]\\n        b=[]\\n        c=[]\\n        d=len(s)//2\\n        if len(s)%2==0 :\\n            for i in range(0,d) :\\n                a.append(s[i])\\n            x=s[::-1]\\n            for i in range(0,d) :\\n                b.append(x[i])\\n            for i in range(0,d) :\\n                if z.index(a[i])<z.index(b[i]) :\\n                    b[i]=a[i]\\n                elif z.index(a[i])>z.index(b[i]) :\\n                    a[i]=b[i]\\n                elif z.index(a[i])==z.index(b[i]) :\\n                    pass\\n            b.reverse()\\n            for i in a :\\n                y+=i\\n            for i in b :\\n                y+=i\\n\\n        else :\\n            x=s[::-1]\\n            for i in range(0,d) :\\n                a.append(s[i])\\n            for i in range(0,d) :\\n                b.append(x[i])\\n            c.append(s[d])\\n            for i in range(0,d) :\\n                if z.index(a[i])<z.index(b[i]) :\\n                    b[i]=a[i]\\n                elif z.index(a[i])>z.index(b[i]) :\\n                    a[i]=b[i]\\n                elif z.index(a[i])==z.index(b[i]) :\\n                    pass\\n            b.reverse()\\n            for i in a :\\n                y+=i\\n            for i in c :\\n                y+=i\\n            for i in b :\\n                y+=i\\n        return y\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        z=\\'abcdefghijklmnopqrstuvwxyz\\'\\n        y=\\'\\'\\n        a=[]\\n        b=[]\\n        c=[]\\n        d=len(s)//2\\n        if len(s)%2==0 :\\n            for i in range(0,d) :\\n                a.append(s[i])\\n            x=s[::-1]\\n            for i in range(0,d) :\\n                b.append(x[i])\\n            for i in range(0,d) :\\n                if z.index(a[i])<z.index(b[i]) :\\n                    b[i]=a[i]\\n                elif z.index(a[i])>z.index(b[i]) :\\n                    a[i]=b[i]\\n                elif z.index(a[i])==z.index(b[i]) :\\n                    pass\\n            b.reverse()\\n            for i in a :\\n                y+=i\\n            for i in b :\\n                y+=i\\n\\n        else :\\n            x=s[::-1]\\n            for i in range(0,d) :\\n                a.append(s[i])\\n            for i in range(0,d) :\\n                b.append(x[i])\\n            c.append(s[d])\\n            for i in range(0,d) :\\n                if z.index(a[i])<z.index(b[i]) :\\n                    b[i]=a[i]\\n                elif z.index(a[i])>z.index(b[i]) :\\n                    a[i]=b[i]\\n                elif z.index(a[i])==z.index(b[i]) :\\n                    pass\\n            b.reverse()\\n            for i in a :\\n                y+=i\\n            for i in c :\\n                y+=i\\n            for i in b :\\n                y+=i\\n        return y\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984186,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        string str;\\n\\n        while(i<j)\\n        {\\n            if(s[i]==s[j])\\n            {\\n                i++;\\n                j--;\\n            }\\n            else \\n            {\\n                if(s[i]>s[j])\\n                {\\n                    s[i]=s[j];\\n                }\\n                else\\n                {\\n                   s[j]=s[i];\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        string str;\\n\\n        while(i<j)\\n        {\\n            if(s[i]==s[j])\\n            {\\n                i++;\\n                j--;\\n            }\\n            else \\n            {\\n                if(s[i]>s[j])\\n                {\\n                    s[i]=s[j];\\n                }\\n                else\\n                {\\n                   s[j]=s[i];\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983168,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        i = 0\\n        j = len(s) - 1\\n        while i < j:\\n            if s[i] != s[j]:\\n                 if s[i] < s[j]:                   \\n                    s = s[:j] + s[i] + s[j+1:]    \\n                 else:\\n                     s = s[:i] + s[j] + s[i+1:]        \\n            i+=1\\n            j-=1\\n                  \\n        return s\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        i = 0\\n        j = len(s) - 1\\n        while i < j:\\n            if s[i] != s[j]:\\n                 if s[i] < s[j]:                   \\n                    s = s[:j] + s[i] + s[j+1:]    \\n                 else:\\n                     s = s[:i] + s[j] + s[i+1:]        \\n            i+=1\\n            j-=1\\n                  \\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982852,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        int i=0,j=s.length()-1;\\n        while(i<j){\\n            if(s.charAt(i)!=s.charAt(j)){\\n                if(s.charAt(i)<s.charAt(j)){\\n                    s=s.substring(0,j)+s.charAt(i)+s.substring(j+1,s.length());\\n                }\\n                else{\\n                    s=s.substring(0,i)+s.charAt(j)+s.substring(i+1,s.length());\\n                }\\n            }\\n            i++;\\n            j--;\\n        }\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        int i=0,j=s.length()-1;\\n        while(i<j){\\n            if(s.charAt(i)!=s.charAt(j)){\\n                if(s.charAt(i)<s.charAt(j)){\\n                    s=s.substring(0,j)+s.charAt(i)+s.substring(j+1,s.length());\\n                }\\n                else{\\n                    s=s.substring(0,i)+s.charAt(j)+s.substring(i+1,s.length());\\n                }\\n            }\\n            i++;\\n            j--;\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974529,
                "title": "very-easy-approach-in-java-that-anyone-can-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        int l=s.length()-1;\\n         StringBuilder f=new StringBuilder(\"\");\\n        for(int i=0;i<l;i++){\\n            if(s.charAt(i)<s.charAt(l)){\\n                f.append(s.charAt(i));\\n                l--;\\n            }\\n            else{\\n                f.append(s.charAt(l));\\n                l--;\\n            }\\n        }\\n        String a=f.toString();\\n        if((s.length())%2==0)\\n        a=a+f.reverse();\\n        else\\n        a=a+(s.charAt((((s.length())/2))))+f.reverse();\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        int l=s.length()-1;\\n         StringBuilder f=new StringBuilder(\"\");\\n        for(int i=0;i<l;i++){\\n            if(s.charAt(i)<s.charAt(l)){\\n                f.append(s.charAt(i));\\n                l--;\\n            }\\n            else{\\n                f.append(s.charAt(l));\\n                l--;\\n            }\\n        }\\n        String a=f.toString();\\n        if((s.length())%2==0)\\n        a=a+f.reverse();\\n        else\\n        a=a+(s.charAt((((s.length())/2))))+f.reverse();\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973982,
                "title": "python-simple-solution-using-single-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$ \\n\\n# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        l = list(s)\\n        for i in range(len(s)//2):\\n            if s[i] != s[-(i+1)]:\\n                if s[i] < s[-(i+1)]:\\n                   l[-(i+1)] = l[i]\\n                else:\\n                    l[i] = l[-(i+1)]\\n\\n        return \"\".join(l)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        l = list(s)\\n        for i in range(len(s)//2):\\n            if s[i] != s[-(i+1)]:\\n                if s[i] < s[-(i+1)]:\\n                   l[-(i+1)] = l[i]\\n                else:\\n                    l[i] = l[-(i+1)]\\n\\n        return \"\".join(l)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973076,
                "title": "smallest-palindrome-simple-java-solution",
                "content": "\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        int n=s.length();\\n        String p=\"\";\\n        int d=n/2; \\n        System.out.println(d+\" \"+n);\\n        for(int i=0;i<d;i++){\\n            if(s.charAt(i)>s.charAt(n-1-i)){\\n               p+=s.charAt(n-1-i);\\n            }\\n            else{\\n                p+=s.charAt(i);\\n            }\\n        }\\n        StringBuilder str= new StringBuilder(p);\\n        StringBuilder rStr = str.reverse();\\n        String out=(n%2==0)?(p+rStr):(p+s.charAt(d)+rStr);\\n        return out;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        int n=s.length();\\n        String p=\"\";\\n        int d=n/2; \\n        System.out.println(d+\" \"+n);\\n        for(int i=0;i<d;i++){\\n            if(s.charAt(i)>s.charAt(n-1-i)){\\n               p+=s.charAt(n-1-i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3967915,
                "title": "easy-to-read-python-solution-with-explanation-in-comments",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        #use two pinter\\n\\n        # comparer the char at the left and right index\\n        # if they are different, replace both chars with the \\n        # smaller of the character\\n\\n        #NOTE You cannot replace chars in a strings\\n        #so need to put the chatacters in a \\n\\n        #putting the chars from the string into an array\\n\\n        sArr = []\\n\\n        for char in s:\\n            sArr.append(char)\\n\\n        lp = 0 #left pointer\\n        rp = len(s) - 1 #right pointer\\n        #changes = 0\\n\\n\\n        while lp <= rp: #can also be lp < rp\\n            if sArr[lp] != sArr[rp]:\\n                #changes += 1\\n                #if the characters are different\\n                # replace both chars with the smaller character\\n                if sArr[lp] < sArr[rp]:\\n                    sArr[rp] = sArr[lp]\\n                else:\\n                    sArr[lp] = sArr[rp]\\n            \\n            #move both lp and rp\\n            lp += 1\\n            rp -= 1\\n        \\n        #combining the array back into a string\\n        return \\'\\'.join(sArr)\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        #use two pinter\\n\\n        # comparer the char at the left and right index\\n        # if they are different, replace both chars with the \\n        # smaller of the character\\n\\n        #NOTE You cannot replace chars in a strings\\n        #so need to put the chatacters in a \\n\\n        #putting the chars from the string into an array\\n\\n        sArr = []\\n\\n        for char in s:\\n            sArr.append(char)\\n\\n        lp = 0 #left pointer\\n        rp = len(s) - 1 #right pointer\\n        #changes = 0\\n\\n\\n        while lp <= rp: #can also be lp < rp\\n            if sArr[lp] != sArr[rp]:\\n                #changes += 1\\n                #if the characters are different\\n                # replace both chars with the smaller character\\n                if sArr[lp] < sArr[rp]:\\n                    sArr[rp] = sArr[lp]\\n                else:\\n                    sArr[lp] = sArr[rp]\\n            \\n            #move both lp and rp\\n            lp += 1\\n            rp -= 1\\n        \\n        #combining the array back into a string\\n        return \\'\\'.join(sArr)\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966613,
                "title": "simple-2-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        lo = 0\\n        hi = len(s) - 1\\n        s = list(s)\\n        while lo <= hi:\\n            s[hi] = s[lo] = min(s[hi], s[lo])\\n            lo += 1\\n            hi -= 1\\n        return \\'\\'.join(s)\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        lo = 0\\n        hi = len(s) - 1\\n        s = list(s)\\n        while lo <= hi:\\n            s[hi] = s[lo] = min(s[hi], s[lo])\\n            lo += 1\\n            hi -= 1\\n        return \\'\\'.join(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957327,
                "title": "simple-js-solution",
                "content": "```\\nvar makeSmallestPalindrome = function (s) {\\n  const palindromeArr = [...s].map((letter, letterIndex) => {\\n    const mirrorIndex = s.length - 1 - letterIndex;\\n    const mirrorLetter = s[mirrorIndex];\\n\\n    const smallerLetter = letter < mirrorLetter ? letter : mirrorLetter;\\n\\n    return smallerLetter;\\n  });\\n\\n  return palindromeArr.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar makeSmallestPalindrome = function (s) {\\n  const palindromeArr = [...s].map((letter, letterIndex) => {\\n    const mirrorIndex = s.length - 1 - letterIndex;\\n    const mirrorLetter = s[mirrorIndex];\\n\\n    const smallerLetter = letter < mirrorLetter ? letter : mirrorLetter;\\n\\n    return smallerLetter;\\n  });\\n\\n  return palindromeArr.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3953897,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt seems to me that this is a fairly good and understandable solution to this problem\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity: \\nBeats **98.78%**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nBeats **61.23%**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        t = list(s)\\n        for i in range(len(s)//2):\\n            if t[i] < t[-i-1]:\\n                t[-i-1] = t[i]\\n            else:\\n                t[i] = t[-i-1]   \\n        return \\'\\'.join(t)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        t = list(s)\\n        for i in range(len(s)//2):\\n            if t[i] < t[-i-1]:\\n                t[-i-1] = t[i]\\n            else:\\n                t[i] = t[-i-1]   \\n        return \\'\\'.join(t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953033,
                "title": "elixir-simple-solution",
                "content": "```\\ndefmodule Solution do\\n  @spec make_smallest_palindrome(s :: String.t()) :: String.t()\\n  def make_smallest_palindrome(s) do\\n    s = String.graphemes(s)\\n    t = Enum.reverse(s)\\n\\n    Enum.zip(s, t)\\n    |> Enum.map(fn {a, b} -> min(a, b) end)\\n    |> Enum.join()\\n  end\\nend\\n\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec make_smallest_palindrome(s :: String.t()) :: String.t()\\n  def make_smallest_palindrome(s) do\\n    s = String.graphemes(s)\\n    t = Enum.reverse(s)\\n\\n    Enum.zip(s, t)\\n    |> Enum.map(fn {a, b} -> min(a, b) end)\\n    |> Enum.join()\\n  end\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3951792,
                "title": "2-pointer-approach",
                "content": "# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        lst = list(s)\\n        left, right = 0, len(s)-1\\n        while left < right:\\n            if not s[left] == s[right]:\\n                if ord(s[left]) < ord(s[right]):\\n                    lst[right] = lst[left]\\n                else:\\n                    lst[left] = lst[right]\\n            left += 1\\n            right -= 1\\n        return \"\".join(lst)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        lst = list(s)\\n        left, right = 0, len(s)-1\\n        while left < right:\\n            if not s[left] == s[right]:\\n                if ord(s[left]) < ord(s[right]):\\n                    lst[right] = lst[left]\\n                else:\\n                    lst[left] = lst[right]\\n            left += 1\\n            right -= 1\\n        return \"\".join(lst)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950386,
                "title": "python-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def makeSmallestPalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        s = list(s)\\n        for i in range(len(s)//2):\\n            if s[i] != s[len(s)-1-i]:\\n                new = min(s[i], s[len(s)-1-i])\\n                s[i], s[len(s)-1-i] = new, new\\n\\n        return \\'\\'.join(s)\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def makeSmallestPalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        s = list(s)\\n        for i in range(len(s)//2):\\n            if s[i] != s[len(s)-1-i]:\\n                new = min(s[i], s[len(s)-1-i])\\n                s[i], s[len(s)-1-i] = new, new\\n\\n        return \\'\\'.join(s)\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947950,
                "title": "simple-solution-using-python",
                "content": "# Intuitiont\\nFind the palindromic string using the given string with minimum arrangements of contents that too with preference to alphabetical order.\\n\\n# Approach \\nConvert the given string into an list.Iterate over the list till the middle of it and check for each iteration that if the current value with the corresponding last value is not equal or not if true then find the minimum of the current value and the corresponding last value.Again check if the minimum value is equla to the first value or not if true then change the last corresponding value with the minimum value else change the current value to the minimum value.Finally return the re-arranged list string.\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        x=[i for i in s]\\n        for i in range((len(x)//2)):\\n            if x[i] != x[len(x)-i-1]:\\n                a=min(x[i],x[len(x)-i-1])\\n                if x[i] == a:\\n                    x[len(x)-i-1] = a\\n                else:\\n                    x[i] = a\\n        return \\'\\'.join(x)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        x=[i for i in s]\\n        for i in range((len(x)//2)):\\n            if x[i] != x[len(x)-i-1]:\\n                a=min(x[i],x[len(x)-i-1])\\n                if x[i] == a:\\n                    x[len(x)-i-1] = a\\n                else:\\n                    x[i] = a\\n        return \\'\\'.join(x)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941462,
                "title": "easy-java-solution-two-pointers-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        int i=0;\\n        int j=s.length()-1;\\n        char[] ch = s.toCharArray();\\n        while(i <= j){\\n        if(ch[i] == ch[j]){\\n            i++;\\n            j--;\\n            } else {\\n                if(ch[i] > ch[j]){\\n                    ch[i] = ch[j];\\n                    i++;\\n                    j--;\\n                } else {\\n                    ch[j] = ch[i];\\n                    i++;\\n                    j--;\\n                }\\n            }\\n        }\\n            return new String(ch);\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        int i=0;\\n        int j=s.length()-1;\\n        char[] ch = s.toCharArray();\\n        while(i <= j){\\n        if(ch[i] == ch[j]){\\n            i++;\\n            j--;\\n            } else {\\n                if(ch[i] > ch[j]){\\n                    ch[i] = ch[j];\\n                    i++;\\n                    j--;\\n                } else {\\n                    ch[j] = ch[i];\\n                    i++;\\n                    j--;\\n                }\\n            }\\n        }\\n            return new String(ch);\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938939,
                "title": "135ms-and-51mb-memory",
                "content": "# Approach\\nI use 2 pointers, the first one start from the left, the second one start from the right.\\nThen I compare the value of these indexes\\nIf the value on the left is bigger than the value on the right, update its value with the value from the right\\nIf the value on the right is bigger than the value on the left, update its value with the value from the left\\nThen I increase the value of the left index, and also decrease the value of the right index to continue checking the value.\\nThe loop will end when left index is not less then the right index anymore.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar makeSmallestPalindrome = function(s) {\\n    let str = s.split(\\'\\')\\n    let left = 0\\n    let right = str.length - 1\\n    while (left < right) {\\n        if (str[left] > str[right]) {\\n            str[left] = str[right]\\n        }\\n        else if (s[right] > s[left]) {\\n            str[right] = str[left]\\n        }\\n        left++\\n        right--\\n    }\\n    return str.join(\\'\\')\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar makeSmallestPalindrome = function(s) {\\n    let str = s.split(\\'\\')\\n    let left = 0\\n    let right = str.length - 1\\n    while (left < right) {\\n        if (str[left] > str[right]) {\\n            str[left] = str[right]\\n        }\\n        else if (s[right] > s[left]) {\\n            str[right] = str[left]\\n        }\\n        left++\\n        right--\\n    }\\n    return str.join(\\'\\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3935858,
                "title": "java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        char[] tmp = s.toCharArray();\\n        int operationCount = 0;\\n\\n        for (int i = 0, j = tmp.length - 1; i < j; i++, j--) {\\n            if (tmp[i] != tmp[j]) {\\n                if (tmp[i] > tmp[j]) {\\n                    tmp[i] = tmp[j];\\n                } else {\\n                    tmp[j] = tmp[i];\\n                }\\n                \\n                operationCount++;\\n            }\\n        }\\n\\n        return new String(tmp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        char[] tmp = s.toCharArray();\\n        int operationCount = 0;\\n\\n        for (int i = 0, j = tmp.length - 1; i < j; i++, j--) {\\n            if (tmp[i] != tmp[j]) {\\n                if (tmp[i] > tmp[j]) {\\n                    tmp[i] = tmp[j];\\n                } else {\\n                    tmp[j] = tmp[i];\\n                }\\n                \\n                operationCount++;\\n            }\\n        }\\n\\n        return new String(tmp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3934512,
                "title": "c-in-33-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\niterate from the end to the midpoint and start to midpoint\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbrute force\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) for n elements in the string\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) for n elements in the string\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int n = s.size();\\n        int m = n/2; // midpoint\\n        int i=0, j=n-1;\\n        string res(n, \\'\\\\0\\'); // result\\n        int y = 0;\\n        if (n%2 == 1) {\\n            res[m] = s[m];\\n        }\\n\\n        while (i < m && j > m-1) {\\n            if (s[i] != s[j]) {\\n                if (s[j] >= s[i]) {\\n                    res[i] = s[i];\\n                    res[j] = s[i];\\n                } else {\\n                    res[i] = s[j];\\n                    res[j] = s[j];\\n                }\\n            } else{\\n                res[i] = s[i];\\n                res[j] = s[i];\\n            }\\n            i++;\\n            j--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int n = s.size();\\n        int m = n/2; // midpoint\\n        int i=0, j=n-1;\\n        string res(n, \\'\\\\0\\'); // result\\n        int y = 0;\\n        if (n%2 == 1) {\\n            res[m] = s[m];\\n        }\\n\\n        while (i < m && j > m-1) {\\n            if (s[i] != s[j]) {\\n                if (s[j] >= s[i]) {\\n                    res[i] = s[i];\\n                    res[j] = s[i];\\n                } else {\\n                    res[i] = s[j];\\n                    res[j] = s[j];\\n                }\\n            } else{\\n                res[i] = s[i];\\n                res[j] = s[i];\\n            }\\n            i++;\\n            j--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3932860,
                "title": "java-string",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        char [] ch = s.toCharArray();\\n        if(ch.length%2==0){  // If string length are even then iteration perfom i<j\\n            int i=0,j=ch.length-1;\\n            while(i<j){\\n                if(ch[i]>ch[j]){\\n                    ch[i]=ch[j];\\n                    i++;j--;\\n                }\\n                else{\\n                    ch[j]=ch[i];\\n                    i++;j--;\\n                }\\n            }\\n        }\\n        else {      // If string length are odd then iteration perfom i<=j\\n            int i=0,j=ch.length-1;\\n            while(i<=j){\\n                if(ch[i]>ch[j]){\\n                    ch[i]=ch[j];\\n                    i++;j--;\\n                }\\n                else{\\n                    ch[j]=ch[i];\\n                    i++;j--;\\n                }\\n            }\\n        }\\n        String str = new String(ch);\\n        return str;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        char [] ch = s.toCharArray();\\n        if(ch.length%2==0){  // If string length are even then iteration perfom i<j\\n            int i=0,j=ch.length-1;\\n            while(i<j){\\n                if(ch[i]>ch[j]){\\n                    ch[i]=ch[j];\\n                    i++;j--;\\n                }\\n                else{\\n                    ch[j]=ch[i];\\n                    i++;j--;\\n                }\\n            }\\n        }\\n        else {      // If string length are odd then iteration perfom i<=j\\n            int i=0,j=ch.length-1;\\n            while(i<=j){\\n                if(ch[i]>ch[j]){\\n                    ch[i]=ch[j];\\n                    i++;j--;\\n                }\\n                else{\\n                    ch[j]=ch[i];\\n                    i++;j--;\\n                }\\n            }\\n        }\\n        String str = new String(ch);\\n        return str;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931736,
                "title": "easy-solution-using-two-pointers-approach",
                "content": "\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        char[] arr = s.toCharArray();\\n        int n = arr.length;\\n        for(int i = 0; i < n/2; i++){\\n            if(arr[i] > arr[n - i - 1]){\\n                arr[i] = arr[n - i - 1];\\n            }else{\\n                arr[n - i - 1] = arr[i];\\n            }\\n        }\\n        return new String(arr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        char[] arr = s.toCharArray();\\n        int n = arr.length;\\n        for(int i = 0; i < n/2; i++){\\n            if(arr[i] > arr[n - i - 1]){\\n                arr[i] = arr[n - i - 1];\\n            }else{\\n                arr[n - i - 1] = arr[i];\\n            }\\n        }\\n        return new String(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928108,
                "title": "c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int l=0,r=s.size()-1;\\n\\n        while(l<r)\\n        {\\n            if(s[l]!=s[r])\\n            {\\n                if(s[l]+\\'0\\'>s[r]+\\'0\\')\\n                {\\n                    s[l]=s[r];\\n                }\\n                else\\n                s[r]=s[l];\\n            }\\n            l++;r--;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int l=0,r=s.size()-1;\\n\\n        while(l<r)\\n        {\\n            if(s[l]!=s[r])\\n            {\\n                if(s[l]+\\'0\\'>s[r]+\\'0\\')\\n                {\\n                    s[l]=s[r];\\n                }\\n                else\\n                s[r]=s[l];\\n            }\\n            l++;r--;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920935,
                "title": "easy-python-code-python-two-pointer",
                "content": "# Approach\\n1. Split the characters of the string and compare with right end character to the left end and go on convering the two pointers. \\n2. When you encounter a mismatch, replace the other character with the lexicologically lesser character.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\n\\n# Code\\n```\\nclass Solution(object):\\n    def makeSmallestPalindrome(self, s):\\n        i=0\\n        j=len(s)-1\\n        count=0\\n        word = list(s)\\n        while i <j:\\n            if word[i] != word[j]:\\n                if word[j] > word[i]:\\n                    word[j] = word[i]\\n                else:\\n                    word[i] = word[j]    \\n            i+=1    \\n            j-=1\\n        return \"\".join(word)    \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def makeSmallestPalindrome(self, s):\\n        i=0\\n        j=len(s)-1\\n        count=0\\n        word = list(s)\\n        while i <j:\\n            if word[i] != word[j]:\\n                if word[j] > word[i]:\\n                    word[j] = word[i]\\n                else:\\n                    word[i] = word[j]    \\n            i+=1    \\n            j-=1\\n        return \"\".join(word)    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3912323,
                "title": "java-2-pointer-solution-97",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        char[] chars = s.toCharArray();\\n        int left= 0, right = chars.length - 1;\\n\\n        while(left < right){\\n            if(chars[left] < chars[right])\\n              chars[right] = chars[left];\\n            else \\n              chars[left] = chars[right];\\n\\n            left ++;\\n            right --;\\n        }\\n\\n        return new String(chars);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        char[] chars = s.toCharArray();\\n        int left= 0, right = chars.length - 1;\\n\\n        while(left < right){\\n            if(chars[left] < chars[right])\\n              chars[right] = chars[left];\\n            else \\n              chars[left] = chars[right];\\n\\n            left ++;\\n            right --;\\n        }\\n\\n        return new String(chars);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909898,
                "title": "go-with-runes",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc makeSmallestPalindrome(s string) string {\\n    start := 0\\n    end := len(s) - 1\\n\\n    runes := []rune(s)\\n\\n    for start < end {\\n        if runes[start] != runes[end] {\\n            if runes[start] < runes[end] {\\n                runes[end] = runes[start]\\n            } else {\\n                runes[start] = runes[end]\\n            }\\n        }\\n        start++\\n        end--\\n    }\\n\\n    return string(runes)\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc makeSmallestPalindrome(s string) string {\\n    start := 0\\n    end := len(s) - 1\\n\\n    runes := []rune(s)\\n\\n    for start < end {\\n        if runes[start] != runes[end] {\\n            if runes[start] < runes[end] {\\n                runes[end] = runes[start]\\n            } else {\\n                runes[start] = runes[end]\\n            }\\n        }\\n        start++\\n        end--\\n    }\\n\\n    return string(runes)\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3907239,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int n = s.length() -1;\\n        for(int i=0;i<(s.length())/2;i++){\\n            if(s[i]!=s[n-i]){\\n                if(s[i]<s[n-i]){\\n                    s[n-i]=s[i];\\n                }\\n                else{\\n                    s[i]=s[n-i];\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int n = s.length() -1;\\n        for(int i=0;i<(s.length())/2;i++){\\n            if(s[i]!=s[n-i]){\\n                if(s[i]<s[n-i]){\\n                    s[n-i]=s[i];\\n                }\\n                else{\\n                    s[i]=s[n-i];\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897866,
                "title": "java-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        \\n        char[] arr = new char[s.length()]; \\n        int k = s.length() - 1;  \\n      \\n      int kp = s.length()/2; \\n      \\n      arr[kp] = s.charAt(kp);\\n\\n        for(int j = 0; j < s.length()/2; j++)\\n        {\\n            if(s.charAt(j) != s.charAt(k))\\n            {\\n                if(s.charAt(j) < s.charAt(k))\\n                {\\n                    arr[j] = s.charAt(j); \\n                    arr[k] = s.charAt(j);\\n                }\\n                else\\n                {\\n                    arr[j] = s.charAt(k); \\n                    arr[k] = s.charAt(k);\\n                } \\n            }  \\n           else\\n           {\\n              arr[j] = s.charAt(j); \\n              arr[k] = s.charAt(j);\\n           }\\n            --k;\\n        } \\n        String result = new String(arr); \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        \\n        char[] arr = new char[s.length()]; \\n        int k = s.length() - 1;  \\n      \\n      int kp = s.length()/2; \\n      \\n      arr[kp] = s.charAt(kp);\\n\\n        for(int j = 0; j < s.length()/2; j++)\\n        {\\n            if(s.charAt(j) != s.charAt(k))\\n            {\\n                if(s.charAt(j) < s.charAt(k))\\n                {\\n                    arr[j] = s.charAt(j); \\n                    arr[k] = s.charAt(j);\\n                }\\n                else\\n                {\\n                    arr[j] = s.charAt(k); \\n                    arr[k] = s.charAt(k);\\n                } \\n            }  \\n           else\\n           {\\n              arr[j] = s.charAt(j); \\n              arr[k] = s.charAt(j);\\n           }\\n            --k;\\n        } \\n        String result = new String(arr); \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3896621,
                "title": "java-intuition-explained-easy-solution",
                "content": "# Intuition\\nThe intuition for this is very easy.\\nYou just look at the right most and left most letters and see if they are same.\\nIf yes, do nothing and check the next elements from left and right.\\nIf no, check which letter is lexicographically small and replace the larger letter with smaller one.\\n\\nIn Java, Strings are immutable, that is, we cannot change the letters of a string at particular index.\\nHence we are using StringBuilder here which has a built in method called setCharAt(index,char)\\n\\n# Approach\\n1. This is a Two Pointer problem\\n2. We create two pointers start and end which are indexes where start = 0 and end = length of string minus 1\\n3. Create a StringBuilder object using input string\\n3. Run a while loop until start is less than end.\\n4. Check the letters are these indices.\\n5. If the letters are same, increment start and decrement end.\\n6. If they are different, replace lexicographically larger number with smaller one in the StringBuilder object.\\n7. Return the StringBuilder object after converting to String.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        int start = 0;\\n        int end = s.length()-1;\\n\\n        StringBuilder newStr = new StringBuilder(s);\\n        while(start<end){\\n            char startChar = s.charAt(start);\\n            char endChar =  s.charAt(end);\\n            if(startChar != endChar){\\n                if(startChar<endChar)\\n                    newStr.setCharAt(end,startChar);\\n                else if(endChar<startChar)\\n                    newStr.setCharAt(start,endChar);\\n            }\\n            start++;\\n            end--;\\n        }\\n        return newStr.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        int start = 0;\\n        int end = s.length()-1;\\n\\n        StringBuilder newStr = new StringBuilder(s);\\n        while(start<end){\\n            char startChar = s.charAt(start);\\n            char endChar =  s.charAt(end);\\n            if(startChar != endChar){\\n                if(startChar<endChar)\\n                    newStr.setCharAt(end,startChar);\\n                else if(endChar<startChar)\\n                    newStr.setCharAt(start,endChar);\\n            }\\n            start++;\\n            end--;\\n        }\\n        return newStr.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3895790,
                "title": "explained-with-two-pointers-method-very-easy-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given code aims to modify a given string to create the smallest possible palindrome. The approach involves iterating through the string from both ends (left and right) towards the center. At each step, if the characters at the current left and right positions are not the same, the code compares them. If the character on the left is smaller, it replaces the character on the right with the character on the left, and vice versa. The goal is to make the string a palindrome by minimizing its value while maintaining the palindrome property.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.Initialize two pointers, left and right, pointing to the first and last characters of the input string s.\\n2.Iterate while left is less than right.\\n3.If s[left] and s[right] are not equal, determine whether s[left] should be replaced with s[right] or vice versa to create the smallest possible palindrome.\\n4.Move left one step to the right and right one step to the left.\\n5.Repeat the process until left is no longer less than right.\\n6.Return the modified string.\\n# Complexity\\n- Time complexity: O(n / 2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe correct time complexity of the given code is actually O(n/2), which simplifies to O(n), where n is the length of the input string s.\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(1) because the algorithm modifies the input string in place and does not use any additional data structures that grow with the input size.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        \\n        int left = 0, right = s.length() - 1;\\n\\n        while(left < right){\\n\\n            if(s[left] != s[right]){\\n\\n                if(s[left] < s[right]){\\n                    s[right] = s[left];\\n                }else if(s[left] > s[right]) {\\n                    s[left] = s[right];\\n                }\\n            }\\n            ++left, --right;\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        \\n        int left = 0, right = s.length() - 1;\\n\\n        while(left < right){\\n\\n            if(s[left] != s[right]){\\n\\n                if(s[left] < s[right]){\\n                    s[right] = s[left];\\n                }else if(s[left] > s[right]) {\\n                    s[left] = s[right];\\n                }\\n            }\\n            ++left, --right;\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3882153,
                "title": "simple-and-easy-solution-two-pointer-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int st=0, last=s.length()-1;\\n        while(st<=last){\\n            if(s[st]==s[last]){\\n                st++;\\n                last--;\\n            }\\n            else{\\n                if(s[st]<s[last]){\\n                    s[last] = s[st];\\n                }else{\\n                    s[st] = s[last];\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int st=0, last=s.length()-1;\\n        while(st<=last){\\n            if(s[st]==s[last]){\\n                st++;\\n                last--;\\n            }\\n            else{\\n                if(s[st]<s[last]){\\n                    s[last] = s[st];\\n                }else{\\n                    s[st] = s[last];\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880983,
                "title": "beats-80-java-with-explanation-beginner-friendly-solution",
                "content": "# Intuition\\nThe goal is to modify the input string such that the resulting string is lexicographically smallest. To achieve this, we compare characters from both ends of the string and replace the larger character with the smaller one. This way, we ensure that we are making the string as small as possible while maintaining lexicographical order.\\n\\n# Approach\\n1. Initialize two pointers \\'i\\' at the beginning of the string and j at the end of the string.\\n2. Create a \\'StringBuilder\\' to manipulate the string.\\n3. Iterate while \\'i\\' is less than \\'j\\'.\\n4. If the characters at positions i and j are different:\\n        -> Store the characters at positions \\'i\\' and \\'j\\' in variables \\'c1\\' and \\'c2\\'.\\n        -> Compare \\'c1\\' and \\'c2\\'. If \\'c1\\' is lexicographically smaller, replace     character at position \\'j\\' with \\'c1\\', else replace character at position \\'i\\' with \\'c2\\'.\\n5. Move \\'i\\' to the right and \\'j\\' to the left.\\n6. Return the modified string using \\'toString()\\' on the \\'StringBuilder\\'.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        int i=0;\\n        int j=s.length()-1;\\n        StringBuilder sb = new StringBuilder(s);\\n        while(i<j){\\n            if(s.charAt(i)!=s.charAt(j)){\\n                int c1 = s.charAt(i);\\n                int c2 = s.charAt(j);\\n                if(c1<c2){\\n                    sb.setCharAt(j, s.charAt(i));\\n                }\\n                else{\\n                    sb.setCharAt(i, s.charAt(j));\\n                }\\n            }\\n            i++;\\n            j--;\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        int i=0;\\n        int j=s.length()-1;\\n        StringBuilder sb = new StringBuilder(s);\\n        while(i<j){\\n            if(s.charAt(i)!=s.charAt(j)){\\n                int c1 = s.charAt(i);\\n                int c2 = s.charAt(j);\\n                if(c1<c2){\\n                    sb.setCharAt(j, s.charAt(i));\\n                }\\n                else{\\n                    sb.setCharAt(i, s.charAt(j));\\n                }\\n            }\\n            i++;\\n            j--;\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880654,
                "title": "while-loop-with-two-pointers-vs-one-line-of-code-with-zip-function",
                "content": "## While loop with two pointers\\n![image.png](https://assets.leetcode.com/users/images/69bea62f-bb8b-4854-9d4c-567789c77797_1691480782.9002447.png)\\n\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        left = 0\\n        right = len(s) - 1\\n        while left < right:\\n            if s[left] != s[right]:\\n                ch = min(s[left], s[right])\\n                s = s[:left] + ch + s[left + 1:right] + ch + s[right + 1:]\\n            left += 1\\n            right -= 1\\n        return s\\n```\\n\\n## One line of code with zip() function\\n![image.png](https://assets.leetcode.com/users/images/b4f8a0ff-b93f-423f-b049-4f63b96a2bc4_1691480678.9646778.png)\\n\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        return \"\".join(min(a, b) for a, b in zip(s, s[::-1]))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        left = 0\\n        right = len(s) - 1\\n        while left < right:\\n            if s[left] != s[right]:\\n                ch = min(s[left], s[right])\\n                s = s[:left] + ch + s[left + 1:right] + ch + s[right + 1:]\\n            left += 1\\n            right -= 1\\n        return s\\n```\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        return \"\".join(min(a, b) for a, b in zip(s, s[::-1]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3878002,
                "title": "c-beginner-friendly-very-much-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int i=0,j=s.size()-1;\\n        int n=s.size();\\n        while(i<=j)\\n        {\\n            if(s[i]==s[j])\\n            {\\n                i++;\\n                j--;\\n            }\\n           else if(s[i]<s[j])\\n            {\\n                s[j]=s[i];\\n                i++;\\n                j--;\\n                \\n            }\\n            else if(s[i]>s[j])\\n            {\\n                s[i]=s[j];\\n                i++;\\n                j--;\\n                \\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int i=0,j=s.size()-1;\\n        int n=s.size();\\n        while(i<=j)\\n        {\\n            if(s[i]==s[j])\\n            {\\n                i++;\\n                j--;\\n            }\\n           else if(s[i]<s[j])\\n            {\\n                s[j]=s[i];\\n                i++;\\n                j--;\\n                \\n            }\\n            else if(s[i]>s[j])\\n            {\\n                s[i]=s[j];\\n                i++;\\n                j--;\\n                \\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874874,
                "title": "easy-c-2-pointer-approach-beginner-friendly",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int i = 0;\\n        int j = s.size() - 1;\\n        while (i <= j) {\\n            if (s[i] == s[j]) {\\n                i++;\\n                j--;\\n            } else {\\n                if (s[i] < s[j]) {\\n                    s[j] = s[i];\\n                } else {\\n                    s[i] = s[j];\\n                }\\n                i++;\\n                j--;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int i = 0;\\n        int j = s.size() - 1;\\n        while (i <= j) {\\n            if (s[i] == s[j]) {\\n                i++;\\n                j--;\\n            } else {\\n                if (s[i] < s[j]) {\\n                    s[j] = s[i];\\n                } else {\\n                    s[i] = s[j];\\n                }\\n                i++;\\n                j--;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874294,
                "title": "easy-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ntraverse the string from front and last and find the positin where the chars are not same, replace one of them with the samllest one among them, till we do not get meet from both sides.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nchar * makeSmallestPalindrome(char * s){\\nint i=0;\\nint j=strlen(s)-1;\\nwhile(i<j)\\n{\\n    if(s[i]==s[j])\\n    {\\n        i++;\\n        j--;\\n    }\\n    else\\n    {\\n        if((s[i])<(s[j]))\\n        {\\n            s[j]=s[i];\\n            i++;\\n            j--;\\n        }\\n        else\\n        {\\n            s[i]=s[j];\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\nreturn s;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar * makeSmallestPalindrome(char * s){\\nint i=0;\\nint j=strlen(s)-1;\\nwhile(i<j)\\n{\\n    if(s[i]==s[j])\\n    {\\n        i++;\\n        j--;\\n    }\\n    else\\n    {\\n        if((s[i])<(s[j]))\\n        {\\n            s[j]=s[i];\\n            i++;\\n            j--;\\n        }\\n        else\\n        {\\n            s[i]=s[j];\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\nreturn s;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3874233,
                "title": "super-duper-easy-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) \\n    {\\n        int i = 0;\\n        int j = s.size() - 1;\\n\\n        while (i < j) {\\n            if (s[i] != s[j]) {\\n                int temp = min(s[i], s[j]);\\n                s[i] = (char)temp;\\n                s[j] = (char)temp;\\n            }\\n            ++i;\\n            --j;\\n        }\\n\\n        return s;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) \\n    {\\n        int i = 0;\\n        int j = s.size() - 1;\\n\\n        while (i < j) {\\n            if (s[i] != s[j]) {\\n                int temp = min(s[i], s[j]);\\n                s[i] = (char)temp;\\n                s[j] = (char)temp;\\n            }\\n            ++i;\\n            --j;\\n        }\\n\\n        return s;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874232,
                "title": "super-duper-easy-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) \\n    {\\n        int i = 0;\\n        int j = s.size() - 1;\\n\\n        while (i < j) {\\n            if (s[i] != s[j]) {\\n                int temp = min(s[i], s[j]);\\n                s[i] = (char)temp;\\n                s[j] = (char)temp;\\n            }\\n            ++i;\\n            --j;\\n        }\\n\\n        return s;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) \\n    {\\n        int i = 0;\\n        int j = s.size() - 1;\\n\\n        while (i < j) {\\n            if (s[i] != s[j]) {\\n                int temp = min(s[i], s[j]);\\n                s[i] = (char)temp;\\n                s[j] = (char)temp;\\n            }\\n            ++i;\\n            --j;\\n        }\\n\\n        return s;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3869858,
                "title": "c-solution-2-pointers-technique",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    string makeSmallestPalindrome(string& s) \\n    {\\n        int left = s.length() / 2 - !(s.length() & 1);\\n        int right = s.length() - left - 1;\\n\\n        while (left >= 0 && right < s.length())\\n        {\\n            char common = std::min(s[left], s[right]);\\n            s[left] = s[right] = common;\\n\\n            left--;\\n            right++;\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    string makeSmallestPalindrome(string& s) \\n    {\\n        int left = s.length() / 2 - !(s.length() & 1);\\n        int right = s.length() - left - 1;\\n\\n        while (left >= 0 && right < s.length())\\n        {\\n            char common = std::min(s[left], s[right]);\\n            s[left] = s[right] = common;\\n\\n            left--;\\n            right++;\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3869207,
                "title": "2-lines-in-python-faster-than-100",
                "content": "# Code\\n```python\\ndef makeSmallestPalindrome(self, s: str) -> str:\\n    ret = \\'\\'.join([min(x,y) for x, y in zip(s[:len(s)//2], reversed(s[-len(s)//2:]))])\\n    return ret + (s[len(s)//2] if len(s)%2 else \"\") + ret[::-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\ndef makeSmallestPalindrome(self, s: str) -> str:\\n    ret = \\'\\'.join([min(x,y) for x, y in zip(s[:len(s)//2], reversed(s[-len(s)//2:]))])\\n    return ret + (s[len(s)//2] if len(s)%2 else \"\") + ret[::-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3868145,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nString builder  , reverce , replace.\\n\\n# Complexity\\n- Time complexity:\\n<!-- 30ms -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Java\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n      StringBuilder s1 = new StringBuilder(s.substring(0, s.length() / 2));\\n        StringBuilder s2 = new StringBuilder(s.substring(s.length() / 2)).reverse();\\n        for (int i = 0; i < s1.length(); i++) {\\n            if (s1.charAt(i) != s2.charAt(i)){\\n                if (s1.charAt(i) > s2.charAt(i)){\\n                    s1.replace(i,i+1,String.valueOf(s2.charAt(i)));\\n                }else {\\n                    s2.replace(i,i+1,String.valueOf(s1.charAt(i)));\\n                }\\n            }\\n        }\\n        return s1+s2.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n      StringBuilder s1 = new StringBuilder(s.substring(0, s.length() / 2));\\n        StringBuilder s2 = new StringBuilder(s.substring(s.length() / 2)).reverse();\\n        for (int i = 0; i < s1.length(); i++) {\\n            if (s1.charAt(i) != s2.charAt(i)){\\n                if (s1.charAt(i) > s2.charAt(i)){\\n                    s1.replace(i,i+1,String.valueOf(s2.charAt(i)));\\n                }else {\\n                    s2.replace(i,i+1,String.valueOf(s1.charAt(i)));\\n                }\\n            }\\n        }\\n        return s1+s2.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856067,
                "title": "simple-solution-use-two-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTwo pointer solution\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n         for (int i = 0, j = s.size() - 1; i <= j; i++, j--) {\\n            if (s[i] < s[j]) {\\n                s[j] = s[i];\\n            }\\n            else if (s[i] > s[j]) {\\n                s[i] = s[j];\\n            }\\n        }\\n        return s;       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n         for (int i = 0, j = s.size() - 1; i <= j; i++, j--) {\\n            if (s[i] < s[j]) {\\n                s[j] = s[i];\\n            }\\n            else if (s[i] > s[j]) {\\n                s[i] = s[j];\\n            }\\n        }\\n        return s;       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854722,
                "title": "python-easy-to-understand-using-two-points-for-palindrome-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        l = 0\\n        r = len(s)-1\\n        s = list(s)\\n        while l < r:\\n            if s[l]!= s[r]:\\n                if s[l] < s[r]:\\n                    s[r] = s[l]\\n                else:\\n                    s[l] = s[r] \\n            l+=1\\n            r-=1\\n        return \\'\\'.join(s)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        l = 0\\n        r = len(s)-1\\n        s = list(s)\\n        while l < r:\\n            if s[l]!= s[r]:\\n                if s[l] < s[r]:\\n                    s[r] = s[l]\\n                else:\\n                    s[l] = s[r] \\n            l+=1\\n            r-=1\\n        return \\'\\'.join(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3851073,
                "title": "using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        int i=0;\\n        int j = s.length()-1;\\n        StringBuilder sb = new StringBuilder(s);\\n\\n        while(i<j){\\n                if(sb.charAt(i)<sb.charAt(j)){\\n                    sb.setCharAt(j,sb.charAt(i));\\n                }\\n                else if((sb.charAt(i)>sb.charAt(j))){\\n                    sb.setCharAt(i,sb.charAt(j));\\n                }\\n                i++;\\n                j--;\\n        }\\n        return sb.toString();\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        int i=0;\\n        int j = s.length()-1;\\n        StringBuilder sb = new StringBuilder(s);\\n\\n        while(i<j){\\n                if(sb.charAt(i)<sb.charAt(j)){\\n                    sb.setCharAt(j,sb.charAt(i));\\n                }\\n                else if((sb.charAt(i)>sb.charAt(j))){\\n                    sb.setCharAt(i,sb.charAt(j));\\n                }\\n                i++;\\n                j--;\\n        }\\n        return sb.toString();\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849422,
                "title": "very-simple-solution-just-using-looping-see-my-code-and-get-understand-upvote-please",
                "content": "- ## ****Bold**# Intuition**\\n\\n---\\n\\n- <!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n\\n\\n       char a[]=s.toCharArray();\\n\\n int i=0,j=a.length;\\n\\n while(i<j)\\n {\\n\\n    if(a[i]<a[j-1])\\n    a[j-1]=a[i];\\n    else\\n    a[i]=a[j-1];\\n    \\ni++;\\nj--;\\n }\\n    return new String(a); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n\\n\\n       char a[]=s.toCharArray();\\n\\n int i=0,j=a.length;\\n\\n while(i<j)\\n {\\n\\n    if(a[i]<a[j-1])\\n    a[j-1]=a[i];\\n    else\\n    a[i]=a[j-1];\\n    \\ni++;\\nj--;\\n }\\n    return new String(a); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848138,
                "title": "easy-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        char str[] = s.toCharArray();\\n        int i=0, j=s.length()-1;\\n        while(i<j){\\n            str[i] = (char)Math.min(str[i],str[j]);\\n            str[j]= str[i];\\n            i++;\\n            j--;\\n        }\\n        return new String(str);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        char str[] = s.toCharArray();\\n        int i=0, j=s.length()-1;\\n        while(i<j){\\n            str[i] = (char)Math.min(str[i],str[j]);\\n            str[j]= str[i];\\n            i++;\\n            j--;\\n        }\\n        return new String(str);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843312,
                "title": "beats-99-06-python-easy-sol",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        s=[*s]\\n        r=s[::-1]\\n        for i in range(len(s)):\\n            if s[i]>r[i]:\\n                s[i]=r[i]\\n        return \\'\\'.join(s)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        s=[*s]\\n        r=s[::-1]\\n        for i in range(len(s)):\\n            if s[i]>r[i]:\\n                s[i]=r[i]\\n        return \\'\\'.join(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840083,
                "title": "two-pointer-approach-very-easy-basic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. first we have to think about that we have to make that string palindrome.\\n2. second whenever we think about palindrome we check with two pointer\\n3. when we are matching those two pointer and if they are not same and ascii value of first one is greater than second one then in this condition we replace first one with second one and vice versa\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntwo pointer approach\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        li=list(s)\\n        i=0\\n        j=len(li)-1\\n        while i<j:\\n            if li[i]!=li[j] and ord(li[i])>ord(li[j]):\\n                li[i]=li[j]\\n            else:\\n                li[j]=li[i]\\n            i+=1\\n            j-=1\\n        return \"\".join(li)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        li=list(s)\\n        i=0\\n        j=len(li)-1\\n        while i<j:\\n            if li[i]!=li[j] and ord(li[i])>ord(li[j]):\\n                li[i]=li[j]\\n            else:\\n                li[j]=li[i]\\n            i+=1\\n            j-=1\\n        return \"\".join(li)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839616,
                "title": "java-solution-beats-100-time-and-space-o-n",
                "content": "\\n# Approach\\n- Initialize n as the index of the last character in the string s.\\n- Initialize l as 0, representing the index of the first character in the string s.\\n- Convert the input string s into a character array charArray.\\n- Use a while loop to iterate over the characters from the beginning (l) and end (n) of the string towards the middle.\\n- For each pair of characters at indices l and n, check if they are not equal.\\n- If they are not equal, select the smaller of the two characters and assign it to both charArray[l] and charArray[n] to make them equal.\\n- Increment l and decrement n to move towards the middle of the string.\\n- Repeat steps 5 to 7 until l is less than or equal to n.\\n    \\nFinally, after all the iterations, the function returns the modified charArray as a new string representing the smallest palindrome.\\n# Complexity\\n- Time complexity : O(N)\\n\\n- Space complexity : O(N)\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/01548d59-e849-4ac9-8e56-72630d68005e_1690738879.945812.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n    int n = s.length()-1;\\n    int l=0;\\n    char[] charArray = s.toCharArray();\\n    while(l<n)\\n    {\\n        if(charArray[l] != charArray[n]){\\n            char c = (char) Math.min(charArray[l],charArray[n]);\\n            charArray[l] = charArray[n]  = c;\\n        }\\n        l++;\\n        n--;\\n    }\\n    return new String(charArray);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n    int n = s.length()-1;\\n    int l=0;\\n    char[] charArray = s.toCharArray();\\n    while(l<n)\\n    {\\n        if(charArray[l] != charArray[n]){\\n            char c = (char) Math.min(charArray[l],charArray[n]);\\n            charArray[l] = charArray[n]  = c;\\n        }\\n        l++;\\n        n--;\\n    }\\n    return new String(charArray);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838619,
                "title": "java-two-pointer-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        int n = s.length();\\n        char[] chrArr = s.toCharArray();\\n        int start = 0;\\n        int end = n - 1;\\n\\n        while(end > start){\\n\\n            if(chrArr[start] != chrArr[end]) {\\n                if(chrArr[start] < chrArr[end]) chrArr[end] = chrArr[start];\\n                else chrArr[start] = chrArr[end];\\n            }\\n            start++;\\n            end--;\\n        }\\n        return String.valueOf(chrArr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        int n = s.length();\\n        char[] chrArr = s.toCharArray();\\n        int start = 0;\\n        int end = n - 1;\\n\\n        while(end > start){\\n\\n            if(chrArr[start] != chrArr[end]) {\\n                if(chrArr[start] < chrArr[end]) chrArr[end] = chrArr[start];\\n                else chrArr[start] = chrArr[end];\\n            }\\n            start++;\\n            end--;\\n        }\\n        return String.valueOf(chrArr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830445,
                "title": "simple-c-solution-extremely-beginner-friendly-beats-82-79",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCheck if start and end are not equal, then change it to minimum of both of them.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterate till half of the array(excluding the n/2 th element), check if those aren\\'t equal. If not, then if `ith` is greater than `(n-1-i)th` then change `ith` to minimum of `ith` and `(n-1-i)th` else change the last one with minimum of those.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int n=s.length();\\n        for(int i=0; i<n/2; i++){\\n            if(s[i]!=s[n-1-i]){\\n                if(s[i]>s[n-i-1]){\\n                    s[i]=min(s[i], s[n-1-i]);\\n                }else s[n-1-i]=min(s[i],s[n-1-i]);\\n            }\\n        }return s; \\n    }\\n};\\n```\\n`\\nif(like) upvote++ ;p\\n`",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int n=s.length();\\n        for(int i=0; i<n/2; i++){\\n            if(s[i]!=s[n-1-i]){\\n                if(s[i]>s[n-i-1]){\\n                    s[i]=min(s[i], s[n-1-i]);\\n                }else s[n-1-i]=min(s[i],s[n-1-i]);\\n            }\\n        }return s; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823684,
                "title": "simple-and-easy-java-stringbuilder-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        int n = s.length();\\n        StringBuilder sb = new StringBuilder(s);\\n        int i=0,j=n-1;\\n        while(i<j){\\n            if(s.charAt(i)!=s.charAt(j)){\\n                if(s.charAt(j)<s.charAt(i)){\\n                    sb.setCharAt(i,s.charAt(j));\\n                    // s= s.substring(0,i-1) + s.charAt(j)+ s.substring(i+1,n);\\n                }\\n                else{\\n                    sb.setCharAt(j,s.charAt(i));\\n                    //  s= s.substring(0,j-1) + s.charAt(i)+ s.substring(j+1,n);\\n                }\\n            }\\n\\n            i++;\\n            j--;\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        int n = s.length();\\n        StringBuilder sb = new StringBuilder(s);\\n        int i=0,j=n-1;\\n        while(i<j){\\n            if(s.charAt(i)!=s.charAt(j)){\\n                if(s.charAt(j)<s.charAt(i)){\\n                    sb.setCharAt(i,s.charAt(j));\\n                    // s= s.substring(0,i-1) + s.charAt(j)+ s.substring(i+1,n);\\n                }\\n                else{\\n                    sb.setCharAt(j,s.charAt(i));\\n                    //  s= s.substring(0,j-1) + s.charAt(i)+ s.substring(j+1,n);\\n                }\\n            }\\n\\n            i++;\\n            j--;\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818034,
                "title": "lexicographically-smallest-palindrome",
                "content": "class Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        l=0\\n        r=len(s)-1\\n        s=list(s)\\n        while l<r:\\n            if s[l]!=s[r]:\\n                if ord(s[l])<ord(s[r]):\\n                    s[r]=s[r].replace(s[r],s[l])\\n                else:\\n                    s[l]=s[l].replace(s[l],s[r])\\n            l+=1\\n            r-=1\\n        return \"\".join(s)",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "class Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        l=0\\n        r=len(s)-1\\n        s=list(s)\\n        while l<r:\\n            if s[l]!=s[r]:\\n                if ord(s[l])<ord(s[r]):\\n                    s[r]=s[r].replace(s[r],s[l])\\n                else:\\n                    s[l]=s[l].replace(s[l],s[r])\\n            l+=1\\n            r-=1\\n        return \"\".join(s)",
                "codeTag": "Java"
            },
            {
                "id": 3814601,
                "title": "java-solution-for-beignners-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTwo Pointer,Comparison,One ARRAY to store ans.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nstart comparingfrom opposite ends;\\nif they are equal thn store them in array;\\nif they are different thn check which is smaller and add it to the arr at both position.\\ncovert the array to string.\\nhave a break u solved one question today champion!\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        int i = 0;\\n        int j = s.length() - 1;\\n        Character[] arr = new Character[j + 1];\\n\\n        while (i <= j) {\\n            char si = s.charAt(i);\\n            char ej = s.charAt(j);\\n\\n            if (si != ej) {\\n                // To make the palindrome smallest, we need to replace the larger character\\n                // with the smaller one, so the difference in their ASCII values should be minimized.\\n                if (si > ej) {\\n                    arr[i] = s.charAt(j);\\n                    arr[j] = s.charAt(j);\\n                } else {\\n                    arr[i] = s.charAt(i);\\n                    arr[j] = s.charAt(i);\\n                }\\n            } else {\\n                arr[i] = s.charAt(i);\\n                arr[j] = s.charAt(j);\\n            }\\n            i++;\\n            j--;\\n        }\\n\\n        // Convert the Character array to a String\\n        StringBuilder result = new StringBuilder();\\n        for (char c : arr) {\\n                result.append(c);\\n            }\\n        return result.toString();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        int i = 0;\\n        int j = s.length() - 1;\\n        Character[] arr = new Character[j + 1];\\n\\n        while (i <= j) {\\n            char si = s.charAt(i);\\n            char ej = s.charAt(j);\\n\\n            if (si != ej) {\\n                // To make the palindrome smallest, we need to replace the larger character\\n                // with the smaller one, so the difference in their ASCII values should be minimized.\\n                if (si > ej) {\\n                    arr[i] = s.charAt(j);\\n                    arr[j] = s.charAt(j);\\n                } else {\\n                    arr[i] = s.charAt(i);\\n                    arr[j] = s.charAt(i);\\n                }\\n            } else {\\n                arr[i] = s.charAt(i);\\n                arr[j] = s.charAt(j);\\n            }\\n            i++;\\n            j--;\\n        }\\n\\n        // Convert the Character array to a String\\n        StringBuilder result = new StringBuilder();\\n        for (char c : arr) {\\n                result.append(c);\\n            }\\n        return result.toString();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810027,
                "title": "java-easy-solution-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n           char crr [] = s.toCharArray();\\n     int start = 0;\\n     int end = crr.length-1;\\n     while(start<end){\\n\\n         crr[start] = (char)Math.min(crr[start],crr[end]);\\n         crr[end] = crr[start];\\n         start++;\\n         end--;\\n\\n     } \\n\\n     return new String(crr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n           char crr [] = s.toCharArray();\\n     int start = 0;\\n     int end = crr.length-1;\\n     while(start<end){\\n\\n         crr[start] = (char)Math.min(crr[start],crr[end]);\\n         crr[end] = crr[start];\\n         start++;\\n         end--;\\n\\n     } \\n\\n     return new String(crr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807622,
                "title": "clean-python",
                "content": "# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        output = list(s)\\n        for x in range(len(s) // 2):\\n            left = output[x]\\n            right = output[-(x + 1)]\\n            if left != right:\\n                smaller = min(left, right)\\n                output[x] = smaller\\n                output[-(x + 1)] = smaller\\n        return \\'\\'.join(output)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        output = list(s)\\n        for x in range(len(s) // 2):\\n            left = output[x]\\n            right = output[-(x + 1)]\\n            if left != right:\\n                smaller = min(left, right)\\n                output[x] = smaller\\n                output[-(x + 1)] = smaller\\n        return \\'\\'.join(output)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807586,
                "title": "beat-91-of-solutions-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def makeSmallestPalindrome(self, s):\\n        s = list(s)\\n        i = 0\\n        j = len(s) - 1\\n        \\n        while i < j:\\n            if (s[i] != s[j]):\\n                if(s[i] > s[j]):\\n                    s[i] = s[j]\\n                else:\\n                    s[j] = s[i]\\n                    \\n            i = i + 1\\n            j = j - 1\\n            \\n        return(\\'\\'.join(s))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def makeSmallestPalindrome(self, s):\\n        s = list(s)\\n        i = 0\\n        j = len(s) - 1\\n        \\n        while i < j:\\n            if (s[i] != s[j]):\\n                if(s[i] > s[j]):\\n                    s[i] = s[j]\\n                else:\\n                    s[j] = s[i]\\n                    \\n            i = i + 1\\n            j = j - 1\\n            \\n        return(\\'\\'.join(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801863,
                "title": "with-explanation-comments-time-xx-ms-98-97-space-xx-mb-89-9",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n               \\n        for(int i=0, j=s.size()-1;i<j;i++,j--){\\n            if(s[i]!=s[j])\\n                if(int(s[i])<int(s[j]))\\n                    s[j]=s[i];\\n                if(int(s[j])<int(s[i]))\\n                    s[i]=s[j];       \\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n               \\n        for(int i=0, j=s.size()-1;i<j;i++,j--){\\n            if(s[i]!=s[j])\\n                if(int(s[i])<int(s[j]))\\n                    s[j]=s[i];\\n                if(int(s[j])<int(s[i]))\\n                    s[i]=s[j];       \\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801364,
                "title": "2-pointer-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int i=0;\\n        int j=s.length()-1;\\n        while(i<j)\\n        {\\n            if(s[i]!=s[j])\\n            {\\n                char x=min(s[i],s[j]);\\n                s[i]=x;s[j]=x;\\n            }\\n            i++;j--;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int i=0;\\n        int j=s.length()-1;\\n        while(i<j)\\n        {\\n            if(s[i]!=s[j])\\n            {\\n                char x=min(s[i],s[j]);\\n                s[i]=x;s[j]=x;\\n            }\\n            i++;j--;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801052,
                "title": "easiest-solution-using-two-pointer-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int n=0;\\n        int p=s.size()-1;\\n        while(n<p)\\n        {\\n            if(s[n]!=s[p])\\n            {\\n                char x=min(s[n],s[p]);\\n                s[n]=s[p]=x;\\n            }\\n            n++;\\n            p--;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int n=0;\\n        int p=s.size()-1;\\n        while(n<p)\\n        {\\n            if(s[n]!=s[p])\\n            {\\n                char x=min(s[n],s[p]);\\n                s[n]=s[p]=x;\\n            }\\n            n++;\\n            p--;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798042,
                "title": "beginner-friendly-c-code-two-pointers-c-explained-with-comments",
                "content": "\\n# Complexity\\n- Time complexity: **O(n)**\\n\\n- Space complexity: **O(1)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) \\n    {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<j)    \\n        {\\n            if(s.at(i)==s.at(j))\\n            {\\n                i++;\\n                j--;\\n            }\\n            else \\n            {\\n                if(s[i]>s[j])\\n                {\\n                    s[i]=s[j];\\n                }\\n                else\\n                {\\n                    s[j]=s[i];\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```\\nIf you liked my approach please upvote ! Happy Coding \\u2764\\uFE0F",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) \\n    {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<j)    \\n        {\\n            if(s.at(i)==s.at(j))\\n            {\\n                i++;\\n                j--;\\n            }\\n            else \\n            {\\n                if(s[i]>s[j])\\n                {\\n                    s[i]=s[j];\\n                }\\n                else\\n                {\\n                    s[j]=s[i];\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797465,
                "title": "java-two-pointers-8ms-beat-100-6-lines-of-code-beginner-friendly",
                "content": "# Intuition\\n![image.png](https://assets.leetcode.com/users/images/fb9aed2c-96fd-474d-a975-7a76042c6467_1689953604.8667414.png)\\nThe intuition behind this approach is to create the lexicographically smallest palindrome from a given string by using two pointers, one starting from the beginning of the string and the other from the end. We compare the characters at these two pointers and choose the smaller one to fill in the character array.\\n\\n# Approach\\nWe start by initializing two pointers, `l` and `r`, at the beginning and end of the string respectively. We also initialize a character array `chars` to store the characters of the palindrome.\\n\\n```java\\nint n = s.length() - 1, l = 0, r = n - 1;\\nchar[] chars = new char[n];\\n```\\n\\nNext, we loop through the string to determine the characters to be filled into the array:\\n\\n```java\\nwhile(l <= r) {\\n    char leftChar = s.charAt(l);\\n    char rightChar = s.charAt(r);\\n    char ch = \\' \\';\\n    if(leftChar < rightChar) {\\n        ch = leftChar;\\n    } else {\\n        ch = rightChar;\\n    }\\n    chars[l] = ch;\\n    chars[r] = ch;\\n    l++; r--;\\n}\\n```\\n\\nWe can simplify the `if-else` logic using the ternary operator:\\n\\n```java\\nwhile(l <= r) {\\n    char leftChar = s.charAt(l);\\n    char rightChar = s.charAt(r);\\n    char ch = leftChar < rightChar ? leftChar : rightChar;\\n    chars[l] = ch;\\n    chars[r] = ch;\\n    l++; r--;\\n}\\n```\\n\\nFurthermore, we can eliminate the variables `leftChar` and `rightChar` and directly assign the character to `chars` array\\n\\n```java\\nwhile(l <= r) {\\n    chars[l++] = chars[r--] = (char) Math.min(s.charAt(l), s.charAt(r));\\n}\\n```\\n\\nTo make the code more concise, we can use a for loop and declare variables directly:\\n\\n```java\\nfor (int l = 0, r = n - 1; l <= r; l++, r--) {\\n    chars[l] = chars[r] = (char) Math.min(s.charAt(l), s.charAt(r));\\n}\\n```\\n\\n# Complexity\\n- Time complexity: $O(n/2)$ ~ $O(n)$ (Since we loop through only half of the string)\\n- Space complexity: $O(n)$\\n\\n# Code\\n```java\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        int n = s.length(); \\n        char[] chars = new char[n];\\n        for (int l = 0, r = n - 1; l <= r; l++, r--) {\\n            chars[l] = chars[r] = (char) Math.min(s.charAt(l), s.charAt(r));\\n        }\\n        return String.valueOf(chars);\\n    }\\n}\\n```\\n\\nIf you like the solution and the explanation, please give me an upvote! It would be very helpful \\uD83D\\uDE0A\\n\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```java\\nint n = s.length() - 1, l = 0, r = n - 1;\\nchar[] chars = new char[n];\\n```\n```java\\nwhile(l <= r) {\\n    char leftChar = s.charAt(l);\\n    char rightChar = s.charAt(r);\\n    char ch = \\' \\';\\n    if(leftChar < rightChar) {\\n        ch = leftChar;\\n    } else {\\n        ch = rightChar;\\n    }\\n    chars[l] = ch;\\n    chars[r] = ch;\\n    l++; r--;\\n}\\n```\n```java\\nwhile(l <= r) {\\n    char leftChar = s.charAt(l);\\n    char rightChar = s.charAt(r);\\n    char ch = leftChar < rightChar ? leftChar : rightChar;\\n    chars[l] = ch;\\n    chars[r] = ch;\\n    l++; r--;\\n}\\n```\n```java\\nwhile(l <= r) {\\n    chars[l++] = chars[r--] = (char) Math.min(s.charAt(l), s.charAt(r));\\n}\\n```\n```java\\nfor (int l = 0, r = n - 1; l <= r; l++, r--) {\\n    chars[l] = chars[r] = (char) Math.min(s.charAt(l), s.charAt(r));\\n}\\n```\n```java\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        int n = s.length(); \\n        char[] chars = new char[n];\\n        for (int l = 0, r = n - 1; l <= r; l++, r--) {\\n            chars[l] = chars[r] = (char) Math.min(s.charAt(l), s.charAt(r));\\n        }\\n        return String.valueOf(chars);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795880,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        char[] arr = s.toCharArray();\\n        int j = arr.length - 1;\\n        for (int i = 0; i < j; i++) {\\n            if (arr[i] < arr[j]) {\\n                arr[j] = arr[i];\\n            } else if (arr[j] < arr[i]) {\\n                arr[i] = arr[j];\\n            }\\n            --j;\\n        }\\n        return new String(arr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        char[] arr = s.toCharArray();\\n        int j = arr.length - 1;\\n        for (int i = 0; i < j; i++) {\\n            if (arr[i] < arr[j]) {\\n                arr[j] = arr[i];\\n            } else if (arr[j] < arr[i]) {\\n                arr[i] = arr[j];\\n            }\\n            --j;\\n        }\\n        return new String(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795651,
                "title": "simple-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int low=0,high=s.size()-1;\\n        vector<char>ans(s.size());\\n        string str;\\n        while(low<=high)\\n        {\\n            if(s[low]==s[high])\\n            {\\n                \\n                ans[low]=s[low];\\n                ans[high]=s[high];\\n                low++;\\n                high--;\\n            }\\n            else if(s[low]!=s[high])\\n            {\\n                if(s[low]>s[high])\\n                {\\n                  \\n                    char new_ele=s[high];\\n                    ans[low]=new_ele;\\n                    ans[high]=new_ele;\\n                }\\n                else{\\n                   \\n                     char new_ele1=s[low];\\n                    ans[high]= new_ele1;\\n                    ans[low]=new_ele1;\\n                }\\n                low++;\\n                high--;\\n            }\\n        }\\n      for(auto i:ans)str+=i;\\n      return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int low=0,high=s.size()-1;\\n        vector<char>ans(s.size());\\n        string str;\\n        while(low<=high)\\n        {\\n            if(s[low]==s[high])\\n            {\\n                \\n                ans[low]=s[low];\\n                ans[high]=s[high];\\n                low++;\\n                high--;\\n            }\\n            else if(s[low]!=s[high])\\n            {\\n                if(s[low]>s[high])\\n                {\\n                  \\n                    char new_ele=s[high];\\n                    ans[low]=new_ele;\\n                    ans[high]=new_ele;\\n                }\\n                else{\\n                   \\n                     char new_ele1=s[low];\\n                    ans[high]= new_ele1;\\n                    ans[low]=new_ele1;\\n                }\\n                low++;\\n                high--;\\n            }\\n        }\\n      for(auto i:ans)str+=i;\\n      return str;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3788921,
                "title": "easy-to-understand-java-solution-make-smallest-palindrome",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        StringBuilder str = new StringBuilder();\\n        str.append(s);\\n        \\n        for(int i = 0; i < s.length() / 2; i++){\\n            int a = s.charAt(i);\\n            int b = s.charAt(s.length() - i - 1);\\n            if(a > b) str.replace(i,i + 1, String.valueOf(s.charAt(s.length() - i - 1)));\\n            else if(a < b) str.replace(s.length() - i - 1, s.length() - i, String.valueOf(s.charAt(i)));\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        StringBuilder str = new StringBuilder();\\n        str.append(s);\\n        \\n        for(int i = 0; i < s.length() / 2; i++){\\n            int a = s.charAt(i);\\n            int b = s.charAt(s.length() - i - 1);\\n            if(a > b) str.replace(i,i + 1, String.valueOf(s.charAt(s.length() - i - 1)));\\n            else if(a < b) str.replace(s.length() - i - 1, s.length() - i, String.valueOf(s.charAt(i)));\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779642,
                "title": "easy-javascript-solution-with-explantion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar makeSmallestPalindrome = function(s) {\\n    let str = \\'\\', j = s.length - 1; // initialize empty str and j is equal to length of s - 1\\n\\n    function smallestPalindrome(string, len){ // initialize function smallestPalindrome with parameter string and len\\n        for(let i=0; i<len; i++){ // loop through the len\\n            let firstChar = string.charCodeAt(i); // initialize firstChar is equal to charCode of ith character of string\\n            let lastChar = string.charCodeAt(j) // initialize lastChar is equal to charCode of jth character of string\\n            if(firstChar == lastChar){ // if firstChar is equal to lastChar then add str and ith char of string in str and decrement j\\n                str += string.charAt(i);\\n                j--;\\n            }else{ // else \\n                if(firstChar > lastChar){ // if firstChar is greater than or equal to lastChar then add str and jth char of string in str and decrement j\\n                    str += string.charAt(j);\\n                    j--;\\n                }else{ // else add str and ith char of string in str and decrement j\\n                    str += string.charAt(i);\\n                    j--;\\n                }\\n            }\\n        }\\n    }\\n    smallestPalindrome(s, s.length/2); // call smallestPalindrome fuction with argument s and the half of length of s\\n    if(s.length % 2 == 0){ // if length of s is even then return str and reverse of str\\n        return (str + str.split(\"\").reverse().join(\"\"))\\n        \\n    }else{ // if length of s is even then return str and reverse of str from second character \\n        return (str + str.split(\"\").reverse().slice(1).join(\"\"))\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar makeSmallestPalindrome = function(s) {\\n    let str = \\'\\', j = s.length - 1; // initialize empty str and j is equal to length of s - 1\\n\\n    function smallestPalindrome(string, len){ // initialize function smallestPalindrome with parameter string and len\\n        for(let i=0; i<len; i++){ // loop through the len\\n            let firstChar = string.charCodeAt(i); // initialize firstChar is equal to charCode of ith character of string\\n            let lastChar = string.charCodeAt(j) // initialize lastChar is equal to charCode of jth character of string\\n            if(firstChar == lastChar){ // if firstChar is equal to lastChar then add str and ith char of string in str and decrement j\\n                str += string.charAt(i);\\n                j--;\\n            }else{ // else \\n                if(firstChar > lastChar){ // if firstChar is greater than or equal to lastChar then add str and jth char of string in str and decrement j\\n                    str += string.charAt(j);\\n                    j--;\\n                }else{ // else add str and ith char of string in str and decrement j\\n                    str += string.charAt(i);\\n                    j--;\\n                }\\n            }\\n        }\\n    }\\n    smallestPalindrome(s, s.length/2); // call smallestPalindrome fuction with argument s and the half of length of s\\n    if(s.length % 2 == 0){ // if length of s is even then return str and reverse of str\\n        return (str + str.split(\"\").reverse().join(\"\"))\\n        \\n    }else{ // if length of s is even then return str and reverse of str from second character \\n        return (str + str.split(\"\").reverse().slice(1).join(\"\"))\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3779159,
                "title": "2-pointer-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int p1 = 0;\\n        int p2 = s.size()-1;\\n        while(p1<p2){\\n            if(s[p1]!=s[p2]){\\n                int k = s[p1];\\n                int l = s[p2];\\n                int t = min(k,l);\\n                char c = t;\\n                s[p1] = c;\\n                s[p2] = c;\\n            }\\n            p1++;\\n            p2--;\\n\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n        int p1 = 0;\\n        int p2 = s.size()-1;\\n        while(p1<p2){\\n            if(s[p1]!=s[p2]){\\n                int k = s[p1];\\n                int l = s[p2];\\n                int t = min(k,l);\\n                char c = t;\\n                s[p1] = c;\\n                s[p2] = c;\\n            }\\n            p1++;\\n            p2--;\\n\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777374,
                "title": "very-easy-jebasraja",
                "content": "# Intuition:Karunya university::Accenture\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) \\n    {\\n\\n      char[] ch=new char[s.length()];\\n   \\n   int i=0;\\n   int j=s.length()-1;\\n   \\n   while(i<j)\\n  {      \\n      System.out.println(i+\" \"+j);\\n\\n      if (s.charAt(i)!=s.charAt(j)) \\n      {\\n        if (s.charAt(i)<s.charAt(j)) \\n        {\\n          ch[i]=s.charAt(i);\\n          ch[j]=s.charAt(i);\\n        }\\n        else \\n        {\\n          ch[i]=s.charAt(j);\\n          ch[j]=s.charAt(j);\\n        }\\n      \\n      }\\n      else\\n      {\\n        ch[i]=s.charAt(i);\\n        ch[j]=s.charAt(j);\\n      }   \\n      i++;\\n      j--;\\n  }\\n\\n  if (s.length()%2!=0) \\n  {\\n      ch[i]=s.charAt(i);   \\n  }\\n    \\n  String str=new String(ch);\\n//   System.out.println(str); \\nreturn str;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) \\n    {\\n\\n      char[] ch=new char[s.length()];\\n   \\n   int i=0;\\n   int j=s.length()-1;\\n   \\n   while(i<j)\\n  {      \\n      System.out.println(i+\" \"+j);\\n\\n      if (s.charAt(i)!=s.charAt(j)) \\n      {\\n        if (s.charAt(i)<s.charAt(j)) \\n        {\\n          ch[i]=s.charAt(i);\\n          ch[j]=s.charAt(i);\\n        }\\n        else \\n        {\\n          ch[i]=s.charAt(j);\\n          ch[j]=s.charAt(j);\\n        }\\n      \\n      }\\n      else\\n      {\\n        ch[i]=s.charAt(i);\\n        ch[j]=s.charAt(j);\\n      }   \\n      i++;\\n      j--;\\n  }\\n\\n  if (s.length()%2!=0) \\n  {\\n      ch[i]=s.charAt(i);   \\n  }\\n    \\n  String str=new String(ch);\\n//   System.out.println(str); \\nreturn str;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3771084,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar makeSmallestPalindrome = function(s) {\\n    let arr = s.split(\\'\\');\\n    let left = 0;\\n    let right = arr.length - 1;\\n    while (left < right) {\\n        if (arr[left] < arr[right]) {\\n            arr[right--] = arr[left++];\\n        } else {\\n            arr[left++] = arr[right--];\\n        }\\n    }\\n    return arr.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar makeSmallestPalindrome = function(s) {\\n    let arr = s.split(\\'\\');\\n    let left = 0;\\n    let right = arr.length - 1;\\n    while (left < right) {\\n        if (arr[left] < arr[right]) {\\n            arr[right--] = arr[left++];\\n        } else {\\n            arr[left++] = arr[right--];\\n        }\\n    }\\n    return arr.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3768201,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nby two pointer\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nset ont pointer on index 0 and second pointer on index size-1.\\nwhere values differ change the value of one index by second index lexographically.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\nint n=s.size();\\nint i=0;\\nint j=n-1;\\nwhile(i<j)\\n{\\nif(s[i]!=s[j])\\n{\\n    int val1=s[i]-\\'a\\';\\n    int val2=s[j]-\\'a\\';\\n    if(val1<val2)\\n    {\\n       s[j]=s[i];\\n    }\\nelse{\\n    s[i]=s[j];\\n}\\n}\\ni++;\\nj--;\\n}\\n\\nreturn s;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\nint n=s.size();\\nint i=0;\\nint j=n-1;\\nwhile(i<j)\\n{\\nif(s[i]!=s[j])\\n{\\n    int val1=s[i]-\\'a\\';\\n    int val2=s[j]-\\'a\\';\\n    if(val1<val2)\\n    {\\n       s[j]=s[i];\\n    }\\nelse{\\n    s[i]=s[j];\\n}\\n}\\ni++;\\nj--;\\n}\\n\\nreturn s;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768200,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nby two pointer\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nset ont pointer on index 0 and second pointer on index size-1.\\nwhere values differ change the value of one index by second index lexographically.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\nint n=s.size();\\nint i=0;\\nint j=n-1;\\nwhile(i<j)\\n{\\nif(s[i]!=s[j])\\n{\\n    int val1=s[i]-\\'a\\';\\n    int val2=s[j]-\\'a\\';\\n    if(val1<val2)\\n    {\\n       s[j]=s[i];\\n    }\\nelse{\\n    s[i]=s[j];\\n}\\n}\\ni++;\\nj--;\\n}\\n\\nreturn s;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\nint n=s.size();\\nint i=0;\\nint j=n-1;\\nwhile(i<j)\\n{\\nif(s[i]!=s[j])\\n{\\n    int val1=s[i]-\\'a\\';\\n    int val2=s[j]-\\'a\\';\\n    if(val1<val2)\\n    {\\n       s[j]=s[i];\\n    }\\nelse{\\n    s[i]=s[j];\\n}\\n}\\ni++;\\nj--;\\n}\\n\\nreturn s;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767120,
                "title": "easy-java-solution-using-char-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n/2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        char[] ch=s.toCharArray();\\n        int n=ch.length;\\n       for(int i=0;i<n;i++){\\n        if(i<n-i){\\n        char ch1=ch[i];\\n        char ch2=ch[n-i-1];\\n        if(ch1!=ch2 && ch1<ch2){\\n            ch[n-i-1]=ch1;\\n\\n        }\\n        else if(ch1!=ch2 && ch1>ch2){\\n            ch[i]=ch2;\\n\\n        }\\n           }\\n\\n       }\\n       String s1=new String(ch);\\n       return s1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        char[] ch=s.toCharArray();\\n        int n=ch.length;\\n       for(int i=0;i<n;i++){\\n        if(i<n-i){\\n        char ch1=ch[i];\\n        char ch2=ch[n-i-1];\\n        if(ch1!=ch2 && ch1<ch2){\\n            ch[n-i-1]=ch1;\\n\\n        }\\n        else if(ch1!=ch2 && ch1>ch2){\\n            ch[i]=ch2;\\n\\n        }\\n           }\\n\\n       }\\n       String s1=new String(ch);\\n       return s1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764930,
                "title": "easy-and-beautiful-solution-2-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n\\n    int left = 0;\\n    int right = s.length() - 1;\\n    \\n    while (left < right) {\\n        if (s[left] != s[right]) {\\n            s[left] = s[right] = min(s[left], s[right]);\\n        }\\n        right--;\\n        left++;\\n    }\\n    return s;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeSmallestPalindrome(string s) {\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n\\n    int left = 0;\\n    int right = s.length() - 1;\\n    \\n    while (left < right) {\\n        if (s[left] != s[right]) {\\n            s[left] = s[right] = min(s[left], s[right]);\\n        }\\n        right--;\\n        left++;\\n    }\\n    return s;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3751033,
                "title": "stringbuilder-approaching",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The string will be separated to 2 parts:\\n  + Part 1: If the length of the string is an even number. Therefore, the middle character is [ (length(of string) /2 ) - 1 ], then I compare different characters in a common index and choose the smaller ones.\\n  + Part 2: If the length is odd, the middle character is just [(length/2)]\\n- My code using a StringBuilder then copying from the original string suppose to modify easily. \\n\\n# Code\\n```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        StringBuilder str1 = new StringBuilder(s);\\n        int len = s.length();\\n        if(len % 2 == 0){\\n            for(int i = 0; i <= (len/2) - 1; i++){\\n                if(str1.charAt(i) != str1.charAt(len - i - 1)){\\n                    char c1 = str1.charAt(i);\\n                    char c2 = str1.charAt(len - i - 1);\\n                    char c = (c1 < c2)? c1 : c2;\\n                    str1.setCharAt(i, c);\\n                    str1.setCharAt(len - i - 1, c);\\n                }\\n            }\\n            return str1.toString();\\n        }else{\\n            for(int i = 0; i <= (len/2); i++){\\n                if(str1.charAt(i) != str1.charAt(len - i - 1)){\\n                    char c1 = str1.charAt(i);\\n                    char c2 = str1.charAt(len - i - 1);\\n                    char c = (c1 < c2)? c1 : c2;\\n                    str1.setCharAt(i, c);\\n                    str1.setCharAt(len - i - 1, c);\\n                }\\n            }\\n            return str1.toString();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        StringBuilder str1 = new StringBuilder(s);\\n        int len = s.length();\\n        if(len % 2 == 0){\\n            for(int i = 0; i <= (len/2) - 1; i++){\\n                if(str1.charAt(i) != str1.charAt(len - i - 1)){\\n                    char c1 = str1.charAt(i);\\n                    char c2 = str1.charAt(len - i - 1);\\n                    char c = (c1 < c2)? c1 : c2;\\n                    str1.setCharAt(i, c);\\n                    str1.setCharAt(len - i - 1, c);\\n                }\\n            }\\n            return str1.toString();\\n        }else{\\n            for(int i = 0; i <= (len/2); i++){\\n                if(str1.charAt(i) != str1.charAt(len - i - 1)){\\n                    char c1 = str1.charAt(i);\\n                    char c2 = str1.charAt(len - i - 1);\\n                    char c = (c1 < c2)? c1 : c2;\\n                    str1.setCharAt(i, c);\\n                    str1.setCharAt(len - i - 1, c);\\n                }\\n            }\\n            return str1.toString();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750848,
                "title": "java-easy-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeSmallestPalindrome(String arr) {\\n       char[] s=arr.toCharArray();\\n       int i=0;\\n       String str=\"\";\\n       int j=s.length-1;\\n       while(i<j)\\n       {\\n         if(s[i]!=s[j])\\n         {\\n            if(s[i]<s[j])\\n            {\\n               s[j]=s[i];\\n            }\\n            else if(s[i]>s[j])\\n            {\\n            s[i]=s[j];\\n            }\\n         }\\n         i++;\\n         j--;\\n       }\\n       for(char item:s)\\n       str+=item;\\n       return str;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeSmallestPalindrome(String arr) {\\n       char[] s=arr.toCharArray();\\n       int i=0;\\n       String str=\"\";\\n       int j=s.length-1;\\n       while(i<j)\\n       {\\n         if(s[i]!=s[j])\\n         {\\n            if(s[i]<s[j])\\n            {\\n               s[j]=s[i];\\n            }\\n            else if(s[i]>s[j])\\n            {\\n            s[i]=s[j];\\n            }\\n         }\\n         i++;\\n         j--;\\n       }\\n       for(char item:s)\\n       str+=item;\\n       return str;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749861,
                "title": "using-ord-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        letters = [letter for letter in s]\\n        i, j = 0, len(letters)-1\\n        while i < j:\\n            if ord(letters[i]) < ord(letters[j]):\\n                letters[j] = letters[i]\\n            if ord(letters[j]) < ord(letters[i]):\\n                letters[i] = letters[j]\\n            i += 1\\n            j -= 1\\n        return \\'\\'.join(letters)  \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        letters = [letter for letter in s]\\n        i, j = 0, len(letters)-1\\n        while i < j:\\n            if ord(letters[i]) < ord(letters[j]):\\n                letters[j] = letters[i]\\n            if ord(letters[j]) < ord(letters[i]):\\n                letters[i] = letters[j]\\n            i += 1\\n            j -= 1\\n        return \\'\\'.join(letters)  \\n            \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1922428,
                "content": [
                    {
                        "username": "AyushS9020",
                        "content": "Can someone please explain this case ??\n```\ninput : s = \"atie\"\nOutput : \"atta\"\nExpected : \"aiia\"\n```\nHow can we connect `a` and `i` if they are not connected at the first place ?\n\nAlso if we consider a case where we can connect these letters, wouldnt be the smallest one be \n```\nExpected : \"aeea\"\n```"
                    },
                    {
                        "username": "danek1313",
                        "content": "I think the key here is completing the task with \"the minimum number of operations possible\" and keeping it to be the \"lexicographically smallest one\" i.e. using the lowest letter values possible.\\n\\nIn the case that every letter is different in a string, the fewest operations we need to do are s.length / 2. We check first the outermost letters. If they match, great. No operation is needed. If they don\\'t match, we need to set one of those letters to whichever letter is the lowest.\\n\\nIn the case of \"atie\" we first consider \\'a\\' (first) vs \\'e\\' (last).\\n\\nSince \\'a\\' is lower than \\'e\\', change \\'e\\' to \\'a\\'. We now have \"atia\".\\n\\nThen check the next pair of letters as we head towards the inside. This has us comparing \\'t\\' (second) vs \\'i\\' (next-to-last).\\n\\nSince \\'i\\' is lower than \\'t\\', change \\'t\\' to \\'i\\'. This results in \"aiia\".\\n\\n\"aeea\" is not a possible outcome because \\'e\\' only resides in the outermost pair of letters. So, it could never end up on the inside pair."
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "Think lexicographically using two pointers!"
                    },
                    {
                        "username": "vjGokul",
                        "content": "poda pattu"
                    },
                    {
                        "username": "CalCreate",
                        "content": "what is the output when it is not possible to return the smallest lexicographic string ? "
                    },
                    {
                        "username": "mohitdbst",
                        "content": "Basic intution we get from palindrome is that we will use 2 pointers , \nnow we can have 2 scenarios \n1 :  element on ith ind is equal to element on jth ind : in this case u will not do any changes just move pointers i -> i++ and j -> j--\n2 : element on ith ind is not equal to element on jth ind : in this case we are supposed to change any one of the element on ith or jth element so which we should change with whom to make string lexicographically smallest one, any guesses?\n\nyes we will update the element which is larger among both the ind to the smallest element from both the ind and hence making the string lexicographically smallest one.\n\nu can refer to my code given below.\n `string makeSmallestPalindrome(string s) {`\n       `int i = 0;`\n        `int j = s.size()-1;`\n         `while(i < j){`\n              `if(s[i] != s[j]){`\n                `if(s[i] < s[j]){`\n                  `  s[j] = s[i];`\n                `}else s[i] = s[j];`\n         `   }`\n           ` i++;`\n          `  j--;`\n      `  }`\n       ` return s;`\n   ` }`\n\n @"
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "The idea is to check if the first and last element are the same, the second and second to last are the same, and so on.  If not, check which of the 2 letters comes first in the alphabet and then replace the one that comes second with the first one.\\n\\n\\n"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "I think the description should also say that you can relace with another alphabet **present  in the string**"
                    }
                ]
            },
            {
                "id": 1900711,
                "content": [
                    {
                        "username": "AyushS9020",
                        "content": "Can someone please explain this case ??\n```\ninput : s = \"atie\"\nOutput : \"atta\"\nExpected : \"aiia\"\n```\nHow can we connect `a` and `i` if they are not connected at the first place ?\n\nAlso if we consider a case where we can connect these letters, wouldnt be the smallest one be \n```\nExpected : \"aeea\"\n```"
                    },
                    {
                        "username": "danek1313",
                        "content": "I think the key here is completing the task with \"the minimum number of operations possible\" and keeping it to be the \"lexicographically smallest one\" i.e. using the lowest letter values possible.\\n\\nIn the case that every letter is different in a string, the fewest operations we need to do are s.length / 2. We check first the outermost letters. If they match, great. No operation is needed. If they don\\'t match, we need to set one of those letters to whichever letter is the lowest.\\n\\nIn the case of \"atie\" we first consider \\'a\\' (first) vs \\'e\\' (last).\\n\\nSince \\'a\\' is lower than \\'e\\', change \\'e\\' to \\'a\\'. We now have \"atia\".\\n\\nThen check the next pair of letters as we head towards the inside. This has us comparing \\'t\\' (second) vs \\'i\\' (next-to-last).\\n\\nSince \\'i\\' is lower than \\'t\\', change \\'t\\' to \\'i\\'. This results in \"aiia\".\\n\\n\"aeea\" is not a possible outcome because \\'e\\' only resides in the outermost pair of letters. So, it could never end up on the inside pair."
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "Think lexicographically using two pointers!"
                    },
                    {
                        "username": "vjGokul",
                        "content": "poda pattu"
                    },
                    {
                        "username": "CalCreate",
                        "content": "what is the output when it is not possible to return the smallest lexicographic string ? "
                    },
                    {
                        "username": "mohitdbst",
                        "content": "Basic intution we get from palindrome is that we will use 2 pointers , \nnow we can have 2 scenarios \n1 :  element on ith ind is equal to element on jth ind : in this case u will not do any changes just move pointers i -> i++ and j -> j--\n2 : element on ith ind is not equal to element on jth ind : in this case we are supposed to change any one of the element on ith or jth element so which we should change with whom to make string lexicographically smallest one, any guesses?\n\nyes we will update the element which is larger among both the ind to the smallest element from both the ind and hence making the string lexicographically smallest one.\n\nu can refer to my code given below.\n `string makeSmallestPalindrome(string s) {`\n       `int i = 0;`\n        `int j = s.size()-1;`\n         `while(i < j){`\n              `if(s[i] != s[j]){`\n                `if(s[i] < s[j]){`\n                  `  s[j] = s[i];`\n                `}else s[i] = s[j];`\n         `   }`\n           ` i++;`\n          `  j--;`\n      `  }`\n       ` return s;`\n   ` }`\n\n @"
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "The idea is to check if the first and last element are the same, the second and second to last are the same, and so on.  If not, check which of the 2 letters comes first in the alphabet and then replace the one that comes second with the first one.\\n\\n\\n"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "I think the description should also say that you can relace with another alphabet **present  in the string**"
                    }
                ]
            },
            {
                "id": 1928397,
                "content": [
                    {
                        "username": "AyushS9020",
                        "content": "Can someone please explain this case ??\n```\ninput : s = \"atie\"\nOutput : \"atta\"\nExpected : \"aiia\"\n```\nHow can we connect `a` and `i` if they are not connected at the first place ?\n\nAlso if we consider a case where we can connect these letters, wouldnt be the smallest one be \n```\nExpected : \"aeea\"\n```"
                    },
                    {
                        "username": "danek1313",
                        "content": "I think the key here is completing the task with \"the minimum number of operations possible\" and keeping it to be the \"lexicographically smallest one\" i.e. using the lowest letter values possible.\\n\\nIn the case that every letter is different in a string, the fewest operations we need to do are s.length / 2. We check first the outermost letters. If they match, great. No operation is needed. If they don\\'t match, we need to set one of those letters to whichever letter is the lowest.\\n\\nIn the case of \"atie\" we first consider \\'a\\' (first) vs \\'e\\' (last).\\n\\nSince \\'a\\' is lower than \\'e\\', change \\'e\\' to \\'a\\'. We now have \"atia\".\\n\\nThen check the next pair of letters as we head towards the inside. This has us comparing \\'t\\' (second) vs \\'i\\' (next-to-last).\\n\\nSince \\'i\\' is lower than \\'t\\', change \\'t\\' to \\'i\\'. This results in \"aiia\".\\n\\n\"aeea\" is not a possible outcome because \\'e\\' only resides in the outermost pair of letters. So, it could never end up on the inside pair."
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "Think lexicographically using two pointers!"
                    },
                    {
                        "username": "vjGokul",
                        "content": "poda pattu"
                    },
                    {
                        "username": "CalCreate",
                        "content": "what is the output when it is not possible to return the smallest lexicographic string ? "
                    },
                    {
                        "username": "mohitdbst",
                        "content": "Basic intution we get from palindrome is that we will use 2 pointers , \nnow we can have 2 scenarios \n1 :  element on ith ind is equal to element on jth ind : in this case u will not do any changes just move pointers i -> i++ and j -> j--\n2 : element on ith ind is not equal to element on jth ind : in this case we are supposed to change any one of the element on ith or jth element so which we should change with whom to make string lexicographically smallest one, any guesses?\n\nyes we will update the element which is larger among both the ind to the smallest element from both the ind and hence making the string lexicographically smallest one.\n\nu can refer to my code given below.\n `string makeSmallestPalindrome(string s) {`\n       `int i = 0;`\n        `int j = s.size()-1;`\n         `while(i < j){`\n              `if(s[i] != s[j]){`\n                `if(s[i] < s[j]){`\n                  `  s[j] = s[i];`\n                `}else s[i] = s[j];`\n         `   }`\n           ` i++;`\n          `  j--;`\n      `  }`\n       ` return s;`\n   ` }`\n\n @"
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "The idea is to check if the first and last element are the same, the second and second to last are the same, and so on.  If not, check which of the 2 letters comes first in the alphabet and then replace the one that comes second with the first one.\\n\\n\\n"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "I think the description should also say that you can relace with another alphabet **present  in the string**"
                    }
                ]
            },
            {
                "id": 1902005,
                "content": [
                    {
                        "username": "AyushS9020",
                        "content": "Can someone please explain this case ??\n```\ninput : s = \"atie\"\nOutput : \"atta\"\nExpected : \"aiia\"\n```\nHow can we connect `a` and `i` if they are not connected at the first place ?\n\nAlso if we consider a case where we can connect these letters, wouldnt be the smallest one be \n```\nExpected : \"aeea\"\n```"
                    },
                    {
                        "username": "danek1313",
                        "content": "I think the key here is completing the task with \"the minimum number of operations possible\" and keeping it to be the \"lexicographically smallest one\" i.e. using the lowest letter values possible.\\n\\nIn the case that every letter is different in a string, the fewest operations we need to do are s.length / 2. We check first the outermost letters. If they match, great. No operation is needed. If they don\\'t match, we need to set one of those letters to whichever letter is the lowest.\\n\\nIn the case of \"atie\" we first consider \\'a\\' (first) vs \\'e\\' (last).\\n\\nSince \\'a\\' is lower than \\'e\\', change \\'e\\' to \\'a\\'. We now have \"atia\".\\n\\nThen check the next pair of letters as we head towards the inside. This has us comparing \\'t\\' (second) vs \\'i\\' (next-to-last).\\n\\nSince \\'i\\' is lower than \\'t\\', change \\'t\\' to \\'i\\'. This results in \"aiia\".\\n\\n\"aeea\" is not a possible outcome because \\'e\\' only resides in the outermost pair of letters. So, it could never end up on the inside pair."
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "Think lexicographically using two pointers!"
                    },
                    {
                        "username": "vjGokul",
                        "content": "poda pattu"
                    },
                    {
                        "username": "CalCreate",
                        "content": "what is the output when it is not possible to return the smallest lexicographic string ? "
                    },
                    {
                        "username": "mohitdbst",
                        "content": "Basic intution we get from palindrome is that we will use 2 pointers , \nnow we can have 2 scenarios \n1 :  element on ith ind is equal to element on jth ind : in this case u will not do any changes just move pointers i -> i++ and j -> j--\n2 : element on ith ind is not equal to element on jth ind : in this case we are supposed to change any one of the element on ith or jth element so which we should change with whom to make string lexicographically smallest one, any guesses?\n\nyes we will update the element which is larger among both the ind to the smallest element from both the ind and hence making the string lexicographically smallest one.\n\nu can refer to my code given below.\n `string makeSmallestPalindrome(string s) {`\n       `int i = 0;`\n        `int j = s.size()-1;`\n         `while(i < j){`\n              `if(s[i] != s[j]){`\n                `if(s[i] < s[j]){`\n                  `  s[j] = s[i];`\n                `}else s[i] = s[j];`\n         `   }`\n           ` i++;`\n          `  j--;`\n      `  }`\n       ` return s;`\n   ` }`\n\n @"
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "The idea is to check if the first and last element are the same, the second and second to last are the same, and so on.  If not, check which of the 2 letters comes first in the alphabet and then replace the one that comes second with the first one.\\n\\n\\n"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "I think the description should also say that you can relace with another alphabet **present  in the string**"
                    }
                ]
            },
            {
                "id": 2038563,
                "content": [
                    {
                        "username": "AyushS9020",
                        "content": "Can someone please explain this case ??\n```\ninput : s = \"atie\"\nOutput : \"atta\"\nExpected : \"aiia\"\n```\nHow can we connect `a` and `i` if they are not connected at the first place ?\n\nAlso if we consider a case where we can connect these letters, wouldnt be the smallest one be \n```\nExpected : \"aeea\"\n```"
                    },
                    {
                        "username": "danek1313",
                        "content": "I think the key here is completing the task with \"the minimum number of operations possible\" and keeping it to be the \"lexicographically smallest one\" i.e. using the lowest letter values possible.\\n\\nIn the case that every letter is different in a string, the fewest operations we need to do are s.length / 2. We check first the outermost letters. If they match, great. No operation is needed. If they don\\'t match, we need to set one of those letters to whichever letter is the lowest.\\n\\nIn the case of \"atie\" we first consider \\'a\\' (first) vs \\'e\\' (last).\\n\\nSince \\'a\\' is lower than \\'e\\', change \\'e\\' to \\'a\\'. We now have \"atia\".\\n\\nThen check the next pair of letters as we head towards the inside. This has us comparing \\'t\\' (second) vs \\'i\\' (next-to-last).\\n\\nSince \\'i\\' is lower than \\'t\\', change \\'t\\' to \\'i\\'. This results in \"aiia\".\\n\\n\"aeea\" is not a possible outcome because \\'e\\' only resides in the outermost pair of letters. So, it could never end up on the inside pair."
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "Think lexicographically using two pointers!"
                    },
                    {
                        "username": "vjGokul",
                        "content": "poda pattu"
                    },
                    {
                        "username": "CalCreate",
                        "content": "what is the output when it is not possible to return the smallest lexicographic string ? "
                    },
                    {
                        "username": "mohitdbst",
                        "content": "Basic intution we get from palindrome is that we will use 2 pointers , \nnow we can have 2 scenarios \n1 :  element on ith ind is equal to element on jth ind : in this case u will not do any changes just move pointers i -> i++ and j -> j--\n2 : element on ith ind is not equal to element on jth ind : in this case we are supposed to change any one of the element on ith or jth element so which we should change with whom to make string lexicographically smallest one, any guesses?\n\nyes we will update the element which is larger among both the ind to the smallest element from both the ind and hence making the string lexicographically smallest one.\n\nu can refer to my code given below.\n `string makeSmallestPalindrome(string s) {`\n       `int i = 0;`\n        `int j = s.size()-1;`\n         `while(i < j){`\n              `if(s[i] != s[j]){`\n                `if(s[i] < s[j]){`\n                  `  s[j] = s[i];`\n                `}else s[i] = s[j];`\n         `   }`\n           ` i++;`\n          `  j--;`\n      `  }`\n       ` return s;`\n   ` }`\n\n @"
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "The idea is to check if the first and last element are the same, the second and second to last are the same, and so on.  If not, check which of the 2 letters comes first in the alphabet and then replace the one that comes second with the first one.\\n\\n\\n"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "I think the description should also say that you can relace with another alphabet **present  in the string**"
                    }
                ]
            },
            {
                "id": 2025789,
                "content": [
                    {
                        "username": "AyushS9020",
                        "content": "Can someone please explain this case ??\n```\ninput : s = \"atie\"\nOutput : \"atta\"\nExpected : \"aiia\"\n```\nHow can we connect `a` and `i` if they are not connected at the first place ?\n\nAlso if we consider a case where we can connect these letters, wouldnt be the smallest one be \n```\nExpected : \"aeea\"\n```"
                    },
                    {
                        "username": "danek1313",
                        "content": "I think the key here is completing the task with \"the minimum number of operations possible\" and keeping it to be the \"lexicographically smallest one\" i.e. using the lowest letter values possible.\\n\\nIn the case that every letter is different in a string, the fewest operations we need to do are s.length / 2. We check first the outermost letters. If they match, great. No operation is needed. If they don\\'t match, we need to set one of those letters to whichever letter is the lowest.\\n\\nIn the case of \"atie\" we first consider \\'a\\' (first) vs \\'e\\' (last).\\n\\nSince \\'a\\' is lower than \\'e\\', change \\'e\\' to \\'a\\'. We now have \"atia\".\\n\\nThen check the next pair of letters as we head towards the inside. This has us comparing \\'t\\' (second) vs \\'i\\' (next-to-last).\\n\\nSince \\'i\\' is lower than \\'t\\', change \\'t\\' to \\'i\\'. This results in \"aiia\".\\n\\n\"aeea\" is not a possible outcome because \\'e\\' only resides in the outermost pair of letters. So, it could never end up on the inside pair."
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "Think lexicographically using two pointers!"
                    },
                    {
                        "username": "vjGokul",
                        "content": "poda pattu"
                    },
                    {
                        "username": "CalCreate",
                        "content": "what is the output when it is not possible to return the smallest lexicographic string ? "
                    },
                    {
                        "username": "mohitdbst",
                        "content": "Basic intution we get from palindrome is that we will use 2 pointers , \nnow we can have 2 scenarios \n1 :  element on ith ind is equal to element on jth ind : in this case u will not do any changes just move pointers i -> i++ and j -> j--\n2 : element on ith ind is not equal to element on jth ind : in this case we are supposed to change any one of the element on ith or jth element so which we should change with whom to make string lexicographically smallest one, any guesses?\n\nyes we will update the element which is larger among both the ind to the smallest element from both the ind and hence making the string lexicographically smallest one.\n\nu can refer to my code given below.\n `string makeSmallestPalindrome(string s) {`\n       `int i = 0;`\n        `int j = s.size()-1;`\n         `while(i < j){`\n              `if(s[i] != s[j]){`\n                `if(s[i] < s[j]){`\n                  `  s[j] = s[i];`\n                `}else s[i] = s[j];`\n         `   }`\n           ` i++;`\n          `  j--;`\n      `  }`\n       ` return s;`\n   ` }`\n\n @"
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "The idea is to check if the first and last element are the same, the second and second to last are the same, and so on.  If not, check which of the 2 letters comes first in the alphabet and then replace the one that comes second with the first one.\\n\\n\\n"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "I think the description should also say that you can relace with another alphabet **present  in the string**"
                    }
                ]
            }
        ]
    },
    {
        "title": "Extra Characters in a String",
        "question_content": "<p>You are given a <strong>0-indexed</strong> string <code>s</code> and a dictionary of words <code>dictionary</code>. You have to break <code>s</code> into one or more <strong>non-overlapping</strong> substrings such that each substring is present in <code>dictionary</code>. There may be some <strong>extra characters</strong> in <code>s</code> which are not present in any of the substrings.</p>\n\n<p>Return <em>the <strong>minimum</strong> number of extra characters left over if you break up </em><code>s</code><em> optimally.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;leetscode&quot;, dictionary = [&quot;leet&quot;,&quot;code&quot;,&quot;leetcode&quot;]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> We can break s in two substrings: &quot;leet&quot; from index 0 to 3 and &quot;code&quot; from index 5 to 8. There is only 1 unused character (at index 4), so we return 1.\n\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;sayhelloworld&quot;, dictionary = [&quot;hello&quot;,&quot;world&quot;]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> We can break s in two substrings: &quot;hello&quot; from index 3 to 7 and &quot;world&quot; from index 8 to 12. The characters at indices 0, 1, 2 are not used in any substring and thus are considered as extra characters. Hence, we return 3.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 50</code></li>\n\t<li><code>1 &lt;= dictionary.length &lt;= 50</code></li>\n\t<li><code>1 &lt;= dictionary[i].length &lt;= 50</code></li>\n\t<li><code>dictionary[i]</code>&nbsp;and <code>s</code> consists of only lowercase English letters</li>\n\t<li><code>dictionary</code> contains distinct words</li>\n</ul>\n",
        "solutions": [
            {
                "id": 3568666,
                "title": "recursion-top-down-bottom-up-explained-easy-to-understand",
                "content": "leetscode, dictionary = [\"leet\",\"code\",\"leetcode\"]\\n\\n**[l + eetscode]**\\n#Make a cut \\u201Cl\\u201D and fix the string\\n#Then get the extra character count for \\u201Ceetscode\\u201D (recursion)\\n#Now \\u201Cl\\u201D is not in dictionary so \\n**totalExtra = sizeof(\\u201Cl\\u201D) + nextExtra(got via recursion)**\\n//====================================================\\n**[le + etscode]**\\n#Make a cut \\u201Cle\\u201D and fix the string\\n#Then get the extra character count for \\u201Cetscode\\u201D (recursion)\\n#Noe \\u201Cle\\u201D is not in dictionary\\n**totalExtra = sizeof(\\u201Cle\\u201D) + nextExtra(got via recursion)**\\n//====================================================\\n**[lee + tscode]**\\n#Similarly for \\u201Clee\\u201D\\n//================================================================\\n**[leet + scode]**\\n#Make a cut \\u201Cleet\\u201D and fix the string\\n#Then get the extra character count for \\u201Cscode\\u201D (recursion)\\n#Now \\u201Cleet\\u201D is in dictionary :) [A relief]\\n**totalExtra = 0 + nextExtra(got via recursion)**\\n//==================================================================\\n#Similarly other calls are made\\n\\n## RECURSION\\n```\\nclass Solution {\\npublic:\\n    int solve(string& s, unordered_map<string, int>&mp, int index)\\n    {\\n        if (index >= s.size()) return 0;\\n        \\n        string currStr = \"\";\\n        int minExtra = s.size();\\n        for (int cutIdx = index; cutIdx < s.size(); cutIdx++)\\n        {\\n            currStr.push_back(s[cutIdx]);\\n            //currStr will be a string from (index to cutIdx)\\n            \\n            //if string not in dictionary, we have to delete as they are extra chars\\n            int currExtra = (mp.count(currStr))? 0 : currStr.size();\\n            int nextExtra = solve(s, mp, cutIdx + 1);\\n            int totalExtra = currExtra + nextExtra;\\n            \\n            minExtra = min(minExtra, totalExtra);\\n        }\\n        return minExtra;\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) \\n    {\\n        unordered_map<string, int>mp;\\n        for (string& word : dictionary) mp[word]++;\\n        \\n        int ans = solve(s, mp, 0);\\n        return ans;\\n        \\n    }\\n};\\n```\\n//======================================================================================================================\\n## TOP-DOWN MEMOIZATION\\n```\\nclass Solution {\\npublic:\\n    int solve(string& s, unordered_map<string, int>&mp, vector<int>&dp, int index)\\n    {\\n        if (index >= s.size()) return 0;\\n        if (dp[index] != -1) return dp[index]; //use the stored results\\n        \\n        string currStr = \"\";\\n        int minExtra = s.size();\\n        for (int cutIdx = index; cutIdx < s.size(); cutIdx++)\\n        {\\n            currStr.push_back(s[cutIdx]);\\n            //currStr will be a string from (index to cutIdx)\\n            \\n            //if string not in dictionary, we have to delete as they are extra chars\\n            int currExtra = (mp.count(currStr))? 0 : currStr.size();\\n            int nextExtra = solve(s, mp, dp, cutIdx + 1);\\n            int totalExtra = currExtra + nextExtra;\\n            \\n            minExtra = min(minExtra, totalExtra);\\n        }\\n        return dp[index] = minExtra;\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) \\n    {\\n        vector<int>dp(s.size(), -1);\\n        unordered_map<string, int>mp;\\n        for (string& word : dictionary) mp[word]++;\\n        \\n        int ans = solve(s, mp, dp, 0);\\n        return ans;\\n        \\n    }\\n};\\n```\\n//======================================================================================================================\\n## BOTTOM-UP\\n```\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) \\n    { \\n        int n = s.size();\\n        unordered_map<string, int>mp;\\n        for (string& word : dictionary) mp[word]++;\\n        vector<int>dp(n + 1, 0);\\n        //===================================================================================================\\n        for (int index = n - 1; index >= 0; index--) //index denotes the startIdx of current sub problem string\\n        {\\n            string currStr = \"\";\\n            int minExtra = s.size();\\n            for (int cutIdx = index; cutIdx < n; cutIdx++)\\n            {\\n                currStr.push_back(s[cutIdx]);\\n                //currStr will be a string from (index to cutIdx)\\n\\n                //if string not in dictionary, we have to delete as they are extra chars\\n                int currExtra = (mp.count(currStr))? 0 : currStr.size();\\n                int nextExtra = dp[cutIdx + 1]; \\n                int totalExtra = currExtra + nextExtra;\\n\\n                minExtra = min(minExtra, totalExtra);\\n            }\\n            dp[index] = minExtra;\\n        }\\n        //====================================================================================================\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(string& s, unordered_map<string, int>&mp, int index)\\n    {\\n        if (index >= s.size()) return 0;\\n        \\n        string currStr = \"\";\\n        int minExtra = s.size();\\n        for (int cutIdx = index; cutIdx < s.size(); cutIdx++)\\n        {\\n            currStr.push_back(s[cutIdx]);\\n            //currStr will be a string from (index to cutIdx)\\n            \\n            //if string not in dictionary, we have to delete as they are extra chars\\n            int currExtra = (mp.count(currStr))? 0 : currStr.size();\\n            int nextExtra = solve(s, mp, cutIdx + 1);\\n            int totalExtra = currExtra + nextExtra;\\n            \\n            minExtra = min(minExtra, totalExtra);\\n        }\\n        return minExtra;\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) \\n    {\\n        unordered_map<string, int>mp;\\n        for (string& word : dictionary) mp[word]++;\\n        \\n        int ans = solve(s, mp, 0);\\n        return ans;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(string& s, unordered_map<string, int>&mp, vector<int>&dp, int index)\\n    {\\n        if (index >= s.size()) return 0;\\n        if (dp[index] != -1) return dp[index]; //use the stored results\\n        \\n        string currStr = \"\";\\n        int minExtra = s.size();\\n        for (int cutIdx = index; cutIdx < s.size(); cutIdx++)\\n        {\\n            currStr.push_back(s[cutIdx]);\\n            //currStr will be a string from (index to cutIdx)\\n            \\n            //if string not in dictionary, we have to delete as they are extra chars\\n            int currExtra = (mp.count(currStr))? 0 : currStr.size();\\n            int nextExtra = solve(s, mp, dp, cutIdx + 1);\\n            int totalExtra = currExtra + nextExtra;\\n            \\n            minExtra = min(minExtra, totalExtra);\\n        }\\n        return dp[index] = minExtra;\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) \\n    {\\n        vector<int>dp(s.size(), -1);\\n        unordered_map<string, int>mp;\\n        for (string& word : dictionary) mp[word]++;\\n        \\n        int ans = solve(s, mp, dp, 0);\\n        return ans;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) \\n    { \\n        int n = s.size();\\n        unordered_map<string, int>mp;\\n        for (string& word : dictionary) mp[word]++;\\n        vector<int>dp(n + 1, 0);\\n        //===================================================================================================\\n        for (int index = n - 1; index >= 0; index--) //index denotes the startIdx of current sub problem string\\n        {\\n            string currStr = \"\";\\n            int minExtra = s.size();\\n            for (int cutIdx = index; cutIdx < n; cutIdx++)\\n            {\\n                currStr.push_back(s[cutIdx]);\\n                //currStr will be a string from (index to cutIdx)\\n\\n                //if string not in dictionary, we have to delete as they are extra chars\\n                int currExtra = (mp.count(currStr))? 0 : currStr.size();\\n                int nextExtra = dp[cutIdx + 1]; \\n                int totalExtra = currExtra + nextExtra;\\n\\n                minExtra = min(minExtra, totalExtra);\\n            }\\n            dp[index] = minExtra;\\n        }\\n        //====================================================================================================\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990686,
                "title": "step-by-step-beginner-friendly-full-explanation-dp-efficient-easy-to-understand",
                "content": "\\n# **Problem Statement:**\\nWe are given a **string s and a dictionary of words**. The goal is to **break s** into one or more **non-overlapping substrings** such that each substring is present in the dictionary and **minimize the number of extra characters left over**.\\n\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n**Dynamic Programming Approach:** We can solve this problem using dynamic programming. There are two **common approaches: bottom-up (iterative) and top-down (recursive with memoization)**. Both approaches aim to find the minimum extra characters from the end of the string to the beginning.\\n\\n# Steps-\\n\\n1. **Initialization:** Initialize a **dynamic programming array (dp)** to store the minimum number of extra characters at each position in the string. **Initialize all elements in dp to a maximum value (e.g., -1 or a large number) to indicate that they haven\\'t been calculated yet.**\\n2. **Bottom-Up (Iterative) Approach:**\\n\\n    - **Start iterating** through the string s from **the end (right to left).**\\n    - For **each position i**, initialize dp[i] with a **value of 1 + dp[i + 1]**. This represents breaking the string after the current character and adding one extra character to the minimum extra characters found in the next position.\\n    - **Check for each word in the dictionary** if **it matches** the substring starting from the current position i. **If a match is found**, **update** **dp[i]** **to the minimum between its current value and** **dp[i + w.size()],** where w.size() is the length of the matched word.\\n    - **Continue this process** for all positions in the string s, and the final value of dp[0] will represent the minimum number of extra characters left over.\\n\\n3. **Top-Down (Recursive with Memoization) Approach:**\\n\\n    -** Define a recursive** function that starts from the beginning of the string s and calculates the minimum extra characters.\\n    - **Use an array (dp) to memoize intermediate results** to avoid redundant calculations. Initialize all elements in dp to a special value (e.g., -1) to indicate that they haven\\'t been calculated yet.\\n    - In the recursive function, **if dp[i] is not yet calculated **(equals -1), **calculate it as follows:**\\n        - **a->** Initialize dp[i] **with a value of 1 + minExtraChar(s, dict, i + 1)**, representing breaking the string after the current character and adding one extra character to the minimum extra characters found in the next position.\\n        - **b->** **Check for each word in the dictionary** if it matches the substring starting from the current position i. **If a match is found**, **update dp[i] to the minimum between its current value and 1 + minExtraChar(s, dict, i + w.size())**, where w.size() is the length of the matched word.\\n    - **Return dp[0]**, which represents the minimum extra characters starting from position 0.\\n\\n4. **Result:** **The result of either approach is the minimum number of extra characters left over** when optimally breaking up the string into substrings from the dictionary.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n**Bottom-Up (Iterative) Approach:**\\n\\n- **Time Complexity (TC): O(NML)**, where N is the length of the input string s, M is the number of words in the dictionary, and L is the average length of words in the dictionary.\\n- **Space Complexity (SC): O(N)**, where N is the length of the input string s. We use an array dp of size N to store the minimum extra characters at each position.\\n\\n**Top-Down (Recursive with Memoization) Approach:**\\n\\n- **Time Complexity (TC): O(NML),** where N is the length of the input string s, M is the number of words in the dictionary, and L is the average length of words in the dictionary. This is because each position in the string is visited once for each word in the dictionary.\\n- **Space Complexity (SC): O(N)**, where N is the length of the input string s. We use an array dp of size N for memoization, and the recursive call stack can go up to a depth of N.\\n\\n# SMALL REQUEST : If you found this post even remotely helpful, be kind enough to smash a upvote. I will be grateful.I will be motivated\\uD83D\\uDE0A\\uD83D\\uDE0A\\n\\n---\\n\\n\\n\\n# Code  top-down dynamic programming.\\n```C++ []\\nclass Solution {\\npublic:\\n    int minExtraChar(const string &s, vector<string>& dict) {\\n        memset(dp, -1, sizeof(dp)); // Initialize dp array with -1\\n        \\n        return minExtraCharHelper(s, dict, 0);\\n    }\\n    \\nprivate:\\n    int dp[51]; // Initialize dp array to store memoization values\\n\\n    int minExtraCharHelper(const string &s, vector<string>& dict, int i) {\\n        if (i == s.size())\\n            return 0;\\n\\n        if (dp[i] == -1) {\\n            dp[i] = 1 + minExtraCharHelper(s, dict, i + 1); // Initialize with one extra character.\\n\\n            for (const auto &w : dict) {\\n                if (s.compare(i, w.size(), w) == 0) {\\n                    dp[i] = min(dp[i], minExtraCharHelper(s, dict, i + w.size())); // Update if a word in the dictionary is found.\\n                }\\n            }\\n        }\\n\\n        return dp[i]; // Return the minimum extra characters starting from position i.\\n    }\\n};\\n```\\n```Java []\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    private int[] dp = new int[51]; // Initialize dp array with 0 values\\n\\n    public int minExtraChar(String s, String[] dictionary) {\\n        Arrays.fill(dp, -1); // Initialize dp array with -1 values\\n        return minExtraCharHelper(s, dictionary, 0);\\n    }\\n\\n    private int minExtraCharHelper(String s, String[] dictionary, int i) {\\n        if (i == s.length()) {\\n            return 0;\\n        }\\n\\n        if (dp[i] == -1) {\\n            dp[i] = 1 + minExtraCharHelper(s, dictionary, i + 1); // Initialize with one extra character\\n\\n            for (String w : dictionary) {\\n                if (i + w.length() <= s.length() && s.substring(i, i + w.length()).equals(w)) {\\n                    dp[i] = Math.min(dp[i], minExtraCharHelper(s, dictionary, i + w.length())); // Update if a word in the dictionary is found\\n                }\\n            }\\n        }\\n\\n        return dp[i]; // Return the minimum extra characters starting from position i\\n    }\\n}\\n\\n```\\n```Python3 []\\nclass Solution:\\n    def __init__(self):\\n        self.dp = [-1] * 51  # Initialize dp array with -1 values\\n        \\n    def minExtraChar(self, s, dictionary):\\n        return self.minExtraCharHelper(s, dictionary, 0)\\n    \\n    def minExtraCharHelper(self, s, dictionary, i):\\n        if i == len(s):\\n            return 0\\n\\n        if self.dp[i] == -1:\\n            self.dp[i] = 1 + self.minExtraCharHelper(s, dictionary, i + 1)  # Initialize with one extra character.\\n\\n            for w in dictionary:\\n                if s[i:i+len(w)] == w:\\n                    self.dp[i] = min(self.dp[i], self.minExtraCharHelper(s, dictionary, i + len(w)))  # Update if a word in the dictionary is found.\\n\\n        return self.dp[i]  # Return the minimum extra characters starting from position i\\n\\n```\\n```Javascript   []\\nfunction minExtraChar(s, dictionary) {\\n    const dp = new Array(s.length + 1).fill(-1);\\n\\n    function minExtraCharHelper(i) {\\n        if (i === 0) {\\n            return 0;\\n        }\\n\\n        if (dp[i] !== -1) {\\n            return dp[i];\\n        }\\n\\n        dp[i] = 1 + minExtraCharHelper(i - 1);\\n\\n        for (const w of dictionary) {\\n            if (i >= w.length && s.slice(i - w.length, i) === w) {\\n                dp[i] = Math.min(dp[i], minExtraCharHelper(i - w.length));\\n            }\\n        }\\n\\n        return dp[i];\\n    }\\n\\n    return minExtraCharHelper(s.length);\\n}\\n\\n```\\n---\\n# Code  Bottom-up dynamic programming\\n```C++ []\\nclass Solution {\\npublic:\\n    int minExtraChar( string &s, vector<string>& dictionary) {\\n        int dp[51] = {}; // Initialize an array to store the minimum extra characters.\\n        int n = s.size();\\n        \\n        for (int i = n - 1; i >= 0; --i) {\\n            dp[i] = 1 + dp[i + 1]; // Initialize with one extra character.\\n            \\n            for (const auto &w : dictionary) {\\n                if (i + w.size() <= n && s.compare(i, w.size(), w) == 0) {\\n                    dp[i] = min(dp[i], dp[i + w.size()]); // Update if a word in the dictionaryionary is found.\\n                }\\n            }\\n        }\\n        \\n        return dp[0]; // Return the minimum extra characters for the entire string.\\n    }\\n\\n};\\n\\n```\\n```Java []\\nclass Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        int[] dp = new int[51]; // Initialize an array to store the minimum extra characters.\\n        int n = s.length();\\n\\n        for (int i = n - 1; i >= 0; --i) {\\n            dp[i] = 1 + dp[i + 1]; // Initialize with one extra character.\\n\\n            for (String w : dictionary) {\\n                if (i + w.length() <= n && s.substring(i, i + w.length()).equals(w)) {\\n                    dp[i] = Math.min(dp[i], dp[i + w.length()]); // Update if a word in the dictionary is found.\\n                }\\n            }\\n        }\\n\\n        return dp[0]; // Return the minimum extra characters for the entire string.\\n    }\\n}\\n\\n```\\n```Python3 []\\nclass Solution:\\n    def minExtraChar(self, s, dictionary):\\n        dp = [0] * 51  # Initialize an array to store the minimum extra characters.\\n        n = len(s)\\n\\n        for i in range(n - 1, -1, -1):\\n            dp[i] = 1 + dp[i + 1]  # Initialize with one extra character.\\n\\n            for w in dictionary:\\n                if i + len(w) <= n and s[i:i + len(w)] == w:\\n                    dp[i] = min(dp[i], dp[i + len(w)])  # Update if a word in the dictionary is found.\\n\\n        return dp[0]  # Return the minimum extra characters for the entire string.\\n\\n```\\n```Javascript []\\nfunction minExtraChar(s, dictionary) {\\n    const dp = new Array(s.length + 1).fill(Infinity);\\n    dp[0] = 0;\\n\\n    for (let i = 0; i <= s.length; i++) {\\n        for (const w of dictionary) {\\n            if (i + w.length <= s.length && s.slice(i, i + w.length) === w) {\\n                dp[i + w.length] = Math.min(dp[i + w.length], dp[i]);\\n            }\\n        }\\n        dp[i + 1] = Math.min(dp[i + 1], dp[i] + 1);\\n    }\\n\\n    return dp[s.length];\\n}\\n\\n\\n\\n```\\n\\n---\\n# SMALL REQUEST : If you found this post even remotely helpful, be kind enough to smash a upvote. I will be grateful.I will be motivated\\uD83D\\uDE0A\\uD83D\\uDE0A\\n![UPVOTE.png](https://assets.leetcode.com/users/images/e3965db1-2e8e-4ada-bb45-36b1d822fa52_1693627504.4490802.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int minExtraChar(const string &s, vector<string>& dict) {\\n        memset(dp, -1, sizeof(dp)); // Initialize dp array with -1\\n        \\n        return minExtraCharHelper(s, dict, 0);\\n    }\\n    \\nprivate:\\n    int dp[51]; // Initialize dp array to store memoization values\\n\\n    int minExtraCharHelper(const string &s, vector<string>& dict, int i) {\\n        if (i == s.size())\\n            return 0;\\n\\n        if (dp[i] == -1) {\\n            dp[i] = 1 + minExtraCharHelper(s, dict, i + 1); // Initialize with one extra character.\\n\\n            for (const auto &w : dict) {\\n                if (s.compare(i, w.size(), w) == 0) {\\n                    dp[i] = min(dp[i], minExtraCharHelper(s, dict, i + w.size())); // Update if a word in the dictionary is found.\\n                }\\n            }\\n        }\\n\\n        return dp[i]; // Return the minimum extra characters starting from position i.\\n    }\\n};\\n```\n```Java []\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    private int[] dp = new int[51]; // Initialize dp array with 0 values\\n\\n    public int minExtraChar(String s, String[] dictionary) {\\n        Arrays.fill(dp, -1); // Initialize dp array with -1 values\\n        return minExtraCharHelper(s, dictionary, 0);\\n    }\\n\\n    private int minExtraCharHelper(String s, String[] dictionary, int i) {\\n        if (i == s.length()) {\\n            return 0;\\n        }\\n\\n        if (dp[i] == -1) {\\n            dp[i] = 1 + minExtraCharHelper(s, dictionary, i + 1); // Initialize with one extra character\\n\\n            for (String w : dictionary) {\\n                if (i + w.length() <= s.length() && s.substring(i, i + w.length()).equals(w)) {\\n                    dp[i] = Math.min(dp[i], minExtraCharHelper(s, dictionary, i + w.length())); // Update if a word in the dictionary is found\\n                }\\n            }\\n        }\\n\\n        return dp[i]; // Return the minimum extra characters starting from position i\\n    }\\n}\\n\\n```\n```Python3 []\\nclass Solution:\\n    def __init__(self):\\n        self.dp = [-1] * 51  # Initialize dp array with -1 values\\n        \\n    def minExtraChar(self, s, dictionary):\\n        return self.minExtraCharHelper(s, dictionary, 0)\\n    \\n    def minExtraCharHelper(self, s, dictionary, i):\\n        if i == len(s):\\n            return 0\\n\\n        if self.dp[i] == -1:\\n            self.dp[i] = 1 + self.minExtraCharHelper(s, dictionary, i + 1)  # Initialize with one extra character.\\n\\n            for w in dictionary:\\n                if s[i:i+len(w)] == w:\\n                    self.dp[i] = min(self.dp[i], self.minExtraCharHelper(s, dictionary, i + len(w)))  # Update if a word in the dictionary is found.\\n\\n        return self.dp[i]  # Return the minimum extra characters starting from position i\\n\\n```\n```Javascript   []\\nfunction minExtraChar(s, dictionary) {\\n    const dp = new Array(s.length + 1).fill(-1);\\n\\n    function minExtraCharHelper(i) {\\n        if (i === 0) {\\n            return 0;\\n        }\\n\\n        if (dp[i] !== -1) {\\n            return dp[i];\\n        }\\n\\n        dp[i] = 1 + minExtraCharHelper(i - 1);\\n\\n        for (const w of dictionary) {\\n            if (i >= w.length && s.slice(i - w.length, i) === w) {\\n                dp[i] = Math.min(dp[i], minExtraCharHelper(i - w.length));\\n            }\\n        }\\n\\n        return dp[i];\\n    }\\n\\n    return minExtraCharHelper(s.length);\\n}\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int minExtraChar( string &s, vector<string>& dictionary) {\\n        int dp[51] = {}; // Initialize an array to store the minimum extra characters.\\n        int n = s.size();\\n        \\n        for (int i = n - 1; i >= 0; --i) {\\n            dp[i] = 1 + dp[i + 1]; // Initialize with one extra character.\\n            \\n            for (const auto &w : dictionary) {\\n                if (i + w.size() <= n && s.compare(i, w.size(), w) == 0) {\\n                    dp[i] = min(dp[i], dp[i + w.size()]); // Update if a word in the dictionaryionary is found.\\n                }\\n            }\\n        }\\n        \\n        return dp[0]; // Return the minimum extra characters for the entire string.\\n    }\\n\\n};\\n\\n```\n```Java []\\nclass Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        int[] dp = new int[51]; // Initialize an array to store the minimum extra characters.\\n        int n = s.length();\\n\\n        for (int i = n - 1; i >= 0; --i) {\\n            dp[i] = 1 + dp[i + 1]; // Initialize with one extra character.\\n\\n            for (String w : dictionary) {\\n                if (i + w.length() <= n && s.substring(i, i + w.length()).equals(w)) {\\n                    dp[i] = Math.min(dp[i], dp[i + w.length()]); // Update if a word in the dictionary is found.\\n                }\\n            }\\n        }\\n\\n        return dp[0]; // Return the minimum extra characters for the entire string.\\n    }\\n}\\n\\n```\n```Python3 []\\nclass Solution:\\n    def minExtraChar(self, s, dictionary):\\n        dp = [0] * 51  # Initialize an array to store the minimum extra characters.\\n        n = len(s)\\n\\n        for i in range(n - 1, -1, -1):\\n            dp[i] = 1 + dp[i + 1]  # Initialize with one extra character.\\n\\n            for w in dictionary:\\n                if i + len(w) <= n and s[i:i + len(w)] == w:\\n                    dp[i] = min(dp[i], dp[i + len(w)])  # Update if a word in the dictionary is found.\\n\\n        return dp[0]  # Return the minimum extra characters for the entire string.\\n\\n```\n```Javascript []\\nfunction minExtraChar(s, dictionary) {\\n    const dp = new Array(s.length + 1).fill(Infinity);\\n    dp[0] = 0;\\n\\n    for (let i = 0; i <= s.length; i++) {\\n        for (const w of dictionary) {\\n            if (i + w.length <= s.length && s.slice(i, i + w.length) === w) {\\n                dp[i + w.length] = Math.min(dp[i + w.length], dp[i]);\\n            }\\n        }\\n        dp[i + 1] = Math.min(dp[i + 1], dp[i] + 1);\\n    }\\n\\n    return dp[s.length];\\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990359,
                "title": "96-3-easy-dp-trie",
                "content": "# Interview Guide - Finding the Minimum Extra Characters in a String\\n## Problem Understanding\\n\\nThe problem presents us with a string `s` and a dictionary of words. The challenge is to break `s` into one or more non-overlapping substrings such that each substring is present in the dictionary. However, there may be some extra characters in `s` which are not present in any of the substrings. The goal is to find the minimum number of such extra characters.\\n\\n### Key Points to Consider\\n\\n1. **Understand the Constraints**:  \\n   String length: `1 <= |s| <= 50`  \\n   Dictionary size: `1 <= |dictionary| <= 50`  \\n   Dictionary word length: `1 <= |dictionary[i]| <= 50`\\n\\n2. **String Manipulation and Substring Matching**:  \\n   This problem is essentially about efficiently handling strings and substrings. You need to consider all possible substrings of `s` and check if they are present in the dictionary.\\n\\n3. **Dynamic Programming Approach**:  \\n   This problem can be efficiently solved using Dynamic Programming. We will define `dp[i]` as the minimum number of extra characters when considering the string `s[0:i]`.\\n\\n## Live Coding & More\\nhttps://youtu.be/nEjvcsqqONs?si=sR5DNI-P2HOXA2Xp\\n\\n## Solution #1: Dynamic Programming \\n\\n### Intuition and Logic Behind the Solution\\n\\nThe idea here is to use the Dynamic Programming array `dp` to store the minimum number of extra characters needed when the string is broken up optimally up to index `i`.\\n\\n### Step-by-step Explanation\\n\\n1. **Initialization**: Create an array `dp` of length `|s| + 1`, initialized with a large value (larger than the maximum possible extra characters). Set `dp[0] = 0`.\\n  \\n2. **Main Algorithm**:  \\n   - Iterate through the string from `1` to `|s|`.\\n   - For each `i`, set `dp[i] = dp[i-1] + 1` as a worst-case scenario.\\n   - Update `dp[i]` based on substrings of `s` ending at `i` that are in the dictionary. Use `dp[i - len(substring)]` for this.\\n\\n### Complexity Analysis\\n\\n- **Time Complexity**: $$ O(n^2) $$ \\u2014 We iterate through the string and for each character, we consider all substrings ending at that character.\\n- **Space Complexity**: $$ O(n) $$ \\u2014 For the DP array.\\n\\n---\\n\\n### Solution #2: Dynamic Programming with Trie: Explained\\n\\n#### Intuition\\n\\nThe key to speeding up the solution is avoiding the creation of substrings. We achieve this by using a Trie data structure, which allows us to check if a substring exists in the dictionary without actually creating it.\\n\\n#### Algorithm\\n\\n1. **Define a TrieNode Class**:  \\n   Each node in the Trie represents a character and has a dictionary of children and a flag indicating whether it\\'s the end of a word.\\n\\n2. **Building the Trie**:  \\n   The Trie is built from the given dictionary. Each word in the dictionary is inserted into the Trie character by character.\\n\\n3. **Initialize DP Array**:  \\n   We use an array `dp` where `dp[i]` represents the minimum number of extra characters needed for the substring `s[i:]`.\\n\\n4. **Fill DP Array**:  \\n   - Iterate through the string `s` from right to left.\\n   - For each index `start`, initialize `dp[start] = dp[start + 1] + 1` as the base case.\\n   - Traverse the Trie to find substrings that start at the index `start` and update `dp[start]` accordingly.\\n\\n#### Complexity Analysis\\n\\n- **Time Complexity**: $$O(n \\\\times m)$$  \\n  $$n$$ is the length of the string `s`, and $$m$$ is the maximum length of a word in the dictionary. This complexity is because we traverse the Trie for each starting index in `s`.\\n\\n- **Space Complexity**: $$O(n + k)$$  \\n  $$n$$ is the length of the string `s`, and $$k$$ is the total number of characters in the Trie (dictionary).\\n\\n---\\n\\n# Performance\\n\\n| Language   | Execution Time (ms) | Memory Usage |\\n|------------|---------------------|--------------|\\n| Go         | 24                  | 8 MB         |\\n| Rust       | 35                  | 2.2 MB       |\\n| Java       | 42                  | 44.4 MB      |\\n| PHP        | 71                  | 19.1 MB      |\\n| C#         | 121                 | 99.8 MB      |\\n| JavaScript | 143                 | 51.3 MB      |\\n| C++        | 152                 | 82.3 MB      |\\n| Python3 (Trie)   | 179                 | 17.4 MB      |\\n| Python3 (DP)   | 209                 | 16.5 MB      |\\n\\n![s2.png](https://assets.leetcode.com/users/images/6090928e-458f-462c-8f17-04b09a0e194a_1693617443.1233141.png)\\n\\n\\n# Code #1\\n``` Python []\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        max_val = len(s) + 1\\n        dp = [max_val] * (len(s) + 1)\\n        dp[0] = 0 \\n        dictionary_set = set(dictionary)\\n\\n        for i in range(1, len(s) + 1):\\n            dp[i] = dp[i - 1] + 1\\n\\n            for l in range(1, i + 1): \\n                if s[i-l:i] in dictionary_set:\\n                    dp[i] = min(dp[i], dp[i-l])\\n                    \\n        return dp[-1]\\n```\\n``` Rust []\\n\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn min_extra_char(s: String, dictionary: Vec<String>) -> i32 {\\n        let max_val = s.len() as i32 + 1;\\n        let mut dp = vec![max_val; s.len() + 1];\\n        dp[0] = 0;\\n\\n        let dictionary_set: HashSet<_> = dictionary.into_iter().collect();\\n\\n        for i in 1..=s.len() {\\n            dp[i] = dp[i - 1] + 1;\\n            for l in 1..=i {\\n                if dictionary_set.contains(&s[i-l..i].to_string()) {\\n                    dp[i] = std::cmp::min(dp[i], dp[i-l]);\\n                }\\n            }\\n        }\\n        dp[s.len()] as i32\\n    }\\n}\\n```\\n``` Go []\\nfunc minExtraChar(s string, dictionary []string) int {\\n\\tmaxVal := len(s) + 1\\n\\tdp := make([]int, len(s)+1)\\n\\tfor i := range dp {\\n\\t\\tdp[i] = maxVal\\n\\t}\\n\\tdp[0] = 0\\n\\n\\tdictionarySet := make(map[string]bool)\\n\\tfor _, word := range dictionary {\\n\\t\\tdictionarySet[word] = true\\n\\t}\\n\\n\\tfor i := 1; i <= len(s); i++ {\\n\\t\\tdp[i] = dp[i-1] + 1\\n\\t\\tfor l := 1; l <= i; l++ {\\n\\t\\t\\tif dictionarySet[s[i-l:i]] {\\n\\t\\t\\t\\tdp[i] = int(math.Min(float64(dp[i]), float64(dp[i-l])))\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[len(s)]\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        int max_val = s.length() + 1;\\n        vector<int> dp(s.length() + 1, max_val);\\n        dp[0] = 0;\\n\\n        unordered_set<string> dictionary_set(dictionary.begin(), dictionary.end());\\n\\n        for (int i = 1; i <= s.length(); ++i) {\\n            dp[i] = dp[i - 1] + 1;\\n            for (int l = 1; l <= i; ++l) {\\n                if (dictionary_set.find(s.substr(i - l, l)) != dictionary_set.end()) {\\n                    dp[i] = min(dp[i], dp[i - l]);\\n                }\\n            }\\n        }\\n        return dp.back();\\n    }\\n};\\n```\\n``` Java []\\nclass Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        int maxVal = s.length() + 1;\\n        int[] dp = new int[s.length() + 1];\\n        Arrays.fill(dp, maxVal);\\n        dp[0] = 0;\\n\\n        Set<String> dictionarySet = new HashSet<>(Arrays.asList(dictionary));\\n\\n        for (int i = 1; i <= s.length(); ++i) {\\n            dp[i] = dp[i - 1] + 1;\\n            for (int l = 1; l <= i; ++l) {\\n                if (dictionarySet.contains(s.substring(i - l, i))) {\\n                    dp[i] = Math.min(dp[i], dp[i - l]);\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public int MinExtraChar(string s, string[] dictionary) {\\n        int maxVal = s.Length + 1;\\n        int[] dp = new int[s.Length + 1];\\n        Array.Fill(dp, maxVal);\\n        dp[0] = 0;\\n\\n        HashSet<string> dictionarySet = new HashSet<string>(dictionary);\\n\\n        for (int i = 1; i <= s.Length; ++i) {\\n            dp[i] = dp[i - 1] + 1;\\n            for (int l = 1; l <= i; ++l) {\\n                if (dictionarySet.Contains(s.Substring(i - l, l))) {\\n                    dp[i] = Math.Min(dp[i], dp[i - l]);\\n                }\\n            }\\n        }\\n        return dp[s.Length];\\n    }\\n}\\n```\\n``` PHP []\\nclass Solution {\\n    function minExtraChar($s, $dictionary) {\\n        $maxVal = strlen($s) + 1;\\n        $dp = array_fill(0, strlen($s) + 1, $maxVal);\\n        $dp[0] = 0;\\n\\n        $dictionarySet = array_flip($dictionary);\\n\\n        for ($i = 1; $i <= strlen($s); ++$i) {\\n            $dp[$i] = $dp[$i - 1] + 1;\\n            for ($l = 1; $l <= $i; ++$l) {\\n                if (isset($dictionarySet[substr($s, $i - $l, $l)])) {\\n                    $dp[$i] = min($dp[$i], $dp[$i - $l]);\\n                }\\n            }\\n        }\\n        return $dp[strlen($s)];\\n    }\\n}\\n```\\n``` JAvaScript []\\n/**\\n * @param {string} s\\n * @param {string[]} dictionary\\n * @return {number}\\n */\\nvar minExtraChar = function(s, dictionary) {\\n    const maxVal = s.length + 1;\\n    const dp = Array(s.length + 1).fill(maxVal);\\n    dp[0] = 0;\\n\\n    const dictionarySet = new Set(dictionary);\\n\\n    for (let i = 1; i <= s.length; ++i) {\\n        dp[i] = dp[i - 1] + 1;\\n        for (let l = 1; l <= i; ++l) {\\n            if (dictionarySet.has(s.substring(i - l, i))) {\\n                dp[i] = Math.min(dp[i], dp[i - l]);\\n            }\\n        }\\n    }\\n    return dp[s.length];\\n}\\n```\\n# Code #2\\n``` Python []\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.is_word = False\\n\\ndef buildTrie(dictionary):\\n    root = TrieNode()\\n    for word in dictionary:\\n        node = root\\n        for ch in word:\\n            if ch not in node.children:\\n                node.children[ch] = TrieNode()\\n            node = node.children[ch]\\n        node.is_word = True\\n    return root\\n\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        root = buildTrie(dictionary)\\n        n = len(s)\\n        dp = [float(\\'inf\\')] * (n + 1)\\n        dp[-1] = 0  # No extra character for an empty string\\n\\n        for start in reversed(range(n)):\\n            dp[start] = dp[start + 1] + 1  # Initialize with worst-case scenario\\n            node = root\\n            for end in range(start, n):\\n                if s[end] not in node.children:\\n                    break\\n                node = node.children[s[end]]\\n                if node.is_word:\\n                    dp[start] = min(dp[start], dp[end + 1])\\n        \\n        return dp[0]\\n```\\n\\nConquering this problem is an exploration into the nuances of Dynamic Programming and String Manipulation. From efficiently handling substrings to using DP for optimization, each aspect of the solution serves as a lesson in strategic problem-solving. So dive in, bring your creativity to the table, and elevate your coding skills. This is more than just solving a problem; it\\'s a vital step in your journey towards mastering algorithms and data structures. \\uD83D\\uDE80\\uD83D\\uDC69\\u200D\\uD83D\\uDCBB\\u2728",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "PHP",
                    "Dynamic Programming",
                    "Trie"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        max_val = len(s) + 1\\n        dp = [max_val] * (len(s) + 1)\\n        dp[0] = 0 \\n        dictionary_set = set(dictionary)\\n\\n        for i in range(1, len(s) + 1):\\n            dp[i] = dp[i - 1] + 1\\n\\n            for l in range(1, i + 1): \\n                if s[i-l:i] in dictionary_set:\\n                    dp[i] = min(dp[i], dp[i-l])\\n                    \\n        return dp[-1]\\n```\n``` Rust []\\n\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn min_extra_char(s: String, dictionary: Vec<String>) -> i32 {\\n        let max_val = s.len() as i32 + 1;\\n        let mut dp = vec![max_val; s.len() + 1];\\n        dp[0] = 0;\\n\\n        let dictionary_set: HashSet<_> = dictionary.into_iter().collect();\\n\\n        for i in 1..=s.len() {\\n            dp[i] = dp[i - 1] + 1;\\n            for l in 1..=i {\\n                if dictionary_set.contains(&s[i-l..i].to_string()) {\\n                    dp[i] = std::cmp::min(dp[i], dp[i-l]);\\n                }\\n            }\\n        }\\n        dp[s.len()] as i32\\n    }\\n}\\n```\n``` Go []\\nfunc minExtraChar(s string, dictionary []string) int {\\n\\tmaxVal := len(s) + 1\\n\\tdp := make([]int, len(s)+1)\\n\\tfor i := range dp {\\n\\t\\tdp[i] = maxVal\\n\\t}\\n\\tdp[0] = 0\\n\\n\\tdictionarySet := make(map[string]bool)\\n\\tfor _, word := range dictionary {\\n\\t\\tdictionarySet[word] = true\\n\\t}\\n\\n\\tfor i := 1; i <= len(s); i++ {\\n\\t\\tdp[i] = dp[i-1] + 1\\n\\t\\tfor l := 1; l <= i; l++ {\\n\\t\\t\\tif dictionarySet[s[i-l:i]] {\\n\\t\\t\\t\\tdp[i] = int(math.Min(float64(dp[i]), float64(dp[i-l])))\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[len(s)]\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        int max_val = s.length() + 1;\\n        vector<int> dp(s.length() + 1, max_val);\\n        dp[0] = 0;\\n\\n        unordered_set<string> dictionary_set(dictionary.begin(), dictionary.end());\\n\\n        for (int i = 1; i <= s.length(); ++i) {\\n            dp[i] = dp[i - 1] + 1;\\n            for (int l = 1; l <= i; ++l) {\\n                if (dictionary_set.find(s.substr(i - l, l)) != dictionary_set.end()) {\\n                    dp[i] = min(dp[i], dp[i - l]);\\n                }\\n            }\\n        }\\n        return dp.back();\\n    }\\n};\\n```\n``` Java []\\nclass Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        int maxVal = s.length() + 1;\\n        int[] dp = new int[s.length() + 1];\\n        Arrays.fill(dp, maxVal);\\n        dp[0] = 0;\\n\\n        Set<String> dictionarySet = new HashSet<>(Arrays.asList(dictionary));\\n\\n        for (int i = 1; i <= s.length(); ++i) {\\n            dp[i] = dp[i - 1] + 1;\\n            for (int l = 1; l <= i; ++l) {\\n                if (dictionarySet.contains(s.substring(i - l, i))) {\\n                    dp[i] = Math.min(dp[i], dp[i - l]);\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public int MinExtraChar(string s, string[] dictionary) {\\n        int maxVal = s.Length + 1;\\n        int[] dp = new int[s.Length + 1];\\n        Array.Fill(dp, maxVal);\\n        dp[0] = 0;\\n\\n        HashSet<string> dictionarySet = new HashSet<string>(dictionary);\\n\\n        for (int i = 1; i <= s.Length; ++i) {\\n            dp[i] = dp[i - 1] + 1;\\n            for (int l = 1; l <= i; ++l) {\\n                if (dictionarySet.Contains(s.Substring(i - l, l))) {\\n                    dp[i] = Math.Min(dp[i], dp[i - l]);\\n                }\\n            }\\n        }\\n        return dp[s.Length];\\n    }\\n}\\n```\n``` PHP []\\nclass Solution {\\n    function minExtraChar($s, $dictionary) {\\n        $maxVal = strlen($s) + 1;\\n        $dp = array_fill(0, strlen($s) + 1, $maxVal);\\n        $dp[0] = 0;\\n\\n        $dictionarySet = array_flip($dictionary);\\n\\n        for ($i = 1; $i <= strlen($s); ++$i) {\\n            $dp[$i] = $dp[$i - 1] + 1;\\n            for ($l = 1; $l <= $i; ++$l) {\\n                if (isset($dictionarySet[substr($s, $i - $l, $l)])) {\\n                    $dp[$i] = min($dp[$i], $dp[$i - $l]);\\n                }\\n            }\\n        }\\n        return $dp[strlen($s)];\\n    }\\n}\\n```\n``` JAvaScript []\\n/**\\n * @param {string} s\\n * @param {string[]} dictionary\\n * @return {number}\\n */\\nvar minExtraChar = function(s, dictionary) {\\n    const maxVal = s.length + 1;\\n    const dp = Array(s.length + 1).fill(maxVal);\\n    dp[0] = 0;\\n\\n    const dictionarySet = new Set(dictionary);\\n\\n    for (let i = 1; i <= s.length; ++i) {\\n        dp[i] = dp[i - 1] + 1;\\n        for (let l = 1; l <= i; ++l) {\\n            if (dictionarySet.has(s.substring(i - l, i))) {\\n                dp[i] = Math.min(dp[i], dp[i - l]);\\n            }\\n        }\\n    }\\n    return dp[s.length];\\n}\\n```\n``` Python []\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.is_word = False\\n\\ndef buildTrie(dictionary):\\n    root = TrieNode()\\n    for word in dictionary:\\n        node = root\\n        for ch in word:\\n            if ch not in node.children:\\n                node.children[ch] = TrieNode()\\n            node = node.children[ch]\\n        node.is_word = True\\n    return root\\n\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        root = buildTrie(dictionary)\\n        n = len(s)\\n        dp = [float(\\'inf\\')] * (n + 1)\\n        dp[-1] = 0  # No extra character for an empty string\\n\\n        for start in reversed(range(n)):\\n            dp[start] = dp[start + 1] + 1  # Initialize with worst-case scenario\\n            node = root\\n            for end in range(start, n):\\n                if s[end] not in node.children:\\n                    break\\n                node = node.children[s[end]]\\n                if node.is_word:\\n                    dp[start] = min(dp[start], dp[end + 1])\\n        \\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568575,
                "title": "recursion-with-memorisation-very-simple-easy-to-understand-solution",
                "content": "<b> Up vote if you like the solution</b>\\n\\n# Approach \\nSimply we take each sub string and check if it is present in the dictionary or not. If present then move the index to ind + ith one do the recursion.\\n\\nAlso we need to skip one elemnet and again do the check. This add up 1 to our value as we are considering that we are leaving the value.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_set<string> st;\\n    vector<int> mem;\\n\\n    int solve(string& s, int ind){ \\n        if(ind >= s.size()) return 0;\\n        if(mem[ind] != -1) return mem[ind];\\n        int res = 1 + solve(s, ind + 1);   //skip one element with vlaue 1 added to result\\n        for(int i = 1; ind + i <= s.size(); ++i){ //check if any of the chars can be skiped without any value returned \\n            string t = s.substr(ind, i);\\n            if(st.find(t) != st.end()) res = min(res, solve(s, ind+i));\\n        }\\n        return mem[ind] = res;\\n    }\\n\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        mem.resize(s.size() + 1, -1);\\n        for(auto d: dictionary ) st.insert(d);\\n        return solve(s, 0);\\n    }\\n};\\n```\\n\\n<b> Here is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_set<string> st;\\n    vector<int> mem;\\n\\n    int solve(string& s, int ind){ \\n        if(ind >= s.size()) return 0;\\n        if(mem[ind] != -1) return mem[ind];\\n        int res = 1 + solve(s, ind + 1);   //skip one element with vlaue 1 added to result\\n        for(int i = 1; ind + i <= s.size(); ++i){ //check if any of the chars can be skiped without any value returned \\n            string t = s.substr(ind, i);\\n            if(st.find(t) != st.end()) res = min(res, solve(s, ind+i));\\n        }\\n        return mem[ind] = res;\\n    }\\n\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        mem.resize(s.size() + 1, -1);\\n        for(auto d: dictionary ) st.insert(d);\\n        return solve(s, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568669,
                "title": "simple-dp-solution-c-very-simple-easy-to-understand-solution",
                "content": "# Intuition\\nThe main idea is to use an array dp of size n+1, where n is the length of the input string s. The value of dp[i] represents the minimum number of extra characters left over if we break up the substring s[i..n-1] optimally.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        set<string> str;\\n        int n1 = s.size();\\n        int n2 = dictionary.size();\\n        for(int i=0;i<n2;i++)\\n        {\\n            str.insert(dictionary[i]);\\n        }\\n        vector<int> dp(n1+1,0);\\n        //0 1 2 3 4 5 6\\n        for(int i=1;i<=n1;i++)\\n        {\\n            dp[i] = dp[i-1]+1;\\n            for(int j=i;j>=1;j--)\\n            {\\n            string temp = s.substr(j-1,i-j+1);\\n                if(str.count(temp))\\n                {\\n                    dp[i] = min(dp[i],dp[j-1]);\\n                }\\n            }\\n        }\\n        return dp[n1];\\n    }\\n};\\n```\\n![upvote.jpeg](https://assets.leetcode.com/users/images/f2fd7213-5800-4e5f-8467-5393aa20db5c_1685203544.1991982.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        set<string> str;\\n        int n1 = s.size();\\n        int n2 = dictionary.size();\\n        for(int i=0;i<n2;i++)\\n        {\\n            str.insert(dictionary[i]);\\n        }\\n        vector<int> dp(n1+1,0);\\n        //0 1 2 3 4 5 6\\n        for(int i=1;i<=n1;i++)\\n        {\\n            dp[i] = dp[i-1]+1;\\n            for(int j=i;j>=1;j--)\\n            {\\n            string temp = s.substr(j-1,i-j+1);\\n                if(str.count(temp))\\n                {\\n                    dp[i] = min(dp[i],dp[j-1]);\\n                }\\n            }\\n        }\\n        return dp[n1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990356,
                "title": "c-dp-recursion-memoization",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    map<string,int>m;\\n    int c(int i,string &s,vector<int>&dp){\\n        if(i>=s.size())return 0;\\n        int ans=INT_MAX;\\n        if(dp[i]!=-1)return dp[i];\\n        ans = 1 + c(i+1,s,dp);\\n        string k=\"\";\\n        for(int j=i;j<s.size();j++){\\n            k+= s[j];\\n            if(m[k]){\\n                ans=min(ans,c(j+1,s,dp));\\n            }\\n        }\\n        return dp[i]=ans;\\n    }\\n    int minExtraChar(string s, vector<string>& d) {\\n        for(auto i : d)m[i]++;\\n        vector<int>dp(s.size(),-1);\\n        return c(0,s,dp);\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/ba6c2b59-c445-489b-bae4-9bd38865bbc8_1693613706.3674912.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<string,int>m;\\n    int c(int i,string &s,vector<int>&dp){\\n        if(i>=s.size())return 0;\\n        int ans=INT_MAX;\\n        if(dp[i]!=-1)return dp[i];\\n        ans = 1 + c(i+1,s,dp);\\n        string k=\"\";\\n        for(int j=i;j<s.size();j++){\\n            k+= s[j];\\n            if(m[k]){\\n                ans=min(ans,c(j+1,s,dp));\\n            }\\n        }\\n        return dp[i]=ans;\\n    }\\n    int minExtraChar(string s, vector<string>& d) {\\n        for(auto i : d)m[i]++;\\n        vector<int>dp(s.size(),-1);\\n        return c(0,s,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990853,
                "title": "beginner-friendly-easy-solution-dp-beats-100-line-by-line-explanation",
                "content": "![image.png](https://assets.leetcode.com/users/images/a2369537-e160-49ea-a79a-c3578dcff73c_1693632790.9550076.png)\\n\\n# Intuition\\n**The problem requires breaking a given string s into non-overlapping substrings such that each substring is present in a given dictionary. The goal is to minimize the number of extra characters left over after breaking the string optimally.**\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize a defaultdict word_dict to store words from the dictionary grouped by their first characters. This helps in efficient lookup during string traversal.\\n2. Initialize a list result of length n+1 where n is the length of the input string s. This list will store the minimum number of extra characters left at each position in the string.\\n3. Iterate through the string s from right to left (starting from the end).\\n4. For each position i in the string s, calculate the minimum number of extra characters left if we break the string optimally at this position.\\n5. If the current character s[i] is found in the word_dict, iterate through the words that start with s[i] and check if they match the substring starting at position i. If a match is found, update result[i] with the minimum of its current value and result[i + len(word)], where word is the matching word.\\n6. Finally, return result[0], which represents the minimum number of extra characters left when breaking the string optimally.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n\\n- Time complexity: $$O(n*m)$$, \\n- where n is the length of the input string s, and m is the average length of words in the dictionary. In the worst case, we iterate through the string once and perform string slicing operations that can take O(m) time.\\n- Space complexity: $$O(n)$$ for the result list and $$O(m)$$ for the word_dict where m is the number of words in the dictionary.\\n\\n# Code\\n```\\n\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        # Get the length of the input string \\'s\\'\\n        n = len(s)\\n        \\n        # Create a defaultdict \\'word_dict\\' to store words grouped by their first characters\\n        word_dict = defaultdict(list)\\n        \\n        # Populate \\'word_dict\\' with words from the \\'dictionary\\' list\\n        for word in dictionary:\\n            word_dict[word[0]].append(word)\\n            \\n        # Initialize a list \\'result\\' of length \\'n+1\\' to store minimum extra characters at each position\\n        result = [0] * (n + 1)\\n        \\n        # Iterate through the string \\'s\\' from right to left\\n        for i in range(n - 1, -1, -1):\\n            # Initialize the current position in \\'result\\' with one more extra character than the next position\\n            result[i] = result[i + 1] + 1\\n            \\n            # Check if the current character \\'s[i]\\' is found in \\'word_dict\\'\\n            if s[i] in word_dict:\\n                # Iterate through the words that start with \\'s[i]\\'\\n                for word in word_dict[s[i]]:\\n                    # Check if the substring starting at position \\'i\\' matches the current word\\n                    if s[i:i + len(word)] == word:\\n                        # Update \\'result[i]\\' with the minimum of its current value and \\'result[i + len(word)]\\'\\n                        result[i] = min(result[i], result[i + len(word)])\\n                        \\n        # Return the minimum number of extra characters left when breaking the string optimally\\n        return result[0]\\n#uncomment all the comments to save the memory\\n#Please Upvote if u like\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Trie"
                ],
                "code": "```\\n\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        # Get the length of the input string \\'s\\'\\n        n = len(s)\\n        \\n        # Create a defaultdict \\'word_dict\\' to store words grouped by their first characters\\n        word_dict = defaultdict(list)\\n        \\n        # Populate \\'word_dict\\' with words from the \\'dictionary\\' list\\n        for word in dictionary:\\n            word_dict[word[0]].append(word)\\n            \\n        # Initialize a list \\'result\\' of length \\'n+1\\' to store minimum extra characters at each position\\n        result = [0] * (n + 1)\\n        \\n        # Iterate through the string \\'s\\' from right to left\\n        for i in range(n - 1, -1, -1):\\n            # Initialize the current position in \\'result\\' with one more extra character than the next position\\n            result[i] = result[i + 1] + 1\\n            \\n            # Check if the current character \\'s[i]\\' is found in \\'word_dict\\'\\n            if s[i] in word_dict:\\n                # Iterate through the words that start with \\'s[i]\\'\\n                for word in word_dict[s[i]]:\\n                    # Check if the substring starting at position \\'i\\' matches the current word\\n                    if s[i:i + len(word)] == word:\\n                        # Update \\'result[i]\\' with the minimum of its current value and \\'result[i + len(word)]\\'\\n                        result[i] = min(result[i], result[i + len(word)])\\n                        \\n        # Return the minimum number of extra characters left when breaking the string optimally\\n        return result[0]\\n#uncomment all the comments to save the memory\\n#Please Upvote if u like\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990757,
                "title": "video-dynamic-programming-and-trie-solution-with-python-javascript-java-and-c",
                "content": "\\n# Solution Video\\n\\n### In the video, the steps of approach below are visualized using diagrams and drawings. I\\'m sure you understand the solution easily!\\n\\nhttps://youtu.be/UKaXF_iV4qE\\n\\n### \\u2B50\\uFE0F Don\\'t forget to subscribe to my channel! I have 253 videos as of September 1st, 2023.\\n\\n**\\u25A0 Subscribe URL**\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\n---\\n\\n# Approach\\nThis is based on Python. Other might be different a bit.\\n\\nThe most important idea to solve this question is dynamic programming with the goal of finding the minimum number of extra characters needed to form the given string s using words from a dictionary. Dynamic programming allows you to efficiently explore and compute the minimum extra characters needed for each substring of s while considering previously computed values.\\n\\n\\n**1. Initialization**\\n   - Set `max_len` to the length of the input string `s` plus 1. This represents the maximum length of a valid substring.\\n   - Create an array `dp` of size `max_len`, initializing all elements to `max_len`. This array will store the minimum extra characters needed for substrings.\\n   - Set `dp[0]` to 0, indicating that no extra characters are needed for an empty string.\\n   - Create a set called `word_set` to efficiently look up words from the `dictionary`.\\n\\n**2. Dynamic Programming Loop (Outer Loop)**\\n   - Iterate `i` from 1 to `max_len - 1`, representing the current position in the string `s`.\\n   - Set `dp[i]` to `dp[i - 1] + 1`, initializing it with a worst-case scenario (one more character than the previous position).\\n\\n**3. Substring Check Loop (Inner Loop)**\\n   - For each `i`, iterate `length` from 1 to `i`, representing the length of the current substring being considered.\\n   - Extract the substring `s[i - length:i]` from the string `s`.\\n\\n**4. Check Substring Existence in Dictionary**\\n   - Check if the extracted substring exists in the `word_set` (i.e., if it is a valid word from the dictionary).\\n   - If the substring is in the dictionary, it means it can be used without extra characters.\\n\\n**5. Update `dp[i]`**\\n   - If the substring is in the dictionary, update `dp[i]` by taking the minimum of the current `dp[i]` and `dp[i - length]`.\\n     - This step represents the minimum extra characters needed to form the substring ending at position `i`.\\n\\n**6. Return Minimum Extra Characters**\\n   - After the loops complete, return `dp[max_len - 1]`, which represents the minimum extra characters needed to form the entire string `s`.\\n\\nIn summary, the algorithm uses dynamic programming to find the minimum extra characters needed to form the input string `s` using words from the dictionary. It iterates through the string, considering all possible substrings and checking if they exist in the dictionary, updating the minimum extra characters accordingly. Finally, it returns the minimum extra characters needed for the entire string.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n\\n- Space complexity: O(n)\\n\\n```python []\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        max_len = len(s) + 1  # Maximum length of a valid substring\\n        dp = [max_len] * max_len  # Initialize an array to store minimum extra characters needed for substrings\\n        \\n        dp[0] = 0  # No extra characters needed for an empty string\\n        word_set = set(dictionary)  # Convert the dictionary into a set for efficient word look-up\\n        \\n        for i in range(1, max_len):\\n            dp[i] = dp[i - 1] + 1  # Initialize with a worst-case scenario (one more character than previous)\\n            \\n            for length in range(1, i + 1):\\n                # Check if the substring s[i-length:i] exists in the dictionary\\n                if s[i - length:i] in word_set:\\n                    # If it does, update dp[i] with the minimum of current dp[i] and dp[i-length]\\n                    dp[i] = min(dp[i], dp[i - length])\\n                    \\n        return dp[-1]  # Return the minimum extra characters needed for the entire string\\n\\n```\\n```javascript []\\n/**\\n * @param {string} s\\n * @param {string[]} dictionary\\n * @return {number}\\n */\\nvar minExtraChar = function(s, dictionary) {\\n    const maxLen = s.length + 1;\\n    const dp = new Array(maxLen).fill(maxLen);\\n    \\n    dp[0] = 0;\\n    const wordSet = new Set(dictionary);\\n    \\n    for (let i = 1; i < maxLen; i++) {\\n        dp[i] = dp[i - 1] + 1;\\n        \\n        for (let length = 1; length <= i; length++) {\\n            const substring = s.substring(i - length, i);\\n            if (wordSet.has(substring)) {\\n                dp[i] = Math.min(dp[i], dp[i - length]);\\n            }\\n        }\\n    }\\n    \\n    return dp[maxLen - 1];    \\n};\\n```\\n```java []\\nclass Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        int maxLen = s.length() + 1;\\n        int[] dp = new int[maxLen];\\n        Arrays.fill(dp, maxLen);\\n        \\n        dp[0] = 0;\\n        Set<String> wordSet = new HashSet<>(Arrays.asList(dictionary));\\n        \\n        for (int i = 1; i < maxLen; i++) {\\n            dp[i] = dp[i - 1] + 1;\\n            \\n            for (int length = 1; length <= i; length++) {\\n                String substring = s.substring(i - length, i);\\n                if (wordSet.contains(substring)) {\\n                    dp[i] = Math.min(dp[i], dp[i - length]);\\n                }\\n            }\\n        }\\n        \\n        return dp[maxLen - 1];        \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        int maxLen = s.length() + 1;\\n        vector<int> dp(maxLen, maxLen);\\n        \\n        dp[0] = 0;\\n        unordered_set<string> wordSet(dictionary.begin(), dictionary.end());\\n        \\n        for (int i = 1; i < maxLen; i++) {\\n            dp[i] = dp[i - 1] + 1;\\n            \\n            for (int length = 1; length <= i; length++) {\\n                string substring = s.substr(i - length, length);\\n                if (wordSet.count(substring)) {\\n                    dp[i] = min(dp[i], dp[i - length]);\\n                }\\n            }\\n        }\\n        \\n        return dp[maxLen - 1];        \\n    }\\n};\\n```\\n\\n---\\n\\n\\n# Approach with Trie\\n\\nThe main idea is to leverage the Trie data structure for efficient word lookup and dynamic programming to iteratively compute the minimum extra characters required for each substring of s. By considering valid word endings and reusing previously computed results, the algorithm efficiently finds the optimal solution for constructing s.\\n\\n**1. Trie Data Structure Initialization:**\\n   - Initialize a Trie data structure. Each node in the Trie has a dictionary to store children nodes and a boolean flag `is_word` to indicate if the node represents the end of a word.\\n\\n**2. Building the Trie:**\\n   - Implement the `buildTrie` method to construct a Trie from the given `dictionary` of words.\\n   - For each word in the `dictionary`, iterate through its characters and add them to the Trie, creating nodes as needed.\\n   - Set the `is_word` flag to `True` for the final character node to mark the end of a word.\\n\\n**3. Dynamic Programming Initialization:**\\n   - Initialize an array `dp` of size `n + 1`, where `n` is the length of the input string `s`.\\n   - Initialize all elements of `dp` with a value of positive infinity except for `dp[-1]`, which is set to 0.\\n   - `dp[i]` will represent the minimum number of extra characters needed to form the suffix of `s` starting from index `i`.\\n\\n**4. Dynamic Programming Loop (Outer Loop):**\\n   - Iterate through the characters of `s` in reverse order, from `start = n - 1` to `start = 0`.\\n   - `start` represents the starting index of the suffix that we are currently considering.\\n\\n**5. Initialize `dp[start]`:**\\n   - For each `start`, initialize `dp[start]` with `dp[start + 1] + 1`, representing the worst-case scenario where one extra character is needed for the current suffix.\\n\\n**6. Trie Node and Inner Loop:**\\n   - Initialize a Trie node `node` to the root of the Trie.\\n   - Implement an inner loop to iterate through the characters of the current suffix, from `end = start` to `end = n - 1`.\\n   - Check if `s[end]` is not in `node.children`. If it\\'s not, break out of the inner loop as the current suffix cannot be formed using the Trie.\\n\\n**7. Trie Node Transition:**\\n   - If `s[end]` exists in `node.children`, update `node` to `node.children[s[end]]`. This step represents transitioning to the next character node in the Trie.\\n\\n**8. Check for Valid Word Endings:**\\n   - Check if `node.is_word` is `True`, indicating that the current suffix (from `start` to `end`) is a valid word from the dictionary.\\n\\n**9. Update `dp[start]`:**\\n   - If the current suffix is a valid word, update `dp[start]` by taking the minimum of its current value and `dp[end + 1]`. This step considers the possibility of not adding any extra characters for the current valid word.\\n\\n**10. Return Result:**\\n- After completing the dynamic programming loop, return `dp[0]`, which represents the minimum number of extra characters needed to form the entire string `s` using words from the dictionary.\\n\\nThis algorithm uses dynamic programming and a Trie data structure to efficiently find the minimum number of extra characters required to construct the input string `s`.\\n\\n```python []\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.is_word = False\\n\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        root = self.buildTrie(dictionary)\\n        n = len(s)\\n        dp = [float(\\'inf\\')] * (n + 1)\\n        dp[-1] = 0\\n\\n        for start in reversed(range(n)):\\n            dp[start] = dp[start + 1] + 1\\n            node = root\\n            for end in range(start, n):\\n                if s[end] not in node.children:\\n                    break\\n                node = node.children[s[end]]\\n                if node.is_word:\\n                    dp[start] = min(dp[start], dp[end + 1])\\n        \\n        return dp[0]\\n\\n    def buildTrie(self, dictionary):\\n        root = TrieNode()\\n        for word in dictionary:\\n            node = root\\n            for ch in word:\\n                if ch not in node.children:\\n                    node.children[ch] = TrieNode()\\n                node = node.children[ch]\\n            node.is_word = True\\n        return root\\n```\\n```javascript []\\n/**\\n * @param {string} s\\n * @param {string[]} dictionary\\n * @return {number}\\n */\\nvar minExtraChar = function(s, dictionary) {\\n    class TrieNode {\\n        constructor() {\\n            this.children = {};\\n            this.isWord = false;\\n        }\\n    }\\n\\n    const buildTrie = function(dictionary) {\\n        const root = new TrieNode();\\n        for (const word of dictionary) {\\n            let node = root;\\n            for (const ch of word) {\\n                if (!(ch in node.children)) {\\n                    node.children[ch] = new TrieNode();\\n                }\\n                node = node.children[ch];\\n            }\\n            node.isWord = true;\\n        }\\n        return root;\\n    }\\n\\n    const root = buildTrie(dictionary);\\n    const n = s.length;\\n    const dp = new Array(n + 1).fill(Number.POSITIVE_INFINITY);\\n    dp[n] = 0;\\n\\n    for (let start = n - 1; start >= 0; start--) {\\n        dp[start] = dp[start + 1] + 1;\\n        let node = root;\\n        for (let end = start; end < n; end++) {\\n            const char = s[end];\\n            if (!(char in node.children)) {\\n                break;\\n            }\\n            node = node.children[char];\\n            if (node.isWord) {\\n                dp[start] = Math.min(dp[start], dp[end + 1]);\\n            }\\n        }\\n    }\\n\\n    return dp[0];    \\n};\\n```\\n```java []\\nclass TrieNode {\\n    Map<Character, TrieNode> children;\\n    boolean isWord;\\n\\n    TrieNode() {\\n        children = new HashMap<>();\\n        isWord = false;\\n    }\\n}\\n\\nclass Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        TrieNode root = buildTrie(dictionary);\\n        int n = s.length();\\n        int[] dp = new int[n + 1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[n] = 0;\\n\\n        for (int start = n - 1; start >= 0; start--) {\\n            dp[start] = dp[start + 1] + 1;\\n            TrieNode node = root;\\n            for (int end = start; end < n; end++) {\\n                char ch = s.charAt(end);\\n                if (!node.children.containsKey(ch)) {\\n                    break;\\n                }\\n                node = node.children.get(ch);\\n                if (node.isWord) {\\n                    dp[start] = Math.min(dp[start], dp[end + 1]);\\n                }\\n            }\\n        }\\n\\n        return dp[0];        \\n    }\\n\\n    private TrieNode buildTrie(String[] dictionary) {\\n        TrieNode root = new TrieNode();\\n        for (String word : dictionary) {\\n            TrieNode node = root;\\n            for (char ch : word.toCharArray()) {\\n                if (!node.children.containsKey(ch)) {\\n                    node.children.put(ch, new TrieNode());\\n                }\\n                node = node.children.get(ch);\\n            }\\n            node.isWord = true;\\n        }\\n        return root;\\n    }\\n}\\n```\\n```C++ []\\nclass TrieNode {\\npublic:\\n    unordered_map<char, TrieNode*> children;\\n    bool isWord;\\n\\n    TrieNode() {\\n        isWord = false;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        TrieNode* root = buildTrie(dictionary);\\n        int n = s.length();\\n        vector<int> dp(n + 1, INT_MAX);\\n        dp[n] = 0;\\n\\n        for (int start = n - 1; start >= 0; start--) {\\n            dp[start] = dp[start + 1] + 1;\\n            TrieNode* node = root;\\n            for (int end = start; end < n; end++) {\\n                char ch = s[end];\\n                if (node->children.find(ch) == node->children.end()) {\\n                    break;\\n                }\\n                node = node->children[ch];\\n                if (node->isWord) {\\n                    dp[start] = min(dp[start], dp[end + 1]);\\n                }\\n            }\\n        }\\n\\n        return dp[0];\\n    }\\n\\nprivate:\\n    TrieNode* buildTrie(vector<string>& dictionary) {\\n        TrieNode* root = new TrieNode();\\n        for (const string& word : dictionary) {\\n            TrieNode* node = root;\\n            for (char ch : word) {\\n                if (node->children.find(ch) == node->children.end()) {\\n                    node->children[ch] = new TrieNode();\\n                }\\n                node = node->children[ch];\\n            }\\n            node->isWord = true;\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        max_len = len(s) + 1  # Maximum length of a valid substring\\n        dp = [max_len] * max_len  # Initialize an array to store minimum extra characters needed for substrings\\n        \\n        dp[0] = 0  # No extra characters needed for an empty string\\n        word_set = set(dictionary)  # Convert the dictionary into a set for efficient word look-up\\n        \\n        for i in range(1, max_len):\\n            dp[i] = dp[i - 1] + 1  # Initialize with a worst-case scenario (one more character than previous)\\n            \\n            for length in range(1, i + 1):\\n                # Check if the substring s[i-length:i] exists in the dictionary\\n                if s[i - length:i] in word_set:\\n                    # If it does, update dp[i] with the minimum of current dp[i] and dp[i-length]\\n                    dp[i] = min(dp[i], dp[i - length])\\n                    \\n        return dp[-1]  # Return the minimum extra characters needed for the entire string\\n\\n```\n```javascript []\\n/**\\n * @param {string} s\\n * @param {string[]} dictionary\\n * @return {number}\\n */\\nvar minExtraChar = function(s, dictionary) {\\n    const maxLen = s.length + 1;\\n    const dp = new Array(maxLen).fill(maxLen);\\n    \\n    dp[0] = 0;\\n    const wordSet = new Set(dictionary);\\n    \\n    for (let i = 1; i < maxLen; i++) {\\n        dp[i] = dp[i - 1] + 1;\\n        \\n        for (let length = 1; length <= i; length++) {\\n            const substring = s.substring(i - length, i);\\n            if (wordSet.has(substring)) {\\n                dp[i] = Math.min(dp[i], dp[i - length]);\\n            }\\n        }\\n    }\\n    \\n    return dp[maxLen - 1];    \\n};\\n```\n```java []\\nclass Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        int maxLen = s.length() + 1;\\n        int[] dp = new int[maxLen];\\n        Arrays.fill(dp, maxLen);\\n        \\n        dp[0] = 0;\\n        Set<String> wordSet = new HashSet<>(Arrays.asList(dictionary));\\n        \\n        for (int i = 1; i < maxLen; i++) {\\n            dp[i] = dp[i - 1] + 1;\\n            \\n            for (int length = 1; length <= i; length++) {\\n                String substring = s.substring(i - length, i);\\n                if (wordSet.contains(substring)) {\\n                    dp[i] = Math.min(dp[i], dp[i - length]);\\n                }\\n            }\\n        }\\n        \\n        return dp[maxLen - 1];        \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        int maxLen = s.length() + 1;\\n        vector<int> dp(maxLen, maxLen);\\n        \\n        dp[0] = 0;\\n        unordered_set<string> wordSet(dictionary.begin(), dictionary.end());\\n        \\n        for (int i = 1; i < maxLen; i++) {\\n            dp[i] = dp[i - 1] + 1;\\n            \\n            for (int length = 1; length <= i; length++) {\\n                string substring = s.substr(i - length, length);\\n                if (wordSet.count(substring)) {\\n                    dp[i] = min(dp[i], dp[i - length]);\\n                }\\n            }\\n        }\\n        \\n        return dp[maxLen - 1];        \\n    }\\n};\\n```\n```python []\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.is_word = False\\n\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        root = self.buildTrie(dictionary)\\n        n = len(s)\\n        dp = [float(\\'inf\\')] * (n + 1)\\n        dp[-1] = 0\\n\\n        for start in reversed(range(n)):\\n            dp[start] = dp[start + 1] + 1\\n            node = root\\n            for end in range(start, n):\\n                if s[end] not in node.children:\\n                    break\\n                node = node.children[s[end]]\\n                if node.is_word:\\n                    dp[start] = min(dp[start], dp[end + 1])\\n        \\n        return dp[0]\\n\\n    def buildTrie(self, dictionary):\\n        root = TrieNode()\\n        for word in dictionary:\\n            node = root\\n            for ch in word:\\n                if ch not in node.children:\\n                    node.children[ch] = TrieNode()\\n                node = node.children[ch]\\n            node.is_word = True\\n        return root\\n```\n```javascript []\\n/**\\n * @param {string} s\\n * @param {string[]} dictionary\\n * @return {number}\\n */\\nvar minExtraChar = function(s, dictionary) {\\n    class TrieNode {\\n        constructor() {\\n            this.children = {};\\n            this.isWord = false;\\n        }\\n    }\\n\\n    const buildTrie = function(dictionary) {\\n        const root = new TrieNode();\\n        for (const word of dictionary) {\\n            let node = root;\\n            for (const ch of word) {\\n                if (!(ch in node.children)) {\\n                    node.children[ch] = new TrieNode();\\n                }\\n                node = node.children[ch];\\n            }\\n            node.isWord = true;\\n        }\\n        return root;\\n    }\\n\\n    const root = buildTrie(dictionary);\\n    const n = s.length;\\n    const dp = new Array(n + 1).fill(Number.POSITIVE_INFINITY);\\n    dp[n] = 0;\\n\\n    for (let start = n - 1; start >= 0; start--) {\\n        dp[start] = dp[start + 1] + 1;\\n        let node = root;\\n        for (let end = start; end < n; end++) {\\n            const char = s[end];\\n            if (!(char in node.children)) {\\n                break;\\n            }\\n            node = node.children[char];\\n            if (node.isWord) {\\n                dp[start] = Math.min(dp[start], dp[end + 1]);\\n            }\\n        }\\n    }\\n\\n    return dp[0];    \\n};\\n```\n```java []\\nclass TrieNode {\\n    Map<Character, TrieNode> children;\\n    boolean isWord;\\n\\n    TrieNode() {\\n        children = new HashMap<>();\\n        isWord = false;\\n    }\\n}\\n\\nclass Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        TrieNode root = buildTrie(dictionary);\\n        int n = s.length();\\n        int[] dp = new int[n + 1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[n] = 0;\\n\\n        for (int start = n - 1; start >= 0; start--) {\\n            dp[start] = dp[start + 1] + 1;\\n            TrieNode node = root;\\n            for (int end = start; end < n; end++) {\\n                char ch = s.charAt(end);\\n                if (!node.children.containsKey(ch)) {\\n                    break;\\n                }\\n                node = node.children.get(ch);\\n                if (node.isWord) {\\n                    dp[start] = Math.min(dp[start], dp[end + 1]);\\n                }\\n            }\\n        }\\n\\n        return dp[0];        \\n    }\\n\\n    private TrieNode buildTrie(String[] dictionary) {\\n        TrieNode root = new TrieNode();\\n        for (String word : dictionary) {\\n            TrieNode node = root;\\n            for (char ch : word.toCharArray()) {\\n                if (!node.children.containsKey(ch)) {\\n                    node.children.put(ch, new TrieNode());\\n                }\\n                node = node.children.get(ch);\\n            }\\n            node.isWord = true;\\n        }\\n        return root;\\n    }\\n}\\n```\n```C++ []\\nclass TrieNode {\\npublic:\\n    unordered_map<char, TrieNode*> children;\\n    bool isWord;\\n\\n    TrieNode() {\\n        isWord = false;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        TrieNode* root = buildTrie(dictionary);\\n        int n = s.length();\\n        vector<int> dp(n + 1, INT_MAX);\\n        dp[n] = 0;\\n\\n        for (int start = n - 1; start >= 0; start--) {\\n            dp[start] = dp[start + 1] + 1;\\n            TrieNode* node = root;\\n            for (int end = start; end < n; end++) {\\n                char ch = s[end];\\n                if (node->children.find(ch) == node->children.end()) {\\n                    break;\\n                }\\n                node = node->children[ch];\\n                if (node->isWord) {\\n                    dp[start] = min(dp[start], dp[end + 1]);\\n                }\\n            }\\n        }\\n\\n        return dp[0];\\n    }\\n\\nprivate:\\n    TrieNode* buildTrie(vector<string>& dictionary) {\\n        TrieNode* root = new TrieNode();\\n        for (const string& word : dictionary) {\\n            TrieNode* node = root;\\n            for (char ch : word) {\\n                if (node->children.find(ch) == node->children.end()) {\\n                    node->children[ch] = new TrieNode();\\n                }\\n                node = node->children[ch];\\n            }\\n            node->isWord = true;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568713,
                "title": "easy-recursion-dyanamic-programming-c-java-python",
                "content": "# Intuition\\n**``` Since the constraints are minimal \\uD83D\\uDE43\\uD83D\\uDE43we can try out for all possible substrings, check if the substring if there in the dictionary and then update the cost.```\\n```At last minimize the cost after trying all possiblities```**\\n\\n# Approach\\n**```Since we are trying for all possible substrings we can use Recursion and then Memoize the overlapping subproblems.```**\\n# Time Complexity\\n**``` O(N^2) as for every index we are tyring for all elements where N is the size of array```**\\n# Space Complexity\\n**``` O(N) for DP table which is used to memoize the overlapping subproblems  ```**\\n\\n*# ***``` Please Upvote if it was helpful \\uD83D\\uDE07 \\uD83D\\uDE07 ```****\\n# Code (C++)\\n```\\nclass Solution {\\npublic:\\n    int func(int idx, string &s, set<string> &st, vector<int>& dp)\\n    {\\n        if (idx == s.size())\\n            return 0;\\n        if (dp[idx] != -1)\\n            return dp[idx];\\n        int res = 1e9;\\n        for (int j = idx; j < s.size(); ++j)\\n        {\\n            string str = s.substr(idx, j - idx + 1);\\n            if (st.find(str) != st.end())\\n            {\\n                res = min(res, 0 + func(j + 1, s, st, dp));\\n            }\\n            else\\n                res = min(res, j - idx + 1 + func(j + 1, s, st, dp));\\n        }\\n        return dp[idx] = res;\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        vector<int> dp(s.size() + 1, -1);\\n        set<string> st(dictionary.begin(), dictionary.end());\\n        return func(0, s, st, dp);\\n    }\\n};\\n```\\n# Code (Java)\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    public int func(int idx, String s, Set<String> st, int[] dp) {\\n        if (idx == s.length())\\n            return 0;\\n        if (dp[idx] != -1)\\n            return dp[idx];\\n        int res = Integer.MAX_VALUE;\\n        for (int j = idx; j < s.length(); ++j) {\\n            String str = s.substring(idx, j + 1);\\n            if (st.contains(str))\\n                res = Math.min(res, 0 + func(j + 1, s, st, dp));\\n            else\\n                res = Math.min(res, j - idx + 1 + func(j + 1, s, st, dp));\\n        }\\n        return dp[idx] = res;\\n    }\\n\\n    public int minExtraChar(String s, String[] dictionary) {\\n        int[] dp = new int[s.length() + 1];\\n        Arrays.fill(dp, -1);\\n        Set<String> st = new HashSet<>(Arrays.asList(dictionary));\\n        return func(0, s, st, dp);\\n    }\\n}\\n```\\n# Code (Python)\\n```\\nclass Solution:\\n    def func(self, idx, s, st, dp):\\n        if idx == len(s):\\n            return 0\\n        if dp[idx] != -1:\\n            return dp[idx]\\n        res = float(\\'inf\\')\\n        for j in range(idx, len(s)):\\n            substr = s[idx:j + 1]\\n            if substr in st:\\n                res = min(res, 0 + self.func(j + 1, s, st, dp))\\n            else:\\n                res = min(res, j - idx + 1 + self.func(j + 1, s, st, dp))\\n        dp[idx] = res\\n        return res\\n\\n    def minExtraChar(self, s, dictionary):\\n        dp = [-1] * (len(s) + 1)\\n        st = set(dictionary)\\n        return self.func(0, s, st, dp)\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "``` Since the constraints are minimal \\uD83D\\uDE43\\uD83D\\uDE43we can try out for all possible substrings, check if the substring if there in the dictionary and then update the cost.```\n```At last minimize the cost after trying all possiblities```\n```Since we are trying for all possible substrings we can use Recursion and then Memoize the overlapping subproblems.```\n``` O(N^2) as for every index we are tyring for all elements where N is the size of array```\n``` O(N) for DP table which is used to memoize the overlapping subproblems  ```\n``` Please Upvote if it was helpful \\uD83D\\uDE07 \\uD83D\\uDE07 ```\n```\\nclass Solution {\\npublic:\\n    int func(int idx, string &s, set<string> &st, vector<int>& dp)\\n    {\\n        if (idx == s.size())\\n            return 0;\\n        if (dp[idx] != -1)\\n            return dp[idx];\\n        int res = 1e9;\\n        for (int j = idx; j < s.size(); ++j)\\n        {\\n            string str = s.substr(idx, j - idx + 1);\\n            if (st.find(str) != st.end())\\n            {\\n                res = min(res, 0 + func(j + 1, s, st, dp));\\n            }\\n            else\\n                res = min(res, j - idx + 1 + func(j + 1, s, st, dp));\\n        }\\n        return dp[idx] = res;\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        vector<int> dp(s.size() + 1, -1);\\n        set<string> st(dictionary.begin(), dictionary.end());\\n        return func(0, s, st, dp);\\n    }\\n};\\n```\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    public int func(int idx, String s, Set<String> st, int[] dp) {\\n        if (idx == s.length())\\n            return 0;\\n        if (dp[idx] != -1)\\n            return dp[idx];\\n        int res = Integer.MAX_VALUE;\\n        for (int j = idx; j < s.length(); ++j) {\\n            String str = s.substring(idx, j + 1);\\n            if (st.contains(str))\\n                res = Math.min(res, 0 + func(j + 1, s, st, dp));\\n            else\\n                res = Math.min(res, j - idx + 1 + func(j + 1, s, st, dp));\\n        }\\n        return dp[idx] = res;\\n    }\\n\\n    public int minExtraChar(String s, String[] dictionary) {\\n        int[] dp = new int[s.length() + 1];\\n        Arrays.fill(dp, -1);\\n        Set<String> st = new HashSet<>(Arrays.asList(dictionary));\\n        return func(0, s, st, dp);\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def func(self, idx, s, st, dp):\\n        if idx == len(s):\\n            return 0\\n        if dp[idx] != -1:\\n            return dp[idx]\\n        res = float(\\'inf\\')\\n        for j in range(idx, len(s)):\\n            substr = s[idx:j + 1]\\n            if substr in st:\\n                res = min(res, 0 + self.func(j + 1, s, st, dp))\\n            else:\\n                res = min(res, j - idx + 1 + self.func(j + 1, s, st, dp))\\n        dp[idx] = res\\n        return res\\n\\n    def minExtraChar(self, s, dictionary):\\n        dp = [-1] * (len(s) + 1)\\n        st = set(dictionary)\\n        return self.func(0, s, st, dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568582,
                "title": "2-approach-dp-memoization-trie-approach-detailed-explanation",
                "content": "## Dynamic Programming Approach:\\n\\nThe main idea is to use an array `dp` of size `n+1`, where `n` is the length of the input string `s`. The value of `dp[i]` represents the minimum number of extra characters left over if we break up the substring `s[i..n-1]` optimally.\\n\\nFirst, we initialize the `dp` array with all values set to `n+1`, except for `dp[n]`, which is set to `0`. This is because if there are no characters left in the string, there are no extra characters left over.\\n\\nThen, we iterate backwards from `n-1` to `0`. For each index `i`, we first set `dp[i]` to `dp[i+1]+1`. This represents the case where we do not break up the substring at index `i`, and instead leave it as an extra character.\\n\\nNext, we iterate from `i+1` to `n`, checking if the substring `s[i..j-1]` is present in the dictionary. If it is, we update `dp[i]` to be the minimum of its current value and `dp[j]`. This represents the case where we break up the substring at index `j`, and there are no extra characters between indices `i` and `j-1`.\\n\\nFinally, after all iterations are complete, the value of `dp[0]` represents the minimum number of extra characters left over if we break up the entire string `s` optimally.\\n\\n```java []\\nclass Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        Set<String> dict = new HashSet<>();\\n        for (String word : dictionary) {\\n            dict.add(word);\\n        }\\n\\n        int n = s.length();\\n        int[] dp = new int[n + 1];\\n\\n        for (int i = 1; i <= n; i++) {\\n            dp[i] = dp[i - 1] + 1;\\n\\n            for (int j = i - 1; j >= 0; j--) {\\n                String substring = s.substring(j, i);\\n                if (dict.contains(substring)) {\\n                    dp[i] = Math.min(dp[i], dp[j]);\\n                }\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n```\\n```cpp []\\nclass Solution {\\npublic:\\n    int minExtraChar(std::string s, std::vector<std::string>& dictionary) {\\n        std::unordered_set<std::string> dict;\\n        for (const std::string& word : dictionary) {\\n            dict.insert(word);\\n        }\\n\\n        int n = s.length();\\n        std::vector<int> dp(n + 1);\\n\\n        for (int i = 1; i <= n; i++) {\\n            dp[i] = dp[i - 1] + 1;\\n\\n            for (int j = i - 1; j >= 0; j--) {\\n                std::string substring = s.substr(j, i - j);\\n                if (dict.count(substring)) {\\n                    dp[i] = std::min(dp[i], dp[j]);\\n                }\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def minExtraChar(self, s, dictionary):\\n        dict_set = set(dictionary)\\n\\n        n = len(s)\\n        dp = [0] * (n + 1)\\n\\n        for i in range(1, n + 1):\\n            dp[i] = dp[i - 1] + 1\\n\\n            for j in range(i - 1, -1, -1):\\n                substring = s[j:i]\\n                if substring in dict_set:\\n                    dp[i] = min(dp[i], dp[j])\\n\\n        return dp[n]\\n```\\n\\n\\n## Trie with DP Approach:\\n\\nWe use a trie data structure and dynamic programming to solve the problem. The main idea is to use an array `dp` of size `n+1`, where `n` is the length of the input string `s`. The value of `dp[i]` represents the minimum number of extra characters left over if we break up the substring `s[i..n-1]` optimally.\\n\\nFirst, we create a `TrieNode` class that represents a node in the trie. Each node has an array of children nodes and a boolean flag `isWord` that indicates whether the node represents the end of a word in the dictionary.\\n\\nNext, we create a `root` node and use the insert method to insert each word in the dictionary into the trie.\\n\\nIn the `minExtraChar` method, we initialize the `dp` array with all values set to `n+1`, except for `dp[n]`, which is set to `0`. This is because if there are no characters left in the string, there are no extra characters left over.\\n\\nThen, we iterate backwards from `n-1` to `0`. For each index `i`, we first set `dp[i]` to `dp[i+1]+1`. This represents the case where we do not break up the substring at index `i`, and instead leave it as an extra character.\\n\\nNext, we iterate from `i` to `n-1`, using the trie to check if the substring `s[i..j]` is present in the dictionary. If it is, we update `dp[i]` to be the minimum of its current value and `dp[j+1]`. This represents the case where we break up the substring at index `j+1`, and there are no extra characters between indices `i` and `j`.\\n\\nFinally, after all iterations are complete, the value of `dp[0]` represents the minimum number of extra characters left over if we break up the entire string `s` optimally.\\n\\n```java []\\nclass TrieNode {\\n    TrieNode[] children = new TrieNode[26];\\n    boolean isWord = false;\\n}\\n\\nclass Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        TrieNode root = new TrieNode();\\n        for (String word : dictionary) {\\n            insert(root, word);\\n        }\\n        int n = s.length();\\n        int[] dp = new int[n + 1];\\n        for (int i = n - 1; i >= 0; i--) {\\n            dp[i] = dp[i + 1] + 1;\\n            TrieNode node = root;\\n            for (int j = i; j < n; j++) {\\n                int c = s.charAt(j) - \\'a\\';\\n                if (node.children[c] == null) break;\\n                node = node.children[c];\\n                if (node.isWord) {\\n                    dp[i] = Math.min(dp[i], dp[j + 1]);\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n\\n    private void insert(TrieNode root, String word) {\\n        TrieNode node = root;\\n        for (char c : word.toCharArray()) {\\n            int i = c - \\'a\\';\\n            if (node.children[i] == null) {\\n                node.children[i] = new TrieNode();\\n            }\\n            node = node.children[i];\\n        }\\n        node.isWord = true;\\n    }\\n}\\n```\\n```cpp []\\nclass TrieNode {\\npublic:\\n    TrieNode* children[26];\\n    bool isWord;\\n\\n    TrieNode() {\\n        for (int i = 0; i < 26; i++) {\\n            children[i] = nullptr;\\n        }\\n        isWord = false;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        TrieNode* root = new TrieNode();\\n        for (string word : dictionary) {\\n            insert(root, word);\\n        }\\n        int n = s.length();\\n        vector<int> dp(n + 1);\\n        for (int i = n - 1; i >= 0; i--) {\\n            dp[i] = dp[i + 1] + 1;\\n            TrieNode* node = root;\\n            for (int j = i; j < n; j++) {\\n                int c = s[j] - \\'a\\';\\n                if (node->children[c] == nullptr) break;\\n                node = node->children[c];\\n                if (node->isWord) {\\n                    dp[i] = min(dp[i], dp[j + 1]);\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n\\nprivate:\\n    void insert(TrieNode* root, string word) {\\n        TrieNode* node = root;\\n        for (char c : word) {\\n            int i = c - \\'a\\';\\n            if (node->children[i] == nullptr) {\\n                node->children[i] = new TrieNode();\\n            }\\n            node = node->children[i];\\n        }\\n        node->isWord = true;\\n    }\\n};\\n```\\n```python []\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = [None] * 26\\n        self.isWord = False\\n\\nclass Solution:\\n    def minExtraChar(self, s, dictionary):\\n        root = TrieNode()\\n        for word in dictionary:\\n            self.insert(root, word)\\n        n = len(s)\\n        dp = [0] * (n + 1)\\n        for i in range(n - 1, -1, -1):\\n            dp[i] = dp[i + 1] + 1\\n            node = root\\n            for j in range(i, n):\\n                c = ord(s[j]) - ord(\\'a\\')\\n                if node.children[c] is None:\\n                    break\\n                node = node.children[c]\\n                if node.isWord:\\n                    dp[i] = min(dp[i], dp[j + 1])\\n        return dp[0]\\n\\n    def insert(self, root, word):\\n        node = root\\n        for c in word:\\n            i = ord(c) - ord(\\'a\\')\\n            if node.children[i] is None:\\n                node.children[i] = TrieNode()\\n            node = node.children[i]\\n        node.isWord = True\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Trie",
                    "Memoization"
                ],
                "code": "```java []\\nclass Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        Set<String> dict = new HashSet<>();\\n        for (String word : dictionary) {\\n            dict.add(word);\\n        }\\n\\n        int n = s.length();\\n        int[] dp = new int[n + 1];\\n\\n        for (int i = 1; i <= n; i++) {\\n            dp[i] = dp[i - 1] + 1;\\n\\n            for (int j = i - 1; j >= 0; j--) {\\n                String substring = s.substring(j, i);\\n                if (dict.contains(substring)) {\\n                    dp[i] = Math.min(dp[i], dp[j]);\\n                }\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n```\n```cpp []\\nclass Solution {\\npublic:\\n    int minExtraChar(std::string s, std::vector<std::string>& dictionary) {\\n        std::unordered_set<std::string> dict;\\n        for (const std::string& word : dictionary) {\\n            dict.insert(word);\\n        }\\n\\n        int n = s.length();\\n        std::vector<int> dp(n + 1);\\n\\n        for (int i = 1; i <= n; i++) {\\n            dp[i] = dp[i - 1] + 1;\\n\\n            for (int j = i - 1; j >= 0; j--) {\\n                std::string substring = s.substr(j, i - j);\\n                if (dict.count(substring)) {\\n                    dp[i] = std::min(dp[i], dp[j]);\\n                }\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def minExtraChar(self, s, dictionary):\\n        dict_set = set(dictionary)\\n\\n        n = len(s)\\n        dp = [0] * (n + 1)\\n\\n        for i in range(1, n + 1):\\n            dp[i] = dp[i - 1] + 1\\n\\n            for j in range(i - 1, -1, -1):\\n                substring = s[j:i]\\n                if substring in dict_set:\\n                    dp[i] = min(dp[i], dp[j])\\n\\n        return dp[n]\\n```\n```java []\\nclass TrieNode {\\n    TrieNode[] children = new TrieNode[26];\\n    boolean isWord = false;\\n}\\n\\nclass Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        TrieNode root = new TrieNode();\\n        for (String word : dictionary) {\\n            insert(root, word);\\n        }\\n        int n = s.length();\\n        int[] dp = new int[n + 1];\\n        for (int i = n - 1; i >= 0; i--) {\\n            dp[i] = dp[i + 1] + 1;\\n            TrieNode node = root;\\n            for (int j = i; j < n; j++) {\\n                int c = s.charAt(j) - \\'a\\';\\n                if (node.children[c] == null) break;\\n                node = node.children[c];\\n                if (node.isWord) {\\n                    dp[i] = Math.min(dp[i], dp[j + 1]);\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n\\n    private void insert(TrieNode root, String word) {\\n        TrieNode node = root;\\n        for (char c : word.toCharArray()) {\\n            int i = c - \\'a\\';\\n            if (node.children[i] == null) {\\n                node.children[i] = new TrieNode();\\n            }\\n            node = node.children[i];\\n        }\\n        node.isWord = true;\\n    }\\n}\\n```\n```cpp []\\nclass TrieNode {\\npublic:\\n    TrieNode* children[26];\\n    bool isWord;\\n\\n    TrieNode() {\\n        for (int i = 0; i < 26; i++) {\\n            children[i] = nullptr;\\n        }\\n        isWord = false;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        TrieNode* root = new TrieNode();\\n        for (string word : dictionary) {\\n            insert(root, word);\\n        }\\n        int n = s.length();\\n        vector<int> dp(n + 1);\\n        for (int i = n - 1; i >= 0; i--) {\\n            dp[i] = dp[i + 1] + 1;\\n            TrieNode* node = root;\\n            for (int j = i; j < n; j++) {\\n                int c = s[j] - \\'a\\';\\n                if (node->children[c] == nullptr) break;\\n                node = node->children[c];\\n                if (node->isWord) {\\n                    dp[i] = min(dp[i], dp[j + 1]);\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n\\nprivate:\\n    void insert(TrieNode* root, string word) {\\n        TrieNode* node = root;\\n        for (char c : word) {\\n            int i = c - \\'a\\';\\n            if (node->children[i] == nullptr) {\\n                node->children[i] = new TrieNode();\\n            }\\n            node = node->children[i];\\n        }\\n        node->isWord = true;\\n    }\\n};\\n```\n```python []\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = [None] * 26\\n        self.isWord = False\\n\\nclass Solution:\\n    def minExtraChar(self, s, dictionary):\\n        root = TrieNode()\\n        for word in dictionary:\\n            self.insert(root, word)\\n        n = len(s)\\n        dp = [0] * (n + 1)\\n        for i in range(n - 1, -1, -1):\\n            dp[i] = dp[i + 1] + 1\\n            node = root\\n            for j in range(i, n):\\n                c = ord(s[j]) - ord(\\'a\\')\\n                if node.children[c] is None:\\n                    break\\n                node = node.children[c]\\n                if node.isWord:\\n                    dp[i] = min(dp[i], dp[j + 1])\\n        return dp[0]\\n\\n    def insert(self, root, word):\\n        node = root\\n        for c in word:\\n            i = ord(c) - ord(\\'a\\')\\n            if node.children[i] is None:\\n                node.children[i] = TrieNode()\\n            node = node.children[i]\\n        node.isWord = True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990522,
                "title": "beats-100-with-proper-explanation-and-diagram-dp",
                "content": "\\n# Approach\\nFirstly we\\'ll create a dp array to store immediate results which will be minExtra chars at a particular index.\\n\\nCreate a map of words in dictionary.\\n\\nNow call a solve function.\\n\\nIn the solve function-\\n- If ```index``` is equal to size of the string, return 0 since we\\'ve completed our task\\n- if ```dp[index] != -1``` we\\'ve already calculated our answer for this index so return ```dp[index]```\\n- Now, create a empty string ```currStr```, this will store string formed till current index\\n- ```minExtra``` stores the minimum size of extra chars required\\n- Iterate from ```cutIdx = 0 to s.size()``` and push the current character into our empty string.\\n- Now check if our currString is present in map or not, if it is our ```currExtra``` will be 0 , since no extra chars required, else it will be ```currStr.size()```.\\n- In ```nextExtra``` we\\'re finding extra chars in the string that will be formed after the current string i.e from index ```cutIndex + 1 to s.size()```.\\n- ```totalExtra``` will be sum of the two calculate extras, i.e current and next.\\n- ```minExtra``` would store the minimum of all totalExtras.\\n- At last we return ```dp[index] = minExtra``` , here we are basically assigning  minExtra to dp[index] and at the same time returning ```dp[index]```.\\n\\n# Look below for a solved test case\\n![image.png](https://assets.leetcode.com/users/images/5d5f1212-3fe7-4deb-87e6-83e04e7af687_1693622729.2937257.png)\\n\\n\\n# Do Upvote if you liked even a bit!\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(string& s, unordered_map<string, int>&mp, vector<int>&dp, int index)\\n    {\\n        if (index >= s.size()) return 0;\\n        if (dp[index] != -1) return dp[index]; //use the stored results\\n        \\n        string currStr = \"\";\\n        int minExtra = s.size();\\n        for (int cutIdx = index; cutIdx < s.size(); cutIdx++)\\n        {\\n            currStr.push_back(s[cutIdx]);\\n            //currStr will be a string from (index to cutIdx)\\n            \\n            //if string not in dictionary, we have to delete as they are extra chars\\n            int currExtra = (mp.count(currStr))? 0 : currStr.size();\\n            int nextExtra = solve(s, mp, dp, cutIdx + 1);\\n            int totalExtra = currExtra + nextExtra;\\n            \\n            minExtra = min(minExtra, totalExtra);\\n        }\\n        return dp[index] = minExtra;\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) \\n    {\\n        vector<int>dp(s.size(), -1);\\n        unordered_map<string, int>mp;\\n        for (string& word : dictionary) mp[word]++;\\n        \\n        int ans = solve(s, mp, dp, 0);\\n        return ans;\\n        \\n    }\\n};\\n\\n// class Solution {\\n// public:\\n//     unordered_set<string> st;\\n//     vector<int> mem;\\n\\n//     int solve(string& s, int ind){ \\n//         if(ind >= s.size()) return 0;\\n//         if(mem[ind] != -1) return mem[ind];\\n//         int res = 1 + solve(s, ind + 1);   //skip one element with vlaue 1 added to result\\n//         for(int i = 1; ind + i <= s.size(); ++i){ //check if any of the chars can be skiped without any value returned \\n//             string t = s.substr(ind, i);\\n//             if(st.find(t) != st.end()) res = min(res, solve(s, ind+i));\\n//         }\\n//         return mem[ind] = res;\\n//     }\\n\\n//     int minExtraChar(string s, vector<string>& dictionary) {\\n//         mem.resize(s.size() + 1, -1);\\n//         for(auto d: dictionary ) st.insert(d);\\n//         return solve(s, 0);\\n//     }\\n// };\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```index```\n```dp[index] != -1```\n```dp[index]```\n```currStr```\n```minExtra```\n```cutIdx = 0 to s.size()```\n```currExtra```\n```currStr.size()```\n```nextExtra```\n```cutIndex + 1 to s.size()```\n```totalExtra```\n```minExtra```\n```dp[index] = minExtra```\n```dp[index]```\n```\\nclass Solution {\\npublic:\\n    int solve(string& s, unordered_map<string, int>&mp, vector<int>&dp, int index)\\n    {\\n        if (index >= s.size()) return 0;\\n        if (dp[index] != -1) return dp[index]; //use the stored results\\n        \\n        string currStr = \"\";\\n        int minExtra = s.size();\\n        for (int cutIdx = index; cutIdx < s.size(); cutIdx++)\\n        {\\n            currStr.push_back(s[cutIdx]);\\n            //currStr will be a string from (index to cutIdx)\\n            \\n            //if string not in dictionary, we have to delete as they are extra chars\\n            int currExtra = (mp.count(currStr))? 0 : currStr.size();\\n            int nextExtra = solve(s, mp, dp, cutIdx + 1);\\n            int totalExtra = currExtra + nextExtra;\\n            \\n            minExtra = min(minExtra, totalExtra);\\n        }\\n        return dp[index] = minExtra;\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) \\n    {\\n        vector<int>dp(s.size(), -1);\\n        unordered_map<string, int>mp;\\n        for (string& word : dictionary) mp[word]++;\\n        \\n        int ans = solve(s, mp, dp, 0);\\n        return ans;\\n        \\n    }\\n};\\n\\n// class Solution {\\n// public:\\n//     unordered_set<string> st;\\n//     vector<int> mem;\\n\\n//     int solve(string& s, int ind){ \\n//         if(ind >= s.size()) return 0;\\n//         if(mem[ind] != -1) return mem[ind];\\n//         int res = 1 + solve(s, ind + 1);   //skip one element with vlaue 1 added to result\\n//         for(int i = 1; ind + i <= s.size(); ++i){ //check if any of the chars can be skiped without any value returned \\n//             string t = s.substr(ind, i);\\n//             if(st.find(t) != st.end()) res = min(res, solve(s, ind+i));\\n//         }\\n//         return mem[ind] = res;\\n//     }\\n\\n//     int minExtraChar(string s, vector<string>& dictionary) {\\n//         mem.resize(s.size() + 1, -1);\\n//         for(auto d: dictionary ) st.insert(d);\\n//         return solve(s, 0);\\n//     }\\n// };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568624,
                "title": "top-down-and-bottom-up",
                "content": "## Bottom-Up\\n**C++**\\n```cpp\\nint minExtraChar(const string &s, vector<string>& dict) {\\n    int dp[51] = {};\\n    for (int i = s.size() - 1; i >= 0; --i) {\\n        dp[i] = 1 + dp[i + 1];\\n        for (const auto &w: dict)\\n            if (s.compare(i, w.size(), w) == 0)\\n                dp[i] = min(dp[i], dp[i + w.size()]);\\n    }\\n    return dp[0];\\n}\\n```\\n## Top-Down\\n**C++**\\n```cpp\\nint dp[51] = {[0 ... 50] = -1};\\nint minExtraChar(const string &s, vector<string>& dict, int i = 0) {\\n    if (i == s.size())\\n        return 0;\\n    if (dp[i] == -1) {\\n        dp[i] = 1 + minExtraChar(s, dict, i + 1);\\n        for (const auto &w: dict)\\n            if (s.compare(i, w.size(), w) == 0)\\n                dp[i] = min(dp[i], minExtraChar(s, dict, i + w.size()));\\n    }\\n    return dp[i];\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint minExtraChar(const string &s, vector<string>& dict) {\\n    int dp[51] = {};\\n    for (int i = s.size() - 1; i >= 0; --i) {\\n        dp[i] = 1 + dp[i + 1];\\n        for (const auto &w: dict)\\n            if (s.compare(i, w.size(), w) == 0)\\n                dp[i] = min(dp[i], dp[i + w.size()]);\\n    }\\n    return dp[0];\\n}\\n```\n```cpp\\nint dp[51] = {[0 ... 50] = -1};\\nint minExtraChar(const string &s, vector<string>& dict, int i = 0) {\\n    if (i == s.size())\\n        return 0;\\n    if (dp[i] == -1) {\\n        dp[i] = 1 + minExtraChar(s, dict, i + 1);\\n        for (const auto &w: dict)\\n            if (s.compare(i, w.size(), w) == 0)\\n                dp[i] = min(dp[i], minExtraChar(s, dict, i + w.size()));\\n    }\\n    return dp[i];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3990361,
                "title": "96-92-solution-with-dfs-method-python-c-c-jav-5-20-am",
                "content": "```Python3 []\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        cache = {}\\n\\n        def dfs(text):\\n            if len(text) <= 0:\\n                return 0\\n\\n            if len(text) in cache:\\n                return cache[len(text)]\\n            \\n            minimum = len(text)\\n\\n            for word in dictionary:\\n                if text == word:\\n                    minimum = 0\\n                    cache[len(text)] = minimum\\n                    return minimum\\n\\n                elif text[:len(word)] == word:\\n                    result = dfs(text[len(word):])\\n                    minimum = min(minimum, result)\\n\\n            minimum = min(minimum, 1 + dfs(text[1:]))\\n\\n            cache[len(text)] = minimum\\n\\n            return minimum\\n\\n        return dfs(s)\\n```\\n```python []\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        cache = {}\\n\\n        def dfs(text):\\n            if len(text) <= 0:\\n                return 0\\n\\n            if len(text) in cache:\\n                return cache[len(text)]\\n            \\n            minimum = len(text)\\n\\n            for word in dictionary:\\n                if text == word:\\n                    minimum = 0\\n                    cache[len(text)] = minimum\\n                    return minimum\\n\\n                elif text[:len(word)] == word:\\n                    result = dfs(text[len(word):])\\n                    minimum = min(minimum, result)\\n\\n            minimum = min(minimum, 1 + dfs(text[1:]))\\n\\n            cache[len(text)] = minimum\\n\\n            return minimum\\n\\n        return dfs(s)\\n```\\n```C# []\\npublic class Solution\\n{\\n    public int MinExtraChar(string s, string[] dictionary)\\n    {\\n        Dictionary<int, int> cache = new Dictionary<int, int>();\\n\\n        int Dfs(string text)\\n        {\\n            if (text.Length <= 0)\\n                return 0;\\n\\n            if (cache.ContainsKey(text.Length))\\n                return cache[text.Length];\\n\\n            int minimum = text.Length;\\n\\n            foreach (string word in dictionary)\\n            {\\n                if (text == word)\\n                {\\n                    minimum = 0;\\n                    cache[text.Length] = minimum;\\n                    return minimum;\\n                }\\n                else if (text.StartsWith(word))\\n                {\\n                    int result = Dfs(text.Substring(word.Length));\\n                    minimum = Math.Min(minimum, result);\\n                }\\n            }\\n\\n            minimum = Math.Min(minimum, 1 + Dfs(text.Substring(1)));\\n\\n            cache[text.Length] = minimum;\\n\\n            return minimum;\\n        }\\n\\n        return Dfs(s);\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int minExtraChar(std::string s, std::vector<std::string> dictionary) {\\n        std::unordered_map<int, int> cache;\\n\\n        int result = dfs(s, dictionary, cache);\\n        return result;\\n    }\\n\\nprivate:\\n    int dfs(const std::string& text, const std::vector<std::string>& dictionary, std::unordered_map<int, int>& cache) {\\n        if (text.empty()) {\\n            return 0;\\n        }\\n\\n        if (cache.find(text.length()) != cache.end()) {\\n            return cache[text.length()];\\n        }\\n\\n        int minimum = text.length();\\n\\n        for (const std::string& word : dictionary) {\\n            if (text == word) {\\n                minimum = 0;\\n                cache[text.length()] = minimum;\\n                return minimum;\\n            } else if (text.substr(0, word.length()) == word) {\\n                int result = dfs(text.substr(word.length()), dictionary, cache);\\n                minimum = std::min(minimum, result);\\n            }\\n        }\\n\\n        int result = 1 + dfs(text.substr(1), dictionary, cache);\\n        minimum = std::min(minimum, result);\\n\\n        cache[text.length()] = minimum;\\n        return minimum;\\n    }\\n};\\n```\\n```Java []\\npublic class Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        Map<Integer, Integer> cache = new HashMap<>();\\n\\n        int result = dfs(s, dictionary, cache);\\n        return result;\\n    }\\n\\n    private int dfs(String text, String[] dictionary, Map<Integer, Integer> cache) {\\n        if (text.isEmpty()) {\\n            return 0;\\n        }\\n\\n        if (cache.containsKey(text.length())) {\\n            return cache.get(text.length());\\n        }\\n\\n        int minimum = text.length();\\n\\n        for (String word : dictionary) {\\n            if (text.equals(word)) {\\n                minimum = 0;\\n                cache.put(text.length(), minimum);\\n                return minimum;\\n            } else if (text.startsWith(word)) {\\n                int result = dfs(text.substring(word.length()), dictionary, cache);\\n                minimum = Math.min(minimum, result);\\n            }\\n        }\\n\\n        int result = 1 + dfs(text.substring(1), dictionary, cache);\\n        minimum = Math.min(minimum, result);\\n\\n        cache.put(text.length(), minimum);\\n        return minimum;\\n    }\\n}\\n```\\n```ruby []\\nputs \\'Hello world!\\'\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "C#"
                ],
                "code": "```Python3 []\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        cache = {}\\n\\n        def dfs(text):\\n            if len(text) <= 0:\\n                return 0\\n\\n            if len(text) in cache:\\n                return cache[len(text)]\\n            \\n            minimum = len(text)\\n\\n            for word in dictionary:\\n                if text == word:\\n                    minimum = 0\\n                    cache[len(text)] = minimum\\n                    return minimum\\n\\n                elif text[:len(word)] == word:\\n                    result = dfs(text[len(word):])\\n                    minimum = min(minimum, result)\\n\\n            minimum = min(minimum, 1 + dfs(text[1:]))\\n\\n            cache[len(text)] = minimum\\n\\n            return minimum\\n\\n        return dfs(s)\\n```\n```python []\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        cache = {}\\n\\n        def dfs(text):\\n            if len(text) <= 0:\\n                return 0\\n\\n            if len(text) in cache:\\n                return cache[len(text)]\\n            \\n            minimum = len(text)\\n\\n            for word in dictionary:\\n                if text == word:\\n                    minimum = 0\\n                    cache[len(text)] = minimum\\n                    return minimum\\n\\n                elif text[:len(word)] == word:\\n                    result = dfs(text[len(word):])\\n                    minimum = min(minimum, result)\\n\\n            minimum = min(minimum, 1 + dfs(text[1:]))\\n\\n            cache[len(text)] = minimum\\n\\n            return minimum\\n\\n        return dfs(s)\\n```\n```C# []\\npublic class Solution\\n{\\n    public int MinExtraChar(string s, string[] dictionary)\\n    {\\n        Dictionary<int, int> cache = new Dictionary<int, int>();\\n\\n        int Dfs(string text)\\n        {\\n            if (text.Length <= 0)\\n                return 0;\\n\\n            if (cache.ContainsKey(text.Length))\\n                return cache[text.Length];\\n\\n            int minimum = text.Length;\\n\\n            foreach (string word in dictionary)\\n            {\\n                if (text == word)\\n                {\\n                    minimum = 0;\\n                    cache[text.Length] = minimum;\\n                    return minimum;\\n                }\\n                else if (text.StartsWith(word))\\n                {\\n                    int result = Dfs(text.Substring(word.Length));\\n                    minimum = Math.Min(minimum, result);\\n                }\\n            }\\n\\n            minimum = Math.Min(minimum, 1 + Dfs(text.Substring(1)));\\n\\n            cache[text.Length] = minimum;\\n\\n            return minimum;\\n        }\\n\\n        return Dfs(s);\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int minExtraChar(std::string s, std::vector<std::string> dictionary) {\\n        std::unordered_map<int, int> cache;\\n\\n        int result = dfs(s, dictionary, cache);\\n        return result;\\n    }\\n\\nprivate:\\n    int dfs(const std::string& text, const std::vector<std::string>& dictionary, std::unordered_map<int, int>& cache) {\\n        if (text.empty()) {\\n            return 0;\\n        }\\n\\n        if (cache.find(text.length()) != cache.end()) {\\n            return cache[text.length()];\\n        }\\n\\n        int minimum = text.length();\\n\\n        for (const std::string& word : dictionary) {\\n            if (text == word) {\\n                minimum = 0;\\n                cache[text.length()] = minimum;\\n                return minimum;\\n            } else if (text.substr(0, word.length()) == word) {\\n                int result = dfs(text.substr(word.length()), dictionary, cache);\\n                minimum = std::min(minimum, result);\\n            }\\n        }\\n\\n        int result = 1 + dfs(text.substr(1), dictionary, cache);\\n        minimum = std::min(minimum, result);\\n\\n        cache[text.length()] = minimum;\\n        return minimum;\\n    }\\n};\\n```\n```Java []\\npublic class Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        Map<Integer, Integer> cache = new HashMap<>();\\n\\n        int result = dfs(s, dictionary, cache);\\n        return result;\\n    }\\n\\n    private int dfs(String text, String[] dictionary, Map<Integer, Integer> cache) {\\n        if (text.isEmpty()) {\\n            return 0;\\n        }\\n\\n        if (cache.containsKey(text.length())) {\\n            return cache.get(text.length());\\n        }\\n\\n        int minimum = text.length();\\n\\n        for (String word : dictionary) {\\n            if (text.equals(word)) {\\n                minimum = 0;\\n                cache.put(text.length(), minimum);\\n                return minimum;\\n            } else if (text.startsWith(word)) {\\n                int result = dfs(text.substring(word.length()), dictionary, cache);\\n                minimum = Math.min(minimum, result);\\n            }\\n        }\\n\\n        int result = 1 + dfs(text.substring(1), dictionary, cache);\\n        minimum = Math.min(minimum, result);\\n\\n        cache.put(text.length(), minimum);\\n        return minimum;\\n    }\\n}\\n```\n```ruby []\\nputs \\'Hello world!\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991421,
                "title": "simple-solution-explained-with-examples-in-detail",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nLet us take  **s = \"leetscode\", dictionary = [\"leet\",\"code\",\"leetcode\"]**\\n\\nNow, we will try to break this problem in the **minimum size possible..**\\n\\nIntitially, let us take a string of **size 1 from \"s\"**\\n\\nso ,** we have \"l\" + \"eetscode\"**\\n\\nNow, there could be 2 cases..\\n\\n**case 1) => \"l\" is presnt in the dictionary..**\\n\\n**Case 2) => \"l\" is not presnt in the dictionary..**\\n\\n It is not presnt in the dictionary.., so it can be a \"extra character\",** we don\\'t need**..so we will increase the **count by 1** and call our recursive function and ask him to calculte **our ans for \"eetscode\"..**\\n\\nNow, let us take a string of **size 2..**\\n\\nwe have \"le\" + \"etscode\"\\n\\nNow, there could be 2 cases \\n\\nCase 1 => **\"le\" is not presnt in the dictionary..**\\n\\nCase 2 => **\"le\" is presnt in the dictionary..**\\n\\nit is not presnt...so we can have 2 extra charcters here..and we will call our recurive functions to go and calculate for **\"etscode\"**\\n\\nIt means , that at every step..\\n\\n1) We need to check for **size 1,2,3,4.....**and so on... and we need to call our **reursive** function for the remaining charcters that are left..\\n\\nIf by chance.. we get any string , that we have present in our dictionary, It means that the **extra charctetrs will be 0...**\\n\\n\\nHow our code, will look like..for this part of explanation\\n\\n```\\nstring ans = \"\";\\nint extra = 0;\\nint result = s.size();\\nfor(int idx = i; idx<s.size(); idx++)\\n        {\\n\\n            ans+=s[idx];\\n            if(jd.find(ans)==jd.end())\\n            {\\n                extra = ans.size();\\n            }\\n            else\\n            {\\n                extra = 0;\\n            }\\n\\n            int z = solve(idx+1,s,jd,dp);\\n            total  = z + extra;\\n            result  = min(total,result);\\n\\n\\n        }\\n```\\n\\nAt every step, whether the **string is presnt in dictionary or no**t, we will call out our recurive function to **check for the remianing charaters..**\\n\\nNow, why do we initialize..**the result = s.size()**, suppose you got a string s, for which **there is no chatacter presnt** in the dictionary..\\nso in such case the whole string is **filled of extra charatcers..**\\n\\n\\n**What will be the base case..**\\n\\nLet us say , your \"i\" reaches s.size()...**CAN YOU DO ANY CALCULATION..WHEN IT REACHES S.SIZE()** => The ans is \"NO\"..so you will just return 0..\\n\\n\\nNow, **how do we memoize it**...The ans is simple..Always look at the **changing paramter**..HERE,\\n\\n1) **Only index i is changing**...which is an index of string s..so we will make a 1-d dp array..and will store the result for every index in dp[i]...\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe are slicing every indx and checking for the remianing index..so **O(N*N)**\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe took an unordered map, for storing our dictionary + we made a dp array..so **O(N)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int solve(int i, string &s,unordered_map<string,int>&jd,vector<int>&dp)\\n    {\\n\\n        if(i==s.size())\\n        {\\n            return 0;\\n        }\\n\\n        if(dp[i]!=-1)\\n        {\\n            return dp[i];\\n        }\\n\\n        string ans = \"\";\\n        int extra = 0,result = s.size();\\n        int total ;\\n        for(int idx = i; idx<s.size(); idx++)\\n        {\\n\\n            ans+=s[idx];\\n            if(jd.find(ans)==jd.end())\\n            {\\n                extra = ans.size();\\n            }\\n            else\\n            {\\n                extra = 0;\\n            }\\n\\n            int z = solve(idx+1,s,jd,dp);\\n            total  = z + extra;\\n\\n            result  = min(total,result);\\n\\n\\n        }\\n        \\n        dp[i]=result;\\n        return result;\\n    }\\n\\n\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        \\n        unordered_map<string,int>jd;\\n        vector<int>dp(s.size(),-1);\\n        for(int i=0; i<dictionary.size(); i++)\\n        {\\n            jd[dictionary[i]]=0;\\n        }\\n\\n        int ans  = solve(0,s,jd,dp);\\n        return ans;\\n\\n    }\\n};\\n```\\n\\n**TIME FOR A MEME NOW**\\n\\n![WhatsApp Image 2023-07-17 at 21.56.53.jpeg](https://assets.leetcode.com/users/images/7046a5cd-b0c8-47bf-ae28-c6c1124241f6_1693642029.9166553.jpeg)\\n\\n\\n\\n\\n\\n# **IF YOU LIKE MY EXPLANATION, PLEASE UPVOTE..**",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nstring ans = \"\";\\nint extra = 0;\\nint result = s.size();\\nfor(int idx = i; idx<s.size(); idx++)\\n        {\\n\\n            ans+=s[idx];\\n            if(jd.find(ans)==jd.end())\\n            {\\n                extra = ans.size();\\n            }\\n            else\\n            {\\n                extra = 0;\\n            }\\n\\n            int z = solve(idx+1,s,jd,dp);\\n            total  = z + extra;\\n            result  = min(total,result);\\n\\n\\n        }\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int solve(int i, string &s,unordered_map<string,int>&jd,vector<int>&dp)\\n    {\\n\\n        if(i==s.size())\\n        {\\n            return 0;\\n        }\\n\\n        if(dp[i]!=-1)\\n        {\\n            return dp[i];\\n        }\\n\\n        string ans = \"\";\\n        int extra = 0,result = s.size();\\n        int total ;\\n        for(int idx = i; idx<s.size(); idx++)\\n        {\\n\\n            ans+=s[idx];\\n            if(jd.find(ans)==jd.end())\\n            {\\n                extra = ans.size();\\n            }\\n            else\\n            {\\n                extra = 0;\\n            }\\n\\n            int z = solve(idx+1,s,jd,dp);\\n            total  = z + extra;\\n\\n            result  = min(total,result);\\n\\n\\n        }\\n        \\n        dp[i]=result;\\n        return result;\\n    }\\n\\n\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        \\n        unordered_map<string,int>jd;\\n        vector<int>dp(s.size(),-1);\\n        for(int i=0; i<dictionary.size(); i++)\\n        {\\n            jd[dictionary[i]]=0;\\n        }\\n\\n        int ans  = solve(0,s,jd,dp);\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990872,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        int len=s.length();\\n        int dp[]=new int[len];\\n        Arrays.fill(dp,-1);\\n        Set<String> nm=new HashSet<>();\\n        for(String k:dictionary)\\n        {\\n            nm.add(k);\\n        }\\n        return task(dp,s,len,0,nm);\\n    }\\n    public int task(int dp[], String s, int len, int ind, Set<String> nm)\\n    {\\n        if(ind==len)\\n        {\\n            return 0;\\n        }\\n        if(dp[ind]!=-1)\\n        {\\n            return dp[ind];\\n        }\\n        StringBuilder k=new StringBuilder();\\n        int ans=len;\\n        for(int point=ind;point<len;point++)\\n        {\\n            k.append(s.charAt(point));\\n            int val=nm.contains(k.toString()) ? 0 : k.length();\\n            int val1=task(dp,s,len,point+1,nm);\\n            ans=Math.min(ans,val+val1);\\n        }\\n        return dp[ind]=ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        int len=s.length();\\n        int dp[]=new int[len];\\n        Arrays.fill(dp,-1);\\n        Set<String> nm=new HashSet<>();\\n        for(String k:dictionary)\\n        {\\n            nm.add(k);\\n        }\\n        return task(dp,s,len,0,nm);\\n    }\\n    public int task(int dp[], String s, int len, int ind, Set<String> nm)\\n    {\\n        if(ind==len)\\n        {\\n            return 0;\\n        }\\n        if(dp[ind]!=-1)\\n        {\\n            return dp[ind];\\n        }\\n        StringBuilder k=new StringBuilder();\\n        int ans=len;\\n        for(int point=ind;point<len;point++)\\n        {\\n            k.append(s.charAt(point));\\n            int val=nm.contains(k.toString()) ? 0 : k.length();\\n            int val1=task(dp,s,len,point+1,nm);\\n            ans=Math.min(ans,val+val1);\\n        }\\n        return dp[ind]=ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990404,
                "title": "c-dp-recursive-iterative-vs-trie-beats-99-92",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nProvide 4 DP solutions: 1st & 2nd ones using top-down design, 2 recursive versions with memoization, and the other using bottom-up design, an iterative version. No hash table (unordered_map or unordered_set) is used in every solution of this post. So, the DP solutions here are quite different from others.\\n\\nA DP with Trie solution is also presented.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAll solutions using  same dp array:\\n``` dp[i]=the minimum extra characters needed for s[i:end]!```\\n Some of solutions may be slightly modified from previous versions.\\n\\nDP solves it. Use the similar way to [Leetcode 139. Word Break](https://leetcode.com/problems/word-break/solutions/3860474/easy-recursive-dfs-c-python/)!\\n\\nSince the first three solutions use C++ string methods ```substr()``` and ```find()```, it is assumed that these methods have running time not a constant time but a linear time $O(m)$ when the output string w with ```len(w)=m```. To reduce the TC it needs other data structure.\\n\\n4th solution modifies my Trie class for [208. Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/solutions/3307262/c-solution/) ! Its running time is 36 ms & beats 99.92%.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(nkm)$, where n=len(s), k=len(dictionary), and m=average len(w) for w in dictionary.\\n$O(n^2+mk)$ for Trie solution.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(n)$ vs $O(n+mk)$\\n# Code of recursive version Runtime 71 ms Beats 96.81%\\n```\\nclass Solution {\\npublic:\\n    vector<int> dp;// dp[i]=the minimum extra characters needed for s[i:end]\\n    int n;\\n    int f(int i, string& s, vector<string>& dictionary) {\\n        if (i == n) return 0; // Base case\\n\\n        if (dp[i]!= -1) return dp[i]; \\n        int ans = n; \\n\\n        for (string& w : dictionary) {\\n            int wLen = w.size();\\n            if (i+wLen <= n && s.substr(i, wLen) == w) {\\n            // If the current word matches the substring starting at position i\\n                int extra = f(i+wLen, s, dictionary);\\n                ans = min(ans, extra);\\n            }\\n        }\\n\\n        // The current character is not covered by any word in the dictionary\\n        int noWord = 1 + f(i+1, s, dictionary);\\n\\n        // Take the minimum of using a word or not using a word\\n        ans = min(ans, noWord);\\n\\n        return dp[i]=ans;\\n    }\\n\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        n=s.size();\\n        dp.assign(n, -1); \\n        return f(0, s, dictionary);\\n    }\\n\\n};\\n\\n```\\n# Code of recursive version using C++ string find Runtime 65 ms Beats 97.53%\\n```\\nclass Solution {\\npublic:\\n    vector<int> dp;// dp[i]=the minimum extra characters needed for s[i:end]\\n    int n;\\n    int f(int i, string& s, vector<string>& dictionary) {\\n        if (i == n) return 0; // Base case\\n\\n        if (dp[i]!= -1) return dp[i]; \\n        int ans = n; \\n\\n        for (string& w : dictionary) {\\n            int wLen = w.size();\\n            int j=s.find(w, i);// more flexible than substr\\n        //    cout<<j<<\",\";\\n            if (j!=-1) {\\n            // If the current word  is found at j>=i\\n                int extra =(j-i)+f(j+wLen, s, dictionary);\\n                ans = min(ans, extra);\\n            }\\n        }\\n\\n        // The current character is not covered by any word in the dictionary\\n        int noWord = 1+f(i+1, s, dictionary);\\n\\n        // Take the minimum of using a word or not using a word\\n        ans = min(ans, noWord);\\n\\n        return dp[i]=ans;\\n    }\\n\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        n=s.size();\\n        dp.assign(n, -1); \\n        return f(0, s, dictionary);\\n    }\\n\\n};\\n```\\n# Code of interative version\\n```\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        int n = s.size();\\n        vector<int> dp(n+1, n); \\n        dp[n]=0;\\n        for (int i=n-1; i >= 0; i--) {\\n            for (string& w : dictionary) {\\n                int wLen = w.size();\\n                if (i+wLen<=n && s.substr(i, wLen) == w) {\\n                    dp[i] = min(dp[i], dp[i+wLen]);\\n                }\\n            }\\n            dp[i] = min(dp[i], dp[i+1]+1); // Add an extra character\\n        }\\n\\n        return dp[0];\\n    }\\n};\\n\\n```\\n# Remark on Searching on method using Trie\\n\\nThe insert part is just in use of Trie class. The crucial part is \"search\". Let me copy the usual method search in class Trie:\\n```\\nbool search(string word) {\\n      TrieNode* Node = root;\\n        for(char c : word){\\n            int i = c - \\'a\\';\\n            if(Node->links[i]==NULL) return 0;\\n            Node = Node->links[i];\\n        }\\n        return Node->isEnd;  \\n    }\\n```\\nIn the code solving the problem, it is modified as follows\\n```\\ndp[i]=dp[i+1]+1;\\nTrieNode* node=trie.root;\\n    for (int j=i; j<n; j++) {\\n        if (node->links[s[j]-\\'a\\']==NULL) break;//next i--\\n            node=node->links[s[j]-\\'a\\'];\\n            if(node->isEnd) //A word in dictionary is found\\n                dp[i]=min(dp[i], dp[j+1]);\\n  ```\\nThe different between these two is, \"search\" method  is searching for a certain specific string word,  and in this question it is also searching, but not for a specific word, but for any word in dictionary. i.e. until node->isEnd==true!\\n# Code using Trie beats 99.92%\\n\\n```\\nstruct TrieNode{\\n    bool isEnd;\\n    TrieNode* links[26];\\n    TrieNode(){\\n        isEnd=0;\\n        fill(links, links+26, (TrieNode*)NULL);\\n    }\\n};\\nclass Trie {\\npublic:\\n    TrieNode* root;\\n    Trie() {\\n        root=new TrieNode();\\n    }\\n    ~Trie(){//destructor\\n        delete root; //avoid memory leaks\\n    }\\n    \\n    void insert(string& word) {\\n        TrieNode* Node=root;\\n        for(char c: word){\\n            int i=c-\\'a\\';\\n            if(Node->links[i]==NULL)\\n                Node->links[i]=new TrieNode();\\n            Node=Node->links[i];\\n        }\\n        Node->isEnd=1;\\n    }\\n    void insert(vector<string>& dictionary){\\n        for(auto& word: dictionary)\\n            insert(word);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        Trie trie;\\n        trie.insert(dictionary);//Insert all words in trie\\n\\n        int n = s.size();\\n        vector<int> dp(n+1, 0);//dp[i]=the minimum extra characters needed for s[i:end]\\n        for (int i=n-1; i>=0; i--) {\\n            dp[i]=dp[i+1]+1;\\n            TrieNode* node=trie.root;\\n            for (int j=i; j<n; j++) {\\n                if (node->links[s[j]-\\'a\\']==NULL) break;//next i--\\n                node=node->links[s[j]-\\'a\\'];\\n                if(node->isEnd) //A word in dictionary is found\\n                    dp[i]=min(dp[i], dp[j+1]);\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Trie",
                    "Recursion",
                    "Memoization"
                ],
                "code": "``` dp[i]=the minimum extra characters needed for s[i:end]!```\n```substr()```\n```find()```\n```len(w)=m```\n```\\nclass Solution {\\npublic:\\n    vector<int> dp;// dp[i]=the minimum extra characters needed for s[i:end]\\n    int n;\\n    int f(int i, string& s, vector<string>& dictionary) {\\n        if (i == n) return 0; // Base case\\n\\n        if (dp[i]!= -1) return dp[i]; \\n        int ans = n; \\n\\n        for (string& w : dictionary) {\\n            int wLen = w.size();\\n            if (i+wLen <= n && s.substr(i, wLen) == w) {\\n            // If the current word matches the substring starting at position i\\n                int extra = f(i+wLen, s, dictionary);\\n                ans = min(ans, extra);\\n            }\\n        }\\n\\n        // The current character is not covered by any word in the dictionary\\n        int noWord = 1 + f(i+1, s, dictionary);\\n\\n        // Take the minimum of using a word or not using a word\\n        ans = min(ans, noWord);\\n\\n        return dp[i]=ans;\\n    }\\n\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        n=s.size();\\n        dp.assign(n, -1); \\n        return f(0, s, dictionary);\\n    }\\n\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> dp;// dp[i]=the minimum extra characters needed for s[i:end]\\n    int n;\\n    int f(int i, string& s, vector<string>& dictionary) {\\n        if (i == n) return 0; // Base case\\n\\n        if (dp[i]!= -1) return dp[i]; \\n        int ans = n; \\n\\n        for (string& w : dictionary) {\\n            int wLen = w.size();\\n            int j=s.find(w, i);// more flexible than substr\\n        //    cout<<j<<\",\";\\n            if (j!=-1) {\\n            // If the current word  is found at j>=i\\n                int extra =(j-i)+f(j+wLen, s, dictionary);\\n                ans = min(ans, extra);\\n            }\\n        }\\n\\n        // The current character is not covered by any word in the dictionary\\n        int noWord = 1+f(i+1, s, dictionary);\\n\\n        // Take the minimum of using a word or not using a word\\n        ans = min(ans, noWord);\\n\\n        return dp[i]=ans;\\n    }\\n\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        n=s.size();\\n        dp.assign(n, -1); \\n        return f(0, s, dictionary);\\n    }\\n\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        int n = s.size();\\n        vector<int> dp(n+1, n); \\n        dp[n]=0;\\n        for (int i=n-1; i >= 0; i--) {\\n            for (string& w : dictionary) {\\n                int wLen = w.size();\\n                if (i+wLen<=n && s.substr(i, wLen) == w) {\\n                    dp[i] = min(dp[i], dp[i+wLen]);\\n                }\\n            }\\n            dp[i] = min(dp[i], dp[i+1]+1); // Add an extra character\\n        }\\n\\n        return dp[0];\\n    }\\n};\\n\\n```\n```\\nbool search(string word) {\\n      TrieNode* Node = root;\\n        for(char c : word){\\n            int i = c - \\'a\\';\\n            if(Node->links[i]==NULL) return 0;\\n            Node = Node->links[i];\\n        }\\n        return Node->isEnd;  \\n    }\\n```\n```\\ndp[i]=dp[i+1]+1;\\nTrieNode* node=trie.root;\\n    for (int j=i; j<n; j++) {\\n        if (node->links[s[j]-\\'a\\']==NULL) break;//next i--\\n            node=node->links[s[j]-\\'a\\'];\\n            if(node->isEnd) //A word in dictionary is found\\n                dp[i]=min(dp[i], dp[j+1]);\\n  ```\n```\\nstruct TrieNode{\\n    bool isEnd;\\n    TrieNode* links[26];\\n    TrieNode(){\\n        isEnd=0;\\n        fill(links, links+26, (TrieNode*)NULL);\\n    }\\n};\\nclass Trie {\\npublic:\\n    TrieNode* root;\\n    Trie() {\\n        root=new TrieNode();\\n    }\\n    ~Trie(){//destructor\\n        delete root; //avoid memory leaks\\n    }\\n    \\n    void insert(string& word) {\\n        TrieNode* Node=root;\\n        for(char c: word){\\n            int i=c-\\'a\\';\\n            if(Node->links[i]==NULL)\\n                Node->links[i]=new TrieNode();\\n            Node=Node->links[i];\\n        }\\n        Node->isEnd=1;\\n    }\\n    void insert(vector<string>& dictionary){\\n        for(auto& word: dictionary)\\n            insert(word);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        Trie trie;\\n        trie.insert(dictionary);//Insert all words in trie\\n\\n        int n = s.size();\\n        vector<int> dp(n+1, 0);//dp[i]=the minimum extra characters needed for s[i:end]\\n        for (int i=n-1; i>=0; i--) {\\n            dp[i]=dp[i+1]+1;\\n            TrieNode* node=trie.root;\\n            for (int j=i; j<n; j++) {\\n                if (node->links[s[j]-\\'a\\']==NULL) break;//next i--\\n                node=node->links[s[j]-\\'a\\'];\\n                if(node->isEnd) //A word in dictionary is found\\n                    dp[i]=min(dp[i], dp[j+1]);\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3568634,
                "title": "python-7-lines-tabulation",
                "content": "# Code\\n```\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        n = len(s)\\n        dp = [n] * (n+1)\\n        for i in range(1,n+1):\\n            for word in dictionary:\\n                if i >= len(word) and s[i - len(word):i] == word:\\n                    dp[i] = min(dp[i], dp[i-len(word)]-len(word))\\n            dp[i] = min(dp[i],dp[i-1])\\n        return dp[n]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        n = len(s)\\n        dp = [n] * (n+1)\\n        for i in range(1,n+1):\\n            for word in dictionary:\\n                if i >= len(word) and s[i - len(word):i] == word:\\n                    dp[i] = min(dp[i], dp[i-len(word)]-len(word))\\n            dp[i] = min(dp[i],dp[i-1])\\n        return dp[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569433,
                "title": "c-simple-solution-using-memo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe helper function recursively tries to find words from dict in the string s. It stores previously calculated results in the memo map to avoid redundant calculations. It iterates over each word in dict and checks if it occurs in s. If found, it recursively calls itself on the substrings before and after the word, calculates the length of the formed string, and stores the maximum length.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    unordered_map<string, int> memo; // Memoization table\\n    int helper(string s, vector<string>& dict) {\\n        if (memo.count(s)) {\\n            return memo[s];\\n        }\\n        int maxi = 0;\\n        for (int i = 0; i < dict.size(); i++) {\\n            size_t b = s.find(dict[i]);\\n            if (b != string::npos) {\\n                int a = helper(s.substr(0, b), dict) + helper(s.substr(b + dict[i].size()), dict);\\n                a += dict[i].size();\\n                maxi = max(a, maxi);\\n            }\\n        }\\n        memo[s] = maxi; // Store the result in the memoization table\\n        return maxi;\\n    }\\n    \\n    int minExtraChar(string s, vector<string>& dict) {\\n        int n = s.size();\\n        return n - helper(s, dict);\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    unordered_map<string, int> memo; // Memoization table\\n    int helper(string s, vector<string>& dict) {\\n        if (memo.count(s)) {\\n            return memo[s];\\n        }\\n        int maxi = 0;\\n        for (int i = 0; i < dict.size(); i++) {\\n            size_t b = s.find(dict[i]);\\n            if (b != string::npos) {\\n                int a = helper(s.substr(0, b), dict) + helper(s.substr(b + dict[i].size()), dict);\\n                a += dict[i].size();\\n                maxi = max(a, maxi);\\n            }\\n        }\\n        memo[s] = maxi; // Store the result in the memoization table\\n        return maxi;\\n    }\\n    \\n    int minExtraChar(string s, vector<string>& dict) {\\n        int n = s.size();\\n        return n - helper(s, dict);\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991255,
                "title": "java-dp-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to break or partition the string such that maximum partitions are present in dictionary. The summation of length of partitions not present in dictionary will be our result.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ndp[i] denotes how many extra characters are left when we consider the substring [0, i].\\n\\nAt each index i, we will try to partition at all previous indices and check if partition [j + 1, i] is present in dictionary or not.\\n\\n# Case - 1 : Partition [j + 1, i] is present in dictionary\\n\\nSince, our current partition is present in dictionary, our result will be that of the previous partitions.\\n\\nExample : For \"leetscode\", let us assume we create a partition at index 4.\\nOur two partitions will be\\n# leets | code\\nSince, \"code\" is present in string our result will be the number of extra characters in \"leets\", i.e, 1.\\n\\n\\n\\n# Case - 2 : Partition [j + 1, i] is not present in dictionary\\n\\nSince, our current partition is not present in dictionary, our complete partition will constitute the extra characters in result.\\nHence, our result will be that of the previous partitions + length of current partition.\\n\\nExample : For \"leetscod\", let us assume we create a partition at index 4.\\nOur two partitions will be\\n# leets | cod\\nSince, \"cod\" is present in string our result will be the number of extra characters in \"leets\", i.e, 1 and length of current partition, i.e, 3\\nHence, our result will be 1 + 3 = 4;\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        \\n        int n = s.length();\\n\\n        Set<String> dict = new HashSet<>();\\n\\n        for (String word : dictionary) {\\n            dict.add(word);\\n        }\\n\\n        int[] dp = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n\\n            dp[i] = dict.contains(s.substring(0, i + 1)) ? 0 : i + 1;\\n\\n            for (int j = 0; j < i; j++) {\\n\\n                String partition = s.substring(j + 1, i + 1);\\n\\n                if (dict.contains(partition)) {\\n                    dp[i] = Math.min(dp[i], dp[j]);\\n                } else {\\n                    dp[i] = Math.min(dp[i], dp[j] + i - j); // i - j = partition.length()\\n                }\\n            }\\n        }\\n\\n        return dp[n - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        \\n        int n = s.length();\\n\\n        Set<String> dict = new HashSet<>();\\n\\n        for (String word : dictionary) {\\n            dict.add(word);\\n        }\\n\\n        int[] dp = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n\\n            dp[i] = dict.contains(s.substring(0, i + 1)) ? 0 : i + 1;\\n\\n            for (int j = 0; j < i; j++) {\\n\\n                String partition = s.substring(j + 1, i + 1);\\n\\n                if (dict.contains(partition)) {\\n                    dp[i] = Math.min(dp[i], dp[j]);\\n                } else {\\n                    dp[i] = Math.min(dp[i], dp[j] + i - j); // i - j = partition.length()\\n                }\\n            }\\n        }\\n\\n        return dp[n - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991665,
                "title": "from-50-to-96-with-similar-problems",
                "content": "# Similar Problems:\\nI would highly recommend you to study the following problems before jumping into this problem:\\n\\n- [131. Word Break](https://leetcode.com/problems/word-break/)\\n- [208. Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/)\\n\\n# Solving Word Break:\\n\\n``` java []\\nclass Solution {\\n    int n;\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        n = s.length();\\n        Boolean[] memo = new Boolean[n];\\n        return wordBreak(0, s, new HashSet<>(wordDict), memo);\\n    }\\n    boolean wordBreak(int idx, String s, Set<String> dict, Boolean[] memo) {\\n        if(idx == n) {\\n            return true;\\n        }\\n        if(memo[idx]!=null) {\\n            return memo[idx];\\n        }\\n        // read i as end and idx as start, it will be easy to understand\\n        for(int i=idx+1; i<=n; i++) {\\n            if(dict.contains(s.substring(idx, i))&&wordBreak(i, s, dict, memo)) {\\n                return memo[idx] = true;\\n            }\\n        }\\n        return memo[idx] = false;\\n    }\\n}\\n```\\n\\n# HashSet + Recursion: (TLE)\\n\\n**Can we implement in similar fashion? Instead of keeping true or false, we should keep the penalty or unmatched words.**\\n\\n``` java []\\nclass Solution {\\n    int n;\\n    public int minExtraChar(String s, String[] dictionary) {\\n        n = s.length();\\n        Set<String> dict = new HashSet<>(Arrays.asList(dictionary));\\n        return recurse(0, s, dict);\\n    }\\n    int recurse(int start, String s, Set<String> dict) {\\n        if(start == n) {\\n            return 0;\\n        }\\n\\n        int localMin = Integer.MAX_VALUE;\\n\\n        for(int end=start+1; end<=n; end++) {\\n            // in c++ substring(start index, end index)\\n            // but in java substring(start index, length)\\n            // For example, if start = 0 and end = 1\\n            // this means s.substring will take only 1 character\\n            // starting from 0\\n            String cur = s.substring(start, end);\\n            if(dict.contains(cur)) {\\n                localMin = Math.min(localMin, recurse(end, s, dict));\\n            }\\n            else {\\n                // length of the string we weren\\'t able to take is end - start\\n                // We haven\\'t considered character of <index end> that\\'s why we recurse from index end.\\n                localMin = Math.min(localMin, end-start + recurse(end, s, dict));\\n            }\\n        }\\n        return localMin;\\n    }\\n}\\n```\\n\\n# [Accepted] HashSet + Recursion + Memoization:\\n\\nWe can easily memoize the above solution to avoid unnecessary calculations.\\n\\n``` java []\\nclass Solution {\\n    int n;\\n    public int minExtraChar(String s, String[] dictionary) {\\n        n = s.length();\\n        int[] memo = new int[n];\\n        Arrays.fill(memo, -1);\\n        Set<String> dict = new HashSet<>(Arrays.asList(dictionary));\\n        return recurse(0, s, dict, memo);\\n    }\\n    int recurse(int idx, String s, Set<String> dict, int[] memo) {\\n        if(start == n) {\\n            return 0;\\n        }\\n        if(memo[start]!=-1) {\\n            return memo[start];\\n        }\\n        int localMin = Integer.MAX_VALUE;\\n        for(int end=start+1; end<=n; end++) {\\n            // in c++ substring(start index, end index)\\n            // but in java substring(start index, length)\\n            // For example, if start = 0 and end = 1\\n            // this means s.substring will take only 1 character\\n            // starting from 0\\n            String cur = s.substring(start, end);\\n            if(dict.contains(cur)) {\\n                localMin = Math.min(localMin, recurse(end, s, dict, memo));\\n            }\\n            else {\\n                // length of the string we weren\\'t able to take is end - start\\n                // We haven\\'t considered character of <index end> that\\'s why we recurse from index end.\\n                localMin = Math.min(localMin, end-start + recurse(end, s, dict, memo));\\n            }\\n        }\\n        return memo[start] = localMin;\\n    }\\n}\\n```\\n![image.png](https://assets.leetcode.com/users/images/bc5c1794-0336-4bac-9f9f-5695f976b23e_1693646146.8103633.png)\\n\\n## What if we use some other datastructure instead of HashSet?\\n\\n# [Accepted] Using Trie: (Beats 98%)\\n\\nTrie (we pronounce \"try\") or prefix tree is a tree data structure, which is used for retrieval of a key in a dataset of strings. There are various applications of this very efficient data structure such as :\\n- Auto Completion\\n- Genome Sequencing in Bioinformatics\\n- Spell Checker\\n- IP Routing (Longest Prefix Matching)\\n\\n``` java []\\nclass Solution {\\n    int n;\\n    TrieNode root;\\n\\n    public int minExtraChar(String s, String[] dictionary) {\\n        n = s.length();\\n        int[] memo = new int[n];\\n        Arrays.fill(memo, -1);\\n        buildTrie(dictionary);\\n        return recurse(0, s, memo);\\n    }\\n\\n    int recurse(int start, String s, int[] memo) {\\n        if(start == n) {\\n            return 0;\\n        }\\n        if(memo[start]!=-1) {\\n            return memo[start];\\n        }\\n        TrieNode node = root;\\n        // To count this character as a left over character \\n        // move to index \\'start + 1\\'\\n        int localMin = recurse(start+1, s, memo) + 1;\\n\\n        for(int i=start; i<n; i++) {\\n            char ch = s.charAt(i);\\n            if(!node.containsChild(ch)) {\\n                break;\\n            }\\n            node = node.getChild(ch);\\n            if(node.isWord) {\\n                localMin = Math.min(localMin, recurse(i+1, s, memo));\\n            }\\n        }\\n        return memo[start] = localMin;\\n    }\\n\\n    void buildTrie(String[] words) {\\n        root = new TrieNode();\\n        for(String word : words) {\\n            insert(word);\\n        }\\n    }\\n\\n    public void insert(String word) {\\n        TrieNode node = root;\\n        for(char c: word.toCharArray()) {\\n            if(!node.containsChild(c))\\n                node.addChild(c);\\n            \\n            node = node.getChild(c);\\n        }\\n        node.isWord = true;\\n    }\\n}\\nclass TrieNode {\\n    Map<Character, TrieNode> children;\\n    boolean isWord;\\n    \\n    public TrieNode() {\\n        this.children = new HashMap<>();\\n        this.isWord = false;\\n    }\\n    \\n    public boolean containsChild(char c) {\\n        return children.containsKey(c);\\n    }\\n    \\n    public TrieNode getChild(char c) {\\n        return children.get(c);\\n    }\\n    \\n    public void addChild(char c) {\\n        TrieNode node = new TrieNode();\\n        this.children.put(c, node);\\n    }\\n}\\n```\\n![image.png](https://assets.leetcode.com/users/images/232e73b4-7f5f-453a-bb4a-749a6f625090_1693647559.971768.png)\\n\\n\\n![No Upvotes, Have a Good Day.png](https://assets.leetcode.com/users/images/2877dc3d-2d1e-4e2a-a512-7e2d2c8681c2_1693647070.0448112.png)\\n\\nTakes a lot of time and effort to write a solution!!",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Dynamic Programming",
                    "Trie",
                    "Recursion",
                    "Memoization"
                ],
                "code": "``` java []\\nclass Solution {\\n    int n;\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        n = s.length();\\n        Boolean[] memo = new Boolean[n];\\n        return wordBreak(0, s, new HashSet<>(wordDict), memo);\\n    }\\n    boolean wordBreak(int idx, String s, Set<String> dict, Boolean[] memo) {\\n        if(idx == n) {\\n            return true;\\n        }\\n        if(memo[idx]!=null) {\\n            return memo[idx];\\n        }\\n        // read i as end and idx as start, it will be easy to understand\\n        for(int i=idx+1; i<=n; i++) {\\n            if(dict.contains(s.substring(idx, i))&&wordBreak(i, s, dict, memo)) {\\n                return memo[idx] = true;\\n            }\\n        }\\n        return memo[idx] = false;\\n    }\\n}\\n```\n``` java []\\nclass Solution {\\n    int n;\\n    public int minExtraChar(String s, String[] dictionary) {\\n        n = s.length();\\n        Set<String> dict = new HashSet<>(Arrays.asList(dictionary));\\n        return recurse(0, s, dict);\\n    }\\n    int recurse(int start, String s, Set<String> dict) {\\n        if(start == n) {\\n            return 0;\\n        }\\n\\n        int localMin = Integer.MAX_VALUE;\\n\\n        for(int end=start+1; end<=n; end++) {\\n            // in c++ substring(start index, end index)\\n            // but in java substring(start index, length)\\n            // For example, if start = 0 and end = 1\\n            // this means s.substring will take only 1 character\\n            // starting from 0\\n            String cur = s.substring(start, end);\\n            if(dict.contains(cur)) {\\n                localMin = Math.min(localMin, recurse(end, s, dict));\\n            }\\n            else {\\n                // length of the string we weren\\'t able to take is end - start\\n                // We haven\\'t considered character of <index end> that\\'s why we recurse from index end.\\n                localMin = Math.min(localMin, end-start + recurse(end, s, dict));\\n            }\\n        }\\n        return localMin;\\n    }\\n}\\n```\n``` java []\\nclass Solution {\\n    int n;\\n    public int minExtraChar(String s, String[] dictionary) {\\n        n = s.length();\\n        int[] memo = new int[n];\\n        Arrays.fill(memo, -1);\\n        Set<String> dict = new HashSet<>(Arrays.asList(dictionary));\\n        return recurse(0, s, dict, memo);\\n    }\\n    int recurse(int idx, String s, Set<String> dict, int[] memo) {\\n        if(start == n) {\\n            return 0;\\n        }\\n        if(memo[start]!=-1) {\\n            return memo[start];\\n        }\\n        int localMin = Integer.MAX_VALUE;\\n        for(int end=start+1; end<=n; end++) {\\n            // in c++ substring(start index, end index)\\n            // but in java substring(start index, length)\\n            // For example, if start = 0 and end = 1\\n            // this means s.substring will take only 1 character\\n            // starting from 0\\n            String cur = s.substring(start, end);\\n            if(dict.contains(cur)) {\\n                localMin = Math.min(localMin, recurse(end, s, dict, memo));\\n            }\\n            else {\\n                // length of the string we weren\\'t able to take is end - start\\n                // We haven\\'t considered character of <index end> that\\'s why we recurse from index end.\\n                localMin = Math.min(localMin, end-start + recurse(end, s, dict, memo));\\n            }\\n        }\\n        return memo[start] = localMin;\\n    }\\n}\\n```\n``` java []\\nclass Solution {\\n    int n;\\n    TrieNode root;\\n\\n    public int minExtraChar(String s, String[] dictionary) {\\n        n = s.length();\\n        int[] memo = new int[n];\\n        Arrays.fill(memo, -1);\\n        buildTrie(dictionary);\\n        return recurse(0, s, memo);\\n    }\\n\\n    int recurse(int start, String s, int[] memo) {\\n        if(start == n) {\\n            return 0;\\n        }\\n        if(memo[start]!=-1) {\\n            return memo[start];\\n        }\\n        TrieNode node = root;\\n        // To count this character as a left over character \\n        // move to index \\'start + 1\\'\\n        int localMin = recurse(start+1, s, memo) + 1;\\n\\n        for(int i=start; i<n; i++) {\\n            char ch = s.charAt(i);\\n            if(!node.containsChild(ch)) {\\n                break;\\n            }\\n            node = node.getChild(ch);\\n            if(node.isWord) {\\n                localMin = Math.min(localMin, recurse(i+1, s, memo));\\n            }\\n        }\\n        return memo[start] = localMin;\\n    }\\n\\n    void buildTrie(String[] words) {\\n        root = new TrieNode();\\n        for(String word : words) {\\n            insert(word);\\n        }\\n    }\\n\\n    public void insert(String word) {\\n        TrieNode node = root;\\n        for(char c: word.toCharArray()) {\\n            if(!node.containsChild(c))\\n                node.addChild(c);\\n            \\n            node = node.getChild(c);\\n        }\\n        node.isWord = true;\\n    }\\n}\\nclass TrieNode {\\n    Map<Character, TrieNode> children;\\n    boolean isWord;\\n    \\n    public TrieNode() {\\n        this.children = new HashMap<>();\\n        this.isWord = false;\\n    }\\n    \\n    public boolean containsChild(char c) {\\n        return children.containsKey(c);\\n    }\\n    \\n    public TrieNode getChild(char c) {\\n        return children.get(c);\\n    }\\n    \\n    public void addChild(char c) {\\n        TrieNode node = new TrieNode();\\n        this.children.put(c, node);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990725,
                "title": "c-recursive-dp-solution-memoization-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, int> mp;\\n    int solve(int i, int prev, string &s, vector<vector<int>> &dp)\\n    {\\n        int case1 = 1e9, case2 = 1e9;\\n        string temp = s.substr(prev, i - prev + 1);\\n        if(i == s.size() - 1)\\n        {\\n            if(mp[temp])\\n                return 0;\\n            \\n            return (i - prev + 1);\\n        }\\n        \\n        if(dp[i][prev] != -1)\\n            return dp[i][prev];\\n        \\n        if(mp[temp])\\n        {\\n            case1 = solve(i + 1, i + 1, s, dp);\\n            case2 = solve(i + 1, prev, s, dp);\\n            return dp[i][prev] = min(case1, case2);\\n        }\\n        else\\n        {\\n            case1 = (i - prev + 1) + solve(i + 1, i + 1, s, dp);\\n            case2 = solve(i + 1, prev, s, dp);\\n            return dp[i][prev] = min(case1, case2);\\n        }\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        int n = s.size();\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        mp.clear();\\n        for(auto word : dictionary)\\n            mp[word]++;\\n        \\n        return solve(0, 0, s, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string, int> mp;\\n    int solve(int i, int prev, string &s, vector<vector<int>> &dp)\\n    {\\n        int case1 = 1e9, case2 = 1e9;\\n        string temp = s.substr(prev, i - prev + 1);\\n        if(i == s.size() - 1)\\n        {\\n            if(mp[temp])\\n                return 0;\\n            \\n            return (i - prev + 1);\\n        }\\n        \\n        if(dp[i][prev] != -1)\\n            return dp[i][prev];\\n        \\n        if(mp[temp])\\n        {\\n            case1 = solve(i + 1, i + 1, s, dp);\\n            case2 = solve(i + 1, prev, s, dp);\\n            return dp[i][prev] = min(case1, case2);\\n        }\\n        else\\n        {\\n            case1 = (i - prev + 1) + solve(i + 1, i + 1, s, dp);\\n            case2 = solve(i + 1, prev, s, dp);\\n            return dp[i][prev] = min(case1, case2);\\n        }\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        int n = s.size();\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        mp.clear();\\n        for(auto word : dictionary)\\n            mp[word]++;\\n        \\n        return solve(0, 0, s, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569107,
                "title": "java-recursion-recursion-with-memoization-dp-with-explanation",
                "content": "Here is a recursion tree of the example `abcd`:\\n```\\n\\t\\t\\t\\t\\t                             Extra(abcd)\\n\\t\\t\\t\\t\\t       /                         |                         \\\\\\n\\t\\t\\t   a + Extra(bcd)                  ab + Extra(cd)                  abc + Extra(d)\\t \\n\\t\\t\\t  /              \\\\                       |   \\n\\ta + b + Extra(cd)     a + bc + Extra(d)    ab + c + Extra(d)\\n```\\n\\nWe observe for every string with length `n`, we have n choices:\\n```\\n1. [0, 0] + Extra(0, n),\\n2. [0, 1] + Extra(1, n),\\n3. [0, 2] + Extra(2, n),\\n...\\nn. [0, n - 1]\\n```\\nAnd `Extra(0, n)` is the maximum of those n choices.\\n\\n\\nRecursion (TLE):\\n```\\nclass Solution {\\n    Set<String> words;\\n    public int minExtraChar(String s, String[] dictionary) {\\n        words = new HashSet<>(Arrays.asList(dictionary));\\n        return dfs(s);\\n    }\\n    private int dfs(String s) {\\n        if (s.length() == 0) return 0;\\n        int res = s.length();\\n        for (int i = 0; i < s.length(); i++) {\\n            String str = s.substring(0, i + 1);\\n            int curExtra = words.contains(str) ? 0 : i + 1;\\n            res = Math.min(res, curExtra + dfs(s.substring(i + 1)));\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n\\nRecursion with Memoization:\\nC++:\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<vector<int>> memo;\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        n = s.size();\\n        memo.resize(n, vector<int>(n, n + 1));\\n        unordered_set<string> words(dictionary.begin(), dictionary.end());\\n        return dfs(0, s, words);\\n    }\\n    int dfs(int index, string& s, unordered_set<string>& words) {\\n        if (index == s.size()) return 0;\\n        if (memo[index][s.size() - 1 - index] != n + 1) \\n            return memo[index][s.size() - 1 - index];\\n        int res = s.size() - index;\\n        for (int i = index; i < s.size(); i++) {\\n            string str = s.substr(index, i + 1 - index);\\n            int curExtra = words.find(str) == words.end() ? i + 1 - index : 0;\\n            res = min(res, curExtra + dfs(i + 1, s, words));\\n        }\\n        memo[index][s.size() - 1 - index] = res;\\n        return res;\\n    }\\n};\\n```\\nJava:\\n```\\nclass Solution {\\n    int n;\\n    int[][] memo;\\n    public int minExtraChar(String s, String[] dictionary) {\\n        n = s.length();\\n        memo = new int[n][n];\\n        for (int i = 0; i < n; i++) Arrays.fill(memo[i], n);\\n        Set<String> words = new HashSet<>(Arrays.asList(dictionary));\\n        return dfs(0, s, words);\\n    }\\n    private int dfs(int index, String s, Set<String> words) {\\n        if (s.length() == 0) return 0;\\n        if (memo[index][s.length() - 1] != n) return memo[index][s.length() - 1];\\n        int res = s.length();\\n        for (int i = 0; i < s.length(); i++) {\\n            String str = s.substring(0, i + 1);\\n            int curExtra = words.contains(str) ? 0 : i + 1;\\n            res = Math.min(res, curExtra + dfs(i + 1, s.substring(i + 1), words));\\n        }\\n        memo[index][s.length() - 1] = res;\\n        return res;\\n    }\\n}\\n```\\n\\n\\nDP:\\nLet `dp[i]: minimum number of extra character in s[0:i]`,\\nand we have\\n```\\ndp[i] = dp[j - 1], if s[i, j] is in the dictionary\\ndp[i] = dp[j - 1] + i - j + 1, otherwise\\n```\\n\\n```\\nclass Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        int n = s.length();\\n        Set<String> words = new HashSet<>(Arrays.asList(dictionary));\\n        int[] dp = new int[n + 1];\\n        Arrays.fill(dp, n + 1);\\n        dp[0] = 0;\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                String str = s.substring(j, i);\\n                if (words.contains(str)) {\\n                    dp[i] = Math.min(dp[i], dp[j]);\\n                } else {\\n                    dp[i] = Math.min(dp[i], dp[j] + i - j);\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\t\\t\\t\\t                             Extra(abcd)\\n\\t\\t\\t\\t\\t       /                         |                         \\\\\\n\\t\\t\\t   a + Extra(bcd)                  ab + Extra(cd)                  abc + Extra(d)\\t \\n\\t\\t\\t  /              \\\\                       |   \\n\\ta + b + Extra(cd)     a + bc + Extra(d)    ab + c + Extra(d)\\n```\n```\\n1. [0, 0] + Extra(0, n),\\n2. [0, 1] + Extra(1, n),\\n3. [0, 2] + Extra(2, n),\\n...\\nn. [0, n - 1]\\n```\n```\\nclass Solution {\\n    Set<String> words;\\n    public int minExtraChar(String s, String[] dictionary) {\\n        words = new HashSet<>(Arrays.asList(dictionary));\\n        return dfs(s);\\n    }\\n    private int dfs(String s) {\\n        if (s.length() == 0) return 0;\\n        int res = s.length();\\n        for (int i = 0; i < s.length(); i++) {\\n            String str = s.substring(0, i + 1);\\n            int curExtra = words.contains(str) ? 0 : i + 1;\\n            res = Math.min(res, curExtra + dfs(s.substring(i + 1)));\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<vector<int>> memo;\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        n = s.size();\\n        memo.resize(n, vector<int>(n, n + 1));\\n        unordered_set<string> words(dictionary.begin(), dictionary.end());\\n        return dfs(0, s, words);\\n    }\\n    int dfs(int index, string& s, unordered_set<string>& words) {\\n        if (index == s.size()) return 0;\\n        if (memo[index][s.size() - 1 - index] != n + 1) \\n            return memo[index][s.size() - 1 - index];\\n        int res = s.size() - index;\\n        for (int i = index; i < s.size(); i++) {\\n            string str = s.substr(index, i + 1 - index);\\n            int curExtra = words.find(str) == words.end() ? i + 1 - index : 0;\\n            res = min(res, curExtra + dfs(i + 1, s, words));\\n        }\\n        memo[index][s.size() - 1 - index] = res;\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int n;\\n    int[][] memo;\\n    public int minExtraChar(String s, String[] dictionary) {\\n        n = s.length();\\n        memo = new int[n][n];\\n        for (int i = 0; i < n; i++) Arrays.fill(memo[i], n);\\n        Set<String> words = new HashSet<>(Arrays.asList(dictionary));\\n        return dfs(0, s, words);\\n    }\\n    private int dfs(int index, String s, Set<String> words) {\\n        if (s.length() == 0) return 0;\\n        if (memo[index][s.length() - 1] != n) return memo[index][s.length() - 1];\\n        int res = s.length();\\n        for (int i = 0; i < s.length(); i++) {\\n            String str = s.substring(0, i + 1);\\n            int curExtra = words.contains(str) ? 0 : i + 1;\\n            res = Math.min(res, curExtra + dfs(i + 1, s.substring(i + 1), words));\\n        }\\n        memo[index][s.length() - 1] = res;\\n        return res;\\n    }\\n}\\n```\n```\\ndp[i] = dp[j - 1], if s[i, j] is in the dictionary\\ndp[i] = dp[j - 1] + i - j + 1, otherwise\\n```\n```\\nclass Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        int n = s.length();\\n        Set<String> words = new HashSet<>(Arrays.asList(dictionary));\\n        int[] dp = new int[n + 1];\\n        Arrays.fill(dp, n + 1);\\n        dp[0] = 0;\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                String str = s.substring(j, i);\\n                if (words.contains(str)) {\\n                    dp[i] = Math.min(dp[i], dp[j]);\\n                } else {\\n                    dp[i] = Math.min(dp[i], dp[j] + i - j);\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568836,
                "title": "dynamic-programming-pick-not-pick-easy-c-commented-code",
                "content": "### Do Upvote if it helps !!\\n\\n# Complexity\\n- Time complexity:O(N^3)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)+O(M.K)(for map) \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string,int> mp;\\n    int n;\\n    int solve(string &s,int idx,vector<int> &dp){\\n        if(idx>=n){\\n            return 0;\\n        }\\n        \\n        \\n        if(dp[idx]!=-1){\\n            return dp[idx];\\n        }\\n        \\n        //ignoring current index(not picking)\\n        string temp=\"\";\\n        int ans=solve(s,idx+1,dp);\\n\\n        //considering all possible strings(multiple picks)\\n        for(int i=idx ; i<n ; i++){\\n            temp+=s[i];\\n            if(mp[temp]){\\n                ans=max(ans,(int)temp.size()+(int)solve(s,i+1,dp));\\n            }\\n        }\\n        \\n        return dp[idx]=ans;\\n    }\\n    \\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        n=s.size();\\n        vector<int> dp(n+1,-1);\\n        for(auto e : dictionary){\\n            mp[e]=1;\\n        }\\n        return n-solve(s,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,int> mp;\\n    int n;\\n    int solve(string &s,int idx,vector<int> &dp){\\n        if(idx>=n){\\n            return 0;\\n        }\\n        \\n        \\n        if(dp[idx]!=-1){\\n            return dp[idx];\\n        }\\n        \\n        //ignoring current index(not picking)\\n        string temp=\"\";\\n        int ans=solve(s,idx+1,dp);\\n\\n        //considering all possible strings(multiple picks)\\n        for(int i=idx ; i<n ; i++){\\n            temp+=s[i];\\n            if(mp[temp]){\\n                ans=max(ans,(int)temp.size()+(int)solve(s,i+1,dp));\\n            }\\n        }\\n        \\n        return dp[idx]=ans;\\n    }\\n    \\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        n=s.size();\\n        vector<int> dp(n+1,-1);\\n        for(auto e : dictionary){\\n            mp[e]=1;\\n        }\\n        return n-solve(s,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568731,
                "title": "dp-exact-similar-problems-c-image-attached-for-reference",
                "content": "**NOTE:** Try to generate all substring.I have made a detailed video of same solution on my youtube please search \"coding samurais\" on youtube or simply click my profile icon you will find the link.\\n\\n**string**= \"lelest\"\\n**dictionary**= [\"les\",\"st\"]\\n\\n![image](https://assets.leetcode.com/users/images/55f84453-f20f-4ecf-815f-46e120573f56_1685554825.9600222.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n    unordered_map<string,int> d;\\n\\n    for (const string& word : dictionary) {\\n        d[word]=1;\\n    }\\n\\n    int n = s.length();\\n    vector<int> dp(n + 1);\\n    for (int i = 1; i <= n; i++) {\\n        dp[i] = dp[i - 1] + 1;\\n\\n        for (int j = i; j >= 1; j--) {\\n            string sub = s.substr(j - 1, i - j+1);\\n            \\n            if (d[sub] > 0) {\\n                dp[i] = min(dp[i], dp[j - 1]);\\n            }\\n        }\\n        cout<<endl;\\n    }\\n\\n \\xA0\\xA0\\xA0return\\xA0dp[n];\\n    }\\n};\\n```\\n**Exact similar problem:** [Word break](https://leetcode.com/problems/word-break/)\\n You can submit this same code to above problem it will run (just replace return dp[n] with return dp[n]==0 because in word break problem we have to return boolean value). Word Break problem is very very famouse interview problem.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n    unordered_map<string,int> d;\\n\\n    for (const string& word : dictionary) {\\n        d[word]=1;\\n    }\\n\\n    int n = s.length();\\n    vector<int> dp(n + 1);\\n    for (int i = 1; i <= n; i++) {\\n        dp[i] = dp[i - 1] + 1;\\n\\n        for (int j = i; j >= 1; j--) {\\n            string sub = s.substr(j - 1, i - j+1);\\n            \\n            if (d[sub] > 0) {\\n                dp[i] = min(dp[i], dp[j - 1]);\\n            }\\n        }\\n        cout<<endl;\\n    }\\n\\n \\xA0\\xA0\\xA0return\\xA0dp[n];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3990538,
                "title": "python3-99-87-faster-beats-only-11-lines-clean-solution",
                "content": "\\n![image.png](https://assets.leetcode.com/users/images/a1882a54-b8e7-4e63-95ef-98f7c1a37609_1693623035.3575118.png)\\n\\n\\n# Complexity\\n- Time complexity: o(n^m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        dictionary = set(dictionary)\\n        n,dp = len(s),[0]\\n        max_word_len = len(max(dictionary, key=len))\\n        for i in range(1,n+1):\\n            dp.append(dp[-1]+1)\\n            for j in range(i-1,max(i-max_word_len-1,-1),-1):\\n                if s[j:i] in dictionary:\\n                    dp[i] = min(dp[i],dp[j])\\n        return dp[-1]\\n\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        dictionary = set(dictionary)\\n        n,dp = len(s),[0]\\n        max_word_len = len(max(dictionary, key=len))\\n        for i in range(1,n+1):\\n            dp.append(dp[-1]+1)\\n            for j in range(i-1,max(i-max_word_len-1,-1),-1):\\n                if s[j:i] in dictionary:\\n                    dp[i] = min(dp[i],dp[j])\\n        return dp[-1]\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568974,
                "title": "100-beats-dp-memoization-c",
                "content": "````\\nclass Solution {\\npublic:\\n    int solve(int i,int &n,string &str,unordered_set<string> &s,vector<int> &dp){\\n        if(i>=n)return 0;\\n        if(dp[i] != -1)return dp[i];\\n        int a = 1+solve(i+1,n,str,s,dp);\\n        string s1 = \"\";\\n        for(int j = i; j < n; j++){\\n            s1 += str[j];\\n            if(s.count(s1)){\\n                a = min(a,solve(j+1,n,str,s,dp));\\n            }\\n        }\\n        return dp[i] = a;\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        int n = s.length();\\n        vector<int> dp(n,-1);\\n        unordered_set<string> st;\\n        for(auto &i: dictionary){\\n            st.insert(i);\\n        }\\n        return solve(0,n,s,st,dp);\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int solve(int i,int &n,string &str,unordered_set<string> &s,vector<int> &dp){\\n        if(i>=n)return 0;\\n        if(dp[i] != -1)return dp[i];\\n        int a = 1+solve(i+1,n,str,s,dp);\\n        string s1 = \"\";\\n        for(int j = i; j < n; j++){\\n            s1 += str[j];\\n            if(s.count(s1)){\\n                a = min(a,solve(j+1,n,str,s,dp));\\n            }\\n        }\\n        return dp[i] = a;\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        int n = s.length();\\n        vector<int> dp(n,-1);\\n        unordered_set<string> st;\\n        for(auto &i: dictionary){\\n            st.insert(i);\\n        }\\n        return solve(0,n,s,st,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991431,
                "title": "easy-java-solution-using-memoization",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        Integer[] dp = new Integer[s.length()];\\n\\n        HashSet<String> dict = new HashSet<>(Arrays.asList(dictionary));\\n\\n        return memo(dict,new StringBuilder(s),0,dp);\\n    }\\n\\n    private int memo(HashSet<String> dict, StringBuilder s, int index,Integer[] dp){\\n        if(s.length() == index){\\n            return 0;\\n        }\\n\\n        if(dp[index] != null){\\n            return dp[index];\\n        }\\n\\n        int ans = memo(dict, s, index+1, dp)+1;\\n\\n        for(int i = index;i < s.length();i++){\\n            String temp = s.substring(index, i+1);\\n\\n            if(dict.contains(temp)){\\n                ans = Math.min(ans,memo(dict, s, i+1, dp));\\n            }\\n        }\\n\\n        return dp[index] = ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        Integer[] dp = new Integer[s.length()];\\n\\n        HashSet<String> dict = new HashSet<>(Arrays.asList(dictionary));\\n\\n        return memo(dict,new StringBuilder(s),0,dp);\\n    }\\n\\n    private int memo(HashSet<String> dict, StringBuilder s, int index,Integer[] dp){\\n        if(s.length() == index){\\n            return 0;\\n        }\\n\\n        if(dp[index] != null){\\n            return dp[index];\\n        }\\n\\n        int ans = memo(dict, s, index+1, dp)+1;\\n\\n        for(int i = index;i < s.length();i++){\\n            String temp = s.substring(index, i+1);\\n\\n            if(dict.contains(temp)){\\n                ans = Math.min(ans,memo(dict, s, i+1, dp));\\n            }\\n        }\\n\\n        return dp[index] = ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990957,
                "title": "putta-easy-solution-c-recursive-memoization",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string,int> mp;\\n    int dfs(int start ,string s,int end,vector<int>& dp ){\\n        if(end >= s.size()) return end-start;\\n        if(dp[start] != -1) return dp[start];\\n        string temp = s.substr(start,end-start+1);\\n        int ans = 1e9;\\n        //pick\\n        if(mp.find(temp) != mp.end()){\\n            ans = dfs(end+1,s,end+1,dp);\\n        }\\n        //not pick\\n        ans = min(ans,dfs(start,s,end+1,dp));\\n        //skip char\\n        ans = min(ans,end-start+1 +dfs(end+1,s,end+1,dp));\\n        return dp[start] = ans;\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n    for(auto word:dictionary){\\n            mp[word]++;\\n        }\\n        int n = s.size();\\n         vector<int> dp(n+1,-1);\\n        return dfs(0,s,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,int> mp;\\n    int dfs(int start ,string s,int end,vector<int>& dp ){\\n        if(end >= s.size()) return end-start;\\n        if(dp[start] != -1) return dp[start];\\n        string temp = s.substr(start,end-start+1);\\n        int ans = 1e9;\\n        //pick\\n        if(mp.find(temp) != mp.end()){\\n            ans = dfs(end+1,s,end+1,dp);\\n        }\\n        //not pick\\n        ans = min(ans,dfs(start,s,end+1,dp));\\n        //skip char\\n        ans = min(ans,end-start+1 +dfs(end+1,s,end+1,dp));\\n        return dp[start] = ans;\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n    for(auto word:dictionary){\\n            mp[word]++;\\n        }\\n        int n = s.size();\\n         vector<int> dp(n+1,-1);\\n        return dfs(0,s,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990417,
                "title": "dp-easy-to-understand-memoization-solution-commently-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(int i, string &s, unordered_map<string, int>& mp, vector<int>& dp) {\\n        // if index exceeds the size return 0 base case\\n        if(i >= s.size()) return 0;\\n        // if already we counted this subproblem then no need to do the whole stuff, use dp array stored result\\n        if(dp[i] != -1) return dp[i];\\n        int ans = s.size();\\n        string st = \"\";\\n        for(int idx = i;idx < s.size();idx++) {\\n            st += s[idx];\\n            int extraString = st.size();\\n            // if string is present in map then extracharacter should be 0\\n            if(mp.find(st) != mp.end()) extraString = 0;\\n            // calling recursive for other smaller problems\\n            int nextSearch = f(idx+1, s, mp, dp);\\n            // storing min ans in ans\\n            ans = min(ans, extraString+nextSearch);\\n        }\\n        // storing dp array for further use of same subproblem\\n        return dp[i] = ans;\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<string, int> mp;\\n        vector<int> dp(s.size(), -1);\\n        // storing the word in dict for checking whether it is present or not\\n        for(auto dict : dictionary) {\\n            mp[dict]=1;\\n        }\\n        // return using memoisation function f\\n        return f(0, s, mp, dp);\\n    }\\n};\\n\\nPlease!! upvote if you like it \\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming",
                    "Memoization",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int i, string &s, unordered_map<string, int>& mp, vector<int>& dp) {\\n        // if index exceeds the size return 0 base case\\n        if(i >= s.size()) return 0;\\n        // if already we counted this subproblem then no need to do the whole stuff, use dp array stored result\\n        if(dp[i] != -1) return dp[i];\\n        int ans = s.size();\\n        string st = \"\";\\n        for(int idx = i;idx < s.size();idx++) {\\n            st += s[idx];\\n            int extraString = st.size();\\n            // if string is present in map then extracharacter should be 0\\n            if(mp.find(st) != mp.end()) extraString = 0;\\n            // calling recursive for other smaller problems\\n            int nextSearch = f(idx+1, s, mp, dp);\\n            // storing min ans in ans\\n            ans = min(ans, extraString+nextSearch);\\n        }\\n        // storing dp array for further use of same subproblem\\n        return dp[i] = ans;\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<string, int> mp;\\n        vector<int> dp(s.size(), -1);\\n        // storing the word in dict for checking whether it is present or not\\n        for(auto dict : dictionary) {\\n            mp[dict]=1;\\n        }\\n        // return using memoisation function f\\n        return f(0, s, mp, dp);\\n    }\\n};\\n\\nPlease!! upvote if you like it \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568922,
                "title": "easy-dp-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n#define ll long long\\nint dp[100][100];\\nint helper(int i , int j,string &s, set<string>&st)\\n{\\n    if(dp[i][j]!=-1) return dp[i][j];\\n    if(j== 0 )return 0;\\n    string chk;\\n    for(int x = 0 ; x < j; x++)\\n    {\\n        chk.push_back(s[x+i]);\\n    }\\n    if(st.find(chk)!=st.end()) return dp[i][j] = 0;\\n    if(j==1) return 1;\\n    int ans = INT_MAX;\\n    for (int x = 1; x < j; ++x)\\n    {\\n        ans = min(ans, helper(i, x, s, st)+ helper(i+x, j-x, s, st));\\n    }\\n    // cout<<i<<\" \"<< j<<\" \"<<ans<<endl;\\n    return dp[i][j]= ans;\\n}\\nint minExtraChar(string s, vector<string>& dictionary) {\\n    set<string>st;\\n    memset(dp, -1, sizeof(dp));\\n    for(auto &t : dictionary) st.insert(t);\\n    return helper(0, s.size(), s, st);\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n#define ll long long\\nint dp[100][100];\\nint helper(int i , int j,string &s, set<string>&st)\\n{\\n    if(dp[i][j]!=-1) return dp[i][j];\\n    if(j== 0 )return 0;\\n    string chk;\\n    for(int x = 0 ; x < j; x++)\\n    {\\n        chk.push_back(s[x+i]);\\n    }\\n    if(st.find(chk)!=st.end()) return dp[i][j] = 0;\\n    if(j==1) return 1;\\n    int ans = INT_MAX;\\n    for (int x = 1; x < j; ++x)\\n    {\\n        ans = min(ans, helper(i, x, s, st)+ helper(i+x, j-x, s, st));\\n    }\\n    // cout<<i<<\" \"<< j<<\" \"<<ans<<endl;\\n    return dp[i][j]= ans;\\n}\\nint minExtraChar(string s, vector<string>& dictionary) {\\n    set<string>st;\\n    memset(dp, -1, sizeof(dp));\\n    for(auto &t : dictionary) st.insert(t);\\n    return helper(0, s.size(), s, st);\\n}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3568747,
                "title": "dp-image-explanantion",
                "content": "\\n\\n\\n![image](https://assets.leetcode.com/users/images/1d092cd1-f034-46e5-9851-21f4d23420c4_1685203978.281522.jpeg)\\n![image](https://assets.leetcode.com/users/images/47d76116-7f79-4a99-ac7b-7d8fb4bd21af_1685203990.1496108.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& d) {\\n        set<string> st;\\n        for(auto it: d){\\n            st.insert(it);\\n        }\\n\\nint n=s.size();\\n        \\n        vector<int> dp(n+1,0);\\n        for (int i = 1; i <= n; i++) \\n        {\\n            dp[i] = dp[i - 1] + 1; \\n\\n            for (int j=i; j >= 1; j--)\\n            {\\n                string su = s.substr(j - 1, i-j+1);\\n\\n                if (st.find(su)!=st.end()) \\n                {\\n                    dp[i] = min(dp[i], dp[j - 1]); \\n                }\\n            }\\n        }\\n\\n        return dp[n];\\n    \\n    }\\n    };```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& d) {\\n        set<string> st;\\n        for(auto it: d){\\n            st.insert(it);\\n        }\\n\\nint n=s.size();\\n        \\n        vector<int> dp(n+1,0);\\n        for (int i = 1; i <= n; i++) \\n        {\\n            dp[i] = dp[i - 1] + 1; \\n\\n            for (int j=i; j >= 1; j--)\\n            {\\n                string su = s.substr(j - 1, i-j+1);\\n\\n                if (st.find(su)!=st.end()) \\n                {\\n                    dp[i] = min(dp[i], dp[j - 1]); \\n                }\\n            }\\n        }\\n\\n        return dp[n];\\n    \\n    }\\n    };```",
                "codeTag": "Java"
            },
            {
                "id": 3568655,
                "title": "c-dp-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        int n = s.size();\\n        vector<int>dp(n+1,0);  \\n        for (int i=n-1;i>=0;i--){\\n            dp[i]= dp[i+1]+1;\\n        for (auto it: dictionary) {\\n            if (s.compare(i,it.size(),it)==0){\\n                dp[i]=min(dp[i],dp[i+it.length()]);\\n            }\\n        }\\n    }\\n\\n    return dp[0];\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        int n = s.size();\\n        vector<int>dp(n+1,0);  \\n        for (int i=n-1;i>=0;i--){\\n            dp[i]= dp[i+1]+1;\\n        for (auto it: dictionary) {\\n            if (s.compare(i,it.size(),it)==0){\\n                dp[i]=min(dp[i],dp[i+it.length()]);\\n            }\\n        }\\n    }\\n\\n    return dp[0];\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568552,
                "title": "python-elegant-short-top-down-dp-commented",
                "content": "# Complexity\\n- Time complexity: $$O(n^{2} * m * l)$$, where $$m$$ - size of dictionary, $$l$$ - max dictionary word length\\n- Space complexity: $$O(n^{2})$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minExtraChar(self, string: str, dictionary: List[str]) -> int:\\n        @cache\\n        def dp(i: int, extra: int) -> int:\\n            if i >= len(string):\\n                return extra\\n\\n            # Base case, we just move on to the next letter\\n            min_extra = dp(i + 1, extra)\\n\\n            # Alternatively, we are trying to remove a word from the string from the current position\\n            for word in dictionary:\\n                # If a word starts at the current position\\n                if string[i:].startswith(word):\\n                    min_extra = min(\\n                        min_extra,\\n                        dp(i + len(word), extra - len(word)),  # Deleting a word may not be optimal\\n                    )\\n\\n            return min_extra\\n\\n        return dp(0, len(string))\\n```\\n\\n# Important\\nIf you like this solution remember to **upvote it** to let me know.\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minExtraChar(self, string: str, dictionary: List[str]) -> int:\\n        @cache\\n        def dp(i: int, extra: int) -> int:\\n            if i >= len(string):\\n                return extra\\n\\n            # Base case, we just move on to the next letter\\n            min_extra = dp(i + 1, extra)\\n\\n            # Alternatively, we are trying to remove a word from the string from the current position\\n            for word in dictionary:\\n                # If a word starts at the current position\\n                if string[i:].startswith(word):\\n                    min_extra = min(\\n                        min_extra,\\n                        dp(i + len(word), extra - len(word)),  # Deleting a word may not be optimal\\n                    )\\n\\n            return min_extra\\n\\n        return dp(0, len(string))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991344,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        int maxVal = s.length() + 1;\\n        int[] dp = new int[s.length() + 1];\\n        Arrays.fill(dp, maxVal);\\n        dp[0] = 0;\\n\\n        Set<String> dictionarySet = new HashSet<>(Arrays.asList(dictionary));\\n\\n        for (int i = 1; i <= s.length(); ++i) {\\n            dp[i] = dp[i - 1] + 1;\\n            for (int l = 1; l <= i; ++l) {\\n                if (dictionarySet.contains(s.substring(i - l, i))) {\\n                    dp[i] = Math.min(dp[i], dp[i - l]);\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        int maxVal = s.length() + 1;\\n        int[] dp = new int[s.length() + 1];\\n        Arrays.fill(dp, maxVal);\\n        dp[0] = 0;\\n\\n        Set<String> dictionarySet = new HashSet<>(Arrays.asList(dictionary));\\n\\n        for (int i = 1; i <= s.length(); ++i) {\\n            dp[i] = dp[i - 1] + 1;\\n            for (int l = 1; l <= i; ++l) {\\n                if (dictionarySet.contains(s.substring(i - l, i))) {\\n                    dp[i] = Math.min(dp[i], dp[i - l]);\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991056,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[51];\\n    int solve(string& s, unordered_set<string>&st, int i)\\n    {\\n        if (i == s.size()) return 0;\\n\\n        if (dp[i] != -1) return dp[i];\\n        \\n        string str = \"\";\\n        int mn = s.size();\\n        for (int j = i; j < s.size(); j++)\\n        {\\n            str+=s[j];\\n            int v=str.size();\\n           if(st.count(str)){\\n             v=0;\\n           }\\n            mn = min(mn, v+solve(s,st,j+1));\\n        }\\n        return dp[i] = mn;\\n    }\\n    int minExtraChar(string s, vector<string>& d) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        unordered_set<string>st;\\n        for (string& x : d){\\n        st.insert(x);\\n        }\\n        return solve(s, st, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[51];\\n    int solve(string& s, unordered_set<string>&st, int i)\\n    {\\n        if (i == s.size()) return 0;\\n\\n        if (dp[i] != -1) return dp[i];\\n        \\n        string str = \"\";\\n        int mn = s.size();\\n        for (int j = i; j < s.size(); j++)\\n        {\\n            str+=s[j];\\n            int v=str.size();\\n           if(st.count(str)){\\n             v=0;\\n           }\\n            mn = min(mn, v+solve(s,st,j+1));\\n        }\\n        return dp[i] = mn;\\n    }\\n    int minExtraChar(string s, vector<string>& d) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        unordered_set<string>st;\\n        for (string& x : d){\\n        st.insert(x);\\n        }\\n        return solve(s, st, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990875,
                "title": "video-solution-explanation-with-drawings-in-depth-c-java",
                "content": "# Intuition, approach, and complexity discussed in detail in video solution:\\nhttps://youtu.be/KsJSZipj3Ek\\n\\n# Code\\nC++\\n```\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_set<string> dictSet;\\n        int sz = s.size();\\n        for(auto word : dictionary){\\n            dictSet.insert(word);\\n        }\\n        vector<int> delCount(sz+1);\\n        for(int right = 1; right<=sz; right++){\\n                delCount[right] = 1 + delCount[right-1];\\n                for(int left = right; left > 0; left--){\\n                    string word = s.substr(left-1, right - left+1);\\n                    if(dictSet.count(word)){\\n                        delCount[right] = min(delCount[right], delCount[left-1]);\\n                    }\\n                }\\n        }\\n        return delCount[sz];\\n    }\\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        Set<String> dictSet = new HashSet<>();\\n        int sz = s.length();\\n        for(var word : dictionary){\\n            dictSet.add(word);\\n        }\\n        int delCount[] = new int[sz+1];\\n        for(int right = 1; right<=sz; right++){\\n                delCount[right] = 1 + delCount[right-1];\\n                for(int left = right; left > 0; left--){\\n                    String word = s.substring(left-1, right);\\n                    if(dictSet.contains(word)){\\n                        delCount[right] = Math.min(delCount[right], delCount[left-1]);\\n                    }\\n                }\\n        }\\n        return delCount[sz];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_set<string> dictSet;\\n        int sz = s.size();\\n        for(auto word : dictionary){\\n            dictSet.insert(word);\\n        }\\n        vector<int> delCount(sz+1);\\n        for(int right = 1; right<=sz; right++){\\n                delCount[right] = 1 + delCount[right-1];\\n                for(int left = right; left > 0; left--){\\n                    string word = s.substr(left-1, right - left+1);\\n                    if(dictSet.count(word)){\\n                        delCount[right] = min(delCount[right], delCount[left-1]);\\n                    }\\n                }\\n        }\\n        return delCount[sz];\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        Set<String> dictSet = new HashSet<>();\\n        int sz = s.length();\\n        for(var word : dictionary){\\n            dictSet.add(word);\\n        }\\n        int delCount[] = new int[sz+1];\\n        for(int right = 1; right<=sz; right++){\\n                delCount[right] = 1 + delCount[right-1];\\n                for(int left = right; left > 0; left--){\\n                    String word = s.substring(left-1, right);\\n                    if(dictSet.contains(word)){\\n                        delCount[right] = Math.min(delCount[right], delCount[left-1]);\\n                    }\\n                }\\n        }\\n        return delCount[sz];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990392,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        n=len(s)\\n        @cache\\n        def dp(i:int,extra:int)->int:\\n            if i>=n:\\n                return extra\\n\\n            min_extra=dp(i+1,extra)\\n            for word in dictionary:\\n                if s[i:].startswith(word):\\n                    min_extra=min(min_extra,dp(i+len(word),extra-len(word)))\\n\\n            return min_extra\\n\\n        return dp(0,n)            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        n=len(s)\\n        @cache\\n        def dp(i:int,extra:int)->int:\\n            if i>=n:\\n                return extra\\n\\n            min_extra=dp(i+1,extra)\\n            for word in dictionary:\\n                if s[i:].startswith(word):\\n                    min_extra=min(min_extra,dp(i+len(word),extra-len(word)))\\n\\n            return min_extra\\n\\n        return dp(0,n)            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990350,
                "title": "best-dp-solution",
                "content": "# **PLEASE UPVOTE MY SOLUTION IG YOU LIKE IT**\\n# **CONNECT WITH ME**\\n# **[https://www.linkedin.com/in/pratay-nandy-9ba57b229/]()**\\n# **[https://www.instagram.com/pratay_nandy/]()**\\n# **TOP DOWN APPROACH**\\n# Approach\\nCreate an unordered_map mp to store the words from the dictionary as keys and their corresponding frequencies as values. This map will be used to efficiently check whether a substring of s is present in the dictionary.\\n\\nInitialize a vector dp of size equal to the length of the input string s. Each element of this vector will be used to store the minimum number of extra characters needed to make a valid concatenation starting from the corresponding index in s. Initialize all elements of dp to -1 to indicate that the results have not been computed yet.\\n\\nDefine the recursive function solve with the following parameters:\\n\\ns: The input string.\\nmp: The map containing words from the dictionary.\\ndp: The memoization array.\\nindex: The current index in the string s where we are considering substrings.\\nInside the solve function, if index is greater than or equal to the length of the string s, return 0 because there are no extra characters to delete.\\n\\nCheck if the result for the current index is already stored in dp. If so, return the cached result.\\n\\nInitialize an empty string currStr to gradually build the current substring.\\n\\nInitialize minExtra to a value that represents the maximum possible extra characters (initially set to the length of the input string s).\\n\\nUse a loop to iterate through the string s starting from the given index. In each iteration, add the current character to currStr.\\n\\nFor each substring currStr, check if it is present in the dictionary (mp.count(currStr)). If it is, set currExtra to 0 because no characters need to be deleted for a valid word.\\n\\nIf currStr is not in the dictionary, set currExtra to the length of currStr because all characters in it are extra and need to be deleted.\\n\\nRecursively call the solve function with an incremented cutIdx to explore the next part of the string.\\n\\nCalculate the total number of extra characters for the current substring as totalExtra = currExtra + nextExtra.\\n\\nUpdate minExtra to store the minimum number of extra characters seen so far while exploring different substrings.\\n\\nStore the result in dp[index] to cache it for future use.\\n\\nFinally, return dp[0] as the answer, which represents the minimum number of extra characters needed to make the entire string s a concatenation of valid words from the dictionary.\\n\\nBy memoizing the results for each index in the string s, the code avoids redundant calculations and significantly improves the efficiency of the algorithm.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n*n*m) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(k * m + n).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(string& s, unordered_map<string, int>&mp, vector<int>&dp, int index)\\n    {\\n        if (index >= s.size()) return 0;\\n        if (dp[index] != -1) return dp[index]; //use the stored results\\n        \\n        string currStr = \"\";\\n        int minExtra = s.size();\\n        for (int cutIdx = index; cutIdx < s.size(); cutIdx++)\\n        {\\n            currStr.push_back(s[cutIdx]);\\n            //currStr will be a string from (index to cutIdx)\\n            \\n            //if string not in dictionary, we have to delete as they are extra chars\\n            int currExtra = (mp.count(currStr))? 0 : currStr.size();\\n            int nextExtra = solve(s, mp, dp, cutIdx + 1);\\n            int totalExtra = currExtra + nextExtra;\\n            \\n            minExtra = min(minExtra, totalExtra);\\n        }\\n        return dp[index] = minExtra;\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) \\n    {\\n        vector<int>dp(s.size(), -1);\\n        unordered_map<string, int>mp;\\n        for (string& word : dictionary) mp[word]++;\\n        \\n        int ans = solve(s, mp, dp, 0);\\n        return ans;\\n        \\n    }\\n};\\n```\\n# **BOTTTOM UP APPROACH**\\n# Approach\\nInitialize n as the length of the input string s.\\n\\nCreate an unordered map mp to store the words from the dictionary as keys and their corresponding frequencies as values. This map will be used to efficiently check whether a substring of s is present in the dictionary.\\n\\nInitialize a dynamic programming array dp of size n + 1, where dp[i] will store the minimum number of extra characters needed starting from index i in the string s.\\n\\nPerform a bottom-up dynamic programming approach by iterating through the string s from right to left (from the last character to the first character). The index variable represents the starting index of the current subproblem string.\\n\\nWithin the outer loop, initialize an empty string currStr to gradually build the current substring.\\n\\nInitialize minExtra to a value that represents the maximum possible extra characters (initially set to the length of the input string s).\\n\\nUse an inner loop to iterate through the string s starting from the current index to the end of the string. In each iteration, add the current character to currStr.\\n\\nFor each substring currStr, check if it is present in the dictionary (mp.count(currStr)). If it is, set currExtra to 0 because no characters need to be deleted for a valid word.\\n\\nIf currStr is not in the dictionary, set currExtra to the length of currStr because all characters in it are extra and need to be deleted.\\n\\nInstead of making recursive calls, the code directly accesses the values from the dp array. nextExtra is obtained from dp[cutIdx + 1], which represents the minimum extra characters needed for the substring starting from cutIdx + 1.\\n\\nCalculate the total number of extra characters for the current substring as totalExtra = currExtra + nextExtra.\\n\\nUpdate minExtra to store the minimum number of extra characters seen so far while exploring different substrings.\\n\\nStore the result in dp[index] to represent the minimum number of extra characters needed starting from the current index.\\n\\nContinue this process for all possible starting indices in the string.\\n\\nFinally, return dp[0], which represents the minimum number of extra characters needed to make the entire string s a concatenation of valid words from the dictionary.\\n\\nThis approach uses dynamic programming to efficiently compute the minimum number of extra characters for each substring, from right to left, and leverages previously calculated values in the dp array to avoid redundant computations.\\n\\n# Complexity\\n- Time complexity:O(n*n*m) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(k * m + n).\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) \\n    { \\n        int n = s.size();\\n        unordered_map<string, int>mp;\\n        for (string& word : dictionary) mp[word]++;\\n        vector<int>dp(n + 1, 0);\\n       \\n        for (int index = n - 1; index >= 0; index--) \\n        {\\n            string currStr = \"\";\\n            int minExtra = s.size();\\n            for (int cutIdx = index; cutIdx < n; cutIdx++)\\n            {\\n                currStr.push_back(s[cutIdx]);\\n                \\n                int currExtra = (mp.count(currStr))? 0 : currStr.size();\\n                int nextExtra = dp[cutIdx + 1]; \\n                int totalExtra = currExtra + nextExtra;\\n\\n                minExtra = min(minExtra, totalExtra);\\n            }\\n            dp[index] = minExtra;\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(string& s, unordered_map<string, int>&mp, vector<int>&dp, int index)\\n    {\\n        if (index >= s.size()) return 0;\\n        if (dp[index] != -1) return dp[index]; //use the stored results\\n        \\n        string currStr = \"\";\\n        int minExtra = s.size();\\n        for (int cutIdx = index; cutIdx < s.size(); cutIdx++)\\n        {\\n            currStr.push_back(s[cutIdx]);\\n            //currStr will be a string from (index to cutIdx)\\n            \\n            //if string not in dictionary, we have to delete as they are extra chars\\n            int currExtra = (mp.count(currStr))? 0 : currStr.size();\\n            int nextExtra = solve(s, mp, dp, cutIdx + 1);\\n            int totalExtra = currExtra + nextExtra;\\n            \\n            minExtra = min(minExtra, totalExtra);\\n        }\\n        return dp[index] = minExtra;\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) \\n    {\\n        vector<int>dp(s.size(), -1);\\n        unordered_map<string, int>mp;\\n        for (string& word : dictionary) mp[word]++;\\n        \\n        int ans = solve(s, mp, dp, 0);\\n        return ans;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) \\n    { \\n        int n = s.size();\\n        unordered_map<string, int>mp;\\n        for (string& word : dictionary) mp[word]++;\\n        vector<int>dp(n + 1, 0);\\n       \\n        for (int index = n - 1; index >= 0; index--) \\n        {\\n            string currStr = \"\";\\n            int minExtra = s.size();\\n            for (int cutIdx = index; cutIdx < n; cutIdx++)\\n            {\\n                currStr.push_back(s[cutIdx]);\\n                \\n                int currExtra = (mp.count(currStr))? 0 : currStr.size();\\n                int nextExtra = dp[cutIdx + 1]; \\n                int totalExtra = currExtra + nextExtra;\\n\\n                minExtra = min(minExtra, totalExtra);\\n            }\\n            dp[index] = minExtra;\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3694997,
                "title": "java-easy-dynamic-programming-solution",
                "content": "```java\\nclass Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        final Set<String> dict = new HashSet<>();\\n        final int[] dp = new int[s.length() + 1];\\n\\n        for(String word : dictionary)\\n            dict.add(word);\\n\\n        for(int i = 1; i < dp.length; ++i) {\\n            dp[i] = dp[i - 1] + 1;\\n\\n            for(int j = i - 1; j >= 0; --j) {\\n                String sub = s.substring(j, i);\\n\\n                if(dict.contains(sub))\\n                    dp[i] = Math.min(dp[i], dp[j]);\\n            }\\n        }\\n\\n        return dp[dp.length - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        final Set<String> dict = new HashSet<>();\\n        final int[] dp = new int[s.length() + 1];\\n\\n        for(String word : dictionary)\\n            dict.add(word);\\n\\n        for(int i = 1; i < dp.length; ++i) {\\n            dp[i] = dp[i - 1] + 1;\\n\\n            for(int j = i - 1; j >= 0; --j) {\\n                String sub = s.substring(j, i);\\n\\n                if(dict.contains(sub))\\n                    dp[i] = Math.min(dp[i], dp[j]);\\n            }\\n        }\\n\\n        return dp[dp.length - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582356,
                "title": "easy-to-follow-cpp-solution-dynamic-programming-no-recursion",
                "content": "# Intuition\\nStore pairs of start and end indexes of each word if it is present in s, and then find the maximum continuous combination of the intervals, and return the word length minus this maximum\\n\\n# Approach\\nDynamic Programming\\n\\n# Complexity\\n- Time complexity:\\nO(n^2 + n* log(n)) = O(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) \\n    {\\n        vector<pair<int,int>> indexes;\\n\\n        // fill the pairs vector\\n        for(auto word: dictionary)\\n        {\\n            int index = s.find(word);\\n\\n            while(index != string::npos)\\n            {\\n                indexes.push_back({index, index + word.length() -1 });\\n                index = s.find(word, index + word.length());\\n            }\\n        }\\n        \\n        //if no matches found - return the lenght of s\\n        if(indexes.empty())\\n        {\\n            return s.length();\\n        }\\n\\n        // sort the pairs vector\\n        sort(indexes.begin(), indexes.end());\\n\\n        vector<int> dp;\\n        dp.push_back(indexes[0].second - indexes[0].first + 1);\\n\\n        // find minimum interval\\n        for(int i = 1; i < indexes.size(); ++i)\\n        {\\n            int maxInt = 0;\\n            int currInt = indexes[i].second - indexes[i].first + 1;\\n\\n            for(int j = 0; j < i; ++j)\\n            {  \\n                if( indexes[i].first > indexes[j].second)\\n                {\\n                    maxInt = max(dp[j], maxInt);\\n                }\\n            }\\n            \\n            dp.push_back(currInt + maxInt);\\n        }\\n\\n        // find maximum value in the dp vector\\n        auto maximum = max_element(dp.begin(),dp.end() );\\n        \\n        // return the leftover\\n        return s.length() - *maximum ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) \\n    {\\n        vector<pair<int,int>> indexes;\\n\\n        // fill the pairs vector\\n        for(auto word: dictionary)\\n        {\\n            int index = s.find(word);\\n\\n            while(index != string::npos)\\n            {\\n                indexes.push_back({index, index + word.length() -1 });\\n                index = s.find(word, index + word.length());\\n            }\\n        }\\n        \\n        //if no matches found - return the lenght of s\\n        if(indexes.empty())\\n        {\\n            return s.length();\\n        }\\n\\n        // sort the pairs vector\\n        sort(indexes.begin(), indexes.end());\\n\\n        vector<int> dp;\\n        dp.push_back(indexes[0].second - indexes[0].first + 1);\\n\\n        // find minimum interval\\n        for(int i = 1; i < indexes.size(); ++i)\\n        {\\n            int maxInt = 0;\\n            int currInt = indexes[i].second - indexes[i].first + 1;\\n\\n            for(int j = 0; j < i; ++j)\\n            {  \\n                if( indexes[i].first > indexes[j].second)\\n                {\\n                    maxInt = max(dp[j], maxInt);\\n                }\\n            }\\n            \\n            dp.push_back(currInt + maxInt);\\n        }\\n\\n        // find maximum value in the dp vector\\n        auto maximum = max_element(dp.begin(),dp.end() );\\n        \\n        // return the leftover\\n        return s.length() - *maximum ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580539,
                "title": "python-3-8-lines-w-explanation-t-m-100-40",
                "content": "Here\\'s the plan:\\n- We construct a dict of`dictionary`, using the the initial letter of each element of`dictionary`as the key.\\n- We recurse`s`by character, indexed by`ptr`.\\n- At each character, we determine the whether it is better to consider an element (if there are any) of the dictionary that would work or declaring the character at`ptr`as extra.\\n- We move `ptr` as necessary in the recursion step.\\n- We return`dp(0)`.\\n\\n```\\nclass Solution: \\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n\\n        words = defaultdict(list)\\n        for word in dictionary: words[word[0]].append(word)\\n\\n        @lru_cache(1000)  \\n        def dp(ptr:int)-> int:\\n\\n            if ptr == len(s): return 0\\n\\n            cands = (w for w in words[s[ptr]] if s[ptr:].startswith(w))\\n            return min([dp(ptr+len(w)) for w in cands]+[1+dp(ptr+1)])\\n\\n        return dp(0)\\n```\\n[https://leetcode.com/problems/extra-characters-in-a-string/submissions/960564677/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*NK*) and space complexity is *O*(*N*), in which *N* ~`len(s)`and *K* ~`max(len(word.values())`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution: \\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n\\n        words = defaultdict(list)\\n        for word in dictionary: words[word[0]].append(word)\\n\\n        @lru_cache(1000)  \\n        def dp(ptr:int)-> int:\\n\\n            if ptr == len(s): return 0\\n\\n            cands = (w for w in words[s[ptr]] if s[ptr:].startswith(w))\\n            return min([dp(ptr+len(w)) for w in cands]+[1+dp(ptr+1)])\\n\\n        return dp(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568840,
                "title": "c-easy-commented-code-dp-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minExtraChar(string inputString, vector<string>& dictionary) {\\n        // Convert dictionary vector into an unordered_set for efficient lookup\\n        unordered_set<string> dictSet(dictionary.begin(), dictionary.end());\\n        \\n        int n = inputString.length();\\n        // Create a dynamic programming table to store minimum extra characters needed\\n        // to form valid words ending at each index\\n        vector<int> dp(n + 1, n);\\n\\n        dp[0] = 0;  // Base case: no extra characters needed to form a valid word at index 0\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                // Extract the substring from index j to i (exclusive)\\n                string sub = inputString.substr(j, i - j);\\n                \\n                // If the substring is found in the dictionary, update dp[i]\\n                if (dictSet.count(sub) > 0) {\\n                    dp[i] = min(dp[i], dp[j]);  // No extra characters needed if word is found\\n                }\\n            }\\n            // Compare the current dp[i] with the minimum extra characters needed from previous index\\n            dp[i] = min(dp[i], dp[i - 1] + 1);\\n        }\\n\\n        return dp[n];  // Return the minimum extra characters needed to form valid words\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minExtraChar(string inputString, vector<string>& dictionary) {\\n        // Convert dictionary vector into an unordered_set for efficient lookup\\n        unordered_set<string> dictSet(dictionary.begin(), dictionary.end());\\n        \\n        int n = inputString.length();\\n        // Create a dynamic programming table to store minimum extra characters needed\\n        // to form valid words ending at each index\\n        vector<int> dp(n + 1, n);\\n\\n        dp[0] = 0;  // Base case: no extra characters needed to form a valid word at index 0\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                // Extract the substring from index j to i (exclusive)\\n                string sub = inputString.substr(j, i - j);\\n                \\n                // If the substring is found in the dictionary, update dp[i]\\n                if (dictSet.count(sub) > 0) {\\n                    dp[i] = min(dp[i], dp[j]);  // No extra characters needed if word is found\\n                }\\n            }\\n            // Compare the current dp[i] with the minimum extra characters needed from previous index\\n            dp[i] = min(dp[i], dp[i - 1] + 1);\\n        }\\n\\n        return dp[n];  // Return the minimum extra characters needed to form valid words\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994070,
                "title": "brute-force-with-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int n ;\\n    \\n    int solve(int start,string &s,unordered_map<string, int > &mp,vector<int> &dp)\\n    {\\n        if(start>=n)\\n        {\\n          return 0;   \\n        }\\n        \\n        if(dp[start] !=-1)\\n            return dp[start];\\n        \\n        int min_diff = s.length();\\n        string temp;\\n        for(int i=start; i<s.length(); i++)\\n        {\\n            temp.push_back(s[i]);\\n            int cex = temp.length();\\n            if(mp.find(temp)!=mp.end())\\n            {\\n                cex = 0;\\n            }\\n            \\n            int nex = solve(i+1,s,mp,dp);\\n            \\n            min_diff = min(min_diff, nex+cex);\\n            \\n        }\\n        \\n        return dp[start] = min_diff;\\n\\n    }\\n    \\n    int minExtraChar(string s, vector<string>& d) {\\n        \\n        n = s.length();\\n        vector<int> dp(n,-1);\\n        unordered_map<string, int > mp;\\n        \\n        for(auto i: d)\\n        {\\n            mp[i]++;\\n        }\\n        \\n        return solve(0,s,mp,dp);        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n ;\\n    \\n    int solve(int start,string &s,unordered_map<string, int > &mp,vector<int> &dp)\\n    {\\n        if(start>=n)\\n        {\\n          return 0;   \\n        }\\n        \\n        if(dp[start] !=-1)\\n            return dp[start];\\n        \\n        int min_diff = s.length();\\n        string temp;\\n        for(int i=start; i<s.length(); i++)\\n        {\\n            temp.push_back(s[i]);\\n            int cex = temp.length();\\n            if(mp.find(temp)!=mp.end())\\n            {\\n                cex = 0;\\n            }\\n            \\n            int nex = solve(i+1,s,mp,dp);\\n            \\n            min_diff = min(min_diff, nex+cex);\\n            \\n        }\\n        \\n        return dp[start] = min_diff;\\n\\n    }\\n    \\n    int minExtraChar(string s, vector<string>& d) {\\n        \\n        n = s.length();\\n        vector<int> dp(n,-1);\\n        unordered_map<string, int > mp;\\n        \\n        for(auto i: d)\\n        {\\n            mp[i]++;\\n        }\\n        \\n        return solve(0,s,mp,dp);        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992780,
                "title": "extra-characters-in-a-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int traverseString(int index, string &s, int cnt, unordered_set<string>& us, int &ans, vector<int>& dp) {\\n\\n        if (cnt > ans)\\n            return s.size() + 1;\\n\\n        if (index == s.size()) {\\n            ans = min(ans, cnt);\\n            return 0;\\n        }\\n\\n        if (dp[index] != s.size() + 2)\\n            return dp[index];\\n\\n        for (string it : us) {\\n            int len = it.size();\\n            string nxt = s.substr(index, len);\\n            \\n            if (nxt == it) {\\n                dp[index] = min(dp[index], traverseString(index + len, s, cnt, us, ans, dp));\\n            }\\n        }\\n\\n        dp[index] = min(dp[index], 1 + traverseString(index + 1, s, cnt + 1, us, ans, dp));\\n\\n        return dp[index];\\n    }\\n\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_set<string> us;\\n        int len = s.size();\\n        vector<int> dp(len, len + 2);\\n        int n = dictionary.size();\\n\\n        for (int i = 0; i < n; i++) {\\n            us.insert(dictionary[i]);\\n        }\\n\\n        int ans = INT_MAX;\\n\\n        traverseString(0, s, 0, us, ans, dp);\\n\\n        return min(dp[0], ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int traverseString(int index, string &s, int cnt, unordered_set<string>& us, int &ans, vector<int>& dp) {\\n\\n        if (cnt > ans)\\n            return s.size() + 1;\\n\\n        if (index == s.size()) {\\n            ans = min(ans, cnt);\\n            return 0;\\n        }\\n\\n        if (dp[index] != s.size() + 2)\\n            return dp[index];\\n\\n        for (string it : us) {\\n            int len = it.size();\\n            string nxt = s.substr(index, len);\\n            \\n            if (nxt == it) {\\n                dp[index] = min(dp[index], traverseString(index + len, s, cnt, us, ans, dp));\\n            }\\n        }\\n\\n        dp[index] = min(dp[index], 1 + traverseString(index + 1, s, cnt + 1, us, ans, dp));\\n\\n        return dp[index];\\n    }\\n\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_set<string> us;\\n        int len = s.size();\\n        vector<int> dp(len, len + 2);\\n        int n = dictionary.size();\\n\\n        for (int i = 0; i < n; i++) {\\n            us.insert(dictionary[i]);\\n        }\\n\\n        int ans = INT_MAX;\\n\\n        traverseString(0, s, 0, us, ans, dp);\\n\\n        return min(dp[0], ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992558,
                "title": "i-wish-for-you",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n*The problem asks us to find the minimum number of extra characters needed to transform a given string s into a valid word from a list of words in the dictionary. Our intuition here is to use dynamic programming to build a solution. We\\'ll maintain an array to keep track of the minimum extra characters needed at each position in s.*\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n*Step-1 -> Initialize a dynamic programming (DP) array `dp` with a length of `s.length() + 1` to store minimum extra characters at each position.*\\n*Step-2 -> Initialize all elements in the `dp` array with a high value, initially set to `s.length() + 1`, to represent an impossible situation. Set `dp[0]` to 0 since no extra characters are needed at the start.*\\n*Step-3 -> Create a HashSet `hashset` to efficiently check if a word exists in the `dictionary`.*\\n*Step-4 -> Loop through each character in the input string `s`, starting from position 1.*\\n*Step-5 -> For each position `i`, initialize `dp[i]` to be one more than the value at the previous position, representing the addition of one extra character.*\\n*Step-6 -> Utilize a nested loop to explore different substrings ending at the current position `i`.*\\n*Step-7 -> If a valid word (substring) is found in the `dictionary`, update `dp[i]` to the minimum between its current value and `dp[i - j]`, where `j` is the length of the found word.*\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        int maxVal = s.length()+1;\\n        int[] dp = new int[maxVal];\\n        Arrays.fill(dp,maxVal);\\n        dp[0]=0;\\n    Set<String> hashset = new HashSet<>(Arrays.asList(dictionary));\\n        for(int i=1;i<=s.length();i++){\\n            dp[i]=dp[i-1]+1;\\n            for(int j=1;j<=i;j++){\\n                if(hashset.contains(s.substring(i-j,i))){\\n                    dp[i] = Math.min(dp[i],dp[i-j]);\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        int maxVal = s.length()+1;\\n        int[] dp = new int[maxVal];\\n        Arrays.fill(dp,maxVal);\\n        dp[0]=0;\\n    Set<String> hashset = new HashSet<>(Arrays.asList(dictionary));\\n        for(int i=1;i<=s.length();i++){\\n            dp[i]=dp[i-1]+1;\\n            for(int j=1;j<=i;j++){\\n                if(hashset.contains(s.substring(i-j,i))){\\n                    dp[i] = Math.min(dp[i],dp[i-j]);\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991925,
                "title": "simple-beginner-friendly-javascript-solution-with-intuition-and-explanation",
                "content": "# Intuition\\nWe start by iterating through s from right to left, considering substrings starting from each position. For each starting position, we calculate the minimum extra characters needed if no word from the dictionary is used. Then, we check all possible substrings from that position and update the minimum extra characters if a valid word is found in the dictionary. By considering all possible substrings and minimizing the extra characters at each step, we efficiently compute the minimum number of extra characters required to construct the entire string using words from the dictionary.\\n\\n# Approach\\nFollow the following steps:\\n\\n- For each starting position \\'start\\', we initialize \\'dp[start]\\' with a value of \\'dp[start+1]+1\\', which represents the minimum extra characters needed if we don\\'t use any word from the dictionary.\\n\\n- We then iterate through all possible substrings of \\'s\\' starting from the start position.\\n\\n- For each substring \\'curr\\', we check if it exists in the dictionarySet. If it does, we update \\'dp[start]\\' with the minimum value between the current \\'dp[start]\\' and \\'dp[end+1]\\', where end is the ending position of the current substring.\\n\\n- Finally, we return \\'dp[0]\\', which represents the minimum extra characters needed to form the entire string \\'s\\' from the words in the dictionary.\\n\\n# Complexity\\n- Time complexity: O(N^3)\\n\\n- Space complexity: O(N+M\\u22C5K)\\n\\nUPVOTE. Glad to help.\\n# Code\\n```\\nvar minExtraChar = function(s, dictionary) {\\n    const n=s.length;\\n    const dictionarySet=new Set(dictionary);\\n    const dp=Array(n+1).fill(0);\\n    for(let start=n-1;start>=0;start--){\\n        dp[start]=dp[start+1]+1;\\n        for(let end=start;end<n;end++){\\n            const curr=s.substring(start,end+1);\\n            if(dictionarySet.has(curr)) dp[start]=Math.min(dp[start],dp[end+1]);\\n        }\\n    }\\n    return dp[0];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minExtraChar = function(s, dictionary) {\\n    const n=s.length;\\n    const dictionarySet=new Set(dictionary);\\n    const dp=Array(n+1).fill(0);\\n    for(let start=n-1;start>=0;start--){\\n        dp[start]=dp[start+1]+1;\\n        for(let end=start;end<n;end++){\\n            const curr=s.substring(start,end+1);\\n            if(dictionarySet.has(curr)) dp[start]=Math.min(dp[start],dp[end+1]);\\n        }\\n    }\\n    return dp[0];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3991771,
                "title": "c-3-solutions-w-explanations-recursion-memoization-tabulation",
                "content": "## \\u274C Solution I: Recursion [TLE]\\nMake a cut at every index and then get the extra character count for the remaining string using recursion.\\n\\n## Code\\n```\\nclass Solution {\\n    int solve(string& s, unordered_map<string, int>& m, int idx) {\\n        if (idx >= s.size()) {\\n            return 0;\\n        }\\n        string currStr = \"\";\\n        int minExtra = s.size();\\n        for (int currIdx=idx; currIdx<s.size(); currIdx++) {\\n            currStr += s[currIdx];\\n            int currExtra = m.count(currStr) ? 0 : currStr.size();\\n            int nextExtra = solve(s, m, currIdx+1);\\n            minExtra = min(minExtra, currExtra + nextExtra);\\n        }\\n        return minExtra;\\n    }\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<string, int> m;\\n        int n = dictionary.size();\\n        for (int i=0; i<n; i++) {\\n            m[dictionary[i]]++;\\n        }\\n        return solve(s, m, 0);\\n    }\\n};\\n```\\n- Time complexity: `O(2\\u207F)`\\n- Space complexity: `O(n)`\\n\\n---\\n\\n\\n## \\u2705 Solution II: Top-Down DP or Memoization [Accepted]\\nWe are doing a lot of repetitive work in the above recursive solution. We can create a `DP` vector and store the result of each recursion call in it.\\n\\n## Code\\n```\\nclass Solution {\\n    int solve(string& s, unordered_map<string, int>& m, vector<int>& dp, int idx) {\\n        if (idx >= s.size()) {\\n            return 0;\\n        }\\n        if (dp[idx] != -1) {\\n            return dp[idx];\\n        }\\n        string currStr = \"\";\\n        int minExtra = s.size();\\n        for (int currIdx=idx; currIdx<s.size(); currIdx++) {\\n            currStr += s[currIdx];\\n            int currExtra = m.count(currStr) ? 0 : currStr.size();\\n            int nextExtra = solve(s, m, dp, currIdx+1);\\n            minExtra = min(minExtra, currExtra + nextExtra);\\n        }\\n        return dp[idx] = minExtra;\\n    }\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<string, int> m;\\n        vector<int> dp(s.size(), -1);\\n        int n = dictionary.size();\\n        for (int i=0; i<n; i++) {\\n            m[dictionary[i]]++;\\n        }\\n        return solve(s, m, dp, 0);\\n    }\\n};\\n```\\n- Time complexity: `O(n\\xB2)`\\n- Space complexity: `O(n)`\\n\\n---\\n\\n\\n## \\u2705 Solution III: Bottm Up DP or Tabulation [Accepted]\\nWe can do a bottom-up traversal instead of traversing from top to bottom.\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<string, int> m;\\n        int n = dictionary.size();\\n        for (int i=0; i<n; i++) {\\n            m[dictionary[i]]++;\\n        }\\n        n = s.size();\\n        vector<int> dp(n+1, 0);\\n        for (int i=n-1; i>=0; i--) {\\n            string currStr = \"\";\\n            int minExtra = n;\\n            for (int currIdx=i; currIdx<n; currIdx++) {\\n                currStr += s[currIdx];\\n                int currExtra = m.count(currStr) ? 0 : currStr.size();\\n                int nextExtra = dp[currIdx+1];\\n                minExtra = min(minExtra, currExtra + nextExtra);\\n            }\\n            dp[i] = minExtra;\\n        }\\n        return dp[0];\\n    }\\n};\\n```\\n- Time complexity: `O(n\\xB2)`\\n- Space complexity: `O(n)`\\n\\n---\\n\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int solve(string& s, unordered_map<string, int>& m, int idx) {\\n        if (idx >= s.size()) {\\n            return 0;\\n        }\\n        string currStr = \"\";\\n        int minExtra = s.size();\\n        for (int currIdx=idx; currIdx<s.size(); currIdx++) {\\n            currStr += s[currIdx];\\n            int currExtra = m.count(currStr) ? 0 : currStr.size();\\n            int nextExtra = solve(s, m, currIdx+1);\\n            minExtra = min(minExtra, currExtra + nextExtra);\\n        }\\n        return minExtra;\\n    }\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<string, int> m;\\n        int n = dictionary.size();\\n        for (int i=0; i<n; i++) {\\n            m[dictionary[i]]++;\\n        }\\n        return solve(s, m, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int solve(string& s, unordered_map<string, int>& m, vector<int>& dp, int idx) {\\n        if (idx >= s.size()) {\\n            return 0;\\n        }\\n        if (dp[idx] != -1) {\\n            return dp[idx];\\n        }\\n        string currStr = \"\";\\n        int minExtra = s.size();\\n        for (int currIdx=idx; currIdx<s.size(); currIdx++) {\\n            currStr += s[currIdx];\\n            int currExtra = m.count(currStr) ? 0 : currStr.size();\\n            int nextExtra = solve(s, m, dp, currIdx+1);\\n            minExtra = min(minExtra, currExtra + nextExtra);\\n        }\\n        return dp[idx] = minExtra;\\n    }\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<string, int> m;\\n        vector<int> dp(s.size(), -1);\\n        int n = dictionary.size();\\n        for (int i=0; i<n; i++) {\\n            m[dictionary[i]]++;\\n        }\\n        return solve(s, m, dp, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<string, int> m;\\n        int n = dictionary.size();\\n        for (int i=0; i<n; i++) {\\n            m[dictionary[i]]++;\\n        }\\n        n = s.size();\\n        vector<int> dp(n+1, 0);\\n        for (int i=n-1; i>=0; i--) {\\n            string currStr = \"\";\\n            int minExtra = n;\\n            for (int currIdx=i; currIdx<n; currIdx++) {\\n                currStr += s[currIdx];\\n                int currExtra = m.count(currStr) ? 0 : currStr.size();\\n                int nextExtra = dp[currIdx+1];\\n                minExtra = min(minExtra, currExtra + nextExtra);\\n            }\\n            dp[i] = minExtra;\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991645,
                "title": "extra-characters-in-a-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    private int[] dp = new int[51]; // Initialize dp array with 0 values\\n\\n    public int minExtraChar(String s, String[] dictionary) {\\n        Arrays.fill(dp, -1); // Initialize dp array with -1 values\\n        return minExtraCharHelper(s, dictionary, 0);\\n    }\\n\\n    private int minExtraCharHelper(String s, String[] dictionary, int i) {\\n        if (i == s.length()) {\\n            return 0;\\n        }\\n\\n        if (dp[i] == -1) {\\n            dp[i] = 1 + minExtraCharHelper(s, dictionary, i + 1); // Initialize with one extra character\\n\\n            for (String w : dictionary) {\\n                if (i + w.length() <= s.length() && s.substring(i, i + w.length()).equals(w)) {\\n                    dp[i] = Math.min(dp[i], minExtraCharHelper(s, dictionary, i + w.length())); // Update if a word in the dictionary is found\\n                }\\n            }\\n        }\\n\\n        return dp[i]; // Return the minimum extra characters starting from position i\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    private int[] dp = new int[51]; // Initialize dp array with 0 values\\n\\n    public int minExtraChar(String s, String[] dictionary) {\\n        Arrays.fill(dp, -1); // Initialize dp array with -1 values\\n        return minExtraCharHelper(s, dictionary, 0);\\n    }\\n\\n    private int minExtraCharHelper(String s, String[] dictionary, int i) {\\n        if (i == s.length()) {\\n            return 0;\\n        }\\n\\n        if (dp[i] == -1) {\\n            dp[i] = 1 + minExtraCharHelper(s, dictionary, i + 1); // Initialize with one extra character\\n\\n            for (String w : dictionary) {\\n                if (i + w.length() <= s.length() && s.substring(i, i + w.length()).equals(w)) {\\n                    dp[i] = Math.min(dp[i], minExtraCharHelper(s, dictionary, i + w.length())); // Update if a word in the dictionary is found\\n                }\\n            }\\n        }\\n\\n        return dp[i]; // Return the minimum extra characters starting from position i\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991506,
                "title": "swift-c-python-java-easy-to-understand-and-simple-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Swift\\n```\\nclass Solution {\\n    func minExtraChar(_ s: String, _ dictionary: [String]) -> Int {\\n        let (n, dictionarySet) = (s.count, Set(dictionary))\\n        var dp = Array(repeating: n, count: n + 1)\\n        dp[0] = 0\\n        \\n        for i in 1...n {\\n            for j in 0..<i {\\n                if dictionarySet.contains(String(s[s.index(s.startIndex, offsetBy: j)..<s.index(s.startIndex, offsetBy: i)])) {\\n                    dp[i] = min(dp[i], dp[j])\\n\\n                } else {\\n                    dp[i] = min(dp[i], dp[j] + i - j)\\n                }\\n            }\\n        }\\n        return dp[n]\\n    }\\n}\\n\\n```\\n# C++\\n```\\nclass Solution {\\n public:\\n  int minExtraChar(string s, vector<string>& dictionary) {\\n    const int n = s.length();\\n    const unordered_set<string> dictionarySet{dictionary.begin(),\\n                                              dictionary.end()};\\n    vector<int> dp(n + 1, n);\\n    dp[0] = 0;\\n\\n    for (int i = 1; i <= n; ++i)\\n      for (int j = 0; j < i; ++j)\\n        if (dictionarySet.count(s.substr(j, i - j)))\\n          dp[i] = min(dp[i], dp[j]);\\n        \\n        else\\n          dp[i] = min(dp[i], dp[j] + i - j);\\n\\n    return dp[n];\\n  }\\n};\\n```\\n# Python\\n```\\nclass Solution:\\n  def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n    n = len(s)\\n    dictionarySet = set(dictionary)\\n    dp = [0] + [n] * n\\n\\n    for i in range(1, n + 1):\\n      for j in range(i):\\n        if s[j:i] in dictionarySet:\\n          dp[i] = min(dp[i], dp[j])\\n\\n        else:\\n          dp[i] = min(dp[i], dp[j] + i - j)\\n\\n    return dp[n]\\n```\\n# Java\\n```\\nclass Solution {\\n  public int minExtraChar(String s, String[] dictionary) {\\n    final int n = s.length();\\n    Set<String> dictionarySet = new HashSet<>(Arrays.asList(dictionary));\\n    int[] dp = new int[n + 1];\\n    Arrays.fill(dp, n);\\n    dp[0] = 0;\\n\\n    for (int i = 1; i <= n; i++)\\n      for (int j = 0; j < i; j++)\\n        if (dictionarySet.contains(s.substring(j, i)))\\n          dp[i] = Math.min(dp[i], dp[j]);\\n\\n        else\\n          dp[i] = Math.min(dp[i], dp[j] + i - j);\\n\\n    return dp[n];\\n  }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Swift",
                    "Hash Table",
                    "Dynamic Programming",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    func minExtraChar(_ s: String, _ dictionary: [String]) -> Int {\\n        let (n, dictionarySet) = (s.count, Set(dictionary))\\n        var dp = Array(repeating: n, count: n + 1)\\n        dp[0] = 0\\n        \\n        for i in 1...n {\\n            for j in 0..<i {\\n                if dictionarySet.contains(String(s[s.index(s.startIndex, offsetBy: j)..<s.index(s.startIndex, offsetBy: i)])) {\\n                    dp[i] = min(dp[i], dp[j])\\n\\n                } else {\\n                    dp[i] = min(dp[i], dp[j] + i - j)\\n                }\\n            }\\n        }\\n        return dp[n]\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n public:\\n  int minExtraChar(string s, vector<string>& dictionary) {\\n    const int n = s.length();\\n    const unordered_set<string> dictionarySet{dictionary.begin(),\\n                                              dictionary.end()};\\n    vector<int> dp(n + 1, n);\\n    dp[0] = 0;\\n\\n    for (int i = 1; i <= n; ++i)\\n      for (int j = 0; j < i; ++j)\\n        if (dictionarySet.count(s.substr(j, i - j)))\\n          dp[i] = min(dp[i], dp[j]);\\n        \\n        else\\n          dp[i] = min(dp[i], dp[j] + i - j);\\n\\n    return dp[n];\\n  }\\n};\\n```\n```\\nclass Solution:\\n  def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n    n = len(s)\\n    dictionarySet = set(dictionary)\\n    dp = [0] + [n] * n\\n\\n    for i in range(1, n + 1):\\n      for j in range(i):\\n        if s[j:i] in dictionarySet:\\n          dp[i] = min(dp[i], dp[j])\\n\\n        else:\\n          dp[i] = min(dp[i], dp[j] + i - j)\\n\\n    return dp[n]\\n```\n```\\nclass Solution {\\n  public int minExtraChar(String s, String[] dictionary) {\\n    final int n = s.length();\\n    Set<String> dictionarySet = new HashSet<>(Arrays.asList(dictionary));\\n    int[] dp = new int[n + 1];\\n    Arrays.fill(dp, n);\\n    dp[0] = 0;\\n\\n    for (int i = 1; i <= n; i++)\\n      for (int j = 0; j < i; j++)\\n        if (dictionarySet.contains(s.substring(j, i)))\\n          dp[i] = Math.min(dp[i], dp[j]);\\n\\n        else\\n          dp[i] = Math.min(dp[i], dp[j] + i - j);\\n\\n    return dp[n];\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991501,
                "title": "c-recursion-memoization",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int helper(int index, vector<pair<int,int>> v, int prev, vector<vector<int>>& dp){\\n        if(index==v.size()){\\n            return 0;\\n        }\\n        int ans=0;\\n        if(prev!=-1&&dp[index][prev]!=-1)return dp[index][prev];\\n        if(v[index].first>prev){\\n            ans=max(helper(index+1,v,prev,dp),v[index].second-v[index].first+1+helper(index+1,v,v[index].second,dp));\\n        }\\n        else{\\n            ans=helper(index+1,v,prev,dp);\\n        }\\n        if(prev!=-1)dp[index][prev]=ans;\\n        return ans;\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<string,int> m;\\n        for(auto&i:dictionary){\\n            m[i]++;\\n        }\\n        vector<pair<int,int>> v;\\n        for(int i = 0; i<s.length(); i++){\\n            string temp;\\n            for(int j = i; j<s.length(); j++){\\n                temp.push_back(s[j]);\\n                if(m[temp])v.push_back({i,j});\\n            }\\n        }\\n        vector<vector<int>> dp(v.size(),vector<int>(s.length(),-1));\\n        return s.length()-helper(0,v,-1,dp);\\n    }\\n};\\n```\\n\\n```\\n\\n  int   int   if if if  set       set   OOO    for for for EEEEE  \\n  int   int   if    if   set     set  O     O      for     E      \\n  int   int   if if if    set   set   O     O      for     EEE    \\n  int   int   if           set set    O     O      for     E      \\n   int int    if             set        OOO        for     EEEEE  \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int index, vector<pair<int,int>> v, int prev, vector<vector<int>>& dp){\\n        if(index==v.size()){\\n            return 0;\\n        }\\n        int ans=0;\\n        if(prev!=-1&&dp[index][prev]!=-1)return dp[index][prev];\\n        if(v[index].first>prev){\\n            ans=max(helper(index+1,v,prev,dp),v[index].second-v[index].first+1+helper(index+1,v,v[index].second,dp));\\n        }\\n        else{\\n            ans=helper(index+1,v,prev,dp);\\n        }\\n        if(prev!=-1)dp[index][prev]=ans;\\n        return ans;\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<string,int> m;\\n        for(auto&i:dictionary){\\n            m[i]++;\\n        }\\n        vector<pair<int,int>> v;\\n        for(int i = 0; i<s.length(); i++){\\n            string temp;\\n            for(int j = i; j<s.length(); j++){\\n                temp.push_back(s[j]);\\n                if(m[temp])v.push_back({i,j});\\n            }\\n        }\\n        vector<vector<int>> dp(v.size(),vector<int>(s.length(),-1));\\n        return s.length()-helper(0,v,-1,dp);\\n    }\\n};\\n```\n```\\n\\n  int   int   if if if  set       set   OOO    for for for EEEEE  \\n  int   int   if    if   set     set  O     O      for     E      \\n  int   int   if if if    set   set   O     O      for     EEE    \\n  int   int   if           set set    O     O      for     E      \\n   int int    if             set        OOO        for     EEEEE  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991461,
                "title": "simple-memoized-dp",
                "content": "# Code\\n```\\nclass Solution {\\n    Integer[] dp; int n; String str; HashSet<String> set;\\n    public int minExtraChar(String s, String[] dictionary) {\\n        n=s.length(); dp=new Integer[n+1]; dp[n]=0;\\n        str=s; set=new HashSet<String>(Arrays.asList(dictionary));\\n        return f(0);\\n    }\\n    private int f(int ind) {\\n        if(dp[ind]!=null) return dp[ind];\\n        int cnt_min_extra=Integer.MAX_VALUE;\\n        for(int i=ind; i<n; ++i) {\\n            int extraChars = f(i+1) + (set.contains(str.substring(ind, i+1))?0: i-ind+1);\\n            cnt_min_extra=Math.min(cnt_min_extra, extraChars);\\n        }\\n        return dp[ind]=cnt_min_extra;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    Integer[] dp; int n; String str; HashSet<String> set;\\n    public int minExtraChar(String s, String[] dictionary) {\\n        n=s.length(); dp=new Integer[n+1]; dp[n]=0;\\n        str=s; set=new HashSet<String>(Arrays.asList(dictionary));\\n        return f(0);\\n    }\\n    private int f(int ind) {\\n        if(dp[ind]!=null) return dp[ind];\\n        int cnt_min_extra=Integer.MAX_VALUE;\\n        for(int i=ind; i<n; ++i) {\\n            int extraChars = f(i+1) + (set.contains(str.substring(ind, i+1))?0: i-ind+1);\\n            cnt_min_extra=Math.min(cnt_min_extra, extraChars);\\n        }\\n        return dp[ind]=cnt_min_extra;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991179,
                "title": "simple-recursion-memoization-dp-approach-beats-98-people-in-both-time-and-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy initial thought was just to find and fit the best strings from dictionary in the given string.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI have started from the first index of the given string, from the current position I have seen wether there exists a string in dictionary that can be found in the substring (string from current index to end of the main string), if I donot find any string then I simply return the size of the substring i.e., total length - current index, In the other case, If I find any string in dictionary that is found in the substring then I just go to all such possible strings of dictionary that can be found in substring, move my index accordingly and finding the minimum among the all possible combinations and simply return it.\\n\\nBase Case:\\nIf my index pos is greater than or equal to main string length return 0. (If I can make the given string from the strings in dictionary)\\n\\nIf you like the solution, pls try to upvote it. In case of any query regarding the solution comment down.\\n\\nThank You.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helper(int idx,string &s,vector<string>&dictionary,vector<int>&dp)\\n    {\\n        cout << idx << endl;\\n        if(idx>=s.length())\\n        {\\n            return 0;\\n        }\\n        if(dp[idx]!=-1)\\n        {\\n            return dp[idx];\\n        }\\n        int flag=0;\\n        string temp=s.substr(idx,s.length()-idx);\\n        for(int i=0;i<dictionary.size();i++)\\n        {\\n            if(temp.find(dictionary[i])!=string::npos)\\n            {\\n                flag=1;\\n                break;\\n            }\\n        }\\n        if(flag==0)\\n        {\\n            dp[idx]=s.length()-idx;\\n        }\\n        else\\n        {\\n            int ans=INT_MAX;\\n            for(int i=0;i<dictionary.size();i++)\\n            {\\n                if(temp.find(dictionary[i])!=string::npos)\\n                {\\n                    int pos=idx+temp.find(dictionary[i]);\\n                    ans=min(ans,pos-idx+helper(pos+dictionary[i].length(),s,dictionary,dp));\\n                }\\n            }\\n            dp[idx]=ans;\\n        }\\n        return dp[idx];\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        vector<int>dp(s.length()+1,-1);\\n        return helper(0,s,dictionary,dp);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int idx,string &s,vector<string>&dictionary,vector<int>&dp)\\n    {\\n        cout << idx << endl;\\n        if(idx>=s.length())\\n        {\\n            return 0;\\n        }\\n        if(dp[idx]!=-1)\\n        {\\n            return dp[idx];\\n        }\\n        int flag=0;\\n        string temp=s.substr(idx,s.length()-idx);\\n        for(int i=0;i<dictionary.size();i++)\\n        {\\n            if(temp.find(dictionary[i])!=string::npos)\\n            {\\n                flag=1;\\n                break;\\n            }\\n        }\\n        if(flag==0)\\n        {\\n            dp[idx]=s.length()-idx;\\n        }\\n        else\\n        {\\n            int ans=INT_MAX;\\n            for(int i=0;i<dictionary.size();i++)\\n            {\\n                if(temp.find(dictionary[i])!=string::npos)\\n                {\\n                    int pos=idx+temp.find(dictionary[i]);\\n                    ans=min(ans,pos-idx+helper(pos+dictionary[i].length(),s,dictionary,dp));\\n                }\\n            }\\n            dp[idx]=ans;\\n        }\\n        return dp[idx];\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        vector<int>dp(s.length()+1,-1);\\n        return helper(0,s,dictionary,dp);\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3990721,
                "title": "easy-java-solution-recursion-memoization",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int minExtraChar(String s, String[] dict) {\\n        int n = s.length();\\n        HashSet<String> set = new HashSet<>();\\n        \\n        for(int i = 0 ; i < dict.length; i++){\\n            set.add(dict[i]);\\n        }\\n\\n        int[] dp = new int[n];\\n        Arrays.fill(dp, -1);\\n\\n        return solve(0, set, s, dp);\\n    }\\n\\n    int solve(int ind, HashSet<String> set, String s, int[] dp){\\n        if(ind >= s.length()) return 0;\\n\\n        if(dp[ind] != -1) return dp[ind];\\n\\n        int ans = Integer.MAX_VALUE;\\n\\n        String sub = \"\";\\n        for(int i = 0; i + ind < s.length(); i++){\\n            sub = s.substring(ind, ind + i + 1);\\n\\n            if(set.contains(sub)){\\n                ans = Math.min(ans, solve(ind+i+1, set, s, dp));\\n            }\\n            ans = Math.min(ans,i + 1 + solve(ind+i+1, set, s, dp)); // yaha err tha\\n        } \\n\\n        return dp[ind] = ans;\\n    }\\n\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minExtraChar(String s, String[] dict) {\\n        int n = s.length();\\n        HashSet<String> set = new HashSet<>();\\n        \\n        for(int i = 0 ; i < dict.length; i++){\\n            set.add(dict[i]);\\n        }\\n\\n        int[] dp = new int[n];\\n        Arrays.fill(dp, -1);\\n\\n        return solve(0, set, s, dp);\\n    }\\n\\n    int solve(int ind, HashSet<String> set, String s, int[] dp){\\n        if(ind >= s.length()) return 0;\\n\\n        if(dp[ind] != -1) return dp[ind];\\n\\n        int ans = Integer.MAX_VALUE;\\n\\n        String sub = \"\";\\n        for(int i = 0; i + ind < s.length(); i++){\\n            sub = s.substring(ind, ind + i + 1);\\n\\n            if(set.contains(sub)){\\n                ans = Math.min(ans, solve(ind+i+1, set, s, dp));\\n            }\\n            ans = Math.min(ans,i + 1 + solve(ind+i+1, set, s, dp)); // yaha err tha\\n        } \\n\\n        return dp[ind] = ans;\\n    }\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990614,
                "title": "recursion-memoization-line-by-line-commented-code",
                "content": "\\n# Complexity\\n- Time complexity:\\n  O(N*N)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_set<string> st;\\n    int t[51];\\n    int n;\\n    int solve(string &s, int idx) {\\n        if (idx >= n) // we check for all character in string  \\n            return 0;\\n            if(t[idx] != -1) return t[idx];\\n        string currStr = \"\"; // create string to store current string \\n        int minExtra = n;// minExtra goes till n in case of no any matching   \\n        for (int i = idx; i < s.size(); i++) {\\n            currStr.push_back(s[i]);\\n\\n            int currExtra = (st.find(currStr) == st.end()) ? currStr.length() : 0;\\n            int nextExtra = solve(s, i + 1);// further recursion call for next character \\n            int totalExtra = currExtra + nextExtra;\\n            minExtra = min(minExtra, totalExtra); \\n        }\\n        return  t[idx] =minExtra;\\n    }\\n    \\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        n = s.length();\\n        memset(t , -1 , sizeof(t));\\n        for(string &word : dictionary) {\\n            st.insert(word);\\n        }\\n        return solve(s, 0);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_set<string> st;\\n    int t[51];\\n    int n;\\n    int solve(string &s, int idx) {\\n        if (idx >= n) // we check for all character in string  \\n            return 0;\\n            if(t[idx] != -1) return t[idx];\\n        string currStr = \"\"; // create string to store current string \\n        int minExtra = n;// minExtra goes till n in case of no any matching   \\n        for (int i = idx; i < s.size(); i++) {\\n            currStr.push_back(s[i]);\\n\\n            int currExtra = (st.find(currStr) == st.end()) ? currStr.length() : 0;\\n            int nextExtra = solve(s, i + 1);// further recursion call for next character \\n            int totalExtra = currExtra + nextExtra;\\n            minExtra = min(minExtra, totalExtra); \\n        }\\n        return  t[idx] =minExtra;\\n    }\\n    \\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        n = s.length();\\n        memset(t , -1 , sizeof(t));\\n        for(string &word : dictionary) {\\n            st.insert(word);\\n        }\\n        return solve(s, 0);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990467,
                "title": "weird-state",
                "content": "\\n\\n**Acepted Code  TIme Complexity - > O(N^2XlogM) where  M is the length of string present in string  and Space Complexity is O(Size of String)->cache**\\n```\\nclass Solution{\\n    private : \\n    int solve(const string &s,set<string>&dic,int i,vector<int>&dp){\\n        int n = s.size();\\n        if(i==n)return 0;\\n        if(dp[i]!=-1)return dp[i];\\n        int ans = 1e2;\\n        for(int  j = i ; j < s.size();j++){\\n            string tmp = s.substr(i,j-i+1);\\n            int curr = j-i+1;\\n            if(dic.find(tmp)!=dic.end())curr = 0 ;\\n               int next = solve(s,dic,j+1,dp);\\n               ans = min(ans,curr+next);\\n        }\\n        return dp[i]= ans;\\n    }\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        int n = s.size();\\n        vector<int>dp(n+1,-1);\\n        set<string>dic(begin(dictionary),end(dictionary));\\n        int ans = solve(s,dic,0,dp);\\n      //  for(auto it : dp)cout<<it<<\" \";\\n        return ans ;\\n    }\\n};\\n```\\n\\n# While Trying for the first Time i came up with this dp state \\n**I came up with this weird state  dp[i][j][bool] = Maximum  length of Substring [i:j] which is non overlapping and exist in my Trie dictonary  TC Passed - > 400/2028**\\n\\n```\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_set<string> dictSet;\\n\\n        for (const string& word : dictionary) {\\n            dictSet.insert(word);\\n        }\\n\\n        int n = s.length();\\n        vector<vector<pair<int, bool>>> dp(n + 1, vector<pair<int, bool>>(n + 1, { 0, false }));\\n\\n        for (int len = 1; len <= n; len++) {\\n            for (int i = 0; i + len <= n; i++) {\\n                int j = i + len;\\n                string substr = s.substr(i, len);\\n\\n                if (dictSet.count(substr)) {\\n                    dp[i][j] = { len, true }; \\n                }\\n                else {\\n                    dp[i][j].first = max(dp[i][j - 1].first, dp[i + 1][j].first) + 1;\\n                    dp[i][j].second = dp[i][j - 1].second && dp[i + 1][j].second;\\n                }\\n            }\\n        }\\n        int ans = 0 ;\\n        for(auto it : dp){\\n            for(auto it1 : it){\\n               if(it1.second ==true)ans+= it1.first;\\n            }\\n        }\\n\\n\\n        return  n-ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution{\\n    private : \\n    int solve(const string &s,set<string>&dic,int i,vector<int>&dp){\\n        int n = s.size();\\n        if(i==n)return 0;\\n        if(dp[i]!=-1)return dp[i];\\n        int ans = 1e2;\\n        for(int  j = i ; j < s.size();j++){\\n            string tmp = s.substr(i,j-i+1);\\n            int curr = j-i+1;\\n            if(dic.find(tmp)!=dic.end())curr = 0 ;\\n               int next = solve(s,dic,j+1,dp);\\n               ans = min(ans,curr+next);\\n        }\\n        return dp[i]= ans;\\n    }\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        int n = s.size();\\n        vector<int>dp(n+1,-1);\\n        set<string>dic(begin(dictionary),end(dictionary));\\n        int ans = solve(s,dic,0,dp);\\n      //  for(auto it : dp)cout<<it<<\" \";\\n        return ans ;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_set<string> dictSet;\\n\\n        for (const string& word : dictionary) {\\n            dictSet.insert(word);\\n        }\\n\\n        int n = s.length();\\n        vector<vector<pair<int, bool>>> dp(n + 1, vector<pair<int, bool>>(n + 1, { 0, false }));\\n\\n        for (int len = 1; len <= n; len++) {\\n            for (int i = 0; i + len <= n; i++) {\\n                int j = i + len;\\n                string substr = s.substr(i, len);\\n\\n                if (dictSet.count(substr)) {\\n                    dp[i][j] = { len, true }; \\n                }\\n                else {\\n                    dp[i][j].first = max(dp[i][j - 1].first, dp[i + 1][j].first) + 1;\\n                    dp[i][j].second = dp[i][j - 1].second && dp[i + 1][j].second;\\n                }\\n            }\\n        }\\n        int ans = 0 ;\\n        for(auto it : dp){\\n            for(auto it1 : it){\\n               if(it1.second ==true)ans+= it1.first;\\n            }\\n        }\\n\\n\\n        return  n-ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3880717,
                "title": "easy-to-understand-c-solution-using-2-d-dp-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[52][52];\\n    int solve(int i, int j, string &s,unordered_set<string>&dict){\\n        if(dict.find(s.substr(i,j-i+1)) != dict.end()) return 0;\\n        if(i == j){\\n            return 1;\\n        }\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int ans = INT_MAX;\\n        for(int k=i; k<j; k++){\\n            ans = min(ans,solve(i,k,s,dict) + solve(k+1,j,s,dict));\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minExtraChar(string s, vector<string>& arr) {\\n        unordered_set<string>dict(arr.begin(),arr.end());\\n        int n = s.length();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,n-1,s,dict);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[52][52];\\n    int solve(int i, int j, string &s,unordered_set<string>&dict){\\n        if(dict.find(s.substr(i,j-i+1)) != dict.end()) return 0;\\n        if(i == j){\\n            return 1;\\n        }\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int ans = INT_MAX;\\n        for(int k=i; k<j; k++){\\n            ans = min(ans,solve(i,k,s,dict) + solve(k+1,j,s,dict));\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minExtraChar(string s, vector<string>& arr) {\\n        unordered_set<string>dict(arr.begin(),arr.end());\\n        int n = s.length();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,n-1,s,dict);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607423,
                "title": "easy-c-memoization-hashmap",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[55];\\n    int recur(int ind, string &s, map<string, bool> &mp){\\n        int n=s.length();\\n        //base cases\\n        if(ind>n-1){\\n            //out of array -> return 0\\n            return 0;\\n        }\\n        if(dp[ind]!=-1){\\n            return dp[ind];\\n        }\\n        //LOGIC\\n        //try all possible substrings\\n        string curr=\"\";\\n        int mini=INT_MAX;\\n        for(int i=ind; i<n; i++){\\n            curr.push_back(s[i]); //store each char in string\\n            int cnt=curr.length(); //stores extra character\\'s length\\n            if(mp[curr]){\\n                //substring found in map -> set cnt=0\\n                cnt=0;\\n            }\\n            //else move to next character and add the extra chars length to cnt\\n            cnt+=recur(i+1, s, mp); //l+recur(1), le+recur(2), lee+recur(3), leet+recur(4)=0+recur(4)\\n            mini=min(mini, cnt); //find minimum of all the cnts\\n        }\\n        return dp[ind]=mini;\\n    }\\n    int minExtraChar(string s, vector<string>& dict) {\\n        map<string, bool> mp; \\n        //to access the strings in O(logN) time complexity instead of traversing dict each time\\n        for(auto &it:dict){\\n            mp[it]=true;\\n        }\\n        memset(dp, -1, sizeof(dp));\\n        return recur(0, s, mp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[55];\\n    int recur(int ind, string &s, map<string, bool> &mp){\\n        int n=s.length();\\n        //base cases\\n        if(ind>n-1){\\n            //out of array -> return 0\\n            return 0;\\n        }\\n        if(dp[ind]!=-1){\\n            return dp[ind];\\n        }\\n        //LOGIC\\n        //try all possible substrings\\n        string curr=\"\";\\n        int mini=INT_MAX;\\n        for(int i=ind; i<n; i++){\\n            curr.push_back(s[i]); //store each char in string\\n            int cnt=curr.length(); //stores extra character\\'s length\\n            if(mp[curr]){\\n                //substring found in map -> set cnt=0\\n                cnt=0;\\n            }\\n            //else move to next character and add the extra chars length to cnt\\n            cnt+=recur(i+1, s, mp); //l+recur(1), le+recur(2), lee+recur(3), leet+recur(4)=0+recur(4)\\n            mini=min(mini, cnt); //find minimum of all the cnts\\n        }\\n        return dp[ind]=mini;\\n    }\\n    int minExtraChar(string s, vector<string>& dict) {\\n        map<string, bool> mp; \\n        //to access the strings in O(logN) time complexity instead of traversing dict each time\\n        for(auto &it:dict){\\n            mp[it]=true;\\n        }\\n        memset(dp, -1, sizeof(dp));\\n        return recur(0, s, mp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603244,
                "title": "java-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n\\n    public int minExtraChar(String s, String[] dictionary) {\\n        int n=dictionary.length;\\n        int dp[]=new int[s.length()+1];\\n        Set<String> set=new HashSet<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            set.add(dictionary[i]);\\n        }\\n        for(int i=1;i<=s.length();i++)\\n        {\\n            dp[i]=dp[i-1]+1;\\n            for(int j=0;j<=i;j++)\\n            {\\n                String sub=s.substring(j,i);\\n                if(set.contains(sub)){\\n                    dp[i]=Math.min(dp[i],dp[j]);\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n\\n    public int minExtraChar(String s, String[] dictionary) {\\n        int n=dictionary.length;\\n        int dp[]=new int[s.length()+1];\\n        Set<String> set=new HashSet<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            set.add(dictionary[i]);\\n        }\\n        for(int i=1;i<=s.length();i++)\\n        {\\n            dp[i]=dp[i-1]+1;\\n            for(int j=0;j<=i;j++)\\n            {\\n                String sub=s.substring(j,i);\\n                if(set.contains(sub)){\\n                    dp[i]=Math.min(dp[i],dp[j]);\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569321,
                "title": "c-dp-trie-faster-than-using-hashmap",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* First come up with the solution using hashmap.\\n* Dp[i] means min number of extra char left in s[i]~s[n-1].\\n* Try all prefix start at i and check if the substring is in the dictionary. If yes then update dp[i].\\n* Also we need to consider to left char s[i].\\n\\n```\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        int n = s.size();\\n        unordered_set<string> dic;\\n        for(auto& word : dictionary) {\\n            dic.insert(word);\\n        }\\n        \\n        vector<int> dp(n+1, 0);\\n        for(int i=n-1; i>=0; i--) {\\n            dp[i] = 1 + dp[i+1];\\n            for(int j=i; j<n; j++) {\\n                if(dic.count(s.substr(i, j-i+1))) {\\n                    dp[i] = min(dp[i], dp[j+1]);\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```\\nHowever using hashmap to check the substring need O(L) time. L is the length of the substring. Worst case will be O(n).\\n\\n- Time complexity: $$O(N^3 + M*L)$$\\n\\nUsing Trie to reduce the searching time to O(1) and break out of the loop when there is no matching prefix to reduce the time.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        int n = s.size();\\n        Node* root = new Node();\\n\\n        //create Trie\\n        for(auto& word : dictionary) {\\n            Node* now = root;\\n            for(char& c : word) {\\n                if(!now->child.count(c)) {\\n                    now->child[c] = new Node();\\n                }\\n                now = now->child[c];\\n            }\\n            now->is_end = true;\\n        }\\n\\n        //dp[i] means min number of extra char left in s[i]~s[n-1]\\n        vector<int> dp(n+1, 0);\\n        for(int i=n-1; i>=0; i--) {\\n            // left s[j]\\n            dp[i] = 1 + dp[i+1];\\n            Node* now = root;\\n            // check if the prefix is in dictionary\\n            for(int j=i; j<n; j++) {\\n                // if the prefix is not exist break out of the loop\\n                // this place can be faster than using hash map\\n                if(!now->child.count(s[j])) {\\n                    break;\\n                }\\n                now = now->child[s[j]];\\n                // if the prefix is in dictionary, update dp[i]\\n                if(now->is_end) {\\n                    dp[i] = min(dp[i], dp[j+1]);\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n    struct Node{\\n        bool is_end;\\n        unordered_map<char, Node*> child;\\n    };\\n};\\n```\\n\\n# Complexity\\n- Time complexity: $$O(N^2 + M*L)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    //M = dictionary.size()\\n    //L = len of longest string in dictionary\\n- Space complexity: $$O(N + M*L)$$\\nworst case all string with no common prefix\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        int n = s.size();\\n        unordered_set<string> dic;\\n        for(auto& word : dictionary) {\\n            dic.insert(word);\\n        }\\n        \\n        vector<int> dp(n+1, 0);\\n        for(int i=n-1; i>=0; i--) {\\n            dp[i] = 1 + dp[i+1];\\n            for(int j=i; j<n; j++) {\\n                if(dic.count(s.substr(i, j-i+1))) {\\n                    dp[i] = min(dp[i], dp[j+1]);\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        int n = s.size();\\n        Node* root = new Node();\\n\\n        //create Trie\\n        for(auto& word : dictionary) {\\n            Node* now = root;\\n            for(char& c : word) {\\n                if(!now->child.count(c)) {\\n                    now->child[c] = new Node();\\n                }\\n                now = now->child[c];\\n            }\\n            now->is_end = true;\\n        }\\n\\n        //dp[i] means min number of extra char left in s[i]~s[n-1]\\n        vector<int> dp(n+1, 0);\\n        for(int i=n-1; i>=0; i--) {\\n            // left s[j]\\n            dp[i] = 1 + dp[i+1];\\n            Node* now = root;\\n            // check if the prefix is in dictionary\\n            for(int j=i; j<n; j++) {\\n                // if the prefix is not exist break out of the loop\\n                // this place can be faster than using hash map\\n                if(!now->child.count(s[j])) {\\n                    break;\\n                }\\n                now = now->child[s[j]];\\n                // if the prefix is in dictionary, update dp[i]\\n                if(now->is_end) {\\n                    dp[i] = min(dp[i], dp[j+1]);\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n    struct Node{\\n        bool is_end;\\n        unordered_map<char, Node*> child;\\n    };\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569266,
                "title": "very-easy-mcm-dp-explanation-recursion-memorization-python-and-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to divide the given string into substrings in such a way that we have to minimize the sum of length of substrings which are not present in dictionary.\\n\\n*In simpler words, we have to divide a string into substrings such that the sum of length of the substrings which are not present in dictionary is minimized.*\\n\\nEg:- `s = \"leetscode\", dictionary = [\"leet\",\"code\",\"leetcode\"]`\\nwe can divide it into 3 substrings `leet | s | code`\\n`leet and code belongs to the dictionary, but s doesnot.`\\nSo we have to partition the substring and minimize the sum of `length of substrings` which are not in the dictionary.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We first insert all dictionary strings to map to check if the string exists in`OLog(N)`.\\n- We can simply perform a recursion `helper(s, mp, ind)`\\nHere `ind` refers to the start of our substring. To partition a string we can start a forloop `for(int i = ind; i < s.length(); i++)` indicating that the substring starts from index `ind` and ends at index `i`.\\n- Now we check if the substring from `ind to ith index` is a part of dictionary.\\n    - If the substring is a part of dictionary then the number of characters that would be left behind would be `0 + helper(s, mp, i + 1)` i.e 0 + minimum no of characters left behind if substrings start from `i + 1` index (`helper(s, mp, i + 1)`).\\n    - If the substring is `not` a part of dictionary then the number of characters that would be left behind would be `(i - ind + 1) + helper(s, mp, i + 1)` i.e length of this substring (`(i - ind + 1)`) + minimum no of characters left behind if substrings start from `i + 1` index (` helper(s, mp, i + 1)`).\\n- We then store the minimum of each partitions into ans.\\n``` C++ []\\n//t refers to substring ind to i.\\nstring t = \"\";\\nfor(int i = ind;i < s.length(); i++){\\n    t.push_back(s[i]);\\n    if(mp[t] > 0){\\n        // substring exists in dictionary.\\n        ans = min(ans, 0 + helper(s, mp, i + 1));\\n    }else{\\n        // substring doesnot exists in dictionary.\\n        ans = min(ans, (i - ind + 1) + helper(s, mp, i + 1));\\n    }\\n}\\n```\\n\\n\\n# Complexity\\n- Time complexity: `O(N) * (max(len(s)))`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(N) for dictionary`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Python []\\ndef helper(s, mp, ind, dp):\\n    if ind == len(s):\\n        return 0\\n    if dp[ind] != -1:\\n        return dp[ind]\\n    ans = 1e9\\n    t = \"\"\\n    for i in range(ind, len(s)):\\n        t += s[i]\\n        if(t in mp):\\n            ans = min(ans, helper(s, mp, i + 1, dp))\\n        else:\\n            ans = min(ans, i - ind + 1 + helper(s, mp, i + 1, dp))\\n    dp[ind] = ans\\n    return dp[ind]\\n\\nclass Solution(object):\\n    def minExtraChar(self, s, dictionary):\\n        mp = set()\\n        dp = [-1] * 51\\n        for i in dictionary:\\n            mp.add(i)\\n        return helper(s, mp, 0, dp)\\n    \\n```\\n``` C++ []\\nint dp[55];\\nclass Solution {\\npublic:\\n    int helper(string &s, map<string, int>&mp, int ind){\\n        if(ind == s.length())return 0;\\n        if(dp[ind] != -1)return dp[ind];\\n        int ans = 1e9;\\n        string t = \"\";\\n        for(int i = ind;i < s.length(); i++){\\n            t.push_back(s[i]);\\n            if(mp[t] > 0){\\n                ans = min(ans, helper(s, mp, i + 1));\\n            }else{\\n                ans = min(ans, i - ind + 1 + helper(s, mp, i + 1));\\n            }\\n        }\\n        return dp[ind] = ans;\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        map<string, int> mp;\\n        memset(dp, -1, sizeof dp);\\n        for(auto i : dictionary)mp[i]++;\\n        return helper(s, mp, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "``` C++ []\\n//t refers to substring ind to i.\\nstring t = \"\";\\nfor(int i = ind;i < s.length(); i++){\\n    t.push_back(s[i]);\\n    if(mp[t] > 0){\\n        // substring exists in dictionary.\\n        ans = min(ans, 0 + helper(s, mp, i + 1));\\n    }else{\\n        // substring doesnot exists in dictionary.\\n        ans = min(ans, (i - ind + 1) + helper(s, mp, i + 1));\\n    }\\n}\\n```\n```Python []\\ndef helper(s, mp, ind, dp):\\n    if ind == len(s):\\n        return 0\\n    if dp[ind] != -1:\\n        return dp[ind]\\n    ans = 1e9\\n    t = \"\"\\n    for i in range(ind, len(s)):\\n        t += s[i]\\n        if(t in mp):\\n            ans = min(ans, helper(s, mp, i + 1, dp))\\n        else:\\n            ans = min(ans, i - ind + 1 + helper(s, mp, i + 1, dp))\\n    dp[ind] = ans\\n    return dp[ind]\\n\\nclass Solution(object):\\n    def minExtraChar(self, s, dictionary):\\n        mp = set()\\n        dp = [-1] * 51\\n        for i in dictionary:\\n            mp.add(i)\\n        return helper(s, mp, 0, dp)\\n    \\n```\n``` C++ []\\nint dp[55];\\nclass Solution {\\npublic:\\n    int helper(string &s, map<string, int>&mp, int ind){\\n        if(ind == s.length())return 0;\\n        if(dp[ind] != -1)return dp[ind];\\n        int ans = 1e9;\\n        string t = \"\";\\n        for(int i = ind;i < s.length(); i++){\\n            t.push_back(s[i]);\\n            if(mp[t] > 0){\\n                ans = min(ans, helper(s, mp, i + 1));\\n            }else{\\n                ans = min(ans, i - ind + 1 + helper(s, mp, i + 1));\\n            }\\n        }\\n        return dp[ind] = ans;\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        map<string, int> mp;\\n        memset(dp, -1, sizeof dp);\\n        for(auto i : dictionary)mp[i]++;\\n        return helper(s, mp, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569029,
                "title": "python-dp-explanation-of-two-solutions",
                "content": "**Solution 1:**\\n```\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        dp = [0] + [float(\\'inf\\')] * len(s)\\n        for i in range(1, len(s) + 1):\\n            for w in dictionary:\\n                if s[i - len(w):i] == w:\\n                    dp[i] = min(dp[i], dp[i - len(w)])\\n            dp[i] = min(dp[i], dp[i - 1] + 1)\\n        return dp[-1]\\n```\\n\\n**Explanation:**\\n\\nLet\\'s go through the solution step by step:\\n\\nInitialize a dynamic programming (DP) array dp of length len(s) + 1 with all elements set to infinity except for the first element, which is set to 0. This DP array will store the minimum number of extra characters at each position i in the string s.\\n\\nIterate over each position i in the string s from 1 to len(s). For each position i, we will check if any word from the dictionary ends at this position.\\n\\nNested within the position loop, iterate over each word w in the dictionary. Check if the substring from i - len(w) to i in s is equal to the word w. If it is, this means we can form the word w using a substring ending at position i.\\n\\nIf we can form the word w at position i, update dp[i] to be the minimum of its current value dp[i] and dp[i - len(w)]. This means that if we can form the word w at position i, we can either continue the previous substring that ends at position i - len(w) or start a new substring at position i.\\n\\nAfter iterating through all the words in the dictionary, update dp[i] to be the minimum of its current value dp[i] and dp[i - 1] + 1. This means that if we cannot form any word at position i, we have to add an extra character to the previous substring or start a new substring at position i.\\n\\nFinally, return the last element of the dp array, which represents the minimum number of extra characters when breaking up s optimally.\\n\\nThe time complexity of this solution is O(N*M), where N is the length of the string s and M is the number of words in the dictionary. This is because we iterate over each position in the string s and for each position, we iterate over each word in the dictionary to check if it can be formed at that position. The space complexity is O(N) for the DP array.\\n\\n**Solution 2**\\n```\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        memo = dict()\\n        max_len = max(map(len, dictionary))\\n        dictionary = set(dictionary)\\n        \\n        def solve(i):\\n            nonlocal dictionary, memo, max_len\\n            if i >= len(s):\\n                return 0\\n            if i in memo:\\n                return memo[i]\\n            ans = float(\\'inf\\')\\n            for j in range(i + 1, 1 + min(len(s), i + max_len)):\\n                ans = min(ans, j - i + solve(j))\\n                if s[i:j]  in dictionary:\\n                    ans = min(ans, solve(j))\\n            memo[i] = ans\\n            return ans\\n        return solve(0)\\n```\\n\\n**Explanation**\\n\\nThe given solution implements a dynamic programming approach to solve the problem of breaking a string `s` into non-overlapping substrings from a given dictionary, while minimizing the number of extra characters left over.\\n\\nLet\\'s go through the solution step by step:\\n\\n1. The solution defines a class named `Solution` with a method `minExtraChar` that takes in a string `s` and a list of words `dictionary` as input and returns the minimum number of extra characters left over.\\n\\n2. The solution initializes a memoization dictionary called `memo` to store the results of subproblems. This dictionary will be used to avoid redundant computations and improve the efficiency of the solution.\\n\\n3. The solution calculates the maximum length of a word in the dictionary using the `max` function and the `map` function with the `len` function applied to each word in the dictionary.\\n\\n4. The `dictionary` list is converted into a set called `dictionary` to improve the lookup time for words in subsequent steps.\\n\\n5. The solution defines an inner helper function called `solve`, which takes an index `i` as input and returns the minimum number of extra characters left over starting from index `i`.\\n\\n6. Inside the `solve` function, the first base case is checked. If the index `i` is already beyond the length of the string `s`, it means we have processed the entire string, so we return 0 (no extra characters left over).\\n\\n7. The second base case checks if the result for the current index `i` is already stored in the `memo` dictionary. If it is, we return the precalculated result to avoid redundant computations.\\n\\n8. If the base cases are not met, the solution initializes a variable `ans` with a value of positive infinity (float(\\'inf\\')). This variable will be used to store the minimum number of extra characters left over for the current index `i`.\\n\\n9. The solution then enters a loop that iterates from `i + 1` to the minimum of `len(s)` and `i + max_len + 1`. This loop represents all possible substrings starting from index `i` with lengths ranging from 1 to `max_len`.\\n\\n10. Within the loop, the solution updates the `ans` variable to the minimum value between the current `ans` and the difference `j - i` (representing the length of the current substring) plus the result of the recursive call to `solve(j)`. This line evaluates the possibility of breaking the string at index `j` and recursively solving the subproblem for the remaining substring.\\n\\n11. The solution then checks if the substring `s[i:j]` is present in the `dictionary` set. If it is, it updates the `ans` variable to the minimum value between the current `ans` and the result of the recursive call to `solve(j)`. This line evaluates the possibility of not breaking the string at index `j` and directly continuing from index `j` without any extra characters left over.\\n\\n12. Finally, the `ans` value is stored in the `memo` dictionary for the current index `i` and returned as the result.\\n\\n13. Outside the `solve` function, the `minExtraChar` method is called with an initial index of 0, representing the start of the string.\\n\\n14. The result of the `solve` method is returned as the final output of the `minExtraChar` method.\\n\\nOverall, the solution uses memoization and recursive calls to efficiently explore all possible substrings and find the minimum number of extra characters left over by breaking the string optimally based on the given dictionary.\\n\\n**The time complexity** of the provided solution is exponential, specifically O(2^n), where n is the length of the input string s.\\n\\nThe exponential time complexity arises due to the recursive nature of the solution. In the solve function, for each index i, the function explores all possible substrings starting from i+1 to i+max_len. This leads to a branching factor of approximately max_len at each recursive call. Since the function can be called multiple times for each index, the total number of function calls grows exponentially with the length of the string.\\n\\nMoreover, the solution uses memoization to store and retrieve previously computed results, which helps avoid redundant computations. However, in the worst case, where no memoized results are available, the solution still explores all possible combinations of substrings, resulting in exponential time complexity.\\n\\nIt\\'s worth noting that the exponential time complexity is inevitable for this problem because the solution needs to explore all possible combinations of substrings to find the optimal solution.",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        dp = [0] + [float(\\'inf\\')] * len(s)\\n        for i in range(1, len(s) + 1):\\n            for w in dictionary:\\n                if s[i - len(w):i] == w:\\n                    dp[i] = min(dp[i], dp[i - len(w)])\\n            dp[i] = min(dp[i], dp[i - 1] + 1)\\n        return dp[-1]\\n```\n```\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        memo = dict()\\n        max_len = max(map(len, dictionary))\\n        dictionary = set(dictionary)\\n        \\n        def solve(i):\\n            nonlocal dictionary, memo, max_len\\n            if i >= len(s):\\n                return 0\\n            if i in memo:\\n                return memo[i]\\n            ans = float(\\'inf\\')\\n            for j in range(i + 1, 1 + min(len(s), i + max_len)):\\n                ans = min(ans, j - i + solve(j))\\n                if s[i:j]  in dictionary:\\n                    ans = min(ans, solve(j))\\n            memo[i] = ans\\n            return ans\\n        return solve(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568973,
                "title": "java-recursive-dp-memoization-code-with-comments",
                "content": "# Intuition\\nWe need to check for each substring if we can produce minimum extra characters. For each substring we have remaining substring as repeating subproblem.\\n\\nleetscode -> leet scode -> leet s code\\nleetscode -> leets code -> leet s code\\n\\ncode is common subproblem for both the split.\\n\\n# Approach\\n\\n- `dp[index]` will store minimum extra characters for substring `index to length`.\\n- Added comments in code for better explaination.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        Set<String> set = new HashSet<>();\\n        // Create set for dictionary for O(1) search in dictionary.\\n        for (String word : dictionary) set.add(word); \\n        \\n        // Memoization array, with Integer.MAX_VALUE as default value.\\n        int[] dp = new int[s.length()];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        \\n        // start with index 0.\\n        return split(s, 0, dp, set);\\n    }\\n    \\n    private int split(String s, int index, int[] dp, Set<String> dictionary) {\\n        // if index reached at the end of the string there no extra character remaining.\\n        if (index >= s.length()) return 0;\\n        \\n        // if dictionary contains word for subtring from index to length.\\n        // There is no extra character.\\n        if (dictionary.contains(s.substring(index, s.length()))) return 0;\\n        \\n        // if dp[index] is not default value, \\n        // we have already calculated result for this index.\\n        if (dp[index] != Integer.MAX_VALUE) return dp[index];\\n        \\n        // Default value can be all the characters of subtring.\\n        int min = s.length() - index;\\n        // check for all possible substring from current index\\n        for (int i = index + 1; i <= s.length(); i++) {\\n            // if this substring is in dictionary there are zero characters.\\n            // else all characters of this substring are remaining.\\n            int count = dictionary.contains(s.substring(index, i)) ? 0 : i - index;\\n            // check for second half after split.\\n            count += split(s, i, dp, dictionary);\\n            // updated the minimum value.\\n            min = Math.min(min, count);\\n        }\\n        \\n        // update dp[index] with current min.\\n        dp[index] = min;\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        Set<String> set = new HashSet<>();\\n        // Create set for dictionary for O(1) search in dictionary.\\n        for (String word : dictionary) set.add(word); \\n        \\n        // Memoization array, with Integer.MAX_VALUE as default value.\\n        int[] dp = new int[s.length()];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        \\n        // start with index 0.\\n        return split(s, 0, dp, set);\\n    }\\n    \\n    private int split(String s, int index, int[] dp, Set<String> dictionary) {\\n        // if index reached at the end of the string there no extra character remaining.\\n        if (index >= s.length()) return 0;\\n        \\n        // if dictionary contains word for subtring from index to length.\\n        // There is no extra character.\\n        if (dictionary.contains(s.substring(index, s.length()))) return 0;\\n        \\n        // if dp[index] is not default value, \\n        // we have already calculated result for this index.\\n        if (dp[index] != Integer.MAX_VALUE) return dp[index];\\n        \\n        // Default value can be all the characters of subtring.\\n        int min = s.length() - index;\\n        // check for all possible substring from current index\\n        for (int i = index + 1; i <= s.length(); i++) {\\n            // if this substring is in dictionary there are zero characters.\\n            // else all characters of this substring are remaining.\\n            int count = dictionary.contains(s.substring(index, i)) ? 0 : i - index;\\n            // check for second half after split.\\n            count += split(s, i, dp, dictionary);\\n            // updated the minimum value.\\n            min = Math.min(min, count);\\n        }\\n        \\n        // update dp[index] with current min.\\n        dp[index] = min;\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568741,
                "title": "java-dynamic-programming",
                "content": "# Approach\\nThe problem can be solved using **Dynamic Programming** with following recurrence:\\n```\\n    dp[i] = minimum characters left for string[0...i]\\n    dp[i] = dp[i-1] + 1 (base case, if no match is found)\\n    dp[i] = min(dp[i], dp[i - len(s[i..j])]), if the substring is in dictionary\\n```\\n\\n# Complexity\\n- Time complexity: O($n^2m$), where m is length of dictionary and n is length of s.\\n\\n- Space complexity: O($n$)\\n\\n# Code\\n```\\nclass Solution { \\n    \\n    public int minExtraChar(String s, String[] dictionary) {\\n        int n = s.length();\\n        int[] dp = new int[n + 1];\\n        \\n        for (int i = 1; i <= n; i++) {\\n            dp[i] = dp[i - 1] + 1;\\n            \\n            for (String word : dictionary) {\\n                int len = word.length();\\n                if (i >= len && s.substring(i - len, i).equals(word)) {\\n                    dp[i] = Math.min(dp[i], dp[i - len]);\\n                }\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\n    dp[i] = minimum characters left for string[0...i]\\n    dp[i] = dp[i-1] + 1 (base case, if no match is found)\\n    dp[i] = min(dp[i], dp[i - len(s[i..j])]), if the substring is in dictionary\\n```\n```\\nclass Solution { \\n    \\n    public int minExtraChar(String s, String[] dictionary) {\\n        int n = s.length();\\n        int[] dp = new int[n + 1];\\n        \\n        for (int i = 1; i <= n; i++) {\\n            dp[i] = dp[i - 1] + 1;\\n            \\n            for (String word : dictionary) {\\n                int len = word.length();\\n                if (i >= len && s.substring(i - len, i).equals(word)) {\\n                    dp[i] = Math.min(dp[i], dp[i - len]);\\n                }\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568569,
                "title": "similar-to-word-break-dp",
                "content": "# Complexity\\n- Let `n = s.size()`, `m = dictionary.size()`, `l = dictionary[i].size()`\\n- Time complexity: $$O(n^2*l*log(m))$$\\n- Space complexity: $$O((m*l) + n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        // similar to word break\\n        set<string> dict(dictionary.begin(), dictionary.end());\\n        vector<int> memo(s.size(), -1);\\n        \\n        function<int(int)> solve = [&](int i) {\\n            if(i == s.size()) return 0;\\n            if(memo[i] != -1) return memo[i];\\n            \\n            // skip this char\\n            int result = 1 + solve(i+1);\\n            \\n            // consider this char\\n            string str;\\n            \\n            for(int j=i; j<s.size(); j++) {\\n                str.push_back(s[j]);\\n                \\n                if(dict.count(str)) {\\n                    result = min(result, solve(j+1));\\n                }\\n            }\\n            \\n            return memo[i] = result;\\n        };\\n        \\n        return solve(0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        // similar to word break\\n        set<string> dict(dictionary.begin(), dictionary.end());\\n        vector<int> memo(s.size(), -1);\\n        \\n        function<int(int)> solve = [&](int i) {\\n            if(i == s.size()) return 0;\\n            if(memo[i] != -1) return memo[i];\\n            \\n            // skip this char\\n            int result = 1 + solve(i+1);\\n            \\n            // consider this char\\n            string str;\\n            \\n            for(int j=i; j<s.size(); j++) {\\n                str.push_back(s[j]);\\n                \\n                if(dict.count(str)) {\\n                    result = min(result, solve(j+1));\\n                }\\n            }\\n            \\n            return memo[i] = result;\\n        };\\n        \\n        return solve(0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4099033,
                "title": "o-n-2-m-avg-len-words-t-o-n-m-avg-len-words-s-trie",
                "content": "\\t def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        \"\"\" O(N^2+M*avg_len_words)T O(N+M*avg_len_words)\"\"\"\\n        trie = lambda: collections.defaultdict(trie)\\n        root = trie()\\n\\n        for w in dictionary:\\n            functools.reduce(dict.__getitem__, w + \\'$\\', root)\\n\\n        @functools.cache\\n        def fn(i):\\n            if i >= len(s):\\n                return 0\\n            ans = 1 + fn(i + 1)\\n            n = root\\n\\n            for j in range(i, len(s)):\\n                if (n := n.get(s[j], None)) is None:\\n                    break\\n                if \\'$\\' in n:\\n                    ans = min(ans, fn(j + 1))\\n\\n            return ans\\n\\n        return fn(0)",
                "solutionTags": [],
                "code": "\\t def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        \"\"\" O(N^2+M*avg_len_words)T O(N+M*avg_len_words)\"\"\"\\n        trie = lambda: collections.defaultdict(trie)\\n        root = trie()\\n\\n        for w in dictionary:\\n            functools.reduce(dict.__getitem__, w + \\'$\\', root)\\n\\n        @functools.cache\\n        def fn(i):\\n            if i >= len(s):\\n                return 0\\n            ans = 1 + fn(i + 1)\\n            n = root\\n\\n            for j in range(i, len(s)):\\n                if (n := n.get(s[j], None)) is None:\\n                    break\\n                if \\'$\\' in n:\\n                    ans = min(ans, fn(j + 1))\\n\\n            return ans\\n\\n        return fn(0)",
                "codeTag": "Python3"
            },
            {
                "id": 3997448,
                "title": "easy-c-recursion-memoization-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helper(string s,unordered_map<string,int>& mp,int ind, vector<int>& dp){\\n        if(ind==s.size()) return 0;\\n\\n        if(dp[ind]!=-1) return dp[ind];\\n\\n        string temp=\"\";\\n        int ans=INT_MAX;\\n        for(int i=ind;i<s.size();i++){\\n            temp+=s[i];\\n            if(mp[temp]>0){\\n                ans=min(ans,helper(s,mp,i+1,dp));\\n            }\\n        }\\n        ans=min(ans,1+helper(s,mp,ind+1,dp));\\n        dp[ind]=ans;\\n        return ans;\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<string,int> mp;\\n\\n        vector<int> dp(s.size(),-1);        \\n\\n        for(int i=0;i<dictionary.size();i++){\\n            mp[dictionary[i]]++;\\n        }\\n\\n        return helper(s,mp,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(string s,unordered_map<string,int>& mp,int ind, vector<int>& dp){\\n        if(ind==s.size()) return 0;\\n\\n        if(dp[ind]!=-1) return dp[ind];\\n\\n        string temp=\"\";\\n        int ans=INT_MAX;\\n        for(int i=ind;i<s.size();i++){\\n            temp+=s[i];\\n            if(mp[temp]>0){\\n                ans=min(ans,helper(s,mp,i+1,dp));\\n            }\\n        }\\n        ans=min(ans,1+helper(s,mp,ind+1,dp));\\n        dp[ind]=ans;\\n        return ans;\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<string,int> mp;\\n\\n        vector<int> dp(s.size(),-1);        \\n\\n        for(int i=0;i<dictionary.size();i++){\\n            mp[dictionary[i]]++;\\n        }\\n\\n        return helper(s,mp,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3996733,
                "title": "simple-dp-with-subarrays-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nset<string>st;\\nclass Solution {\\npublic:\\n    int dp[51][51];\\n    int solve(string &s,int start,int end){\\n        if(end>=s.length()){\\n            if(start==end){\\n            return 0;\\n            }\\n            return end-start+1;\\n        }\\n        if(dp[start][end]!=-1){\\n            return dp[start][end];\\n        }\\n        string temp=s.substr(start,end-start+1);\\n        if(st.find(temp)!=st.end()){\\n            return dp[start][end]=min(solve(s,start,end+1),solve(s,end+1,end+1));\\n        }\\n        int x=temp.length();\\n        return dp[start][end]=min(solve(s,start,end+1),x+solve(s,end+1,end+1));\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        st.clear();int i=0;memset(dp,-1,sizeof(dp));\\n        for(auto c:dictionary){\\n            st.insert(c);\\n        }\\n        return solve(s,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nset<string>st;\\nclass Solution {\\npublic:\\n    int dp[51][51];\\n    int solve(string &s,int start,int end){\\n        if(end>=s.length()){\\n            if(start==end){\\n            return 0;\\n            }\\n            return end-start+1;\\n        }\\n        if(dp[start][end]!=-1){\\n            return dp[start][end];\\n        }\\n        string temp=s.substr(start,end-start+1);\\n        if(st.find(temp)!=st.end()){\\n            return dp[start][end]=min(solve(s,start,end+1),solve(s,end+1,end+1));\\n        }\\n        int x=temp.length();\\n        return dp[start][end]=min(solve(s,start,end+1),x+solve(s,end+1,end+1));\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        st.clear();int i=0;memset(dp,-1,sizeof(dp));\\n        for(auto c:dictionary){\\n            st.insert(c);\\n        }\\n        return solve(s,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994035,
                "title": "using-dp",
                "content": "# Intuition\\nFunction uses dynamic programming to keep track of the minimum number of extra characters left over at each position in the string s. It iterates through the string and dictionary to find valid substrings and updates the minimum extra characters accordingly. Finally, it returns the minimum extra characters at the end of the string.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        n = len(s)\\n        dp = [float(\\'inf\\')] * (n + 1)\\n        dp[0] = 0\\n\\n        for i in range(1, n + 1):\\n            for word in dictionary:\\n                if i >= len(word):\\n                    if s[i - len(word):i] == word:\\n                        dp[i] = min(dp[i], dp[i - len(word)])\\n\\n            dp[i] = min(dp[i], dp[i - 1] + 1)\\n\\n        return dp[n]\\n```\\n# **PLEASE DO UPVOTE!!!**",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        n = len(s)\\n        dp = [float(\\'inf\\')] * (n + 1)\\n        dp[0] = 0\\n\\n        for i in range(1, n + 1):\\n            for word in dictionary:\\n                if i >= len(word):\\n                    if s[i - len(word):i] == word:\\n                        dp[i] = min(dp[i], dp[i - len(word)])\\n\\n            dp[i] = min(dp[i], dp[i - 1] + 1)\\n\\n        return dp[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3993941,
                "title": "extra-characters-in-string-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[51];\\n    unordered_set<string> mp;\\n    int solve(int idx,string& s)\\n    {\\n        if(idx>=s.length())\\n        {\\n            return 0;\\n        }\\n\\n        if(dp[idx]!=-1)\\n        {\\n            return dp[idx];\\n        }\\n        int min_no=s.length();\\n        string str=\"\";\\n        for(int i=idx;i<s.length();i++)\\n        {\\n            str.push_back(s[i]);\\n            int curr;\\n            if(mp.find(str)==mp.end())\\n            {\\n                curr=str.length();\\n            }\\n            else\\n            {\\n                curr=0;\\n            }\\n            \\n            int next=solve(i+1,s);\\n            int total=curr+next;\\n\\n            min_no=min(min_no,total);\\n        }\\n        return dp[idx]=min_no;\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        memset(dp,-1,sizeof(dp));\\n        for(string i : dictionary)\\n        {\\n            mp.insert(i);\\n        }\\n\\n        return solve(0,s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[51];\\n    unordered_set<string> mp;\\n    int solve(int idx,string& s)\\n    {\\n        if(idx>=s.length())\\n        {\\n            return 0;\\n        }\\n\\n        if(dp[idx]!=-1)\\n        {\\n            return dp[idx];\\n        }\\n        int min_no=s.length();\\n        string str=\"\";\\n        for(int i=idx;i<s.length();i++)\\n        {\\n            str.push_back(s[i]);\\n            int curr;\\n            if(mp.find(str)==mp.end())\\n            {\\n                curr=str.length();\\n            }\\n            else\\n            {\\n                curr=0;\\n            }\\n            \\n            int next=solve(i+1,s);\\n            int total=curr+next;\\n\\n            min_no=min(min_no,total);\\n        }\\n        return dp[idx]=min_no;\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        memset(dp,-1,sizeof(dp));\\n        for(string i : dictionary)\\n        {\\n            mp.insert(i);\\n        }\\n\\n        return solve(0,s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3993899,
                "title": "c-100",
                "content": "\\n```\\npublic class Solution \\n{\\n    public int MinExtraChar(string s, string[] dictionary)\\n    {\\n        var sentenceLength = s.Length;\\n        var dp = new List<int>() {0};\\n        for (var i = 0; i < sentenceLength; ++i)\\n        {\\n            var match = dp[i];\\n            foreach (var word in dictionary)\\n            {\\n                var wordLength = word.Length;\\n                var offset = i - wordLength + 1;\\n                var maxLenght = Math.Min(wordLength, sentenceLength - offset);\\n                var isInBounds = offset >= 0;\\n\\n                if ( isInBounds && s.Substring(offset, maxLenght) == word ) // if match\\n                {\\n                    match = Math.Max(match, dp[offset] + wordLength);\\n                }\\n            }\\n            dp.Add(match);\\n        }\\n\\n        return sentenceLength - dp[^1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int MinExtraChar(string s, string[] dictionary)\\n    {\\n        var sentenceLength = s.Length;\\n        var dp = new List<int>() {0};\\n        for (var i = 0; i < sentenceLength; ++i)\\n        {\\n            var match = dp[i];\\n            foreach (var word in dictionary)\\n            {\\n                var wordLength = word.Length;\\n                var offset = i - wordLength + 1;\\n                var maxLenght = Math.Min(wordLength, sentenceLength - offset);\\n                var isInBounds = offset >= 0;\\n\\n                if ( isInBounds && s.Substring(offset, maxLenght) == word ) // if match\\n                {\\n                    match = Math.Max(match, dp[offset] + wordLength);\\n                }\\n            }\\n            dp.Add(match);\\n        }\\n\\n        return sentenceLength - dp[^1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3993599,
                "title": "dynamic-programming-two-different-solutions-top-down-and-bottom-up",
                "content": "Recursive Approch with Memoization:\\n```\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        def find(s, memo):\\n            if s in memo:\\n                return memo[s]\\n            if not s:\\n                return 0\\n            extra1, extra2 = inf, inf\\n            for word in dictionary:\\n                if word == s[:len(word)]:\\n                    extra1 = min(extra1, find(s[len(word):], memo))\\n            extra2 = find(s[1:], memo) + 1 \\n            memo[s] = min(extra1, extra2)\\n            return memo[s]\\n        \\n        return find(s, {})\\n```\\n\\n\\nBottom up approch:\\n```\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        dp = [0] + [inf] * (len(s))\\n        wordSet = set(dictionary)\\n        \\n        for i in range(1, len(s)+1):\\n            dp[i] = dp[i-1] + 1\\n            for j in range(0, i):\\n                if s[j:i] in wordSet:\\n                    dp[i] = min(dp[i], dp[j])\\n        return dp[-1]\\n    \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        def find(s, memo):\\n            if s in memo:\\n                return memo[s]\\n            if not s:\\n                return 0\\n            extra1, extra2 = inf, inf\\n            for word in dictionary:\\n                if word == s[:len(word)]:\\n                    extra1 = min(extra1, find(s[len(word):], memo))\\n            extra2 = find(s[1:], memo) + 1 \\n            memo[s] = min(extra1, extra2)\\n            return memo[s]\\n        \\n        return find(s, {})\\n```\n```\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        dp = [0] + [inf] * (len(s))\\n        wordSet = set(dictionary)\\n        \\n        for i in range(1, len(s)+1):\\n            dp[i] = dp[i-1] + 1\\n            for j in range(0, i):\\n                if s[j:i] in wordSet:\\n                    dp[i] = min(dp[i], dp[j])\\n        return dp[-1]\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3993292,
                "title": "c-super-easy-clean-code-1d-dp-easy-to-grasp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint n;\\nclass Solution {\\nprivate:\\n    int miniNumber(int i, string& s, unordered_set<string>& st, int dp[]){\\n        if(i == n) return 0;\\n        if(dp[i] != -1) return dp[i];\\n\\n        string str = \"\";\\n        int mini = n;\\n        for(int j=i; j<n; j++){\\n            str += s[j];\\n            int curr = st.find(str) == st.end() ? str.size() : 0;\\n            curr += miniNumber(j+1,s,st,dp);\\n            mini = min(mini,curr);\\n        }\\n        return dp[i] = mini;\\n    }\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        \\n        n = s.size();\\n        unordered_set<string> st(dictionary.begin(),dictionary.end());\\n        int dp[n];\\n        memset(dp,-1,sizeof(dp));\\n        return miniNumber(0,s,st,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nint n;\\nclass Solution {\\nprivate:\\n    int miniNumber(int i, string& s, unordered_set<string>& st, int dp[]){\\n        if(i == n) return 0;\\n        if(dp[i] != -1) return dp[i];\\n\\n        string str = \"\";\\n        int mini = n;\\n        for(int j=i; j<n; j++){\\n            str += s[j];\\n            int curr = st.find(str) == st.end() ? str.size() : 0;\\n            curr += miniNumber(j+1,s,st,dp);\\n            mini = min(mini,curr);\\n        }\\n        return dp[i] = mini;\\n    }\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        \\n        n = s.size();\\n        unordered_set<string> st(dictionary.begin(),dictionary.end());\\n        int dp[n];\\n        memset(dp,-1,sizeof(dp));\\n        return miniNumber(0,s,st,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992741,
                "title": "extra-characters-in-a-string",
                "content": "# Code\\n```\\n/**\\n * @param {string} s\\n * @param {string[]} dictionary\\n * @return {number}\\n */\\nvar minExtraChar = function (s, dictionary) {\\n    const max = s.length + 1;\\n    const dp = Array(s.length + 1).fill(max);\\n    dp[0] = 0;\\n\\n    dictionary = new Set(dictionary);\\n    for (let i = 1; i <= s.length; ++i) {\\n        dp[i] = dp[i - 1] + 1;\\n        for (let l = 1; l <= i; ++l) {\\n            if (dictionary.has(s.substring(i - l, i))) {\\n                dp[i] = Math.min(dp[i], dp[i - l]);\\n            }\\n        }\\n    }\\n    return dp[s.length];\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Hash Table",
                    "String",
                    "Dynamic Programming",
                    "Trie"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string[]} dictionary\\n * @return {number}\\n */\\nvar minExtraChar = function (s, dictionary) {\\n    const max = s.length + 1;\\n    const dp = Array(s.length + 1).fill(max);\\n    dp[0] = 0;\\n\\n    dictionary = new Set(dictionary);\\n    for (let i = 1; i <= s.length; ++i) {\\n        dp[i] = dp[i - 1] + 1;\\n        for (let l = 1; l <= i; ++l) {\\n            if (dictionary.has(s.substring(i - l, i))) {\\n                dp[i] = Math.min(dp[i], dp[i - l]);\\n            }\\n        }\\n    }\\n    return dp[s.length];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3992714,
                "title": "go-golang-dynamic-programming-trie",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe GoLang version of the official solution.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDynamic Programming + Trie\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N^2 + M \\\\cdot K)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N + M \\\\cdot K)$$\\n\\n# Code\\n```\\ntype TrieNode struct {\\n    children map[rune]*TrieNode\\n    isWord bool\\n}\\n\\nfunc newTrieNode() * TrieNode {\\n    return &TrieNode{children: make(map[rune]*TrieNode)}\\n}\\n\\nfunc buildTrieNode(dictionary []string) *TrieNode {\\n    root := newTrieNode()\\n    for _, word := range dictionary {\\n        node := root\\n        for _, c := range word {\\n            if _, ok := node.children[c]; !ok {\\n                node.children[c] = newTrieNode()\\n            }\\n            node = node.children[c]\\n        }\\n        node.isWord = true\\n    }\\n\\n    return root\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc minExtraChar(s string, dictionary []string) int {\\n    n := rune(len(s))\\n    root := buildTrieNode(dictionary)\\n    dp := make([]int, n + 1)\\n\\n    for start := n - 1; start >= 0; start-- {\\n        dp[start] = dp[start + 1] + 1\\n        node := root\\n        for end := start; end < n; end++ {\\n            if _, ok := node.children[rune(s[end])]; !ok {\\n                break\\n            }\\n            node = node.children[rune(s[end])]\\n            if node.isWord {\\n                dp[start] = min(dp[start], dp[end + 1])\\n            }\\n        }\\n    }\\n\\n    return dp[0]\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming",
                    "Trie"
                ],
                "code": "```\\ntype TrieNode struct {\\n    children map[rune]*TrieNode\\n    isWord bool\\n}\\n\\nfunc newTrieNode() * TrieNode {\\n    return &TrieNode{children: make(map[rune]*TrieNode)}\\n}\\n\\nfunc buildTrieNode(dictionary []string) *TrieNode {\\n    root := newTrieNode()\\n    for _, word := range dictionary {\\n        node := root\\n        for _, c := range word {\\n            if _, ok := node.children[c]; !ok {\\n                node.children[c] = newTrieNode()\\n            }\\n            node = node.children[c]\\n        }\\n        node.isWord = true\\n    }\\n\\n    return root\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc minExtraChar(s string, dictionary []string) int {\\n    n := rune(len(s))\\n    root := buildTrieNode(dictionary)\\n    dp := make([]int, n + 1)\\n\\n    for start := n - 1; start >= 0; start-- {\\n        dp[start] = dp[start + 1] + 1\\n        node := root\\n        for end := start; end < n; end++ {\\n            if _, ok := node.children[rune(s[end])]; !ok {\\n                break\\n            }\\n            node = node.children[rune(s[end])]\\n            if node.isWord {\\n                dp[start] = min(dp[start], dp[end + 1])\\n            }\\n        }\\n    }\\n\\n    return dp[0]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3992602,
                "title": "beginner-freindly-solution-and-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int solve(int indx,string s,vector<string>&dictionary,vector<int>&dp){\\n        \\n        if(indx>=s.size()){\\n            return 0;\\n        }\\n        \\n        if(dp[indx]!=-1){\\n            return dp[indx];\\n        }\\n        \\n        int res=n;\\n        \\n        for(string str: dictionary){\\n            \\n            int len=str.length();\\n            if(indx+len<=n and s.substr(indx,len)==str ){\\n                \\n                dp[indx]=res=min(res,solve(indx+len,s,dictionary,dp));\\n                \\n            }\\n        }\\n        \\n        int notchoose=1+solve(indx+1,s,dictionary,dp);\\n        \\n        return dp[indx]=min(res,notchoose);\\n    } \\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        \\n        n=s.size();\\n        vector<int>dp(s.size()+1,-1);\\n        return solve(0,s,dictionary,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int solve(int indx,string s,vector<string>&dictionary,vector<int>&dp){\\n        \\n        if(indx>=s.size()){\\n            return 0;\\n        }\\n        \\n        if(dp[indx]!=-1){\\n            return dp[indx];\\n        }\\n        \\n        int res=n;\\n        \\n        for(string str: dictionary){\\n            \\n            int len=str.length();\\n            if(indx+len<=n and s.substr(indx,len)==str ){\\n                \\n                dp[indx]=res=min(res,solve(indx+len,s,dictionary,dp));\\n                \\n            }\\n        }\\n        \\n        int notchoose=1+solve(indx+1,s,dictionary,dp);\\n        \\n        return dp[indx]=min(res,notchoose);\\n    } \\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        \\n        n=s.size();\\n        vector<int>dp(s.size()+1,-1);\\n        return solve(0,s,dictionary,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992447,
                "title": "100-beats-something-different",
                "content": "\\n# Complexity\\n- Time complexity : 6 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : 44.19MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass TrieNode {\\n    TrieNode[] childs;\\n    boolean isLast;\\n    TrieNode() {\\n        this.childs = new TrieNode[26];\\n        this.isLast = false;\\n    }\\n}\\n\\nclass Solution {\\n    TrieNode root;\\n\\n    private void insert(String word) {\\n        TrieNode temp = root;\\n        for(char c : word.toCharArray()) {\\n            int idx = c-\\'a\\';\\n            if(temp.childs[idx] == null) {\\n                temp.childs[idx] = new TrieNode();\\n            }\\n            temp = temp.childs[idx];\\n        }\\n        temp.isLast = true;\\n    }\\n\\n    private int solve(int i, String s, Integer[] dp) {\\n        if(i == s.length()) {\\n            return 0;\\n        }\\n\\n        if(dp[i] != null) {\\n            return dp[i];\\n        }\\n\\n        int minAns = solve(i+1, s, dp)+1;\\n        TrieNode temp = root;\\n        int j = i;\\n\\n        while(j < s.length()) {\\n            int idx = s.charAt(j)-\\'a\\';\\n            temp = temp.childs[idx];\\n\\n            if(temp == null) {\\n                break;\\n            }\\n\\n            if(temp.isLast) {\\n                minAns = Math.min(minAns, solve(j+1, s, dp));\\n            }\\n            j++;\\n        }\\n\\n        return dp[i] = minAns;\\n    }\\n    public int minExtraChar(String s, String[] dictionary) {\\n        \\n        root = new TrieNode();\\n\\n        for(String word : dictionary) {\\n            insert(word);\\n        }\\n\\n        return solve(0, s, new Integer[s.length()]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String",
                    "Dynamic Programming",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode {\\n    TrieNode[] childs;\\n    boolean isLast;\\n    TrieNode() {\\n        this.childs = new TrieNode[26];\\n        this.isLast = false;\\n    }\\n}\\n\\nclass Solution {\\n    TrieNode root;\\n\\n    private void insert(String word) {\\n        TrieNode temp = root;\\n        for(char c : word.toCharArray()) {\\n            int idx = c-\\'a\\';\\n            if(temp.childs[idx] == null) {\\n                temp.childs[idx] = new TrieNode();\\n            }\\n            temp = temp.childs[idx];\\n        }\\n        temp.isLast = true;\\n    }\\n\\n    private int solve(int i, String s, Integer[] dp) {\\n        if(i == s.length()) {\\n            return 0;\\n        }\\n\\n        if(dp[i] != null) {\\n            return dp[i];\\n        }\\n\\n        int minAns = solve(i+1, s, dp)+1;\\n        TrieNode temp = root;\\n        int j = i;\\n\\n        while(j < s.length()) {\\n            int idx = s.charAt(j)-\\'a\\';\\n            temp = temp.childs[idx];\\n\\n            if(temp == null) {\\n                break;\\n            }\\n\\n            if(temp.isLast) {\\n                minAns = Math.min(minAns, solve(j+1, s, dp));\\n            }\\n            j++;\\n        }\\n\\n        return dp[i] = minAns;\\n    }\\n    public int minExtraChar(String s, String[] dictionary) {\\n        \\n        root = new TrieNode();\\n\\n        for(String word : dictionary) {\\n            insert(word);\\n        }\\n\\n        return solve(0, s, new Integer[s.length()]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992400,
                "title": "c-top-down-dp-and-trie",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(sum(n, n - 1, ..., 1) + m)$$?, n is length of s, m is number of characters in dictionary\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n + m)$$?\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n * 2707. Extra Characters in a String\\n *\\n * You are given a 0-indexed string s and a dictionary of words dictionary. \\n * You have to break s into one or more non-overlapping substrings such \\n * that each substring is present in dictionary. There may be some extra \\n * characters in s which are not present in any of the substrings.\\n * \\n * Return the minimum number of extra characters left over if you break up s optimally.\\n *\\n * 1 <= s.length <= 50\\n * 1 <= dictionary.length <= 50\\n * 1 <= dictionary[i].length <= 50\\n * dictionary[i] and s consists of only lowercase English letters\\n * dictionary contains distinct words\\n */\\n\\ntypedef struct node {\\n    struct node *next[26];\\n    bool is_end;\\n} node_t;\\n\\n#define MIN(a, b) ((a) < (b) ? (a) : (b));\\n\\nvoid trie_init(node_t **head)\\n{\\n    *head = (node_t *)calloc(1, sizeof(node_t));\\n}\\n\\nvoid trie_insert(node_t *head, char *s)\\n{\\n    while (*s) {\\n        char c = *s - \\'a\\';\\n\\n        if (head->next[c] == NULL) {\\n            head->next[c] = (node_t *)calloc(1, sizeof(node_t));\\n        }\\n\\n        head = head->next[c];\\n        s++;\\n    }\\n\\n    head->is_end = true;\\n}\\n\\nint trie_search(node_t *head, char *s, int *len_out)\\n{\\n    int cnt = 0, len = 0;\\n\\n    while (*s) {\\n\\n        char c = *s - \\'a\\';\\n\\n        if (head->next[c] == NULL) {\\n            break;\\n        }\\n\\n        head = head->next[c];\\n        s++;\\n        len++;\\n\\n        /* Store the lengths of matching words in output array */\\n        if (head->is_end == true) {\\n            len_out[cnt] = len;\\n            cnt++;\\n        }\\n    }\\n\\n    return cnt;\\n}\\n\\nvoid trie_release(node_t *head)\\n{\\n    if (head) {\\n\\n        for (int i = 0; i < 26; i++) {\\n            trie_release(head->next[i]);\\n        }\\n\\n        free(head);\\n    }\\n}\\n\\nint minExtra(int idx, char *s, node_t *trie, int *dp)\\n{\\n    int lens[50], cnt = 0, min = INT_MAX, extra;\\n\\n    /* Reached end of string, no extra character anymore */\\n    if (s[idx] == 0) {\\n        return 0;\\n    }\\n\\n    if (dp[idx] != -1) {\\n        return dp[idx];\\n    }\\n\\n    /* Checks if any substring starting at the current index matches the words */\\n    cnt = trie_search(trie, &s[idx], lens);\\n\\n    /* Skip matched substrings */\\n    for (int i = 0; i < cnt; i++) {\\n        extra = minExtra(idx + lens[i], s, trie, dp);\\n        min = MIN(min, extra);\\n    }\\n\\n    /* Skip current character */\\n    extra = 1 + minExtra(idx + 1, s, trie, dp);\\n    min = MIN(min, extra);\\n\\n    dp[idx] = min;\\n\\n    return min;\\n}\\n\\nint minExtraChar(char * s, char ** dictionary, int dictionarySize){\\n    /*\\n     * Input:\\n     *  s, 1 <= len <= 50\\n     *  dictionary\\n     *  dictionarySize\\n     */\\n\\n    /*\\n     * Algorithm:\\n     *  Store the words in Trie\\n     *  Scan character 0 ~ n - 1 in s, check if any 0 ~ n - 1 sustring matches the words\\n     *      Skip number of characters and contine to compare the rest characters\\n     *      or skip current character and contine to compare the rest characters\\n     */\\n\\n    node_t *trie = NULL;\\n    int min = 0, len = strlen(s), *dp;\\n\\n    trie_init(&trie);\\n\\n    /* Allocate dp[n - 1][n] DP table, n is the length of s */\\n    dp = (int *)malloc(sizeof(int *) * len);\\n\\n    for (int i = 0; i < len; i++) {\\n        dp[i] = -1;\\n    }\\n\\n    /* Insert words into trie */\\n    for (int i = 0; i < dictionarySize; i++) {\\n        trie_insert(trie, dictionary[i]);\\n    }\\n\\n    /*\\n     * Output:\\n     *  Return the minimum number of extra characters left over if you break up s optimally.\\n     */\\n\\n    min = minExtra(0, s, trie, dp);\\n\\n    /* Release memory */\\n    trie_release(trie);\\n\\n    free(dp);\\n\\n    return min;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Dynamic Programming",
                    "Trie"
                ],
                "code": "```\\n/*\\n * 2707. Extra Characters in a String\\n *\\n * You are given a 0-indexed string s and a dictionary of words dictionary. \\n * You have to break s into one or more non-overlapping substrings such \\n * that each substring is present in dictionary. There may be some extra \\n * characters in s which are not present in any of the substrings.\\n * \\n * Return the minimum number of extra characters left over if you break up s optimally.\\n *\\n * 1 <= s.length <= 50\\n * 1 <= dictionary.length <= 50\\n * 1 <= dictionary[i].length <= 50\\n * dictionary[i] and s consists of only lowercase English letters\\n * dictionary contains distinct words\\n */\\n\\ntypedef struct node {\\n    struct node *next[26];\\n    bool is_end;\\n} node_t;\\n\\n#define MIN(a, b) ((a) < (b) ? (a) : (b));\\n\\nvoid trie_init(node_t **head)\\n{\\n    *head = (node_t *)calloc(1, sizeof(node_t));\\n}\\n\\nvoid trie_insert(node_t *head, char *s)\\n{\\n    while (*s) {\\n        char c = *s - \\'a\\';\\n\\n        if (head->next[c] == NULL) {\\n            head->next[c] = (node_t *)calloc(1, sizeof(node_t));\\n        }\\n\\n        head = head->next[c];\\n        s++;\\n    }\\n\\n    head->is_end = true;\\n}\\n\\nint trie_search(node_t *head, char *s, int *len_out)\\n{\\n    int cnt = 0, len = 0;\\n\\n    while (*s) {\\n\\n        char c = *s - \\'a\\';\\n\\n        if (head->next[c] == NULL) {\\n            break;\\n        }\\n\\n        head = head->next[c];\\n        s++;\\n        len++;\\n\\n        /* Store the lengths of matching words in output array */\\n        if (head->is_end == true) {\\n            len_out[cnt] = len;\\n            cnt++;\\n        }\\n    }\\n\\n    return cnt;\\n}\\n\\nvoid trie_release(node_t *head)\\n{\\n    if (head) {\\n\\n        for (int i = 0; i < 26; i++) {\\n            trie_release(head->next[i]);\\n        }\\n\\n        free(head);\\n    }\\n}\\n\\nint minExtra(int idx, char *s, node_t *trie, int *dp)\\n{\\n    int lens[50], cnt = 0, min = INT_MAX, extra;\\n\\n    /* Reached end of string, no extra character anymore */\\n    if (s[idx] == 0) {\\n        return 0;\\n    }\\n\\n    if (dp[idx] != -1) {\\n        return dp[idx];\\n    }\\n\\n    /* Checks if any substring starting at the current index matches the words */\\n    cnt = trie_search(trie, &s[idx], lens);\\n\\n    /* Skip matched substrings */\\n    for (int i = 0; i < cnt; i++) {\\n        extra = minExtra(idx + lens[i], s, trie, dp);\\n        min = MIN(min, extra);\\n    }\\n\\n    /* Skip current character */\\n    extra = 1 + minExtra(idx + 1, s, trie, dp);\\n    min = MIN(min, extra);\\n\\n    dp[idx] = min;\\n\\n    return min;\\n}\\n\\nint minExtraChar(char * s, char ** dictionary, int dictionarySize){\\n    /*\\n     * Input:\\n     *  s, 1 <= len <= 50\\n     *  dictionary\\n     *  dictionarySize\\n     */\\n\\n    /*\\n     * Algorithm:\\n     *  Store the words in Trie\\n     *  Scan character 0 ~ n - 1 in s, check if any 0 ~ n - 1 sustring matches the words\\n     *      Skip number of characters and contine to compare the rest characters\\n     *      or skip current character and contine to compare the rest characters\\n     */\\n\\n    node_t *trie = NULL;\\n    int min = 0, len = strlen(s), *dp;\\n\\n    trie_init(&trie);\\n\\n    /* Allocate dp[n - 1][n] DP table, n is the length of s */\\n    dp = (int *)malloc(sizeof(int *) * len);\\n\\n    for (int i = 0; i < len; i++) {\\n        dp[i] = -1;\\n    }\\n\\n    /* Insert words into trie */\\n    for (int i = 0; i < dictionarySize; i++) {\\n        trie_insert(trie, dictionary[i]);\\n    }\\n\\n    /*\\n     * Output:\\n     *  Return the minimum number of extra characters left over if you break up s optimally.\\n     */\\n\\n    min = minExtra(0, s, trie, dp);\\n\\n    /* Release memory */\\n    trie_release(trie);\\n\\n    free(dp);\\n\\n    return min;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3992104,
                "title": "c-dp-memoisation-cleans-and-killer-solution-by-sd",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity :O(n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->   \\n\\n- Space complexity:O(n+m+k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& d) \\n    {\\n        unordered_map<string,bool>mp;\\n        for(auto i :d)\\n        {\\n            mp[i]=true;\\n        }\\n        vector<int>dp(s.size(),-1);\\n        return rec(0,dp,mp,s);\\n    }\\n    int rec(int index,vector<int>&dp,unordered_map<string,bool>&mp,string s)\\n    {\\n        if(index>=s.length())\\n        return 0;\\n        if(dp[index]!=-1)\\n        return dp[index];\\n        string curr=\"\";\\n        int res=s.length();\\n        for(int i=index;i<s.length();i++)\\n        {\\n            curr.push_back(s[i]);\\n            int extra=curr.size();\\n            if(mp[curr])\\n            extra=0;\\n            extra+=rec(i+1,dp,mp,s);\\n            res=min(res,extra);\\n        }\\n        dp[index]=res;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& d) \\n    {\\n        unordered_map<string,bool>mp;\\n        for(auto i :d)\\n        {\\n            mp[i]=true;\\n        }\\n        vector<int>dp(s.size(),-1);\\n        return rec(0,dp,mp,s);\\n    }\\n    int rec(int index,vector<int>&dp,unordered_map<string,bool>&mp,string s)\\n    {\\n        if(index>=s.length())\\n        return 0;\\n        if(dp[index]!=-1)\\n        return dp[index];\\n        string curr=\"\";\\n        int res=s.length();\\n        for(int i=index;i<s.length();i++)\\n        {\\n            curr.push_back(s[i]);\\n            int extra=curr.size();\\n            if(mp[curr])\\n            extra=0;\\n            extra+=rec(i+1,dp,mp,s);\\n            res=min(res,extra);\\n        }\\n        dp[index]=res;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992026,
                "title": "java-33",
                "content": "# Code\\n```\\nclass Solution {\\n    Integer[] memo;\\n    HashSet<String> dictionarySet;\\n    public int minExtraChar(String s, String[] dictionary) {\\n        int n = s.length();\\n        memo = new Integer[n];\\n        dictionarySet = new HashSet<>(Arrays.asList(dictionary));\\n        return dp(0, n, s);\\n    }\\n    private int dp(int start, int n, String s) {\\n        if (start == n) {\\n            return 0;\\n        }\\n        if (memo[start] != null) {\\n            return memo[start];\\n        }\\n        // To count this character as a left over character \\n        // move to index \\'start + 1\\'\\n        int ans = dp(start + 1, n, s) + 1;\\n        for (int end = start; end < n; end++) {\\n            var curr = s.substring(start, end + 1);\\n            if (dictionarySet.contains(curr)) {\\n                ans = Math.min(ans, dp(end + 1, n, s));\\n            }\\n        }\\n\\n        return memo[start] = ans;\\n    }\\n}/*Let n be the total characters in the string.\\nLet m be the average length of the strings in dictionary.\\nLet k be the length of the dictionary\\nTC:O(n^3),SC:O(n+m.k)*/\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Integer[] memo;\\n    HashSet<String> dictionarySet;\\n    public int minExtraChar(String s, String[] dictionary) {\\n        int n = s.length();\\n        memo = new Integer[n];\\n        dictionarySet = new HashSet<>(Arrays.asList(dictionary));\\n        return dp(0, n, s);\\n    }\\n    private int dp(int start, int n, String s) {\\n        if (start == n) {\\n            return 0;\\n        }\\n        if (memo[start] != null) {\\n            return memo[start];\\n        }\\n        // To count this character as a left over character \\n        // move to index \\'start + 1\\'\\n        int ans = dp(start + 1, n, s) + 1;\\n        for (int end = start; end < n; end++) {\\n            var curr = s.substring(start, end + 1);\\n            if (dictionarySet.contains(curr)) {\\n                ans = Math.min(ans, dp(end + 1, n, s));\\n            }\\n        }\\n\\n        return memo[start] = ans;\\n    }\\n}/*Let n be the total characters in the string.\\nLet m be the average length of the strings in dictionary.\\nLet k be the length of the dictionary\\nTC:O(n^3),SC:O(n+m.k)*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991741,
                "title": "java-dp-solution-recursion-memoization-beats-96-45-dp",
                "content": "# Approach\\nGeneral take/notTake approach:\\n\\n1. **NotTake** : Skip the current character and jump to next characater of the string.\\n2. **Take** : Check in the map<char,array<string>> whether any word start with the current character,\\n    1. If Yes : take each string and check whether such substring is \\n        can be formed then add that length and move ahead.\\n    2. If No : then skip take step.\\n3. return thr max length from take and nottake solution \\n4. finally in substract the ans from string s.length() to get the minimum extra characters.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)+Auxilliary space.\\n# Code\\n```\\nclass Solution {\\n    Map<Character,List<String>> map = new HashMap<>();\\n    int dp[];\\n    int solve(int ind,String s){\\n        if(ind >= s.length())\\n            return 0;\\n        \\n        if(dp[ind] != -1)\\n            return dp[ind];\\n\\n        char ch = s.charAt(ind);\\n\\n        //skip curr char\\n        int notTake = solve(ind+1,s);\\n\\n        //if map contains keys with curr char check their lengths\\n        int take = (int)-1e9;\\n        if(map.containsKey(ch)){\\n            for(String str : map.get(ch)){\\n                int len = str.length();\\n                if(ind+len <= s.length()){\\n                    String subStr = s.substring(ind,ind+len);\\n                    if(subStr.equals(str)){\\n                        take = Math.max(take , len + solve(ind+len,s));\\n                }\\n                }\\n            }\\n        }\\n\\n        return dp[ind] = Math.max(notTake , take);\\n    }\\n    \\n    public int minExtraChar(String s, String[] dictionary) {\\n        dp = new int [s.length()];\\n        Arrays.fill(dp,-1);\\n\\n        for(String str:dictionary){\\n            char ch = str.charAt(0);\\n            if(!map.containsKey(ch)){\\n                map.put(ch,new ArrayList<>());\\n            }\\n            map.get(ch).add(str);\\n        }\\n\\n        return (s.length() - solve(0,s));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    Map<Character,List<String>> map = new HashMap<>();\\n    int dp[];\\n    int solve(int ind,String s){\\n        if(ind >= s.length())\\n            return 0;\\n        \\n        if(dp[ind] != -1)\\n            return dp[ind];\\n\\n        char ch = s.charAt(ind);\\n\\n        //skip curr char\\n        int notTake = solve(ind+1,s);\\n\\n        //if map contains keys with curr char check their lengths\\n        int take = (int)-1e9;\\n        if(map.containsKey(ch)){\\n            for(String str : map.get(ch)){\\n                int len = str.length();\\n                if(ind+len <= s.length()){\\n                    String subStr = s.substring(ind,ind+len);\\n                    if(subStr.equals(str)){\\n                        take = Math.max(take , len + solve(ind+len,s));\\n                }\\n                }\\n            }\\n        }\\n\\n        return dp[ind] = Math.max(notTake , take);\\n    }\\n    \\n    public int minExtraChar(String s, String[] dictionary) {\\n        dp = new int [s.length()];\\n        Arrays.fill(dp,-1);\\n\\n        for(String str:dictionary){\\n            char ch = str.charAt(0);\\n            if(!map.containsKey(ch)){\\n                map.put(ch,new ArrayList<>());\\n            }\\n            map.get(ch).add(str);\\n        }\\n\\n        return (s.length() - solve(0,s));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991623,
                "title": "simple-c-solution-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRecursively the traverse the string and try to match dictionary words with the words from current index and then try to skip current index and traverse from next index and then return minimum of two.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Function to recursively traverse the input string \\'s\\' and find the minimum number\\n    // of extra characters required to make it a concatenation of words from \\'dictionary\\'.\\n    int traverseString(int index, string &s, int cnt, unordered_set<string>& us, int &ans, vector<int>& dp) {\\n        // If the current count \\'cnt\\' exceeds the current minimum answer \\'ans\\',\\n        // return a value greater than the size of \\'s\\' to indicate that this branch\\n        // of recursion should be terminated early.\\n        if (cnt > ans)\\n            return s.size() + 1;\\n\\n        // If we have reached the end of the input string, update \\'ans\\' with the\\n        // minimum count \\'cnt\\' if it\\'s smaller than the current \\'ans\\', and return 0\\n        // to indicate the end of recursion.\\n        if (index == s.size()) {\\n            ans = min(ans, cnt);\\n            return 0;\\n        }\\n\\n        // If the minimum count for this index has already been calculated, return it.\\n        if (dp[index] != s.size() + 2)\\n            return dp[index];\\n\\n        // Iterate through the words in \\'dictionary\\' to check if they match the substring\\n        // starting from the current \\'index\\' of \\'s\\'.\\n        for (string it : us) {\\n            int len = it.size();\\n            string nxt = s.substr(index, len);\\n            \\n            // If a word from \\'dictionary\\' matches the substring, recursively call\\n            // \\'traverseString\\' with the updated index and count.\\n            if (nxt == it) {\\n                dp[index] = min(dp[index], traverseString(index + len, s, cnt, us, ans, dp));\\n            }\\n        }\\n\\n        // Continue the recursion by moving to the next character in \\'s\\' and incrementing \\'cnt\\'.\\n        dp[index] = min(dp[index], 1 + traverseString(index + 1, s, cnt + 1, us, ans, dp));\\n\\n        return dp[index];\\n    }\\n\\n    // Main function to find the minimum number of extra characters required to\\n    // make \\'s\\' a concatenation of words from \\'dictionary\\'.\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_set<string> us;\\n        int len = s.size();\\n        vector<int> dp(len, len + 2);\\n        int n = dictionary.size();\\n\\n        // Populate the unordered_set \\'us\\' with words from \\'dictionary\\'.\\n        for (int i = 0; i < n; i++) {\\n            us.insert(dictionary[i]);\\n        }\\n\\n        int ans = INT_MAX;\\n\\n        // Start the traversal from index 0 of \\'s\\' with an initial count of 0.\\n        traverseString(0, s, 0, us, ans, dp);\\n\\n        // Return the minimum count of extra characters required.\\n        return min(dp[0], ans);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Function to recursively traverse the input string \\'s\\' and find the minimum number\\n    // of extra characters required to make it a concatenation of words from \\'dictionary\\'.\\n    int traverseString(int index, string &s, int cnt, unordered_set<string>& us, int &ans, vector<int>& dp) {\\n        // If the current count \\'cnt\\' exceeds the current minimum answer \\'ans\\',\\n        // return a value greater than the size of \\'s\\' to indicate that this branch\\n        // of recursion should be terminated early.\\n        if (cnt > ans)\\n            return s.size() + 1;\\n\\n        // If we have reached the end of the input string, update \\'ans\\' with the\\n        // minimum count \\'cnt\\' if it\\'s smaller than the current \\'ans\\', and return 0\\n        // to indicate the end of recursion.\\n        if (index == s.size()) {\\n            ans = min(ans, cnt);\\n            return 0;\\n        }\\n\\n        // If the minimum count for this index has already been calculated, return it.\\n        if (dp[index] != s.size() + 2)\\n            return dp[index];\\n\\n        // Iterate through the words in \\'dictionary\\' to check if they match the substring\\n        // starting from the current \\'index\\' of \\'s\\'.\\n        for (string it : us) {\\n            int len = it.size();\\n            string nxt = s.substr(index, len);\\n            \\n            // If a word from \\'dictionary\\' matches the substring, recursively call\\n            // \\'traverseString\\' with the updated index and count.\\n            if (nxt == it) {\\n                dp[index] = min(dp[index], traverseString(index + len, s, cnt, us, ans, dp));\\n            }\\n        }\\n\\n        // Continue the recursion by moving to the next character in \\'s\\' and incrementing \\'cnt\\'.\\n        dp[index] = min(dp[index], 1 + traverseString(index + 1, s, cnt + 1, us, ans, dp));\\n\\n        return dp[index];\\n    }\\n\\n    // Main function to find the minimum number of extra characters required to\\n    // make \\'s\\' a concatenation of words from \\'dictionary\\'.\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_set<string> us;\\n        int len = s.size();\\n        vector<int> dp(len, len + 2);\\n        int n = dictionary.size();\\n\\n        // Populate the unordered_set \\'us\\' with words from \\'dictionary\\'.\\n        for (int i = 0; i < n; i++) {\\n            us.insert(dictionary[i]);\\n        }\\n\\n        int ans = INT_MAX;\\n\\n        // Start the traversal from index 0 of \\'s\\' with an initial count of 0.\\n        traverseString(0, s, 0, us, ans, dp);\\n\\n        // Return the minimum count of extra characters required.\\n        return min(dp[0], ans);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991611,
                "title": "python-easy-to-understand-explained",
                "content": "# Python | Easy to Understand | Explained \\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        # Get the length of the input string \\'s\\'\\n        n = len(s)\\n        \\n        # Create a defaultdict \\'word_dict\\' to store words grouped by their first characters\\n        word_dict = defaultdict(list)\\n        \\n        # Populate \\'word_dict\\' with words from the \\'dictionary\\' list\\n        for word in dictionary:\\n            word_dict[word[0]].append(word)\\n            \\n        # Initialize a list \\'result\\' of length \\'n+1\\' to store minimum extra characters at each position\\n        result = [0] * (n + 1)\\n        \\n        # Iterate through the string \\'s\\' from right to left\\n        for i in range(n - 1, -1, -1):\\n            # Initialize the current position in \\'result\\' with one more extra character than the next position\\n            result[i] = result[i + 1] + 1\\n            \\n            # Check if the current character \\'s[i]\\' is found in \\'word_dict\\'\\n            if s[i] in word_dict:\\n                # Iterate through the words that start with \\'s[i]\\'\\n                for word in word_dict[s[i]]:\\n                    # Check if the substring starting at position \\'i\\' matches the current word\\n                    if s[i:i + len(word)] == word:\\n                        # Update \\'result[i]\\' with the minimum of its current value and \\'result[i + len(word)]\\'\\n                        result[i] = min(result[i], result[i + len(word)])\\n                        \\n        # Return the minimum number of extra characters left when breaking the string optimally\\n        return result[0]\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        # Get the length of the input string \\'s\\'\\n        n = len(s)\\n        \\n        # Create a defaultdict \\'word_dict\\' to store words grouped by their first characters\\n        word_dict = defaultdict(list)\\n        \\n        # Populate \\'word_dict\\' with words from the \\'dictionary\\' list\\n        for word in dictionary:\\n            word_dict[word[0]].append(word)\\n            \\n        # Initialize a list \\'result\\' of length \\'n+1\\' to store minimum extra characters at each position\\n        result = [0] * (n + 1)\\n        \\n        # Iterate through the string \\'s\\' from right to left\\n        for i in range(n - 1, -1, -1):\\n            # Initialize the current position in \\'result\\' with one more extra character than the next position\\n            result[i] = result[i + 1] + 1\\n            \\n            # Check if the current character \\'s[i]\\' is found in \\'word_dict\\'\\n            if s[i] in word_dict:\\n                # Iterate through the words that start with \\'s[i]\\'\\n                for word in word_dict[s[i]]:\\n                    # Check if the substring starting at position \\'i\\' matches the current word\\n                    if s[i:i + len(word)] == word:\\n                        # Update \\'result[i]\\' with the minimum of its current value and \\'result[i + len(word)]\\'\\n                        result[i] = min(result[i], result[i + len(word)])\\n                        \\n        # Return the minimum number of extra characters left when breaking the string optimally\\n        return result[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991568,
                "title": "c-easy-to-understand-top-down-memoization",
                "content": "# C++ | Easy to Understand | TOP-DOWN MEMOIZATION\\n```\\nclass Solution {\\npublic:\\n    int solve(string& s, unordered_map<string, int>&mp, vector<int>&dp, int index)\\n    {\\n        if (index >= s.size()) return 0;\\n        if (dp[index] != -1) return dp[index];\\n        \\n        string currStr = \"\";\\n        int minExtra = s.size();\\n        for (int cutIdx = index; cutIdx < s.size(); cutIdx++)\\n        {\\n            currStr.push_back(s[cutIdx]);\\n        \\n            int currExtra = (mp.count(currStr))? 0 : currStr.size();\\n            int nextExtra = solve(s, mp, dp, cutIdx + 1);\\n            int totalExtra = currExtra + nextExtra;\\n            \\n            minExtra = min(minExtra, totalExtra);\\n        }\\n        return dp[index] = minExtra;\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) \\n    {\\n        vector<int>dp(s.size(), -1);\\n        unordered_map<string, int>mp;\\n        for (string& word : dictionary) mp[word]++;\\n        \\n        int ans = solve(s, mp, dp, 0);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(string& s, unordered_map<string, int>&mp, vector<int>&dp, int index)\\n    {\\n        if (index >= s.size()) return 0;\\n        if (dp[index] != -1) return dp[index];\\n        \\n        string currStr = \"\";\\n        int minExtra = s.size();\\n        for (int cutIdx = index; cutIdx < s.size(); cutIdx++)\\n        {\\n            currStr.push_back(s[cutIdx]);\\n        \\n            int currExtra = (mp.count(currStr))? 0 : currStr.size();\\n            int nextExtra = solve(s, mp, dp, cutIdx + 1);\\n            int totalExtra = currExtra + nextExtra;\\n            \\n            minExtra = min(minExtra, totalExtra);\\n        }\\n        return dp[index] = minExtra;\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) \\n    {\\n        vector<int>dp(s.size(), -1);\\n        unordered_map<string, int>mp;\\n        for (string& word : dictionary) mp[word]++;\\n        \\n        int ans = solve(s, mp, dp, 0);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991480,
                "title": "c-solution-for-extra-characters-in-a-string-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\u2022\\tThe goal is to find the minimum number of extra characters left over when breaking s into substrings from the dictionary.\\n\\u2022\\tWe use dynamic programming to find the optimal way to break s into substrings by considering each possible ending position of a substring and tracking the minimum number of extra characters.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.\\tInitialize a set (dictionarySet) to store the dictionary words for efficient lookup.\\n2.\\tInitialize an array dp of size n + 1, where n is the length of s. dp[i] represents the minimum number of extra characters left over when considering the substring starting from position i to the end of the string s.\\n3.\\tIterate through the string s from right to left (from the end to the start).\\n4.\\tFor each starting position start, initialize dp[start] to dp[start + 1] + 1, which represents breaking s into a substring starting from start to the end of s, leaving one extra character.\\n5.\\tThen, iterate through all possible ending positions end starting from start to n.\\n6.\\tFor each substring s[start:end+1], check if it\\u2019s in the dictionarySet. If it is, update dp[start] to the minimum between its current value and dp[end + 1].\\n7.\\tFinally, dp[0] will represent the minimum number of extra characters left over when breaking s optimally.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution is O(n^3), where n is the length of the input string s. This is because, in the worst case, for each starting position start, we consider all possible ending positions end, resulting in O(n^2) iterations, and for each end, we potentially create a substring of length O(n) to check if it\\u2019s in the dictionarySet.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(n) due to the dp array and O(m) due to the dictionarySet, where m is the number of words in the dictionary. Therefore, the overall space complexity is O(max(n, m)).\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinExtraChar(string s, string[] dictionary) {\\n        int n = s.Length;\\n        var dictionarySet = new HashSet<string>(dictionary);\\n        var dp = new int[n + 1];\\n\\n        for (int start = n - 1; start >= 0; start--) {\\n            dp[start] = dp[start + 1] + 1;\\n            for (int end = start; end < n; end++) {\\n                var curr = s.Substring(start, end - start + 1);\\n                if (dictionarySet.Contains(curr)) {\\n                    dp[start] = Math.Min(dp[start], dp[end + 1]);\\n                }\\n            }\\n        }\\n\\n        return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinExtraChar(string s, string[] dictionary) {\\n        int n = s.Length;\\n        var dictionarySet = new HashSet<string>(dictionary);\\n        var dp = new int[n + 1];\\n\\n        for (int start = n - 1; start >= 0; start--) {\\n            dp[start] = dp[start + 1] + 1;\\n            for (int end = start; end < n; end++) {\\n                var curr = s.Substring(start, end - start + 1);\\n                if (dictionarySet.Contains(curr)) {\\n                    dp[start] = Math.Min(dp[start], dp[end + 1]);\\n                }\\n            }\\n        }\\n\\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991469,
                "title": "pure-c-beats-100-00",
                "content": "# Approach\\nRecursive approach. Base cases are  1. if you reach the end of the string, return 0; 2. if result is already caluculated for current string posotion and word, return that result; 3. checked all dictionary words for this position, move to the next position in the string.\\n\\nRecursive calls check if current word length or another word at the same position would provide the longest length. The else statement handles the case where no matching word is found by repeatedly checking the next word which will eventually move to the next position if no match found due to the 3rd base case.\\n\\n# Code\\n```\\nint memo[51][51];\\n\\nint findMaxLen(char *s, char **dict, int sPos, int wordNum, int wSize, int sSize)\\n{\\n    if (sPos == sSize)\\n        return 0;\\n    if (memo[sPos][wordNum] != -1)\\n        return memo[sPos][wordNum];\\n\\n    if (wordNum == wSize)\\n    {\\n        memo[sPos][wordNum] = findMaxLen(s, dict, sPos + 1, 0, wSize, sSize);\\n        return memo[sPos][wordNum];\\n    }\\n\\n    int len = strlen(dict[wordNum]);\\n    if (strncmp(&(s[sPos]), dict[wordNum], len) == 0)\\n    {\\n        int path1 = len + findMaxLen(s, dict, sPos + len, 0, wSize, sSize);\\n        int path2 = findMaxLen(s, dict, sPos, wordNum + 1, wSize, sSize);\\n        memo[sPos][wordNum] = fmax(path1, path2);\\n        return memo[sPos][wordNum];\\n    }\\n    else\\n    {\\n        return findMaxLen(s, dict, sPos, wordNum + 1, wSize, sSize);\\n    }\\n}\\n\\nint minExtraChar(char * s, char ** dictionary, int dictionarySize){\\n    memset(memo, -1, sizeof(memo));\\n    return strlen(s) - findMaxLen(s, dictionary, 0, 0, dictionarySize, strlen(s));\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint memo[51][51];\\n\\nint findMaxLen(char *s, char **dict, int sPos, int wordNum, int wSize, int sSize)\\n{\\n    if (sPos == sSize)\\n        return 0;\\n    if (memo[sPos][wordNum] != -1)\\n        return memo[sPos][wordNum];\\n\\n    if (wordNum == wSize)\\n    {\\n        memo[sPos][wordNum] = findMaxLen(s, dict, sPos + 1, 0, wSize, sSize);\\n        return memo[sPos][wordNum];\\n    }\\n\\n    int len = strlen(dict[wordNum]);\\n    if (strncmp(&(s[sPos]), dict[wordNum], len) == 0)\\n    {\\n        int path1 = len + findMaxLen(s, dict, sPos + len, 0, wSize, sSize);\\n        int path2 = findMaxLen(s, dict, sPos, wordNum + 1, wSize, sSize);\\n        memo[sPos][wordNum] = fmax(path1, path2);\\n        return memo[sPos][wordNum];\\n    }\\n    else\\n    {\\n        return findMaxLen(s, dict, sPos, wordNum + 1, wSize, sSize);\\n    }\\n}\\n\\nint minExtraChar(char * s, char ** dictionary, int dictionarySize){\\n    memset(memo, -1, sizeof(memo));\\n    return strlen(s) - findMaxLen(s, dictionary, 0, 0, dictionarySize, strlen(s));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3991337,
                "title": "python-3-top-down-dp",
                "content": "# Intuition\\nFor each character in s, you loop all words and all characters in dictionary  to find if a certain word can be taken. Evaluate by using tc, tc would be 50 x 50 x 50 = 125_000 -> Possible.\\n\\n# Approach\\nTop down dp\\n\\n# Complexity\\n- Time complexity:\\nO(sdw) -> double loop with word slicing\\n\\n- Space complexity:\\nO(s) -> dp cache size\\n\\ns = len(s)\\nd = len(dictionary)\\nw = average length of words in dictionary\\n\\n# Code\\n```\\nimport collections\\n\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        @cache\\n        def dp(i): # return int, min delete\\n            if i == len(s):\\n                return 0\\n            \\n            res = float(\\'inf\\')\\n\\n            # take s[i]\\n            for word in dictionary:\\n                if len(word) + i > len(s): # word too long\\n                    continue\\n                \\n                sub_s = s[i: i + len(word)]\\n                \\n                # can take word\\n                if sub_s == word:\\n                    res = min(res, dp(i + len(word)))\\n\\n            # skip s[i]\\n            res = min(res, dp(i + 1) + 1)\\n\\n            return res\\n\\n        return dp(0)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nimport collections\\n\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        @cache\\n        def dp(i): # return int, min delete\\n            if i == len(s):\\n                return 0\\n            \\n            res = float(\\'inf\\')\\n\\n            # take s[i]\\n            for word in dictionary:\\n                if len(word) + i > len(s): # word too long\\n                    continue\\n                \\n                sub_s = s[i: i + len(word)]\\n                \\n                # can take word\\n                if sub_s == word:\\n                    res = min(res, dp(i + len(word)))\\n\\n            # skip s[i]\\n            res = min(res, dp(i + 1) + 1)\\n\\n            return res\\n\\n        return dp(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991333,
                "title": "go-solution-using-recursion-and-memoization-93-5-faster",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsed Recursion And Memoization\\n\\n(Additionaly, I break dictionary on the basis of first character)\\n\\n# Code\\n```\\nvar grpMp map[byte][]string\\nvar cacheMp map[string]int\\n\\nfunc matchVal(s, st string) (int, bool) {\\n    if len(s) < len(st) {\\n        return 0, true\\n    }\\n    for j:=0;j<len(st);j++ {\\n        if s[j] != st[j] {\\n            return 0, true\\n        }\\n    }\\n    return len(st), false\\n}\\n\\nfunc calc(s string) int {\\n    if val, ok := cacheMp[s]; ok {\\n        return val\\n    }\\n\\n    if s == \"\" {\\n        cacheMp[s] = 0\\n        return 0\\n    }\\n\\n    strArr, ok := grpMp[s[0]]\\n    if !ok {\\n        return 1 + calc(s[1:], )\\n    }\\n\\n    ans := -1\\n    for _, str := range strArr {\\n        lenS, err := matchVal(s, str)\\n        if err {\\n            continue\\n        }\\n        temp := calc(s[lenS:])\\n        if ans == -1 {\\n            ans = temp\\n        }\\n        if temp < ans {\\n            ans = temp\\n        }\\n    }\\n\\n    ans2 := 1 + calc(s[1:])\\n    if ans == -1 {\\n        cacheMp[s] = ans2\\n        return ans2\\n    }\\n\\n    if ans < ans2 {\\n        cacheMp[s] = ans\\n        return ans\\n    }\\n    cacheMp[s] = ans2\\n    return ans2\\n}\\n\\nfunc minExtraChar(s string, dict []string) int {\\n    cacheMp = make(map[string]int, 0)\\n\\n    grpMp = make(map[byte][]string, 0)\\n    for _, str := range dict {\\n        if _, ok := grpMp[str[0]]; !ok {\\n            grpMp[str[0]] = make([]string, 0, len(dict))\\n        }\\n        grpMp[str[0]] = append(grpMp[str[0]], str)\\n    }\\n\\n    return calc(s)\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nvar grpMp map[byte][]string\\nvar cacheMp map[string]int\\n\\nfunc matchVal(s, st string) (int, bool) {\\n    if len(s) < len(st) {\\n        return 0, true\\n    }\\n    for j:=0;j<len(st);j++ {\\n        if s[j] != st[j] {\\n            return 0, true\\n        }\\n    }\\n    return len(st), false\\n}\\n\\nfunc calc(s string) int {\\n    if val, ok := cacheMp[s]; ok {\\n        return val\\n    }\\n\\n    if s == \"\" {\\n        cacheMp[s] = 0\\n        return 0\\n    }\\n\\n    strArr, ok := grpMp[s[0]]\\n    if !ok {\\n        return 1 + calc(s[1:], )\\n    }\\n\\n    ans := -1\\n    for _, str := range strArr {\\n        lenS, err := matchVal(s, str)\\n        if err {\\n            continue\\n        }\\n        temp := calc(s[lenS:])\\n        if ans == -1 {\\n            ans = temp\\n        }\\n        if temp < ans {\\n            ans = temp\\n        }\\n    }\\n\\n    ans2 := 1 + calc(s[1:])\\n    if ans == -1 {\\n        cacheMp[s] = ans2\\n        return ans2\\n    }\\n\\n    if ans < ans2 {\\n        cacheMp[s] = ans\\n        return ans\\n    }\\n    cacheMp[s] = ans2\\n    return ans2\\n}\\n\\nfunc minExtraChar(s string, dict []string) int {\\n    cacheMp = make(map[string]int, 0)\\n\\n    grpMp = make(map[byte][]string, 0)\\n    for _, str := range dict {\\n        if _, ok := grpMp[str[0]]; !ok {\\n            grpMp[str[0]] = make([]string, 0, len(dict))\\n        }\\n        grpMp[str[0]] = append(grpMp[str[0]], str)\\n    }\\n\\n    return calc(s)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3991034,
                "title": "java-100-faster-commented-clean-code-trie-dynamic-programming-recursion-memoization",
                "content": "# Complexity\\n- Time complexity: $$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n*m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//TrieNode\\nclass TrieNode {\\n    TrieNode[] childs;\\n    boolean isLast;\\n    TrieNode() {\\n        this.childs = new TrieNode[26];\\n        this.isLast = false;\\n    }\\n}\\nclass Solution {\\n    TrieNode root;\\n\\n    //Method to insert into the Trie Tree\\n    private void insert(String word) {\\n        TrieNode temp = root;\\n        for(char c : word.toCharArray()) {\\n            int idx = c-\\'a\\';\\n            if(temp.childs[idx] == null) {\\n                temp.childs[idx] = new TrieNode();\\n            }\\n            temp = temp.childs[idx];\\n        }\\n        temp.isLast = true;\\n    }\\n\\n    //Recursive method to solve.\\n    private int solve(int i, String s, Integer[] dp) {\\n        if(i == s.length()) {\\n            return 0;\\n        }\\n\\n        //Using the caching for solving overlapping sub problems\\n        if(dp[i] != null) {\\n            return dp[i];\\n        }\\n\\n        //Trying out possibility for the current word to delete.\\n        int minAns = solve(i+1, s, dp)+1;\\n        TrieNode temp = root;\\n        int j = i;\\n\\n        //Trying to fing the word available in dictionary\\n        while(j < s.length()) {\\n            int idx = s.charAt(j)-\\'a\\';\\n            temp = temp.childs[idx];\\n\\n            //If no word found then breaking\\n            if(temp == null) {\\n                break;\\n            }\\n\\n            //If found a word then recursively solveing problem for remaining word\\n            if(temp.isLast) {\\n                minAns = Math.min(minAns, solve(j+1, s, dp));\\n            }\\n            j++;\\n        }\\n\\n        //Caching and returning the minimum deletion\\n        return dp[i] = minAns;\\n    }\\n    public int minExtraChar(String s, String[] dictionary) {\\n        //root of the Trie Tree\\n        root = new TrieNode();\\n\\n        //Creating a Trie Tree using dictionary words\\n        for(String word : dictionary) {\\n            insert(word);\\n        }\\n\\n        //Recursive method to solve using dynamic programming\\n        return solve(0, s, new Integer[s.length()]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming",
                    "Trie",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n//TrieNode\\nclass TrieNode {\\n    TrieNode[] childs;\\n    boolean isLast;\\n    TrieNode() {\\n        this.childs = new TrieNode[26];\\n        this.isLast = false;\\n    }\\n}\\nclass Solution {\\n    TrieNode root;\\n\\n    //Method to insert into the Trie Tree\\n    private void insert(String word) {\\n        TrieNode temp = root;\\n        for(char c : word.toCharArray()) {\\n            int idx = c-\\'a\\';\\n            if(temp.childs[idx] == null) {\\n                temp.childs[idx] = new TrieNode();\\n            }\\n            temp = temp.childs[idx];\\n        }\\n        temp.isLast = true;\\n    }\\n\\n    //Recursive method to solve.\\n    private int solve(int i, String s, Integer[] dp) {\\n        if(i == s.length()) {\\n            return 0;\\n        }\\n\\n        //Using the caching for solving overlapping sub problems\\n        if(dp[i] != null) {\\n            return dp[i];\\n        }\\n\\n        //Trying out possibility for the current word to delete.\\n        int minAns = solve(i+1, s, dp)+1;\\n        TrieNode temp = root;\\n        int j = i;\\n\\n        //Trying to fing the word available in dictionary\\n        while(j < s.length()) {\\n            int idx = s.charAt(j)-\\'a\\';\\n            temp = temp.childs[idx];\\n\\n            //If no word found then breaking\\n            if(temp == null) {\\n                break;\\n            }\\n\\n            //If found a word then recursively solveing problem for remaining word\\n            if(temp.isLast) {\\n                minAns = Math.min(minAns, solve(j+1, s, dp));\\n            }\\n            j++;\\n        }\\n\\n        //Caching and returning the minimum deletion\\n        return dp[i] = minAns;\\n    }\\n    public int minExtraChar(String s, String[] dictionary) {\\n        //root of the Trie Tree\\n        root = new TrieNode();\\n\\n        //Creating a Trie Tree using dictionary words\\n        for(String word : dictionary) {\\n            insert(word);\\n        }\\n\\n        //Recursive method to solve using dynamic programming\\n        return solve(0, s, new Integer[s.length()]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990861,
                "title": "bottom-up-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        \\n        n = len(s)\\n        dp = [float(\\'inf\\')] * (n + 1)\\n        dp[0] = 0\\n\\n        for i in range(1, n + 1):\\n            for word in dictionary:\\n                if i >= len(word) and s[i - len(word):i] == word:\\n                    dp[i] = min(dp[i], dp[i - len(word)])\\n\\n            dp[i] = min(dp[i], dp[i - 1] + 1)\\n\\n        return dp[n]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        \\n        n = len(s)\\n        dp = [float(\\'inf\\')] * (n + 1)\\n        dp[0] = 0\\n\\n        for i in range(1, n + 1):\\n            for word in dictionary:\\n                if i >= len(word) and s[i - len(word):i] == word:\\n                    dp[i] = min(dp[i], dp[i - len(word)])\\n\\n            dp[i] = min(dp[i], dp[i - 1] + 1)\\n\\n        return dp[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990826,
                "title": "python-reversed-trie-and-dp-99-21",
                "content": "# Complexity\\n$D$ denotes summation of word length in $dictionary$\\n$n$ denotes length of $s$\\n- Time complexity: $O(max(D, n^2))$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nBuild trie: $O(D)$\\nDP: $O(n^2)$\\nTotal: $O(max(D, n^2))$\\n\\n- Space complexity: $O(D+n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nDP: $O(n)$\\nTrie: $O(D)$\\nTotal: $O(D+n)$\\n\\n# Code\\n```\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n\\n        # Build a trie with reversed words in dictionary\\n        trie = {}\\n        for w in dictionary:\\n            w = reversed(w)\\n            cur = trie\\n            for c in w:\\n                if c not in cur:\\n                    cur[c] = {}\\n                cur = cur[c]\\n            cur[\\'match\\'] = True\\n\\n        def getDictWord(i, trie, s):\\n            \\'\\'\\'Retrieve the lookback indices with revserd trie and index.\\'\\'\\'\\n            cur = trie\\n            res = []\\n            for j in range(i+1)[::-1]:\\n                if s[j] in cur:\\n                    cur = cur[s[j]]\\n                    if \\'match\\' in cur:\\n                        res += [j]\\n                else:\\n                    break\\n            return res\\n\\n\\n        n = len(s)\\n        dp = []\\n        for i in range(n):\\n            # - Fetch lookback indices\\n            lookback = getDictWord(i, trie, s)\\n            # - Initial cost\\n            if dp:\\n                v = dp[-1] + 1\\n            else:\\n                v = 1\\n            # - Optimized the cost with lookback indices\\n            if lookback:\\n                for j in lookback:\\n                    if j == 0:\\n                        v = 0\\n                        break\\n                    v = min(v, dp[j-1])\\n            dp += [v]\\n        return dp[-1]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n\\n        # Build a trie with reversed words in dictionary\\n        trie = {}\\n        for w in dictionary:\\n            w = reversed(w)\\n            cur = trie\\n            for c in w:\\n                if c not in cur:\\n                    cur[c] = {}\\n                cur = cur[c]\\n            cur[\\'match\\'] = True\\n\\n        def getDictWord(i, trie, s):\\n            \\'\\'\\'Retrieve the lookback indices with revserd trie and index.\\'\\'\\'\\n            cur = trie\\n            res = []\\n            for j in range(i+1)[::-1]:\\n                if s[j] in cur:\\n                    cur = cur[s[j]]\\n                    if \\'match\\' in cur:\\n                        res += [j]\\n                else:\\n                    break\\n            return res\\n\\n\\n        n = len(s)\\n        dp = []\\n        for i in range(n):\\n            # - Fetch lookback indices\\n            lookback = getDictWord(i, trie, s)\\n            # - Initial cost\\n            if dp:\\n                v = dp[-1] + 1\\n            else:\\n                v = 1\\n            # - Optimized the cost with lookback indices\\n            if lookback:\\n                for j in lookback:\\n                    if j == 0:\\n                        v = 0\\n                        break\\n                    v = min(v, dp[j-1])\\n            dp += [v]\\n        return dp[-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990772,
                "title": "98-41-beats-python3-dynamic-programming-with-trie-easy-and-effective-trie-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Trie:\\n    def __init__(self):\\n        self.children = {}\\n        self.isEnd = False\\n    def insert(self,word):\\n        head = self\\n        for letter in word:\\n            if letter in head.children:\\n                head = head.children[letter]\\n            else:\\n                head.children[letter] = Trie()\\n                head = head.children[letter]\\n        head.isEnd = True\\n    def printTrie(self):\\n        stk = self.children\\n        for child in stk:\\n            print(child, stk[child].isEnd)\\n            stk[child].printTrie()\\n\\n\\n\\n\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        trie_head = Trie()\\n        #Create Trie\\n        for word in dictionary:\\n            trie_head.insert(word)\\n        # trie_head.printTrie()\\n        dp = [None for _ in range(len(s)+1)]\\n        dp[-1] = 0\\n\\n        for start in range(len(s)-1,-1, -1):\\n            dp[start] = dp[start+1]+1\\n            node = trie_head\\n            for end in range(start,len(s)):\\n                if s[end] not in node.children:\\n                    break\\n                node  = node.children[s[end]]\\n                if node.isEnd:\\n                    dp[start] = min(dp[start],dp[end+1])\\n        return dp[0]\\n\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "String",
                    "Dynamic Programming",
                    "Trie"
                ],
                "code": "```\\nclass Trie:\\n    def __init__(self):\\n        self.children = {}\\n        self.isEnd = False\\n    def insert(self,word):\\n        head = self\\n        for letter in word:\\n            if letter in head.children:\\n                head = head.children[letter]\\n            else:\\n                head.children[letter] = Trie()\\n                head = head.children[letter]\\n        head.isEnd = True\\n    def printTrie(self):\\n        stk = self.children\\n        for child in stk:\\n            print(child, stk[child].isEnd)\\n            stk[child].printTrie()\\n\\n\\n\\n\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        trie_head = Trie()\\n        #Create Trie\\n        for word in dictionary:\\n            trie_head.insert(word)\\n        # trie_head.printTrie()\\n        dp = [None for _ in range(len(s)+1)]\\n        dp[-1] = 0\\n\\n        for start in range(len(s)-1,-1, -1):\\n            dp[start] = dp[start+1]+1\\n            node = trie_head\\n            for end in range(start,len(s)):\\n                if s[end] not in node.children:\\n                    break\\n                node  = node.children[s[end]]\\n                if node.isEnd:\\n                    dp[start] = min(dp[start],dp[end+1])\\n        return dp[0]\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990697,
                "title": "kotlin-trie-dfs-cache",
                "content": "![image.png](https://assets.leetcode.com/users/images/028b6380-780d-4417-90a0-44eca64edfa7_1693638832.7552216.png)\\n\\n\\n#### Join me on Telegram\\n\\nhttps://t.me/leetcode_daily_unstoppable/327\\n\\n#### Problem TLDR\\n\\nMin count of leftovers after split a string by the dictionary\\n\\n#### Intuition\\n\\nWe can search all possible splits at every position when we find a word. To quickly find a word, lets use a `Trie`. The result will only depend on the suffix of the string, so can be cached.\\n\\n#### Approach\\n\\nDo DFS, each time compare a `skipped` result with any `take_word` result, if found a word. We must continue search, because some words can be prefixes to others: `leet`, `leetcode` -> `leetcodes`, taking `leet` is not optimal.\\n\\n#### Complexity\\n\\n- Time complexity:\\n$$O(n^2)$$, DFS depth is `n` and another `n` for the inner iteration\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n#### Code\\n\\n```kotlin\\n\\n    class Trie(var w: Boolean = false) : HashMap<Char, Trie>()\\n    fun minExtraChar(s: String, dictionary: Array<String>): Int {\\n      val trie = Trie()\\n      for (w in dictionary) {\\n        var t = trie\\n        for (c in w) t = t.getOrPut(c) { Trie() }\\n        t.w = true\\n      }\\n      val cache = mutableMapOf<Int, Int>()\\n      fun dfs(pos: Int): Int =  if (pos >= s.length) 0 else \\n        cache.getOrPut(pos) {\\n          var min = 1 + dfs(pos + 1)\\n          var t = trie\\n          for (i in pos..<s.length) {\\n            t = t[s[i]] ?: break\\n            if (t.w) min = minOf(min, dfs(i + 1))\\n          }\\n          min\\n        } \\n      return dfs(0)\\n    }\\n\\n```",
                "solutionTags": [
                    "Kotlin",
                    "String",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Trie",
                    "Memoization"
                ],
                "code": "```kotlin\\n\\n    class Trie(var w: Boolean = false) : HashMap<Char, Trie>()\\n    fun minExtraChar(s: String, dictionary: Array<String>): Int {\\n      val trie = Trie()\\n      for (w in dictionary) {\\n        var t = trie\\n        for (c in w) t = t.getOrPut(c) { Trie() }\\n        t.w = true\\n      }\\n      val cache = mutableMapOf<Int, Int>()\\n      fun dfs(pos: Int): Int =  if (pos >= s.length) 0 else \\n        cache.getOrPut(pos) {\\n          var min = 1 + dfs(pos + 1)\\n          var t = trie\\n          for (i in pos..<s.length) {\\n            t = t[s[i]] ?: break\\n            if (t.w) min = minOf(min, dfs(i + 1))\\n          }\\n          min\\n        } \\n      return dfs(0)\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990678,
                "title": "only-if-you-can-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dict) {\\n        vector<int> dp(s.size()+1,INT_MAX);\\n        unordered_set<string> st(dict.begin(),dict.end());\\n        dp[0]=0;\\n        for(int i=1;i<=s.size();i++){\\n            for(int j=1;j<=i;j++){\\n                if(st.count(s.substr(j-1,i-j+1)))       dp[i]=min(dp[i],dp[j-1]);   \\n            }\\n            dp[i]=min(dp[i],dp[i-1]+1);\\n        }\\n        for(auto x: dp)         cout<<x<<\"  \";\\n\\n        return dp[s.size()];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dict) {\\n        vector<int> dp(s.size()+1,INT_MAX);\\n        unordered_set<string> st(dict.begin(),dict.end());\\n        dp[0]=0;\\n        for(int i=1;i<=s.size();i++){\\n            for(int j=1;j<=i;j++){\\n                if(st.count(s.substr(j-1,i-j+1)))       dp[i]=min(dp[i],dp[j-1]);   \\n            }\\n            dp[i]=min(dp[i],dp[i-1]+1);\\n        }\\n        for(auto x: dp)         cout<<x<<\"  \";\\n\\n        return dp[s.size()];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3990586,
                "title": "javascript-8-lines-dp-using-dfs-hash-time-o-ns-100-space-o-n",
                "content": "# Approach\\n1. Create an array `max` to act as a hash table.\\n2. Create recursive function `f` which takes parameter index `i`. In it:\\n    1. If `s[i]` does not exist, return `0`.\\n    2. If a hashed value exists at `max[i]`, return `max[i]`.\\n    3. Iterate through dictionary. For each entry `word`:\\n        1. If `word` equals to the substring of `s` from index `i` to `i + word.length`, set `max[i] = max( max[i], word.length + f( i + word.length )`.\\n    4. Return `max[i] = max( max[i], f( i + 1 ) )`.\\n1. Return `s.length - f(0)`. \\n\\n# Complexity\\n- Time complexity: $$O(ns)$$\\n- Space complexity: $$O(n)$$\\n\\nWhere $n$ is length of `dictionary` & $s$ is the aggregate character length of all strings i.\\n\\n# Code\\n```\\nconst minExtraChar = ( s, dictionary ) => {\\n    let max = [], f = i => {\\n        if ( !s[i] ) return 0\\n        if ( max[i] ) return max[i]\\n        for ( let word of dictionary )\\n            if ( s.substring( i, i+word.length ) == word )\\n                max[i] = Math.max( ~~max[i], word.length+f( i+word.length ) )\\n        return max[i] = Math.max( ~~max[i], f( i+1 ) )\\n    }\\n    return s.length - f(0)\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Hash Table",
                    "String",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nconst minExtraChar = ( s, dictionary ) => {\\n    let max = [], f = i => {\\n        if ( !s[i] ) return 0\\n        if ( max[i] ) return max[i]\\n        for ( let word of dictionary )\\n            if ( s.substring( i, i+word.length ) == word )\\n                max[i] = Math.max( ~~max[i], word.length+f( i+word.length ) )\\n        return max[i] = Math.max( ~~max[i], f( i+1 ) )\\n    }\\n    return s.length - f(0)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3990566,
                "title": "javascript-solution-dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {string[]} dictionary\\n * @return {number}\\n */\\nfunction minExtraChar(s, dictionary) {\\n    // Create a set to store the words from the dictionary for efficient lookups.\\n    const dict = new Set(dictionary);\\n\\n    // Get the length of the input string.\\n    const n = s.length;\\n    \\n    // Initialize an array to store the minimum extra characters needed for substrings of s.\\n    const dp = new Array(n + 1).fill(0);\\n\\n    for (let i = 1; i <= n; i++) {\\n        // Start by assuming that adding one character is needed.\\n        dp[i] = dp[i - 1] + 1;\\n\\n        for (let j = i - 1; j >= 0; j--) {\\n            // Extract the substring from j to i.\\n            const substring = s.substring(j, i);\\n            \\n            // Check if the substring exists in the dictionary.\\n            if (dict.has(substring)) {\\n                // If it exists, update dp[i] with the minimum value between the current dp[i]\\n                // and dp[j], which means the minimum extra characters needed.\\n                dp[i] = Math.min(dp[i], dp[j]);\\n            }\\n        }\\n    }\\n\\n    // Return the minimum extra characters needed for the entire string s.\\n    return dp[n];\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string[]} dictionary\\n * @return {number}\\n */\\nfunction minExtraChar(s, dictionary) {\\n    // Create a set to store the words from the dictionary for efficient lookups.\\n    const dict = new Set(dictionary);\\n\\n    // Get the length of the input string.\\n    const n = s.length;\\n    \\n    // Initialize an array to store the minimum extra characters needed for substrings of s.\\n    const dp = new Array(n + 1).fill(0);\\n\\n    for (let i = 1; i <= n; i++) {\\n        // Start by assuming that adding one character is needed.\\n        dp[i] = dp[i - 1] + 1;\\n\\n        for (let j = i - 1; j >= 0; j--) {\\n            // Extract the substring from j to i.\\n            const substring = s.substring(j, i);\\n            \\n            // Check if the substring exists in the dictionary.\\n            if (dict.has(substring)) {\\n                // If it exists, update dp[i] with the minimum value between the current dp[i]\\n                // and dp[j], which means the minimum extra characters needed.\\n                dp[i] = Math.min(dp[i], dp[j]);\\n            }\\n        }\\n    }\\n\\n    // Return the minimum extra characters needed for the entire string s.\\n    return dp[n];\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3990407,
                "title": "100-beats-128-ms-dp-python3",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        n = len(s)\\n        \\n        # comments are generated by chatGPT\\n        # Create a defaultdict to group words by their starting letter\\n        word_dict = defaultdict(list)\\n        for word in dictionary:\\n            word_dict[word[0]].append(word)\\n            \\n        # Initialize DP array to hold the minimum extra characters needed from i to end\\n        dp = [0] * (n+1)\\n        \\n        # Iterate through the string from end to start\\n        for i in range(n-1, -1, -1):\\n            # In the worst case, we can choose not to use the current character,\\n            # hence one extra character will be there\\n            dp[i] = dp[i+1] + 1  \\n            \\n            # Check if there are any words that start with this character\\n            if s[i] in word_dict:\\n                # If yes, try each word and update the DP array\\n                for word in word_dict[s[i]]:\\n                    if s[i:i+len(word)] == word:\\n                        dp[i] = min(dp[i], dp[i+len(word)])\\n                        \\n        return dp[0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        n = len(s)\\n        \\n        # comments are generated by chatGPT\\n        # Create a defaultdict to group words by their starting letter\\n        word_dict = defaultdict(list)\\n        for word in dictionary:\\n            word_dict[word[0]].append(word)\\n            \\n        # Initialize DP array to hold the minimum extra characters needed from i to end\\n        dp = [0] * (n+1)\\n        \\n        # Iterate through the string from end to start\\n        for i in range(n-1, -1, -1):\\n            # In the worst case, we can choose not to use the current character,\\n            # hence one extra character will be there\\n            dp[i] = dp[i+1] + 1  \\n            \\n            # Check if there are any words that start with this character\\n            if s[i] in word_dict:\\n                # If yes, try each word and update the DP array\\n                for word in word_dict[s[i]]:\\n                    if s[i:i+len(word)] == word:\\n                        dp[i] = min(dp[i], dp[i+len(word)])\\n                        \\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990381,
                "title": "beat-100-o-nw-mw-most-efficient-solution-simple-dp-with-trie",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can use some kind of data struct to hold the dictionary and apply a simple DP. While we could use a hash map to hold the dictionary, it\\'s less efficient than a Trie because the way we search it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe use a trie to hold the dictionary and search each index of the input string s to see where it can properly ends. The recursive relation is:\\n```\\ndp[i] = min {\\n  dp[j] if s[i: j) is a word \\n}\\n```\\n\\n**Note**: This problem can be viewed as an upgraded version of:\\nhttps://leetcode.com/problems/word-break/solutions/3860518/0ms-o-nw-mw-most-efficient-solution-simple-dp-with-trie/\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(Nw + Mw)$$\\nwhere $N$ is the size of s, $M$ is the size of the dictionary and $w$ is the average size of the words in the dictionary.\\nThe $Mw$ terms comes from the process of building the dictionary.\\nThe $Nw$ terms comes from the dp process.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(Mw)$$\\n\\n# Code\\n```\\nclass Trie {\\n public:\\n  void Add(string_view word) {\\n    Node* node = &head_;\\n    for (char c : word) {\\n      node = NextOrInsert(node, c);\\n    }\\n    node->has_end = true;\\n  }\\n\\n  struct Node {\\n    bool has_end = false;\\n    Node* children[26] = {};\\n  };\\n\\n  class Walker {\\n   public:\\n    Walker(const Node* node) : node_(node) {}\\n\\n    bool Advance(char c) {\\n      node_ = node_->children[c - \\'a\\'];\\n      return node_ != nullptr;\\n    }\\n\\n    bool IsWord() const {\\n      return node_->has_end;\\n    }\\n\\n   private:\\n    const Node* node_;\\n  };\\n\\n  Walker StartWalker() const {\\n    return Walker(&head_);\\n  }\\n\\n private:\\n  Node* NextOrInsert(Node* node, char c) {\\n    Node*& next = node->children[c - \\'a\\'];\\n    if (next == nullptr) {\\n      next = &nodes_.emplace_back();\\n    }\\n    return next;\\n  }\\n\\n  Node head_;\\n  std::deque<Node> nodes_;\\n};\\n\\nclass Solution {\\npublic:\\n  int minExtraChar(string s, vector<string>& dictionary) {\\n    Trie trie;\\n    for (const string& word : dictionary) {\\n      trie.Add(word);\\n    }\\n\\n    const int N = s.size();\\n    vector<int> dp(N + 1);  // extra chars needed for s[i:]\\n    for (int i = N - 1; i >= 0; --i) {\\n      Trie::Walker walker = trie.StartWalker();\\n      dp[i] = 1 + dp[i + 1];\\n      for (int j = i; j < N; ++j) {\\n        if (!walker.Advance(s[j])) {\\n          break;\\n        }\\n        if (walker.IsWord()) {\\n          dp[i] = min(dp[i], dp[j + 1]);\\n        }\\n      }\\n    }\\n    return dp[0];\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Trie"
                ],
                "code": "```\\ndp[i] = min {\\n  dp[j] if s[i: j) is a word \\n}\\n```\n```\\nclass Trie {\\n public:\\n  void Add(string_view word) {\\n    Node* node = &head_;\\n    for (char c : word) {\\n      node = NextOrInsert(node, c);\\n    }\\n    node->has_end = true;\\n  }\\n\\n  struct Node {\\n    bool has_end = false;\\n    Node* children[26] = {};\\n  };\\n\\n  class Walker {\\n   public:\\n    Walker(const Node* node) : node_(node) {}\\n\\n    bool Advance(char c) {\\n      node_ = node_->children[c - \\'a\\'];\\n      return node_ != nullptr;\\n    }\\n\\n    bool IsWord() const {\\n      return node_->has_end;\\n    }\\n\\n   private:\\n    const Node* node_;\\n  };\\n\\n  Walker StartWalker() const {\\n    return Walker(&head_);\\n  }\\n\\n private:\\n  Node* NextOrInsert(Node* node, char c) {\\n    Node*& next = node->children[c - \\'a\\'];\\n    if (next == nullptr) {\\n      next = &nodes_.emplace_back();\\n    }\\n    return next;\\n  }\\n\\n  Node head_;\\n  std::deque<Node> nodes_;\\n};\\n\\nclass Solution {\\npublic:\\n  int minExtraChar(string s, vector<string>& dictionary) {\\n    Trie trie;\\n    for (const string& word : dictionary) {\\n      trie.Add(word);\\n    }\\n\\n    const int N = s.size();\\n    vector<int> dp(N + 1);  // extra chars needed for s[i:]\\n    for (int i = N - 1; i >= 0; --i) {\\n      Trie::Walker walker = trie.StartWalker();\\n      dp[i] = 1 + dp[i + 1];\\n      for (int j = i; j < N; ++j) {\\n        if (!walker.Advance(s[j])) {\\n          break;\\n        }\\n        if (walker.IsWord()) {\\n          dp[i] = min(dp[i], dp[j + 1]);\\n        }\\n      }\\n    }\\n    return dp[0];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990341,
                "title": "daily-leetcoding-challenge-september-day-2",
                "content": "This problem is the Daily LeetCoding Challenge for September, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/extra-characters-in-a-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top Down Dynamic Programming with Substring Method\n\n  \n**Approach 2:** Bottom Up Dynamic Programming with Substring Method\n\n  \n**Approach 3:** Top Down Dynamic Programming with Trie\n\n  \n**Approach 4:** Bottom Up Dynamic Programming with Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/extra-characters-in-a-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3847431,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rec(int ind,string &s,set<string>&st,vector<int>&dp)\\n    {\\n        if (ind==s.size()) return 0;\\n        if (dp[ind]!=-1) return dp[ind];\\n        int ans=s.size()-ind;\\n        for (int i=ind;i<s.size();i++)\\n        {\\n           string temp=s.substr(ind,i-ind+1);\\n           if (st.find(temp)!=st.end())\\n           {\\n              ans=min(ans,rec(i+1,s,st,dp));\\n           }\\n        }\\n        ans=min(ans,1+rec(ind+1,s,st,dp));\\n        return dp[ind]=ans;\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) \\n    {\\n        set<string>st;\\n        int n=s.size();\\n        vector<int>dp(n,-1);\\n        for (auto it:dictionary)\\n        {\\n            st.insert(it);\\n        }\\n        return rec(0,s,st,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rec(int ind,string &s,set<string>&st,vector<int>&dp)\\n    {\\n        if (ind==s.size()) return 0;\\n        if (dp[ind]!=-1) return dp[ind];\\n        int ans=s.size()-ind;\\n        for (int i=ind;i<s.size();i++)\\n        {\\n           string temp=s.substr(ind,i-ind+1);\\n           if (st.find(temp)!=st.end())\\n           {\\n              ans=min(ans,rec(i+1,s,st,dp));\\n           }\\n        }\\n        ans=min(ans,1+rec(ind+1,s,st,dp));\\n        return dp[ind]=ans;\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) \\n    {\\n        set<string>st;\\n        int n=s.size();\\n        vector<int>dp(n,-1);\\n        for (auto it:dictionary)\\n        {\\n            st.insert(it);\\n        }\\n        return rec(0,s,st,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729135,
                "title": "c-solution-recursion-memoization",
                "content": "idea : find largest possible number of words in \\'s\\' which are present in dictionary and at last subtract it from lenght of \\'s\\'\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_set<string> dict;\\n    int ans=0;\\n    int dp[60];\\n    \\n    int help(string &s, int ind){  //returns num of char crossed\\n        if(ind>= s.size()) return 0;\\n        \\n        if(dp[ind]!= -1) return dp[ind];\\n        \\n        for(int ln= 1; ind+ln <= s.size(); ln++){\\n            if(dict.count(s.substr(ind, ln))) dp[ind]= max(dp[ind], ln+help(s, ind+ln));\\n            else dp[ind]= max(dp[ind], help(s, ind+ln));\\n        }\\n        \\n        ans= max(ans, dp[ind]);\\n        return dp[ind];\\n    }\\n    \\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        for(auto &x:dictionary) dict.insert(x);\\n        memset(dp, -1, sizeof(dp));\\n        for(int i=0; i<s.size(); i++) help(s, i);\\n        \\n        // for(int x:dp)cout<<x<<\" \";\\n        return (s.size() -ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_set<string> dict;\\n    int ans=0;\\n    int dp[60];\\n    \\n    int help(string &s, int ind){  //returns num of char crossed\\n        if(ind>= s.size()) return 0;\\n        \\n        if(dp[ind]!= -1) return dp[ind];\\n        \\n        for(int ln= 1; ind+ln <= s.size(); ln++){\\n            if(dict.count(s.substr(ind, ln))) dp[ind]= max(dp[ind], ln+help(s, ind+ln));\\n            else dp[ind]= max(dp[ind], help(s, ind+ln));\\n        }\\n        \\n        ans= max(ans, dp[ind]);\\n        return dp[ind];\\n    }\\n    \\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        for(auto &x:dictionary) dict.insert(x);\\n        memset(dp, -1, sizeof(dp));\\n        for(int i=0; i<s.size(); i++) help(s, i);\\n        \\n        // for(int x:dp)cout<<x<<\" \";\\n        return (s.size() -ans);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3689122,
                "title": "c-dynamic-programming-solution-with-trie-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCheck two cases:\\n1. Skipping current character and count it as missing.\\n2. Iterate over the all substrings starting with character at i and look for dictionary words.\\n\\nOptimizing:\\n3. We can use prefix searching in trie to check whether to continue the loop or not.\\nThis optimization improves runtime from 44%to 94.5%.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass TrieNode {\\n    public:\\n        vector<TrieNode*> children;\\n        bool isEndOfWord = false;\\n\\n        TrieNode() {\\n            children = vector<TrieNode*>(26, NULL);\\n        }\\n};\\n\\nclass Trie {\\npublic:\\n    TrieNode* root;\\n\\n    Trie() {\\n        root = new TrieNode();\\n    }\\n    \\n    void insert(string word) {\\n        TrieNode* temp = root;\\n\\n        for (int i = 0; i < word.length(); i++) {\\n            if (temp->children[word[i] - \\'a\\'] == NULL) {\\n                temp->children[word[i] - \\'a\\'] = new TrieNode();\\n            }\\n\\n            temp = temp->children[word[i] - \\'a\\'];\\n        }\\n\\n        temp->isEndOfWord = true;\\n    }\\n    \\n    bool hasWord(string word) {\\n        TrieNode* temp = root;\\n\\n        for (int i = 0; i < word.length(); i++) {\\n            if (temp->children[word[i] - \\'a\\'] == NULL) {\\n                return false;\\n            }\\n\\n            temp = temp->children[word[i] - \\'a\\'];\\n        }\\n\\n        return temp->isEndOfWord;\\n    }\\n    \\n    bool startsWith(string prefix) {\\n        TrieNode* temp = root;\\n\\n        for (int i = 0; i < prefix.length(); i++) {\\n            if (temp->children[prefix[i] - \\'a\\'] == NULL) {\\n                return false;\\n            }\\n\\n            temp = temp->children[prefix[i] - \\'a\\'];\\n        }\\n\\n        return true;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int solveRec(string &s, Trie &trie, int i, vector<int> &dp) {\\n        if (i >= s.length()) return 0;\\n\\n        if (dp[i] != -1) return dp[i];\\n\\n        int result = 1 + solveRec(s, trie, i + 1, dp); // skip the current letter and count it.\\n\\n        // Include the current letter and try to find substring starting with i.\\n        for (int k = i + 1; k <= s.length(); k++) {\\n            // Only continue with the loop if the there exists a word with starts with \\n            // character at i.\\n            if (!trie.startsWith(s.substr(i, k - i))) break;\\n\\n            if (trie.hasWord(s.substr(i, k - i))) {\\n                result = min(result, solveRec(s, trie, k, dp));\\n            }\\n        }\\n\\n        return dp[i] = result;\\n    }\\n\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        // unordered_set<string> uset;\\n        Trie trie;\\n        vector<int> dp(s.length() + 1, -1);\\n\\n        for (string word : dictionary) trie.insert(word);\\n\\n        return solveRec(s, trie, 0, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Trie",
                    "Memoization"
                ],
                "code": "```\\nclass TrieNode {\\n    public:\\n        vector<TrieNode*> children;\\n        bool isEndOfWord = false;\\n\\n        TrieNode() {\\n            children = vector<TrieNode*>(26, NULL);\\n        }\\n};\\n\\nclass Trie {\\npublic:\\n    TrieNode* root;\\n\\n    Trie() {\\n        root = new TrieNode();\\n    }\\n    \\n    void insert(string word) {\\n        TrieNode* temp = root;\\n\\n        for (int i = 0; i < word.length(); i++) {\\n            if (temp->children[word[i] - \\'a\\'] == NULL) {\\n                temp->children[word[i] - \\'a\\'] = new TrieNode();\\n            }\\n\\n            temp = temp->children[word[i] - \\'a\\'];\\n        }\\n\\n        temp->isEndOfWord = true;\\n    }\\n    \\n    bool hasWord(string word) {\\n        TrieNode* temp = root;\\n\\n        for (int i = 0; i < word.length(); i++) {\\n            if (temp->children[word[i] - \\'a\\'] == NULL) {\\n                return false;\\n            }\\n\\n            temp = temp->children[word[i] - \\'a\\'];\\n        }\\n\\n        return temp->isEndOfWord;\\n    }\\n    \\n    bool startsWith(string prefix) {\\n        TrieNode* temp = root;\\n\\n        for (int i = 0; i < prefix.length(); i++) {\\n            if (temp->children[prefix[i] - \\'a\\'] == NULL) {\\n                return false;\\n            }\\n\\n            temp = temp->children[prefix[i] - \\'a\\'];\\n        }\\n\\n        return true;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int solveRec(string &s, Trie &trie, int i, vector<int> &dp) {\\n        if (i >= s.length()) return 0;\\n\\n        if (dp[i] != -1) return dp[i];\\n\\n        int result = 1 + solveRec(s, trie, i + 1, dp); // skip the current letter and count it.\\n\\n        // Include the current letter and try to find substring starting with i.\\n        for (int k = i + 1; k <= s.length(); k++) {\\n            // Only continue with the loop if the there exists a word with starts with \\n            // character at i.\\n            if (!trie.startsWith(s.substr(i, k - i))) break;\\n\\n            if (trie.hasWord(s.substr(i, k - i))) {\\n                result = min(result, solveRec(s, trie, k, dp));\\n            }\\n        }\\n\\n        return dp[i] = result;\\n    }\\n\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        // unordered_set<string> uset;\\n        Trie trie;\\n        vector<int> dp(s.length() + 1, -1);\\n\\n        for (string word : dictionary) trie.insert(word);\\n\\n        return solveRec(s, trie, 0, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3593212,
                "title": "dp-memoization-96-faster-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int help(int idx, string &s,vector<string>& dict,vector<int> &dp){\\n        if(idx==s.size()) return 0;\\n        if(dp[idx]!=-1) return dp[idx];\\n        int ans=1+help(idx+1,s,dict,dp);\\n\\n        for(auto x:dict){\\n            int f=1;\\n            for(int i=0;i<x.size();i++){\\n                if(idx+i>=s.size()){\\n                    f=0;\\n                    break;\\n                }\\n                if(s[i+idx]!=x[i]){\\n                    f=0;\\n                    break;\\n                }\\n            }\\n            if(f) ans=min(ans,help(idx+x.size(),s,dict,dp));\\n        }\\n        return dp[idx]=ans;\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        vector<int> dp(s.size(),-1);\\n        return help(0,s,dictionary,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int help(int idx, string &s,vector<string>& dict,vector<int> &dp){\\n        if(idx==s.size()) return 0;\\n        if(dp[idx]!=-1) return dp[idx];\\n        int ans=1+help(idx+1,s,dict,dp);\\n\\n        for(auto x:dict){\\n            int f=1;\\n            for(int i=0;i<x.size();i++){\\n                if(idx+i>=s.size()){\\n                    f=0;\\n                    break;\\n                }\\n                if(s[i+idx]!=x[i]){\\n                    f=0;\\n                    break;\\n                }\\n            }\\n            if(f) ans=min(ans,help(idx+x.size(),s,dict,dp));\\n        }\\n        return dp[idx]=ans;\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        vector<int> dp(s.size(),-1);\\n        return help(0,s,dictionary,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581409,
                "title": "kotlin-recursive-dynamic-programming",
                "content": "# Code\\n```\\nclass Solution {\\n    fun minExtraChar(s: String, dictionary: Array<String>): Int {\\n        val memo = HashMap<String, Int>() \\n\\n        fun dfs(str: String): Int {\\n            if (str.length == 0) return 0\\n            if (memo.containsKey(str)) return memo.getOrDefault(str, 0)\\n            val n = str.length\\n            var result = n\\n\\n            for (word in dictionary) {\\n                val m = word.length\\n                if (n < m) continue\\n\\n                val left = str.substring(0, m)\\n                if (!left.equals(word)) continue\\n\\n                val right = str.substring(m)\\n                result = Math.min(dfs(right), result)\\n            }\\n\\n            result = Math.min(dfs(str.substring(1)) + 1, result)\\n            memo.put(str, result)\\n            return result\\n        }\\n\\n        return dfs(s)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun minExtraChar(s: String, dictionary: Array<String>): Int {\\n        val memo = HashMap<String, Int>() \\n\\n        fun dfs(str: String): Int {\\n            if (str.length == 0) return 0\\n            if (memo.containsKey(str)) return memo.getOrDefault(str, 0)\\n            val n = str.length\\n            var result = n\\n\\n            for (word in dictionary) {\\n                val m = word.length\\n                if (n < m) continue\\n\\n                val left = str.substring(0, m)\\n                if (!left.equals(word)) continue\\n\\n                val right = str.substring(m)\\n                result = Math.min(dfs(right), result)\\n            }\\n\\n            result = Math.min(dfs(str.substring(1)) + 1, result)\\n            memo.put(str, result)\\n            return result\\n        }\\n\\n        return dfs(s)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573665,
                "title": "python3-dfs-and-caching",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        \\n        @cache\\n\\n        def dfs(s):\\n            if not s:\\n                return 0\\n            ans=inf\\n            for i in range(len(s)):\\n                sub=s[:i+1]\\n                if sub in seen:\\n                    ans=min(ans,dfs(s[i+1:]))\\n                else:\\n                    ans=min(ans,len(sub)+dfs(s[i+1:]))\\n            return ans\\n        \\n        seen=set(dictionary)\\n        return dfs(s)\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        \\n        @cache\\n\\n        def dfs(s):\\n            if not s:\\n                return 0\\n            ans=inf\\n            for i in range(len(s)):\\n                sub=s[:i+1]\\n                if sub in seen:\\n                    ans=min(ans,dfs(s[i+1:]))\\n                else:\\n                    ans=min(ans,len(sub)+dfs(s[i+1:]))\\n            return ans\\n        \\n        seen=set(dictionary)\\n        return dfs(s)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573304,
                "title": "python-quirky-dp-variation",
                "content": "If you\\'re comfortable with dynamic programming, this problem is an interesting challenge.  It took some thought to determine how to fit this problem into an iterative dp framework.\\n\\n# Approach\\nTo start, create the dp array.  This solution are creates an empty string, which will be added to as we traverse the input string and test if characters can be removed.\\n\\nThe main loop iterates through the string.  Append that character to the test string, and add 1 to the previous dp value, as this new character will be remaining.  For each character in the string, this solution iterates through each dictionary array value, and tests if the test string ends with that dictionary value.  If it does, backtrack in the dp array by the length of that dictionary word, and compare to the current dp index, taking the minimum of all options, which will be the optimal choice of all dictionary options to remove.\\n\\nOnce the full string is traversed, the last value in dp will be the minimum remaining characters after optimal usage of the dictionary word removal.\\n\\n# Code\\n```\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        n = len(s)\\n        dp = [0] * (n+1)\\n        teststr = \"\"\\n        for i, c in enumerate(s):\\n            teststr += c\\n            newdp = dp[i] + 1\\n            for d in dictionary:\\n                backtrack = len(d)\\n                if teststr.endswith(d):\\n                    newdp = min(newdp, dp[i-backtrack+1])\\n            dp[i+1] = newdp\\n        \\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        n = len(s)\\n        dp = [0] * (n+1)\\n        teststr = \"\"\\n        for i, c in enumerate(s):\\n            teststr += c\\n            newdp = dp[i] + 1\\n            for d in dictionary:\\n                backtrack = len(d)\\n                if teststr.endswith(d):\\n                    newdp = min(newdp, dp[i-backtrack+1])\\n            dp[i+1] = newdp\\n        \\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572220,
                "title": "sliding-window-solution-c-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<string,int>d;\\n        for(const string& word : dictionary){\\n                d[word]=1;\\n        }\\n        int n=s.length();\\n        vector<int>dp(n+1,0);\\n        for(int i=1;i<=n;i++){\\n            dp[i]=dp[i-1]+1;\\n            for(int j=i;j>=1;j--){\\n                string sub=s.substr(j-1,i-j+1);//(postion,size\\n                if(d[sub]>0){\\n                    dp[i]=min(dp[i],dp[j-1]);\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<string,int>d;\\n        for(const string& word : dictionary){\\n                d[word]=1;\\n        }\\n        int n=s.length();\\n        vector<int>dp(n+1,0);\\n        for(int i=1;i<=n;i++){\\n            dp[i]=dp[i-1]+1;\\n            for(int j=i;j>=1;j--){\\n                string sub=s.substr(j-1,i-j+1);//(postion,size\\n                if(d[sub]>0){\\n                    dp[i]=min(dp[i],dp[j-1]);\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571612,
                "title": "c-simple-easy-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int f(int i,string &s,set<string> &st,vector<int> &dp)\\n    {\\n       int n=s.size();\\n        if(i>=n)\\n            return 0; \\n        if(dp[i]!=-1)\\n            return dp[i];\\n            string s1=\"\";\\n            int ans=INT_MIN;\\n            for(int k=i;k<n;k++)\\n            {\\n                s1+=s[k];\\n                if(st.find(s1)!=st.end())\\n                {\\n                    int y=s1.size();\\n                    ans=max(ans,y+f(k+1,s,st,dp));  \\n                } \\n                ans=max(ans,f(k+1,s,st,dp));\\n            }\\n        return dp[i]=ans;\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        set<string> st;\\n        int n=s.size();\\n        for(string s:dictionary)\\n           st.insert(s);\\n        vector<int> dp(n,-1);\\n        return n-f(0,s,st,dp);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int i,string &s,set<string> &st,vector<int> &dp)\\n    {\\n       int n=s.size();\\n        if(i>=n)\\n            return 0; \\n        if(dp[i]!=-1)\\n            return dp[i];\\n            string s1=\"\";\\n            int ans=INT_MIN;\\n            for(int k=i;k<n;k++)\\n            {\\n                s1+=s[k];\\n                if(st.find(s1)!=st.end())\\n                {\\n                    int y=s1.size();\\n                    ans=max(ans,y+f(k+1,s,st,dp));  \\n                } \\n                ans=max(ans,f(k+1,s,st,dp));\\n            }\\n        return dp[i]=ans;\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        set<string> st;\\n        int n=s.size();\\n        for(string s:dictionary)\\n           st.insert(s);\\n        vector<int> dp(n,-1);\\n        return n-f(0,s,st,dp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569731,
                "title": "easy-to-understand-fully-explain-with-example",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition was pretty simple to observe generally this type of question is of DP but You may think of greedy approach \\n\\n----------greedy approach fails here ---------\\nleetsscode [leet , eetsscode , code]  \\ngreedy ans = 2\\nexpexted ans = 1\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwhat we can do is think of example \\n\\nleetscode\\n[\"leet\",\"leets\",\"code\"]\\n\\ni will try to starting thing as \\n\\nind = 0;\\nl\\nle\\nlee\\nleet ---- found call for scode\\n\\n\\nmeans for every index we have to form all the substr and see if present ;\\n\\nremainder---------- remaining call is paused\\nleets ------ found in dic call for code;\\n\\n\\nwhen ever we skip i will **add 1** + call for (**ind+1**)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\ndyo(n) + o(n) == o(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    set<string> st;\\n\\n    int helper(int ind,string s,vector<int> &dp)\\n    {\\n        if(ind >= s.size()) return 0;\\n\\n        if(dp[ind]!=-1)return dp[ind];\\n        int pick = INT_MAX;\\n        for(int i=0;ind+i<s.size();i++)\\n        {\\n            string temp = s.substr(ind,i+1);\\n            if(st.find(temp)!=st.end())\\n            {\\n                // taking min because their might be a case which return minimum before the after big number\\n                pick = min(pick,helper(ind+i+1,s,dp));\\n            }\\n        }\\n\\n        int not_pick = 1 + helper(ind+1,s,dp);\\n       return dp[ind] = min(pick,not_pick);\\n\\n    }\\n\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        int n = dictionary.size();\\n\\n        vector<int> dp(s.size(),-1);\\n\\n        for(auto it:dictionary)st.insert(it);\\n        return helper(0,s,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    set<string> st;\\n\\n    int helper(int ind,string s,vector<int> &dp)\\n    {\\n        if(ind >= s.size()) return 0;\\n\\n        if(dp[ind]!=-1)return dp[ind];\\n        int pick = INT_MAX;\\n        for(int i=0;ind+i<s.size();i++)\\n        {\\n            string temp = s.substr(ind,i+1);\\n            if(st.find(temp)!=st.end())\\n            {\\n                // taking min because their might be a case which return minimum before the after big number\\n                pick = min(pick,helper(ind+i+1,s,dp));\\n            }\\n        }\\n\\n        int not_pick = 1 + helper(ind+1,s,dp);\\n       return dp[ind] = min(pick,not_pick);\\n\\n    }\\n\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        int n = dictionary.size();\\n\\n        vector<int> dp(s.size(),-1);\\n\\n        for(auto it:dictionary)st.insert(it);\\n        return helper(0,s,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569678,
                "title": "memoized-recursion-solution-with-small-optimisation",
                "content": "\\n\\n# Code\\n```\\nfunc solve(s string, start int, dictionary []string, cache map[int]int) int {\\n\\tif val, ok := cache[start]; ok {\\n\\t\\treturn val\\n\\t}\\n\\n\\tif start >= len(s) {\\n\\t\\treturn 0\\n\\t}\\n\\n\\trez := len(s) - start\\n\\tfor _, word := range dictionary {\\n\\t\\tindex := strings.Index(s[start:], word)\\n\\t\\tif index == -1 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tv := index + solve(s, index+start+len(word), dictionary, cache)\\n\\t\\tif v < rez {\\n\\t\\t\\trez = v\\n\\t\\t}\\n\\t}\\n\\n\\tcache[start] = rez\\n\\n\\treturn rez\\n}\\n\\nfunc minExtraChar(s string, dictionary []string) int {\\n\\tj := 0\\n\\tfor i := 0; i < len(dictionary); i++ {\\n\\t\\tif strings.Index(s, dictionary[i]) == -1 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tdictionary[j] = dictionary[i]\\n\\t\\tj++\\n\\t}\\n\\tdictionary = dictionary[:j]\\n\\tcache := make(map[int]int, len(s)+1)\\n\\treturn solve(s, 0, dictionary, cache)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc solve(s string, start int, dictionary []string, cache map[int]int) int {\\n\\tif val, ok := cache[start]; ok {\\n\\t\\treturn val\\n\\t}\\n\\n\\tif start >= len(s) {\\n\\t\\treturn 0\\n\\t}\\n\\n\\trez := len(s) - start\\n\\tfor _, word := range dictionary {\\n\\t\\tindex := strings.Index(s[start:], word)\\n\\t\\tif index == -1 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tv := index + solve(s, index+start+len(word), dictionary, cache)\\n\\t\\tif v < rez {\\n\\t\\t\\trez = v\\n\\t\\t}\\n\\t}\\n\\n\\tcache[start] = rez\\n\\n\\treturn rez\\n}\\n\\nfunc minExtraChar(s string, dictionary []string) int {\\n\\tj := 0\\n\\tfor i := 0; i < len(dictionary); i++ {\\n\\t\\tif strings.Index(s, dictionary[i]) == -1 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tdictionary[j] = dictionary[i]\\n\\t\\tj++\\n\\t}\\n\\tdictionary = dictionary[:j]\\n\\tcache := make(map[int]int, len(s)+1)\\n\\treturn solve(s, 0, dictionary, cache)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3569555,
                "title": "memoization-c",
                "content": "```\\nclass Solution {\\n    int dfs(int i, int n, string &s, unordered_set<string> &d, vector<int> &dp) {\\n        if(i == n) return 0;\\n        if(dp[i] != -1) return dp[i];\\n        \\n        int cnt = dfs(i + 1, n, s, d, dp);\\n        string t;\\n        for(int j=i; j<n; j++) {\\n            t += s[j];\\n            if(d.find(t) != d.end()) cnt = max(cnt, (int)t.size() + dfs(j + 1, n, s, d, dp));\\n        }\\n        return dp[i] = cnt;\\n    }\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        int n = s.size();\\n        vector<int> dp(n, -1);\\n        unordered_set<string> d(dictionary.begin(), dictionary.end());\\n        \\n        return n - dfs(0, n, s, d, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(int i, int n, string &s, unordered_set<string> &d, vector<int> &dp) {\\n        if(i == n) return 0;\\n        if(dp[i] != -1) return dp[i];\\n        \\n        int cnt = dfs(i + 1, n, s, d, dp);\\n        string t;\\n        for(int j=i; j<n; j++) {\\n            t += s[j];\\n            if(d.find(t) != d.end()) cnt = max(cnt, (int)t.size() + dfs(j + 1, n, s, d, dp));\\n        }\\n        return dp[i] = cnt;\\n    }\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        int n = s.size();\\n        vector<int> dp(n, -1);\\n        unordered_set<string> d(dictionary.begin(), dictionary.end());\\n        \\n        return n - dfs(0, n, s, d, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569456,
                "title": "easy-clean-c-code-memoization",
                "content": "# Code\\n## Please Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    int helper(int ind,int n,string s,unordered_set<string>& st,vector<int>& dp){\\n        if(ind == n)\\n            return 0;\\n        if(dp[ind] != -1)\\n            return dp[ind];\\n        int left = n, right = n;\\n        string str=\"\";\\n        for(int i=ind;i<n;i++){\\n            str += s[i];\\n            if(st.find(str) != st.end())\\n                left = min(left,helper(i+1,n,s,st,dp));\\n        }\\n        right = 1 + helper(ind+1,n,s,st,dp);\\n        return dp[ind] = min(left,right);\\n    }\\n    \\n    int minExtraChar(string s, vector<string>& dict) {\\n        int n = s.size();\\n        vector<int> dp(n+1,-1);\\n        unordered_set<string> st(dict.begin(),dict.end());\\n        return helper(0,n,s,st,dp);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int ind,int n,string s,unordered_set<string>& st,vector<int>& dp){\\n        if(ind == n)\\n            return 0;\\n        if(dp[ind] != -1)\\n            return dp[ind];\\n        int left = n, right = n;\\n        string str=\"\";\\n        for(int i=ind;i<n;i++){\\n            str += s[i];\\n            if(st.find(str) != st.end())\\n                left = min(left,helper(i+1,n,s,st,dp));\\n        }\\n        right = 1 + helper(ind+1,n,s,st,dp);\\n        return dp[ind] = min(left,right);\\n    }\\n    \\n    int minExtraChar(string s, vector<string>& dict) {\\n        int n = s.size();\\n        vector<int> dp(n+1,-1);\\n        unordered_set<string> st(dict.begin(),dict.end());\\n        return helper(0,n,s,st,dp);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569115,
                "title": "easy-and-begineer-friendly-dp-solution-with-comments-upvotes-are-appreciated-if-it-helps-you",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n            int n = s.length();\\n        int dp[n + 1];  // dp[i] represents the minimum number of extra characters up to index i\\n\\n        unordered_set<string> dict;\\n        for (auto word : dictionary) {\\n            dict.insert(word);\\n        }\\n\\n        // Initialize dp array\\n        dp[0] = 0;\\n\\n        // Iterate over each index of the string\\n        for (int i = 1; i <= n; i++) {\\n            dp[i] = dp[i - 1] + 1;  // Assume the current character is extra\\n\\n            // Check if any substring ending at the current index is present in the dictionary\\n            for (int j = i - 1; j >= 0; j--) {\\n                if (dict.find(s.substr(j, i - j)) != dict.end()) {\\n                    dp[i] = min(dp[i], dp[j]);\\n                }\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n            int n = s.length();\\n        int dp[n + 1];  // dp[i] represents the minimum number of extra characters up to index i\\n\\n        unordered_set<string> dict;\\n        for (auto word : dictionary) {\\n            dict.insert(word);\\n        }\\n\\n        // Initialize dp array\\n        dp[0] = 0;\\n\\n        // Iterate over each index of the string\\n        for (int i = 1; i <= n; i++) {\\n            dp[i] = dp[i - 1] + 1;  // Assume the current character is extra\\n\\n            // Check if any substring ending at the current index is present in the dictionary\\n            for (int j = i - 1; j >= 0; j--) {\\n                if (dict.find(s.substr(j, i - j)) != dict.end()) {\\n                    dp[i] = min(dp[i], dp[j]);\\n                }\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568921,
                "title": "recursive-solution-memoization-solution-tabulation-method-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    Firstly pushing every element of dictionary to set.\\n    By using set We can reduce search time and control \\n    duplicate cases.Then maintaining a dp like we do in \\n    case of checking substring \\n    for keeping solution of subproblems.\\n\\n# Code\\n```\\n// Simple Recursive Solution\\nclass Solution {\\npublic:\\n\\n    int helper(string s, unordered_set<string> dict, int ind){\\n        if(ind >= s.size()) return 0;\\n        int res = 1 + helper(s,dict,ind+1) ;\\n\\n        for(int i = 1 ; ind+i <= s.size() ; i++){\\n            string str = s.substr(ind,i);\\n            if(dict.count(str)){\\n                res = min(res, helper(s,dict,ind+i));\\n            }\\n        }\\n        return res;\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_set <string> dict(dictionary.begin(), dictionary.end());\\n        return helper(s,dict,0);\\n    }\\n};\\n\\n\\n```\\n```Cpp []\\n//Memoization Solution\\nclass Solution {\\npublic:\\n    int helper(string s, unordered_set<string> dict, int ind, vector<int> &dp){\\n        if(ind >= s.size()) return 0;\\n        if(dp[ind] != -1) return dp[ind];\\n        int res = 1 + helper(s,dict,ind+1, dp) ;\\n\\n        for(int i = 1 ; ind+i <= s.size() ; i++){\\n            string str = s.substr(ind,i);\\n            if(dict.count(str)){\\n                res = min(res, helper(s,dict,ind+i,dp));\\n            }\\n        }\\n        return dp[ind] = res;\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_set <string> dict(dictionary.begin(), dictionary.end());\\n        vector<int> dp(s.size()+1, -1);\\n        return helper(s,dict,0, dp);\\n    }\\n};\\n```\\n\\n\\n``` \\n// Tabulation Method\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        int n = s.length();\\n        unordered_set<string> dict(dictionary.begin(), dictionary.end());\\n        vector<int>dp(n+1,INT_MAX);\\n        dp[0] = 0;\\n        \\n        for(int i = 1 ; i <= n ; i++){\\n            for(int j = i ; j >=1 ; j--){\\n                string temp = s.substr(j-1,i-j+1);\\n                if(dict.count(temp)){\\n                    dp[i] = min(dp[i], dp[j-1]);\\n                }\\n            }\\n            dp[i] = min(dp[i], dp[i-1]+1);\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n// Simple Recursive Solution\\nclass Solution {\\npublic:\\n\\n    int helper(string s, unordered_set<string> dict, int ind){\\n        if(ind >= s.size()) return 0;\\n        int res = 1 + helper(s,dict,ind+1) ;\\n\\n        for(int i = 1 ; ind+i <= s.size() ; i++){\\n            string str = s.substr(ind,i);\\n            if(dict.count(str)){\\n                res = min(res, helper(s,dict,ind+i));\\n            }\\n        }\\n        return res;\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_set <string> dict(dictionary.begin(), dictionary.end());\\n        return helper(s,dict,0);\\n    }\\n};\\n\\n\\n```\n```Cpp []\\n//Memoization Solution\\nclass Solution {\\npublic:\\n    int helper(string s, unordered_set<string> dict, int ind, vector<int> &dp){\\n        if(ind >= s.size()) return 0;\\n        if(dp[ind] != -1) return dp[ind];\\n        int res = 1 + helper(s,dict,ind+1, dp) ;\\n\\n        for(int i = 1 ; ind+i <= s.size() ; i++){\\n            string str = s.substr(ind,i);\\n            if(dict.count(str)){\\n                res = min(res, helper(s,dict,ind+i,dp));\\n            }\\n        }\\n        return dp[ind] = res;\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_set <string> dict(dictionary.begin(), dictionary.end());\\n        vector<int> dp(s.size()+1, -1);\\n        return helper(s,dict,0, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568823,
                "title": "pick-not-pick-dp-c-easy",
                "content": "**NOTE** :\\ncode is self explenatory , if you have any doubts do let me know in the comments \\u270C\\uFE0F\\n\\n**Intuition**:\\nMaximise the substring length from s that matches dictionary string. The positions that are not included is our answer.\\n\\n**Approach**:\\nwhenever we found a string that is present in our dictionary map, we have two choices either take it or not take it. keep maximising it untll we reach our end.\\n\\n`dp[pos]`  stores the max indices that can be taken from current position to last.\\nFinally **`n-dp[0]`** gives the characters that are extra which is our answer.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        dp.resize(s.size()+1,-1);\\n        unordered_map<string,int> mp;\\n        for(auto &ss : dictionary) mp[ss]++;\\n\\t\\tint n=s.size();\\n        return n-solve(0,s,mp);\\n    }\\n    \\n    int solve(int pos,string &s,unordered_map<string,int> &mp){\\n        int n=s.size();\\n        int res=0;\\n        if(dp[pos]!=-1) return dp[pos];\\n        for(int i=pos;i<n;i++){\\n            // take\\n            if(mp.count(s.substr(pos,i-pos+1))){\\n                res=max(res,i-pos+1+solve(i+1,s,mp));  \\n            }\\n            // n_take\\n            res=max(res,solve(i+1,s,mp));\\n        }\\n        return dp[pos]=res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        dp.resize(s.size()+1,-1);\\n        unordered_map<string,int> mp;\\n        for(auto &ss : dictionary) mp[ss]++;\\n\\t\\tint n=s.size();\\n        return n-solve(0,s,mp);\\n    }\\n    \\n    int solve(int pos,string &s,unordered_map<string,int> &mp){\\n        int n=s.size();\\n        int res=0;\\n        if(dp[pos]!=-1) return dp[pos];\\n        for(int i=pos;i<n;i++){\\n            // take\\n            if(mp.count(s.substr(pos,i-pos+1))){\\n                res=max(res,i-pos+1+solve(i+1,s,mp));  \\n            }\\n            // n_take\\n            res=max(res,solve(i+1,s,mp));\\n        }\\n        return dp[pos]=res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568816,
                "title": "c-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDo the DP boi\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ndp[i][j]: min amount of chars left for s[i..j)\\nAt each step try every word in the dict, and if it\\'s found we can break it into two subproblems.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2) states, transitions take O(d*n)\\nSo in total around O(n^4)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> dp;\\n    \\n    int f(string&s, int low, int high, vector<string>&dictionary){\\n        int &ans = dp[low][high];\\n        if(ans!=-1) return ans;\\n        ans = high-low;\\n        \\n        string tok = s.substr(low, high-low);\\n        for(auto&d:dictionary){\\n            int id = tok.find(d);\\n            if(id==-1) continue;\\n            ans = min(ans, f(s,low,low+id,dictionary) + f(s,low+id+d.size(),high,dictionary));\\n        }\\n        return ans;\\n        \\n    }\\n    \\n    \\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        int n = s.size();\\n        // dp[i][j] : s[i..j);\\n        dp.assign(n+1, vector<int>(n+1,-1));\\n        \\n        f(s,0,n,dictionary);\\n        return dp[0][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> dp;\\n    \\n    int f(string&s, int low, int high, vector<string>&dictionary){\\n        int &ans = dp[low][high];\\n        if(ans!=-1) return ans;\\n        ans = high-low;\\n        \\n        string tok = s.substr(low, high-low);\\n        for(auto&d:dictionary){\\n            int id = tok.find(d);\\n            if(id==-1) continue;\\n            ans = min(ans, f(s,low,low+id,dictionary) + f(s,low+id+d.size(),high,dictionary));\\n        }\\n        return ans;\\n        \\n    }\\n    \\n    \\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        int n = s.size();\\n        // dp[i][j] : s[i..j);\\n        dp.assign(n+1, vector<int>(n+1,-1));\\n        \\n        f(s,0,n,dictionary);\\n        return dp[0][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568797,
                "title": "simple-pick-not-pick-recursive-solution-memoisation",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dict) {\\n        vector<int> dp(s.size(),-1);\\n        return f(0,s,dict,dp);\\n    }\\n    \\n    int f(int idx, string s, vector<string> &dict, vector<int> &dp) {\\n        if(idx >= s.size()) return 0;\\n        \\n        if(dp[idx] != -1) return dp[idx];\\n        \\n        int ans = 51;\\n        for(int j=0 ; j<dict.size() ; j++) {\\n            string str = dict[j];\\n            int len = str.size();\\n            \\n            if(idx+len <= s.size()) {\\n                string m = s.substr(idx,len);\\n                if(m == str) {\\n                    int pick = f(idx+len,s,dict,dp);\\n                    ans = min(ans,pick);\\n                }\\n            } \\n        }\\n            \\n        int notPick = 1 + f(idx+1,s,dict,dp);\\n        return dp[idx] = min(ans,notPick);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dict) {\\n        vector<int> dp(s.size(),-1);\\n        return f(0,s,dict,dp);\\n    }\\n    \\n    int f(int idx, string s, vector<string> &dict, vector<int> &dp) {\\n        if(idx >= s.size()) return 0;\\n        \\n        if(dp[idx] != -1) return dp[idx];\\n        \\n        int ans = 51;\\n        for(int j=0 ; j<dict.size() ; j++) {\\n            string str = dict[j];\\n            int len = str.size();\\n            \\n            if(idx+len <= s.size()) {\\n                string m = s.substr(idx,len);\\n                if(m == str) {\\n                    int pick = f(idx+len,s,dict,dp);\\n                    ans = min(ans,pick);\\n                }\\n            } \\n        }\\n            \\n        int notPick = 1 + f(idx+1,s,dict,dp);\\n        return dp[idx] = min(ans,notPick);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568780,
                "title": "python-ez-dfs-with-explanation",
                "content": "# Complexity\\n- Time complexity : $$O(n!)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        def dfs(cur, k):\\n            if k >= self.Min: # no need to keep searching\\n                return\\n            if cur == n: # save current answer\\n                self.Min = min(self.Min, k)\\n                return\\n            for i in range(cur, n):\\n                if s[cur:i+1] in d: # if match, jump to this word\\'s end-index + 1\\n                    dfs(i+1, k)\\n            dfs(cur+1, k+1) # skip index cur, so k+1\\n            \\n        d = set(dictionary)\\n        n = len(s)\\n        self.Min = inf\\n        dfs(0, 0)\\n        return self.Min\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        def dfs(cur, k):\\n            if k >= self.Min: # no need to keep searching\\n                return\\n            if cur == n: # save current answer\\n                self.Min = min(self.Min, k)\\n                return\\n            for i in range(cur, n):\\n                if s[cur:i+1] in d: # if match, jump to this word\\'s end-index + 1\\n                    dfs(i+1, k)\\n            dfs(cur+1, k+1) # skip index cur, so k+1\\n            \\n        d = set(dictionary)\\n        n = len(s)\\n        self.Min = inf\\n        dfs(0, 0)\\n        return self.Min\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568766,
                "title": "c-solutions-explained-line-by-line-easy-to-understand-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the code is to use dynamic programming to find the minimum number of extra characters left over when breaking up the input string s into substrings that are present in the dictionary.\\n\\nThe code uses a bottom-up dynamic programming approach. It starts by initializing a DP array dp of size n1 + 1, where n1 is the size of the input string s. Each element dp[i] represents the minimum number of extra characters left over when considering the substring s[0:i].\\n\\nThe code then iterates over the input string s and for each position i, it checks all possible substrings starting from the current position. It uses another pointer j to iterate from i to 1 and considers the substring s[j-1:i]. If this substring is present in the dictionary, it updates the dp[i] value by taking the minimum between the current dp[i] value and the dp[j-1] value, which represents the minimum number of extra characters left over before the substring s[j-1:i].\\n\\nBy the end of the iteration, the dp[n1] value represents the minimum number of extra characters left over for the entire string s. This is the result returned by the code.\\n\\nOverall, the approach uses dynamic programming to build up the solution incrementally by considering all possible substrings and their corresponding minimum extra characters. The DP array helps to avoid recomputation of overlapping subproblems and allows for an efficient solution.\\n\\n\\n\\n\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in the code is a bottom-up dynamic programming approach. Here\\'s a step-by-step explanation of the approach:\\n\\nCreate a set called str to store the words from the dictionary. This allows for efficient lookup of substrings later on.\\n\\nGet the size of the input string s and the number of words in the dictionary n1 and n2 respectively.\\n\\nInitialize a DP array dp of size n1 + 1 with all elements set to 0. Each element dp[i] will represent the minimum number of extra characters left over when considering the substring s[0:i].\\n\\nIterate over the input string s from left to right using the variable i:\\n\\nSet the initial value of dp[i] to dp[i-1] + 1. This represents the case where we consider an extra character at position i.\\n\\nIterate over all possible substrings starting from the current position i and going back to position j, where j ranges from i to 1:\\n\\nExtract the substring temp from s[j-1:i].\\n\\nCheck if the substring temp is present in the str set. If it is, update dp[i] by taking the minimum between the current dp[i] value and dp[j-1]. This represents the case where we break the string at position j-1 and consider the minimum number of extra characters left over before the substring temp.\\nAfter completing the iteration, the value of dp[n1] represents the minimum number of extra characters left over for the entire string s. This is the result returned by the function.\\n\\nThe bottom-up dynamic programming approach allows for efficiently solving the problem by breaking it down into smaller subproblems and using the previously computed values to build up the solution iteratively. The use of the set str enables efficient substring lookup, and the DP array dp helps avoid redundant computations and ensures an optimal solution is achieved.\\n\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the approach is O(n1^2), where n1 is the length of the input string s. This is because there are two nested loops in the code: the outer loop iterates over the input string s of length n1, and the inner loop iterates from i to 1, which can be at most n1 iterations. Within the inner loop, the code checks if substrings are present in the set str, which has an average complexity of O(1) due to the use of hashing in the set implementation.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the approach is O(n1 + n2), where n1 is the length of the input string s and n2 is the number of words in the dictionary. This space is used for storing the DP array dp of size n1+1 and the set str to store the words from the dictionary. The DP array requires O(n1) space, and the set str can store at most n2 words, requiring additional space of O(n2).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        // Create a set to store the words in the dictionary\\n        set<string> str;\\n        \\n        // Get the sizes of the input string and the dictionary\\n        int n1 = s.size();\\n        int n2 = dictionary.size();\\n        \\n        // Insert all the words from the dictionary into the set\\n        for (int i = 0; i < n2; i++) {\\n            str.insert(dictionary[i]);\\n        }\\n        \\n        // Create a DP (dynamic programming) array to store the minimum extra characters\\n        vector<int> dp(n1 + 1, 0);\\n   \\n        // Iterate over the input string\\n        for (int i = 1; i <= n1; i++) {\\n            // Initialize the DP value for the current position as one more than the previous position\\n            dp[i] = dp[i - 1] + 1;\\n            \\n            // Check all possible substrings starting from the current position\\n            for (int j = i; j >= 1; j--) {\\n                // Get the substring from index j-1 to i\\n                string temp = s.substr(j - 1, i - j + 1);\\n                \\n                // If the substring is present in the dictionary, update the DP value\\n                if (str.count(temp)) {\\n                    dp[i] = min(dp[i], dp[j - 1]);\\n                }\\n            }\\n        }\\n        \\n        // Return the minimum extra characters left at the end of the string\\n        return dp[n1];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        // Create a set to store the words in the dictionary\\n        set<string> str;\\n        \\n        // Get the sizes of the input string and the dictionary\\n        int n1 = s.size();\\n        int n2 = dictionary.size();\\n        \\n        // Insert all the words from the dictionary into the set\\n        for (int i = 0; i < n2; i++) {\\n            str.insert(dictionary[i]);\\n        }\\n        \\n        // Create a DP (dynamic programming) array to store the minimum extra characters\\n        vector<int> dp(n1 + 1, 0);\\n   \\n        // Iterate over the input string\\n        for (int i = 1; i <= n1; i++) {\\n            // Initialize the DP value for the current position as one more than the previous position\\n            dp[i] = dp[i - 1] + 1;\\n            \\n            // Check all possible substrings starting from the current position\\n            for (int j = i; j >= 1; j--) {\\n                // Get the substring from index j-1 to i\\n                string temp = s.substr(j - 1, i - j + 1);\\n                \\n                // If the substring is present in the dictionary, update the DP value\\n                if (str.count(temp)) {\\n                    dp[i] = min(dp[i], dp[j - 1]);\\n                }\\n            }\\n        }\\n        \\n        // Return the minimum extra characters left at the end of the string\\n        return dp[n1];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568720,
                "title": "easy-to-understand-beginners-freindly-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis code utilizes dynamic programming to efficiently compute the minimum number of extra characters needed to form a given string using a set of substrings. By iteratively building substrings and using previously computed values, it determines the optimal solution.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nA vector dp of size n + 1 is created and initialized with the maximum possible integer value using numeric_limits<int>::max(). This vector will store the minimum number of extra characters required to form the substring ending at index i of the input string.\\n\\nTwo nested loops are used to iterate through all possible substrings of s. The outer loop iterates from index 1 to n, representing the end index of the substring, and the inner loop iterates from the current end index to index 1, representing the start index of the substring.\\n\\nIn each iteration of the nested loops, a substring is extracted from s using the substr function. This substring is checked against the substrings in the dict set using count. If a matching substring is found in the set, the minimum value of dp[i] is updated with the value of dp[j - 1], where j is the start index of the current substring.\\n\\nAfter the inner loop finishes, the minimum value of dp[i] is compared with the value of dp[i - 1] + 1, which represents the case of adding an extra character at the end of the current substring. The smaller value is then stored in dp[i].\\n\\nFinally, the function returns the value at index n of the dp vector, which represents the minimum number of extra characters required to form the entire input string s\\n# Complexity\\n- Time complexity: O(n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& v) {\\n        unordered_set<string> dict(v.begin(), v.end());\\n        int n = s.length();\\n\\n        \\n        vector<int> dp(n + 1, numeric_limits<int>::max());\\n        dp[0] = 0;\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = i; j >= 1; j--) {\\n                string substring = s.substr(j - 1, i - j + 1);\\n                if (dict.count(substring)) dp[i] = std::min(dp[i], dp[j - 1]);\\n                \\n            }\\n            dp[i] = min(dp[i], dp[i - 1] + 1); \\n        }\\n\\n        return dp[n];   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& v) {\\n        unordered_set<string> dict(v.begin(), v.end());\\n        int n = s.length();\\n\\n        \\n        vector<int> dp(n + 1, numeric_limits<int>::max());\\n        dp[0] = 0;\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = i; j >= 1; j--) {\\n                string substring = s.substr(j - 1, i - j + 1);\\n                if (dict.count(substring)) dp[i] = std::min(dp[i], dp[j - 1]);\\n                \\n            }\\n            dp[i] = min(dp[i], dp[i - 1] + 1); \\n        }\\n\\n        return dp[n];   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568706,
                "title": "c-dp-recursion",
                "content": "# Intuition\\nUse dynamic programming.\\n\\n# Approach\\nAdd an extra method and call it recursively:\\n```\\nprivate int MinExtraChar(int index, Dictionary<int, int> dic, string s, string[] dictionary)\\n```\\nwhere\\n- index is an index in string s\\n- Dictionary<int, int> dic is a dictionary for intermediate results\\n- s is an initial string\\n- dictionary is an initial dictionary\\n\\n# Complexity\\n- Time complexity:\\n$$O(len(s))$$\\n\\n- Space complexity:\\n$$O(len(s))$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinExtraChar(string s, string[] dictionary) {\\n        var rs = MinExtraChar(0, new Dictionary<int, int>(), s, dictionary);\\n        return rs;\\n    }\\n    private int MinExtraChar(int index, Dictionary<int, int> dic, string s, string[] dictionary)\\n    {\\n        if (dic.ContainsKey(index)) return dic[index];\\n        var rs = s.Length - index;\\n        for (int i = 0; i < dictionary.Length; i++)\\n        {\\n            var index0 = s.IndexOf(dictionary[i], index);\\n            if (index0 != -1)\\n            {\\n                var rs0 = (index0 - index) + MinExtraChar(index0 + dictionary[i].Length, dic, s, dictionary);\\n                if (rs > rs0) rs = rs0;\\n            }\\n        }\\n        if (!dic.ContainsKey(index)) dic.Add(index, rs);\\n        return rs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nprivate int MinExtraChar(int index, Dictionary<int, int> dic, string s, string[] dictionary)\\n```\n```\\npublic class Solution {\\n    public int MinExtraChar(string s, string[] dictionary) {\\n        var rs = MinExtraChar(0, new Dictionary<int, int>(), s, dictionary);\\n        return rs;\\n    }\\n    private int MinExtraChar(int index, Dictionary<int, int> dic, string s, string[] dictionary)\\n    {\\n        if (dic.ContainsKey(index)) return dic[index];\\n        var rs = s.Length - index;\\n        for (int i = 0; i < dictionary.Length; i++)\\n        {\\n            var index0 = s.IndexOf(dictionary[i], index);\\n            if (index0 != -1)\\n            {\\n                var rs0 = (index0 - index) + MinExtraChar(index0 + dictionary[i].Length, dic, s, dictionary);\\n                if (rs > rs0) rs = rs0;\\n            }\\n        }\\n        if (!dic.ContainsKey(index)) dic.Add(index, rs);\\n        return rs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568675,
                "title": "using-dp",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,unordered_map<string,int>&h,string s,vector<int>&dp)\\n    {if(dp[i]!=-1)\\n        return(dp[i]);\\n        if(i==s.size())\\n            return(dp[i]=0);\\n        int ans=INT_MAX;\\n        int f=0;\\n        string x=\"\";\\n        for(int j=i;j<s.size();j++)\\n        {\\n            x+=s[j];\\n            \\n            if(h.count(x)>0)\\n            {\\n                ans=min(ans,solve(j+1,h,s,dp));\\n            }\\n            \\n        }\\n        int c=0;\\n        if(f==0)\\n            c=1;\\n        ans=min(ans,c+solve(i+1,h,s,dp));\\n        return(dp[i]=ans);\\n        \\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<string,int>h;\\n        for(auto e:dictionary)\\n             h[e]++;\\n        int n=s.size();\\n        vector<int>dp(n+1,-1);\\n      \\n        return(solve(0,h,s,dp));\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,unordered_map<string,int>&h,string s,vector<int>&dp)\\n    {if(dp[i]!=-1)\\n        return(dp[i]);\\n        if(i==s.size())\\n            return(dp[i]=0);\\n        int ans=INT_MAX;\\n        int f=0;\\n        string x=\"\";\\n        for(int j=i;j<s.size();j++)\\n        {\\n            x+=s[j];\\n            \\n            if(h.count(x)>0)\\n            {\\n                ans=min(ans,solve(j+1,h,s,dp));\\n            }\\n            \\n        }\\n        int c=0;\\n        if(f==0)\\n            c=1;\\n        ans=min(ans,c+solve(i+1,h,s,dp));\\n        return(dp[i]=ans);\\n        \\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<string,int>h;\\n        for(auto e:dictionary)\\n             h[e]++;\\n        int n=s.size();\\n        vector<int>dp(n+1,-1);\\n      \\n        return(solve(0,h,s,dp));\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568674,
                "title": "modified-knapsack-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nModified Knapsack algo.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        diction = set(dictionary)\\n        n = len(s)\\n        dp = [0] * (n + 1)\\n\\n        for i in range(1, n + 1):\\n            dp[i] = dp[i - 1] + 1\\n            for j in range(i - 1, -1, -1):\\n                if s[j: i] in diction:\\n                    dp[i] = min(dp[i], dp[j])\\n\\n        return dp[n]\\n                \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        diction = set(dictionary)\\n        n = len(s)\\n        dp = [0] * (n + 1)\\n\\n        for i in range(1, n + 1):\\n            dp[i] = dp[i - 1] + 1\\n            for j in range(i - 1, -1, -1):\\n                if s[j: i] in diction:\\n                    dp[i] = min(dp[i], dp[j])\\n\\n        return dp[n]\\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568616,
                "title": "top-down-dp-explained-similar-problems",
                "content": "# Intuition\\nReminded me of [139. Word Break](https://leetcode.com/problems/word-break/). Only we are allowed to skip characters this time.\\n\\n# Approach\\n1. Maintain a set of allowed words. At each point either skip the word OR try to form a valid word. \\n2. Minimum number of skips to reach the end is the answer.\\n3. Use dynamic programming to avoid repeating the steps.\\n# Complexity\\n- Time complexity:\\n    O(N^2*LOGN)\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int partit(int ind,int n,string s,unordered_set <string> &words,\\n               vector <int> &dp){\\n        if(ind==n)return 0;\\n        \\n        if(dp[ind]!=-1)return dp[ind];\\n        \\n        int choice=1+partit(ind+1,n,s,words,dp);\\n        for(int i=ind;i<n;i++){\\n            string t=s.substr(ind,i-ind+1);\\n            if(words.count(t))\\n                choice=min(choice,partit(i+1,n,s,words,dp));\\n        }\\n        return dp[ind]=choice;\\n    }\\npublic:\\n    int minExtraChar(string s, vector<string>& wordDict) {\\n        int n=s.length();\\n        unordered_set <string> words(begin(wordDict),end(wordDict));\\n        vector <int> dp(n,-1);\\n\\n        return partit(0,n,s,words,dp);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int partit(int ind,int n,string s,unordered_set <string> &words,\\n               vector <int> &dp){\\n        if(ind==n)return 0;\\n        \\n        if(dp[ind]!=-1)return dp[ind];\\n        \\n        int choice=1+partit(ind+1,n,s,words,dp);\\n        for(int i=ind;i<n;i++){\\n            string t=s.substr(ind,i-ind+1);\\n            if(words.count(t))\\n                choice=min(choice,partit(i+1,n,s,words,dp));\\n        }\\n        return dp[ind]=choice;\\n    }\\npublic:\\n    int minExtraChar(string s, vector<string>& wordDict) {\\n        int n=s.length();\\n        unordered_set <string> words(begin(wordDict),end(wordDict));\\n        vector <int> dp(n,-1);\\n\\n        return partit(0,n,s,words,dp);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568559,
                "title": "c-solution",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    public int MinExtraChar(string s, string[] dictionary)\\n    {\\n        var n = s.Length;\\n        var dp = Enumerable.Repeat(n, n + 1).ToArray();\\n        dp[0] = 0;\\n\\n        for (var i = 0; i < n; i++)\\n        {\\n            if (dp[i] != n)\\n                foreach (var word in dictionary.Where(w => i + w.Length <= n && s[i..(i + w.Length)] == w))\\n                    dp[i + word.Length] = Math.Min(dp[i + word.Length], dp[i]);\\n\\n            dp[i + 1] = Math.Min(dp[i + 1], dp[i] + 1);\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int MinExtraChar(string s, string[] dictionary)\\n    {\\n        var n = s.Length;\\n        var dp = Enumerable.Repeat(n, n + 1).ToArray();\\n        dp[0] = 0;\\n\\n        for (var i = 0; i < n; i++)\\n        {\\n            if (dp[i] != n)\\n                foreach (var word in dictionary.Where(w => i + w.Length <= n && s[i..(i + w.Length)] == w))\\n                    dp[i + word.Length] = Math.Min(dp[i + word.Length], dp[i]);\\n\\n            dp[i + 1] = Math.Min(dp[i + 1], dp[i] + 1);\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097988,
                "title": "super-easy-c-solution-with-explanation",
                "content": "# Code\\n```\\nauto f = [](){\\n    ios::sync_with_stdio(false);\\n    cin.tie(NULL);\\n    return 0;\\n}();\\nclass Solution {\\npublic:\\n    unordered_set<string> us; \\n    int dp[51];\\n\\n    int solve(int i, string & s) {\\n        int n = s.size(); \\n        if(i == n) return 0; \\n        if(dp[i] != -1) return dp[i];\\n        string build = \"\";\\n        int mn = n; \\n        for(int k = i; k < n; ++k) {\\n            build.push_back(s[k]);\\n            if(us.count(build)) {\\n                mn = min(solve(k+1, s), mn);\\n            } else {\\n                mn = min(solve(k+1, s) + (int)build.size(), mn);\\n            }\\n        }\\n        return dp[i] = mn;\\n    }\\n\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        for(string s : dictionary) us.insert(s); \\n        memset(dp, -1, sizeof dp);\\n\\n        return solve(0, s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nauto f = [](){\\n    ios::sync_with_stdio(false);\\n    cin.tie(NULL);\\n    return 0;\\n}();\\nclass Solution {\\npublic:\\n    unordered_set<string> us; \\n    int dp[51];\\n\\n    int solve(int i, string & s) {\\n        int n = s.size(); \\n        if(i == n) return 0; \\n        if(dp[i] != -1) return dp[i];\\n        string build = \"\";\\n        int mn = n; \\n        for(int k = i; k < n; ++k) {\\n            build.push_back(s[k]);\\n            if(us.count(build)) {\\n                mn = min(solve(k+1, s), mn);\\n            } else {\\n                mn = min(solve(k+1, s) + (int)build.size(), mn);\\n            }\\n        }\\n        return dp[i] = mn;\\n    }\\n\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        for(string s : dictionary) us.insert(s); \\n        memset(dp, -1, sizeof dp);\\n\\n        return solve(0, s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4092169,
                "title": "easy-dp-java-program",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        \\n        int n = s.length();\\n\\n        Set<String> dict = new HashSet<>();\\n\\n        for (String word : dictionary) {\\n            dict.add(word);\\n        }\\n\\n        int[] dp = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n\\n            dp[i] = dict.contains(s.substring(0, i + 1)) ? 0 : i + 1;\\n\\n            for (int j = 0; j < i; j++) {\\n\\n                String partition = s.substring(j + 1, i + 1);\\n\\n                if (dict.contains(partition)) {\\n                    dp[i] = Math.min(dp[i], dp[j]);\\n                } else {\\n                    dp[i] = Math.min(dp[i], dp[j] + i - j); // i - j = partition.length()\\n                }\\n            }\\n        }\\n\\n        return dp[n - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        \\n        int n = s.length();\\n\\n        Set<String> dict = new HashSet<>();\\n\\n        for (String word : dictionary) {\\n            dict.add(word);\\n        }\\n\\n        int[] dp = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n\\n            dp[i] = dict.contains(s.substring(0, i + 1)) ? 0 : i + 1;\\n\\n            for (int j = 0; j < i; j++) {\\n\\n                String partition = s.substring(j + 1, i + 1);\\n\\n                if (dict.contains(partition)) {\\n                    dp[i] = Math.min(dp[i], dp[j]);\\n                } else {\\n                    dp[i] = Math.min(dp[i], dp[j] + i - j); // i - j = partition.length()\\n                }\\n            }\\n        }\\n\\n        return dp[n - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075168,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nunordered_set<string> lookup;\\nunordered_map<int,int> mp;\\n\\n\\nint solve(string s,int index)\\n{\\n    if (index >= s.length())   return 0;\\n    if (mp.find(index)!=mp.end())   return mp[index];\\n  \\nstring form;\\nint minExtra=INT32_MAX;\\n    for (int i=index;i<s.length();i++)\\n    {\\n        form.push_back(s[i]);\\n        int currExtra= lookup.count(form)?0: form.length();\\n        int nextExtra= solve(s,i+1);\\n        int totalextra= currExtra+ nextExtra;\\n\\n        minExtra=min(minExtra,totalextra);\\n        \\n    }\\n    return mp[index]=minExtra;\\n}\\n    int minExtraChar(string s, vector<string>& dict) {\\n\\n        for (auto x: dict)\\n        {\\n            lookup.insert(x);\\n        }\\n        return solve(s,0);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nunordered_set<string> lookup;\\nunordered_map<int,int> mp;\\n\\n\\nint solve(string s,int index)\\n{\\n    if (index >= s.length())   return 0;\\n    if (mp.find(index)!=mp.end())   return mp[index];\\n  \\nstring form;\\nint minExtra=INT32_MAX;\\n    for (int i=index;i<s.length();i++)\\n    {\\n        form.push_back(s[i]);\\n        int currExtra= lookup.count(form)?0: form.length();\\n        int nextExtra= solve(s,i+1);\\n        int totalextra= currExtra+ nextExtra;\\n\\n        minExtra=min(minExtra,totalextra);\\n        \\n    }\\n    return mp[index]=minExtra;\\n}\\n    int minExtraChar(string s, vector<string>& dict) {\\n\\n        for (auto x: dict)\\n        {\\n            lookup.insert(x);\\n        }\\n        return solve(s,0);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066006,
                "title": "prefer-string-view-over-substr-in-c",
                "content": "# Intuition\\nI notice many C++ solutions keeping copying strings. With the help of C++17, we can use std::string_view to avoid copying.\\n\\n# Approach\\nReplace `string.substr()` with `std::string_view`.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n- Space complexity: $$O(s + d)$$\\n\\n# Code\\n```\\nstruct Solution\\n{\\n    int minExtraChar(std::string const & s, std::vector<std::string> const & dictionary)\\n    {\\n        auto min = std::numeric_limits<int>::max();\\n        auto max = std::numeric_limits<int>::min();\\n        auto dic = std::unordered_map<int, std::unordered_set<std::string_view>>();\\n        for (auto & word : dictionary)\\n        {\\n            auto len = static_cast<int>(word.size());\\n            min = std::min(min, len);\\n            max = std::max(max, len);\\n            dic[len].insert(word);\\n        }\\n\\n        auto n = static_cast<int>(s.size());\\n        auto f = std::vector<int>(s.size() + 1);\\n        auto h = s.begin();\\n        for (auto r = 1; r <= n; ++r)\\n        {\\n            f[r] = f[r - 1] + 1;\\n            for (auto l = std::max(0, r - max), m = std::max(0, r - min); l <= m; ++l)\\n            {\\n                auto sub = std::string_view(std::next(h, l), std::next(h, r));\\n                auto pos = dic.find(r - l);\\n                if (pos == dic.end())\\n                    continue;\\n\\n                auto & set = pos->second;\\n                if (set.find(sub) == set.end())\\n                    continue;\\n\\n                f[r] = std::min(f[r], f[l]);\\n            }\\n        }\\n        return f[n];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct Solution\\n{\\n    int minExtraChar(std::string const & s, std::vector<std::string> const & dictionary)\\n    {\\n        auto min = std::numeric_limits<int>::max();\\n        auto max = std::numeric_limits<int>::min();\\n        auto dic = std::unordered_map<int, std::unordered_set<std::string_view>>();\\n        for (auto & word : dictionary)\\n        {\\n            auto len = static_cast<int>(word.size());\\n            min = std::min(min, len);\\n            max = std::max(max, len);\\n            dic[len].insert(word);\\n        }\\n\\n        auto n = static_cast<int>(s.size());\\n        auto f = std::vector<int>(s.size() + 1);\\n        auto h = s.begin();\\n        for (auto r = 1; r <= n; ++r)\\n        {\\n            f[r] = f[r - 1] + 1;\\n            for (auto l = std::max(0, r - max), m = std::max(0, r - min); l <= m; ++l)\\n            {\\n                auto sub = std::string_view(std::next(h, l), std::next(h, r));\\n                auto pos = dic.find(r - l);\\n                if (pos == dic.end())\\n                    continue;\\n\\n                auto & set = pos->second;\\n                if (set.find(sub) == set.end())\\n                    continue;\\n\\n                f[r] = std::min(f[r], f[l]);\\n            }\\n        }\\n        return f[n];\\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4055387,
                "title": "python3-dfs",
                "content": "```\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        \\n        dictionary = set(dictionary)\\n        n = len(s)\\n        res = inf\\n\\n        @cache\\n        def dfs(i):\\n            if i == n: return 0\\n\\n            res = 1 + dfs(i + 1)\\n\\n            for j in range(i, n):\\n                if s[i: j + 1] not in dictionary: continue\\n                res = min(res, dfs(j + 1))\\n            return res\\n\\n        return dfs(0)\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        \\n        dictionary = set(dictionary)\\n        n = len(s)\\n        res = inf\\n\\n        @cache\\n        def dfs(i):\\n            if i == n: return 0\\n\\n            res = 1 + dfs(i + 1)\\n\\n            for j in range(i, n):\\n                if s[i: j + 1] not in dictionary: continue\\n                res = min(res, dfs(j + 1))\\n            return res\\n\\n        return dfs(0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4052407,
                "title": "python-solution-dp-beats-97",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    \\n    def minExtraChar(self, s, dictionary):\\n        \\n        ### Adjust dict\\n        dictionary_adj = {}\\n        for elt in dictionary:\\n            if elt[0] not in dictionary_adj:\\n                dictionary_adj[elt[0]] = [elt, ]\\n            else:\\n                dictionary_adj[elt[0]].append(elt)\\n        ###\\n        \\n        dp = {i: 0 for i in range(len(s))}\\n        \\n        if s[-1] in dictionary_adj:\\n            if s[-1] in dictionary_adj[s[-1]]:\\n                dp[len(s) - 1] = 0\\n            else:\\n                dp[len(s) - 1] = 1\\n        else:\\n            dp[len(s) - 1] = 1\\n        \\n                \\n        for i in range(len(s) - 2, -1, -1):\\n            dp[i] = dp[i + 1] + 1\\n            if s[i] in dictionary_adj:\\n                for elt in dictionary_adj[s[i]]:\\n                    if s[i: i + len(elt)] == elt:\\n                        if i + len(elt) == len(s):\\n                            dp[i] = 0\\n                        else:\\n                            dp[i] = min(dp[i], dp[i + len(elt)])\\n        return dp[0]\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def minExtraChar(self, s, dictionary):\\n        \\n        ### Adjust dict\\n        dictionary_adj = {}\\n        for elt in dictionary:\\n            if elt[0] not in dictionary_adj:\\n                dictionary_adj[elt[0]] = [elt, ]\\n            else:\\n                dictionary_adj[elt[0]].append(elt)\\n        ###\\n        \\n        dp = {i: 0 for i in range(len(s))}\\n        \\n        if s[-1] in dictionary_adj:\\n            if s[-1] in dictionary_adj[s[-1]]:\\n                dp[len(s) - 1] = 0\\n            else:\\n                dp[len(s) - 1] = 1\\n        else:\\n            dp[len(s) - 1] = 1\\n        \\n                \\n        for i in range(len(s) - 2, -1, -1):\\n            dp[i] = dp[i + 1] + 1\\n            if s[i] in dictionary_adj:\\n                for elt in dictionary_adj[s[i]]:\\n                    if s[i: i + len(elt)] == elt:\\n                        if i + len(elt) == len(s):\\n                            dp[i] = 0\\n                        else:\\n                            dp[i] = min(dp[i], dp[i + len(elt)])\\n        return dp[0]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049997,
                "title": "different-approach-beats-75",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->I would reccoment solving wordBreak problem and problems on Front partition , \\nBUt this one is kinda hard \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    unordered_set<string> m;\\n    unordered_map<int, int> memo; \\n\\n    int dp(string &s, int ind) {\\n        if (ind == s.size()) {\\n            return 0;\\n        }\\n\\n        if (memo.find(ind) != memo.end()) {\\n            return memo[ind];\\n        }\\n\\n        int ans = INT_MAX;\\n        for (int k = 1; k <= s.size() - ind; k++) { \\n            string temp = s.substr(ind, k);\\n            if (m.find(temp) != m.end()) {\\n                int cse1 = dp(s, ind + k);\\n                ans = min(ans, cse1);\\n            } else {\\n                int cse2 = 1 + dp(s, ind + 1);\\n                ans = min(ans, cse2);\\n            }\\n        }\\n        \\n        memo[ind] = ans;\\n        return ans;\\n    }\\n\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        for (auto x : dictionary) {\\n            m.insert(x);\\n        }\\n        return dp(s, 0);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    unordered_set<string> m;\\n    unordered_map<int, int> memo; \\n\\n    int dp(string &s, int ind) {\\n        if (ind == s.size()) {\\n            return 0;\\n        }\\n\\n        if (memo.find(ind) != memo.end()) {\\n            return memo[ind];\\n        }\\n\\n        int ans = INT_MAX;\\n        for (int k = 1; k <= s.size() - ind; k++) { \\n            string temp = s.substr(ind, k);\\n            if (m.find(temp) != m.end()) {\\n                int cse1 = dp(s, ind + k);\\n                ans = min(ans, cse1);\\n            } else {\\n                int cse2 = 1 + dp(s, ind + 1);\\n                ans = min(ans, cse2);\\n            }\\n        }\\n        \\n        memo[ind] = ans;\\n        return ans;\\n    }\\n\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        for (auto x : dictionary) {\\n            m.insert(x);\\n        }\\n        return dp(s, 0);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042916,
                "title": "java-clean-code",
                "content": "```\\nclass Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        int n = s.length();\\n        int dpLength = n+1;\\n        int[] dp = getDpArray(dpLength);\\n        Set<String> dictSet = new HashSet<>(List.of(dictionary));\\n\\n        for(int i = 1; i<=n; i++) {\\n            for(int j = i; j<=n; j++) {\\n                int left = i-1;\\n                int right = j-1;\\n                String word = s.substring(left, right+1);\\n                if(dictSet.contains(word)) {\\n                    dp[j] = Math.min(dp[i-1], dp[j]);\\n                } else {\\n                    dp[j] = Math.min(dp[j-1] + 1, dp[j]);\\n                }\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n\\n    private int[] getDpArray(int dpLength) {\\n        int[] dp = new int[dpLength];\\n        for(int i = 1; i<dpLength; i++) {\\n            dp[i] = i;\\n        }\\n        return dp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        int n = s.length();\\n        int dpLength = n+1;\\n        int[] dp = getDpArray(dpLength);\\n        Set<String> dictSet = new HashSet<>(List.of(dictionary));\\n\\n        for(int i = 1; i<=n; i++) {\\n            for(int j = i; j<=n; j++) {\\n                int left = i-1;\\n                int right = j-1;\\n                String word = s.substring(left, right+1);\\n                if(dictSet.contains(word)) {\\n                    dp[j] = Math.min(dp[i-1], dp[j]);\\n                } else {\\n                    dp[j] = Math.min(dp[j-1] + 1, dp[j]);\\n                }\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n\\n    private int[] getDpArray(int dpLength) {\\n        int[] dp = new int[dpLength];\\n        for(int i = 1; i<dpLength; i++) {\\n            dp[i] = i;\\n        }\\n        return dp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041520,
                "title": "simple-one-loop-dp-solution-faster-than-97",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor each letter check for possible words and determine the min remaining letters when we reach the letter+word location. IOW, decompose the problem as f(x) = f(x-y) + f(y)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nKeep a associative array to speed up the search for words\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n x k), k = # of words\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(k)\\n# Code\\n```\\n\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        map = {}\\n        for word in dictionary:\\n            if map.get(word[0]):\\n                map[word[0]].append(word)\\n            else:\\n                map[word[0]] = [word]\\n        memo = [i for i in range(len(s) + 1)]\\n        for i, x in enumerate(s):\\n            if map.get(x):\\n                for wd in map[x]:\\n                    if wd == s[i:i + len(wd)]:\\n                        memo[i + len(wd)] = min(memo[i], memo[i + len(wd)])\\n            memo[i + 1] = min(memo[i] + 1, memo[i + 1])\\n        return memo[-1]\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        map = {}\\n        for word in dictionary:\\n            if map.get(word[0]):\\n                map[word[0]].append(word)\\n            else:\\n                map[word[0]] = [word]\\n        memo = [i for i in range(len(s) + 1)]\\n        for i, x in enumerate(s):\\n            if map.get(x):\\n                for wd in map[x]:\\n                    if wd == s[i:i + len(wd)]:\\n                        memo[i + len(wd)] = min(memo[i], memo[i + len(wd)])\\n            memo[i + 1] = min(memo[i] + 1, memo[i + 1])\\n        return memo[-1]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038632,
                "title": "easy-recursion-just-intuition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCreate substring out of given string and for every substring , check whether that exists in the dictionary or not.\\n1) If the sub-string exists,till now no words were extra.\\n2) If the sub-string does not exist,all the chars in string were extra .So ,extra words would be equal to length of substring.\\nIf substring has i chars, length = i+1\\n[String is index based 0 , so if substring is of length i , i+1 chars would be extra/useless]\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterate over string\\'s length, initially pass given string in the question.\\nForm substring by concatenating the chars of string and check if the formed substring is present in dictionary.\\n1) If yes, none of the chars till substring length were extra.so call the method recursively and pass string from i+1 index, so that next time for loop runs from i+1 to s.length()\\n2) If no, then it means substring formed till now is waste as it is not present in the dictionary .[It might be possible that adding more chars to this substring may get us a word in dictionary--**CASE3**]\\nso , for now i+1 chars were extra and we call function recursively for i+1 index.\\n\\nSince, we need to find min chars , we maintain a variable x and asign it to a large value and compare our recursive calls result with it and finally assign the min result to x itself.\\nThis way , we will be able to handle **CASE-3** and also we will get min answer .\\n\\nUse Dp to memoize our recursive call [cache the result of  recursive calls that are already computed].\\n\\nConvert input array to Map /Set so that we can check if formed substring is present in our dictionary or not. \\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n     Map<String,Integer> diction = new HashMap<>();\\n    Map<String,Integer> dp = new HashMap<>();\\n    public int solve(String s){\\n        if(s.length() == 0){\\n            return 0;\\n        }\\n        if(dp.containsKey(s)){\\n            return dp.get(s);\\n        }\\n        String temp = \"\";\\n        int x = 10000;\\n        for(int i=0 ; i<s.length() ; i++){\\n            temp += s.charAt(i);\\n            if(diction.containsKey(temp))\\n            x = Math.min(x,solve(s.substring(i+1)));\\n            else\\n            x = Math.min(x,((i+1) + solve(s.substring(i+1))));\\n        }\\n        dp.put(s,x);\\n        return x;\\n    }\\n\\n\\n    public int minExtraChar(String s, String[] dictionary) {\\n\\n        for(int i=0 ; i<dictionary.length ; i++){\\n            diction.put(dictionary[i],1);\\n        }\\n        return solve(s);\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     Map<String,Integer> diction = new HashMap<>();\\n    Map<String,Integer> dp = new HashMap<>();\\n    public int solve(String s){\\n        if(s.length() == 0){\\n            return 0;\\n        }\\n        if(dp.containsKey(s)){\\n            return dp.get(s);\\n        }\\n        String temp = \"\";\\n        int x = 10000;\\n        for(int i=0 ; i<s.length() ; i++){\\n            temp += s.charAt(i);\\n            if(diction.containsKey(temp))\\n            x = Math.min(x,solve(s.substring(i+1)));\\n            else\\n            x = Math.min(x,((i+1) + solve(s.substring(i+1))));\\n        }\\n        dp.put(s,x);\\n        return x;\\n    }\\n\\n\\n    public int minExtraChar(String s, String[] dictionary) {\\n\\n        for(int i=0 ; i<dictionary.length ; i++){\\n            diction.put(dictionary[i],1);\\n        }\\n        return solve(s);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026600,
                "title": "rust-solution-dp-hashset",
                "content": "# Intuition\\nThis problem can be solved using `DP`, my initial thought was to essentially split the string into `parts` at each point where the `substring` was contained in the `dictionary` and then optimally choose to take/not take from a previous prefix, i.e, from `(0..i)`.\\n\\n# Approach\\nWe can consider `dp[i]` to be the `minimum number` of remaining characters after performing the split operations for each substring when possible.\\n\\nInitially, we can `store` all the substrings of the dictionary in a `HashSet` and also initialise the `dp[n]` vector with `n`. Now, we iterate for each substring `(i..j)` for all `(i, j)` in `[0, n]`. This can be done with a variable storing the running substring.\\n\\nIf the current substring is contained in the `dict`, we minimise `dp[j]` with `n - len(substring)`, i.e, `i - j + 1`. At each iteration we also need to minimise `dp[j]` with `dp[k]` for each `k` from `(0..i)` from the previous states.\\n\\nFinal answer would be `dp[n - 1]`.\\n\\n# Complexity\\n- Time complexity:\\n~ `O(N ^ 3)` (Considering the amortised `O(1)` for HashSet)\\n\\n- Space complexity:\\n~ `O(max(N, |D|)`, where `D` is the dictionary\\n\\n# Code\\n```\\nuse std::cmp::{min};\\nuse std::collections::{HashSet};\\n\\nimpl Solution {\\n    pub fn min_extra_char(s: String, dict: Vec<String>) -> i32 {\\n        let s: Vec<char> = s.chars().collect();\\n        let dict: Vec<Vec<char>> = dict.iter().map(|x| x.chars().collect()).collect();\\n\\n        let mut words: HashSet<Vec<char>> = HashSet::new();\\n        for w in &dict {\\n            words.insert(w.to_vec());\\n        }\\n\\n        let n: usize = s.len();\\n\\n        let mut dp: Vec<i32> = vec![n as i32; n];\\n        for i in 0..n {\\n            let mut pref: Vec<char> = Vec::new();\\n            for j in i..n {\\n                pref.push(s[j]);\\n                if words.contains(&pref) {\\n                    dp[j] = min(dp[j], (n - (j - i + 1)) as i32);\\n                    for k in 0..i {\\n                        dp[j] = min(dp[j], dp[k] - (j - i + 1) as i32);\\n                    }\\n                }\\n                for k in 0..i {\\n                    dp[j] = min(dp[j], dp[k]);\\n                }\\n            }\\n        }\\n\\n        dp[n - 1]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Hash Table",
                    "Dynamic Programming"
                ],
                "code": "```\\nuse std::cmp::{min};\\nuse std::collections::{HashSet};\\n\\nimpl Solution {\\n    pub fn min_extra_char(s: String, dict: Vec<String>) -> i32 {\\n        let s: Vec<char> = s.chars().collect();\\n        let dict: Vec<Vec<char>> = dict.iter().map(|x| x.chars().collect()).collect();\\n\\n        let mut words: HashSet<Vec<char>> = HashSet::new();\\n        for w in &dict {\\n            words.insert(w.to_vec());\\n        }\\n\\n        let n: usize = s.len();\\n\\n        let mut dp: Vec<i32> = vec![n as i32; n];\\n        for i in 0..n {\\n            let mut pref: Vec<char> = Vec::new();\\n            for j in i..n {\\n                pref.push(s[j]);\\n                if words.contains(&pref) {\\n                    dp[j] = min(dp[j], (n - (j - i + 1)) as i32);\\n                    for k in 0..i {\\n                        dp[j] = min(dp[j], dp[k] - (j - i + 1) as i32);\\n                    }\\n                }\\n                for k in 0..i {\\n                    dp[j] = min(dp[j], dp[k]);\\n                }\\n            }\\n        }\\n\\n        dp[n - 1]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4024131,
                "title": "python-top-down-trie-prefix-tree-o-mn",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minExtraChar(self, s: str, A: List[str]) -> int:\\n        T = lambda: defaultdict(T)\\n        t = T()\\n        for w in A:\\n            tt = t\\n            for c in w:\\n                tt = tt[c]\\n            tt[None]= True\\n\\n        n = len(s)\\n        @cache\\n        def f(i):\\n            if i == n: return 0\\n            o = 1+f(i+1)\\n            tt = t\\n            for j in range(i, n+1):\\n                if None in tt:\\n                    o = min(o, f(j))\\n                if j == n or s[j] not in tt: break\\n                tt = tt[s[j]]\\n            return o\\n        return f(0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minExtraChar(self, s: str, A: List[str]) -> int:\\n        T = lambda: defaultdict(T)\\n        t = T()\\n        for w in A:\\n            tt = t\\n            for c in w:\\n                tt = tt[c]\\n            tt[None]= True\\n\\n        n = len(s)\\n        @cache\\n        def f(i):\\n            if i == n: return 0\\n            o = 1+f(i+1)\\n            tt = t\\n            for j in range(i, n+1):\\n                if None in tt:\\n                    o = min(o, f(j))\\n                if j == n or s[j] not in tt: break\\n                tt = tt[s[j]]\\n            return o\\n        return f(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018077,
                "title": "c-solution-with-comments",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- construct the trie using dictionary.\\n- then using recursion with dp.\\n- for each follow the recursion function carefully.\\n- do let me know if you have any questions.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    class Trie\\n    {\\n        public:\\n        bool ends=false;\\n        Trie *child[26];\\n    };\\n    Trie *root;\\n    int dp[50];\\n    string str=\"\";\\n    void constructTrie(vector<string> &d)\\n    {\\n        Trie *nd=root;\\n        for(auto s:d)\\n        {\\n            nd=root;\\n            for(auto c:s)\\n            {   \\n                if(!nd->child[c-\\'a\\'])\\n                    nd->child[c-\\'a\\']=new Trie();\\n                nd=nd->child[c-\\'a\\'];\\n            }\\n            nd->ends=true;\\n        }\\n    }\\n    \\n\\n    int recursion(int i)\\n    {\\n        if(str.size()==i)\\n            return 0;\\n        if(dp[i]!=-1)\\n        {\\n            return dp[i];\\n        }\\n        Trie *nd=root;\\n        int mi=1+recursion(i+1);\\n        for(int j=i;j<str.size();j++)\\n        {\\n            if(!nd->child[str[j]-\\'a\\'])\\n            {   \\n                mi=min(mi,j-i+1+recursion(j+1));\\n                break;\\n            }\\n            else\\n            {\\n                nd=nd->child[str[j]-\\'a\\'];\\n                if(nd->ends)\\n                    mi=min(mi,recursion(j+1));\\n            }\\n        }\\n        return dp[i]=mi;\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        root=new Trie();\\n        str=s;\\n        memset(dp, -1, sizeof(dp));\\n        constructTrie(dictionary);\\n        return recursion(0);\\n\\n    }\\n};\\n\\n/*P\\nN\\nPN\\nNP\\nPPPPP\\nNNNNN\\nPNPNPN\\nPNNNPP\\n\\n\\nNOT PRESENT IN ANY OTHER WORD THEN WE WE CAN ADD ONE,\\n\\nUSE TRIE\\n\\nIT ENDS NOW, THEN START THE NODE=ROOT\\nIT DOESN\\'\\'T END NOW THEN KEEP MOVING.\\n*/\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    class Trie\\n    {\\n        public:\\n        bool ends=false;\\n        Trie *child[26];\\n    };\\n    Trie *root;\\n    int dp[50];\\n    string str=\"\";\\n    void constructTrie(vector<string> &d)\\n    {\\n        Trie *nd=root;\\n        for(auto s:d)\\n        {\\n            nd=root;\\n            for(auto c:s)\\n            {   \\n                if(!nd->child[c-\\'a\\'])\\n                    nd->child[c-\\'a\\']=new Trie();\\n                nd=nd->child[c-\\'a\\'];\\n            }\\n            nd->ends=true;\\n        }\\n    }\\n    \\n\\n    int recursion(int i)\\n    {\\n        if(str.size()==i)\\n            return 0;\\n        if(dp[i]!=-1)\\n        {\\n            return dp[i];\\n        }\\n        Trie *nd=root;\\n        int mi=1+recursion(i+1);\\n        for(int j=i;j<str.size();j++)\\n        {\\n            if(!nd->child[str[j]-\\'a\\'])\\n            {   \\n                mi=min(mi,j-i+1+recursion(j+1));\\n                break;\\n            }\\n            else\\n            {\\n                nd=nd->child[str[j]-\\'a\\'];\\n                if(nd->ends)\\n                    mi=min(mi,recursion(j+1));\\n            }\\n        }\\n        return dp[i]=mi;\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        root=new Trie();\\n        str=s;\\n        memset(dp, -1, sizeof(dp));\\n        constructTrie(dictionary);\\n        return recursion(0);\\n\\n    }\\n};\\n\\n/*P\\nN\\nPN\\nNP\\nPPPPP\\nNNNNN\\nPNPNPN\\nPNNNPP\\n\\n\\nNOT PRESENT IN ANY OTHER WORD THEN WE WE CAN ADD ONE,\\n\\nUSE TRIE\\n\\nIT ENDS NOW, THEN START THE NODE=ROOT\\nIT DOESN\\'\\'T END NOW THEN KEEP MOVING.\\n*/\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014225,
                "title": "explained-c-dynamic-programming-word-matching",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt\\'s a classic word matching problem, so `dynamic programming` is the first approach that came into my mind.\\n\\nAnd one important clue is that, assuming $s_i = concat(s_j, word)$ where word is a string in the dictionary. The minimum extra characters in $s_i$ and $s_j$ are euqal.\\n\\nTherefore, we can get a simple formula:\\n$dp[0] = 1$, when $s_0$ is not in the dictinoary \\n$dp[0] = 0$, when $s_0$ is  in the dictinoary \\n$dp[i] = min(dp[i-1]+1, dp[i-word.size()])$, otherwise\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nBecause we want to check if a character matches the end of any word in the dictionary, we first insert the word in `dictionary` into a hash map, which is an `unordered_map<char, string>`in C++, by their ending characters.\\n\\nThen iterate through the given string `s`. For index $i$, we check if there are some words matchs the end part of $s_i$. If it does, update the `dp[i]` based on whether it has less extra charaters in this case.\\n\\nLast of all, returns the last element in the `dp` array, which represents the minimum number of extra characters of the given `s`.\\n \\n# Complexity\\n- Time complexity: $O(n*m$), where n represents the length of `s` and m represents the total number of characters in dictionary\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n+m)$. Because we need a hashmap to store all the strings in `dictionary` and an extra array `dp` to record the minimum number of extra characters in $s_i$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<char, vector<string>> dict;\\n        for(const string& str: dictionary){\\n            dict[str.back()].push_back(str);\\n        } \\n\\n        vector<int> dp(s.length(), 0);\\n        dp[0] = 1; \\n        for(int i=0; i<s.length(); ++i){\\n            if(i) dp[i] = dp[i-1] + 1;\\n\\n            for(const string &word: dict[s[i]]){\\n                if(\\n                    (i >= (word.length()-1)) &&\\n                    (s.substr(i-word.length()+1, word.length()) == word)\\n                ){\\n                    if(i == (word.length() - 1)){\\n                         dp[i] = 0; \\n                    }\\n                    else dp[i] = min(dp[i], dp[i - word.length()]);\\n                }\\n            }\\n        }\\n\\n        return dp.back();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<char, vector<string>> dict;\\n        for(const string& str: dictionary){\\n            dict[str.back()].push_back(str);\\n        } \\n\\n        vector<int> dp(s.length(), 0);\\n        dp[0] = 1; \\n        for(int i=0; i<s.length(); ++i){\\n            if(i) dp[i] = dp[i-1] + 1;\\n\\n            for(const string &word: dict[s[i]]){\\n                if(\\n                    (i >= (word.length()-1)) &&\\n                    (s.substr(i-word.length()+1, word.length()) == word)\\n                ){\\n                    if(i == (word.length() - 1)){\\n                         dp[i] = 0; \\n                    }\\n                    else dp[i] = min(dp[i], dp[i - word.length()]);\\n                }\\n            }\\n        }\\n\\n        return dp.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014219,
                "title": "simple-c-solution-using-dp-1-d",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        s=\" \"+s;\\n        int n=s.length();\\n        vector<int> dp(n+1,INT_MAX);\\n        dp[0]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            dp[i]=1+dp[i-1];\\n            for(auto j:dictionary)\\n            {\\n                int len=j.length();\\n                int st=i-len+1;\\n                if(st<1)\\n                continue;\\n                if(s.substr(st,len)==j)\\n                dp[i]=min(dp[i],dp[st-1]);\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        s=\" \"+s;\\n        int n=s.length();\\n        vector<int> dp(n+1,INT_MAX);\\n        dp[0]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            dp[i]=1+dp[i-1];\\n            for(auto j:dictionary)\\n            {\\n                int len=j.length();\\n                int st=i-len+1;\\n                if(st<1)\\n                continue;\\n                if(s.substr(st,len)==j)\\n                dp[i]=min(dp[i],dp[st-1]);\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011914,
                "title": "java-memoization-explained",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* Form a string with each letter of s one by one\\n* If the word exists in the dictionary, then extra letters aren\\'t there, else the word thus formed is all extra\\n* Recurse for next index\\n* total extra letters = current extra + next extra\\n* Take a minimum of all such totals across all recursive states\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n**Method 1:** Brute force recursion. Gets TLE\\n```\\npublic int minExtraChar(String s, String[] dictionary) {\\n    return minExtraChar(s, new HashSet<>(Arrays.asList(dictionary)), s.length(), 0);\\n}\\n\\nprivate int minExtraChar(String s, Set<String> dictionary, int n, int i) {\\n    if (i == n)\\n        return 0;\\n\\n    var word = new StringBuilder();\\n    var minExtra = n;\\n\\n    for (var j = i; j < n; j++) {\\n        word.append(s.charAt(j));\\n        var extra = dictionary.contains(word.toString()) ? 0 : word.length();\\n        var nextExtra = minExtraChar(s, dictionary, n, j + 1, memo);\\n        minExtra = Math.min(minExtra, extra + nextExtra);\\n    }\\n\\n    return minExtra;\\n}\\n```\\n**Method 2:** Inject memoization in method 1\\n```\\npublic int minExtraChar(String s, String[] dictionary) {\\n    return minExtraChar(s, new HashSet<>(Arrays.asList(dictionary)), s.length(), 0, new HashMap<>());\\n}\\n\\nprivate int minExtraChar(String s, Set<String> dictionary, int n, int i, Map<Integer, Integer> memo) {\\n    if (i == n)\\n        return 0;\\n    if (memo.containsKey(i))\\n        return memo.get(i);\\n\\n    var word = new StringBuilder();\\n    var minExtra = n;\\n\\n    for (var j = i; j < n; j++) {\\n        word.append(s.charAt(j));\\n        var extra = dictionary.contains(word.toString()) ? 0 : word.length();\\n        var nextExtra = minExtraChar(s, dictionary, n, j + 1, memo);\\n        minExtra = Math.min(minExtra, extra + nextExtra);\\n    }\\n\\n    memo.put(i, minExtra);\\n    return minExtra;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int minExtraChar(String s, String[] dictionary) {\\n    return minExtraChar(s, new HashSet<>(Arrays.asList(dictionary)), s.length(), 0);\\n}\\n\\nprivate int minExtraChar(String s, Set<String> dictionary, int n, int i) {\\n    if (i == n)\\n        return 0;\\n\\n    var word = new StringBuilder();\\n    var minExtra = n;\\n\\n    for (var j = i; j < n; j++) {\\n        word.append(s.charAt(j));\\n        var extra = dictionary.contains(word.toString()) ? 0 : word.length();\\n        var nextExtra = minExtraChar(s, dictionary, n, j + 1, memo);\\n        minExtra = Math.min(minExtra, extra + nextExtra);\\n    }\\n\\n    return minExtra;\\n}\\n```\n```\\npublic int minExtraChar(String s, String[] dictionary) {\\n    return minExtraChar(s, new HashSet<>(Arrays.asList(dictionary)), s.length(), 0, new HashMap<>());\\n}\\n\\nprivate int minExtraChar(String s, Set<String> dictionary, int n, int i, Map<Integer, Integer> memo) {\\n    if (i == n)\\n        return 0;\\n    if (memo.containsKey(i))\\n        return memo.get(i);\\n\\n    var word = new StringBuilder();\\n    var minExtra = n;\\n\\n    for (var j = i; j < n; j++) {\\n        word.append(s.charAt(j));\\n        var extra = dictionary.contains(word.toString()) ? 0 : word.length();\\n        var nextExtra = minExtraChar(s, dictionary, n, j + 1, memo);\\n        minExtra = Math.min(minExtra, extra + nextExtra);\\n    }\\n\\n    memo.put(i, minExtra);\\n    return minExtra;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4011362,
                "title": "very-very-sexy-solution",
                "content": "# Very Very Sexy Solution\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helper(string &s, vector<string> &dict, int len, int start, vector<vector<int>> &dp){\\n        if(start == s.size()){\\n            return 0;\\n        }\\n        if(start + len > s.size()){\\n            return s.size() - start;\\n        }\\n        if(dp[start][len] != -1)    return dp[start][len];\\n        string str = s.substr(start,len);\\n        if(find(dict.begin(),dict.end(),str) != dict.end()){\\n            return dp[start][len] = min(helper(s,dict,1,start+len,dp), helper(s,dict,len+1,start,dp));\\n        }\\n        return dp[start][len] = min(len + helper(s,dict,1,start+len,dp), helper(s,dict,len+1,start,dp));\\n    }\\n    int minExtraChar(string s, vector<string>& dict) {\\n        int n = s.size();\\n        vector<vector<int>> dp(n+1, vector<int> (n+1,-1));\\n        return helper(s, dict, 1, 0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(string &s, vector<string> &dict, int len, int start, vector<vector<int>> &dp){\\n        if(start == s.size()){\\n            return 0;\\n        }\\n        if(start + len > s.size()){\\n            return s.size() - start;\\n        }\\n        if(dp[start][len] != -1)    return dp[start][len];\\n        string str = s.substr(start,len);\\n        if(find(dict.begin(),dict.end(),str) != dict.end()){\\n            return dp[start][len] = min(helper(s,dict,1,start+len,dp), helper(s,dict,len+1,start,dp));\\n        }\\n        return dp[start][len] = min(len + helper(s,dict,1,start+len,dp), helper(s,dict,len+1,start,dp));\\n    }\\n    int minExtraChar(string s, vector<string>& dict) {\\n        int n = s.size();\\n        vector<vector<int>> dp(n+1, vector<int> (n+1,-1));\\n        return helper(s, dict, 1, 0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010530,
                "title": "mcm-approach-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint solve(int start,int end,string&s,map<string,int>&mp,vector<vector<int>>&dp)\\n{\\n    \\n    string t=s.substr(start,end-start+1);\\n    if(mp[t]>0)\\n    {\\n        return t.size();\\n    }\\n    if(start>=end)\\n    return 0;\\n    if(dp[start][end]!=-1)\\n    return dp[start][end];\\n    int mx=0;\\n    for(int k=start;k<end;k++)\\n    {\\n        // mx=max(mx,solve(start,k,s,mp,dp)+solve(k+1,end,s,mp,dp));\\n        int t1,t2;\\n        if(dp[start][k]!=-1)\\n         t1=dp[start][k];\\n         else\\n         t1=solve(start,k,s,mp,dp);\\n\\n         if(dp[k+1][end]!=-1)\\n         t2=dp[k+1][end];\\n         else\\n         t2=solve(k+1,end,s,mp,dp);\\n         mx=max(mx,t1+t2);\\n         \\n        \\n    }\\n    return dp[start][end]=mx;\\n    \\n}   \\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        int n=s.size();\\n        map<string,int>mp;\\n        vector<vector<int>>dp(n,vector<int>(n,-1));\\n        for(auto it:dictionary)\\n        mp[it]++;\\n        int par_ans=solve(0,n-1,s,mp,dp);\\n        cout<<par_ans<<\" \";\\n        return n-par_ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint solve(int start,int end,string&s,map<string,int>&mp,vector<vector<int>>&dp)\\n{\\n    \\n    string t=s.substr(start,end-start+1);\\n    if(mp[t]>0)\\n    {\\n        return t.size();\\n    }\\n    if(start>=end)\\n    return 0;\\n    if(dp[start][end]!=-1)\\n    return dp[start][end];\\n    int mx=0;\\n    for(int k=start;k<end;k++)\\n    {\\n        // mx=max(mx,solve(start,k,s,mp,dp)+solve(k+1,end,s,mp,dp));\\n        int t1,t2;\\n        if(dp[start][k]!=-1)\\n         t1=dp[start][k];\\n         else\\n         t1=solve(start,k,s,mp,dp);\\n\\n         if(dp[k+1][end]!=-1)\\n         t2=dp[k+1][end];\\n         else\\n         t2=solve(k+1,end,s,mp,dp);\\n         mx=max(mx,t1+t2);\\n         \\n        \\n    }\\n    return dp[start][end]=mx;\\n    \\n}   \\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        int n=s.size();\\n        map<string,int>mp;\\n        vector<vector<int>>dp(n,vector<int>(n,-1));\\n        for(auto it:dictionary)\\n        mp[it]++;\\n        int par_ans=solve(0,n-1,s,mp,dp);\\n        cout<<par_ans<<\" \";\\n        return n-par_ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4010500,
                "title": "dp-c",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int dp[51];\\n    int f(int i, map<string,int> &m, string &s)\\n    {\\n        if(i>=s.size()) return 0;\\n        if(dp[i]!=-1) return dp[i];\\n        string str=\"\";\\n        int ans=51;\\n        for(int x=i; x<s.size(); x++)\\n        {\\n            str+=s[x];\\n            int cnt=str.size();\\n            if(m[str]) cnt=0;\\n            ans=min(cnt+f(x+1,m,s),ans);\\n        }\\n        return dp[i]=ans;\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) \\n    {\\n        map<string,int> m;\\n        for(auto word: dictionary) m[word]++;\\n        memset(dp,-1,sizeof(dp));\\n        return f(0,m,s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int dp[51];\\n    int f(int i, map<string,int> &m, string &s)\\n    {\\n        if(i>=s.size()) return 0;\\n        if(dp[i]!=-1) return dp[i];\\n        string str=\"\";\\n        int ans=51;\\n        for(int x=i; x<s.size(); x++)\\n        {\\n            str+=s[x];\\n            int cnt=str.size();\\n            if(m[str]) cnt=0;\\n            ans=min(cnt+f(x+1,m,s),ans);\\n        }\\n        return dp[i]=ans;\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) \\n    {\\n        map<string,int> m;\\n        for(auto word: dictionary) m[word]++;\\n        memset(dp,-1,sizeof(dp));\\n        return f(0,m,s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010308,
                "title": "java-recursive-memo-tabulation-approaches-similar-to-word-break",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        return tabulationApproach(s, dictionary);\\n    }\\n\\n    private int recursiveApproach(String s, String[] dictionary) {\\n        return recursiveApproach(s, dictionary, 0);\\n    }\\n    private int recursiveApproach(String s, String[] dictionary, int i) {\\n        int m = s.length();\\n        if(i == m) return 0;\\n\\n        int skipLetter = recursiveApproach(s, dictionary, i + 1) + 1;\\n\\n        int min = skipLetter;\\n        for(String word : dictionary) {\\n            int n = word.length();\\n\\n            if(s.startsWith(word, i)) {\\n                min = Math.min(min, recursiveApproach(s, dictionary, i + n));\\n            }\\n        }\\n\\n        return min;\\n    }\\n\\n    private int memoApproach(String s, String[] dictionary) {\\n        int m = s.length();\\n        int[] dp = IntStream.generate(() -> -1).limit(m).toArray();\\n        return memoApproach(s, dictionary, 0, dp);\\n    }\\n    private int memoApproach(String s, String[] dictionary, int i, int[] dp) {\\n        int m = s.length();\\n        if(i == m) return 0;\\n        return dp[i] = dp[i] != -1 ? dp[i] : Arrays.stream(dictionary).filter(word -> s.startsWith(word, i)).mapToInt(String::length).map(n -> memoApproach(s, dictionary, i + n, dp)).reduce(memoApproach(s, dictionary, i + 1, dp) + 1, (min, step) -> step < min ? step : min);\\n    }\\n\\n    private int tabulationApproach(String s, String[] dictionary) {\\n        int m = s.length();\\n\\n        int[] dp = new int[m + 1];\\n\\n        for(int i = m - 1; i >= 0; i--) {\\n            dp[i] = dp[i + 1] + 1;\\n\\n            int finalI = i;\\n            Arrays.stream(dictionary).filter(word -> s.startsWith(word, finalI)).mapToInt(String::length).map(n -> dp[finalI + n]).forEach(prev -> dp[finalI] = Math.min(dp[finalI], prev));\\n        }\\n\\n        return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        return tabulationApproach(s, dictionary);\\n    }\\n\\n    private int recursiveApproach(String s, String[] dictionary) {\\n        return recursiveApproach(s, dictionary, 0);\\n    }\\n    private int recursiveApproach(String s, String[] dictionary, int i) {\\n        int m = s.length();\\n        if(i == m) return 0;\\n\\n        int skipLetter = recursiveApproach(s, dictionary, i + 1) + 1;\\n\\n        int min = skipLetter;\\n        for(String word : dictionary) {\\n            int n = word.length();\\n\\n            if(s.startsWith(word, i)) {\\n                min = Math.min(min, recursiveApproach(s, dictionary, i + n));\\n            }\\n        }\\n\\n        return min;\\n    }\\n\\n    private int memoApproach(String s, String[] dictionary) {\\n        int m = s.length();\\n        int[] dp = IntStream.generate(() -> -1).limit(m).toArray();\\n        return memoApproach(s, dictionary, 0, dp);\\n    }\\n    private int memoApproach(String s, String[] dictionary, int i, int[] dp) {\\n        int m = s.length();\\n        if(i == m) return 0;\\n        return dp[i] = dp[i] != -1 ? dp[i] : Arrays.stream(dictionary).filter(word -> s.startsWith(word, i)).mapToInt(String::length).map(n -> memoApproach(s, dictionary, i + n, dp)).reduce(memoApproach(s, dictionary, i + 1, dp) + 1, (min, step) -> step < min ? step : min);\\n    }\\n\\n    private int tabulationApproach(String s, String[] dictionary) {\\n        int m = s.length();\\n\\n        int[] dp = new int[m + 1];\\n\\n        for(int i = m - 1; i >= 0; i--) {\\n            dp[i] = dp[i + 1] + 1;\\n\\n            int finalI = i;\\n            Arrays.stream(dictionary).filter(word -> s.startsWith(word, finalI)).mapToInt(String::length).map(n -> dp[finalI + n]).forEach(prev -> dp[finalI] = Math.min(dp[finalI], prev));\\n        }\\n\\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009346,
                "title": "java-easy-to-understand-recursion-memoization-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    Set<String>set;\\n    int dp[];\\n    private int recur(String s, int idx, int n){\\n        if(idx>=n)\\n            return 0;\\n        \\n        if(dp[idx]!=-1) return dp[idx];\\n\\n        String curStr=\"\";\\n        int minExtra=n;\\n\\n        for(int i=idx;i<n;i++){\\n            curStr+=s.charAt(i);\\n            int cur=(set.contains(curStr))?0:curStr.length();\\n            int next=recur(s,i+1,n);\\n            int total=cur+next;\\n            minExtra=Math.min(minExtra, total);\\n        }\\n        return dp[idx]=minExtra;\\n\\n    }\\n    public int minExtraChar(String s, String[] dictionary) {\\n        set=new HashSet<>();\\n        dp=new int[51];\\n        Arrays.fill(dp,-1);\\n        for(String str:dictionary){\\n            set.add(str);\\n        }\\n        int n=s.length();\\n        return recur(s,0,n);\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Set<String>set;\\n    int dp[];\\n    private int recur(String s, int idx, int n){\\n        if(idx>=n)\\n            return 0;\\n        \\n        if(dp[idx]!=-1) return dp[idx];\\n\\n        String curStr=\"\";\\n        int minExtra=n;\\n\\n        for(int i=idx;i<n;i++){\\n            curStr+=s.charAt(i);\\n            int cur=(set.contains(curStr))?0:curStr.length();\\n            int next=recur(s,i+1,n);\\n            int total=cur+next;\\n            minExtra=Math.min(minExtra, total);\\n        }\\n        return dp[idx]=minExtra;\\n\\n    }\\n    public int minExtraChar(String s, String[] dictionary) {\\n        set=new HashSet<>();\\n        dp=new int[51];\\n        Arrays.fill(dp,-1);\\n        for(String str:dictionary){\\n            set.add(str);\\n        }\\n        int n=s.length();\\n        return recur(s,0,n);\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005366,
                "title": "simple-recursion-dp-can-solve-this-prob",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int check(String s,int []dp,Set<String>set,int idx){\\n        if(idx>=s.length())return 0;\\n        if(dp[idx]!=-1)return dp[idx];\\n        String curr=\"\";\\n        int ans=s.length();\\n        for(int i=idx;i<s.length();i++){\\n            curr+=s.charAt(i);\\n            int count=(set.contains(curr)?0:curr.length())+check(s,dp,set,i+1);\\n            ans=Math.min(count,ans);\\n        }\\n        return dp[idx]=ans;\\n    }\\n    public int minExtraChar(String s, String[] dictionary) {\\n        int []dp=new int [s.length()];\\n        for(int i=0;i<s.length();i++){\\n            dp[i]=-1;\\n        }\\n        Set<String>set=new HashSet<>();\\n        for(String str :dictionary)set.add(str);\\n        return check(s,dp,set,0);\\n\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int check(String s,int []dp,Set<String>set,int idx){\\n        if(idx>=s.length())return 0;\\n        if(dp[idx]!=-1)return dp[idx];\\n        String curr=\"\";\\n        int ans=s.length();\\n        for(int i=idx;i<s.length();i++){\\n            curr+=s.charAt(i);\\n            int count=(set.contains(curr)?0:curr.length())+check(s,dp,set,i+1);\\n            ans=Math.min(count,ans);\\n        }\\n        return dp[idx]=ans;\\n    }\\n    public int minExtraChar(String s, String[] dictionary) {\\n        int []dp=new int [s.length()];\\n        for(int i=0;i<s.length();i++){\\n            dp[i]=-1;\\n        }\\n        Set<String>set=new HashSet<>();\\n        for(String str :dictionary)set.add(str);\\n        return check(s,dp,set,0);\\n\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4004227,
                "title": "java-3-approaches-recursion-memoization-tabulation-easy-to-understand",
                "content": "Recursion:- TLE\\n```\\nclass Solution {\\n    private int helper(int idx, String s, HashSet<String> set) {\\n        if(idx >= s.length())  return 0;\\n        String curStr = \"\";\\n        int ans = s.length() ;\\n        for(int i = idx; i<s.length(); i++) {\\n            curStr += s.charAt(i);\\n            int count = (set.contains(curStr) ? 0 : curStr.length()) + helper(i+1, s, set);\\n            ans = Math.min(ans, count);\\n        }\\n        return ans;       \\n    }\\n\\n\\n    public int minExtraChar(String s, String[] dictionary) {\\n        HashSet<String> set = new HashSet<>();\\n        for(String str : dictionary) set.add(str);\\n        return helper(0, s, set);\\n    }\\n}\\n```\\nMemoization:- Accepted\\n```\\nclass Solution {\\n    private int helper(int idx, String s, HashSet<String> set, int[] dp) {\\n        if(idx >= s.length())  return 0;\\n        if(dp[idx] != -1)  return dp[idx];\\n        String curStr = \"\";\\n        int ans = s.length() ;\\n        for(int i = idx; i<s.length(); i++) {\\n            curStr += s.charAt(i);\\n            int count = (set.contains(curStr) ? 0 : curStr.length()) + helper(i+1, s, set, dp);\\n            ans = Math.min(ans, count);\\n        }\\n        return dp[idx] = ans;       \\n    }\\n    public int minExtraChar(String s, String[] dictionary) {\\n        HashSet<String> set = new HashSet<>();\\n        int[] dp = new int[s.length()];\\n        Arrays.fill(dp, -1);\\n        for(String str : dictionary) set.add(str);\\n        return helper(0, s, set, dp);\\n    }\\n}\\n```\\nTabulation:- Accepted\\n```\\nclass Solution {\\n    private int helper(int idx, String s, HashSet<String> set, int[] dp) {\\n        if(idx >= s.length())  return 0;\\n        if(dp[idx] != -1)  return dp[idx];\\n        String curStr = \"\";\\n        int ans = s.length() ;\\n        for(int i = idx; i<s.length(); i++) {\\n            curStr += s.charAt(i);\\n            int count = (set.contains(curStr) ? 0 : curStr.length()) + helper(i+1, s, set, dp);\\n            ans = Math.min(ans, count);\\n        }\\n        return dp[idx] = ans;       \\n    }\\n    public int minExtraChar(String s, String[] dictionary) {\\n        HashSet<String> set = new HashSet<>();\\n         for(String str : dictionary) set.add(str);\\n        int[] dp = new int[s.length()+1];\\n        dp[s.length()] = 0;\\n\\n        for(int idx = s.length()-1; idx >= 0 ; idx--) {\\n            String curStr = \"\";\\n            int ans = s.length() ;\\n            for(int i = idx; i<s.length(); i++) {\\n                curStr += s.charAt(i);\\n                int count = (set.contains(curStr) ? 0 : curStr.length()) + dp[i+1];\\n                ans = Math.min(ans, count);\\n            }\\n            dp[idx] = ans;\\n        }\\n       \\n        return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int helper(int idx, String s, HashSet<String> set) {\\n        if(idx >= s.length())  return 0;\\n        String curStr = \"\";\\n        int ans = s.length() ;\\n        for(int i = idx; i<s.length(); i++) {\\n            curStr += s.charAt(i);\\n            int count = (set.contains(curStr) ? 0 : curStr.length()) + helper(i+1, s, set);\\n            ans = Math.min(ans, count);\\n        }\\n        return ans;       \\n    }\\n\\n\\n    public int minExtraChar(String s, String[] dictionary) {\\n        HashSet<String> set = new HashSet<>();\\n        for(String str : dictionary) set.add(str);\\n        return helper(0, s, set);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private int helper(int idx, String s, HashSet<String> set, int[] dp) {\\n        if(idx >= s.length())  return 0;\\n        if(dp[idx] != -1)  return dp[idx];\\n        String curStr = \"\";\\n        int ans = s.length() ;\\n        for(int i = idx; i<s.length(); i++) {\\n            curStr += s.charAt(i);\\n            int count = (set.contains(curStr) ? 0 : curStr.length()) + helper(i+1, s, set, dp);\\n            ans = Math.min(ans, count);\\n        }\\n        return dp[idx] = ans;       \\n    }\\n    public int minExtraChar(String s, String[] dictionary) {\\n        HashSet<String> set = new HashSet<>();\\n        int[] dp = new int[s.length()];\\n        Arrays.fill(dp, -1);\\n        for(String str : dictionary) set.add(str);\\n        return helper(0, s, set, dp);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private int helper(int idx, String s, HashSet<String> set, int[] dp) {\\n        if(idx >= s.length())  return 0;\\n        if(dp[idx] != -1)  return dp[idx];\\n        String curStr = \"\";\\n        int ans = s.length() ;\\n        for(int i = idx; i<s.length(); i++) {\\n            curStr += s.charAt(i);\\n            int count = (set.contains(curStr) ? 0 : curStr.length()) + helper(i+1, s, set, dp);\\n            ans = Math.min(ans, count);\\n        }\\n        return dp[idx] = ans;       \\n    }\\n    public int minExtraChar(String s, String[] dictionary) {\\n        HashSet<String> set = new HashSet<>();\\n         for(String str : dictionary) set.add(str);\\n        int[] dp = new int[s.length()+1];\\n        dp[s.length()] = 0;\\n\\n        for(int idx = s.length()-1; idx >= 0 ; idx--) {\\n            String curStr = \"\";\\n            int ans = s.length() ;\\n            for(int i = idx; i<s.length(); i++) {\\n                curStr += s.charAt(i);\\n                int count = (set.contains(curStr) ? 0 : curStr.length()) + dp[i+1];\\n                ans = Math.min(ans, count);\\n            }\\n            dp[idx] = ans;\\n        }\\n       \\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003696,
                "title": "extending-word-break-question-using-dp",
                "content": "# Intuition\\nExtension of Word Break\\n\\n\\n# Approach\\n1.  dp = [51] * (len(s) + 1)  since 50 char only so keep this no highest\\n2. empty string has 0 extra char\\n3. new substring will have  old substring +1 as the len of extra char (worst case)\\n4. now loop through dict check the match, and change the dp[i]; \\nNote: Mostly a string is matches we do at i . dp[i-1]+1 or dp[i] >= dp[i - len(word)] # i- len(word)at the staring of the word\\n \\n# Complexity\\n- Time complexity:\\nO(N * M) [N is the length of the input string s, and M is the total number of characters in the dictionary.]\\n\\n- Space complexity:\\nO(N + M) [N is the length of the input string s, and M is the total number of characters in the dictionary.]\\n\\n# Code\\n```\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n   \\n        dictionary_set = set(dictionary)\\n        dp = [51] * (len(s) + 1) #since len(s)<=50\\n        dp[0] = 0  # No extra characters for an empty string\\n        \\n        for i in range(1, len(s) + 1):\\n            dp[i]=dp[i-1]+1\\n            for word in dictionary_set:\\n                if i - len(word) >= 0 and s[i - len(word):i] == word:\\n                    dp[i] = min(dp[i], dp[i - len(word)] )\\n        \\n        # The final result is the minimum number of extra characters at the end of the string\\n        return dp[-1]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n   \\n        dictionary_set = set(dictionary)\\n        dp = [51] * (len(s) + 1) #since len(s)<=50\\n        dp[0] = 0  # No extra characters for an empty string\\n        \\n        for i in range(1, len(s) + 1):\\n            dp[i]=dp[i-1]+1\\n            for word in dictionary_set:\\n                if i - len(word) >= 0 and s[i - len(word):i] == word:\\n                    dp[i] = min(dp[i], dp[i - len(word)] )\\n        \\n        # The final result is the minimum number of extra characters at the end of the string\\n        return dp[-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003343,
                "title": "sharing-my-java-solution-dp-memory-trie",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        Dict root = new Dict(\\'0\\');\\n        for(String d: dictionary) {\\n            addWord(root, d);\\n        }\\n        Integer[] dp = new Integer[s.length()];\\n        return helper(dp, s, 0, root);\\n    }\\n\\n    private int helper(Integer[] dp, String s, int index, Dict root) {\\n        if(index>=s.length()) return 0;\\n        if(dp[index]!=null) return dp[index];\\n        char c = s.charAt(index);\\n        if(root.children[c-\\'a\\']==null) return 1+helper(dp, s, index+1, root);\\n        Dict temp = root;\\n        int ret = s.length()-index;\\n        for(int i = index;i<s.length();i++) {\\n            c = s.charAt(i);\\n            if(temp.children[c-\\'a\\']==null) {\\n                ret = Math.min(ret, i-index+1 + helper(dp, s, i+1, root));\\n                break;\\n            }\\n            ret = Math.min(ret, i-index+1 + helper(dp, s, i+1, root));\\n            temp = temp.children[c-\\'a\\'];\\n            if(temp.isWord) {\\n                ret = Math.min(ret, helper(dp, s, i+1, root));\\n            }\\n        }\\n        dp[index] = ret;\\n        return ret;\\n    }\\n\\n    private void addWord(Dict root, String word) {\\n        Dict temp = root;\\n        for(char c: word.toCharArray()) {\\n            if(temp.children[c-\\'a\\']==null) {\\n                temp.children[c-\\'a\\'] = new Dict(c);\\n            }\\n            temp = temp.children[c-\\'a\\'];\\n        }\\n        temp.isWord = true;\\n    }\\n}\\n\\nclass Dict {\\n    boolean isWord;\\n    char c;\\n    Dict[] children = new Dict[26];\\n    public Dict(char chr) {\\n        this.c = chr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        Dict root = new Dict(\\'0\\');\\n        for(String d: dictionary) {\\n            addWord(root, d);\\n        }\\n        Integer[] dp = new Integer[s.length()];\\n        return helper(dp, s, 0, root);\\n    }\\n\\n    private int helper(Integer[] dp, String s, int index, Dict root) {\\n        if(index>=s.length()) return 0;\\n        if(dp[index]!=null) return dp[index];\\n        char c = s.charAt(index);\\n        if(root.children[c-\\'a\\']==null) return 1+helper(dp, s, index+1, root);\\n        Dict temp = root;\\n        int ret = s.length()-index;\\n        for(int i = index;i<s.length();i++) {\\n            c = s.charAt(i);\\n            if(temp.children[c-\\'a\\']==null) {\\n                ret = Math.min(ret, i-index+1 + helper(dp, s, i+1, root));\\n                break;\\n            }\\n            ret = Math.min(ret, i-index+1 + helper(dp, s, i+1, root));\\n            temp = temp.children[c-\\'a\\'];\\n            if(temp.isWord) {\\n                ret = Math.min(ret, helper(dp, s, i+1, root));\\n            }\\n        }\\n        dp[index] = ret;\\n        return ret;\\n    }\\n\\n    private void addWord(Dict root, String word) {\\n        Dict temp = root;\\n        for(char c: word.toCharArray()) {\\n            if(temp.children[c-\\'a\\']==null) {\\n                temp.children[c-\\'a\\'] = new Dict(c);\\n            }\\n            temp = temp.children[c-\\'a\\'];\\n        }\\n        temp.isWord = true;\\n    }\\n}\\n\\nclass Dict {\\n    boolean isWord;\\n    char c;\\n    Dict[] children = new Dict[26];\\n    public Dict(char chr) {\\n        this.c = chr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002695,
                "title": "python-dynamic-programming",
                "content": "# Intuition\\nThe goal of this problem is to find the minimum number of characters that remain in a string after removing words from that string using a dictionary. \\n\\nIf the dictionary words don\\'t overlap, the solution is easy. In the example\\n `\\'leetscode\\'`, the dictionary `[\\'leet\\', \\'code\\']` removes all letters save for `s`. Therefore the answer is 1. \\n\\nIf we make a toy example, such as `changer` with dictionary `[\\'chan\\',\\'hanger\\']`, if `chan` is stricken from `changer`, then remaining string no longer contains `hanger`. So-`hanger` must be removed because it removes more letters leaving fewer characters in the string, resulting in an answer `1`. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy approach is dynamic programming. We get the length of the string. Turn the dictionary (which is really a list of words) into a set because a set has `O(1)` lookup time. We initialize the array to store the up-to-date minimum number of characters with each iteration. \\n\\nIterate over the whole list of characters in the input string, `s`. Start at `index=1` because the memo array is one item longer than the length of the string, in order to initialize the search at `0`. \\n\\nIf the current character at step `i` is not found in any dictionary word, then the count of letters goes up and `dp[i] = dp[i-1] + 1`. The list `dp` at index `i` adds `1` to the entry previous index `i-1`. \\n\\nNext, we check if the the current letter at `i` is part of a word in the dictionary. Loop for all the possibilities from `1` to `i+1` exclusive. Let the variable be `ell`, and the max value of `ell=i`. The nested loop looks back on the visited characters to see if a new word may be found. \\n\\nWith the loop, we can split the string and check the dictionary words. The slice is `s[i-ell:i]`, where `ell` is incrementing with in the nested loop. Note the lowest `ell` can be is 1, so the slice always has a length of at least 1. \\n\\nIf a substring matches a word in the dictionary, update the list `dp[i]` at index `i` with the minimum of either the current character count, which has already been incremented by 1 to accomodate the current character, or `dp[i-ell]`. The list `dp` holds in memory the minimum number of characters at every index of the input string. If we can remove a word because the substring is in the dictionary, we do not need to add a character to `dp`, nor do we need to include any characters included in the word. We do need to take the minimum of the current `dp[i]` versus `dp[i-ell]` for the problem of **overlapping words**. It may be that `dp[i]` is smaller than `dp[i-ell]` despite the word being found in the dictionary. \\n\\nIn the end, return the last entry in the list `dp`. The last entry accomodates the entire string and has minimized the number of characters. \\n\\n\\n# Complexity\\n- Time complexity: 212 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 16.24 MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        n = len(s)\\n        dictionary_set = set(dictionary)\\n        dp = [0] * (len(s) + 1)\\n\\n        for i in range(1, len(s) + 1):\\n            dp[i] = dp[i - 1] + 1\\n            for ell in range(1, i+1):\\n                if s[i-ell:i] in dictionary_set:\\n                    dp[i] = min(dp[i], dp[i-ell])\\n                     \\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        n = len(s)\\n        dictionary_set = set(dictionary)\\n        dp = [0] * (len(s) + 1)\\n\\n        for i in range(1, len(s) + 1):\\n            dp[i] = dp[i - 1] + 1\\n            for ell in range(1, i+1):\\n                if s[i-ell:i] in dictionary_set:\\n                    dp[i] = min(dp[i], dp[i-ell])\\n                     \\n        return dp[-1]\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2040093,
                "content": [
                    {
                        "username": "joshczipo",
                        "content": "2028 test casts buddy touch grass"
                    },
                    {
                        "username": "sergei99",
                        "content": "This separates the men from the boys.\\nLow amount of test data => any shoddy job runs at 1 ms.\\nHigh amount of test data => we see a dispersion."
                    },
                    {
                        "username": "ares22121999",
                        "content": "https://leetcode.com/problems/bitwise-and-of-numbers-range/ this question have 8269 cases XD"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Typical those who are always ready to stay in the office upto next day, cuz they don\\'t have any hobbies.\\n\\nNow I know they stay in the office to write 2028 testcases for leetcode. \\nThe badge \\'Stapler of the month\\' is unlocked. jajajaja"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Feels good to be able to solve these problems, atleast with the most basic method considering there was a time when I couldn\\'t figure out how to even start approaching the problem. Keep on keeping on guys!"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@mohantysatyajit57](/mohantysatyajit57) Dynamic programming, this is a very common type of problem."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@mohantysatyajit57](/mohantysatyajit57) I\\'ve been solving the daily problems for 175 days now. Obviously I couldn\\'t figure out most problems in the beginning. But after lookin at and understanding solutions day after day I am now able to solve many problems by myself. I occasionally solve problems people mention being similar to the current one. I don\\'t stick to topics because in an interview, you really won\\'t be informed of the topics of the questions you\\'ll be solving. "
                    },
                    {
                        "username": "mohantysatyajit57",
                        "content": "What topics did you practice in order to figure out what this problem was about?\\n"
                    },
                    {
                        "username": "c4tdog",
                        "content": "test\\n\"dwmodizxvvbosxxw\"\\n[\"ox\",\"lb\",\"diz\",\"gu\",\"v\",\"ksv\",\"o\",\"nuq\",\"r\",\"txhe\",\"e\",\"wmo\",\"cehy\",\"tskz\",\"ds\",\"kzbu\"]\\nhow come the answer is 7? I can only see this way (with 8 chars left)\\nd <b>wmo</b> <b>diz</b> xv <b>v</b> b <b>o</b> sxxw"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just split the input string to halves and execute each half separately. Take the failing half and repeat the procedure. At 4-5 chars you will be able to see the problem instantly. If not, repeat the same thing with the dictionary array."
                    },
                    {
                        "username": "just_ayush",
                        "content": "v is present two times"
                    },
                    {
                        "username": "sakshi_17",
                        "content": "v is deleted two times. So for input - [eev] and dictionary [e] , dict contains only distinct words but all occurrences of word can be deleted."
                    },
                    {
                        "username": "user8307St",
                        "content": "d **wmo** **diz** x **v** **v** b **o** sxxw !"
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@qutequbit](/qutequbit) leetcode is not considered for leetscode. \"leet\" is a different word in dictionary and \"code\" is a different word in the dictionary and \"leetcode\" is broken into \"leet\" and \"code\" which is then considered as the two words in the dictionary."
                    },
                    {
                        "username": "Qnide",
                        "content": "Sort the dictionary in descending order def len"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@6leet](/6leet) how can one not see that. feeling dumb after seeing your comment. thank you."
                    },
                    {
                        "username": "Baymax_",
                        "content": "[@_Anurag_Singhal_](/_Anurag_Singhal_) \"non-overlapping substrings\" is way different from \"can use  dictionary words multiple times\" (even though it is not mentioned)"
                    },
                    {
                        "username": "caleb-mabry",
                        "content": "[@6leet](/6leet) You have no idea how long I have been trying to figure out what was going on. Thanks for this!"
                    },
                    {
                        "username": "_Anurag_Singhal_",
                        "content": "but the questions says non-overlapping substrings!"
                    },
                    {
                        "username": "6leet",
                        "content": "there are two v"
                    },
                    {
                        "username": "anwendeng",
                        "content": "I like DP much more than bit counting.\nAfter usual DP can try DP+Trie! more challenging."
                    },
                    {
                        "username": "sergei99",
                        "content": "Tries ruthlessly beat any other collections here. I see the execution time top is all involving tries.\\nSpent 4 hours debugging my trie and didn\\'t regret: 40 ms, absolute top for the time being, for the first submission.\\nStill need to improve its memory consumption though. Went a simple way to avoid costly node reallocations, it helped to an extent in another task, but here it takes 76 Mb vs 64 Mb of an STL hash set... what a shame."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "[@anwendeng](/anwendeng)  Thanks! Will give it try for sure!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@akash_vannam](/akash_vannam) Trie is also hard for me. My DP is however a little bit different from other. I don't use hash table. Try a double for loop , i varies over the indexes of s , j varies over indexes of dictionary. Inside the loop  use  just substr, find, rfind in C++ string.  I hope that it is useful."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "I initially thought about tries first, then saw that greedy wouldn\\'t work here. Then, tried dp but wasn\\'t able to write recursion. I struggle alot to come up with an alternative approach when an approach intuitively comes up and I am not able to fully complete it. Any tips? I always see you in daily challenges discussion aceing every question, when I get stuck your hints help me alot."
                    },
                    {
                        "username": "sheshnathverma",
                        "content": "I think description should mention, we are allowed to reuse the dictionary word multiple time.\\n\\nIt took lot of time to realize :(\\n\\nTest Case: \"leetsleetscode\", [\"leets\", \"code\"]"
                    },
                    {
                        "username": "NagaNikhil",
                        "content": "Thanks for pointing it out"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[139. Word Break] similar problem  (https://leetcode.com/problems/word-break/)"
                    },
                    {
                        "username": "user3429v",
                        "content": "this one[2707] is a little bit harder"
                    },
                    {
                        "username": "aman1320",
                        "content": "(Time Limit Exceeded )Test Case 2024/2024\\ns=\\n\\nwho the hell putted this in the test case???????"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "It means your time limit exceeded, don\\'t check that testcase, as that one isn\\'t a testcase. You reduce the time. The overall time probably exceeds the time limit."
                    },
                    {
                        "username": "aquaman55",
                        "content": "PUTTED must be a golfer "
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Hint:\n\nWe know that substring of `s` must exist in dictionary to be able to break. The substring may start from index 0. If it doesn't then the index 0 is the leftover and so on.\n\nMore generally, for every substring there are a 2 choices:\n\n1) this substring is an leftover then `len(substring) + mininmumLeftOver(rest of the string)`\n 2) this substring is part of a substring of string from dictionary, then `0(no leftover) + mininmumLeftOver(rest of the string)`. \n\nWe shall pick the minimum from these 2 choices."
                    },
                    {
                        "username": "Beorn",
                        "content": "Knapsack  problem"
                    },
                    {
                        "username": "shivansh_07",
                        "content": "Like this take and not_take it is similar to knapsack\\n\\nclass Solution {\\npublic:\\nint mini = INT_MAX;\\n    int func(int index, string s , unordered_map<string ,  int> &mp , vector<int> &dp){\\n\\n        if(index == s.size()) return 0;\\n\\n        if(dp[index]!=-1) return dp[index];\\n        \\n        int not_take = 1 + func(index + 1 , s ,mp,dp);\\n        int take = INT_MAX;\\n        for(int i = index; i < s.size();i++){\\n            string t1 = s.substr(index , i - index + 1);\\n            \\n            if(mp.find(t1)!=mp.end()) take = min(take , 0+ func(i+1 , s , mp,dp));\\n            \\n        }\\n\\n        return dp[index] = min(take , not_take);\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<string,int> mp;\\n\\n        vector<int> dp(s.size() + 1 , -1);\\n        for(auto it : dictionary) mp[it]++;\\n\\n        return func(0 , s , mp,dp);\\n    }\\n};"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "how\\n"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "I\\'ve stuck on 1988 test case:\\ns = \"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\ndictionary = \"\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"\"\\n\\nOutput = 14\\nExpected = 15\\n\\nWhy 15 is expected? By the end, my solution produces the following string: \"hlwjeastjqwkof\". Isn\\'t it correct?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@desuraj110](/desuraj110) because smaller data set makes it easier to locate the bug in the code."
                    },
                    {
                        "username": "desuraj110",
                        "content": "same case i stuck too"
                    },
                    {
                        "username": "desuraj110",
                        "content": "[@sergei99](/sergei99) why split in halves ?? "
                    },
                    {
                        "username": "sans_102",
                        "content": "\"hlwxjeastjqwkof\" this is the string left after doing the operations. there is x between w and j (4th place). string is of length 15."
                    },
                    {
                        "username": "sergei99",
                        "content": "Split the input string to halves and execute each half separately. Take the failing half and repeat the procedure. At 4-5 chars you will be able to see the problem instantly. If not, repeat the same thing with the dictionary array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\n```\nazvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\nazv\n   zul\n    u\n          wobow\n            b\n               i\n                 i\n                  yeb\n                    b\n                        kecv\n                                 maqnv\n                                    n\n                                      na\n                                      n\n                                         maqnv\n                                            n\n```\nWith `15` extra characters you can produce this:\n```\nazv zul _ _ _ _ wobow i _ i yeb _ _ _ kecv _ _ _ _ _ maqnv na _ maqnv _\n```"
                    },
                    {
                        "username": "Alexander238",
                        "content": "Yep same, \"hlwjeastjqwkof\" is the word I get with Output 14 and expected 15..."
                    },
                    {
                        "username": "Labib2003",
                        "content": "same case my friend, tried to solve it as a greedy problem "
                    },
                    {
                        "username": "supperr-coder",
                        "content": "got the same output: with the exact same string too: \"hlwjeastjqwkof\" would appreciate someone\\'s help"
                    }
                ]
            },
            {
                "id": 2040163,
                "content": [
                    {
                        "username": "joshczipo",
                        "content": "2028 test casts buddy touch grass"
                    },
                    {
                        "username": "sergei99",
                        "content": "This separates the men from the boys.\\nLow amount of test data => any shoddy job runs at 1 ms.\\nHigh amount of test data => we see a dispersion."
                    },
                    {
                        "username": "ares22121999",
                        "content": "https://leetcode.com/problems/bitwise-and-of-numbers-range/ this question have 8269 cases XD"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Typical those who are always ready to stay in the office upto next day, cuz they don\\'t have any hobbies.\\n\\nNow I know they stay in the office to write 2028 testcases for leetcode. \\nThe badge \\'Stapler of the month\\' is unlocked. jajajaja"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Feels good to be able to solve these problems, atleast with the most basic method considering there was a time when I couldn\\'t figure out how to even start approaching the problem. Keep on keeping on guys!"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@mohantysatyajit57](/mohantysatyajit57) Dynamic programming, this is a very common type of problem."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@mohantysatyajit57](/mohantysatyajit57) I\\'ve been solving the daily problems for 175 days now. Obviously I couldn\\'t figure out most problems in the beginning. But after lookin at and understanding solutions day after day I am now able to solve many problems by myself. I occasionally solve problems people mention being similar to the current one. I don\\'t stick to topics because in an interview, you really won\\'t be informed of the topics of the questions you\\'ll be solving. "
                    },
                    {
                        "username": "mohantysatyajit57",
                        "content": "What topics did you practice in order to figure out what this problem was about?\\n"
                    },
                    {
                        "username": "c4tdog",
                        "content": "test\\n\"dwmodizxvvbosxxw\"\\n[\"ox\",\"lb\",\"diz\",\"gu\",\"v\",\"ksv\",\"o\",\"nuq\",\"r\",\"txhe\",\"e\",\"wmo\",\"cehy\",\"tskz\",\"ds\",\"kzbu\"]\\nhow come the answer is 7? I can only see this way (with 8 chars left)\\nd <b>wmo</b> <b>diz</b> xv <b>v</b> b <b>o</b> sxxw"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just split the input string to halves and execute each half separately. Take the failing half and repeat the procedure. At 4-5 chars you will be able to see the problem instantly. If not, repeat the same thing with the dictionary array."
                    },
                    {
                        "username": "just_ayush",
                        "content": "v is present two times"
                    },
                    {
                        "username": "sakshi_17",
                        "content": "v is deleted two times. So for input - [eev] and dictionary [e] , dict contains only distinct words but all occurrences of word can be deleted."
                    },
                    {
                        "username": "user8307St",
                        "content": "d **wmo** **diz** x **v** **v** b **o** sxxw !"
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@qutequbit](/qutequbit) leetcode is not considered for leetscode. \"leet\" is a different word in dictionary and \"code\" is a different word in the dictionary and \"leetcode\" is broken into \"leet\" and \"code\" which is then considered as the two words in the dictionary."
                    },
                    {
                        "username": "Qnide",
                        "content": "Sort the dictionary in descending order def len"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@6leet](/6leet) how can one not see that. feeling dumb after seeing your comment. thank you."
                    },
                    {
                        "username": "Baymax_",
                        "content": "[@_Anurag_Singhal_](/_Anurag_Singhal_) \"non-overlapping substrings\" is way different from \"can use  dictionary words multiple times\" (even though it is not mentioned)"
                    },
                    {
                        "username": "caleb-mabry",
                        "content": "[@6leet](/6leet) You have no idea how long I have been trying to figure out what was going on. Thanks for this!"
                    },
                    {
                        "username": "_Anurag_Singhal_",
                        "content": "but the questions says non-overlapping substrings!"
                    },
                    {
                        "username": "6leet",
                        "content": "there are two v"
                    },
                    {
                        "username": "anwendeng",
                        "content": "I like DP much more than bit counting.\nAfter usual DP can try DP+Trie! more challenging."
                    },
                    {
                        "username": "sergei99",
                        "content": "Tries ruthlessly beat any other collections here. I see the execution time top is all involving tries.\\nSpent 4 hours debugging my trie and didn\\'t regret: 40 ms, absolute top for the time being, for the first submission.\\nStill need to improve its memory consumption though. Went a simple way to avoid costly node reallocations, it helped to an extent in another task, but here it takes 76 Mb vs 64 Mb of an STL hash set... what a shame."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "[@anwendeng](/anwendeng)  Thanks! Will give it try for sure!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@akash_vannam](/akash_vannam) Trie is also hard for me. My DP is however a little bit different from other. I don't use hash table. Try a double for loop , i varies over the indexes of s , j varies over indexes of dictionary. Inside the loop  use  just substr, find, rfind in C++ string.  I hope that it is useful."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "I initially thought about tries first, then saw that greedy wouldn\\'t work here. Then, tried dp but wasn\\'t able to write recursion. I struggle alot to come up with an alternative approach when an approach intuitively comes up and I am not able to fully complete it. Any tips? I always see you in daily challenges discussion aceing every question, when I get stuck your hints help me alot."
                    },
                    {
                        "username": "sheshnathverma",
                        "content": "I think description should mention, we are allowed to reuse the dictionary word multiple time.\\n\\nIt took lot of time to realize :(\\n\\nTest Case: \"leetsleetscode\", [\"leets\", \"code\"]"
                    },
                    {
                        "username": "NagaNikhil",
                        "content": "Thanks for pointing it out"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[139. Word Break] similar problem  (https://leetcode.com/problems/word-break/)"
                    },
                    {
                        "username": "user3429v",
                        "content": "this one[2707] is a little bit harder"
                    },
                    {
                        "username": "aman1320",
                        "content": "(Time Limit Exceeded )Test Case 2024/2024\\ns=\\n\\nwho the hell putted this in the test case???????"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "It means your time limit exceeded, don\\'t check that testcase, as that one isn\\'t a testcase. You reduce the time. The overall time probably exceeds the time limit."
                    },
                    {
                        "username": "aquaman55",
                        "content": "PUTTED must be a golfer "
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Hint:\n\nWe know that substring of `s` must exist in dictionary to be able to break. The substring may start from index 0. If it doesn't then the index 0 is the leftover and so on.\n\nMore generally, for every substring there are a 2 choices:\n\n1) this substring is an leftover then `len(substring) + mininmumLeftOver(rest of the string)`\n 2) this substring is part of a substring of string from dictionary, then `0(no leftover) + mininmumLeftOver(rest of the string)`. \n\nWe shall pick the minimum from these 2 choices."
                    },
                    {
                        "username": "Beorn",
                        "content": "Knapsack  problem"
                    },
                    {
                        "username": "shivansh_07",
                        "content": "Like this take and not_take it is similar to knapsack\\n\\nclass Solution {\\npublic:\\nint mini = INT_MAX;\\n    int func(int index, string s , unordered_map<string ,  int> &mp , vector<int> &dp){\\n\\n        if(index == s.size()) return 0;\\n\\n        if(dp[index]!=-1) return dp[index];\\n        \\n        int not_take = 1 + func(index + 1 , s ,mp,dp);\\n        int take = INT_MAX;\\n        for(int i = index; i < s.size();i++){\\n            string t1 = s.substr(index , i - index + 1);\\n            \\n            if(mp.find(t1)!=mp.end()) take = min(take , 0+ func(i+1 , s , mp,dp));\\n            \\n        }\\n\\n        return dp[index] = min(take , not_take);\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<string,int> mp;\\n\\n        vector<int> dp(s.size() + 1 , -1);\\n        for(auto it : dictionary) mp[it]++;\\n\\n        return func(0 , s , mp,dp);\\n    }\\n};"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "how\\n"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "I\\'ve stuck on 1988 test case:\\ns = \"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\ndictionary = \"\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"\"\\n\\nOutput = 14\\nExpected = 15\\n\\nWhy 15 is expected? By the end, my solution produces the following string: \"hlwjeastjqwkof\". Isn\\'t it correct?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@desuraj110](/desuraj110) because smaller data set makes it easier to locate the bug in the code."
                    },
                    {
                        "username": "desuraj110",
                        "content": "same case i stuck too"
                    },
                    {
                        "username": "desuraj110",
                        "content": "[@sergei99](/sergei99) why split in halves ?? "
                    },
                    {
                        "username": "sans_102",
                        "content": "\"hlwxjeastjqwkof\" this is the string left after doing the operations. there is x between w and j (4th place). string is of length 15."
                    },
                    {
                        "username": "sergei99",
                        "content": "Split the input string to halves and execute each half separately. Take the failing half and repeat the procedure. At 4-5 chars you will be able to see the problem instantly. If not, repeat the same thing with the dictionary array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\n```\nazvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\nazv\n   zul\n    u\n          wobow\n            b\n               i\n                 i\n                  yeb\n                    b\n                        kecv\n                                 maqnv\n                                    n\n                                      na\n                                      n\n                                         maqnv\n                                            n\n```\nWith `15` extra characters you can produce this:\n```\nazv zul _ _ _ _ wobow i _ i yeb _ _ _ kecv _ _ _ _ _ maqnv na _ maqnv _\n```"
                    },
                    {
                        "username": "Alexander238",
                        "content": "Yep same, \"hlwjeastjqwkof\" is the word I get with Output 14 and expected 15..."
                    },
                    {
                        "username": "Labib2003",
                        "content": "same case my friend, tried to solve it as a greedy problem "
                    },
                    {
                        "username": "supperr-coder",
                        "content": "got the same output: with the exact same string too: \"hlwjeastjqwkof\" would appreciate someone\\'s help"
                    }
                ]
            },
            {
                "id": 1907499,
                "content": [
                    {
                        "username": "joshczipo",
                        "content": "2028 test casts buddy touch grass"
                    },
                    {
                        "username": "sergei99",
                        "content": "This separates the men from the boys.\\nLow amount of test data => any shoddy job runs at 1 ms.\\nHigh amount of test data => we see a dispersion."
                    },
                    {
                        "username": "ares22121999",
                        "content": "https://leetcode.com/problems/bitwise-and-of-numbers-range/ this question have 8269 cases XD"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Typical those who are always ready to stay in the office upto next day, cuz they don\\'t have any hobbies.\\n\\nNow I know they stay in the office to write 2028 testcases for leetcode. \\nThe badge \\'Stapler of the month\\' is unlocked. jajajaja"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Feels good to be able to solve these problems, atleast with the most basic method considering there was a time when I couldn\\'t figure out how to even start approaching the problem. Keep on keeping on guys!"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@mohantysatyajit57](/mohantysatyajit57) Dynamic programming, this is a very common type of problem."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@mohantysatyajit57](/mohantysatyajit57) I\\'ve been solving the daily problems for 175 days now. Obviously I couldn\\'t figure out most problems in the beginning. But after lookin at and understanding solutions day after day I am now able to solve many problems by myself. I occasionally solve problems people mention being similar to the current one. I don\\'t stick to topics because in an interview, you really won\\'t be informed of the topics of the questions you\\'ll be solving. "
                    },
                    {
                        "username": "mohantysatyajit57",
                        "content": "What topics did you practice in order to figure out what this problem was about?\\n"
                    },
                    {
                        "username": "c4tdog",
                        "content": "test\\n\"dwmodizxvvbosxxw\"\\n[\"ox\",\"lb\",\"diz\",\"gu\",\"v\",\"ksv\",\"o\",\"nuq\",\"r\",\"txhe\",\"e\",\"wmo\",\"cehy\",\"tskz\",\"ds\",\"kzbu\"]\\nhow come the answer is 7? I can only see this way (with 8 chars left)\\nd <b>wmo</b> <b>diz</b> xv <b>v</b> b <b>o</b> sxxw"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just split the input string to halves and execute each half separately. Take the failing half and repeat the procedure. At 4-5 chars you will be able to see the problem instantly. If not, repeat the same thing with the dictionary array."
                    },
                    {
                        "username": "just_ayush",
                        "content": "v is present two times"
                    },
                    {
                        "username": "sakshi_17",
                        "content": "v is deleted two times. So for input - [eev] and dictionary [e] , dict contains only distinct words but all occurrences of word can be deleted."
                    },
                    {
                        "username": "user8307St",
                        "content": "d **wmo** **diz** x **v** **v** b **o** sxxw !"
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@qutequbit](/qutequbit) leetcode is not considered for leetscode. \"leet\" is a different word in dictionary and \"code\" is a different word in the dictionary and \"leetcode\" is broken into \"leet\" and \"code\" which is then considered as the two words in the dictionary."
                    },
                    {
                        "username": "Qnide",
                        "content": "Sort the dictionary in descending order def len"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@6leet](/6leet) how can one not see that. feeling dumb after seeing your comment. thank you."
                    },
                    {
                        "username": "Baymax_",
                        "content": "[@_Anurag_Singhal_](/_Anurag_Singhal_) \"non-overlapping substrings\" is way different from \"can use  dictionary words multiple times\" (even though it is not mentioned)"
                    },
                    {
                        "username": "caleb-mabry",
                        "content": "[@6leet](/6leet) You have no idea how long I have been trying to figure out what was going on. Thanks for this!"
                    },
                    {
                        "username": "_Anurag_Singhal_",
                        "content": "but the questions says non-overlapping substrings!"
                    },
                    {
                        "username": "6leet",
                        "content": "there are two v"
                    },
                    {
                        "username": "anwendeng",
                        "content": "I like DP much more than bit counting.\nAfter usual DP can try DP+Trie! more challenging."
                    },
                    {
                        "username": "sergei99",
                        "content": "Tries ruthlessly beat any other collections here. I see the execution time top is all involving tries.\\nSpent 4 hours debugging my trie and didn\\'t regret: 40 ms, absolute top for the time being, for the first submission.\\nStill need to improve its memory consumption though. Went a simple way to avoid costly node reallocations, it helped to an extent in another task, but here it takes 76 Mb vs 64 Mb of an STL hash set... what a shame."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "[@anwendeng](/anwendeng)  Thanks! Will give it try for sure!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@akash_vannam](/akash_vannam) Trie is also hard for me. My DP is however a little bit different from other. I don't use hash table. Try a double for loop , i varies over the indexes of s , j varies over indexes of dictionary. Inside the loop  use  just substr, find, rfind in C++ string.  I hope that it is useful."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "I initially thought about tries first, then saw that greedy wouldn\\'t work here. Then, tried dp but wasn\\'t able to write recursion. I struggle alot to come up with an alternative approach when an approach intuitively comes up and I am not able to fully complete it. Any tips? I always see you in daily challenges discussion aceing every question, when I get stuck your hints help me alot."
                    },
                    {
                        "username": "sheshnathverma",
                        "content": "I think description should mention, we are allowed to reuse the dictionary word multiple time.\\n\\nIt took lot of time to realize :(\\n\\nTest Case: \"leetsleetscode\", [\"leets\", \"code\"]"
                    },
                    {
                        "username": "NagaNikhil",
                        "content": "Thanks for pointing it out"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[139. Word Break] similar problem  (https://leetcode.com/problems/word-break/)"
                    },
                    {
                        "username": "user3429v",
                        "content": "this one[2707] is a little bit harder"
                    },
                    {
                        "username": "aman1320",
                        "content": "(Time Limit Exceeded )Test Case 2024/2024\\ns=\\n\\nwho the hell putted this in the test case???????"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "It means your time limit exceeded, don\\'t check that testcase, as that one isn\\'t a testcase. You reduce the time. The overall time probably exceeds the time limit."
                    },
                    {
                        "username": "aquaman55",
                        "content": "PUTTED must be a golfer "
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Hint:\n\nWe know that substring of `s` must exist in dictionary to be able to break. The substring may start from index 0. If it doesn't then the index 0 is the leftover and so on.\n\nMore generally, for every substring there are a 2 choices:\n\n1) this substring is an leftover then `len(substring) + mininmumLeftOver(rest of the string)`\n 2) this substring is part of a substring of string from dictionary, then `0(no leftover) + mininmumLeftOver(rest of the string)`. \n\nWe shall pick the minimum from these 2 choices."
                    },
                    {
                        "username": "Beorn",
                        "content": "Knapsack  problem"
                    },
                    {
                        "username": "shivansh_07",
                        "content": "Like this take and not_take it is similar to knapsack\\n\\nclass Solution {\\npublic:\\nint mini = INT_MAX;\\n    int func(int index, string s , unordered_map<string ,  int> &mp , vector<int> &dp){\\n\\n        if(index == s.size()) return 0;\\n\\n        if(dp[index]!=-1) return dp[index];\\n        \\n        int not_take = 1 + func(index + 1 , s ,mp,dp);\\n        int take = INT_MAX;\\n        for(int i = index; i < s.size();i++){\\n            string t1 = s.substr(index , i - index + 1);\\n            \\n            if(mp.find(t1)!=mp.end()) take = min(take , 0+ func(i+1 , s , mp,dp));\\n            \\n        }\\n\\n        return dp[index] = min(take , not_take);\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<string,int> mp;\\n\\n        vector<int> dp(s.size() + 1 , -1);\\n        for(auto it : dictionary) mp[it]++;\\n\\n        return func(0 , s , mp,dp);\\n    }\\n};"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "how\\n"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "I\\'ve stuck on 1988 test case:\\ns = \"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\ndictionary = \"\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"\"\\n\\nOutput = 14\\nExpected = 15\\n\\nWhy 15 is expected? By the end, my solution produces the following string: \"hlwjeastjqwkof\". Isn\\'t it correct?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@desuraj110](/desuraj110) because smaller data set makes it easier to locate the bug in the code."
                    },
                    {
                        "username": "desuraj110",
                        "content": "same case i stuck too"
                    },
                    {
                        "username": "desuraj110",
                        "content": "[@sergei99](/sergei99) why split in halves ?? "
                    },
                    {
                        "username": "sans_102",
                        "content": "\"hlwxjeastjqwkof\" this is the string left after doing the operations. there is x between w and j (4th place). string is of length 15."
                    },
                    {
                        "username": "sergei99",
                        "content": "Split the input string to halves and execute each half separately. Take the failing half and repeat the procedure. At 4-5 chars you will be able to see the problem instantly. If not, repeat the same thing with the dictionary array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\n```\nazvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\nazv\n   zul\n    u\n          wobow\n            b\n               i\n                 i\n                  yeb\n                    b\n                        kecv\n                                 maqnv\n                                    n\n                                      na\n                                      n\n                                         maqnv\n                                            n\n```\nWith `15` extra characters you can produce this:\n```\nazv zul _ _ _ _ wobow i _ i yeb _ _ _ kecv _ _ _ _ _ maqnv na _ maqnv _\n```"
                    },
                    {
                        "username": "Alexander238",
                        "content": "Yep same, \"hlwjeastjqwkof\" is the word I get with Output 14 and expected 15..."
                    },
                    {
                        "username": "Labib2003",
                        "content": "same case my friend, tried to solve it as a greedy problem "
                    },
                    {
                        "username": "supperr-coder",
                        "content": "got the same output: with the exact same string too: \"hlwjeastjqwkof\" would appreciate someone\\'s help"
                    }
                ]
            },
            {
                "id": 2040003,
                "content": [
                    {
                        "username": "joshczipo",
                        "content": "2028 test casts buddy touch grass"
                    },
                    {
                        "username": "sergei99",
                        "content": "This separates the men from the boys.\\nLow amount of test data => any shoddy job runs at 1 ms.\\nHigh amount of test data => we see a dispersion."
                    },
                    {
                        "username": "ares22121999",
                        "content": "https://leetcode.com/problems/bitwise-and-of-numbers-range/ this question have 8269 cases XD"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Typical those who are always ready to stay in the office upto next day, cuz they don\\'t have any hobbies.\\n\\nNow I know they stay in the office to write 2028 testcases for leetcode. \\nThe badge \\'Stapler of the month\\' is unlocked. jajajaja"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Feels good to be able to solve these problems, atleast with the most basic method considering there was a time when I couldn\\'t figure out how to even start approaching the problem. Keep on keeping on guys!"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@mohantysatyajit57](/mohantysatyajit57) Dynamic programming, this is a very common type of problem."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@mohantysatyajit57](/mohantysatyajit57) I\\'ve been solving the daily problems for 175 days now. Obviously I couldn\\'t figure out most problems in the beginning. But after lookin at and understanding solutions day after day I am now able to solve many problems by myself. I occasionally solve problems people mention being similar to the current one. I don\\'t stick to topics because in an interview, you really won\\'t be informed of the topics of the questions you\\'ll be solving. "
                    },
                    {
                        "username": "mohantysatyajit57",
                        "content": "What topics did you practice in order to figure out what this problem was about?\\n"
                    },
                    {
                        "username": "c4tdog",
                        "content": "test\\n\"dwmodizxvvbosxxw\"\\n[\"ox\",\"lb\",\"diz\",\"gu\",\"v\",\"ksv\",\"o\",\"nuq\",\"r\",\"txhe\",\"e\",\"wmo\",\"cehy\",\"tskz\",\"ds\",\"kzbu\"]\\nhow come the answer is 7? I can only see this way (with 8 chars left)\\nd <b>wmo</b> <b>diz</b> xv <b>v</b> b <b>o</b> sxxw"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just split the input string to halves and execute each half separately. Take the failing half and repeat the procedure. At 4-5 chars you will be able to see the problem instantly. If not, repeat the same thing with the dictionary array."
                    },
                    {
                        "username": "just_ayush",
                        "content": "v is present two times"
                    },
                    {
                        "username": "sakshi_17",
                        "content": "v is deleted two times. So for input - [eev] and dictionary [e] , dict contains only distinct words but all occurrences of word can be deleted."
                    },
                    {
                        "username": "user8307St",
                        "content": "d **wmo** **diz** x **v** **v** b **o** sxxw !"
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@qutequbit](/qutequbit) leetcode is not considered for leetscode. \"leet\" is a different word in dictionary and \"code\" is a different word in the dictionary and \"leetcode\" is broken into \"leet\" and \"code\" which is then considered as the two words in the dictionary."
                    },
                    {
                        "username": "Qnide",
                        "content": "Sort the dictionary in descending order def len"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@6leet](/6leet) how can one not see that. feeling dumb after seeing your comment. thank you."
                    },
                    {
                        "username": "Baymax_",
                        "content": "[@_Anurag_Singhal_](/_Anurag_Singhal_) \"non-overlapping substrings\" is way different from \"can use  dictionary words multiple times\" (even though it is not mentioned)"
                    },
                    {
                        "username": "caleb-mabry",
                        "content": "[@6leet](/6leet) You have no idea how long I have been trying to figure out what was going on. Thanks for this!"
                    },
                    {
                        "username": "_Anurag_Singhal_",
                        "content": "but the questions says non-overlapping substrings!"
                    },
                    {
                        "username": "6leet",
                        "content": "there are two v"
                    },
                    {
                        "username": "anwendeng",
                        "content": "I like DP much more than bit counting.\nAfter usual DP can try DP+Trie! more challenging."
                    },
                    {
                        "username": "sergei99",
                        "content": "Tries ruthlessly beat any other collections here. I see the execution time top is all involving tries.\\nSpent 4 hours debugging my trie and didn\\'t regret: 40 ms, absolute top for the time being, for the first submission.\\nStill need to improve its memory consumption though. Went a simple way to avoid costly node reallocations, it helped to an extent in another task, but here it takes 76 Mb vs 64 Mb of an STL hash set... what a shame."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "[@anwendeng](/anwendeng)  Thanks! Will give it try for sure!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@akash_vannam](/akash_vannam) Trie is also hard for me. My DP is however a little bit different from other. I don't use hash table. Try a double for loop , i varies over the indexes of s , j varies over indexes of dictionary. Inside the loop  use  just substr, find, rfind in C++ string.  I hope that it is useful."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "I initially thought about tries first, then saw that greedy wouldn\\'t work here. Then, tried dp but wasn\\'t able to write recursion. I struggle alot to come up with an alternative approach when an approach intuitively comes up and I am not able to fully complete it. Any tips? I always see you in daily challenges discussion aceing every question, when I get stuck your hints help me alot."
                    },
                    {
                        "username": "sheshnathverma",
                        "content": "I think description should mention, we are allowed to reuse the dictionary word multiple time.\\n\\nIt took lot of time to realize :(\\n\\nTest Case: \"leetsleetscode\", [\"leets\", \"code\"]"
                    },
                    {
                        "username": "NagaNikhil",
                        "content": "Thanks for pointing it out"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[139. Word Break] similar problem  (https://leetcode.com/problems/word-break/)"
                    },
                    {
                        "username": "user3429v",
                        "content": "this one[2707] is a little bit harder"
                    },
                    {
                        "username": "aman1320",
                        "content": "(Time Limit Exceeded )Test Case 2024/2024\\ns=\\n\\nwho the hell putted this in the test case???????"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "It means your time limit exceeded, don\\'t check that testcase, as that one isn\\'t a testcase. You reduce the time. The overall time probably exceeds the time limit."
                    },
                    {
                        "username": "aquaman55",
                        "content": "PUTTED must be a golfer "
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Hint:\n\nWe know that substring of `s` must exist in dictionary to be able to break. The substring may start from index 0. If it doesn't then the index 0 is the leftover and so on.\n\nMore generally, for every substring there are a 2 choices:\n\n1) this substring is an leftover then `len(substring) + mininmumLeftOver(rest of the string)`\n 2) this substring is part of a substring of string from dictionary, then `0(no leftover) + mininmumLeftOver(rest of the string)`. \n\nWe shall pick the minimum from these 2 choices."
                    },
                    {
                        "username": "Beorn",
                        "content": "Knapsack  problem"
                    },
                    {
                        "username": "shivansh_07",
                        "content": "Like this take and not_take it is similar to knapsack\\n\\nclass Solution {\\npublic:\\nint mini = INT_MAX;\\n    int func(int index, string s , unordered_map<string ,  int> &mp , vector<int> &dp){\\n\\n        if(index == s.size()) return 0;\\n\\n        if(dp[index]!=-1) return dp[index];\\n        \\n        int not_take = 1 + func(index + 1 , s ,mp,dp);\\n        int take = INT_MAX;\\n        for(int i = index; i < s.size();i++){\\n            string t1 = s.substr(index , i - index + 1);\\n            \\n            if(mp.find(t1)!=mp.end()) take = min(take , 0+ func(i+1 , s , mp,dp));\\n            \\n        }\\n\\n        return dp[index] = min(take , not_take);\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<string,int> mp;\\n\\n        vector<int> dp(s.size() + 1 , -1);\\n        for(auto it : dictionary) mp[it]++;\\n\\n        return func(0 , s , mp,dp);\\n    }\\n};"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "how\\n"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "I\\'ve stuck on 1988 test case:\\ns = \"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\ndictionary = \"\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"\"\\n\\nOutput = 14\\nExpected = 15\\n\\nWhy 15 is expected? By the end, my solution produces the following string: \"hlwjeastjqwkof\". Isn\\'t it correct?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@desuraj110](/desuraj110) because smaller data set makes it easier to locate the bug in the code."
                    },
                    {
                        "username": "desuraj110",
                        "content": "same case i stuck too"
                    },
                    {
                        "username": "desuraj110",
                        "content": "[@sergei99](/sergei99) why split in halves ?? "
                    },
                    {
                        "username": "sans_102",
                        "content": "\"hlwxjeastjqwkof\" this is the string left after doing the operations. there is x between w and j (4th place). string is of length 15."
                    },
                    {
                        "username": "sergei99",
                        "content": "Split the input string to halves and execute each half separately. Take the failing half and repeat the procedure. At 4-5 chars you will be able to see the problem instantly. If not, repeat the same thing with the dictionary array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\n```\nazvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\nazv\n   zul\n    u\n          wobow\n            b\n               i\n                 i\n                  yeb\n                    b\n                        kecv\n                                 maqnv\n                                    n\n                                      na\n                                      n\n                                         maqnv\n                                            n\n```\nWith `15` extra characters you can produce this:\n```\nazv zul _ _ _ _ wobow i _ i yeb _ _ _ kecv _ _ _ _ _ maqnv na _ maqnv _\n```"
                    },
                    {
                        "username": "Alexander238",
                        "content": "Yep same, \"hlwjeastjqwkof\" is the word I get with Output 14 and expected 15..."
                    },
                    {
                        "username": "Labib2003",
                        "content": "same case my friend, tried to solve it as a greedy problem "
                    },
                    {
                        "username": "supperr-coder",
                        "content": "got the same output: with the exact same string too: \"hlwjeastjqwkof\" would appreciate someone\\'s help"
                    }
                ]
            },
            {
                "id": 2040417,
                "content": [
                    {
                        "username": "joshczipo",
                        "content": "2028 test casts buddy touch grass"
                    },
                    {
                        "username": "sergei99",
                        "content": "This separates the men from the boys.\\nLow amount of test data => any shoddy job runs at 1 ms.\\nHigh amount of test data => we see a dispersion."
                    },
                    {
                        "username": "ares22121999",
                        "content": "https://leetcode.com/problems/bitwise-and-of-numbers-range/ this question have 8269 cases XD"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Typical those who are always ready to stay in the office upto next day, cuz they don\\'t have any hobbies.\\n\\nNow I know they stay in the office to write 2028 testcases for leetcode. \\nThe badge \\'Stapler of the month\\' is unlocked. jajajaja"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Feels good to be able to solve these problems, atleast with the most basic method considering there was a time when I couldn\\'t figure out how to even start approaching the problem. Keep on keeping on guys!"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@mohantysatyajit57](/mohantysatyajit57) Dynamic programming, this is a very common type of problem."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@mohantysatyajit57](/mohantysatyajit57) I\\'ve been solving the daily problems for 175 days now. Obviously I couldn\\'t figure out most problems in the beginning. But after lookin at and understanding solutions day after day I am now able to solve many problems by myself. I occasionally solve problems people mention being similar to the current one. I don\\'t stick to topics because in an interview, you really won\\'t be informed of the topics of the questions you\\'ll be solving. "
                    },
                    {
                        "username": "mohantysatyajit57",
                        "content": "What topics did you practice in order to figure out what this problem was about?\\n"
                    },
                    {
                        "username": "c4tdog",
                        "content": "test\\n\"dwmodizxvvbosxxw\"\\n[\"ox\",\"lb\",\"diz\",\"gu\",\"v\",\"ksv\",\"o\",\"nuq\",\"r\",\"txhe\",\"e\",\"wmo\",\"cehy\",\"tskz\",\"ds\",\"kzbu\"]\\nhow come the answer is 7? I can only see this way (with 8 chars left)\\nd <b>wmo</b> <b>diz</b> xv <b>v</b> b <b>o</b> sxxw"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just split the input string to halves and execute each half separately. Take the failing half and repeat the procedure. At 4-5 chars you will be able to see the problem instantly. If not, repeat the same thing with the dictionary array."
                    },
                    {
                        "username": "just_ayush",
                        "content": "v is present two times"
                    },
                    {
                        "username": "sakshi_17",
                        "content": "v is deleted two times. So for input - [eev] and dictionary [e] , dict contains only distinct words but all occurrences of word can be deleted."
                    },
                    {
                        "username": "user8307St",
                        "content": "d **wmo** **diz** x **v** **v** b **o** sxxw !"
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@qutequbit](/qutequbit) leetcode is not considered for leetscode. \"leet\" is a different word in dictionary and \"code\" is a different word in the dictionary and \"leetcode\" is broken into \"leet\" and \"code\" which is then considered as the two words in the dictionary."
                    },
                    {
                        "username": "Qnide",
                        "content": "Sort the dictionary in descending order def len"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@6leet](/6leet) how can one not see that. feeling dumb after seeing your comment. thank you."
                    },
                    {
                        "username": "Baymax_",
                        "content": "[@_Anurag_Singhal_](/_Anurag_Singhal_) \"non-overlapping substrings\" is way different from \"can use  dictionary words multiple times\" (even though it is not mentioned)"
                    },
                    {
                        "username": "caleb-mabry",
                        "content": "[@6leet](/6leet) You have no idea how long I have been trying to figure out what was going on. Thanks for this!"
                    },
                    {
                        "username": "_Anurag_Singhal_",
                        "content": "but the questions says non-overlapping substrings!"
                    },
                    {
                        "username": "6leet",
                        "content": "there are two v"
                    },
                    {
                        "username": "anwendeng",
                        "content": "I like DP much more than bit counting.\nAfter usual DP can try DP+Trie! more challenging."
                    },
                    {
                        "username": "sergei99",
                        "content": "Tries ruthlessly beat any other collections here. I see the execution time top is all involving tries.\\nSpent 4 hours debugging my trie and didn\\'t regret: 40 ms, absolute top for the time being, for the first submission.\\nStill need to improve its memory consumption though. Went a simple way to avoid costly node reallocations, it helped to an extent in another task, but here it takes 76 Mb vs 64 Mb of an STL hash set... what a shame."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "[@anwendeng](/anwendeng)  Thanks! Will give it try for sure!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@akash_vannam](/akash_vannam) Trie is also hard for me. My DP is however a little bit different from other. I don't use hash table. Try a double for loop , i varies over the indexes of s , j varies over indexes of dictionary. Inside the loop  use  just substr, find, rfind in C++ string.  I hope that it is useful."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "I initially thought about tries first, then saw that greedy wouldn\\'t work here. Then, tried dp but wasn\\'t able to write recursion. I struggle alot to come up with an alternative approach when an approach intuitively comes up and I am not able to fully complete it. Any tips? I always see you in daily challenges discussion aceing every question, when I get stuck your hints help me alot."
                    },
                    {
                        "username": "sheshnathverma",
                        "content": "I think description should mention, we are allowed to reuse the dictionary word multiple time.\\n\\nIt took lot of time to realize :(\\n\\nTest Case: \"leetsleetscode\", [\"leets\", \"code\"]"
                    },
                    {
                        "username": "NagaNikhil",
                        "content": "Thanks for pointing it out"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[139. Word Break] similar problem  (https://leetcode.com/problems/word-break/)"
                    },
                    {
                        "username": "user3429v",
                        "content": "this one[2707] is a little bit harder"
                    },
                    {
                        "username": "aman1320",
                        "content": "(Time Limit Exceeded )Test Case 2024/2024\\ns=\\n\\nwho the hell putted this in the test case???????"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "It means your time limit exceeded, don\\'t check that testcase, as that one isn\\'t a testcase. You reduce the time. The overall time probably exceeds the time limit."
                    },
                    {
                        "username": "aquaman55",
                        "content": "PUTTED must be a golfer "
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Hint:\n\nWe know that substring of `s` must exist in dictionary to be able to break. The substring may start from index 0. If it doesn't then the index 0 is the leftover and so on.\n\nMore generally, for every substring there are a 2 choices:\n\n1) this substring is an leftover then `len(substring) + mininmumLeftOver(rest of the string)`\n 2) this substring is part of a substring of string from dictionary, then `0(no leftover) + mininmumLeftOver(rest of the string)`. \n\nWe shall pick the minimum from these 2 choices."
                    },
                    {
                        "username": "Beorn",
                        "content": "Knapsack  problem"
                    },
                    {
                        "username": "shivansh_07",
                        "content": "Like this take and not_take it is similar to knapsack\\n\\nclass Solution {\\npublic:\\nint mini = INT_MAX;\\n    int func(int index, string s , unordered_map<string ,  int> &mp , vector<int> &dp){\\n\\n        if(index == s.size()) return 0;\\n\\n        if(dp[index]!=-1) return dp[index];\\n        \\n        int not_take = 1 + func(index + 1 , s ,mp,dp);\\n        int take = INT_MAX;\\n        for(int i = index; i < s.size();i++){\\n            string t1 = s.substr(index , i - index + 1);\\n            \\n            if(mp.find(t1)!=mp.end()) take = min(take , 0+ func(i+1 , s , mp,dp));\\n            \\n        }\\n\\n        return dp[index] = min(take , not_take);\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<string,int> mp;\\n\\n        vector<int> dp(s.size() + 1 , -1);\\n        for(auto it : dictionary) mp[it]++;\\n\\n        return func(0 , s , mp,dp);\\n    }\\n};"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "how\\n"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "I\\'ve stuck on 1988 test case:\\ns = \"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\ndictionary = \"\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"\"\\n\\nOutput = 14\\nExpected = 15\\n\\nWhy 15 is expected? By the end, my solution produces the following string: \"hlwjeastjqwkof\". Isn\\'t it correct?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@desuraj110](/desuraj110) because smaller data set makes it easier to locate the bug in the code."
                    },
                    {
                        "username": "desuraj110",
                        "content": "same case i stuck too"
                    },
                    {
                        "username": "desuraj110",
                        "content": "[@sergei99](/sergei99) why split in halves ?? "
                    },
                    {
                        "username": "sans_102",
                        "content": "\"hlwxjeastjqwkof\" this is the string left after doing the operations. there is x between w and j (4th place). string is of length 15."
                    },
                    {
                        "username": "sergei99",
                        "content": "Split the input string to halves and execute each half separately. Take the failing half and repeat the procedure. At 4-5 chars you will be able to see the problem instantly. If not, repeat the same thing with the dictionary array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\n```\nazvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\nazv\n   zul\n    u\n          wobow\n            b\n               i\n                 i\n                  yeb\n                    b\n                        kecv\n                                 maqnv\n                                    n\n                                      na\n                                      n\n                                         maqnv\n                                            n\n```\nWith `15` extra characters you can produce this:\n```\nazv zul _ _ _ _ wobow i _ i yeb _ _ _ kecv _ _ _ _ _ maqnv na _ maqnv _\n```"
                    },
                    {
                        "username": "Alexander238",
                        "content": "Yep same, \"hlwjeastjqwkof\" is the word I get with Output 14 and expected 15..."
                    },
                    {
                        "username": "Labib2003",
                        "content": "same case my friend, tried to solve it as a greedy problem "
                    },
                    {
                        "username": "supperr-coder",
                        "content": "got the same output: with the exact same string too: \"hlwjeastjqwkof\" would appreciate someone\\'s help"
                    }
                ]
            },
            {
                "id": 1908885,
                "content": [
                    {
                        "username": "joshczipo",
                        "content": "2028 test casts buddy touch grass"
                    },
                    {
                        "username": "sergei99",
                        "content": "This separates the men from the boys.\\nLow amount of test data => any shoddy job runs at 1 ms.\\nHigh amount of test data => we see a dispersion."
                    },
                    {
                        "username": "ares22121999",
                        "content": "https://leetcode.com/problems/bitwise-and-of-numbers-range/ this question have 8269 cases XD"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Typical those who are always ready to stay in the office upto next day, cuz they don\\'t have any hobbies.\\n\\nNow I know they stay in the office to write 2028 testcases for leetcode. \\nThe badge \\'Stapler of the month\\' is unlocked. jajajaja"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Feels good to be able to solve these problems, atleast with the most basic method considering there was a time when I couldn\\'t figure out how to even start approaching the problem. Keep on keeping on guys!"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@mohantysatyajit57](/mohantysatyajit57) Dynamic programming, this is a very common type of problem."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@mohantysatyajit57](/mohantysatyajit57) I\\'ve been solving the daily problems for 175 days now. Obviously I couldn\\'t figure out most problems in the beginning. But after lookin at and understanding solutions day after day I am now able to solve many problems by myself. I occasionally solve problems people mention being similar to the current one. I don\\'t stick to topics because in an interview, you really won\\'t be informed of the topics of the questions you\\'ll be solving. "
                    },
                    {
                        "username": "mohantysatyajit57",
                        "content": "What topics did you practice in order to figure out what this problem was about?\\n"
                    },
                    {
                        "username": "c4tdog",
                        "content": "test\\n\"dwmodizxvvbosxxw\"\\n[\"ox\",\"lb\",\"diz\",\"gu\",\"v\",\"ksv\",\"o\",\"nuq\",\"r\",\"txhe\",\"e\",\"wmo\",\"cehy\",\"tskz\",\"ds\",\"kzbu\"]\\nhow come the answer is 7? I can only see this way (with 8 chars left)\\nd <b>wmo</b> <b>diz</b> xv <b>v</b> b <b>o</b> sxxw"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just split the input string to halves and execute each half separately. Take the failing half and repeat the procedure. At 4-5 chars you will be able to see the problem instantly. If not, repeat the same thing with the dictionary array."
                    },
                    {
                        "username": "just_ayush",
                        "content": "v is present two times"
                    },
                    {
                        "username": "sakshi_17",
                        "content": "v is deleted two times. So for input - [eev] and dictionary [e] , dict contains only distinct words but all occurrences of word can be deleted."
                    },
                    {
                        "username": "user8307St",
                        "content": "d **wmo** **diz** x **v** **v** b **o** sxxw !"
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@qutequbit](/qutequbit) leetcode is not considered for leetscode. \"leet\" is a different word in dictionary and \"code\" is a different word in the dictionary and \"leetcode\" is broken into \"leet\" and \"code\" which is then considered as the two words in the dictionary."
                    },
                    {
                        "username": "Qnide",
                        "content": "Sort the dictionary in descending order def len"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@6leet](/6leet) how can one not see that. feeling dumb after seeing your comment. thank you."
                    },
                    {
                        "username": "Baymax_",
                        "content": "[@_Anurag_Singhal_](/_Anurag_Singhal_) \"non-overlapping substrings\" is way different from \"can use  dictionary words multiple times\" (even though it is not mentioned)"
                    },
                    {
                        "username": "caleb-mabry",
                        "content": "[@6leet](/6leet) You have no idea how long I have been trying to figure out what was going on. Thanks for this!"
                    },
                    {
                        "username": "_Anurag_Singhal_",
                        "content": "but the questions says non-overlapping substrings!"
                    },
                    {
                        "username": "6leet",
                        "content": "there are two v"
                    },
                    {
                        "username": "anwendeng",
                        "content": "I like DP much more than bit counting.\nAfter usual DP can try DP+Trie! more challenging."
                    },
                    {
                        "username": "sergei99",
                        "content": "Tries ruthlessly beat any other collections here. I see the execution time top is all involving tries.\\nSpent 4 hours debugging my trie and didn\\'t regret: 40 ms, absolute top for the time being, for the first submission.\\nStill need to improve its memory consumption though. Went a simple way to avoid costly node reallocations, it helped to an extent in another task, but here it takes 76 Mb vs 64 Mb of an STL hash set... what a shame."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "[@anwendeng](/anwendeng)  Thanks! Will give it try for sure!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@akash_vannam](/akash_vannam) Trie is also hard for me. My DP is however a little bit different from other. I don't use hash table. Try a double for loop , i varies over the indexes of s , j varies over indexes of dictionary. Inside the loop  use  just substr, find, rfind in C++ string.  I hope that it is useful."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "I initially thought about tries first, then saw that greedy wouldn\\'t work here. Then, tried dp but wasn\\'t able to write recursion. I struggle alot to come up with an alternative approach when an approach intuitively comes up and I am not able to fully complete it. Any tips? I always see you in daily challenges discussion aceing every question, when I get stuck your hints help me alot."
                    },
                    {
                        "username": "sheshnathverma",
                        "content": "I think description should mention, we are allowed to reuse the dictionary word multiple time.\\n\\nIt took lot of time to realize :(\\n\\nTest Case: \"leetsleetscode\", [\"leets\", \"code\"]"
                    },
                    {
                        "username": "NagaNikhil",
                        "content": "Thanks for pointing it out"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[139. Word Break] similar problem  (https://leetcode.com/problems/word-break/)"
                    },
                    {
                        "username": "user3429v",
                        "content": "this one[2707] is a little bit harder"
                    },
                    {
                        "username": "aman1320",
                        "content": "(Time Limit Exceeded )Test Case 2024/2024\\ns=\\n\\nwho the hell putted this in the test case???????"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "It means your time limit exceeded, don\\'t check that testcase, as that one isn\\'t a testcase. You reduce the time. The overall time probably exceeds the time limit."
                    },
                    {
                        "username": "aquaman55",
                        "content": "PUTTED must be a golfer "
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Hint:\n\nWe know that substring of `s` must exist in dictionary to be able to break. The substring may start from index 0. If it doesn't then the index 0 is the leftover and so on.\n\nMore generally, for every substring there are a 2 choices:\n\n1) this substring is an leftover then `len(substring) + mininmumLeftOver(rest of the string)`\n 2) this substring is part of a substring of string from dictionary, then `0(no leftover) + mininmumLeftOver(rest of the string)`. \n\nWe shall pick the minimum from these 2 choices."
                    },
                    {
                        "username": "Beorn",
                        "content": "Knapsack  problem"
                    },
                    {
                        "username": "shivansh_07",
                        "content": "Like this take and not_take it is similar to knapsack\\n\\nclass Solution {\\npublic:\\nint mini = INT_MAX;\\n    int func(int index, string s , unordered_map<string ,  int> &mp , vector<int> &dp){\\n\\n        if(index == s.size()) return 0;\\n\\n        if(dp[index]!=-1) return dp[index];\\n        \\n        int not_take = 1 + func(index + 1 , s ,mp,dp);\\n        int take = INT_MAX;\\n        for(int i = index; i < s.size();i++){\\n            string t1 = s.substr(index , i - index + 1);\\n            \\n            if(mp.find(t1)!=mp.end()) take = min(take , 0+ func(i+1 , s , mp,dp));\\n            \\n        }\\n\\n        return dp[index] = min(take , not_take);\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<string,int> mp;\\n\\n        vector<int> dp(s.size() + 1 , -1);\\n        for(auto it : dictionary) mp[it]++;\\n\\n        return func(0 , s , mp,dp);\\n    }\\n};"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "how\\n"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "I\\'ve stuck on 1988 test case:\\ns = \"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\ndictionary = \"\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"\"\\n\\nOutput = 14\\nExpected = 15\\n\\nWhy 15 is expected? By the end, my solution produces the following string: \"hlwjeastjqwkof\". Isn\\'t it correct?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@desuraj110](/desuraj110) because smaller data set makes it easier to locate the bug in the code."
                    },
                    {
                        "username": "desuraj110",
                        "content": "same case i stuck too"
                    },
                    {
                        "username": "desuraj110",
                        "content": "[@sergei99](/sergei99) why split in halves ?? "
                    },
                    {
                        "username": "sans_102",
                        "content": "\"hlwxjeastjqwkof\" this is the string left after doing the operations. there is x between w and j (4th place). string is of length 15."
                    },
                    {
                        "username": "sergei99",
                        "content": "Split the input string to halves and execute each half separately. Take the failing half and repeat the procedure. At 4-5 chars you will be able to see the problem instantly. If not, repeat the same thing with the dictionary array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\n```\nazvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\nazv\n   zul\n    u\n          wobow\n            b\n               i\n                 i\n                  yeb\n                    b\n                        kecv\n                                 maqnv\n                                    n\n                                      na\n                                      n\n                                         maqnv\n                                            n\n```\nWith `15` extra characters you can produce this:\n```\nazv zul _ _ _ _ wobow i _ i yeb _ _ _ kecv _ _ _ _ _ maqnv na _ maqnv _\n```"
                    },
                    {
                        "username": "Alexander238",
                        "content": "Yep same, \"hlwjeastjqwkof\" is the word I get with Output 14 and expected 15..."
                    },
                    {
                        "username": "Labib2003",
                        "content": "same case my friend, tried to solve it as a greedy problem "
                    },
                    {
                        "username": "supperr-coder",
                        "content": "got the same output: with the exact same string too: \"hlwjeastjqwkof\" would appreciate someone\\'s help"
                    }
                ]
            },
            {
                "id": 1908779,
                "content": [
                    {
                        "username": "joshczipo",
                        "content": "2028 test casts buddy touch grass"
                    },
                    {
                        "username": "sergei99",
                        "content": "This separates the men from the boys.\\nLow amount of test data => any shoddy job runs at 1 ms.\\nHigh amount of test data => we see a dispersion."
                    },
                    {
                        "username": "ares22121999",
                        "content": "https://leetcode.com/problems/bitwise-and-of-numbers-range/ this question have 8269 cases XD"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Typical those who are always ready to stay in the office upto next day, cuz they don\\'t have any hobbies.\\n\\nNow I know they stay in the office to write 2028 testcases for leetcode. \\nThe badge \\'Stapler of the month\\' is unlocked. jajajaja"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Feels good to be able to solve these problems, atleast with the most basic method considering there was a time when I couldn\\'t figure out how to even start approaching the problem. Keep on keeping on guys!"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@mohantysatyajit57](/mohantysatyajit57) Dynamic programming, this is a very common type of problem."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@mohantysatyajit57](/mohantysatyajit57) I\\'ve been solving the daily problems for 175 days now. Obviously I couldn\\'t figure out most problems in the beginning. But after lookin at and understanding solutions day after day I am now able to solve many problems by myself. I occasionally solve problems people mention being similar to the current one. I don\\'t stick to topics because in an interview, you really won\\'t be informed of the topics of the questions you\\'ll be solving. "
                    },
                    {
                        "username": "mohantysatyajit57",
                        "content": "What topics did you practice in order to figure out what this problem was about?\\n"
                    },
                    {
                        "username": "c4tdog",
                        "content": "test\\n\"dwmodizxvvbosxxw\"\\n[\"ox\",\"lb\",\"diz\",\"gu\",\"v\",\"ksv\",\"o\",\"nuq\",\"r\",\"txhe\",\"e\",\"wmo\",\"cehy\",\"tskz\",\"ds\",\"kzbu\"]\\nhow come the answer is 7? I can only see this way (with 8 chars left)\\nd <b>wmo</b> <b>diz</b> xv <b>v</b> b <b>o</b> sxxw"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just split the input string to halves and execute each half separately. Take the failing half and repeat the procedure. At 4-5 chars you will be able to see the problem instantly. If not, repeat the same thing with the dictionary array."
                    },
                    {
                        "username": "just_ayush",
                        "content": "v is present two times"
                    },
                    {
                        "username": "sakshi_17",
                        "content": "v is deleted two times. So for input - [eev] and dictionary [e] , dict contains only distinct words but all occurrences of word can be deleted."
                    },
                    {
                        "username": "user8307St",
                        "content": "d **wmo** **diz** x **v** **v** b **o** sxxw !"
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@qutequbit](/qutequbit) leetcode is not considered for leetscode. \"leet\" is a different word in dictionary and \"code\" is a different word in the dictionary and \"leetcode\" is broken into \"leet\" and \"code\" which is then considered as the two words in the dictionary."
                    },
                    {
                        "username": "Qnide",
                        "content": "Sort the dictionary in descending order def len"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@6leet](/6leet) how can one not see that. feeling dumb after seeing your comment. thank you."
                    },
                    {
                        "username": "Baymax_",
                        "content": "[@_Anurag_Singhal_](/_Anurag_Singhal_) \"non-overlapping substrings\" is way different from \"can use  dictionary words multiple times\" (even though it is not mentioned)"
                    },
                    {
                        "username": "caleb-mabry",
                        "content": "[@6leet](/6leet) You have no idea how long I have been trying to figure out what was going on. Thanks for this!"
                    },
                    {
                        "username": "_Anurag_Singhal_",
                        "content": "but the questions says non-overlapping substrings!"
                    },
                    {
                        "username": "6leet",
                        "content": "there are two v"
                    },
                    {
                        "username": "anwendeng",
                        "content": "I like DP much more than bit counting.\nAfter usual DP can try DP+Trie! more challenging."
                    },
                    {
                        "username": "sergei99",
                        "content": "Tries ruthlessly beat any other collections here. I see the execution time top is all involving tries.\\nSpent 4 hours debugging my trie and didn\\'t regret: 40 ms, absolute top for the time being, for the first submission.\\nStill need to improve its memory consumption though. Went a simple way to avoid costly node reallocations, it helped to an extent in another task, but here it takes 76 Mb vs 64 Mb of an STL hash set... what a shame."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "[@anwendeng](/anwendeng)  Thanks! Will give it try for sure!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@akash_vannam](/akash_vannam) Trie is also hard for me. My DP is however a little bit different from other. I don't use hash table. Try a double for loop , i varies over the indexes of s , j varies over indexes of dictionary. Inside the loop  use  just substr, find, rfind in C++ string.  I hope that it is useful."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "I initially thought about tries first, then saw that greedy wouldn\\'t work here. Then, tried dp but wasn\\'t able to write recursion. I struggle alot to come up with an alternative approach when an approach intuitively comes up and I am not able to fully complete it. Any tips? I always see you in daily challenges discussion aceing every question, when I get stuck your hints help me alot."
                    },
                    {
                        "username": "sheshnathverma",
                        "content": "I think description should mention, we are allowed to reuse the dictionary word multiple time.\\n\\nIt took lot of time to realize :(\\n\\nTest Case: \"leetsleetscode\", [\"leets\", \"code\"]"
                    },
                    {
                        "username": "NagaNikhil",
                        "content": "Thanks for pointing it out"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[139. Word Break] similar problem  (https://leetcode.com/problems/word-break/)"
                    },
                    {
                        "username": "user3429v",
                        "content": "this one[2707] is a little bit harder"
                    },
                    {
                        "username": "aman1320",
                        "content": "(Time Limit Exceeded )Test Case 2024/2024\\ns=\\n\\nwho the hell putted this in the test case???????"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "It means your time limit exceeded, don\\'t check that testcase, as that one isn\\'t a testcase. You reduce the time. The overall time probably exceeds the time limit."
                    },
                    {
                        "username": "aquaman55",
                        "content": "PUTTED must be a golfer "
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Hint:\n\nWe know that substring of `s` must exist in dictionary to be able to break. The substring may start from index 0. If it doesn't then the index 0 is the leftover and so on.\n\nMore generally, for every substring there are a 2 choices:\n\n1) this substring is an leftover then `len(substring) + mininmumLeftOver(rest of the string)`\n 2) this substring is part of a substring of string from dictionary, then `0(no leftover) + mininmumLeftOver(rest of the string)`. \n\nWe shall pick the minimum from these 2 choices."
                    },
                    {
                        "username": "Beorn",
                        "content": "Knapsack  problem"
                    },
                    {
                        "username": "shivansh_07",
                        "content": "Like this take and not_take it is similar to knapsack\\n\\nclass Solution {\\npublic:\\nint mini = INT_MAX;\\n    int func(int index, string s , unordered_map<string ,  int> &mp , vector<int> &dp){\\n\\n        if(index == s.size()) return 0;\\n\\n        if(dp[index]!=-1) return dp[index];\\n        \\n        int not_take = 1 + func(index + 1 , s ,mp,dp);\\n        int take = INT_MAX;\\n        for(int i = index; i < s.size();i++){\\n            string t1 = s.substr(index , i - index + 1);\\n            \\n            if(mp.find(t1)!=mp.end()) take = min(take , 0+ func(i+1 , s , mp,dp));\\n            \\n        }\\n\\n        return dp[index] = min(take , not_take);\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<string,int> mp;\\n\\n        vector<int> dp(s.size() + 1 , -1);\\n        for(auto it : dictionary) mp[it]++;\\n\\n        return func(0 , s , mp,dp);\\n    }\\n};"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "how\\n"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "I\\'ve stuck on 1988 test case:\\ns = \"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\ndictionary = \"\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"\"\\n\\nOutput = 14\\nExpected = 15\\n\\nWhy 15 is expected? By the end, my solution produces the following string: \"hlwjeastjqwkof\". Isn\\'t it correct?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@desuraj110](/desuraj110) because smaller data set makes it easier to locate the bug in the code."
                    },
                    {
                        "username": "desuraj110",
                        "content": "same case i stuck too"
                    },
                    {
                        "username": "desuraj110",
                        "content": "[@sergei99](/sergei99) why split in halves ?? "
                    },
                    {
                        "username": "sans_102",
                        "content": "\"hlwxjeastjqwkof\" this is the string left after doing the operations. there is x between w and j (4th place). string is of length 15."
                    },
                    {
                        "username": "sergei99",
                        "content": "Split the input string to halves and execute each half separately. Take the failing half and repeat the procedure. At 4-5 chars you will be able to see the problem instantly. If not, repeat the same thing with the dictionary array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\n```\nazvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\nazv\n   zul\n    u\n          wobow\n            b\n               i\n                 i\n                  yeb\n                    b\n                        kecv\n                                 maqnv\n                                    n\n                                      na\n                                      n\n                                         maqnv\n                                            n\n```\nWith `15` extra characters you can produce this:\n```\nazv zul _ _ _ _ wobow i _ i yeb _ _ _ kecv _ _ _ _ _ maqnv na _ maqnv _\n```"
                    },
                    {
                        "username": "Alexander238",
                        "content": "Yep same, \"hlwjeastjqwkof\" is the word I get with Output 14 and expected 15..."
                    },
                    {
                        "username": "Labib2003",
                        "content": "same case my friend, tried to solve it as a greedy problem "
                    },
                    {
                        "username": "supperr-coder",
                        "content": "got the same output: with the exact same string too: \"hlwjeastjqwkof\" would appreciate someone\\'s help"
                    }
                ]
            },
            {
                "id": 2040053,
                "content": [
                    {
                        "username": "joshczipo",
                        "content": "2028 test casts buddy touch grass"
                    },
                    {
                        "username": "sergei99",
                        "content": "This separates the men from the boys.\\nLow amount of test data => any shoddy job runs at 1 ms.\\nHigh amount of test data => we see a dispersion."
                    },
                    {
                        "username": "ares22121999",
                        "content": "https://leetcode.com/problems/bitwise-and-of-numbers-range/ this question have 8269 cases XD"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Typical those who are always ready to stay in the office upto next day, cuz they don\\'t have any hobbies.\\n\\nNow I know they stay in the office to write 2028 testcases for leetcode. \\nThe badge \\'Stapler of the month\\' is unlocked. jajajaja"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Feels good to be able to solve these problems, atleast with the most basic method considering there was a time when I couldn\\'t figure out how to even start approaching the problem. Keep on keeping on guys!"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@mohantysatyajit57](/mohantysatyajit57) Dynamic programming, this is a very common type of problem."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@mohantysatyajit57](/mohantysatyajit57) I\\'ve been solving the daily problems for 175 days now. Obviously I couldn\\'t figure out most problems in the beginning. But after lookin at and understanding solutions day after day I am now able to solve many problems by myself. I occasionally solve problems people mention being similar to the current one. I don\\'t stick to topics because in an interview, you really won\\'t be informed of the topics of the questions you\\'ll be solving. "
                    },
                    {
                        "username": "mohantysatyajit57",
                        "content": "What topics did you practice in order to figure out what this problem was about?\\n"
                    },
                    {
                        "username": "c4tdog",
                        "content": "test\\n\"dwmodizxvvbosxxw\"\\n[\"ox\",\"lb\",\"diz\",\"gu\",\"v\",\"ksv\",\"o\",\"nuq\",\"r\",\"txhe\",\"e\",\"wmo\",\"cehy\",\"tskz\",\"ds\",\"kzbu\"]\\nhow come the answer is 7? I can only see this way (with 8 chars left)\\nd <b>wmo</b> <b>diz</b> xv <b>v</b> b <b>o</b> sxxw"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just split the input string to halves and execute each half separately. Take the failing half and repeat the procedure. At 4-5 chars you will be able to see the problem instantly. If not, repeat the same thing with the dictionary array."
                    },
                    {
                        "username": "just_ayush",
                        "content": "v is present two times"
                    },
                    {
                        "username": "sakshi_17",
                        "content": "v is deleted two times. So for input - [eev] and dictionary [e] , dict contains only distinct words but all occurrences of word can be deleted."
                    },
                    {
                        "username": "user8307St",
                        "content": "d **wmo** **diz** x **v** **v** b **o** sxxw !"
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@qutequbit](/qutequbit) leetcode is not considered for leetscode. \"leet\" is a different word in dictionary and \"code\" is a different word in the dictionary and \"leetcode\" is broken into \"leet\" and \"code\" which is then considered as the two words in the dictionary."
                    },
                    {
                        "username": "Qnide",
                        "content": "Sort the dictionary in descending order def len"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@6leet](/6leet) how can one not see that. feeling dumb after seeing your comment. thank you."
                    },
                    {
                        "username": "Baymax_",
                        "content": "[@_Anurag_Singhal_](/_Anurag_Singhal_) \"non-overlapping substrings\" is way different from \"can use  dictionary words multiple times\" (even though it is not mentioned)"
                    },
                    {
                        "username": "caleb-mabry",
                        "content": "[@6leet](/6leet) You have no idea how long I have been trying to figure out what was going on. Thanks for this!"
                    },
                    {
                        "username": "_Anurag_Singhal_",
                        "content": "but the questions says non-overlapping substrings!"
                    },
                    {
                        "username": "6leet",
                        "content": "there are two v"
                    },
                    {
                        "username": "anwendeng",
                        "content": "I like DP much more than bit counting.\nAfter usual DP can try DP+Trie! more challenging."
                    },
                    {
                        "username": "sergei99",
                        "content": "Tries ruthlessly beat any other collections here. I see the execution time top is all involving tries.\\nSpent 4 hours debugging my trie and didn\\'t regret: 40 ms, absolute top for the time being, for the first submission.\\nStill need to improve its memory consumption though. Went a simple way to avoid costly node reallocations, it helped to an extent in another task, but here it takes 76 Mb vs 64 Mb of an STL hash set... what a shame."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "[@anwendeng](/anwendeng)  Thanks! Will give it try for sure!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@akash_vannam](/akash_vannam) Trie is also hard for me. My DP is however a little bit different from other. I don't use hash table. Try a double for loop , i varies over the indexes of s , j varies over indexes of dictionary. Inside the loop  use  just substr, find, rfind in C++ string.  I hope that it is useful."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "I initially thought about tries first, then saw that greedy wouldn\\'t work here. Then, tried dp but wasn\\'t able to write recursion. I struggle alot to come up with an alternative approach when an approach intuitively comes up and I am not able to fully complete it. Any tips? I always see you in daily challenges discussion aceing every question, when I get stuck your hints help me alot."
                    },
                    {
                        "username": "sheshnathverma",
                        "content": "I think description should mention, we are allowed to reuse the dictionary word multiple time.\\n\\nIt took lot of time to realize :(\\n\\nTest Case: \"leetsleetscode\", [\"leets\", \"code\"]"
                    },
                    {
                        "username": "NagaNikhil",
                        "content": "Thanks for pointing it out"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[139. Word Break] similar problem  (https://leetcode.com/problems/word-break/)"
                    },
                    {
                        "username": "user3429v",
                        "content": "this one[2707] is a little bit harder"
                    },
                    {
                        "username": "aman1320",
                        "content": "(Time Limit Exceeded )Test Case 2024/2024\\ns=\\n\\nwho the hell putted this in the test case???????"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "It means your time limit exceeded, don\\'t check that testcase, as that one isn\\'t a testcase. You reduce the time. The overall time probably exceeds the time limit."
                    },
                    {
                        "username": "aquaman55",
                        "content": "PUTTED must be a golfer "
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Hint:\n\nWe know that substring of `s` must exist in dictionary to be able to break. The substring may start from index 0. If it doesn't then the index 0 is the leftover and so on.\n\nMore generally, for every substring there are a 2 choices:\n\n1) this substring is an leftover then `len(substring) + mininmumLeftOver(rest of the string)`\n 2) this substring is part of a substring of string from dictionary, then `0(no leftover) + mininmumLeftOver(rest of the string)`. \n\nWe shall pick the minimum from these 2 choices."
                    },
                    {
                        "username": "Beorn",
                        "content": "Knapsack  problem"
                    },
                    {
                        "username": "shivansh_07",
                        "content": "Like this take and not_take it is similar to knapsack\\n\\nclass Solution {\\npublic:\\nint mini = INT_MAX;\\n    int func(int index, string s , unordered_map<string ,  int> &mp , vector<int> &dp){\\n\\n        if(index == s.size()) return 0;\\n\\n        if(dp[index]!=-1) return dp[index];\\n        \\n        int not_take = 1 + func(index + 1 , s ,mp,dp);\\n        int take = INT_MAX;\\n        for(int i = index; i < s.size();i++){\\n            string t1 = s.substr(index , i - index + 1);\\n            \\n            if(mp.find(t1)!=mp.end()) take = min(take , 0+ func(i+1 , s , mp,dp));\\n            \\n        }\\n\\n        return dp[index] = min(take , not_take);\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<string,int> mp;\\n\\n        vector<int> dp(s.size() + 1 , -1);\\n        for(auto it : dictionary) mp[it]++;\\n\\n        return func(0 , s , mp,dp);\\n    }\\n};"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "how\\n"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "I\\'ve stuck on 1988 test case:\\ns = \"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\ndictionary = \"\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"\"\\n\\nOutput = 14\\nExpected = 15\\n\\nWhy 15 is expected? By the end, my solution produces the following string: \"hlwjeastjqwkof\". Isn\\'t it correct?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@desuraj110](/desuraj110) because smaller data set makes it easier to locate the bug in the code."
                    },
                    {
                        "username": "desuraj110",
                        "content": "same case i stuck too"
                    },
                    {
                        "username": "desuraj110",
                        "content": "[@sergei99](/sergei99) why split in halves ?? "
                    },
                    {
                        "username": "sans_102",
                        "content": "\"hlwxjeastjqwkof\" this is the string left after doing the operations. there is x between w and j (4th place). string is of length 15."
                    },
                    {
                        "username": "sergei99",
                        "content": "Split the input string to halves and execute each half separately. Take the failing half and repeat the procedure. At 4-5 chars you will be able to see the problem instantly. If not, repeat the same thing with the dictionary array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\n```\nazvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\nazv\n   zul\n    u\n          wobow\n            b\n               i\n                 i\n                  yeb\n                    b\n                        kecv\n                                 maqnv\n                                    n\n                                      na\n                                      n\n                                         maqnv\n                                            n\n```\nWith `15` extra characters you can produce this:\n```\nazv zul _ _ _ _ wobow i _ i yeb _ _ _ kecv _ _ _ _ _ maqnv na _ maqnv _\n```"
                    },
                    {
                        "username": "Alexander238",
                        "content": "Yep same, \"hlwjeastjqwkof\" is the word I get with Output 14 and expected 15..."
                    },
                    {
                        "username": "Labib2003",
                        "content": "same case my friend, tried to solve it as a greedy problem "
                    },
                    {
                        "username": "supperr-coder",
                        "content": "got the same output: with the exact same string too: \"hlwjeastjqwkof\" would appreciate someone\\'s help"
                    }
                ]
            },
            {
                "id": 1907804,
                "content": [
                    {
                        "username": "joshczipo",
                        "content": "2028 test casts buddy touch grass"
                    },
                    {
                        "username": "sergei99",
                        "content": "This separates the men from the boys.\\nLow amount of test data => any shoddy job runs at 1 ms.\\nHigh amount of test data => we see a dispersion."
                    },
                    {
                        "username": "ares22121999",
                        "content": "https://leetcode.com/problems/bitwise-and-of-numbers-range/ this question have 8269 cases XD"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Typical those who are always ready to stay in the office upto next day, cuz they don\\'t have any hobbies.\\n\\nNow I know they stay in the office to write 2028 testcases for leetcode. \\nThe badge \\'Stapler of the month\\' is unlocked. jajajaja"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Feels good to be able to solve these problems, atleast with the most basic method considering there was a time when I couldn\\'t figure out how to even start approaching the problem. Keep on keeping on guys!"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@mohantysatyajit57](/mohantysatyajit57) Dynamic programming, this is a very common type of problem."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@mohantysatyajit57](/mohantysatyajit57) I\\'ve been solving the daily problems for 175 days now. Obviously I couldn\\'t figure out most problems in the beginning. But after lookin at and understanding solutions day after day I am now able to solve many problems by myself. I occasionally solve problems people mention being similar to the current one. I don\\'t stick to topics because in an interview, you really won\\'t be informed of the topics of the questions you\\'ll be solving. "
                    },
                    {
                        "username": "mohantysatyajit57",
                        "content": "What topics did you practice in order to figure out what this problem was about?\\n"
                    },
                    {
                        "username": "c4tdog",
                        "content": "test\\n\"dwmodizxvvbosxxw\"\\n[\"ox\",\"lb\",\"diz\",\"gu\",\"v\",\"ksv\",\"o\",\"nuq\",\"r\",\"txhe\",\"e\",\"wmo\",\"cehy\",\"tskz\",\"ds\",\"kzbu\"]\\nhow come the answer is 7? I can only see this way (with 8 chars left)\\nd <b>wmo</b> <b>diz</b> xv <b>v</b> b <b>o</b> sxxw"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just split the input string to halves and execute each half separately. Take the failing half and repeat the procedure. At 4-5 chars you will be able to see the problem instantly. If not, repeat the same thing with the dictionary array."
                    },
                    {
                        "username": "just_ayush",
                        "content": "v is present two times"
                    },
                    {
                        "username": "sakshi_17",
                        "content": "v is deleted two times. So for input - [eev] and dictionary [e] , dict contains only distinct words but all occurrences of word can be deleted."
                    },
                    {
                        "username": "user8307St",
                        "content": "d **wmo** **diz** x **v** **v** b **o** sxxw !"
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@qutequbit](/qutequbit) leetcode is not considered for leetscode. \"leet\" is a different word in dictionary and \"code\" is a different word in the dictionary and \"leetcode\" is broken into \"leet\" and \"code\" which is then considered as the two words in the dictionary."
                    },
                    {
                        "username": "Qnide",
                        "content": "Sort the dictionary in descending order def len"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@6leet](/6leet) how can one not see that. feeling dumb after seeing your comment. thank you."
                    },
                    {
                        "username": "Baymax_",
                        "content": "[@_Anurag_Singhal_](/_Anurag_Singhal_) \"non-overlapping substrings\" is way different from \"can use  dictionary words multiple times\" (even though it is not mentioned)"
                    },
                    {
                        "username": "caleb-mabry",
                        "content": "[@6leet](/6leet) You have no idea how long I have been trying to figure out what was going on. Thanks for this!"
                    },
                    {
                        "username": "_Anurag_Singhal_",
                        "content": "but the questions says non-overlapping substrings!"
                    },
                    {
                        "username": "6leet",
                        "content": "there are two v"
                    },
                    {
                        "username": "anwendeng",
                        "content": "I like DP much more than bit counting.\nAfter usual DP can try DP+Trie! more challenging."
                    },
                    {
                        "username": "sergei99",
                        "content": "Tries ruthlessly beat any other collections here. I see the execution time top is all involving tries.\\nSpent 4 hours debugging my trie and didn\\'t regret: 40 ms, absolute top for the time being, for the first submission.\\nStill need to improve its memory consumption though. Went a simple way to avoid costly node reallocations, it helped to an extent in another task, but here it takes 76 Mb vs 64 Mb of an STL hash set... what a shame."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "[@anwendeng](/anwendeng)  Thanks! Will give it try for sure!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@akash_vannam](/akash_vannam) Trie is also hard for me. My DP is however a little bit different from other. I don't use hash table. Try a double for loop , i varies over the indexes of s , j varies over indexes of dictionary. Inside the loop  use  just substr, find, rfind in C++ string.  I hope that it is useful."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "I initially thought about tries first, then saw that greedy wouldn\\'t work here. Then, tried dp but wasn\\'t able to write recursion. I struggle alot to come up with an alternative approach when an approach intuitively comes up and I am not able to fully complete it. Any tips? I always see you in daily challenges discussion aceing every question, when I get stuck your hints help me alot."
                    },
                    {
                        "username": "sheshnathverma",
                        "content": "I think description should mention, we are allowed to reuse the dictionary word multiple time.\\n\\nIt took lot of time to realize :(\\n\\nTest Case: \"leetsleetscode\", [\"leets\", \"code\"]"
                    },
                    {
                        "username": "NagaNikhil",
                        "content": "Thanks for pointing it out"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[139. Word Break] similar problem  (https://leetcode.com/problems/word-break/)"
                    },
                    {
                        "username": "user3429v",
                        "content": "this one[2707] is a little bit harder"
                    },
                    {
                        "username": "aman1320",
                        "content": "(Time Limit Exceeded )Test Case 2024/2024\\ns=\\n\\nwho the hell putted this in the test case???????"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "It means your time limit exceeded, don\\'t check that testcase, as that one isn\\'t a testcase. You reduce the time. The overall time probably exceeds the time limit."
                    },
                    {
                        "username": "aquaman55",
                        "content": "PUTTED must be a golfer "
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Hint:\n\nWe know that substring of `s` must exist in dictionary to be able to break. The substring may start from index 0. If it doesn't then the index 0 is the leftover and so on.\n\nMore generally, for every substring there are a 2 choices:\n\n1) this substring is an leftover then `len(substring) + mininmumLeftOver(rest of the string)`\n 2) this substring is part of a substring of string from dictionary, then `0(no leftover) + mininmumLeftOver(rest of the string)`. \n\nWe shall pick the minimum from these 2 choices."
                    },
                    {
                        "username": "Beorn",
                        "content": "Knapsack  problem"
                    },
                    {
                        "username": "shivansh_07",
                        "content": "Like this take and not_take it is similar to knapsack\\n\\nclass Solution {\\npublic:\\nint mini = INT_MAX;\\n    int func(int index, string s , unordered_map<string ,  int> &mp , vector<int> &dp){\\n\\n        if(index == s.size()) return 0;\\n\\n        if(dp[index]!=-1) return dp[index];\\n        \\n        int not_take = 1 + func(index + 1 , s ,mp,dp);\\n        int take = INT_MAX;\\n        for(int i = index; i < s.size();i++){\\n            string t1 = s.substr(index , i - index + 1);\\n            \\n            if(mp.find(t1)!=mp.end()) take = min(take , 0+ func(i+1 , s , mp,dp));\\n            \\n        }\\n\\n        return dp[index] = min(take , not_take);\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<string,int> mp;\\n\\n        vector<int> dp(s.size() + 1 , -1);\\n        for(auto it : dictionary) mp[it]++;\\n\\n        return func(0 , s , mp,dp);\\n    }\\n};"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "how\\n"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "I\\'ve stuck on 1988 test case:\\ns = \"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\ndictionary = \"\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"\"\\n\\nOutput = 14\\nExpected = 15\\n\\nWhy 15 is expected? By the end, my solution produces the following string: \"hlwjeastjqwkof\". Isn\\'t it correct?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@desuraj110](/desuraj110) because smaller data set makes it easier to locate the bug in the code."
                    },
                    {
                        "username": "desuraj110",
                        "content": "same case i stuck too"
                    },
                    {
                        "username": "desuraj110",
                        "content": "[@sergei99](/sergei99) why split in halves ?? "
                    },
                    {
                        "username": "sans_102",
                        "content": "\"hlwxjeastjqwkof\" this is the string left after doing the operations. there is x between w and j (4th place). string is of length 15."
                    },
                    {
                        "username": "sergei99",
                        "content": "Split the input string to halves and execute each half separately. Take the failing half and repeat the procedure. At 4-5 chars you will be able to see the problem instantly. If not, repeat the same thing with the dictionary array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\n```\nazvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\nazv\n   zul\n    u\n          wobow\n            b\n               i\n                 i\n                  yeb\n                    b\n                        kecv\n                                 maqnv\n                                    n\n                                      na\n                                      n\n                                         maqnv\n                                            n\n```\nWith `15` extra characters you can produce this:\n```\nazv zul _ _ _ _ wobow i _ i yeb _ _ _ kecv _ _ _ _ _ maqnv na _ maqnv _\n```"
                    },
                    {
                        "username": "Alexander238",
                        "content": "Yep same, \"hlwjeastjqwkof\" is the word I get with Output 14 and expected 15..."
                    },
                    {
                        "username": "Labib2003",
                        "content": "same case my friend, tried to solve it as a greedy problem "
                    },
                    {
                        "username": "supperr-coder",
                        "content": "got the same output: with the exact same string too: \"hlwjeastjqwkof\" would appreciate someone\\'s help"
                    }
                ]
            },
            {
                "id": 2040552,
                "content": [
                    {
                        "username": "joshczipo",
                        "content": "2028 test casts buddy touch grass"
                    },
                    {
                        "username": "sergei99",
                        "content": "This separates the men from the boys.\\nLow amount of test data => any shoddy job runs at 1 ms.\\nHigh amount of test data => we see a dispersion."
                    },
                    {
                        "username": "ares22121999",
                        "content": "https://leetcode.com/problems/bitwise-and-of-numbers-range/ this question have 8269 cases XD"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Typical those who are always ready to stay in the office upto next day, cuz they don\\'t have any hobbies.\\n\\nNow I know they stay in the office to write 2028 testcases for leetcode. \\nThe badge \\'Stapler of the month\\' is unlocked. jajajaja"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Feels good to be able to solve these problems, atleast with the most basic method considering there was a time when I couldn\\'t figure out how to even start approaching the problem. Keep on keeping on guys!"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@mohantysatyajit57](/mohantysatyajit57) Dynamic programming, this is a very common type of problem."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@mohantysatyajit57](/mohantysatyajit57) I\\'ve been solving the daily problems for 175 days now. Obviously I couldn\\'t figure out most problems in the beginning. But after lookin at and understanding solutions day after day I am now able to solve many problems by myself. I occasionally solve problems people mention being similar to the current one. I don\\'t stick to topics because in an interview, you really won\\'t be informed of the topics of the questions you\\'ll be solving. "
                    },
                    {
                        "username": "mohantysatyajit57",
                        "content": "What topics did you practice in order to figure out what this problem was about?\\n"
                    },
                    {
                        "username": "c4tdog",
                        "content": "test\\n\"dwmodizxvvbosxxw\"\\n[\"ox\",\"lb\",\"diz\",\"gu\",\"v\",\"ksv\",\"o\",\"nuq\",\"r\",\"txhe\",\"e\",\"wmo\",\"cehy\",\"tskz\",\"ds\",\"kzbu\"]\\nhow come the answer is 7? I can only see this way (with 8 chars left)\\nd <b>wmo</b> <b>diz</b> xv <b>v</b> b <b>o</b> sxxw"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just split the input string to halves and execute each half separately. Take the failing half and repeat the procedure. At 4-5 chars you will be able to see the problem instantly. If not, repeat the same thing with the dictionary array."
                    },
                    {
                        "username": "just_ayush",
                        "content": "v is present two times"
                    },
                    {
                        "username": "sakshi_17",
                        "content": "v is deleted two times. So for input - [eev] and dictionary [e] , dict contains only distinct words but all occurrences of word can be deleted."
                    },
                    {
                        "username": "user8307St",
                        "content": "d **wmo** **diz** x **v** **v** b **o** sxxw !"
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@qutequbit](/qutequbit) leetcode is not considered for leetscode. \"leet\" is a different word in dictionary and \"code\" is a different word in the dictionary and \"leetcode\" is broken into \"leet\" and \"code\" which is then considered as the two words in the dictionary."
                    },
                    {
                        "username": "Qnide",
                        "content": "Sort the dictionary in descending order def len"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@6leet](/6leet) how can one not see that. feeling dumb after seeing your comment. thank you."
                    },
                    {
                        "username": "Baymax_",
                        "content": "[@_Anurag_Singhal_](/_Anurag_Singhal_) \"non-overlapping substrings\" is way different from \"can use  dictionary words multiple times\" (even though it is not mentioned)"
                    },
                    {
                        "username": "caleb-mabry",
                        "content": "[@6leet](/6leet) You have no idea how long I have been trying to figure out what was going on. Thanks for this!"
                    },
                    {
                        "username": "_Anurag_Singhal_",
                        "content": "but the questions says non-overlapping substrings!"
                    },
                    {
                        "username": "6leet",
                        "content": "there are two v"
                    },
                    {
                        "username": "anwendeng",
                        "content": "I like DP much more than bit counting.\nAfter usual DP can try DP+Trie! more challenging."
                    },
                    {
                        "username": "sergei99",
                        "content": "Tries ruthlessly beat any other collections here. I see the execution time top is all involving tries.\\nSpent 4 hours debugging my trie and didn\\'t regret: 40 ms, absolute top for the time being, for the first submission.\\nStill need to improve its memory consumption though. Went a simple way to avoid costly node reallocations, it helped to an extent in another task, but here it takes 76 Mb vs 64 Mb of an STL hash set... what a shame."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "[@anwendeng](/anwendeng)  Thanks! Will give it try for sure!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@akash_vannam](/akash_vannam) Trie is also hard for me. My DP is however a little bit different from other. I don't use hash table. Try a double for loop , i varies over the indexes of s , j varies over indexes of dictionary. Inside the loop  use  just substr, find, rfind in C++ string.  I hope that it is useful."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "I initially thought about tries first, then saw that greedy wouldn\\'t work here. Then, tried dp but wasn\\'t able to write recursion. I struggle alot to come up with an alternative approach when an approach intuitively comes up and I am not able to fully complete it. Any tips? I always see you in daily challenges discussion aceing every question, when I get stuck your hints help me alot."
                    },
                    {
                        "username": "sheshnathverma",
                        "content": "I think description should mention, we are allowed to reuse the dictionary word multiple time.\\n\\nIt took lot of time to realize :(\\n\\nTest Case: \"leetsleetscode\", [\"leets\", \"code\"]"
                    },
                    {
                        "username": "NagaNikhil",
                        "content": "Thanks for pointing it out"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[139. Word Break] similar problem  (https://leetcode.com/problems/word-break/)"
                    },
                    {
                        "username": "user3429v",
                        "content": "this one[2707] is a little bit harder"
                    },
                    {
                        "username": "aman1320",
                        "content": "(Time Limit Exceeded )Test Case 2024/2024\\ns=\\n\\nwho the hell putted this in the test case???????"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "It means your time limit exceeded, don\\'t check that testcase, as that one isn\\'t a testcase. You reduce the time. The overall time probably exceeds the time limit."
                    },
                    {
                        "username": "aquaman55",
                        "content": "PUTTED must be a golfer "
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Hint:\n\nWe know that substring of `s` must exist in dictionary to be able to break. The substring may start from index 0. If it doesn't then the index 0 is the leftover and so on.\n\nMore generally, for every substring there are a 2 choices:\n\n1) this substring is an leftover then `len(substring) + mininmumLeftOver(rest of the string)`\n 2) this substring is part of a substring of string from dictionary, then `0(no leftover) + mininmumLeftOver(rest of the string)`. \n\nWe shall pick the minimum from these 2 choices."
                    },
                    {
                        "username": "Beorn",
                        "content": "Knapsack  problem"
                    },
                    {
                        "username": "shivansh_07",
                        "content": "Like this take and not_take it is similar to knapsack\\n\\nclass Solution {\\npublic:\\nint mini = INT_MAX;\\n    int func(int index, string s , unordered_map<string ,  int> &mp , vector<int> &dp){\\n\\n        if(index == s.size()) return 0;\\n\\n        if(dp[index]!=-1) return dp[index];\\n        \\n        int not_take = 1 + func(index + 1 , s ,mp,dp);\\n        int take = INT_MAX;\\n        for(int i = index; i < s.size();i++){\\n            string t1 = s.substr(index , i - index + 1);\\n            \\n            if(mp.find(t1)!=mp.end()) take = min(take , 0+ func(i+1 , s , mp,dp));\\n            \\n        }\\n\\n        return dp[index] = min(take , not_take);\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<string,int> mp;\\n\\n        vector<int> dp(s.size() + 1 , -1);\\n        for(auto it : dictionary) mp[it]++;\\n\\n        return func(0 , s , mp,dp);\\n    }\\n};"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "how\\n"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "I\\'ve stuck on 1988 test case:\\ns = \"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\ndictionary = \"\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"\"\\n\\nOutput = 14\\nExpected = 15\\n\\nWhy 15 is expected? By the end, my solution produces the following string: \"hlwjeastjqwkof\". Isn\\'t it correct?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@desuraj110](/desuraj110) because smaller data set makes it easier to locate the bug in the code."
                    },
                    {
                        "username": "desuraj110",
                        "content": "same case i stuck too"
                    },
                    {
                        "username": "desuraj110",
                        "content": "[@sergei99](/sergei99) why split in halves ?? "
                    },
                    {
                        "username": "sans_102",
                        "content": "\"hlwxjeastjqwkof\" this is the string left after doing the operations. there is x between w and j (4th place). string is of length 15."
                    },
                    {
                        "username": "sergei99",
                        "content": "Split the input string to halves and execute each half separately. Take the failing half and repeat the procedure. At 4-5 chars you will be able to see the problem instantly. If not, repeat the same thing with the dictionary array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\n```\nazvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\nazv\n   zul\n    u\n          wobow\n            b\n               i\n                 i\n                  yeb\n                    b\n                        kecv\n                                 maqnv\n                                    n\n                                      na\n                                      n\n                                         maqnv\n                                            n\n```\nWith `15` extra characters you can produce this:\n```\nazv zul _ _ _ _ wobow i _ i yeb _ _ _ kecv _ _ _ _ _ maqnv na _ maqnv _\n```"
                    },
                    {
                        "username": "Alexander238",
                        "content": "Yep same, \"hlwjeastjqwkof\" is the word I get with Output 14 and expected 15..."
                    },
                    {
                        "username": "Labib2003",
                        "content": "same case my friend, tried to solve it as a greedy problem "
                    },
                    {
                        "username": "supperr-coder",
                        "content": "got the same output: with the exact same string too: \"hlwjeastjqwkof\" would appreciate someone\\'s help"
                    }
                ]
            },
            {
                "id": 2040093,
                "content": [
                    {
                        "username": "joshczipo",
                        "content": "2028 test casts buddy touch grass"
                    },
                    {
                        "username": "sergei99",
                        "content": "This separates the men from the boys.\\nLow amount of test data => any shoddy job runs at 1 ms.\\nHigh amount of test data => we see a dispersion."
                    },
                    {
                        "username": "ares22121999",
                        "content": "https://leetcode.com/problems/bitwise-and-of-numbers-range/ this question have 8269 cases XD"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Typical those who are always ready to stay in the office upto next day, cuz they don\\'t have any hobbies.\\n\\nNow I know they stay in the office to write 2028 testcases for leetcode. \\nThe badge \\'Stapler of the month\\' is unlocked. jajajaja"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Feels good to be able to solve these problems, atleast with the most basic method considering there was a time when I couldn\\'t figure out how to even start approaching the problem. Keep on keeping on guys!"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@mohantysatyajit57](/mohantysatyajit57) Dynamic programming, this is a very common type of problem."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@mohantysatyajit57](/mohantysatyajit57) I\\'ve been solving the daily problems for 175 days now. Obviously I couldn\\'t figure out most problems in the beginning. But after lookin at and understanding solutions day after day I am now able to solve many problems by myself. I occasionally solve problems people mention being similar to the current one. I don\\'t stick to topics because in an interview, you really won\\'t be informed of the topics of the questions you\\'ll be solving. "
                    },
                    {
                        "username": "mohantysatyajit57",
                        "content": "What topics did you practice in order to figure out what this problem was about?\\n"
                    },
                    {
                        "username": "c4tdog",
                        "content": "test\\n\"dwmodizxvvbosxxw\"\\n[\"ox\",\"lb\",\"diz\",\"gu\",\"v\",\"ksv\",\"o\",\"nuq\",\"r\",\"txhe\",\"e\",\"wmo\",\"cehy\",\"tskz\",\"ds\",\"kzbu\"]\\nhow come the answer is 7? I can only see this way (with 8 chars left)\\nd <b>wmo</b> <b>diz</b> xv <b>v</b> b <b>o</b> sxxw"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just split the input string to halves and execute each half separately. Take the failing half and repeat the procedure. At 4-5 chars you will be able to see the problem instantly. If not, repeat the same thing with the dictionary array."
                    },
                    {
                        "username": "just_ayush",
                        "content": "v is present two times"
                    },
                    {
                        "username": "sakshi_17",
                        "content": "v is deleted two times. So for input - [eev] and dictionary [e] , dict contains only distinct words but all occurrences of word can be deleted."
                    },
                    {
                        "username": "user8307St",
                        "content": "d **wmo** **diz** x **v** **v** b **o** sxxw !"
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@qutequbit](/qutequbit) leetcode is not considered for leetscode. \"leet\" is a different word in dictionary and \"code\" is a different word in the dictionary and \"leetcode\" is broken into \"leet\" and \"code\" which is then considered as the two words in the dictionary."
                    },
                    {
                        "username": "Qnide",
                        "content": "Sort the dictionary in descending order def len"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@6leet](/6leet) how can one not see that. feeling dumb after seeing your comment. thank you."
                    },
                    {
                        "username": "Baymax_",
                        "content": "[@_Anurag_Singhal_](/_Anurag_Singhal_) \"non-overlapping substrings\" is way different from \"can use  dictionary words multiple times\" (even though it is not mentioned)"
                    },
                    {
                        "username": "caleb-mabry",
                        "content": "[@6leet](/6leet) You have no idea how long I have been trying to figure out what was going on. Thanks for this!"
                    },
                    {
                        "username": "_Anurag_Singhal_",
                        "content": "but the questions says non-overlapping substrings!"
                    },
                    {
                        "username": "6leet",
                        "content": "there are two v"
                    },
                    {
                        "username": "anwendeng",
                        "content": "I like DP much more than bit counting.\nAfter usual DP can try DP+Trie! more challenging."
                    },
                    {
                        "username": "sergei99",
                        "content": "Tries ruthlessly beat any other collections here. I see the execution time top is all involving tries.\\nSpent 4 hours debugging my trie and didn\\'t regret: 40 ms, absolute top for the time being, for the first submission.\\nStill need to improve its memory consumption though. Went a simple way to avoid costly node reallocations, it helped to an extent in another task, but here it takes 76 Mb vs 64 Mb of an STL hash set... what a shame."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "[@anwendeng](/anwendeng)  Thanks! Will give it try for sure!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@akash_vannam](/akash_vannam) Trie is also hard for me. My DP is however a little bit different from other. I don't use hash table. Try a double for loop , i varies over the indexes of s , j varies over indexes of dictionary. Inside the loop  use  just substr, find, rfind in C++ string.  I hope that it is useful."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "I initially thought about tries first, then saw that greedy wouldn\\'t work here. Then, tried dp but wasn\\'t able to write recursion. I struggle alot to come up with an alternative approach when an approach intuitively comes up and I am not able to fully complete it. Any tips? I always see you in daily challenges discussion aceing every question, when I get stuck your hints help me alot."
                    },
                    {
                        "username": "sheshnathverma",
                        "content": "I think description should mention, we are allowed to reuse the dictionary word multiple time.\\n\\nIt took lot of time to realize :(\\n\\nTest Case: \"leetsleetscode\", [\"leets\", \"code\"]"
                    },
                    {
                        "username": "NagaNikhil",
                        "content": "Thanks for pointing it out"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[139. Word Break] similar problem  (https://leetcode.com/problems/word-break/)"
                    },
                    {
                        "username": "user3429v",
                        "content": "this one[2707] is a little bit harder"
                    },
                    {
                        "username": "aman1320",
                        "content": "(Time Limit Exceeded )Test Case 2024/2024\\ns=\\n\\nwho the hell putted this in the test case???????"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "It means your time limit exceeded, don\\'t check that testcase, as that one isn\\'t a testcase. You reduce the time. The overall time probably exceeds the time limit."
                    },
                    {
                        "username": "aquaman55",
                        "content": "PUTTED must be a golfer "
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Hint:\n\nWe know that substring of `s` must exist in dictionary to be able to break. The substring may start from index 0. If it doesn't then the index 0 is the leftover and so on.\n\nMore generally, for every substring there are a 2 choices:\n\n1) this substring is an leftover then `len(substring) + mininmumLeftOver(rest of the string)`\n 2) this substring is part of a substring of string from dictionary, then `0(no leftover) + mininmumLeftOver(rest of the string)`. \n\nWe shall pick the minimum from these 2 choices."
                    },
                    {
                        "username": "Beorn",
                        "content": "Knapsack  problem"
                    },
                    {
                        "username": "shivansh_07",
                        "content": "Like this take and not_take it is similar to knapsack\\n\\nclass Solution {\\npublic:\\nint mini = INT_MAX;\\n    int func(int index, string s , unordered_map<string ,  int> &mp , vector<int> &dp){\\n\\n        if(index == s.size()) return 0;\\n\\n        if(dp[index]!=-1) return dp[index];\\n        \\n        int not_take = 1 + func(index + 1 , s ,mp,dp);\\n        int take = INT_MAX;\\n        for(int i = index; i < s.size();i++){\\n            string t1 = s.substr(index , i - index + 1);\\n            \\n            if(mp.find(t1)!=mp.end()) take = min(take , 0+ func(i+1 , s , mp,dp));\\n            \\n        }\\n\\n        return dp[index] = min(take , not_take);\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<string,int> mp;\\n\\n        vector<int> dp(s.size() + 1 , -1);\\n        for(auto it : dictionary) mp[it]++;\\n\\n        return func(0 , s , mp,dp);\\n    }\\n};"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "how\\n"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "I\\'ve stuck on 1988 test case:\\ns = \"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\ndictionary = \"\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"\"\\n\\nOutput = 14\\nExpected = 15\\n\\nWhy 15 is expected? By the end, my solution produces the following string: \"hlwjeastjqwkof\". Isn\\'t it correct?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@desuraj110](/desuraj110) because smaller data set makes it easier to locate the bug in the code."
                    },
                    {
                        "username": "desuraj110",
                        "content": "same case i stuck too"
                    },
                    {
                        "username": "desuraj110",
                        "content": "[@sergei99](/sergei99) why split in halves ?? "
                    },
                    {
                        "username": "sans_102",
                        "content": "\"hlwxjeastjqwkof\" this is the string left after doing the operations. there is x between w and j (4th place). string is of length 15."
                    },
                    {
                        "username": "sergei99",
                        "content": "Split the input string to halves and execute each half separately. Take the failing half and repeat the procedure. At 4-5 chars you will be able to see the problem instantly. If not, repeat the same thing with the dictionary array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\n```\nazvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\nazv\n   zul\n    u\n          wobow\n            b\n               i\n                 i\n                  yeb\n                    b\n                        kecv\n                                 maqnv\n                                    n\n                                      na\n                                      n\n                                         maqnv\n                                            n\n```\nWith `15` extra characters you can produce this:\n```\nazv zul _ _ _ _ wobow i _ i yeb _ _ _ kecv _ _ _ _ _ maqnv na _ maqnv _\n```"
                    },
                    {
                        "username": "Alexander238",
                        "content": "Yep same, \"hlwjeastjqwkof\" is the word I get with Output 14 and expected 15..."
                    },
                    {
                        "username": "Labib2003",
                        "content": "same case my friend, tried to solve it as a greedy problem "
                    },
                    {
                        "username": "supperr-coder",
                        "content": "got the same output: with the exact same string too: \"hlwjeastjqwkof\" would appreciate someone\\'s help"
                    }
                ]
            },
            {
                "id": 2040163,
                "content": [
                    {
                        "username": "joshczipo",
                        "content": "2028 test casts buddy touch grass"
                    },
                    {
                        "username": "sergei99",
                        "content": "This separates the men from the boys.\\nLow amount of test data => any shoddy job runs at 1 ms.\\nHigh amount of test data => we see a dispersion."
                    },
                    {
                        "username": "ares22121999",
                        "content": "https://leetcode.com/problems/bitwise-and-of-numbers-range/ this question have 8269 cases XD"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Typical those who are always ready to stay in the office upto next day, cuz they don\\'t have any hobbies.\\n\\nNow I know they stay in the office to write 2028 testcases for leetcode. \\nThe badge \\'Stapler of the month\\' is unlocked. jajajaja"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Feels good to be able to solve these problems, atleast with the most basic method considering there was a time when I couldn\\'t figure out how to even start approaching the problem. Keep on keeping on guys!"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@mohantysatyajit57](/mohantysatyajit57) Dynamic programming, this is a very common type of problem."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@mohantysatyajit57](/mohantysatyajit57) I\\'ve been solving the daily problems for 175 days now. Obviously I couldn\\'t figure out most problems in the beginning. But after lookin at and understanding solutions day after day I am now able to solve many problems by myself. I occasionally solve problems people mention being similar to the current one. I don\\'t stick to topics because in an interview, you really won\\'t be informed of the topics of the questions you\\'ll be solving. "
                    },
                    {
                        "username": "mohantysatyajit57",
                        "content": "What topics did you practice in order to figure out what this problem was about?\\n"
                    },
                    {
                        "username": "c4tdog",
                        "content": "test\\n\"dwmodizxvvbosxxw\"\\n[\"ox\",\"lb\",\"diz\",\"gu\",\"v\",\"ksv\",\"o\",\"nuq\",\"r\",\"txhe\",\"e\",\"wmo\",\"cehy\",\"tskz\",\"ds\",\"kzbu\"]\\nhow come the answer is 7? I can only see this way (with 8 chars left)\\nd <b>wmo</b> <b>diz</b> xv <b>v</b> b <b>o</b> sxxw"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just split the input string to halves and execute each half separately. Take the failing half and repeat the procedure. At 4-5 chars you will be able to see the problem instantly. If not, repeat the same thing with the dictionary array."
                    },
                    {
                        "username": "just_ayush",
                        "content": "v is present two times"
                    },
                    {
                        "username": "sakshi_17",
                        "content": "v is deleted two times. So for input - [eev] and dictionary [e] , dict contains only distinct words but all occurrences of word can be deleted."
                    },
                    {
                        "username": "user8307St",
                        "content": "d **wmo** **diz** x **v** **v** b **o** sxxw !"
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@qutequbit](/qutequbit) leetcode is not considered for leetscode. \"leet\" is a different word in dictionary and \"code\" is a different word in the dictionary and \"leetcode\" is broken into \"leet\" and \"code\" which is then considered as the two words in the dictionary."
                    },
                    {
                        "username": "Qnide",
                        "content": "Sort the dictionary in descending order def len"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@6leet](/6leet) how can one not see that. feeling dumb after seeing your comment. thank you."
                    },
                    {
                        "username": "Baymax_",
                        "content": "[@_Anurag_Singhal_](/_Anurag_Singhal_) \"non-overlapping substrings\" is way different from \"can use  dictionary words multiple times\" (even though it is not mentioned)"
                    },
                    {
                        "username": "caleb-mabry",
                        "content": "[@6leet](/6leet) You have no idea how long I have been trying to figure out what was going on. Thanks for this!"
                    },
                    {
                        "username": "_Anurag_Singhal_",
                        "content": "but the questions says non-overlapping substrings!"
                    },
                    {
                        "username": "6leet",
                        "content": "there are two v"
                    },
                    {
                        "username": "anwendeng",
                        "content": "I like DP much more than bit counting.\nAfter usual DP can try DP+Trie! more challenging."
                    },
                    {
                        "username": "sergei99",
                        "content": "Tries ruthlessly beat any other collections here. I see the execution time top is all involving tries.\\nSpent 4 hours debugging my trie and didn\\'t regret: 40 ms, absolute top for the time being, for the first submission.\\nStill need to improve its memory consumption though. Went a simple way to avoid costly node reallocations, it helped to an extent in another task, but here it takes 76 Mb vs 64 Mb of an STL hash set... what a shame."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "[@anwendeng](/anwendeng)  Thanks! Will give it try for sure!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@akash_vannam](/akash_vannam) Trie is also hard for me. My DP is however a little bit different from other. I don't use hash table. Try a double for loop , i varies over the indexes of s , j varies over indexes of dictionary. Inside the loop  use  just substr, find, rfind in C++ string.  I hope that it is useful."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "I initially thought about tries first, then saw that greedy wouldn\\'t work here. Then, tried dp but wasn\\'t able to write recursion. I struggle alot to come up with an alternative approach when an approach intuitively comes up and I am not able to fully complete it. Any tips? I always see you in daily challenges discussion aceing every question, when I get stuck your hints help me alot."
                    },
                    {
                        "username": "sheshnathverma",
                        "content": "I think description should mention, we are allowed to reuse the dictionary word multiple time.\\n\\nIt took lot of time to realize :(\\n\\nTest Case: \"leetsleetscode\", [\"leets\", \"code\"]"
                    },
                    {
                        "username": "NagaNikhil",
                        "content": "Thanks for pointing it out"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[139. Word Break] similar problem  (https://leetcode.com/problems/word-break/)"
                    },
                    {
                        "username": "user3429v",
                        "content": "this one[2707] is a little bit harder"
                    },
                    {
                        "username": "aman1320",
                        "content": "(Time Limit Exceeded )Test Case 2024/2024\\ns=\\n\\nwho the hell putted this in the test case???????"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "It means your time limit exceeded, don\\'t check that testcase, as that one isn\\'t a testcase. You reduce the time. The overall time probably exceeds the time limit."
                    },
                    {
                        "username": "aquaman55",
                        "content": "PUTTED must be a golfer "
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Hint:\n\nWe know that substring of `s` must exist in dictionary to be able to break. The substring may start from index 0. If it doesn't then the index 0 is the leftover and so on.\n\nMore generally, for every substring there are a 2 choices:\n\n1) this substring is an leftover then `len(substring) + mininmumLeftOver(rest of the string)`\n 2) this substring is part of a substring of string from dictionary, then `0(no leftover) + mininmumLeftOver(rest of the string)`. \n\nWe shall pick the minimum from these 2 choices."
                    },
                    {
                        "username": "Beorn",
                        "content": "Knapsack  problem"
                    },
                    {
                        "username": "shivansh_07",
                        "content": "Like this take and not_take it is similar to knapsack\\n\\nclass Solution {\\npublic:\\nint mini = INT_MAX;\\n    int func(int index, string s , unordered_map<string ,  int> &mp , vector<int> &dp){\\n\\n        if(index == s.size()) return 0;\\n\\n        if(dp[index]!=-1) return dp[index];\\n        \\n        int not_take = 1 + func(index + 1 , s ,mp,dp);\\n        int take = INT_MAX;\\n        for(int i = index; i < s.size();i++){\\n            string t1 = s.substr(index , i - index + 1);\\n            \\n            if(mp.find(t1)!=mp.end()) take = min(take , 0+ func(i+1 , s , mp,dp));\\n            \\n        }\\n\\n        return dp[index] = min(take , not_take);\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<string,int> mp;\\n\\n        vector<int> dp(s.size() + 1 , -1);\\n        for(auto it : dictionary) mp[it]++;\\n\\n        return func(0 , s , mp,dp);\\n    }\\n};"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "how\\n"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "I\\'ve stuck on 1988 test case:\\ns = \"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\ndictionary = \"\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"\"\\n\\nOutput = 14\\nExpected = 15\\n\\nWhy 15 is expected? By the end, my solution produces the following string: \"hlwjeastjqwkof\". Isn\\'t it correct?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@desuraj110](/desuraj110) because smaller data set makes it easier to locate the bug in the code."
                    },
                    {
                        "username": "desuraj110",
                        "content": "same case i stuck too"
                    },
                    {
                        "username": "desuraj110",
                        "content": "[@sergei99](/sergei99) why split in halves ?? "
                    },
                    {
                        "username": "sans_102",
                        "content": "\"hlwxjeastjqwkof\" this is the string left after doing the operations. there is x between w and j (4th place). string is of length 15."
                    },
                    {
                        "username": "sergei99",
                        "content": "Split the input string to halves and execute each half separately. Take the failing half and repeat the procedure. At 4-5 chars you will be able to see the problem instantly. If not, repeat the same thing with the dictionary array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\n```\nazvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\nazv\n   zul\n    u\n          wobow\n            b\n               i\n                 i\n                  yeb\n                    b\n                        kecv\n                                 maqnv\n                                    n\n                                      na\n                                      n\n                                         maqnv\n                                            n\n```\nWith `15` extra characters you can produce this:\n```\nazv zul _ _ _ _ wobow i _ i yeb _ _ _ kecv _ _ _ _ _ maqnv na _ maqnv _\n```"
                    },
                    {
                        "username": "Alexander238",
                        "content": "Yep same, \"hlwjeastjqwkof\" is the word I get with Output 14 and expected 15..."
                    },
                    {
                        "username": "Labib2003",
                        "content": "same case my friend, tried to solve it as a greedy problem "
                    },
                    {
                        "username": "supperr-coder",
                        "content": "got the same output: with the exact same string too: \"hlwjeastjqwkof\" would appreciate someone\\'s help"
                    }
                ]
            },
            {
                "id": 1907499,
                "content": [
                    {
                        "username": "joshczipo",
                        "content": "2028 test casts buddy touch grass"
                    },
                    {
                        "username": "sergei99",
                        "content": "This separates the men from the boys.\\nLow amount of test data => any shoddy job runs at 1 ms.\\nHigh amount of test data => we see a dispersion."
                    },
                    {
                        "username": "ares22121999",
                        "content": "https://leetcode.com/problems/bitwise-and-of-numbers-range/ this question have 8269 cases XD"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Typical those who are always ready to stay in the office upto next day, cuz they don\\'t have any hobbies.\\n\\nNow I know they stay in the office to write 2028 testcases for leetcode. \\nThe badge \\'Stapler of the month\\' is unlocked. jajajaja"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Feels good to be able to solve these problems, atleast with the most basic method considering there was a time when I couldn\\'t figure out how to even start approaching the problem. Keep on keeping on guys!"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@mohantysatyajit57](/mohantysatyajit57) Dynamic programming, this is a very common type of problem."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@mohantysatyajit57](/mohantysatyajit57) I\\'ve been solving the daily problems for 175 days now. Obviously I couldn\\'t figure out most problems in the beginning. But after lookin at and understanding solutions day after day I am now able to solve many problems by myself. I occasionally solve problems people mention being similar to the current one. I don\\'t stick to topics because in an interview, you really won\\'t be informed of the topics of the questions you\\'ll be solving. "
                    },
                    {
                        "username": "mohantysatyajit57",
                        "content": "What topics did you practice in order to figure out what this problem was about?\\n"
                    },
                    {
                        "username": "c4tdog",
                        "content": "test\\n\"dwmodizxvvbosxxw\"\\n[\"ox\",\"lb\",\"diz\",\"gu\",\"v\",\"ksv\",\"o\",\"nuq\",\"r\",\"txhe\",\"e\",\"wmo\",\"cehy\",\"tskz\",\"ds\",\"kzbu\"]\\nhow come the answer is 7? I can only see this way (with 8 chars left)\\nd <b>wmo</b> <b>diz</b> xv <b>v</b> b <b>o</b> sxxw"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just split the input string to halves and execute each half separately. Take the failing half and repeat the procedure. At 4-5 chars you will be able to see the problem instantly. If not, repeat the same thing with the dictionary array."
                    },
                    {
                        "username": "just_ayush",
                        "content": "v is present two times"
                    },
                    {
                        "username": "sakshi_17",
                        "content": "v is deleted two times. So for input - [eev] and dictionary [e] , dict contains only distinct words but all occurrences of word can be deleted."
                    },
                    {
                        "username": "user8307St",
                        "content": "d **wmo** **diz** x **v** **v** b **o** sxxw !"
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@qutequbit](/qutequbit) leetcode is not considered for leetscode. \"leet\" is a different word in dictionary and \"code\" is a different word in the dictionary and \"leetcode\" is broken into \"leet\" and \"code\" which is then considered as the two words in the dictionary."
                    },
                    {
                        "username": "Qnide",
                        "content": "Sort the dictionary in descending order def len"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@6leet](/6leet) how can one not see that. feeling dumb after seeing your comment. thank you."
                    },
                    {
                        "username": "Baymax_",
                        "content": "[@_Anurag_Singhal_](/_Anurag_Singhal_) \"non-overlapping substrings\" is way different from \"can use  dictionary words multiple times\" (even though it is not mentioned)"
                    },
                    {
                        "username": "caleb-mabry",
                        "content": "[@6leet](/6leet) You have no idea how long I have been trying to figure out what was going on. Thanks for this!"
                    },
                    {
                        "username": "_Anurag_Singhal_",
                        "content": "but the questions says non-overlapping substrings!"
                    },
                    {
                        "username": "6leet",
                        "content": "there are two v"
                    },
                    {
                        "username": "anwendeng",
                        "content": "I like DP much more than bit counting.\nAfter usual DP can try DP+Trie! more challenging."
                    },
                    {
                        "username": "sergei99",
                        "content": "Tries ruthlessly beat any other collections here. I see the execution time top is all involving tries.\\nSpent 4 hours debugging my trie and didn\\'t regret: 40 ms, absolute top for the time being, for the first submission.\\nStill need to improve its memory consumption though. Went a simple way to avoid costly node reallocations, it helped to an extent in another task, but here it takes 76 Mb vs 64 Mb of an STL hash set... what a shame."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "[@anwendeng](/anwendeng)  Thanks! Will give it try for sure!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@akash_vannam](/akash_vannam) Trie is also hard for me. My DP is however a little bit different from other. I don't use hash table. Try a double for loop , i varies over the indexes of s , j varies over indexes of dictionary. Inside the loop  use  just substr, find, rfind in C++ string.  I hope that it is useful."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "I initially thought about tries first, then saw that greedy wouldn\\'t work here. Then, tried dp but wasn\\'t able to write recursion. I struggle alot to come up with an alternative approach when an approach intuitively comes up and I am not able to fully complete it. Any tips? I always see you in daily challenges discussion aceing every question, when I get stuck your hints help me alot."
                    },
                    {
                        "username": "sheshnathverma",
                        "content": "I think description should mention, we are allowed to reuse the dictionary word multiple time.\\n\\nIt took lot of time to realize :(\\n\\nTest Case: \"leetsleetscode\", [\"leets\", \"code\"]"
                    },
                    {
                        "username": "NagaNikhil",
                        "content": "Thanks for pointing it out"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[139. Word Break] similar problem  (https://leetcode.com/problems/word-break/)"
                    },
                    {
                        "username": "user3429v",
                        "content": "this one[2707] is a little bit harder"
                    },
                    {
                        "username": "aman1320",
                        "content": "(Time Limit Exceeded )Test Case 2024/2024\\ns=\\n\\nwho the hell putted this in the test case???????"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "It means your time limit exceeded, don\\'t check that testcase, as that one isn\\'t a testcase. You reduce the time. The overall time probably exceeds the time limit."
                    },
                    {
                        "username": "aquaman55",
                        "content": "PUTTED must be a golfer "
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Hint:\n\nWe know that substring of `s` must exist in dictionary to be able to break. The substring may start from index 0. If it doesn't then the index 0 is the leftover and so on.\n\nMore generally, for every substring there are a 2 choices:\n\n1) this substring is an leftover then `len(substring) + mininmumLeftOver(rest of the string)`\n 2) this substring is part of a substring of string from dictionary, then `0(no leftover) + mininmumLeftOver(rest of the string)`. \n\nWe shall pick the minimum from these 2 choices."
                    },
                    {
                        "username": "Beorn",
                        "content": "Knapsack  problem"
                    },
                    {
                        "username": "shivansh_07",
                        "content": "Like this take and not_take it is similar to knapsack\\n\\nclass Solution {\\npublic:\\nint mini = INT_MAX;\\n    int func(int index, string s , unordered_map<string ,  int> &mp , vector<int> &dp){\\n\\n        if(index == s.size()) return 0;\\n\\n        if(dp[index]!=-1) return dp[index];\\n        \\n        int not_take = 1 + func(index + 1 , s ,mp,dp);\\n        int take = INT_MAX;\\n        for(int i = index; i < s.size();i++){\\n            string t1 = s.substr(index , i - index + 1);\\n            \\n            if(mp.find(t1)!=mp.end()) take = min(take , 0+ func(i+1 , s , mp,dp));\\n            \\n        }\\n\\n        return dp[index] = min(take , not_take);\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<string,int> mp;\\n\\n        vector<int> dp(s.size() + 1 , -1);\\n        for(auto it : dictionary) mp[it]++;\\n\\n        return func(0 , s , mp,dp);\\n    }\\n};"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "how\\n"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "I\\'ve stuck on 1988 test case:\\ns = \"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\ndictionary = \"\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"\"\\n\\nOutput = 14\\nExpected = 15\\n\\nWhy 15 is expected? By the end, my solution produces the following string: \"hlwjeastjqwkof\". Isn\\'t it correct?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@desuraj110](/desuraj110) because smaller data set makes it easier to locate the bug in the code."
                    },
                    {
                        "username": "desuraj110",
                        "content": "same case i stuck too"
                    },
                    {
                        "username": "desuraj110",
                        "content": "[@sergei99](/sergei99) why split in halves ?? "
                    },
                    {
                        "username": "sans_102",
                        "content": "\"hlwxjeastjqwkof\" this is the string left after doing the operations. there is x between w and j (4th place). string is of length 15."
                    },
                    {
                        "username": "sergei99",
                        "content": "Split the input string to halves and execute each half separately. Take the failing half and repeat the procedure. At 4-5 chars you will be able to see the problem instantly. If not, repeat the same thing with the dictionary array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\n```\nazvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\nazv\n   zul\n    u\n          wobow\n            b\n               i\n                 i\n                  yeb\n                    b\n                        kecv\n                                 maqnv\n                                    n\n                                      na\n                                      n\n                                         maqnv\n                                            n\n```\nWith `15` extra characters you can produce this:\n```\nazv zul _ _ _ _ wobow i _ i yeb _ _ _ kecv _ _ _ _ _ maqnv na _ maqnv _\n```"
                    },
                    {
                        "username": "Alexander238",
                        "content": "Yep same, \"hlwjeastjqwkof\" is the word I get with Output 14 and expected 15..."
                    },
                    {
                        "username": "Labib2003",
                        "content": "same case my friend, tried to solve it as a greedy problem "
                    },
                    {
                        "username": "supperr-coder",
                        "content": "got the same output: with the exact same string too: \"hlwjeastjqwkof\" would appreciate someone\\'s help"
                    }
                ]
            },
            {
                "id": 2040003,
                "content": [
                    {
                        "username": "joshczipo",
                        "content": "2028 test casts buddy touch grass"
                    },
                    {
                        "username": "sergei99",
                        "content": "This separates the men from the boys.\\nLow amount of test data => any shoddy job runs at 1 ms.\\nHigh amount of test data => we see a dispersion."
                    },
                    {
                        "username": "ares22121999",
                        "content": "https://leetcode.com/problems/bitwise-and-of-numbers-range/ this question have 8269 cases XD"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Typical those who are always ready to stay in the office upto next day, cuz they don\\'t have any hobbies.\\n\\nNow I know they stay in the office to write 2028 testcases for leetcode. \\nThe badge \\'Stapler of the month\\' is unlocked. jajajaja"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Feels good to be able to solve these problems, atleast with the most basic method considering there was a time when I couldn\\'t figure out how to even start approaching the problem. Keep on keeping on guys!"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@mohantysatyajit57](/mohantysatyajit57) Dynamic programming, this is a very common type of problem."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@mohantysatyajit57](/mohantysatyajit57) I\\'ve been solving the daily problems for 175 days now. Obviously I couldn\\'t figure out most problems in the beginning. But after lookin at and understanding solutions day after day I am now able to solve many problems by myself. I occasionally solve problems people mention being similar to the current one. I don\\'t stick to topics because in an interview, you really won\\'t be informed of the topics of the questions you\\'ll be solving. "
                    },
                    {
                        "username": "mohantysatyajit57",
                        "content": "What topics did you practice in order to figure out what this problem was about?\\n"
                    },
                    {
                        "username": "c4tdog",
                        "content": "test\\n\"dwmodizxvvbosxxw\"\\n[\"ox\",\"lb\",\"diz\",\"gu\",\"v\",\"ksv\",\"o\",\"nuq\",\"r\",\"txhe\",\"e\",\"wmo\",\"cehy\",\"tskz\",\"ds\",\"kzbu\"]\\nhow come the answer is 7? I can only see this way (with 8 chars left)\\nd <b>wmo</b> <b>diz</b> xv <b>v</b> b <b>o</b> sxxw"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just split the input string to halves and execute each half separately. Take the failing half and repeat the procedure. At 4-5 chars you will be able to see the problem instantly. If not, repeat the same thing with the dictionary array."
                    },
                    {
                        "username": "just_ayush",
                        "content": "v is present two times"
                    },
                    {
                        "username": "sakshi_17",
                        "content": "v is deleted two times. So for input - [eev] and dictionary [e] , dict contains only distinct words but all occurrences of word can be deleted."
                    },
                    {
                        "username": "user8307St",
                        "content": "d **wmo** **diz** x **v** **v** b **o** sxxw !"
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@qutequbit](/qutequbit) leetcode is not considered for leetscode. \"leet\" is a different word in dictionary and \"code\" is a different word in the dictionary and \"leetcode\" is broken into \"leet\" and \"code\" which is then considered as the two words in the dictionary."
                    },
                    {
                        "username": "Qnide",
                        "content": "Sort the dictionary in descending order def len"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@6leet](/6leet) how can one not see that. feeling dumb after seeing your comment. thank you."
                    },
                    {
                        "username": "Baymax_",
                        "content": "[@_Anurag_Singhal_](/_Anurag_Singhal_) \"non-overlapping substrings\" is way different from \"can use  dictionary words multiple times\" (even though it is not mentioned)"
                    },
                    {
                        "username": "caleb-mabry",
                        "content": "[@6leet](/6leet) You have no idea how long I have been trying to figure out what was going on. Thanks for this!"
                    },
                    {
                        "username": "_Anurag_Singhal_",
                        "content": "but the questions says non-overlapping substrings!"
                    },
                    {
                        "username": "6leet",
                        "content": "there are two v"
                    },
                    {
                        "username": "anwendeng",
                        "content": "I like DP much more than bit counting.\nAfter usual DP can try DP+Trie! more challenging."
                    },
                    {
                        "username": "sergei99",
                        "content": "Tries ruthlessly beat any other collections here. I see the execution time top is all involving tries.\\nSpent 4 hours debugging my trie and didn\\'t regret: 40 ms, absolute top for the time being, for the first submission.\\nStill need to improve its memory consumption though. Went a simple way to avoid costly node reallocations, it helped to an extent in another task, but here it takes 76 Mb vs 64 Mb of an STL hash set... what a shame."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "[@anwendeng](/anwendeng)  Thanks! Will give it try for sure!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@akash_vannam](/akash_vannam) Trie is also hard for me. My DP is however a little bit different from other. I don't use hash table. Try a double for loop , i varies over the indexes of s , j varies over indexes of dictionary. Inside the loop  use  just substr, find, rfind in C++ string.  I hope that it is useful."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "I initially thought about tries first, then saw that greedy wouldn\\'t work here. Then, tried dp but wasn\\'t able to write recursion. I struggle alot to come up with an alternative approach when an approach intuitively comes up and I am not able to fully complete it. Any tips? I always see you in daily challenges discussion aceing every question, when I get stuck your hints help me alot."
                    },
                    {
                        "username": "sheshnathverma",
                        "content": "I think description should mention, we are allowed to reuse the dictionary word multiple time.\\n\\nIt took lot of time to realize :(\\n\\nTest Case: \"leetsleetscode\", [\"leets\", \"code\"]"
                    },
                    {
                        "username": "NagaNikhil",
                        "content": "Thanks for pointing it out"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[139. Word Break] similar problem  (https://leetcode.com/problems/word-break/)"
                    },
                    {
                        "username": "user3429v",
                        "content": "this one[2707] is a little bit harder"
                    },
                    {
                        "username": "aman1320",
                        "content": "(Time Limit Exceeded )Test Case 2024/2024\\ns=\\n\\nwho the hell putted this in the test case???????"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "It means your time limit exceeded, don\\'t check that testcase, as that one isn\\'t a testcase. You reduce the time. The overall time probably exceeds the time limit."
                    },
                    {
                        "username": "aquaman55",
                        "content": "PUTTED must be a golfer "
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Hint:\n\nWe know that substring of `s` must exist in dictionary to be able to break. The substring may start from index 0. If it doesn't then the index 0 is the leftover and so on.\n\nMore generally, for every substring there are a 2 choices:\n\n1) this substring is an leftover then `len(substring) + mininmumLeftOver(rest of the string)`\n 2) this substring is part of a substring of string from dictionary, then `0(no leftover) + mininmumLeftOver(rest of the string)`. \n\nWe shall pick the minimum from these 2 choices."
                    },
                    {
                        "username": "Beorn",
                        "content": "Knapsack  problem"
                    },
                    {
                        "username": "shivansh_07",
                        "content": "Like this take and not_take it is similar to knapsack\\n\\nclass Solution {\\npublic:\\nint mini = INT_MAX;\\n    int func(int index, string s , unordered_map<string ,  int> &mp , vector<int> &dp){\\n\\n        if(index == s.size()) return 0;\\n\\n        if(dp[index]!=-1) return dp[index];\\n        \\n        int not_take = 1 + func(index + 1 , s ,mp,dp);\\n        int take = INT_MAX;\\n        for(int i = index; i < s.size();i++){\\n            string t1 = s.substr(index , i - index + 1);\\n            \\n            if(mp.find(t1)!=mp.end()) take = min(take , 0+ func(i+1 , s , mp,dp));\\n            \\n        }\\n\\n        return dp[index] = min(take , not_take);\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<string,int> mp;\\n\\n        vector<int> dp(s.size() + 1 , -1);\\n        for(auto it : dictionary) mp[it]++;\\n\\n        return func(0 , s , mp,dp);\\n    }\\n};"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "how\\n"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "I\\'ve stuck on 1988 test case:\\ns = \"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\ndictionary = \"\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"\"\\n\\nOutput = 14\\nExpected = 15\\n\\nWhy 15 is expected? By the end, my solution produces the following string: \"hlwjeastjqwkof\". Isn\\'t it correct?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@desuraj110](/desuraj110) because smaller data set makes it easier to locate the bug in the code."
                    },
                    {
                        "username": "desuraj110",
                        "content": "same case i stuck too"
                    },
                    {
                        "username": "desuraj110",
                        "content": "[@sergei99](/sergei99) why split in halves ?? "
                    },
                    {
                        "username": "sans_102",
                        "content": "\"hlwxjeastjqwkof\" this is the string left after doing the operations. there is x between w and j (4th place). string is of length 15."
                    },
                    {
                        "username": "sergei99",
                        "content": "Split the input string to halves and execute each half separately. Take the failing half and repeat the procedure. At 4-5 chars you will be able to see the problem instantly. If not, repeat the same thing with the dictionary array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\n```\nazvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\nazv\n   zul\n    u\n          wobow\n            b\n               i\n                 i\n                  yeb\n                    b\n                        kecv\n                                 maqnv\n                                    n\n                                      na\n                                      n\n                                         maqnv\n                                            n\n```\nWith `15` extra characters you can produce this:\n```\nazv zul _ _ _ _ wobow i _ i yeb _ _ _ kecv _ _ _ _ _ maqnv na _ maqnv _\n```"
                    },
                    {
                        "username": "Alexander238",
                        "content": "Yep same, \"hlwjeastjqwkof\" is the word I get with Output 14 and expected 15..."
                    },
                    {
                        "username": "Labib2003",
                        "content": "same case my friend, tried to solve it as a greedy problem "
                    },
                    {
                        "username": "supperr-coder",
                        "content": "got the same output: with the exact same string too: \"hlwjeastjqwkof\" would appreciate someone\\'s help"
                    }
                ]
            },
            {
                "id": 2040417,
                "content": [
                    {
                        "username": "joshczipo",
                        "content": "2028 test casts buddy touch grass"
                    },
                    {
                        "username": "sergei99",
                        "content": "This separates the men from the boys.\\nLow amount of test data => any shoddy job runs at 1 ms.\\nHigh amount of test data => we see a dispersion."
                    },
                    {
                        "username": "ares22121999",
                        "content": "https://leetcode.com/problems/bitwise-and-of-numbers-range/ this question have 8269 cases XD"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Typical those who are always ready to stay in the office upto next day, cuz they don\\'t have any hobbies.\\n\\nNow I know they stay in the office to write 2028 testcases for leetcode. \\nThe badge \\'Stapler of the month\\' is unlocked. jajajaja"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Feels good to be able to solve these problems, atleast with the most basic method considering there was a time when I couldn\\'t figure out how to even start approaching the problem. Keep on keeping on guys!"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@mohantysatyajit57](/mohantysatyajit57) Dynamic programming, this is a very common type of problem."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@mohantysatyajit57](/mohantysatyajit57) I\\'ve been solving the daily problems for 175 days now. Obviously I couldn\\'t figure out most problems in the beginning. But after lookin at and understanding solutions day after day I am now able to solve many problems by myself. I occasionally solve problems people mention being similar to the current one. I don\\'t stick to topics because in an interview, you really won\\'t be informed of the topics of the questions you\\'ll be solving. "
                    },
                    {
                        "username": "mohantysatyajit57",
                        "content": "What topics did you practice in order to figure out what this problem was about?\\n"
                    },
                    {
                        "username": "c4tdog",
                        "content": "test\\n\"dwmodizxvvbosxxw\"\\n[\"ox\",\"lb\",\"diz\",\"gu\",\"v\",\"ksv\",\"o\",\"nuq\",\"r\",\"txhe\",\"e\",\"wmo\",\"cehy\",\"tskz\",\"ds\",\"kzbu\"]\\nhow come the answer is 7? I can only see this way (with 8 chars left)\\nd <b>wmo</b> <b>diz</b> xv <b>v</b> b <b>o</b> sxxw"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just split the input string to halves and execute each half separately. Take the failing half and repeat the procedure. At 4-5 chars you will be able to see the problem instantly. If not, repeat the same thing with the dictionary array."
                    },
                    {
                        "username": "just_ayush",
                        "content": "v is present two times"
                    },
                    {
                        "username": "sakshi_17",
                        "content": "v is deleted two times. So for input - [eev] and dictionary [e] , dict contains only distinct words but all occurrences of word can be deleted."
                    },
                    {
                        "username": "user8307St",
                        "content": "d **wmo** **diz** x **v** **v** b **o** sxxw !"
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@qutequbit](/qutequbit) leetcode is not considered for leetscode. \"leet\" is a different word in dictionary and \"code\" is a different word in the dictionary and \"leetcode\" is broken into \"leet\" and \"code\" which is then considered as the two words in the dictionary."
                    },
                    {
                        "username": "Qnide",
                        "content": "Sort the dictionary in descending order def len"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@6leet](/6leet) how can one not see that. feeling dumb after seeing your comment. thank you."
                    },
                    {
                        "username": "Baymax_",
                        "content": "[@_Anurag_Singhal_](/_Anurag_Singhal_) \"non-overlapping substrings\" is way different from \"can use  dictionary words multiple times\" (even though it is not mentioned)"
                    },
                    {
                        "username": "caleb-mabry",
                        "content": "[@6leet](/6leet) You have no idea how long I have been trying to figure out what was going on. Thanks for this!"
                    },
                    {
                        "username": "_Anurag_Singhal_",
                        "content": "but the questions says non-overlapping substrings!"
                    },
                    {
                        "username": "6leet",
                        "content": "there are two v"
                    },
                    {
                        "username": "anwendeng",
                        "content": "I like DP much more than bit counting.\nAfter usual DP can try DP+Trie! more challenging."
                    },
                    {
                        "username": "sergei99",
                        "content": "Tries ruthlessly beat any other collections here. I see the execution time top is all involving tries.\\nSpent 4 hours debugging my trie and didn\\'t regret: 40 ms, absolute top for the time being, for the first submission.\\nStill need to improve its memory consumption though. Went a simple way to avoid costly node reallocations, it helped to an extent in another task, but here it takes 76 Mb vs 64 Mb of an STL hash set... what a shame."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "[@anwendeng](/anwendeng)  Thanks! Will give it try for sure!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@akash_vannam](/akash_vannam) Trie is also hard for me. My DP is however a little bit different from other. I don't use hash table. Try a double for loop , i varies over the indexes of s , j varies over indexes of dictionary. Inside the loop  use  just substr, find, rfind in C++ string.  I hope that it is useful."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "I initially thought about tries first, then saw that greedy wouldn\\'t work here. Then, tried dp but wasn\\'t able to write recursion. I struggle alot to come up with an alternative approach when an approach intuitively comes up and I am not able to fully complete it. Any tips? I always see you in daily challenges discussion aceing every question, when I get stuck your hints help me alot."
                    },
                    {
                        "username": "sheshnathverma",
                        "content": "I think description should mention, we are allowed to reuse the dictionary word multiple time.\\n\\nIt took lot of time to realize :(\\n\\nTest Case: \"leetsleetscode\", [\"leets\", \"code\"]"
                    },
                    {
                        "username": "NagaNikhil",
                        "content": "Thanks for pointing it out"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[139. Word Break] similar problem  (https://leetcode.com/problems/word-break/)"
                    },
                    {
                        "username": "user3429v",
                        "content": "this one[2707] is a little bit harder"
                    },
                    {
                        "username": "aman1320",
                        "content": "(Time Limit Exceeded )Test Case 2024/2024\\ns=\\n\\nwho the hell putted this in the test case???????"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "It means your time limit exceeded, don\\'t check that testcase, as that one isn\\'t a testcase. You reduce the time. The overall time probably exceeds the time limit."
                    },
                    {
                        "username": "aquaman55",
                        "content": "PUTTED must be a golfer "
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Hint:\n\nWe know that substring of `s` must exist in dictionary to be able to break. The substring may start from index 0. If it doesn't then the index 0 is the leftover and so on.\n\nMore generally, for every substring there are a 2 choices:\n\n1) this substring is an leftover then `len(substring) + mininmumLeftOver(rest of the string)`\n 2) this substring is part of a substring of string from dictionary, then `0(no leftover) + mininmumLeftOver(rest of the string)`. \n\nWe shall pick the minimum from these 2 choices."
                    },
                    {
                        "username": "Beorn",
                        "content": "Knapsack  problem"
                    },
                    {
                        "username": "shivansh_07",
                        "content": "Like this take and not_take it is similar to knapsack\\n\\nclass Solution {\\npublic:\\nint mini = INT_MAX;\\n    int func(int index, string s , unordered_map<string ,  int> &mp , vector<int> &dp){\\n\\n        if(index == s.size()) return 0;\\n\\n        if(dp[index]!=-1) return dp[index];\\n        \\n        int not_take = 1 + func(index + 1 , s ,mp,dp);\\n        int take = INT_MAX;\\n        for(int i = index; i < s.size();i++){\\n            string t1 = s.substr(index , i - index + 1);\\n            \\n            if(mp.find(t1)!=mp.end()) take = min(take , 0+ func(i+1 , s , mp,dp));\\n            \\n        }\\n\\n        return dp[index] = min(take , not_take);\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<string,int> mp;\\n\\n        vector<int> dp(s.size() + 1 , -1);\\n        for(auto it : dictionary) mp[it]++;\\n\\n        return func(0 , s , mp,dp);\\n    }\\n};"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "how\\n"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "I\\'ve stuck on 1988 test case:\\ns = \"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\ndictionary = \"\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"\"\\n\\nOutput = 14\\nExpected = 15\\n\\nWhy 15 is expected? By the end, my solution produces the following string: \"hlwjeastjqwkof\". Isn\\'t it correct?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@desuraj110](/desuraj110) because smaller data set makes it easier to locate the bug in the code."
                    },
                    {
                        "username": "desuraj110",
                        "content": "same case i stuck too"
                    },
                    {
                        "username": "desuraj110",
                        "content": "[@sergei99](/sergei99) why split in halves ?? "
                    },
                    {
                        "username": "sans_102",
                        "content": "\"hlwxjeastjqwkof\" this is the string left after doing the operations. there is x between w and j (4th place). string is of length 15."
                    },
                    {
                        "username": "sergei99",
                        "content": "Split the input string to halves and execute each half separately. Take the failing half and repeat the procedure. At 4-5 chars you will be able to see the problem instantly. If not, repeat the same thing with the dictionary array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\n```\nazvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\nazv\n   zul\n    u\n          wobow\n            b\n               i\n                 i\n                  yeb\n                    b\n                        kecv\n                                 maqnv\n                                    n\n                                      na\n                                      n\n                                         maqnv\n                                            n\n```\nWith `15` extra characters you can produce this:\n```\nazv zul _ _ _ _ wobow i _ i yeb _ _ _ kecv _ _ _ _ _ maqnv na _ maqnv _\n```"
                    },
                    {
                        "username": "Alexander238",
                        "content": "Yep same, \"hlwjeastjqwkof\" is the word I get with Output 14 and expected 15..."
                    },
                    {
                        "username": "Labib2003",
                        "content": "same case my friend, tried to solve it as a greedy problem "
                    },
                    {
                        "username": "supperr-coder",
                        "content": "got the same output: with the exact same string too: \"hlwjeastjqwkof\" would appreciate someone\\'s help"
                    }
                ]
            },
            {
                "id": 1908885,
                "content": [
                    {
                        "username": "joshczipo",
                        "content": "2028 test casts buddy touch grass"
                    },
                    {
                        "username": "sergei99",
                        "content": "This separates the men from the boys.\\nLow amount of test data => any shoddy job runs at 1 ms.\\nHigh amount of test data => we see a dispersion."
                    },
                    {
                        "username": "ares22121999",
                        "content": "https://leetcode.com/problems/bitwise-and-of-numbers-range/ this question have 8269 cases XD"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Typical those who are always ready to stay in the office upto next day, cuz they don\\'t have any hobbies.\\n\\nNow I know they stay in the office to write 2028 testcases for leetcode. \\nThe badge \\'Stapler of the month\\' is unlocked. jajajaja"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Feels good to be able to solve these problems, atleast with the most basic method considering there was a time when I couldn\\'t figure out how to even start approaching the problem. Keep on keeping on guys!"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@mohantysatyajit57](/mohantysatyajit57) Dynamic programming, this is a very common type of problem."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@mohantysatyajit57](/mohantysatyajit57) I\\'ve been solving the daily problems for 175 days now. Obviously I couldn\\'t figure out most problems in the beginning. But after lookin at and understanding solutions day after day I am now able to solve many problems by myself. I occasionally solve problems people mention being similar to the current one. I don\\'t stick to topics because in an interview, you really won\\'t be informed of the topics of the questions you\\'ll be solving. "
                    },
                    {
                        "username": "mohantysatyajit57",
                        "content": "What topics did you practice in order to figure out what this problem was about?\\n"
                    },
                    {
                        "username": "c4tdog",
                        "content": "test\\n\"dwmodizxvvbosxxw\"\\n[\"ox\",\"lb\",\"diz\",\"gu\",\"v\",\"ksv\",\"o\",\"nuq\",\"r\",\"txhe\",\"e\",\"wmo\",\"cehy\",\"tskz\",\"ds\",\"kzbu\"]\\nhow come the answer is 7? I can only see this way (with 8 chars left)\\nd <b>wmo</b> <b>diz</b> xv <b>v</b> b <b>o</b> sxxw"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just split the input string to halves and execute each half separately. Take the failing half and repeat the procedure. At 4-5 chars you will be able to see the problem instantly. If not, repeat the same thing with the dictionary array."
                    },
                    {
                        "username": "just_ayush",
                        "content": "v is present two times"
                    },
                    {
                        "username": "sakshi_17",
                        "content": "v is deleted two times. So for input - [eev] and dictionary [e] , dict contains only distinct words but all occurrences of word can be deleted."
                    },
                    {
                        "username": "user8307St",
                        "content": "d **wmo** **diz** x **v** **v** b **o** sxxw !"
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@qutequbit](/qutequbit) leetcode is not considered for leetscode. \"leet\" is a different word in dictionary and \"code\" is a different word in the dictionary and \"leetcode\" is broken into \"leet\" and \"code\" which is then considered as the two words in the dictionary."
                    },
                    {
                        "username": "Qnide",
                        "content": "Sort the dictionary in descending order def len"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@6leet](/6leet) how can one not see that. feeling dumb after seeing your comment. thank you."
                    },
                    {
                        "username": "Baymax_",
                        "content": "[@_Anurag_Singhal_](/_Anurag_Singhal_) \"non-overlapping substrings\" is way different from \"can use  dictionary words multiple times\" (even though it is not mentioned)"
                    },
                    {
                        "username": "caleb-mabry",
                        "content": "[@6leet](/6leet) You have no idea how long I have been trying to figure out what was going on. Thanks for this!"
                    },
                    {
                        "username": "_Anurag_Singhal_",
                        "content": "but the questions says non-overlapping substrings!"
                    },
                    {
                        "username": "6leet",
                        "content": "there are two v"
                    },
                    {
                        "username": "anwendeng",
                        "content": "I like DP much more than bit counting.\nAfter usual DP can try DP+Trie! more challenging."
                    },
                    {
                        "username": "sergei99",
                        "content": "Tries ruthlessly beat any other collections here. I see the execution time top is all involving tries.\\nSpent 4 hours debugging my trie and didn\\'t regret: 40 ms, absolute top for the time being, for the first submission.\\nStill need to improve its memory consumption though. Went a simple way to avoid costly node reallocations, it helped to an extent in another task, but here it takes 76 Mb vs 64 Mb of an STL hash set... what a shame."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "[@anwendeng](/anwendeng)  Thanks! Will give it try for sure!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@akash_vannam](/akash_vannam) Trie is also hard for me. My DP is however a little bit different from other. I don't use hash table. Try a double for loop , i varies over the indexes of s , j varies over indexes of dictionary. Inside the loop  use  just substr, find, rfind in C++ string.  I hope that it is useful."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "I initially thought about tries first, then saw that greedy wouldn\\'t work here. Then, tried dp but wasn\\'t able to write recursion. I struggle alot to come up with an alternative approach when an approach intuitively comes up and I am not able to fully complete it. Any tips? I always see you in daily challenges discussion aceing every question, when I get stuck your hints help me alot."
                    },
                    {
                        "username": "sheshnathverma",
                        "content": "I think description should mention, we are allowed to reuse the dictionary word multiple time.\\n\\nIt took lot of time to realize :(\\n\\nTest Case: \"leetsleetscode\", [\"leets\", \"code\"]"
                    },
                    {
                        "username": "NagaNikhil",
                        "content": "Thanks for pointing it out"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[139. Word Break] similar problem  (https://leetcode.com/problems/word-break/)"
                    },
                    {
                        "username": "user3429v",
                        "content": "this one[2707] is a little bit harder"
                    },
                    {
                        "username": "aman1320",
                        "content": "(Time Limit Exceeded )Test Case 2024/2024\\ns=\\n\\nwho the hell putted this in the test case???????"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "It means your time limit exceeded, don\\'t check that testcase, as that one isn\\'t a testcase. You reduce the time. The overall time probably exceeds the time limit."
                    },
                    {
                        "username": "aquaman55",
                        "content": "PUTTED must be a golfer "
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Hint:\n\nWe know that substring of `s` must exist in dictionary to be able to break. The substring may start from index 0. If it doesn't then the index 0 is the leftover and so on.\n\nMore generally, for every substring there are a 2 choices:\n\n1) this substring is an leftover then `len(substring) + mininmumLeftOver(rest of the string)`\n 2) this substring is part of a substring of string from dictionary, then `0(no leftover) + mininmumLeftOver(rest of the string)`. \n\nWe shall pick the minimum from these 2 choices."
                    },
                    {
                        "username": "Beorn",
                        "content": "Knapsack  problem"
                    },
                    {
                        "username": "shivansh_07",
                        "content": "Like this take and not_take it is similar to knapsack\\n\\nclass Solution {\\npublic:\\nint mini = INT_MAX;\\n    int func(int index, string s , unordered_map<string ,  int> &mp , vector<int> &dp){\\n\\n        if(index == s.size()) return 0;\\n\\n        if(dp[index]!=-1) return dp[index];\\n        \\n        int not_take = 1 + func(index + 1 , s ,mp,dp);\\n        int take = INT_MAX;\\n        for(int i = index; i < s.size();i++){\\n            string t1 = s.substr(index , i - index + 1);\\n            \\n            if(mp.find(t1)!=mp.end()) take = min(take , 0+ func(i+1 , s , mp,dp));\\n            \\n        }\\n\\n        return dp[index] = min(take , not_take);\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<string,int> mp;\\n\\n        vector<int> dp(s.size() + 1 , -1);\\n        for(auto it : dictionary) mp[it]++;\\n\\n        return func(0 , s , mp,dp);\\n    }\\n};"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "how\\n"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "I\\'ve stuck on 1988 test case:\\ns = \"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\ndictionary = \"\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"\"\\n\\nOutput = 14\\nExpected = 15\\n\\nWhy 15 is expected? By the end, my solution produces the following string: \"hlwjeastjqwkof\". Isn\\'t it correct?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@desuraj110](/desuraj110) because smaller data set makes it easier to locate the bug in the code."
                    },
                    {
                        "username": "desuraj110",
                        "content": "same case i stuck too"
                    },
                    {
                        "username": "desuraj110",
                        "content": "[@sergei99](/sergei99) why split in halves ?? "
                    },
                    {
                        "username": "sans_102",
                        "content": "\"hlwxjeastjqwkof\" this is the string left after doing the operations. there is x between w and j (4th place). string is of length 15."
                    },
                    {
                        "username": "sergei99",
                        "content": "Split the input string to halves and execute each half separately. Take the failing half and repeat the procedure. At 4-5 chars you will be able to see the problem instantly. If not, repeat the same thing with the dictionary array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\n```\nazvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\nazv\n   zul\n    u\n          wobow\n            b\n               i\n                 i\n                  yeb\n                    b\n                        kecv\n                                 maqnv\n                                    n\n                                      na\n                                      n\n                                         maqnv\n                                            n\n```\nWith `15` extra characters you can produce this:\n```\nazv zul _ _ _ _ wobow i _ i yeb _ _ _ kecv _ _ _ _ _ maqnv na _ maqnv _\n```"
                    },
                    {
                        "username": "Alexander238",
                        "content": "Yep same, \"hlwjeastjqwkof\" is the word I get with Output 14 and expected 15..."
                    },
                    {
                        "username": "Labib2003",
                        "content": "same case my friend, tried to solve it as a greedy problem "
                    },
                    {
                        "username": "supperr-coder",
                        "content": "got the same output: with the exact same string too: \"hlwjeastjqwkof\" would appreciate someone\\'s help"
                    }
                ]
            },
            {
                "id": 1908779,
                "content": [
                    {
                        "username": "joshczipo",
                        "content": "2028 test casts buddy touch grass"
                    },
                    {
                        "username": "sergei99",
                        "content": "This separates the men from the boys.\\nLow amount of test data => any shoddy job runs at 1 ms.\\nHigh amount of test data => we see a dispersion."
                    },
                    {
                        "username": "ares22121999",
                        "content": "https://leetcode.com/problems/bitwise-and-of-numbers-range/ this question have 8269 cases XD"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Typical those who are always ready to stay in the office upto next day, cuz they don\\'t have any hobbies.\\n\\nNow I know they stay in the office to write 2028 testcases for leetcode. \\nThe badge \\'Stapler of the month\\' is unlocked. jajajaja"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Feels good to be able to solve these problems, atleast with the most basic method considering there was a time when I couldn\\'t figure out how to even start approaching the problem. Keep on keeping on guys!"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@mohantysatyajit57](/mohantysatyajit57) Dynamic programming, this is a very common type of problem."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@mohantysatyajit57](/mohantysatyajit57) I\\'ve been solving the daily problems for 175 days now. Obviously I couldn\\'t figure out most problems in the beginning. But after lookin at and understanding solutions day after day I am now able to solve many problems by myself. I occasionally solve problems people mention being similar to the current one. I don\\'t stick to topics because in an interview, you really won\\'t be informed of the topics of the questions you\\'ll be solving. "
                    },
                    {
                        "username": "mohantysatyajit57",
                        "content": "What topics did you practice in order to figure out what this problem was about?\\n"
                    },
                    {
                        "username": "c4tdog",
                        "content": "test\\n\"dwmodizxvvbosxxw\"\\n[\"ox\",\"lb\",\"diz\",\"gu\",\"v\",\"ksv\",\"o\",\"nuq\",\"r\",\"txhe\",\"e\",\"wmo\",\"cehy\",\"tskz\",\"ds\",\"kzbu\"]\\nhow come the answer is 7? I can only see this way (with 8 chars left)\\nd <b>wmo</b> <b>diz</b> xv <b>v</b> b <b>o</b> sxxw"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just split the input string to halves and execute each half separately. Take the failing half and repeat the procedure. At 4-5 chars you will be able to see the problem instantly. If not, repeat the same thing with the dictionary array."
                    },
                    {
                        "username": "just_ayush",
                        "content": "v is present two times"
                    },
                    {
                        "username": "sakshi_17",
                        "content": "v is deleted two times. So for input - [eev] and dictionary [e] , dict contains only distinct words but all occurrences of word can be deleted."
                    },
                    {
                        "username": "user8307St",
                        "content": "d **wmo** **diz** x **v** **v** b **o** sxxw !"
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@qutequbit](/qutequbit) leetcode is not considered for leetscode. \"leet\" is a different word in dictionary and \"code\" is a different word in the dictionary and \"leetcode\" is broken into \"leet\" and \"code\" which is then considered as the two words in the dictionary."
                    },
                    {
                        "username": "Qnide",
                        "content": "Sort the dictionary in descending order def len"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@6leet](/6leet) how can one not see that. feeling dumb after seeing your comment. thank you."
                    },
                    {
                        "username": "Baymax_",
                        "content": "[@_Anurag_Singhal_](/_Anurag_Singhal_) \"non-overlapping substrings\" is way different from \"can use  dictionary words multiple times\" (even though it is not mentioned)"
                    },
                    {
                        "username": "caleb-mabry",
                        "content": "[@6leet](/6leet) You have no idea how long I have been trying to figure out what was going on. Thanks for this!"
                    },
                    {
                        "username": "_Anurag_Singhal_",
                        "content": "but the questions says non-overlapping substrings!"
                    },
                    {
                        "username": "6leet",
                        "content": "there are two v"
                    },
                    {
                        "username": "anwendeng",
                        "content": "I like DP much more than bit counting.\nAfter usual DP can try DP+Trie! more challenging."
                    },
                    {
                        "username": "sergei99",
                        "content": "Tries ruthlessly beat any other collections here. I see the execution time top is all involving tries.\\nSpent 4 hours debugging my trie and didn\\'t regret: 40 ms, absolute top for the time being, for the first submission.\\nStill need to improve its memory consumption though. Went a simple way to avoid costly node reallocations, it helped to an extent in another task, but here it takes 76 Mb vs 64 Mb of an STL hash set... what a shame."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "[@anwendeng](/anwendeng)  Thanks! Will give it try for sure!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@akash_vannam](/akash_vannam) Trie is also hard for me. My DP is however a little bit different from other. I don't use hash table. Try a double for loop , i varies over the indexes of s , j varies over indexes of dictionary. Inside the loop  use  just substr, find, rfind in C++ string.  I hope that it is useful."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "I initially thought about tries first, then saw that greedy wouldn\\'t work here. Then, tried dp but wasn\\'t able to write recursion. I struggle alot to come up with an alternative approach when an approach intuitively comes up and I am not able to fully complete it. Any tips? I always see you in daily challenges discussion aceing every question, when I get stuck your hints help me alot."
                    },
                    {
                        "username": "sheshnathverma",
                        "content": "I think description should mention, we are allowed to reuse the dictionary word multiple time.\\n\\nIt took lot of time to realize :(\\n\\nTest Case: \"leetsleetscode\", [\"leets\", \"code\"]"
                    },
                    {
                        "username": "NagaNikhil",
                        "content": "Thanks for pointing it out"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[139. Word Break] similar problem  (https://leetcode.com/problems/word-break/)"
                    },
                    {
                        "username": "user3429v",
                        "content": "this one[2707] is a little bit harder"
                    },
                    {
                        "username": "aman1320",
                        "content": "(Time Limit Exceeded )Test Case 2024/2024\\ns=\\n\\nwho the hell putted this in the test case???????"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "It means your time limit exceeded, don\\'t check that testcase, as that one isn\\'t a testcase. You reduce the time. The overall time probably exceeds the time limit."
                    },
                    {
                        "username": "aquaman55",
                        "content": "PUTTED must be a golfer "
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Hint:\n\nWe know that substring of `s` must exist in dictionary to be able to break. The substring may start from index 0. If it doesn't then the index 0 is the leftover and so on.\n\nMore generally, for every substring there are a 2 choices:\n\n1) this substring is an leftover then `len(substring) + mininmumLeftOver(rest of the string)`\n 2) this substring is part of a substring of string from dictionary, then `0(no leftover) + mininmumLeftOver(rest of the string)`. \n\nWe shall pick the minimum from these 2 choices."
                    },
                    {
                        "username": "Beorn",
                        "content": "Knapsack  problem"
                    },
                    {
                        "username": "shivansh_07",
                        "content": "Like this take and not_take it is similar to knapsack\\n\\nclass Solution {\\npublic:\\nint mini = INT_MAX;\\n    int func(int index, string s , unordered_map<string ,  int> &mp , vector<int> &dp){\\n\\n        if(index == s.size()) return 0;\\n\\n        if(dp[index]!=-1) return dp[index];\\n        \\n        int not_take = 1 + func(index + 1 , s ,mp,dp);\\n        int take = INT_MAX;\\n        for(int i = index; i < s.size();i++){\\n            string t1 = s.substr(index , i - index + 1);\\n            \\n            if(mp.find(t1)!=mp.end()) take = min(take , 0+ func(i+1 , s , mp,dp));\\n            \\n        }\\n\\n        return dp[index] = min(take , not_take);\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<string,int> mp;\\n\\n        vector<int> dp(s.size() + 1 , -1);\\n        for(auto it : dictionary) mp[it]++;\\n\\n        return func(0 , s , mp,dp);\\n    }\\n};"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "how\\n"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "I\\'ve stuck on 1988 test case:\\ns = \"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\ndictionary = \"\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"\"\\n\\nOutput = 14\\nExpected = 15\\n\\nWhy 15 is expected? By the end, my solution produces the following string: \"hlwjeastjqwkof\". Isn\\'t it correct?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@desuraj110](/desuraj110) because smaller data set makes it easier to locate the bug in the code."
                    },
                    {
                        "username": "desuraj110",
                        "content": "same case i stuck too"
                    },
                    {
                        "username": "desuraj110",
                        "content": "[@sergei99](/sergei99) why split in halves ?? "
                    },
                    {
                        "username": "sans_102",
                        "content": "\"hlwxjeastjqwkof\" this is the string left after doing the operations. there is x between w and j (4th place). string is of length 15."
                    },
                    {
                        "username": "sergei99",
                        "content": "Split the input string to halves and execute each half separately. Take the failing half and repeat the procedure. At 4-5 chars you will be able to see the problem instantly. If not, repeat the same thing with the dictionary array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\n```\nazvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\nazv\n   zul\n    u\n          wobow\n            b\n               i\n                 i\n                  yeb\n                    b\n                        kecv\n                                 maqnv\n                                    n\n                                      na\n                                      n\n                                         maqnv\n                                            n\n```\nWith `15` extra characters you can produce this:\n```\nazv zul _ _ _ _ wobow i _ i yeb _ _ _ kecv _ _ _ _ _ maqnv na _ maqnv _\n```"
                    },
                    {
                        "username": "Alexander238",
                        "content": "Yep same, \"hlwjeastjqwkof\" is the word I get with Output 14 and expected 15..."
                    },
                    {
                        "username": "Labib2003",
                        "content": "same case my friend, tried to solve it as a greedy problem "
                    },
                    {
                        "username": "supperr-coder",
                        "content": "got the same output: with the exact same string too: \"hlwjeastjqwkof\" would appreciate someone\\'s help"
                    }
                ]
            },
            {
                "id": 2040053,
                "content": [
                    {
                        "username": "joshczipo",
                        "content": "2028 test casts buddy touch grass"
                    },
                    {
                        "username": "sergei99",
                        "content": "This separates the men from the boys.\\nLow amount of test data => any shoddy job runs at 1 ms.\\nHigh amount of test data => we see a dispersion."
                    },
                    {
                        "username": "ares22121999",
                        "content": "https://leetcode.com/problems/bitwise-and-of-numbers-range/ this question have 8269 cases XD"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Typical those who are always ready to stay in the office upto next day, cuz they don\\'t have any hobbies.\\n\\nNow I know they stay in the office to write 2028 testcases for leetcode. \\nThe badge \\'Stapler of the month\\' is unlocked. jajajaja"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Feels good to be able to solve these problems, atleast with the most basic method considering there was a time when I couldn\\'t figure out how to even start approaching the problem. Keep on keeping on guys!"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@mohantysatyajit57](/mohantysatyajit57) Dynamic programming, this is a very common type of problem."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@mohantysatyajit57](/mohantysatyajit57) I\\'ve been solving the daily problems for 175 days now. Obviously I couldn\\'t figure out most problems in the beginning. But after lookin at and understanding solutions day after day I am now able to solve many problems by myself. I occasionally solve problems people mention being similar to the current one. I don\\'t stick to topics because in an interview, you really won\\'t be informed of the topics of the questions you\\'ll be solving. "
                    },
                    {
                        "username": "mohantysatyajit57",
                        "content": "What topics did you practice in order to figure out what this problem was about?\\n"
                    },
                    {
                        "username": "c4tdog",
                        "content": "test\\n\"dwmodizxvvbosxxw\"\\n[\"ox\",\"lb\",\"diz\",\"gu\",\"v\",\"ksv\",\"o\",\"nuq\",\"r\",\"txhe\",\"e\",\"wmo\",\"cehy\",\"tskz\",\"ds\",\"kzbu\"]\\nhow come the answer is 7? I can only see this way (with 8 chars left)\\nd <b>wmo</b> <b>diz</b> xv <b>v</b> b <b>o</b> sxxw"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just split the input string to halves and execute each half separately. Take the failing half and repeat the procedure. At 4-5 chars you will be able to see the problem instantly. If not, repeat the same thing with the dictionary array."
                    },
                    {
                        "username": "just_ayush",
                        "content": "v is present two times"
                    },
                    {
                        "username": "sakshi_17",
                        "content": "v is deleted two times. So for input - [eev] and dictionary [e] , dict contains only distinct words but all occurrences of word can be deleted."
                    },
                    {
                        "username": "user8307St",
                        "content": "d **wmo** **diz** x **v** **v** b **o** sxxw !"
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@qutequbit](/qutequbit) leetcode is not considered for leetscode. \"leet\" is a different word in dictionary and \"code\" is a different word in the dictionary and \"leetcode\" is broken into \"leet\" and \"code\" which is then considered as the two words in the dictionary."
                    },
                    {
                        "username": "Qnide",
                        "content": "Sort the dictionary in descending order def len"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@6leet](/6leet) how can one not see that. feeling dumb after seeing your comment. thank you."
                    },
                    {
                        "username": "Baymax_",
                        "content": "[@_Anurag_Singhal_](/_Anurag_Singhal_) \"non-overlapping substrings\" is way different from \"can use  dictionary words multiple times\" (even though it is not mentioned)"
                    },
                    {
                        "username": "caleb-mabry",
                        "content": "[@6leet](/6leet) You have no idea how long I have been trying to figure out what was going on. Thanks for this!"
                    },
                    {
                        "username": "_Anurag_Singhal_",
                        "content": "but the questions says non-overlapping substrings!"
                    },
                    {
                        "username": "6leet",
                        "content": "there are two v"
                    },
                    {
                        "username": "anwendeng",
                        "content": "I like DP much more than bit counting.\nAfter usual DP can try DP+Trie! more challenging."
                    },
                    {
                        "username": "sergei99",
                        "content": "Tries ruthlessly beat any other collections here. I see the execution time top is all involving tries.\\nSpent 4 hours debugging my trie and didn\\'t regret: 40 ms, absolute top for the time being, for the first submission.\\nStill need to improve its memory consumption though. Went a simple way to avoid costly node reallocations, it helped to an extent in another task, but here it takes 76 Mb vs 64 Mb of an STL hash set... what a shame."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "[@anwendeng](/anwendeng)  Thanks! Will give it try for sure!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@akash_vannam](/akash_vannam) Trie is also hard for me. My DP is however a little bit different from other. I don't use hash table. Try a double for loop , i varies over the indexes of s , j varies over indexes of dictionary. Inside the loop  use  just substr, find, rfind in C++ string.  I hope that it is useful."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "I initially thought about tries first, then saw that greedy wouldn\\'t work here. Then, tried dp but wasn\\'t able to write recursion. I struggle alot to come up with an alternative approach when an approach intuitively comes up and I am not able to fully complete it. Any tips? I always see you in daily challenges discussion aceing every question, when I get stuck your hints help me alot."
                    },
                    {
                        "username": "sheshnathverma",
                        "content": "I think description should mention, we are allowed to reuse the dictionary word multiple time.\\n\\nIt took lot of time to realize :(\\n\\nTest Case: \"leetsleetscode\", [\"leets\", \"code\"]"
                    },
                    {
                        "username": "NagaNikhil",
                        "content": "Thanks for pointing it out"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[139. Word Break] similar problem  (https://leetcode.com/problems/word-break/)"
                    },
                    {
                        "username": "user3429v",
                        "content": "this one[2707] is a little bit harder"
                    },
                    {
                        "username": "aman1320",
                        "content": "(Time Limit Exceeded )Test Case 2024/2024\\ns=\\n\\nwho the hell putted this in the test case???????"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "It means your time limit exceeded, don\\'t check that testcase, as that one isn\\'t a testcase. You reduce the time. The overall time probably exceeds the time limit."
                    },
                    {
                        "username": "aquaman55",
                        "content": "PUTTED must be a golfer "
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Hint:\n\nWe know that substring of `s` must exist in dictionary to be able to break. The substring may start from index 0. If it doesn't then the index 0 is the leftover and so on.\n\nMore generally, for every substring there are a 2 choices:\n\n1) this substring is an leftover then `len(substring) + mininmumLeftOver(rest of the string)`\n 2) this substring is part of a substring of string from dictionary, then `0(no leftover) + mininmumLeftOver(rest of the string)`. \n\nWe shall pick the minimum from these 2 choices."
                    },
                    {
                        "username": "Beorn",
                        "content": "Knapsack  problem"
                    },
                    {
                        "username": "shivansh_07",
                        "content": "Like this take and not_take it is similar to knapsack\\n\\nclass Solution {\\npublic:\\nint mini = INT_MAX;\\n    int func(int index, string s , unordered_map<string ,  int> &mp , vector<int> &dp){\\n\\n        if(index == s.size()) return 0;\\n\\n        if(dp[index]!=-1) return dp[index];\\n        \\n        int not_take = 1 + func(index + 1 , s ,mp,dp);\\n        int take = INT_MAX;\\n        for(int i = index; i < s.size();i++){\\n            string t1 = s.substr(index , i - index + 1);\\n            \\n            if(mp.find(t1)!=mp.end()) take = min(take , 0+ func(i+1 , s , mp,dp));\\n            \\n        }\\n\\n        return dp[index] = min(take , not_take);\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<string,int> mp;\\n\\n        vector<int> dp(s.size() + 1 , -1);\\n        for(auto it : dictionary) mp[it]++;\\n\\n        return func(0 , s , mp,dp);\\n    }\\n};"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "how\\n"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "I\\'ve stuck on 1988 test case:\\ns = \"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\ndictionary = \"\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"\"\\n\\nOutput = 14\\nExpected = 15\\n\\nWhy 15 is expected? By the end, my solution produces the following string: \"hlwjeastjqwkof\". Isn\\'t it correct?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@desuraj110](/desuraj110) because smaller data set makes it easier to locate the bug in the code."
                    },
                    {
                        "username": "desuraj110",
                        "content": "same case i stuck too"
                    },
                    {
                        "username": "desuraj110",
                        "content": "[@sergei99](/sergei99) why split in halves ?? "
                    },
                    {
                        "username": "sans_102",
                        "content": "\"hlwxjeastjqwkof\" this is the string left after doing the operations. there is x between w and j (4th place). string is of length 15."
                    },
                    {
                        "username": "sergei99",
                        "content": "Split the input string to halves and execute each half separately. Take the failing half and repeat the procedure. At 4-5 chars you will be able to see the problem instantly. If not, repeat the same thing with the dictionary array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\n```\nazvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\nazv\n   zul\n    u\n          wobow\n            b\n               i\n                 i\n                  yeb\n                    b\n                        kecv\n                                 maqnv\n                                    n\n                                      na\n                                      n\n                                         maqnv\n                                            n\n```\nWith `15` extra characters you can produce this:\n```\nazv zul _ _ _ _ wobow i _ i yeb _ _ _ kecv _ _ _ _ _ maqnv na _ maqnv _\n```"
                    },
                    {
                        "username": "Alexander238",
                        "content": "Yep same, \"hlwjeastjqwkof\" is the word I get with Output 14 and expected 15..."
                    },
                    {
                        "username": "Labib2003",
                        "content": "same case my friend, tried to solve it as a greedy problem "
                    },
                    {
                        "username": "supperr-coder",
                        "content": "got the same output: with the exact same string too: \"hlwjeastjqwkof\" would appreciate someone\\'s help"
                    }
                ]
            },
            {
                "id": 1907804,
                "content": [
                    {
                        "username": "joshczipo",
                        "content": "2028 test casts buddy touch grass"
                    },
                    {
                        "username": "sergei99",
                        "content": "This separates the men from the boys.\\nLow amount of test data => any shoddy job runs at 1 ms.\\nHigh amount of test data => we see a dispersion."
                    },
                    {
                        "username": "ares22121999",
                        "content": "https://leetcode.com/problems/bitwise-and-of-numbers-range/ this question have 8269 cases XD"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Typical those who are always ready to stay in the office upto next day, cuz they don\\'t have any hobbies.\\n\\nNow I know they stay in the office to write 2028 testcases for leetcode. \\nThe badge \\'Stapler of the month\\' is unlocked. jajajaja"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Feels good to be able to solve these problems, atleast with the most basic method considering there was a time when I couldn\\'t figure out how to even start approaching the problem. Keep on keeping on guys!"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@mohantysatyajit57](/mohantysatyajit57) Dynamic programming, this is a very common type of problem."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@mohantysatyajit57](/mohantysatyajit57) I\\'ve been solving the daily problems for 175 days now. Obviously I couldn\\'t figure out most problems in the beginning. But after lookin at and understanding solutions day after day I am now able to solve many problems by myself. I occasionally solve problems people mention being similar to the current one. I don\\'t stick to topics because in an interview, you really won\\'t be informed of the topics of the questions you\\'ll be solving. "
                    },
                    {
                        "username": "mohantysatyajit57",
                        "content": "What topics did you practice in order to figure out what this problem was about?\\n"
                    },
                    {
                        "username": "c4tdog",
                        "content": "test\\n\"dwmodizxvvbosxxw\"\\n[\"ox\",\"lb\",\"diz\",\"gu\",\"v\",\"ksv\",\"o\",\"nuq\",\"r\",\"txhe\",\"e\",\"wmo\",\"cehy\",\"tskz\",\"ds\",\"kzbu\"]\\nhow come the answer is 7? I can only see this way (with 8 chars left)\\nd <b>wmo</b> <b>diz</b> xv <b>v</b> b <b>o</b> sxxw"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just split the input string to halves and execute each half separately. Take the failing half and repeat the procedure. At 4-5 chars you will be able to see the problem instantly. If not, repeat the same thing with the dictionary array."
                    },
                    {
                        "username": "just_ayush",
                        "content": "v is present two times"
                    },
                    {
                        "username": "sakshi_17",
                        "content": "v is deleted two times. So for input - [eev] and dictionary [e] , dict contains only distinct words but all occurrences of word can be deleted."
                    },
                    {
                        "username": "user8307St",
                        "content": "d **wmo** **diz** x **v** **v** b **o** sxxw !"
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@qutequbit](/qutequbit) leetcode is not considered for leetscode. \"leet\" is a different word in dictionary and \"code\" is a different word in the dictionary and \"leetcode\" is broken into \"leet\" and \"code\" which is then considered as the two words in the dictionary."
                    },
                    {
                        "username": "Qnide",
                        "content": "Sort the dictionary in descending order def len"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@6leet](/6leet) how can one not see that. feeling dumb after seeing your comment. thank you."
                    },
                    {
                        "username": "Baymax_",
                        "content": "[@_Anurag_Singhal_](/_Anurag_Singhal_) \"non-overlapping substrings\" is way different from \"can use  dictionary words multiple times\" (even though it is not mentioned)"
                    },
                    {
                        "username": "caleb-mabry",
                        "content": "[@6leet](/6leet) You have no idea how long I have been trying to figure out what was going on. Thanks for this!"
                    },
                    {
                        "username": "_Anurag_Singhal_",
                        "content": "but the questions says non-overlapping substrings!"
                    },
                    {
                        "username": "6leet",
                        "content": "there are two v"
                    },
                    {
                        "username": "anwendeng",
                        "content": "I like DP much more than bit counting.\nAfter usual DP can try DP+Trie! more challenging."
                    },
                    {
                        "username": "sergei99",
                        "content": "Tries ruthlessly beat any other collections here. I see the execution time top is all involving tries.\\nSpent 4 hours debugging my trie and didn\\'t regret: 40 ms, absolute top for the time being, for the first submission.\\nStill need to improve its memory consumption though. Went a simple way to avoid costly node reallocations, it helped to an extent in another task, but here it takes 76 Mb vs 64 Mb of an STL hash set... what a shame."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "[@anwendeng](/anwendeng)  Thanks! Will give it try for sure!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@akash_vannam](/akash_vannam) Trie is also hard for me. My DP is however a little bit different from other. I don't use hash table. Try a double for loop , i varies over the indexes of s , j varies over indexes of dictionary. Inside the loop  use  just substr, find, rfind in C++ string.  I hope that it is useful."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "I initially thought about tries first, then saw that greedy wouldn\\'t work here. Then, tried dp but wasn\\'t able to write recursion. I struggle alot to come up with an alternative approach when an approach intuitively comes up and I am not able to fully complete it. Any tips? I always see you in daily challenges discussion aceing every question, when I get stuck your hints help me alot."
                    },
                    {
                        "username": "sheshnathverma",
                        "content": "I think description should mention, we are allowed to reuse the dictionary word multiple time.\\n\\nIt took lot of time to realize :(\\n\\nTest Case: \"leetsleetscode\", [\"leets\", \"code\"]"
                    },
                    {
                        "username": "NagaNikhil",
                        "content": "Thanks for pointing it out"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[139. Word Break] similar problem  (https://leetcode.com/problems/word-break/)"
                    },
                    {
                        "username": "user3429v",
                        "content": "this one[2707] is a little bit harder"
                    },
                    {
                        "username": "aman1320",
                        "content": "(Time Limit Exceeded )Test Case 2024/2024\\ns=\\n\\nwho the hell putted this in the test case???????"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "It means your time limit exceeded, don\\'t check that testcase, as that one isn\\'t a testcase. You reduce the time. The overall time probably exceeds the time limit."
                    },
                    {
                        "username": "aquaman55",
                        "content": "PUTTED must be a golfer "
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Hint:\n\nWe know that substring of `s` must exist in dictionary to be able to break. The substring may start from index 0. If it doesn't then the index 0 is the leftover and so on.\n\nMore generally, for every substring there are a 2 choices:\n\n1) this substring is an leftover then `len(substring) + mininmumLeftOver(rest of the string)`\n 2) this substring is part of a substring of string from dictionary, then `0(no leftover) + mininmumLeftOver(rest of the string)`. \n\nWe shall pick the minimum from these 2 choices."
                    },
                    {
                        "username": "Beorn",
                        "content": "Knapsack  problem"
                    },
                    {
                        "username": "shivansh_07",
                        "content": "Like this take and not_take it is similar to knapsack\\n\\nclass Solution {\\npublic:\\nint mini = INT_MAX;\\n    int func(int index, string s , unordered_map<string ,  int> &mp , vector<int> &dp){\\n\\n        if(index == s.size()) return 0;\\n\\n        if(dp[index]!=-1) return dp[index];\\n        \\n        int not_take = 1 + func(index + 1 , s ,mp,dp);\\n        int take = INT_MAX;\\n        for(int i = index; i < s.size();i++){\\n            string t1 = s.substr(index , i - index + 1);\\n            \\n            if(mp.find(t1)!=mp.end()) take = min(take , 0+ func(i+1 , s , mp,dp));\\n            \\n        }\\n\\n        return dp[index] = min(take , not_take);\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<string,int> mp;\\n\\n        vector<int> dp(s.size() + 1 , -1);\\n        for(auto it : dictionary) mp[it]++;\\n\\n        return func(0 , s , mp,dp);\\n    }\\n};"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "how\\n"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "I\\'ve stuck on 1988 test case:\\ns = \"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\ndictionary = \"\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"\"\\n\\nOutput = 14\\nExpected = 15\\n\\nWhy 15 is expected? By the end, my solution produces the following string: \"hlwjeastjqwkof\". Isn\\'t it correct?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@desuraj110](/desuraj110) because smaller data set makes it easier to locate the bug in the code."
                    },
                    {
                        "username": "desuraj110",
                        "content": "same case i stuck too"
                    },
                    {
                        "username": "desuraj110",
                        "content": "[@sergei99](/sergei99) why split in halves ?? "
                    },
                    {
                        "username": "sans_102",
                        "content": "\"hlwxjeastjqwkof\" this is the string left after doing the operations. there is x between w and j (4th place). string is of length 15."
                    },
                    {
                        "username": "sergei99",
                        "content": "Split the input string to halves and execute each half separately. Take the failing half and repeat the procedure. At 4-5 chars you will be able to see the problem instantly. If not, repeat the same thing with the dictionary array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\n```\nazvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\nazv\n   zul\n    u\n          wobow\n            b\n               i\n                 i\n                  yeb\n                    b\n                        kecv\n                                 maqnv\n                                    n\n                                      na\n                                      n\n                                         maqnv\n                                            n\n```\nWith `15` extra characters you can produce this:\n```\nazv zul _ _ _ _ wobow i _ i yeb _ _ _ kecv _ _ _ _ _ maqnv na _ maqnv _\n```"
                    },
                    {
                        "username": "Alexander238",
                        "content": "Yep same, \"hlwjeastjqwkof\" is the word I get with Output 14 and expected 15..."
                    },
                    {
                        "username": "Labib2003",
                        "content": "same case my friend, tried to solve it as a greedy problem "
                    },
                    {
                        "username": "supperr-coder",
                        "content": "got the same output: with the exact same string too: \"hlwjeastjqwkof\" would appreciate someone\\'s help"
                    }
                ]
            },
            {
                "id": 2040552,
                "content": [
                    {
                        "username": "joshczipo",
                        "content": "2028 test casts buddy touch grass"
                    },
                    {
                        "username": "sergei99",
                        "content": "This separates the men from the boys.\\nLow amount of test data => any shoddy job runs at 1 ms.\\nHigh amount of test data => we see a dispersion."
                    },
                    {
                        "username": "ares22121999",
                        "content": "https://leetcode.com/problems/bitwise-and-of-numbers-range/ this question have 8269 cases XD"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Typical those who are always ready to stay in the office upto next day, cuz they don\\'t have any hobbies.\\n\\nNow I know they stay in the office to write 2028 testcases for leetcode. \\nThe badge \\'Stapler of the month\\' is unlocked. jajajaja"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Feels good to be able to solve these problems, atleast with the most basic method considering there was a time when I couldn\\'t figure out how to even start approaching the problem. Keep on keeping on guys!"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@mohantysatyajit57](/mohantysatyajit57) Dynamic programming, this is a very common type of problem."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@mohantysatyajit57](/mohantysatyajit57) I\\'ve been solving the daily problems for 175 days now. Obviously I couldn\\'t figure out most problems in the beginning. But after lookin at and understanding solutions day after day I am now able to solve many problems by myself. I occasionally solve problems people mention being similar to the current one. I don\\'t stick to topics because in an interview, you really won\\'t be informed of the topics of the questions you\\'ll be solving. "
                    },
                    {
                        "username": "mohantysatyajit57",
                        "content": "What topics did you practice in order to figure out what this problem was about?\\n"
                    },
                    {
                        "username": "c4tdog",
                        "content": "test\\n\"dwmodizxvvbosxxw\"\\n[\"ox\",\"lb\",\"diz\",\"gu\",\"v\",\"ksv\",\"o\",\"nuq\",\"r\",\"txhe\",\"e\",\"wmo\",\"cehy\",\"tskz\",\"ds\",\"kzbu\"]\\nhow come the answer is 7? I can only see this way (with 8 chars left)\\nd <b>wmo</b> <b>diz</b> xv <b>v</b> b <b>o</b> sxxw"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just split the input string to halves and execute each half separately. Take the failing half and repeat the procedure. At 4-5 chars you will be able to see the problem instantly. If not, repeat the same thing with the dictionary array."
                    },
                    {
                        "username": "just_ayush",
                        "content": "v is present two times"
                    },
                    {
                        "username": "sakshi_17",
                        "content": "v is deleted two times. So for input - [eev] and dictionary [e] , dict contains only distinct words but all occurrences of word can be deleted."
                    },
                    {
                        "username": "user8307St",
                        "content": "d **wmo** **diz** x **v** **v** b **o** sxxw !"
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@qutequbit](/qutequbit) leetcode is not considered for leetscode. \"leet\" is a different word in dictionary and \"code\" is a different word in the dictionary and \"leetcode\" is broken into \"leet\" and \"code\" which is then considered as the two words in the dictionary."
                    },
                    {
                        "username": "Qnide",
                        "content": "Sort the dictionary in descending order def len"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@6leet](/6leet) how can one not see that. feeling dumb after seeing your comment. thank you."
                    },
                    {
                        "username": "Baymax_",
                        "content": "[@_Anurag_Singhal_](/_Anurag_Singhal_) \"non-overlapping substrings\" is way different from \"can use  dictionary words multiple times\" (even though it is not mentioned)"
                    },
                    {
                        "username": "caleb-mabry",
                        "content": "[@6leet](/6leet) You have no idea how long I have been trying to figure out what was going on. Thanks for this!"
                    },
                    {
                        "username": "_Anurag_Singhal_",
                        "content": "but the questions says non-overlapping substrings!"
                    },
                    {
                        "username": "6leet",
                        "content": "there are two v"
                    },
                    {
                        "username": "anwendeng",
                        "content": "I like DP much more than bit counting.\nAfter usual DP can try DP+Trie! more challenging."
                    },
                    {
                        "username": "sergei99",
                        "content": "Tries ruthlessly beat any other collections here. I see the execution time top is all involving tries.\\nSpent 4 hours debugging my trie and didn\\'t regret: 40 ms, absolute top for the time being, for the first submission.\\nStill need to improve its memory consumption though. Went a simple way to avoid costly node reallocations, it helped to an extent in another task, but here it takes 76 Mb vs 64 Mb of an STL hash set... what a shame."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "[@anwendeng](/anwendeng)  Thanks! Will give it try for sure!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@akash_vannam](/akash_vannam) Trie is also hard for me. My DP is however a little bit different from other. I don't use hash table. Try a double for loop , i varies over the indexes of s , j varies over indexes of dictionary. Inside the loop  use  just substr, find, rfind in C++ string.  I hope that it is useful."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "I initially thought about tries first, then saw that greedy wouldn\\'t work here. Then, tried dp but wasn\\'t able to write recursion. I struggle alot to come up with an alternative approach when an approach intuitively comes up and I am not able to fully complete it. Any tips? I always see you in daily challenges discussion aceing every question, when I get stuck your hints help me alot."
                    },
                    {
                        "username": "sheshnathverma",
                        "content": "I think description should mention, we are allowed to reuse the dictionary word multiple time.\\n\\nIt took lot of time to realize :(\\n\\nTest Case: \"leetsleetscode\", [\"leets\", \"code\"]"
                    },
                    {
                        "username": "NagaNikhil",
                        "content": "Thanks for pointing it out"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[139. Word Break] similar problem  (https://leetcode.com/problems/word-break/)"
                    },
                    {
                        "username": "user3429v",
                        "content": "this one[2707] is a little bit harder"
                    },
                    {
                        "username": "aman1320",
                        "content": "(Time Limit Exceeded )Test Case 2024/2024\\ns=\\n\\nwho the hell putted this in the test case???????"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "It means your time limit exceeded, don\\'t check that testcase, as that one isn\\'t a testcase. You reduce the time. The overall time probably exceeds the time limit."
                    },
                    {
                        "username": "aquaman55",
                        "content": "PUTTED must be a golfer "
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Hint:\n\nWe know that substring of `s` must exist in dictionary to be able to break. The substring may start from index 0. If it doesn't then the index 0 is the leftover and so on.\n\nMore generally, for every substring there are a 2 choices:\n\n1) this substring is an leftover then `len(substring) + mininmumLeftOver(rest of the string)`\n 2) this substring is part of a substring of string from dictionary, then `0(no leftover) + mininmumLeftOver(rest of the string)`. \n\nWe shall pick the minimum from these 2 choices."
                    },
                    {
                        "username": "Beorn",
                        "content": "Knapsack  problem"
                    },
                    {
                        "username": "shivansh_07",
                        "content": "Like this take and not_take it is similar to knapsack\\n\\nclass Solution {\\npublic:\\nint mini = INT_MAX;\\n    int func(int index, string s , unordered_map<string ,  int> &mp , vector<int> &dp){\\n\\n        if(index == s.size()) return 0;\\n\\n        if(dp[index]!=-1) return dp[index];\\n        \\n        int not_take = 1 + func(index + 1 , s ,mp,dp);\\n        int take = INT_MAX;\\n        for(int i = index; i < s.size();i++){\\n            string t1 = s.substr(index , i - index + 1);\\n            \\n            if(mp.find(t1)!=mp.end()) take = min(take , 0+ func(i+1 , s , mp,dp));\\n            \\n        }\\n\\n        return dp[index] = min(take , not_take);\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<string,int> mp;\\n\\n        vector<int> dp(s.size() + 1 , -1);\\n        for(auto it : dictionary) mp[it]++;\\n\\n        return func(0 , s , mp,dp);\\n    }\\n};"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "how\\n"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "I\\'ve stuck on 1988 test case:\\ns = \"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\ndictionary = \"\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"\"\\n\\nOutput = 14\\nExpected = 15\\n\\nWhy 15 is expected? By the end, my solution produces the following string: \"hlwjeastjqwkof\". Isn\\'t it correct?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@desuraj110](/desuraj110) because smaller data set makes it easier to locate the bug in the code."
                    },
                    {
                        "username": "desuraj110",
                        "content": "same case i stuck too"
                    },
                    {
                        "username": "desuraj110",
                        "content": "[@sergei99](/sergei99) why split in halves ?? "
                    },
                    {
                        "username": "sans_102",
                        "content": "\"hlwxjeastjqwkof\" this is the string left after doing the operations. there is x between w and j (4th place). string is of length 15."
                    },
                    {
                        "username": "sergei99",
                        "content": "Split the input string to halves and execute each half separately. Take the failing half and repeat the procedure. At 4-5 chars you will be able to see the problem instantly. If not, repeat the same thing with the dictionary array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\n```\nazvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\nazv\n   zul\n    u\n          wobow\n            b\n               i\n                 i\n                  yeb\n                    b\n                        kecv\n                                 maqnv\n                                    n\n                                      na\n                                      n\n                                         maqnv\n                                            n\n```\nWith `15` extra characters you can produce this:\n```\nazv zul _ _ _ _ wobow i _ i yeb _ _ _ kecv _ _ _ _ _ maqnv na _ maqnv _\n```"
                    },
                    {
                        "username": "Alexander238",
                        "content": "Yep same, \"hlwjeastjqwkof\" is the word I get with Output 14 and expected 15..."
                    },
                    {
                        "username": "Labib2003",
                        "content": "same case my friend, tried to solve it as a greedy problem "
                    },
                    {
                        "username": "supperr-coder",
                        "content": "got the same output: with the exact same string too: \"hlwjeastjqwkof\" would appreciate someone\\'s help"
                    }
                ]
            },
            {
                "id": 2040185,
                "content": [
                    {
                        "username": "freezeen3",
                        "content": "The joy of solving a DP problem on your own is not something other types of problems can provide."
                    },
                    {
                        "username": "sans_102",
                        "content": "my buddy woke up and chose truth"
                    },
                    {
                        "username": "eduard92",
                        "content": "So I am not gonna have a weekend right Leetcode?"
                    },
                    {
                        "username": "sapercq",
                        "content": "\"kevlplxozaizdhxoimmraiakbak\"\\n[\"yv\",\"bmab\",\"hv\",\"bnsll\",\"mra\",\"jjqf\",\"g\",\"aiyzi\",\"ip\",\"pfctr\",\"flr\",\"ybbcl\",\"biu\",\"ke\",\"lpl\",\"iak\",\"pirua\",\"ilhqd\",\"zdhx\",\"fux\",\"xaw\",\"pdfvt\",\"xf\",\"t\",\"wq\",\"r\",\"cgmud\",\"aokas\",\"xv\",\"jf\",\"cyys\",\"wcaz\",\"rvegf\",\"ysg\",\"xo\",\"uwb\",\"lw\",\"okgk\",\"vbmi\",\"v\",\"mvo\",\"fxyx\",\"ad\",\"e\"]\\n\\nUse Testcase\\nOutput\\n8\\nExpected\\n9\\n1964 task\\nI count by myself and theres 8 letter that we don\\'t use.not 9"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@sapercq](/sapercq) The instructions say that \"*you have to break s into one or more **non-overlapping** substrings*\".  \\nYou cannot break `\"zdhxo\"` into `\"zdhx\"` and `\"xo\"`, those two words would overlap.-"
                    },
                    {
                        "username": "sapercq",
                        "content": "[@siebenschlaefer](/siebenschlaefer) You have \"XO\" in dictonary\\nAnd you have (zdh(x)o) but you didn\\'t write it in your answer\\nYou can use that XO for making 1.zdhx 2.zdh(xo)"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\\n```\\nkevlplxozaizdhxoimmraiakbak\\nke\\n e\\n  v\\n   lpl\\n      xo\\n           zdhx\\n              xo\\n                  mra\\n                   r\\n                     iak\\n```\\nWith `9` extra characters you can build `s` like this:\\n```\\nke v lpl xo _ _ _ zdhx _ _ _ mra iak _ _ _\\n```\\nI don\\'t see a way of achieving that with fewer extra characters."
                    },
                    {
                        "username": "sapercq",
                        "content": "Please answer me why not???"
                    },
                    {
                        "username": "sapercq",
                        "content": "(01{ke})ke!!!!!!!!!!!!!      (2{v})v  !!!!!!!!!!!!!       (3,4,5{lpl})lpl    !!!!!!!!!!!!!       (67{xo})xo  !!!!!!!!!!!!!        3 letters we don't use-----zai----- !!!!!!!!!!!!!  (11,12,13,14{zdhx})zdhx !!!!!!!!!!!!!  \n     (15{xo})o    !!!!!!!!!!!!!        2letters we don't use -------------im--------------(18,19,20{mra})mra      !!!!!!!!!!!!!        (21,22,23{iak})iak !!!!!!!!!!!!!       3 letters we dont use  -------bak--------\n3+2+3 = 8 not 9 "
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "There seems to be a wrong answer for azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf There are 14 extra characters while the answer choice is given as 15 in test cases. \\n"
                    },
                    {
                        "username": "sans_102",
                        "content": "\"hlwxjeastjqwkof\" this is the string after doing operations. there is X on 4th place."
                    },
                    {
                        "username": "ktnaneri",
                        "content": "It looks like you got the same mistake as me - you replace the substrings with \"\", and that way the string gets merged and impossible combinations start to appear. \\nTry to not merge the string but break into substrings and then check the existence of substrings in each of those parts instead. "
                    },
                    {
                        "username": "Qnide",
                        "content": "\\u0414\\u0410\\u0410\\u0410. \\u0422\\u041E\\u0416\\u0415 \\u0421\\u0410\\u041C\\u041E\\u0415"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Every weekend daily challenges always be a DP or a Graph type of problems.."
                    },
                    {
                        "username": "earlinn",
                        "content": "[@Rahul_108](/Rahul_108) me too"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "And so my weekends get ruined :\\'("
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis is the `cutting` type dp problem where inside the recursive function, you will have to iterate through each of the index and decide the optimal position to cut.\\n\\nAt each cut, you will be adding a char to your current String and then you will have to call the function again.\\n\\nWhen you cut, check whether the `currString` is in dictionary or not, if it is, it does not contribute to any extra character, but if it\\'s not, then it\\'s contribution will be its`length`.\\n\\nThen, count the future extras by calling the function again, at then end, find the `minimum` of `currExtra+futuExtra` for all possible cut positions"
                    },
                    {
                        "username": "alexeyvoronin",
                        "content": "How do we define \" non-overlapping substrings\" for this task? Are \"abc\" and \"bcd\" overlapping? are \"bad\" and \"a\" overlapping? Or should one string be inside another to be overlapping? Or should their ends have common sequences? "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In `\"abcd\"` -> `\"abc\"` & `\"bcd\"` are overlapping, while\\nIn `\"abcbcd\"` -> `\"abc\"` & `\"bcd\"` are not overlapping."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I spent a long time thinking that each word in dictionary can only be used once at most. I was very confused how this wasn\\'t considered a hard problem. Pro tip: Thats not the case, each substring has to be a word in the dictionary, but they dont have to be different words. "
                    },
                    {
                        "username": "Mentrix",
                        "content": "I think I may have found an error in test case number 1991. When using regex on the entire dictionary, sorting the words in descending order and simply replacing all matches with an empty string, my solution gives a minimum number of extra characters of 14, while the solution states it\\'s 15, which makes no sense to me, since if my solution should be wrong, my minimum remaining character should be HIGHER than the solution and not LOWER. Is there any way how I can report this testcase as I think it is wrong?"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Take the test case:\\n\"abcde\",[\"ae\",\"bcd\"]\\nYou would remove bcd and suddenly you have ae which also matches."
                    },
                    {
                        "username": "sumit_awatar",
                        "content": "For:-\nTestCase 2020\ns =\"aakodubkrlauvfkzje\"\ndictionary =[\"ix\",\"qoqw\",\"ax\",\"ar\",\"v\",\"hxpl\",\"nxcg\",\"thr\",\"kod\",\"pns\",\"cdo\",\"euy\",\"es\",\"rf\",\"bxcx\",\"xe\",\"ua\",\"vws\",\"vumr\",\"zren\",\"bzt\",\"qwxn\",\"ami\",\"rrbk\",\"ak\",\"uan\",\"g\",\"vfk\",\"jxmg\",\"fhb\",\"nqgd\",\"fau\",\"rl\",\"h\",\"r\",\"jxvo\",\"tv\",\"smfp\",\"lmck\",\"od\"]\n\nOutPut :-10\nExpected : 9\n\nCan any one explain why ?\n\nMy Code:- \n class Solution {\npublic:\n    int minExtraChar(string s, vector<string>& dictionary) {\n        int n = dictionary.size();\n        int size = s.length();\n        vector<bool> v(size,false);\n        //int j = 0;\n        sort(dictionary.begin(),dictionary.end(),[](const string &s1,const string &s2){\n            return s1.size() > s2.size() ;\n        });\n        for(int i=0;i<n;i++){\n            size_t pos = s.find(dictionary[i],0);\n            if(pos!=string::npos){\n                //j = pos+dictionary[i].size();\n                //size = size - dictionary[i].size();\n                int k = dictionary[i].size();\n                while(pos!=string::npos){\n                    if(v[pos]==false && v[pos+k-1]==false){\n                        size = size - k;\n                        for(int j = pos;j<pos+k;j++){\n                            v[j]=true;\n                        }\n                    }\n                    pos = s.find(dictionary[i],pos+1);\n                    \n                }\n\n                \n            }\n        }\n        return size;\n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\n```\naakodubkrlauvfkzje\n ak\n  kod\n   od\n        rl\n        r\n            vfk\n            v\n```\nWith `9` extra characters you can produce this:\n```\n_ ak od _ _ _ rl _ _ vfk _ _ _\n```\n\nThe solution in your commend sorts the words by their size and then matches the words greedily.  \nIn this particular test case it finds the match `\"kod\"` and sets the corresponting element of `v` to `true`  \nbut then cannot match `\"ak\"` and `\"od\"` later on, even though their combination would match more characters.\n\nI don't thin a greedy approach will work for this exercise."
                    }
                ]
            },
            {
                "id": 2039973,
                "content": [
                    {
                        "username": "freezeen3",
                        "content": "The joy of solving a DP problem on your own is not something other types of problems can provide."
                    },
                    {
                        "username": "sans_102",
                        "content": "my buddy woke up and chose truth"
                    },
                    {
                        "username": "eduard92",
                        "content": "So I am not gonna have a weekend right Leetcode?"
                    },
                    {
                        "username": "sapercq",
                        "content": "\"kevlplxozaizdhxoimmraiakbak\"\\n[\"yv\",\"bmab\",\"hv\",\"bnsll\",\"mra\",\"jjqf\",\"g\",\"aiyzi\",\"ip\",\"pfctr\",\"flr\",\"ybbcl\",\"biu\",\"ke\",\"lpl\",\"iak\",\"pirua\",\"ilhqd\",\"zdhx\",\"fux\",\"xaw\",\"pdfvt\",\"xf\",\"t\",\"wq\",\"r\",\"cgmud\",\"aokas\",\"xv\",\"jf\",\"cyys\",\"wcaz\",\"rvegf\",\"ysg\",\"xo\",\"uwb\",\"lw\",\"okgk\",\"vbmi\",\"v\",\"mvo\",\"fxyx\",\"ad\",\"e\"]\\n\\nUse Testcase\\nOutput\\n8\\nExpected\\n9\\n1964 task\\nI count by myself and theres 8 letter that we don\\'t use.not 9"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@sapercq](/sapercq) The instructions say that \"*you have to break s into one or more **non-overlapping** substrings*\".  \\nYou cannot break `\"zdhxo\"` into `\"zdhx\"` and `\"xo\"`, those two words would overlap.-"
                    },
                    {
                        "username": "sapercq",
                        "content": "[@siebenschlaefer](/siebenschlaefer) You have \"XO\" in dictonary\\nAnd you have (zdh(x)o) but you didn\\'t write it in your answer\\nYou can use that XO for making 1.zdhx 2.zdh(xo)"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\\n```\\nkevlplxozaizdhxoimmraiakbak\\nke\\n e\\n  v\\n   lpl\\n      xo\\n           zdhx\\n              xo\\n                  mra\\n                   r\\n                     iak\\n```\\nWith `9` extra characters you can build `s` like this:\\n```\\nke v lpl xo _ _ _ zdhx _ _ _ mra iak _ _ _\\n```\\nI don\\'t see a way of achieving that with fewer extra characters."
                    },
                    {
                        "username": "sapercq",
                        "content": "Please answer me why not???"
                    },
                    {
                        "username": "sapercq",
                        "content": "(01{ke})ke!!!!!!!!!!!!!      (2{v})v  !!!!!!!!!!!!!       (3,4,5{lpl})lpl    !!!!!!!!!!!!!       (67{xo})xo  !!!!!!!!!!!!!        3 letters we don't use-----zai----- !!!!!!!!!!!!!  (11,12,13,14{zdhx})zdhx !!!!!!!!!!!!!  \n     (15{xo})o    !!!!!!!!!!!!!        2letters we don't use -------------im--------------(18,19,20{mra})mra      !!!!!!!!!!!!!        (21,22,23{iak})iak !!!!!!!!!!!!!       3 letters we dont use  -------bak--------\n3+2+3 = 8 not 9 "
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "There seems to be a wrong answer for azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf There are 14 extra characters while the answer choice is given as 15 in test cases. \\n"
                    },
                    {
                        "username": "sans_102",
                        "content": "\"hlwxjeastjqwkof\" this is the string after doing operations. there is X on 4th place."
                    },
                    {
                        "username": "ktnaneri",
                        "content": "It looks like you got the same mistake as me - you replace the substrings with \"\", and that way the string gets merged and impossible combinations start to appear. \\nTry to not merge the string but break into substrings and then check the existence of substrings in each of those parts instead. "
                    },
                    {
                        "username": "Qnide",
                        "content": "\\u0414\\u0410\\u0410\\u0410. \\u0422\\u041E\\u0416\\u0415 \\u0421\\u0410\\u041C\\u041E\\u0415"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Every weekend daily challenges always be a DP or a Graph type of problems.."
                    },
                    {
                        "username": "earlinn",
                        "content": "[@Rahul_108](/Rahul_108) me too"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "And so my weekends get ruined :\\'("
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis is the `cutting` type dp problem where inside the recursive function, you will have to iterate through each of the index and decide the optimal position to cut.\\n\\nAt each cut, you will be adding a char to your current String and then you will have to call the function again.\\n\\nWhen you cut, check whether the `currString` is in dictionary or not, if it is, it does not contribute to any extra character, but if it\\'s not, then it\\'s contribution will be its`length`.\\n\\nThen, count the future extras by calling the function again, at then end, find the `minimum` of `currExtra+futuExtra` for all possible cut positions"
                    },
                    {
                        "username": "alexeyvoronin",
                        "content": "How do we define \" non-overlapping substrings\" for this task? Are \"abc\" and \"bcd\" overlapping? are \"bad\" and \"a\" overlapping? Or should one string be inside another to be overlapping? Or should their ends have common sequences? "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In `\"abcd\"` -> `\"abc\"` & `\"bcd\"` are overlapping, while\\nIn `\"abcbcd\"` -> `\"abc\"` & `\"bcd\"` are not overlapping."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I spent a long time thinking that each word in dictionary can only be used once at most. I was very confused how this wasn\\'t considered a hard problem. Pro tip: Thats not the case, each substring has to be a word in the dictionary, but they dont have to be different words. "
                    },
                    {
                        "username": "Mentrix",
                        "content": "I think I may have found an error in test case number 1991. When using regex on the entire dictionary, sorting the words in descending order and simply replacing all matches with an empty string, my solution gives a minimum number of extra characters of 14, while the solution states it\\'s 15, which makes no sense to me, since if my solution should be wrong, my minimum remaining character should be HIGHER than the solution and not LOWER. Is there any way how I can report this testcase as I think it is wrong?"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Take the test case:\\n\"abcde\",[\"ae\",\"bcd\"]\\nYou would remove bcd and suddenly you have ae which also matches."
                    },
                    {
                        "username": "sumit_awatar",
                        "content": "For:-\nTestCase 2020\ns =\"aakodubkrlauvfkzje\"\ndictionary =[\"ix\",\"qoqw\",\"ax\",\"ar\",\"v\",\"hxpl\",\"nxcg\",\"thr\",\"kod\",\"pns\",\"cdo\",\"euy\",\"es\",\"rf\",\"bxcx\",\"xe\",\"ua\",\"vws\",\"vumr\",\"zren\",\"bzt\",\"qwxn\",\"ami\",\"rrbk\",\"ak\",\"uan\",\"g\",\"vfk\",\"jxmg\",\"fhb\",\"nqgd\",\"fau\",\"rl\",\"h\",\"r\",\"jxvo\",\"tv\",\"smfp\",\"lmck\",\"od\"]\n\nOutPut :-10\nExpected : 9\n\nCan any one explain why ?\n\nMy Code:- \n class Solution {\npublic:\n    int minExtraChar(string s, vector<string>& dictionary) {\n        int n = dictionary.size();\n        int size = s.length();\n        vector<bool> v(size,false);\n        //int j = 0;\n        sort(dictionary.begin(),dictionary.end(),[](const string &s1,const string &s2){\n            return s1.size() > s2.size() ;\n        });\n        for(int i=0;i<n;i++){\n            size_t pos = s.find(dictionary[i],0);\n            if(pos!=string::npos){\n                //j = pos+dictionary[i].size();\n                //size = size - dictionary[i].size();\n                int k = dictionary[i].size();\n                while(pos!=string::npos){\n                    if(v[pos]==false && v[pos+k-1]==false){\n                        size = size - k;\n                        for(int j = pos;j<pos+k;j++){\n                            v[j]=true;\n                        }\n                    }\n                    pos = s.find(dictionary[i],pos+1);\n                    \n                }\n\n                \n            }\n        }\n        return size;\n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\n```\naakodubkrlauvfkzje\n ak\n  kod\n   od\n        rl\n        r\n            vfk\n            v\n```\nWith `9` extra characters you can produce this:\n```\n_ ak od _ _ _ rl _ _ vfk _ _ _\n```\n\nThe solution in your commend sorts the words by their size and then matches the words greedily.  \nIn this particular test case it finds the match `\"kod\"` and sets the corresponting element of `v` to `true`  \nbut then cannot match `\"ak\"` and `\"od\"` later on, even though their combination would match more characters.\n\nI don't thin a greedy approach will work for this exercise."
                    }
                ]
            },
            {
                "id": 2041588,
                "content": [
                    {
                        "username": "freezeen3",
                        "content": "The joy of solving a DP problem on your own is not something other types of problems can provide."
                    },
                    {
                        "username": "sans_102",
                        "content": "my buddy woke up and chose truth"
                    },
                    {
                        "username": "eduard92",
                        "content": "So I am not gonna have a weekend right Leetcode?"
                    },
                    {
                        "username": "sapercq",
                        "content": "\"kevlplxozaizdhxoimmraiakbak\"\\n[\"yv\",\"bmab\",\"hv\",\"bnsll\",\"mra\",\"jjqf\",\"g\",\"aiyzi\",\"ip\",\"pfctr\",\"flr\",\"ybbcl\",\"biu\",\"ke\",\"lpl\",\"iak\",\"pirua\",\"ilhqd\",\"zdhx\",\"fux\",\"xaw\",\"pdfvt\",\"xf\",\"t\",\"wq\",\"r\",\"cgmud\",\"aokas\",\"xv\",\"jf\",\"cyys\",\"wcaz\",\"rvegf\",\"ysg\",\"xo\",\"uwb\",\"lw\",\"okgk\",\"vbmi\",\"v\",\"mvo\",\"fxyx\",\"ad\",\"e\"]\\n\\nUse Testcase\\nOutput\\n8\\nExpected\\n9\\n1964 task\\nI count by myself and theres 8 letter that we don\\'t use.not 9"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@sapercq](/sapercq) The instructions say that \"*you have to break s into one or more **non-overlapping** substrings*\".  \\nYou cannot break `\"zdhxo\"` into `\"zdhx\"` and `\"xo\"`, those two words would overlap.-"
                    },
                    {
                        "username": "sapercq",
                        "content": "[@siebenschlaefer](/siebenschlaefer) You have \"XO\" in dictonary\\nAnd you have (zdh(x)o) but you didn\\'t write it in your answer\\nYou can use that XO for making 1.zdhx 2.zdh(xo)"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\\n```\\nkevlplxozaizdhxoimmraiakbak\\nke\\n e\\n  v\\n   lpl\\n      xo\\n           zdhx\\n              xo\\n                  mra\\n                   r\\n                     iak\\n```\\nWith `9` extra characters you can build `s` like this:\\n```\\nke v lpl xo _ _ _ zdhx _ _ _ mra iak _ _ _\\n```\\nI don\\'t see a way of achieving that with fewer extra characters."
                    },
                    {
                        "username": "sapercq",
                        "content": "Please answer me why not???"
                    },
                    {
                        "username": "sapercq",
                        "content": "(01{ke})ke!!!!!!!!!!!!!      (2{v})v  !!!!!!!!!!!!!       (3,4,5{lpl})lpl    !!!!!!!!!!!!!       (67{xo})xo  !!!!!!!!!!!!!        3 letters we don't use-----zai----- !!!!!!!!!!!!!  (11,12,13,14{zdhx})zdhx !!!!!!!!!!!!!  \n     (15{xo})o    !!!!!!!!!!!!!        2letters we don't use -------------im--------------(18,19,20{mra})mra      !!!!!!!!!!!!!        (21,22,23{iak})iak !!!!!!!!!!!!!       3 letters we dont use  -------bak--------\n3+2+3 = 8 not 9 "
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "There seems to be a wrong answer for azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf There are 14 extra characters while the answer choice is given as 15 in test cases. \\n"
                    },
                    {
                        "username": "sans_102",
                        "content": "\"hlwxjeastjqwkof\" this is the string after doing operations. there is X on 4th place."
                    },
                    {
                        "username": "ktnaneri",
                        "content": "It looks like you got the same mistake as me - you replace the substrings with \"\", and that way the string gets merged and impossible combinations start to appear. \\nTry to not merge the string but break into substrings and then check the existence of substrings in each of those parts instead. "
                    },
                    {
                        "username": "Qnide",
                        "content": "\\u0414\\u0410\\u0410\\u0410. \\u0422\\u041E\\u0416\\u0415 \\u0421\\u0410\\u041C\\u041E\\u0415"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Every weekend daily challenges always be a DP or a Graph type of problems.."
                    },
                    {
                        "username": "earlinn",
                        "content": "[@Rahul_108](/Rahul_108) me too"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "And so my weekends get ruined :\\'("
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis is the `cutting` type dp problem where inside the recursive function, you will have to iterate through each of the index and decide the optimal position to cut.\\n\\nAt each cut, you will be adding a char to your current String and then you will have to call the function again.\\n\\nWhen you cut, check whether the `currString` is in dictionary or not, if it is, it does not contribute to any extra character, but if it\\'s not, then it\\'s contribution will be its`length`.\\n\\nThen, count the future extras by calling the function again, at then end, find the `minimum` of `currExtra+futuExtra` for all possible cut positions"
                    },
                    {
                        "username": "alexeyvoronin",
                        "content": "How do we define \" non-overlapping substrings\" for this task? Are \"abc\" and \"bcd\" overlapping? are \"bad\" and \"a\" overlapping? Or should one string be inside another to be overlapping? Or should their ends have common sequences? "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In `\"abcd\"` -> `\"abc\"` & `\"bcd\"` are overlapping, while\\nIn `\"abcbcd\"` -> `\"abc\"` & `\"bcd\"` are not overlapping."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I spent a long time thinking that each word in dictionary can only be used once at most. I was very confused how this wasn\\'t considered a hard problem. Pro tip: Thats not the case, each substring has to be a word in the dictionary, but they dont have to be different words. "
                    },
                    {
                        "username": "Mentrix",
                        "content": "I think I may have found an error in test case number 1991. When using regex on the entire dictionary, sorting the words in descending order and simply replacing all matches with an empty string, my solution gives a minimum number of extra characters of 14, while the solution states it\\'s 15, which makes no sense to me, since if my solution should be wrong, my minimum remaining character should be HIGHER than the solution and not LOWER. Is there any way how I can report this testcase as I think it is wrong?"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Take the test case:\\n\"abcde\",[\"ae\",\"bcd\"]\\nYou would remove bcd and suddenly you have ae which also matches."
                    },
                    {
                        "username": "sumit_awatar",
                        "content": "For:-\nTestCase 2020\ns =\"aakodubkrlauvfkzje\"\ndictionary =[\"ix\",\"qoqw\",\"ax\",\"ar\",\"v\",\"hxpl\",\"nxcg\",\"thr\",\"kod\",\"pns\",\"cdo\",\"euy\",\"es\",\"rf\",\"bxcx\",\"xe\",\"ua\",\"vws\",\"vumr\",\"zren\",\"bzt\",\"qwxn\",\"ami\",\"rrbk\",\"ak\",\"uan\",\"g\",\"vfk\",\"jxmg\",\"fhb\",\"nqgd\",\"fau\",\"rl\",\"h\",\"r\",\"jxvo\",\"tv\",\"smfp\",\"lmck\",\"od\"]\n\nOutPut :-10\nExpected : 9\n\nCan any one explain why ?\n\nMy Code:- \n class Solution {\npublic:\n    int minExtraChar(string s, vector<string>& dictionary) {\n        int n = dictionary.size();\n        int size = s.length();\n        vector<bool> v(size,false);\n        //int j = 0;\n        sort(dictionary.begin(),dictionary.end(),[](const string &s1,const string &s2){\n            return s1.size() > s2.size() ;\n        });\n        for(int i=0;i<n;i++){\n            size_t pos = s.find(dictionary[i],0);\n            if(pos!=string::npos){\n                //j = pos+dictionary[i].size();\n                //size = size - dictionary[i].size();\n                int k = dictionary[i].size();\n                while(pos!=string::npos){\n                    if(v[pos]==false && v[pos+k-1]==false){\n                        size = size - k;\n                        for(int j = pos;j<pos+k;j++){\n                            v[j]=true;\n                        }\n                    }\n                    pos = s.find(dictionary[i],pos+1);\n                    \n                }\n\n                \n            }\n        }\n        return size;\n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\n```\naakodubkrlauvfkzje\n ak\n  kod\n   od\n        rl\n        r\n            vfk\n            v\n```\nWith `9` extra characters you can produce this:\n```\n_ ak od _ _ _ rl _ _ vfk _ _ _\n```\n\nThe solution in your commend sorts the words by their size and then matches the words greedily.  \nIn this particular test case it finds the match `\"kod\"` and sets the corresponting element of `v` to `true`  \nbut then cannot match `\"ak\"` and `\"od\"` later on, even though their combination would match more characters.\n\nI don't thin a greedy approach will work for this exercise."
                    }
                ]
            },
            {
                "id": 2040252,
                "content": [
                    {
                        "username": "freezeen3",
                        "content": "The joy of solving a DP problem on your own is not something other types of problems can provide."
                    },
                    {
                        "username": "sans_102",
                        "content": "my buddy woke up and chose truth"
                    },
                    {
                        "username": "eduard92",
                        "content": "So I am not gonna have a weekend right Leetcode?"
                    },
                    {
                        "username": "sapercq",
                        "content": "\"kevlplxozaizdhxoimmraiakbak\"\\n[\"yv\",\"bmab\",\"hv\",\"bnsll\",\"mra\",\"jjqf\",\"g\",\"aiyzi\",\"ip\",\"pfctr\",\"flr\",\"ybbcl\",\"biu\",\"ke\",\"lpl\",\"iak\",\"pirua\",\"ilhqd\",\"zdhx\",\"fux\",\"xaw\",\"pdfvt\",\"xf\",\"t\",\"wq\",\"r\",\"cgmud\",\"aokas\",\"xv\",\"jf\",\"cyys\",\"wcaz\",\"rvegf\",\"ysg\",\"xo\",\"uwb\",\"lw\",\"okgk\",\"vbmi\",\"v\",\"mvo\",\"fxyx\",\"ad\",\"e\"]\\n\\nUse Testcase\\nOutput\\n8\\nExpected\\n9\\n1964 task\\nI count by myself and theres 8 letter that we don\\'t use.not 9"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@sapercq](/sapercq) The instructions say that \"*you have to break s into one or more **non-overlapping** substrings*\".  \\nYou cannot break `\"zdhxo\"` into `\"zdhx\"` and `\"xo\"`, those two words would overlap.-"
                    },
                    {
                        "username": "sapercq",
                        "content": "[@siebenschlaefer](/siebenschlaefer) You have \"XO\" in dictonary\\nAnd you have (zdh(x)o) but you didn\\'t write it in your answer\\nYou can use that XO for making 1.zdhx 2.zdh(xo)"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\\n```\\nkevlplxozaizdhxoimmraiakbak\\nke\\n e\\n  v\\n   lpl\\n      xo\\n           zdhx\\n              xo\\n                  mra\\n                   r\\n                     iak\\n```\\nWith `9` extra characters you can build `s` like this:\\n```\\nke v lpl xo _ _ _ zdhx _ _ _ mra iak _ _ _\\n```\\nI don\\'t see a way of achieving that with fewer extra characters."
                    },
                    {
                        "username": "sapercq",
                        "content": "Please answer me why not???"
                    },
                    {
                        "username": "sapercq",
                        "content": "(01{ke})ke!!!!!!!!!!!!!      (2{v})v  !!!!!!!!!!!!!       (3,4,5{lpl})lpl    !!!!!!!!!!!!!       (67{xo})xo  !!!!!!!!!!!!!        3 letters we don't use-----zai----- !!!!!!!!!!!!!  (11,12,13,14{zdhx})zdhx !!!!!!!!!!!!!  \n     (15{xo})o    !!!!!!!!!!!!!        2letters we don't use -------------im--------------(18,19,20{mra})mra      !!!!!!!!!!!!!        (21,22,23{iak})iak !!!!!!!!!!!!!       3 letters we dont use  -------bak--------\n3+2+3 = 8 not 9 "
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "There seems to be a wrong answer for azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf There are 14 extra characters while the answer choice is given as 15 in test cases. \\n"
                    },
                    {
                        "username": "sans_102",
                        "content": "\"hlwxjeastjqwkof\" this is the string after doing operations. there is X on 4th place."
                    },
                    {
                        "username": "ktnaneri",
                        "content": "It looks like you got the same mistake as me - you replace the substrings with \"\", and that way the string gets merged and impossible combinations start to appear. \\nTry to not merge the string but break into substrings and then check the existence of substrings in each of those parts instead. "
                    },
                    {
                        "username": "Qnide",
                        "content": "\\u0414\\u0410\\u0410\\u0410. \\u0422\\u041E\\u0416\\u0415 \\u0421\\u0410\\u041C\\u041E\\u0415"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Every weekend daily challenges always be a DP or a Graph type of problems.."
                    },
                    {
                        "username": "earlinn",
                        "content": "[@Rahul_108](/Rahul_108) me too"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "And so my weekends get ruined :\\'("
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis is the `cutting` type dp problem where inside the recursive function, you will have to iterate through each of the index and decide the optimal position to cut.\\n\\nAt each cut, you will be adding a char to your current String and then you will have to call the function again.\\n\\nWhen you cut, check whether the `currString` is in dictionary or not, if it is, it does not contribute to any extra character, but if it\\'s not, then it\\'s contribution will be its`length`.\\n\\nThen, count the future extras by calling the function again, at then end, find the `minimum` of `currExtra+futuExtra` for all possible cut positions"
                    },
                    {
                        "username": "alexeyvoronin",
                        "content": "How do we define \" non-overlapping substrings\" for this task? Are \"abc\" and \"bcd\" overlapping? are \"bad\" and \"a\" overlapping? Or should one string be inside another to be overlapping? Or should their ends have common sequences? "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In `\"abcd\"` -> `\"abc\"` & `\"bcd\"` are overlapping, while\\nIn `\"abcbcd\"` -> `\"abc\"` & `\"bcd\"` are not overlapping."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I spent a long time thinking that each word in dictionary can only be used once at most. I was very confused how this wasn\\'t considered a hard problem. Pro tip: Thats not the case, each substring has to be a word in the dictionary, but they dont have to be different words. "
                    },
                    {
                        "username": "Mentrix",
                        "content": "I think I may have found an error in test case number 1991. When using regex on the entire dictionary, sorting the words in descending order and simply replacing all matches with an empty string, my solution gives a minimum number of extra characters of 14, while the solution states it\\'s 15, which makes no sense to me, since if my solution should be wrong, my minimum remaining character should be HIGHER than the solution and not LOWER. Is there any way how I can report this testcase as I think it is wrong?"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Take the test case:\\n\"abcde\",[\"ae\",\"bcd\"]\\nYou would remove bcd and suddenly you have ae which also matches."
                    },
                    {
                        "username": "sumit_awatar",
                        "content": "For:-\nTestCase 2020\ns =\"aakodubkrlauvfkzje\"\ndictionary =[\"ix\",\"qoqw\",\"ax\",\"ar\",\"v\",\"hxpl\",\"nxcg\",\"thr\",\"kod\",\"pns\",\"cdo\",\"euy\",\"es\",\"rf\",\"bxcx\",\"xe\",\"ua\",\"vws\",\"vumr\",\"zren\",\"bzt\",\"qwxn\",\"ami\",\"rrbk\",\"ak\",\"uan\",\"g\",\"vfk\",\"jxmg\",\"fhb\",\"nqgd\",\"fau\",\"rl\",\"h\",\"r\",\"jxvo\",\"tv\",\"smfp\",\"lmck\",\"od\"]\n\nOutPut :-10\nExpected : 9\n\nCan any one explain why ?\n\nMy Code:- \n class Solution {\npublic:\n    int minExtraChar(string s, vector<string>& dictionary) {\n        int n = dictionary.size();\n        int size = s.length();\n        vector<bool> v(size,false);\n        //int j = 0;\n        sort(dictionary.begin(),dictionary.end(),[](const string &s1,const string &s2){\n            return s1.size() > s2.size() ;\n        });\n        for(int i=0;i<n;i++){\n            size_t pos = s.find(dictionary[i],0);\n            if(pos!=string::npos){\n                //j = pos+dictionary[i].size();\n                //size = size - dictionary[i].size();\n                int k = dictionary[i].size();\n                while(pos!=string::npos){\n                    if(v[pos]==false && v[pos+k-1]==false){\n                        size = size - k;\n                        for(int j = pos;j<pos+k;j++){\n                            v[j]=true;\n                        }\n                    }\n                    pos = s.find(dictionary[i],pos+1);\n                    \n                }\n\n                \n            }\n        }\n        return size;\n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\n```\naakodubkrlauvfkzje\n ak\n  kod\n   od\n        rl\n        r\n            vfk\n            v\n```\nWith `9` extra characters you can produce this:\n```\n_ ak od _ _ _ rl _ _ vfk _ _ _\n```\n\nThe solution in your commend sorts the words by their size and then matches the words greedily.  \nIn this particular test case it finds the match `\"kod\"` and sets the corresponting element of `v` to `true`  \nbut then cannot match `\"ak\"` and `\"od\"` later on, even though their combination would match more characters.\n\nI don't thin a greedy approach will work for this exercise."
                    }
                ]
            },
            {
                "id": 2040177,
                "content": [
                    {
                        "username": "freezeen3",
                        "content": "The joy of solving a DP problem on your own is not something other types of problems can provide."
                    },
                    {
                        "username": "sans_102",
                        "content": "my buddy woke up and chose truth"
                    },
                    {
                        "username": "eduard92",
                        "content": "So I am not gonna have a weekend right Leetcode?"
                    },
                    {
                        "username": "sapercq",
                        "content": "\"kevlplxozaizdhxoimmraiakbak\"\\n[\"yv\",\"bmab\",\"hv\",\"bnsll\",\"mra\",\"jjqf\",\"g\",\"aiyzi\",\"ip\",\"pfctr\",\"flr\",\"ybbcl\",\"biu\",\"ke\",\"lpl\",\"iak\",\"pirua\",\"ilhqd\",\"zdhx\",\"fux\",\"xaw\",\"pdfvt\",\"xf\",\"t\",\"wq\",\"r\",\"cgmud\",\"aokas\",\"xv\",\"jf\",\"cyys\",\"wcaz\",\"rvegf\",\"ysg\",\"xo\",\"uwb\",\"lw\",\"okgk\",\"vbmi\",\"v\",\"mvo\",\"fxyx\",\"ad\",\"e\"]\\n\\nUse Testcase\\nOutput\\n8\\nExpected\\n9\\n1964 task\\nI count by myself and theres 8 letter that we don\\'t use.not 9"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@sapercq](/sapercq) The instructions say that \"*you have to break s into one or more **non-overlapping** substrings*\".  \\nYou cannot break `\"zdhxo\"` into `\"zdhx\"` and `\"xo\"`, those two words would overlap.-"
                    },
                    {
                        "username": "sapercq",
                        "content": "[@siebenschlaefer](/siebenschlaefer) You have \"XO\" in dictonary\\nAnd you have (zdh(x)o) but you didn\\'t write it in your answer\\nYou can use that XO for making 1.zdhx 2.zdh(xo)"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\\n```\\nkevlplxozaizdhxoimmraiakbak\\nke\\n e\\n  v\\n   lpl\\n      xo\\n           zdhx\\n              xo\\n                  mra\\n                   r\\n                     iak\\n```\\nWith `9` extra characters you can build `s` like this:\\n```\\nke v lpl xo _ _ _ zdhx _ _ _ mra iak _ _ _\\n```\\nI don\\'t see a way of achieving that with fewer extra characters."
                    },
                    {
                        "username": "sapercq",
                        "content": "Please answer me why not???"
                    },
                    {
                        "username": "sapercq",
                        "content": "(01{ke})ke!!!!!!!!!!!!!      (2{v})v  !!!!!!!!!!!!!       (3,4,5{lpl})lpl    !!!!!!!!!!!!!       (67{xo})xo  !!!!!!!!!!!!!        3 letters we don't use-----zai----- !!!!!!!!!!!!!  (11,12,13,14{zdhx})zdhx !!!!!!!!!!!!!  \n     (15{xo})o    !!!!!!!!!!!!!        2letters we don't use -------------im--------------(18,19,20{mra})mra      !!!!!!!!!!!!!        (21,22,23{iak})iak !!!!!!!!!!!!!       3 letters we dont use  -------bak--------\n3+2+3 = 8 not 9 "
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "There seems to be a wrong answer for azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf There are 14 extra characters while the answer choice is given as 15 in test cases. \\n"
                    },
                    {
                        "username": "sans_102",
                        "content": "\"hlwxjeastjqwkof\" this is the string after doing operations. there is X on 4th place."
                    },
                    {
                        "username": "ktnaneri",
                        "content": "It looks like you got the same mistake as me - you replace the substrings with \"\", and that way the string gets merged and impossible combinations start to appear. \\nTry to not merge the string but break into substrings and then check the existence of substrings in each of those parts instead. "
                    },
                    {
                        "username": "Qnide",
                        "content": "\\u0414\\u0410\\u0410\\u0410. \\u0422\\u041E\\u0416\\u0415 \\u0421\\u0410\\u041C\\u041E\\u0415"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Every weekend daily challenges always be a DP or a Graph type of problems.."
                    },
                    {
                        "username": "earlinn",
                        "content": "[@Rahul_108](/Rahul_108) me too"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "And so my weekends get ruined :\\'("
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis is the `cutting` type dp problem where inside the recursive function, you will have to iterate through each of the index and decide the optimal position to cut.\\n\\nAt each cut, you will be adding a char to your current String and then you will have to call the function again.\\n\\nWhen you cut, check whether the `currString` is in dictionary or not, if it is, it does not contribute to any extra character, but if it\\'s not, then it\\'s contribution will be its`length`.\\n\\nThen, count the future extras by calling the function again, at then end, find the `minimum` of `currExtra+futuExtra` for all possible cut positions"
                    },
                    {
                        "username": "alexeyvoronin",
                        "content": "How do we define \" non-overlapping substrings\" for this task? Are \"abc\" and \"bcd\" overlapping? are \"bad\" and \"a\" overlapping? Or should one string be inside another to be overlapping? Or should their ends have common sequences? "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In `\"abcd\"` -> `\"abc\"` & `\"bcd\"` are overlapping, while\\nIn `\"abcbcd\"` -> `\"abc\"` & `\"bcd\"` are not overlapping."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I spent a long time thinking that each word in dictionary can only be used once at most. I was very confused how this wasn\\'t considered a hard problem. Pro tip: Thats not the case, each substring has to be a word in the dictionary, but they dont have to be different words. "
                    },
                    {
                        "username": "Mentrix",
                        "content": "I think I may have found an error in test case number 1991. When using regex on the entire dictionary, sorting the words in descending order and simply replacing all matches with an empty string, my solution gives a minimum number of extra characters of 14, while the solution states it\\'s 15, which makes no sense to me, since if my solution should be wrong, my minimum remaining character should be HIGHER than the solution and not LOWER. Is there any way how I can report this testcase as I think it is wrong?"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Take the test case:\\n\"abcde\",[\"ae\",\"bcd\"]\\nYou would remove bcd and suddenly you have ae which also matches."
                    },
                    {
                        "username": "sumit_awatar",
                        "content": "For:-\nTestCase 2020\ns =\"aakodubkrlauvfkzje\"\ndictionary =[\"ix\",\"qoqw\",\"ax\",\"ar\",\"v\",\"hxpl\",\"nxcg\",\"thr\",\"kod\",\"pns\",\"cdo\",\"euy\",\"es\",\"rf\",\"bxcx\",\"xe\",\"ua\",\"vws\",\"vumr\",\"zren\",\"bzt\",\"qwxn\",\"ami\",\"rrbk\",\"ak\",\"uan\",\"g\",\"vfk\",\"jxmg\",\"fhb\",\"nqgd\",\"fau\",\"rl\",\"h\",\"r\",\"jxvo\",\"tv\",\"smfp\",\"lmck\",\"od\"]\n\nOutPut :-10\nExpected : 9\n\nCan any one explain why ?\n\nMy Code:- \n class Solution {\npublic:\n    int minExtraChar(string s, vector<string>& dictionary) {\n        int n = dictionary.size();\n        int size = s.length();\n        vector<bool> v(size,false);\n        //int j = 0;\n        sort(dictionary.begin(),dictionary.end(),[](const string &s1,const string &s2){\n            return s1.size() > s2.size() ;\n        });\n        for(int i=0;i<n;i++){\n            size_t pos = s.find(dictionary[i],0);\n            if(pos!=string::npos){\n                //j = pos+dictionary[i].size();\n                //size = size - dictionary[i].size();\n                int k = dictionary[i].size();\n                while(pos!=string::npos){\n                    if(v[pos]==false && v[pos+k-1]==false){\n                        size = size - k;\n                        for(int j = pos;j<pos+k;j++){\n                            v[j]=true;\n                        }\n                    }\n                    pos = s.find(dictionary[i],pos+1);\n                    \n                }\n\n                \n            }\n        }\n        return size;\n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\n```\naakodubkrlauvfkzje\n ak\n  kod\n   od\n        rl\n        r\n            vfk\n            v\n```\nWith `9` extra characters you can produce this:\n```\n_ ak od _ _ _ rl _ _ vfk _ _ _\n```\n\nThe solution in your commend sorts the words by their size and then matches the words greedily.  \nIn this particular test case it finds the match `\"kod\"` and sets the corresponting element of `v` to `true`  \nbut then cannot match `\"ak\"` and `\"od\"` later on, even though their combination would match more characters.\n\nI don't thin a greedy approach will work for this exercise."
                    }
                ]
            },
            {
                "id": 2040141,
                "content": [
                    {
                        "username": "freezeen3",
                        "content": "The joy of solving a DP problem on your own is not something other types of problems can provide."
                    },
                    {
                        "username": "sans_102",
                        "content": "my buddy woke up and chose truth"
                    },
                    {
                        "username": "eduard92",
                        "content": "So I am not gonna have a weekend right Leetcode?"
                    },
                    {
                        "username": "sapercq",
                        "content": "\"kevlplxozaizdhxoimmraiakbak\"\\n[\"yv\",\"bmab\",\"hv\",\"bnsll\",\"mra\",\"jjqf\",\"g\",\"aiyzi\",\"ip\",\"pfctr\",\"flr\",\"ybbcl\",\"biu\",\"ke\",\"lpl\",\"iak\",\"pirua\",\"ilhqd\",\"zdhx\",\"fux\",\"xaw\",\"pdfvt\",\"xf\",\"t\",\"wq\",\"r\",\"cgmud\",\"aokas\",\"xv\",\"jf\",\"cyys\",\"wcaz\",\"rvegf\",\"ysg\",\"xo\",\"uwb\",\"lw\",\"okgk\",\"vbmi\",\"v\",\"mvo\",\"fxyx\",\"ad\",\"e\"]\\n\\nUse Testcase\\nOutput\\n8\\nExpected\\n9\\n1964 task\\nI count by myself and theres 8 letter that we don\\'t use.not 9"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@sapercq](/sapercq) The instructions say that \"*you have to break s into one or more **non-overlapping** substrings*\".  \\nYou cannot break `\"zdhxo\"` into `\"zdhx\"` and `\"xo\"`, those two words would overlap.-"
                    },
                    {
                        "username": "sapercq",
                        "content": "[@siebenschlaefer](/siebenschlaefer) You have \"XO\" in dictonary\\nAnd you have (zdh(x)o) but you didn\\'t write it in your answer\\nYou can use that XO for making 1.zdhx 2.zdh(xo)"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\\n```\\nkevlplxozaizdhxoimmraiakbak\\nke\\n e\\n  v\\n   lpl\\n      xo\\n           zdhx\\n              xo\\n                  mra\\n                   r\\n                     iak\\n```\\nWith `9` extra characters you can build `s` like this:\\n```\\nke v lpl xo _ _ _ zdhx _ _ _ mra iak _ _ _\\n```\\nI don\\'t see a way of achieving that with fewer extra characters."
                    },
                    {
                        "username": "sapercq",
                        "content": "Please answer me why not???"
                    },
                    {
                        "username": "sapercq",
                        "content": "(01{ke})ke!!!!!!!!!!!!!      (2{v})v  !!!!!!!!!!!!!       (3,4,5{lpl})lpl    !!!!!!!!!!!!!       (67{xo})xo  !!!!!!!!!!!!!        3 letters we don't use-----zai----- !!!!!!!!!!!!!  (11,12,13,14{zdhx})zdhx !!!!!!!!!!!!!  \n     (15{xo})o    !!!!!!!!!!!!!        2letters we don't use -------------im--------------(18,19,20{mra})mra      !!!!!!!!!!!!!        (21,22,23{iak})iak !!!!!!!!!!!!!       3 letters we dont use  -------bak--------\n3+2+3 = 8 not 9 "
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "There seems to be a wrong answer for azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf There are 14 extra characters while the answer choice is given as 15 in test cases. \\n"
                    },
                    {
                        "username": "sans_102",
                        "content": "\"hlwxjeastjqwkof\" this is the string after doing operations. there is X on 4th place."
                    },
                    {
                        "username": "ktnaneri",
                        "content": "It looks like you got the same mistake as me - you replace the substrings with \"\", and that way the string gets merged and impossible combinations start to appear. \\nTry to not merge the string but break into substrings and then check the existence of substrings in each of those parts instead. "
                    },
                    {
                        "username": "Qnide",
                        "content": "\\u0414\\u0410\\u0410\\u0410. \\u0422\\u041E\\u0416\\u0415 \\u0421\\u0410\\u041C\\u041E\\u0415"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Every weekend daily challenges always be a DP or a Graph type of problems.."
                    },
                    {
                        "username": "earlinn",
                        "content": "[@Rahul_108](/Rahul_108) me too"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "And so my weekends get ruined :\\'("
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis is the `cutting` type dp problem where inside the recursive function, you will have to iterate through each of the index and decide the optimal position to cut.\\n\\nAt each cut, you will be adding a char to your current String and then you will have to call the function again.\\n\\nWhen you cut, check whether the `currString` is in dictionary or not, if it is, it does not contribute to any extra character, but if it\\'s not, then it\\'s contribution will be its`length`.\\n\\nThen, count the future extras by calling the function again, at then end, find the `minimum` of `currExtra+futuExtra` for all possible cut positions"
                    },
                    {
                        "username": "alexeyvoronin",
                        "content": "How do we define \" non-overlapping substrings\" for this task? Are \"abc\" and \"bcd\" overlapping? are \"bad\" and \"a\" overlapping? Or should one string be inside another to be overlapping? Or should their ends have common sequences? "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In `\"abcd\"` -> `\"abc\"` & `\"bcd\"` are overlapping, while\\nIn `\"abcbcd\"` -> `\"abc\"` & `\"bcd\"` are not overlapping."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I spent a long time thinking that each word in dictionary can only be used once at most. I was very confused how this wasn\\'t considered a hard problem. Pro tip: Thats not the case, each substring has to be a word in the dictionary, but they dont have to be different words. "
                    },
                    {
                        "username": "Mentrix",
                        "content": "I think I may have found an error in test case number 1991. When using regex on the entire dictionary, sorting the words in descending order and simply replacing all matches with an empty string, my solution gives a minimum number of extra characters of 14, while the solution states it\\'s 15, which makes no sense to me, since if my solution should be wrong, my minimum remaining character should be HIGHER than the solution and not LOWER. Is there any way how I can report this testcase as I think it is wrong?"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Take the test case:\\n\"abcde\",[\"ae\",\"bcd\"]\\nYou would remove bcd and suddenly you have ae which also matches."
                    },
                    {
                        "username": "sumit_awatar",
                        "content": "For:-\nTestCase 2020\ns =\"aakodubkrlauvfkzje\"\ndictionary =[\"ix\",\"qoqw\",\"ax\",\"ar\",\"v\",\"hxpl\",\"nxcg\",\"thr\",\"kod\",\"pns\",\"cdo\",\"euy\",\"es\",\"rf\",\"bxcx\",\"xe\",\"ua\",\"vws\",\"vumr\",\"zren\",\"bzt\",\"qwxn\",\"ami\",\"rrbk\",\"ak\",\"uan\",\"g\",\"vfk\",\"jxmg\",\"fhb\",\"nqgd\",\"fau\",\"rl\",\"h\",\"r\",\"jxvo\",\"tv\",\"smfp\",\"lmck\",\"od\"]\n\nOutPut :-10\nExpected : 9\n\nCan any one explain why ?\n\nMy Code:- \n class Solution {\npublic:\n    int minExtraChar(string s, vector<string>& dictionary) {\n        int n = dictionary.size();\n        int size = s.length();\n        vector<bool> v(size,false);\n        //int j = 0;\n        sort(dictionary.begin(),dictionary.end(),[](const string &s1,const string &s2){\n            return s1.size() > s2.size() ;\n        });\n        for(int i=0;i<n;i++){\n            size_t pos = s.find(dictionary[i],0);\n            if(pos!=string::npos){\n                //j = pos+dictionary[i].size();\n                //size = size - dictionary[i].size();\n                int k = dictionary[i].size();\n                while(pos!=string::npos){\n                    if(v[pos]==false && v[pos+k-1]==false){\n                        size = size - k;\n                        for(int j = pos;j<pos+k;j++){\n                            v[j]=true;\n                        }\n                    }\n                    pos = s.find(dictionary[i],pos+1);\n                    \n                }\n\n                \n            }\n        }\n        return size;\n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\n```\naakodubkrlauvfkzje\n ak\n  kod\n   od\n        rl\n        r\n            vfk\n            v\n```\nWith `9` extra characters you can produce this:\n```\n_ ak od _ _ _ rl _ _ vfk _ _ _\n```\n\nThe solution in your commend sorts the words by their size and then matches the words greedily.  \nIn this particular test case it finds the match `\"kod\"` and sets the corresponting element of `v` to `true`  \nbut then cannot match `\"ak\"` and `\"od\"` later on, even though their combination would match more characters.\n\nI don't thin a greedy approach will work for this exercise."
                    }
                ]
            },
            {
                "id": 2014442,
                "content": [
                    {
                        "username": "freezeen3",
                        "content": "The joy of solving a DP problem on your own is not something other types of problems can provide."
                    },
                    {
                        "username": "sans_102",
                        "content": "my buddy woke up and chose truth"
                    },
                    {
                        "username": "eduard92",
                        "content": "So I am not gonna have a weekend right Leetcode?"
                    },
                    {
                        "username": "sapercq",
                        "content": "\"kevlplxozaizdhxoimmraiakbak\"\\n[\"yv\",\"bmab\",\"hv\",\"bnsll\",\"mra\",\"jjqf\",\"g\",\"aiyzi\",\"ip\",\"pfctr\",\"flr\",\"ybbcl\",\"biu\",\"ke\",\"lpl\",\"iak\",\"pirua\",\"ilhqd\",\"zdhx\",\"fux\",\"xaw\",\"pdfvt\",\"xf\",\"t\",\"wq\",\"r\",\"cgmud\",\"aokas\",\"xv\",\"jf\",\"cyys\",\"wcaz\",\"rvegf\",\"ysg\",\"xo\",\"uwb\",\"lw\",\"okgk\",\"vbmi\",\"v\",\"mvo\",\"fxyx\",\"ad\",\"e\"]\\n\\nUse Testcase\\nOutput\\n8\\nExpected\\n9\\n1964 task\\nI count by myself and theres 8 letter that we don\\'t use.not 9"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@sapercq](/sapercq) The instructions say that \"*you have to break s into one or more **non-overlapping** substrings*\".  \\nYou cannot break `\"zdhxo\"` into `\"zdhx\"` and `\"xo\"`, those two words would overlap.-"
                    },
                    {
                        "username": "sapercq",
                        "content": "[@siebenschlaefer](/siebenschlaefer) You have \"XO\" in dictonary\\nAnd you have (zdh(x)o) but you didn\\'t write it in your answer\\nYou can use that XO for making 1.zdhx 2.zdh(xo)"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\\n```\\nkevlplxozaizdhxoimmraiakbak\\nke\\n e\\n  v\\n   lpl\\n      xo\\n           zdhx\\n              xo\\n                  mra\\n                   r\\n                     iak\\n```\\nWith `9` extra characters you can build `s` like this:\\n```\\nke v lpl xo _ _ _ zdhx _ _ _ mra iak _ _ _\\n```\\nI don\\'t see a way of achieving that with fewer extra characters."
                    },
                    {
                        "username": "sapercq",
                        "content": "Please answer me why not???"
                    },
                    {
                        "username": "sapercq",
                        "content": "(01{ke})ke!!!!!!!!!!!!!      (2{v})v  !!!!!!!!!!!!!       (3,4,5{lpl})lpl    !!!!!!!!!!!!!       (67{xo})xo  !!!!!!!!!!!!!        3 letters we don't use-----zai----- !!!!!!!!!!!!!  (11,12,13,14{zdhx})zdhx !!!!!!!!!!!!!  \n     (15{xo})o    !!!!!!!!!!!!!        2letters we don't use -------------im--------------(18,19,20{mra})mra      !!!!!!!!!!!!!        (21,22,23{iak})iak !!!!!!!!!!!!!       3 letters we dont use  -------bak--------\n3+2+3 = 8 not 9 "
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "There seems to be a wrong answer for azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf There are 14 extra characters while the answer choice is given as 15 in test cases. \\n"
                    },
                    {
                        "username": "sans_102",
                        "content": "\"hlwxjeastjqwkof\" this is the string after doing operations. there is X on 4th place."
                    },
                    {
                        "username": "ktnaneri",
                        "content": "It looks like you got the same mistake as me - you replace the substrings with \"\", and that way the string gets merged and impossible combinations start to appear. \\nTry to not merge the string but break into substrings and then check the existence of substrings in each of those parts instead. "
                    },
                    {
                        "username": "Qnide",
                        "content": "\\u0414\\u0410\\u0410\\u0410. \\u0422\\u041E\\u0416\\u0415 \\u0421\\u0410\\u041C\\u041E\\u0415"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Every weekend daily challenges always be a DP or a Graph type of problems.."
                    },
                    {
                        "username": "earlinn",
                        "content": "[@Rahul_108](/Rahul_108) me too"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "And so my weekends get ruined :\\'("
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis is the `cutting` type dp problem where inside the recursive function, you will have to iterate through each of the index and decide the optimal position to cut.\\n\\nAt each cut, you will be adding a char to your current String and then you will have to call the function again.\\n\\nWhen you cut, check whether the `currString` is in dictionary or not, if it is, it does not contribute to any extra character, but if it\\'s not, then it\\'s contribution will be its`length`.\\n\\nThen, count the future extras by calling the function again, at then end, find the `minimum` of `currExtra+futuExtra` for all possible cut positions"
                    },
                    {
                        "username": "alexeyvoronin",
                        "content": "How do we define \" non-overlapping substrings\" for this task? Are \"abc\" and \"bcd\" overlapping? are \"bad\" and \"a\" overlapping? Or should one string be inside another to be overlapping? Or should their ends have common sequences? "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In `\"abcd\"` -> `\"abc\"` & `\"bcd\"` are overlapping, while\\nIn `\"abcbcd\"` -> `\"abc\"` & `\"bcd\"` are not overlapping."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I spent a long time thinking that each word in dictionary can only be used once at most. I was very confused how this wasn\\'t considered a hard problem. Pro tip: Thats not the case, each substring has to be a word in the dictionary, but they dont have to be different words. "
                    },
                    {
                        "username": "Mentrix",
                        "content": "I think I may have found an error in test case number 1991. When using regex on the entire dictionary, sorting the words in descending order and simply replacing all matches with an empty string, my solution gives a minimum number of extra characters of 14, while the solution states it\\'s 15, which makes no sense to me, since if my solution should be wrong, my minimum remaining character should be HIGHER than the solution and not LOWER. Is there any way how I can report this testcase as I think it is wrong?"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Take the test case:\\n\"abcde\",[\"ae\",\"bcd\"]\\nYou would remove bcd and suddenly you have ae which also matches."
                    },
                    {
                        "username": "sumit_awatar",
                        "content": "For:-\nTestCase 2020\ns =\"aakodubkrlauvfkzje\"\ndictionary =[\"ix\",\"qoqw\",\"ax\",\"ar\",\"v\",\"hxpl\",\"nxcg\",\"thr\",\"kod\",\"pns\",\"cdo\",\"euy\",\"es\",\"rf\",\"bxcx\",\"xe\",\"ua\",\"vws\",\"vumr\",\"zren\",\"bzt\",\"qwxn\",\"ami\",\"rrbk\",\"ak\",\"uan\",\"g\",\"vfk\",\"jxmg\",\"fhb\",\"nqgd\",\"fau\",\"rl\",\"h\",\"r\",\"jxvo\",\"tv\",\"smfp\",\"lmck\",\"od\"]\n\nOutPut :-10\nExpected : 9\n\nCan any one explain why ?\n\nMy Code:- \n class Solution {\npublic:\n    int minExtraChar(string s, vector<string>& dictionary) {\n        int n = dictionary.size();\n        int size = s.length();\n        vector<bool> v(size,false);\n        //int j = 0;\n        sort(dictionary.begin(),dictionary.end(),[](const string &s1,const string &s2){\n            return s1.size() > s2.size() ;\n        });\n        for(int i=0;i<n;i++){\n            size_t pos = s.find(dictionary[i],0);\n            if(pos!=string::npos){\n                //j = pos+dictionary[i].size();\n                //size = size - dictionary[i].size();\n                int k = dictionary[i].size();\n                while(pos!=string::npos){\n                    if(v[pos]==false && v[pos+k-1]==false){\n                        size = size - k;\n                        for(int j = pos;j<pos+k;j++){\n                            v[j]=true;\n                        }\n                    }\n                    pos = s.find(dictionary[i],pos+1);\n                    \n                }\n\n                \n            }\n        }\n        return size;\n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\n```\naakodubkrlauvfkzje\n ak\n  kod\n   od\n        rl\n        r\n            vfk\n            v\n```\nWith `9` extra characters you can produce this:\n```\n_ ak od _ _ _ rl _ _ vfk _ _ _\n```\n\nThe solution in your commend sorts the words by their size and then matches the words greedily.  \nIn this particular test case it finds the match `\"kod\"` and sets the corresponting element of `v` to `true`  \nbut then cannot match `\"ak\"` and `\"od\"` later on, even though their combination would match more characters.\n\nI don't thin a greedy approach will work for this exercise."
                    }
                ]
            },
            {
                "id": 2040782,
                "content": [
                    {
                        "username": "freezeen3",
                        "content": "The joy of solving a DP problem on your own is not something other types of problems can provide."
                    },
                    {
                        "username": "sans_102",
                        "content": "my buddy woke up and chose truth"
                    },
                    {
                        "username": "eduard92",
                        "content": "So I am not gonna have a weekend right Leetcode?"
                    },
                    {
                        "username": "sapercq",
                        "content": "\"kevlplxozaizdhxoimmraiakbak\"\\n[\"yv\",\"bmab\",\"hv\",\"bnsll\",\"mra\",\"jjqf\",\"g\",\"aiyzi\",\"ip\",\"pfctr\",\"flr\",\"ybbcl\",\"biu\",\"ke\",\"lpl\",\"iak\",\"pirua\",\"ilhqd\",\"zdhx\",\"fux\",\"xaw\",\"pdfvt\",\"xf\",\"t\",\"wq\",\"r\",\"cgmud\",\"aokas\",\"xv\",\"jf\",\"cyys\",\"wcaz\",\"rvegf\",\"ysg\",\"xo\",\"uwb\",\"lw\",\"okgk\",\"vbmi\",\"v\",\"mvo\",\"fxyx\",\"ad\",\"e\"]\\n\\nUse Testcase\\nOutput\\n8\\nExpected\\n9\\n1964 task\\nI count by myself and theres 8 letter that we don\\'t use.not 9"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@sapercq](/sapercq) The instructions say that \"*you have to break s into one or more **non-overlapping** substrings*\".  \\nYou cannot break `\"zdhxo\"` into `\"zdhx\"` and `\"xo\"`, those two words would overlap.-"
                    },
                    {
                        "username": "sapercq",
                        "content": "[@siebenschlaefer](/siebenschlaefer) You have \"XO\" in dictonary\\nAnd you have (zdh(x)o) but you didn\\'t write it in your answer\\nYou can use that XO for making 1.zdhx 2.zdh(xo)"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\\n```\\nkevlplxozaizdhxoimmraiakbak\\nke\\n e\\n  v\\n   lpl\\n      xo\\n           zdhx\\n              xo\\n                  mra\\n                   r\\n                     iak\\n```\\nWith `9` extra characters you can build `s` like this:\\n```\\nke v lpl xo _ _ _ zdhx _ _ _ mra iak _ _ _\\n```\\nI don\\'t see a way of achieving that with fewer extra characters."
                    },
                    {
                        "username": "sapercq",
                        "content": "Please answer me why not???"
                    },
                    {
                        "username": "sapercq",
                        "content": "(01{ke})ke!!!!!!!!!!!!!      (2{v})v  !!!!!!!!!!!!!       (3,4,5{lpl})lpl    !!!!!!!!!!!!!       (67{xo})xo  !!!!!!!!!!!!!        3 letters we don't use-----zai----- !!!!!!!!!!!!!  (11,12,13,14{zdhx})zdhx !!!!!!!!!!!!!  \n     (15{xo})o    !!!!!!!!!!!!!        2letters we don't use -------------im--------------(18,19,20{mra})mra      !!!!!!!!!!!!!        (21,22,23{iak})iak !!!!!!!!!!!!!       3 letters we dont use  -------bak--------\n3+2+3 = 8 not 9 "
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "There seems to be a wrong answer for azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf There are 14 extra characters while the answer choice is given as 15 in test cases. \\n"
                    },
                    {
                        "username": "sans_102",
                        "content": "\"hlwxjeastjqwkof\" this is the string after doing operations. there is X on 4th place."
                    },
                    {
                        "username": "ktnaneri",
                        "content": "It looks like you got the same mistake as me - you replace the substrings with \"\", and that way the string gets merged and impossible combinations start to appear. \\nTry to not merge the string but break into substrings and then check the existence of substrings in each of those parts instead. "
                    },
                    {
                        "username": "Qnide",
                        "content": "\\u0414\\u0410\\u0410\\u0410. \\u0422\\u041E\\u0416\\u0415 \\u0421\\u0410\\u041C\\u041E\\u0415"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Every weekend daily challenges always be a DP or a Graph type of problems.."
                    },
                    {
                        "username": "earlinn",
                        "content": "[@Rahul_108](/Rahul_108) me too"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "And so my weekends get ruined :\\'("
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis is the `cutting` type dp problem where inside the recursive function, you will have to iterate through each of the index and decide the optimal position to cut.\\n\\nAt each cut, you will be adding a char to your current String and then you will have to call the function again.\\n\\nWhen you cut, check whether the `currString` is in dictionary or not, if it is, it does not contribute to any extra character, but if it\\'s not, then it\\'s contribution will be its`length`.\\n\\nThen, count the future extras by calling the function again, at then end, find the `minimum` of `currExtra+futuExtra` for all possible cut positions"
                    },
                    {
                        "username": "alexeyvoronin",
                        "content": "How do we define \" non-overlapping substrings\" for this task? Are \"abc\" and \"bcd\" overlapping? are \"bad\" and \"a\" overlapping? Or should one string be inside another to be overlapping? Or should their ends have common sequences? "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In `\"abcd\"` -> `\"abc\"` & `\"bcd\"` are overlapping, while\\nIn `\"abcbcd\"` -> `\"abc\"` & `\"bcd\"` are not overlapping."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I spent a long time thinking that each word in dictionary can only be used once at most. I was very confused how this wasn\\'t considered a hard problem. Pro tip: Thats not the case, each substring has to be a word in the dictionary, but they dont have to be different words. "
                    },
                    {
                        "username": "Mentrix",
                        "content": "I think I may have found an error in test case number 1991. When using regex on the entire dictionary, sorting the words in descending order and simply replacing all matches with an empty string, my solution gives a minimum number of extra characters of 14, while the solution states it\\'s 15, which makes no sense to me, since if my solution should be wrong, my minimum remaining character should be HIGHER than the solution and not LOWER. Is there any way how I can report this testcase as I think it is wrong?"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Take the test case:\\n\"abcde\",[\"ae\",\"bcd\"]\\nYou would remove bcd and suddenly you have ae which also matches."
                    },
                    {
                        "username": "sumit_awatar",
                        "content": "For:-\nTestCase 2020\ns =\"aakodubkrlauvfkzje\"\ndictionary =[\"ix\",\"qoqw\",\"ax\",\"ar\",\"v\",\"hxpl\",\"nxcg\",\"thr\",\"kod\",\"pns\",\"cdo\",\"euy\",\"es\",\"rf\",\"bxcx\",\"xe\",\"ua\",\"vws\",\"vumr\",\"zren\",\"bzt\",\"qwxn\",\"ami\",\"rrbk\",\"ak\",\"uan\",\"g\",\"vfk\",\"jxmg\",\"fhb\",\"nqgd\",\"fau\",\"rl\",\"h\",\"r\",\"jxvo\",\"tv\",\"smfp\",\"lmck\",\"od\"]\n\nOutPut :-10\nExpected : 9\n\nCan any one explain why ?\n\nMy Code:- \n class Solution {\npublic:\n    int minExtraChar(string s, vector<string>& dictionary) {\n        int n = dictionary.size();\n        int size = s.length();\n        vector<bool> v(size,false);\n        //int j = 0;\n        sort(dictionary.begin(),dictionary.end(),[](const string &s1,const string &s2){\n            return s1.size() > s2.size() ;\n        });\n        for(int i=0;i<n;i++){\n            size_t pos = s.find(dictionary[i],0);\n            if(pos!=string::npos){\n                //j = pos+dictionary[i].size();\n                //size = size - dictionary[i].size();\n                int k = dictionary[i].size();\n                while(pos!=string::npos){\n                    if(v[pos]==false && v[pos+k-1]==false){\n                        size = size - k;\n                        for(int j = pos;j<pos+k;j++){\n                            v[j]=true;\n                        }\n                    }\n                    pos = s.find(dictionary[i],pos+1);\n                    \n                }\n\n                \n            }\n        }\n        return size;\n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\n```\naakodubkrlauvfkzje\n ak\n  kod\n   od\n        rl\n        r\n            vfk\n            v\n```\nWith `9` extra characters you can produce this:\n```\n_ ak od _ _ _ rl _ _ vfk _ _ _\n```\n\nThe solution in your commend sorts the words by their size and then matches the words greedily.  \nIn this particular test case it finds the match `\"kod\"` and sets the corresponting element of `v` to `true`  \nbut then cannot match `\"ak\"` and `\"od\"` later on, even though their combination would match more characters.\n\nI don't thin a greedy approach will work for this exercise."
                    }
                ]
            },
            {
                "id": 2040744,
                "content": [
                    {
                        "username": "freezeen3",
                        "content": "The joy of solving a DP problem on your own is not something other types of problems can provide."
                    },
                    {
                        "username": "sans_102",
                        "content": "my buddy woke up and chose truth"
                    },
                    {
                        "username": "eduard92",
                        "content": "So I am not gonna have a weekend right Leetcode?"
                    },
                    {
                        "username": "sapercq",
                        "content": "\"kevlplxozaizdhxoimmraiakbak\"\\n[\"yv\",\"bmab\",\"hv\",\"bnsll\",\"mra\",\"jjqf\",\"g\",\"aiyzi\",\"ip\",\"pfctr\",\"flr\",\"ybbcl\",\"biu\",\"ke\",\"lpl\",\"iak\",\"pirua\",\"ilhqd\",\"zdhx\",\"fux\",\"xaw\",\"pdfvt\",\"xf\",\"t\",\"wq\",\"r\",\"cgmud\",\"aokas\",\"xv\",\"jf\",\"cyys\",\"wcaz\",\"rvegf\",\"ysg\",\"xo\",\"uwb\",\"lw\",\"okgk\",\"vbmi\",\"v\",\"mvo\",\"fxyx\",\"ad\",\"e\"]\\n\\nUse Testcase\\nOutput\\n8\\nExpected\\n9\\n1964 task\\nI count by myself and theres 8 letter that we don\\'t use.not 9"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@sapercq](/sapercq) The instructions say that \"*you have to break s into one or more **non-overlapping** substrings*\".  \\nYou cannot break `\"zdhxo\"` into `\"zdhx\"` and `\"xo\"`, those two words would overlap.-"
                    },
                    {
                        "username": "sapercq",
                        "content": "[@siebenschlaefer](/siebenschlaefer) You have \"XO\" in dictonary\\nAnd you have (zdh(x)o) but you didn\\'t write it in your answer\\nYou can use that XO for making 1.zdhx 2.zdh(xo)"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\\n```\\nkevlplxozaizdhxoimmraiakbak\\nke\\n e\\n  v\\n   lpl\\n      xo\\n           zdhx\\n              xo\\n                  mra\\n                   r\\n                     iak\\n```\\nWith `9` extra characters you can build `s` like this:\\n```\\nke v lpl xo _ _ _ zdhx _ _ _ mra iak _ _ _\\n```\\nI don\\'t see a way of achieving that with fewer extra characters."
                    },
                    {
                        "username": "sapercq",
                        "content": "Please answer me why not???"
                    },
                    {
                        "username": "sapercq",
                        "content": "(01{ke})ke!!!!!!!!!!!!!      (2{v})v  !!!!!!!!!!!!!       (3,4,5{lpl})lpl    !!!!!!!!!!!!!       (67{xo})xo  !!!!!!!!!!!!!        3 letters we don't use-----zai----- !!!!!!!!!!!!!  (11,12,13,14{zdhx})zdhx !!!!!!!!!!!!!  \n     (15{xo})o    !!!!!!!!!!!!!        2letters we don't use -------------im--------------(18,19,20{mra})mra      !!!!!!!!!!!!!        (21,22,23{iak})iak !!!!!!!!!!!!!       3 letters we dont use  -------bak--------\n3+2+3 = 8 not 9 "
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "There seems to be a wrong answer for azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf There are 14 extra characters while the answer choice is given as 15 in test cases. \\n"
                    },
                    {
                        "username": "sans_102",
                        "content": "\"hlwxjeastjqwkof\" this is the string after doing operations. there is X on 4th place."
                    },
                    {
                        "username": "ktnaneri",
                        "content": "It looks like you got the same mistake as me - you replace the substrings with \"\", and that way the string gets merged and impossible combinations start to appear. \\nTry to not merge the string but break into substrings and then check the existence of substrings in each of those parts instead. "
                    },
                    {
                        "username": "Qnide",
                        "content": "\\u0414\\u0410\\u0410\\u0410. \\u0422\\u041E\\u0416\\u0415 \\u0421\\u0410\\u041C\\u041E\\u0415"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Every weekend daily challenges always be a DP or a Graph type of problems.."
                    },
                    {
                        "username": "earlinn",
                        "content": "[@Rahul_108](/Rahul_108) me too"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "And so my weekends get ruined :\\'("
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis is the `cutting` type dp problem where inside the recursive function, you will have to iterate through each of the index and decide the optimal position to cut.\\n\\nAt each cut, you will be adding a char to your current String and then you will have to call the function again.\\n\\nWhen you cut, check whether the `currString` is in dictionary or not, if it is, it does not contribute to any extra character, but if it\\'s not, then it\\'s contribution will be its`length`.\\n\\nThen, count the future extras by calling the function again, at then end, find the `minimum` of `currExtra+futuExtra` for all possible cut positions"
                    },
                    {
                        "username": "alexeyvoronin",
                        "content": "How do we define \" non-overlapping substrings\" for this task? Are \"abc\" and \"bcd\" overlapping? are \"bad\" and \"a\" overlapping? Or should one string be inside another to be overlapping? Or should their ends have common sequences? "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In `\"abcd\"` -> `\"abc\"` & `\"bcd\"` are overlapping, while\\nIn `\"abcbcd\"` -> `\"abc\"` & `\"bcd\"` are not overlapping."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I spent a long time thinking that each word in dictionary can only be used once at most. I was very confused how this wasn\\'t considered a hard problem. Pro tip: Thats not the case, each substring has to be a word in the dictionary, but they dont have to be different words. "
                    },
                    {
                        "username": "Mentrix",
                        "content": "I think I may have found an error in test case number 1991. When using regex on the entire dictionary, sorting the words in descending order and simply replacing all matches with an empty string, my solution gives a minimum number of extra characters of 14, while the solution states it\\'s 15, which makes no sense to me, since if my solution should be wrong, my minimum remaining character should be HIGHER than the solution and not LOWER. Is there any way how I can report this testcase as I think it is wrong?"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Take the test case:\\n\"abcde\",[\"ae\",\"bcd\"]\\nYou would remove bcd and suddenly you have ae which also matches."
                    },
                    {
                        "username": "sumit_awatar",
                        "content": "For:-\nTestCase 2020\ns =\"aakodubkrlauvfkzje\"\ndictionary =[\"ix\",\"qoqw\",\"ax\",\"ar\",\"v\",\"hxpl\",\"nxcg\",\"thr\",\"kod\",\"pns\",\"cdo\",\"euy\",\"es\",\"rf\",\"bxcx\",\"xe\",\"ua\",\"vws\",\"vumr\",\"zren\",\"bzt\",\"qwxn\",\"ami\",\"rrbk\",\"ak\",\"uan\",\"g\",\"vfk\",\"jxmg\",\"fhb\",\"nqgd\",\"fau\",\"rl\",\"h\",\"r\",\"jxvo\",\"tv\",\"smfp\",\"lmck\",\"od\"]\n\nOutPut :-10\nExpected : 9\n\nCan any one explain why ?\n\nMy Code:- \n class Solution {\npublic:\n    int minExtraChar(string s, vector<string>& dictionary) {\n        int n = dictionary.size();\n        int size = s.length();\n        vector<bool> v(size,false);\n        //int j = 0;\n        sort(dictionary.begin(),dictionary.end(),[](const string &s1,const string &s2){\n            return s1.size() > s2.size() ;\n        });\n        for(int i=0;i<n;i++){\n            size_t pos = s.find(dictionary[i],0);\n            if(pos!=string::npos){\n                //j = pos+dictionary[i].size();\n                //size = size - dictionary[i].size();\n                int k = dictionary[i].size();\n                while(pos!=string::npos){\n                    if(v[pos]==false && v[pos+k-1]==false){\n                        size = size - k;\n                        for(int j = pos;j<pos+k;j++){\n                            v[j]=true;\n                        }\n                    }\n                    pos = s.find(dictionary[i],pos+1);\n                    \n                }\n\n                \n            }\n        }\n        return size;\n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\n```\naakodubkrlauvfkzje\n ak\n  kod\n   od\n        rl\n        r\n            vfk\n            v\n```\nWith `9` extra characters you can produce this:\n```\n_ ak od _ _ _ rl _ _ vfk _ _ _\n```\n\nThe solution in your commend sorts the words by their size and then matches the words greedily.  \nIn this particular test case it finds the match `\"kod\"` and sets the corresponting element of `v` to `true`  \nbut then cannot match `\"ak\"` and `\"od\"` later on, even though their combination would match more characters.\n\nI don't thin a greedy approach will work for this exercise."
                    }
                ]
            },
            {
                "id": 2040359,
                "content": [
                    {
                        "username": "freezeen3",
                        "content": "The joy of solving a DP problem on your own is not something other types of problems can provide."
                    },
                    {
                        "username": "sans_102",
                        "content": "my buddy woke up and chose truth"
                    },
                    {
                        "username": "eduard92",
                        "content": "So I am not gonna have a weekend right Leetcode?"
                    },
                    {
                        "username": "sapercq",
                        "content": "\"kevlplxozaizdhxoimmraiakbak\"\\n[\"yv\",\"bmab\",\"hv\",\"bnsll\",\"mra\",\"jjqf\",\"g\",\"aiyzi\",\"ip\",\"pfctr\",\"flr\",\"ybbcl\",\"biu\",\"ke\",\"lpl\",\"iak\",\"pirua\",\"ilhqd\",\"zdhx\",\"fux\",\"xaw\",\"pdfvt\",\"xf\",\"t\",\"wq\",\"r\",\"cgmud\",\"aokas\",\"xv\",\"jf\",\"cyys\",\"wcaz\",\"rvegf\",\"ysg\",\"xo\",\"uwb\",\"lw\",\"okgk\",\"vbmi\",\"v\",\"mvo\",\"fxyx\",\"ad\",\"e\"]\\n\\nUse Testcase\\nOutput\\n8\\nExpected\\n9\\n1964 task\\nI count by myself and theres 8 letter that we don\\'t use.not 9"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@sapercq](/sapercq) The instructions say that \"*you have to break s into one or more **non-overlapping** substrings*\".  \\nYou cannot break `\"zdhxo\"` into `\"zdhx\"` and `\"xo\"`, those two words would overlap.-"
                    },
                    {
                        "username": "sapercq",
                        "content": "[@siebenschlaefer](/siebenschlaefer) You have \"XO\" in dictonary\\nAnd you have (zdh(x)o) but you didn\\'t write it in your answer\\nYou can use that XO for making 1.zdhx 2.zdh(xo)"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\\n```\\nkevlplxozaizdhxoimmraiakbak\\nke\\n e\\n  v\\n   lpl\\n      xo\\n           zdhx\\n              xo\\n                  mra\\n                   r\\n                     iak\\n```\\nWith `9` extra characters you can build `s` like this:\\n```\\nke v lpl xo _ _ _ zdhx _ _ _ mra iak _ _ _\\n```\\nI don\\'t see a way of achieving that with fewer extra characters."
                    },
                    {
                        "username": "sapercq",
                        "content": "Please answer me why not???"
                    },
                    {
                        "username": "sapercq",
                        "content": "(01{ke})ke!!!!!!!!!!!!!      (2{v})v  !!!!!!!!!!!!!       (3,4,5{lpl})lpl    !!!!!!!!!!!!!       (67{xo})xo  !!!!!!!!!!!!!        3 letters we don't use-----zai----- !!!!!!!!!!!!!  (11,12,13,14{zdhx})zdhx !!!!!!!!!!!!!  \n     (15{xo})o    !!!!!!!!!!!!!        2letters we don't use -------------im--------------(18,19,20{mra})mra      !!!!!!!!!!!!!        (21,22,23{iak})iak !!!!!!!!!!!!!       3 letters we dont use  -------bak--------\n3+2+3 = 8 not 9 "
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "There seems to be a wrong answer for azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf There are 14 extra characters while the answer choice is given as 15 in test cases. \\n"
                    },
                    {
                        "username": "sans_102",
                        "content": "\"hlwxjeastjqwkof\" this is the string after doing operations. there is X on 4th place."
                    },
                    {
                        "username": "ktnaneri",
                        "content": "It looks like you got the same mistake as me - you replace the substrings with \"\", and that way the string gets merged and impossible combinations start to appear. \\nTry to not merge the string but break into substrings and then check the existence of substrings in each of those parts instead. "
                    },
                    {
                        "username": "Qnide",
                        "content": "\\u0414\\u0410\\u0410\\u0410. \\u0422\\u041E\\u0416\\u0415 \\u0421\\u0410\\u041C\\u041E\\u0415"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Every weekend daily challenges always be a DP or a Graph type of problems.."
                    },
                    {
                        "username": "earlinn",
                        "content": "[@Rahul_108](/Rahul_108) me too"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "And so my weekends get ruined :\\'("
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis is the `cutting` type dp problem where inside the recursive function, you will have to iterate through each of the index and decide the optimal position to cut.\\n\\nAt each cut, you will be adding a char to your current String and then you will have to call the function again.\\n\\nWhen you cut, check whether the `currString` is in dictionary or not, if it is, it does not contribute to any extra character, but if it\\'s not, then it\\'s contribution will be its`length`.\\n\\nThen, count the future extras by calling the function again, at then end, find the `minimum` of `currExtra+futuExtra` for all possible cut positions"
                    },
                    {
                        "username": "alexeyvoronin",
                        "content": "How do we define \" non-overlapping substrings\" for this task? Are \"abc\" and \"bcd\" overlapping? are \"bad\" and \"a\" overlapping? Or should one string be inside another to be overlapping? Or should their ends have common sequences? "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In `\"abcd\"` -> `\"abc\"` & `\"bcd\"` are overlapping, while\\nIn `\"abcbcd\"` -> `\"abc\"` & `\"bcd\"` are not overlapping."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I spent a long time thinking that each word in dictionary can only be used once at most. I was very confused how this wasn\\'t considered a hard problem. Pro tip: Thats not the case, each substring has to be a word in the dictionary, but they dont have to be different words. "
                    },
                    {
                        "username": "Mentrix",
                        "content": "I think I may have found an error in test case number 1991. When using regex on the entire dictionary, sorting the words in descending order and simply replacing all matches with an empty string, my solution gives a minimum number of extra characters of 14, while the solution states it\\'s 15, which makes no sense to me, since if my solution should be wrong, my minimum remaining character should be HIGHER than the solution and not LOWER. Is there any way how I can report this testcase as I think it is wrong?"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Take the test case:\\n\"abcde\",[\"ae\",\"bcd\"]\\nYou would remove bcd and suddenly you have ae which also matches."
                    },
                    {
                        "username": "sumit_awatar",
                        "content": "For:-\nTestCase 2020\ns =\"aakodubkrlauvfkzje\"\ndictionary =[\"ix\",\"qoqw\",\"ax\",\"ar\",\"v\",\"hxpl\",\"nxcg\",\"thr\",\"kod\",\"pns\",\"cdo\",\"euy\",\"es\",\"rf\",\"bxcx\",\"xe\",\"ua\",\"vws\",\"vumr\",\"zren\",\"bzt\",\"qwxn\",\"ami\",\"rrbk\",\"ak\",\"uan\",\"g\",\"vfk\",\"jxmg\",\"fhb\",\"nqgd\",\"fau\",\"rl\",\"h\",\"r\",\"jxvo\",\"tv\",\"smfp\",\"lmck\",\"od\"]\n\nOutPut :-10\nExpected : 9\n\nCan any one explain why ?\n\nMy Code:- \n class Solution {\npublic:\n    int minExtraChar(string s, vector<string>& dictionary) {\n        int n = dictionary.size();\n        int size = s.length();\n        vector<bool> v(size,false);\n        //int j = 0;\n        sort(dictionary.begin(),dictionary.end(),[](const string &s1,const string &s2){\n            return s1.size() > s2.size() ;\n        });\n        for(int i=0;i<n;i++){\n            size_t pos = s.find(dictionary[i],0);\n            if(pos!=string::npos){\n                //j = pos+dictionary[i].size();\n                //size = size - dictionary[i].size();\n                int k = dictionary[i].size();\n                while(pos!=string::npos){\n                    if(v[pos]==false && v[pos+k-1]==false){\n                        size = size - k;\n                        for(int j = pos;j<pos+k;j++){\n                            v[j]=true;\n                        }\n                    }\n                    pos = s.find(dictionary[i],pos+1);\n                    \n                }\n\n                \n            }\n        }\n        return size;\n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\n```\naakodubkrlauvfkzje\n ak\n  kod\n   od\n        rl\n        r\n            vfk\n            v\n```\nWith `9` extra characters you can produce this:\n```\n_ ak od _ _ _ rl _ _ vfk _ _ _\n```\n\nThe solution in your commend sorts the words by their size and then matches the words greedily.  \nIn this particular test case it finds the match `\"kod\"` and sets the corresponting element of `v` to `true`  \nbut then cannot match `\"ak\"` and `\"od\"` later on, even though their combination would match more characters.\n\nI don't thin a greedy approach will work for this exercise."
                    }
                ]
            },
            {
                "id": 2040017,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "kinda tough seeing the dp recurrence relation "
                    },
                    {
                        "username": "miglani_9121",
                        "content": "why my answer is coming wrong at this testcase while i am solving the question brutly\\ns=\"kevlplxozaizdhxoimmraiakbak\"\\ndict =[\"yv\",\"bmab\",\"hv\",\"bnsll\",\"mra\",\"jjqf\",\"g\",\"aiyzi\",\"ip\",\"pfctr\",\"flr\",\"ybbcl\",\"biu\",\"ke\",\"lpl\",\"iak\",\"pirua\",\"ilhqd\",\"zdhx\",\"fux\",\"xaw\",\"pdfvt\",\"xf\",\"t\",\"wq\",\"r\",\"cgmud\",\"aokas\",\"xv\",\"jf\",\"cyys\",\"wcaz\",\"rvegf\",\"ysg\",\"xo\",\"uwb\",\"lw\",\"okgk\",\"vbmi\",\"v\",\"mvo\",\"fxyx\",\"ad\",\"e\"]\\n\\nmy ans coming 8 and ans is 9\\n\\nmy code is\\n\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<string, int> m;\\n        cout<<s.size()<<endl;\\n        for(int i = 0; i<dictionary.size(); i++)\\n        {\\n            m[dictionary[i]]++;\\n        }\\n        int n=s.size();\\n        vector<int> v(n, -1);\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string temp = \"\";\\n            temp+=s[i];\\n            // cout<<temp<<endl;\\n            if(m.find(temp)!=m.end())\\n            {\\n                v[i]=max(v[i], i);\\n            }\\n            for(int j=i+1;j<s.size();j++)\\n            {\\n                temp+=s[j];\\n                // cout<<temp<<endl;\\n                if(m.find(temp)!=m.end())\\n                {\\n                    v[i]=max(v[i], j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<v.size();i++) cout<<v[i]<<\" \";\\n        cout << endl;\\n        for(int i = 0; i<v.size(); i++)\\n        {\\n            if(v[i]!=-1)\\n            {\\n                for(int j = i; j<=v[i]; j++) if(s[j]!= \\'-1\\') s[j]=\\'1\\';\\n            }\\n        }\\n        cout<<s<<endl;\\n        int count = 0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]!=\\'1\\') count++;\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "breathermachine",
                        "content": "```\\nkevlplxo---zdhx---mraiak---\\nkevlplxozaizdhxoimmraiakbak\\n```"
                    },
                    {
                        "username": "therealgeraldsy",
                        "content": "I am also stuck here! got an answer of 8, but leetcode said its 9"
                    },
                    {
                        "username": "Manu_7122001",
                        "content": "please tell me"
                    },
                    {
                        "username": "lexuankyxd",
                        "content": "Java array list adding new numbers from no where?\\n\\nSo basically, i have a static list<integer> object called list in Node class. At the bottom of node class, it checks if current node has any children, if not then add the number of spaces left behind into the list. And whenever it adds something to the list a System.out.println is executed so I know if they are adding stuff to the list. My problem is when somehow numbers are being added out of nowhere. This happens for the 2nd test case. Can anyone tell me why this is happening or what might have something to do with it. Much appreciated.\\n\\n\\ncode that check print out the list\\n\\nfor(int i = 0; i < Node.list.size(); i ++){\\n            if(Node.list.get(i) < min) min = Node.list.get(i);\\n            System.out.println(Node.list.get(i));\\n        }\\n        return min;\\n\\n\\ncode that add stuff to the list \\n\\nif(nodes.size() == 0) {\\n            int f = 0;\\n            for(boolean c: a){\\n                if(c) f++;\\n            }\\n            for(boolean asd: a){\\n                System.out.print(asd?1 + \" \":0 + \" \");\\n            }\\n            System.out.println(\"| \" + (string.length() - f));\\n            list.add( (string.length() - f)); // this is the only place where stuff get added to the list.\\n        }"
                    },
                    {
                        "username": "basurahan",
                        "content": "I don\\'t know why I am failing this test case my actual is 8 but the testcase expected is 9. I dont see my mistake. Can someone tell me why its supposed to be 9?\\n\\nMine is 8 and here are they:\\nCharPoint(char=k, points=1)\\nCharPoint(char=e, points=2)\\nCharPoint(char=v, points=1)\\nCharPoint(char=l, points=1)\\nCharPoint(char=p, points=1)\\nCharPoint(char=l, points=1)\\nCharPoint(char=x, points=1)\\nCharPoint(char=o, points=1)\\nCharPoint(char=z, points=0)\\nCharPoint(char=a, points=0)\\nCharPoint(char=i, points=0)\\nCharPoint(char=z, points=1)\\nCharPoint(char=d, points=1)\\nCharPoint(char=h, points=1)\\nCharPoint(char=x, points=2)\\nCharPoint(char=o, points=1)\\nCharPoint(char=i, points=0)\\nCharPoint(char=m, points=0)\\nCharPoint(char=m, points=1)\\nCharPoint(char=r, points=2)\\nCharPoint(char=a, points=1)\\nCharPoint(char=i, points=1)\\nCharPoint(char=a, points=1)\\nCharPoint(char=k, points=1)\\nCharPoint(char=b, points=0)\\nCharPoint(char=a, points=0)\\nCharPoint(char=k, points=0)\\n\\n\\ns = \"kevlplxozaizdhxoimmraiakbak\"\\ndictionary = [\"yv\",\"bmab\",\"hv\",\"bnsll\",\"mra\",\"jjqf\",\"g\",\"aiyzi\",\"ip\",\"pfctr\",\"flr\",\"ybbcl\",\"biu\",\"ke\",\"lpl\",\"iak\",\"pirua\",\"ilhqd\",\"zdhx\",\"fux\",\"xaw\",\"pdfvt\",\"xf\",\"t\",\"wq\",\"r\",\"cgmud\",\"aokas\",\"xv\",\"jf\",\"cyys\",\"wcaz\",\"rvegf\",\"ysg\",\"xo\",\"uwb\",\"lw\",\"okgk\",\"vbmi\",\"v\",\"mvo\",\"fxyx\",\"ad\",\"e\"]"
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@sapercq](/sapercq) So which word/words can handle `zdh`?"
                    },
                    {
                        "username": "sapercq",
                        "content": "[@sapercq](/sapercq) so you can build \"XO\" and gain -1 letter"
                    },
                    {
                        "username": "sapercq",
                        "content": "[@breathermachine](/breathermachine) Why not kevlplxo---zdhxo--mraiak---?????\\nbcs we have xo in dictionary\\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "```\\nkevlplxo---zdhx---mraiak---\\nkevlplxozaizdhxoimmraiakbak\\n```\\n9 characters not mapped to any substring"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I have a doubt regarding this question, what if some part of the given string is \"_______yy___\" and in the dictionary i have a string \"y\" -> then i should remove only 1 y or both y's from the given string ?\n\nAny help is appreciated."
                    },
                    {
                        "username": "aakashsrh",
                        "content": "[@sergei99](/sergei99) Thank you, Sir."
                    },
                    {
                        "username": "sergei99",
                        "content": "A single 'y' in the string won't match 'yy' in the dictionary. It's just all or nothing match.\nThe other way around (dictionary's 'y' and string's 'yy') is fine. Both 'y's will be removed from the string."
                    },
                    {
                        "username": "ArtemBaykov",
                        "content": "HELP! I NEED SOMEBODY) where is a mistake?\\nOutput\\n8\\nExpected\\n9\\nwhich index  is not counted?\\n{8, 9, 10, 16, 17, 24, 25, 26}\\n\\n\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        d = {w:s.count(w) for w in dictionary if s.count(w)!=0}\\n        res = []\\n        for key in d:\\n            if d[key]!=0:\\n                print(\\'key:\\',key, d[key])\\n                in_start = 0\\n                count = s.index(key)\\n                for i in range(d[key]):\\n                    in_w = s[in_start:].index(key)\\n                    l = [x for x in range(in_w + in_start, in_start+in_w + len(key))]\\n                    print(l)\\n                    res += l\\n                    in_start = max(l)+1\\n\\n                \\n        print(sorted(res))\\n        y = [x for x in range(len(s))]\\n        print(y)\\n        print(set(y).difference(set(res)))\\n        return len(set(y).difference(set(res)))\\n\\n"
                    },
                    {
                        "username": "mstuebs",
                        "content": "\"zzyyxxwwvvuuttssrrqqppoonnmmllkkjjiihhggffeeddccbb\"\n[\"ffeed\", \"kkjji\", \"ppoon\", \"uutts\", \"zzyyx\", \"ccb\", \"dcc\", \"ddc\", \"eed\", \"fee\", \"ffe\", \"ggf\", \"hgg\", \"hhg\", \"iih\", \"jii\", \"jji\", \"kkj\", \"lkk\", \"llk\", \"mml\", \"nmm\", \"nnm\", \"oon\", \"poo\", \"ppo\", \"qqp\", \"rqq\", \"rrq\", \"ssr\", \"tss\", \"tts\", \"uut\", \"vuu\", \"vvu\", \"wwv\", \"xww\", \"xxw\", \"yyx\", \"zyy\", \"zzy\"]"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Guys I think I\\'ve reached a bottleneck. No matter how much I practice, I\\'m just not getting better ..."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "To pick or not to pick."
                    },
                    {
                        "username": "aditya13451",
                        "content": "What is wrong in this implementation it\\'s showing wrong answer on test case 1995 i.e.\\ns = \"metzeaencgpgvsckjrqafkxgyzbe\"\\ndictionary =\\n[\"zdzz\",\"lgrhy\",\"r\",\"ohk\",\"zkowk\",\"g\",\"zqpn\",\"anoni\",\"ka\",\"qafkx\",\"t\",\"jr\",\"xdye\",\"mppc\",\"bqqb\",\"encgp\",\"yf\",\"vl\",\"ctsxk\",\"gn\",\"cujh\",\"ce\",\"rwrpq\",\"tze\",\"zxhg\",\"yzbe\",\"c\",\"o\",\"hnk\",\"gv\",\"uzbc\",\"xn\",\"kk\",\"ujjd\",\"vv\",\"mxhmv\",\"ugn\",\"at\",\"kumr\",\"ensv\",\"x\",\"uy\",\"gb\",\"ae\",\"jljuo\",\"xqkgj\"]\\n\\nclass Solution {\\npublic:\\n\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        int n = s.size();\\n        int x;\\n        int found = 0;\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            found = 0;\\n            for(int j=i; j<n; j++){\\n                if(find(dictionary.begin(), dictionary.end(), s.substr(i,j-i+1)) != dictionary.end()){\\n                    found = 1;\\n                    x = j;\\n                }\\n            }\\n            if(found == 1){\\n                i = x;\\n            }\\n            else{\\n                ans++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "aditya13451",
                        "content": "[@user3954sk](/user3954sk) Ohhhkkayy right, thanks bro"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Consider these two test cases.  Your program will fail for both of them.\\n\"abc\", [\"a\",\"ab\",\"bc\"]\\n\"abcd\",[\"ab\",\"bcd\"]"
                    }
                ]
            },
            {
                "id": 1907820,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "kinda tough seeing the dp recurrence relation "
                    },
                    {
                        "username": "miglani_9121",
                        "content": "why my answer is coming wrong at this testcase while i am solving the question brutly\\ns=\"kevlplxozaizdhxoimmraiakbak\"\\ndict =[\"yv\",\"bmab\",\"hv\",\"bnsll\",\"mra\",\"jjqf\",\"g\",\"aiyzi\",\"ip\",\"pfctr\",\"flr\",\"ybbcl\",\"biu\",\"ke\",\"lpl\",\"iak\",\"pirua\",\"ilhqd\",\"zdhx\",\"fux\",\"xaw\",\"pdfvt\",\"xf\",\"t\",\"wq\",\"r\",\"cgmud\",\"aokas\",\"xv\",\"jf\",\"cyys\",\"wcaz\",\"rvegf\",\"ysg\",\"xo\",\"uwb\",\"lw\",\"okgk\",\"vbmi\",\"v\",\"mvo\",\"fxyx\",\"ad\",\"e\"]\\n\\nmy ans coming 8 and ans is 9\\n\\nmy code is\\n\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<string, int> m;\\n        cout<<s.size()<<endl;\\n        for(int i = 0; i<dictionary.size(); i++)\\n        {\\n            m[dictionary[i]]++;\\n        }\\n        int n=s.size();\\n        vector<int> v(n, -1);\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string temp = \"\";\\n            temp+=s[i];\\n            // cout<<temp<<endl;\\n            if(m.find(temp)!=m.end())\\n            {\\n                v[i]=max(v[i], i);\\n            }\\n            for(int j=i+1;j<s.size();j++)\\n            {\\n                temp+=s[j];\\n                // cout<<temp<<endl;\\n                if(m.find(temp)!=m.end())\\n                {\\n                    v[i]=max(v[i], j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<v.size();i++) cout<<v[i]<<\" \";\\n        cout << endl;\\n        for(int i = 0; i<v.size(); i++)\\n        {\\n            if(v[i]!=-1)\\n            {\\n                for(int j = i; j<=v[i]; j++) if(s[j]!= \\'-1\\') s[j]=\\'1\\';\\n            }\\n        }\\n        cout<<s<<endl;\\n        int count = 0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]!=\\'1\\') count++;\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "breathermachine",
                        "content": "```\\nkevlplxo---zdhx---mraiak---\\nkevlplxozaizdhxoimmraiakbak\\n```"
                    },
                    {
                        "username": "therealgeraldsy",
                        "content": "I am also stuck here! got an answer of 8, but leetcode said its 9"
                    },
                    {
                        "username": "Manu_7122001",
                        "content": "please tell me"
                    },
                    {
                        "username": "lexuankyxd",
                        "content": "Java array list adding new numbers from no where?\\n\\nSo basically, i have a static list<integer> object called list in Node class. At the bottom of node class, it checks if current node has any children, if not then add the number of spaces left behind into the list. And whenever it adds something to the list a System.out.println is executed so I know if they are adding stuff to the list. My problem is when somehow numbers are being added out of nowhere. This happens for the 2nd test case. Can anyone tell me why this is happening or what might have something to do with it. Much appreciated.\\n\\n\\ncode that check print out the list\\n\\nfor(int i = 0; i < Node.list.size(); i ++){\\n            if(Node.list.get(i) < min) min = Node.list.get(i);\\n            System.out.println(Node.list.get(i));\\n        }\\n        return min;\\n\\n\\ncode that add stuff to the list \\n\\nif(nodes.size() == 0) {\\n            int f = 0;\\n            for(boolean c: a){\\n                if(c) f++;\\n            }\\n            for(boolean asd: a){\\n                System.out.print(asd?1 + \" \":0 + \" \");\\n            }\\n            System.out.println(\"| \" + (string.length() - f));\\n            list.add( (string.length() - f)); // this is the only place where stuff get added to the list.\\n        }"
                    },
                    {
                        "username": "basurahan",
                        "content": "I don\\'t know why I am failing this test case my actual is 8 but the testcase expected is 9. I dont see my mistake. Can someone tell me why its supposed to be 9?\\n\\nMine is 8 and here are they:\\nCharPoint(char=k, points=1)\\nCharPoint(char=e, points=2)\\nCharPoint(char=v, points=1)\\nCharPoint(char=l, points=1)\\nCharPoint(char=p, points=1)\\nCharPoint(char=l, points=1)\\nCharPoint(char=x, points=1)\\nCharPoint(char=o, points=1)\\nCharPoint(char=z, points=0)\\nCharPoint(char=a, points=0)\\nCharPoint(char=i, points=0)\\nCharPoint(char=z, points=1)\\nCharPoint(char=d, points=1)\\nCharPoint(char=h, points=1)\\nCharPoint(char=x, points=2)\\nCharPoint(char=o, points=1)\\nCharPoint(char=i, points=0)\\nCharPoint(char=m, points=0)\\nCharPoint(char=m, points=1)\\nCharPoint(char=r, points=2)\\nCharPoint(char=a, points=1)\\nCharPoint(char=i, points=1)\\nCharPoint(char=a, points=1)\\nCharPoint(char=k, points=1)\\nCharPoint(char=b, points=0)\\nCharPoint(char=a, points=0)\\nCharPoint(char=k, points=0)\\n\\n\\ns = \"kevlplxozaizdhxoimmraiakbak\"\\ndictionary = [\"yv\",\"bmab\",\"hv\",\"bnsll\",\"mra\",\"jjqf\",\"g\",\"aiyzi\",\"ip\",\"pfctr\",\"flr\",\"ybbcl\",\"biu\",\"ke\",\"lpl\",\"iak\",\"pirua\",\"ilhqd\",\"zdhx\",\"fux\",\"xaw\",\"pdfvt\",\"xf\",\"t\",\"wq\",\"r\",\"cgmud\",\"aokas\",\"xv\",\"jf\",\"cyys\",\"wcaz\",\"rvegf\",\"ysg\",\"xo\",\"uwb\",\"lw\",\"okgk\",\"vbmi\",\"v\",\"mvo\",\"fxyx\",\"ad\",\"e\"]"
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@sapercq](/sapercq) So which word/words can handle `zdh`?"
                    },
                    {
                        "username": "sapercq",
                        "content": "[@sapercq](/sapercq) so you can build \"XO\" and gain -1 letter"
                    },
                    {
                        "username": "sapercq",
                        "content": "[@breathermachine](/breathermachine) Why not kevlplxo---zdhxo--mraiak---?????\\nbcs we have xo in dictionary\\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "```\\nkevlplxo---zdhx---mraiak---\\nkevlplxozaizdhxoimmraiakbak\\n```\\n9 characters not mapped to any substring"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I have a doubt regarding this question, what if some part of the given string is \"_______yy___\" and in the dictionary i have a string \"y\" -> then i should remove only 1 y or both y's from the given string ?\n\nAny help is appreciated."
                    },
                    {
                        "username": "aakashsrh",
                        "content": "[@sergei99](/sergei99) Thank you, Sir."
                    },
                    {
                        "username": "sergei99",
                        "content": "A single 'y' in the string won't match 'yy' in the dictionary. It's just all or nothing match.\nThe other way around (dictionary's 'y' and string's 'yy') is fine. Both 'y's will be removed from the string."
                    },
                    {
                        "username": "ArtemBaykov",
                        "content": "HELP! I NEED SOMEBODY) where is a mistake?\\nOutput\\n8\\nExpected\\n9\\nwhich index  is not counted?\\n{8, 9, 10, 16, 17, 24, 25, 26}\\n\\n\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        d = {w:s.count(w) for w in dictionary if s.count(w)!=0}\\n        res = []\\n        for key in d:\\n            if d[key]!=0:\\n                print(\\'key:\\',key, d[key])\\n                in_start = 0\\n                count = s.index(key)\\n                for i in range(d[key]):\\n                    in_w = s[in_start:].index(key)\\n                    l = [x for x in range(in_w + in_start, in_start+in_w + len(key))]\\n                    print(l)\\n                    res += l\\n                    in_start = max(l)+1\\n\\n                \\n        print(sorted(res))\\n        y = [x for x in range(len(s))]\\n        print(y)\\n        print(set(y).difference(set(res)))\\n        return len(set(y).difference(set(res)))\\n\\n"
                    },
                    {
                        "username": "mstuebs",
                        "content": "\"zzyyxxwwvvuuttssrrqqppoonnmmllkkjjiihhggffeeddccbb\"\n[\"ffeed\", \"kkjji\", \"ppoon\", \"uutts\", \"zzyyx\", \"ccb\", \"dcc\", \"ddc\", \"eed\", \"fee\", \"ffe\", \"ggf\", \"hgg\", \"hhg\", \"iih\", \"jii\", \"jji\", \"kkj\", \"lkk\", \"llk\", \"mml\", \"nmm\", \"nnm\", \"oon\", \"poo\", \"ppo\", \"qqp\", \"rqq\", \"rrq\", \"ssr\", \"tss\", \"tts\", \"uut\", \"vuu\", \"vvu\", \"wwv\", \"xww\", \"xxw\", \"yyx\", \"zyy\", \"zzy\"]"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Guys I think I\\'ve reached a bottleneck. No matter how much I practice, I\\'m just not getting better ..."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "To pick or not to pick."
                    },
                    {
                        "username": "aditya13451",
                        "content": "What is wrong in this implementation it\\'s showing wrong answer on test case 1995 i.e.\\ns = \"metzeaencgpgvsckjrqafkxgyzbe\"\\ndictionary =\\n[\"zdzz\",\"lgrhy\",\"r\",\"ohk\",\"zkowk\",\"g\",\"zqpn\",\"anoni\",\"ka\",\"qafkx\",\"t\",\"jr\",\"xdye\",\"mppc\",\"bqqb\",\"encgp\",\"yf\",\"vl\",\"ctsxk\",\"gn\",\"cujh\",\"ce\",\"rwrpq\",\"tze\",\"zxhg\",\"yzbe\",\"c\",\"o\",\"hnk\",\"gv\",\"uzbc\",\"xn\",\"kk\",\"ujjd\",\"vv\",\"mxhmv\",\"ugn\",\"at\",\"kumr\",\"ensv\",\"x\",\"uy\",\"gb\",\"ae\",\"jljuo\",\"xqkgj\"]\\n\\nclass Solution {\\npublic:\\n\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        int n = s.size();\\n        int x;\\n        int found = 0;\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            found = 0;\\n            for(int j=i; j<n; j++){\\n                if(find(dictionary.begin(), dictionary.end(), s.substr(i,j-i+1)) != dictionary.end()){\\n                    found = 1;\\n                    x = j;\\n                }\\n            }\\n            if(found == 1){\\n                i = x;\\n            }\\n            else{\\n                ans++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "aditya13451",
                        "content": "[@user3954sk](/user3954sk) Ohhhkkayy right, thanks bro"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Consider these two test cases.  Your program will fail for both of them.\\n\"abc\", [\"a\",\"ab\",\"bc\"]\\n\"abcd\",[\"ab\",\"bcd\"]"
                    }
                ]
            },
            {
                "id": 2049577,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "kinda tough seeing the dp recurrence relation "
                    },
                    {
                        "username": "miglani_9121",
                        "content": "why my answer is coming wrong at this testcase while i am solving the question brutly\\ns=\"kevlplxozaizdhxoimmraiakbak\"\\ndict =[\"yv\",\"bmab\",\"hv\",\"bnsll\",\"mra\",\"jjqf\",\"g\",\"aiyzi\",\"ip\",\"pfctr\",\"flr\",\"ybbcl\",\"biu\",\"ke\",\"lpl\",\"iak\",\"pirua\",\"ilhqd\",\"zdhx\",\"fux\",\"xaw\",\"pdfvt\",\"xf\",\"t\",\"wq\",\"r\",\"cgmud\",\"aokas\",\"xv\",\"jf\",\"cyys\",\"wcaz\",\"rvegf\",\"ysg\",\"xo\",\"uwb\",\"lw\",\"okgk\",\"vbmi\",\"v\",\"mvo\",\"fxyx\",\"ad\",\"e\"]\\n\\nmy ans coming 8 and ans is 9\\n\\nmy code is\\n\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<string, int> m;\\n        cout<<s.size()<<endl;\\n        for(int i = 0; i<dictionary.size(); i++)\\n        {\\n            m[dictionary[i]]++;\\n        }\\n        int n=s.size();\\n        vector<int> v(n, -1);\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string temp = \"\";\\n            temp+=s[i];\\n            // cout<<temp<<endl;\\n            if(m.find(temp)!=m.end())\\n            {\\n                v[i]=max(v[i], i);\\n            }\\n            for(int j=i+1;j<s.size();j++)\\n            {\\n                temp+=s[j];\\n                // cout<<temp<<endl;\\n                if(m.find(temp)!=m.end())\\n                {\\n                    v[i]=max(v[i], j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<v.size();i++) cout<<v[i]<<\" \";\\n        cout << endl;\\n        for(int i = 0; i<v.size(); i++)\\n        {\\n            if(v[i]!=-1)\\n            {\\n                for(int j = i; j<=v[i]; j++) if(s[j]!= \\'-1\\') s[j]=\\'1\\';\\n            }\\n        }\\n        cout<<s<<endl;\\n        int count = 0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]!=\\'1\\') count++;\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "breathermachine",
                        "content": "```\\nkevlplxo---zdhx---mraiak---\\nkevlplxozaizdhxoimmraiakbak\\n```"
                    },
                    {
                        "username": "therealgeraldsy",
                        "content": "I am also stuck here! got an answer of 8, but leetcode said its 9"
                    },
                    {
                        "username": "Manu_7122001",
                        "content": "please tell me"
                    },
                    {
                        "username": "lexuankyxd",
                        "content": "Java array list adding new numbers from no where?\\n\\nSo basically, i have a static list<integer> object called list in Node class. At the bottom of node class, it checks if current node has any children, if not then add the number of spaces left behind into the list. And whenever it adds something to the list a System.out.println is executed so I know if they are adding stuff to the list. My problem is when somehow numbers are being added out of nowhere. This happens for the 2nd test case. Can anyone tell me why this is happening or what might have something to do with it. Much appreciated.\\n\\n\\ncode that check print out the list\\n\\nfor(int i = 0; i < Node.list.size(); i ++){\\n            if(Node.list.get(i) < min) min = Node.list.get(i);\\n            System.out.println(Node.list.get(i));\\n        }\\n        return min;\\n\\n\\ncode that add stuff to the list \\n\\nif(nodes.size() == 0) {\\n            int f = 0;\\n            for(boolean c: a){\\n                if(c) f++;\\n            }\\n            for(boolean asd: a){\\n                System.out.print(asd?1 + \" \":0 + \" \");\\n            }\\n            System.out.println(\"| \" + (string.length() - f));\\n            list.add( (string.length() - f)); // this is the only place where stuff get added to the list.\\n        }"
                    },
                    {
                        "username": "basurahan",
                        "content": "I don\\'t know why I am failing this test case my actual is 8 but the testcase expected is 9. I dont see my mistake. Can someone tell me why its supposed to be 9?\\n\\nMine is 8 and here are they:\\nCharPoint(char=k, points=1)\\nCharPoint(char=e, points=2)\\nCharPoint(char=v, points=1)\\nCharPoint(char=l, points=1)\\nCharPoint(char=p, points=1)\\nCharPoint(char=l, points=1)\\nCharPoint(char=x, points=1)\\nCharPoint(char=o, points=1)\\nCharPoint(char=z, points=0)\\nCharPoint(char=a, points=0)\\nCharPoint(char=i, points=0)\\nCharPoint(char=z, points=1)\\nCharPoint(char=d, points=1)\\nCharPoint(char=h, points=1)\\nCharPoint(char=x, points=2)\\nCharPoint(char=o, points=1)\\nCharPoint(char=i, points=0)\\nCharPoint(char=m, points=0)\\nCharPoint(char=m, points=1)\\nCharPoint(char=r, points=2)\\nCharPoint(char=a, points=1)\\nCharPoint(char=i, points=1)\\nCharPoint(char=a, points=1)\\nCharPoint(char=k, points=1)\\nCharPoint(char=b, points=0)\\nCharPoint(char=a, points=0)\\nCharPoint(char=k, points=0)\\n\\n\\ns = \"kevlplxozaizdhxoimmraiakbak\"\\ndictionary = [\"yv\",\"bmab\",\"hv\",\"bnsll\",\"mra\",\"jjqf\",\"g\",\"aiyzi\",\"ip\",\"pfctr\",\"flr\",\"ybbcl\",\"biu\",\"ke\",\"lpl\",\"iak\",\"pirua\",\"ilhqd\",\"zdhx\",\"fux\",\"xaw\",\"pdfvt\",\"xf\",\"t\",\"wq\",\"r\",\"cgmud\",\"aokas\",\"xv\",\"jf\",\"cyys\",\"wcaz\",\"rvegf\",\"ysg\",\"xo\",\"uwb\",\"lw\",\"okgk\",\"vbmi\",\"v\",\"mvo\",\"fxyx\",\"ad\",\"e\"]"
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@sapercq](/sapercq) So which word/words can handle `zdh`?"
                    },
                    {
                        "username": "sapercq",
                        "content": "[@sapercq](/sapercq) so you can build \"XO\" and gain -1 letter"
                    },
                    {
                        "username": "sapercq",
                        "content": "[@breathermachine](/breathermachine) Why not kevlplxo---zdhxo--mraiak---?????\\nbcs we have xo in dictionary\\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "```\\nkevlplxo---zdhx---mraiak---\\nkevlplxozaizdhxoimmraiakbak\\n```\\n9 characters not mapped to any substring"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I have a doubt regarding this question, what if some part of the given string is \"_______yy___\" and in the dictionary i have a string \"y\" -> then i should remove only 1 y or both y's from the given string ?\n\nAny help is appreciated."
                    },
                    {
                        "username": "aakashsrh",
                        "content": "[@sergei99](/sergei99) Thank you, Sir."
                    },
                    {
                        "username": "sergei99",
                        "content": "A single 'y' in the string won't match 'yy' in the dictionary. It's just all or nothing match.\nThe other way around (dictionary's 'y' and string's 'yy') is fine. Both 'y's will be removed from the string."
                    },
                    {
                        "username": "ArtemBaykov",
                        "content": "HELP! I NEED SOMEBODY) where is a mistake?\\nOutput\\n8\\nExpected\\n9\\nwhich index  is not counted?\\n{8, 9, 10, 16, 17, 24, 25, 26}\\n\\n\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        d = {w:s.count(w) for w in dictionary if s.count(w)!=0}\\n        res = []\\n        for key in d:\\n            if d[key]!=0:\\n                print(\\'key:\\',key, d[key])\\n                in_start = 0\\n                count = s.index(key)\\n                for i in range(d[key]):\\n                    in_w = s[in_start:].index(key)\\n                    l = [x for x in range(in_w + in_start, in_start+in_w + len(key))]\\n                    print(l)\\n                    res += l\\n                    in_start = max(l)+1\\n\\n                \\n        print(sorted(res))\\n        y = [x for x in range(len(s))]\\n        print(y)\\n        print(set(y).difference(set(res)))\\n        return len(set(y).difference(set(res)))\\n\\n"
                    },
                    {
                        "username": "mstuebs",
                        "content": "\"zzyyxxwwvvuuttssrrqqppoonnmmllkkjjiihhggffeeddccbb\"\n[\"ffeed\", \"kkjji\", \"ppoon\", \"uutts\", \"zzyyx\", \"ccb\", \"dcc\", \"ddc\", \"eed\", \"fee\", \"ffe\", \"ggf\", \"hgg\", \"hhg\", \"iih\", \"jii\", \"jji\", \"kkj\", \"lkk\", \"llk\", \"mml\", \"nmm\", \"nnm\", \"oon\", \"poo\", \"ppo\", \"qqp\", \"rqq\", \"rrq\", \"ssr\", \"tss\", \"tts\", \"uut\", \"vuu\", \"vvu\", \"wwv\", \"xww\", \"xxw\", \"yyx\", \"zyy\", \"zzy\"]"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Guys I think I\\'ve reached a bottleneck. No matter how much I practice, I\\'m just not getting better ..."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "To pick or not to pick."
                    },
                    {
                        "username": "aditya13451",
                        "content": "What is wrong in this implementation it\\'s showing wrong answer on test case 1995 i.e.\\ns = \"metzeaencgpgvsckjrqafkxgyzbe\"\\ndictionary =\\n[\"zdzz\",\"lgrhy\",\"r\",\"ohk\",\"zkowk\",\"g\",\"zqpn\",\"anoni\",\"ka\",\"qafkx\",\"t\",\"jr\",\"xdye\",\"mppc\",\"bqqb\",\"encgp\",\"yf\",\"vl\",\"ctsxk\",\"gn\",\"cujh\",\"ce\",\"rwrpq\",\"tze\",\"zxhg\",\"yzbe\",\"c\",\"o\",\"hnk\",\"gv\",\"uzbc\",\"xn\",\"kk\",\"ujjd\",\"vv\",\"mxhmv\",\"ugn\",\"at\",\"kumr\",\"ensv\",\"x\",\"uy\",\"gb\",\"ae\",\"jljuo\",\"xqkgj\"]\\n\\nclass Solution {\\npublic:\\n\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        int n = s.size();\\n        int x;\\n        int found = 0;\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            found = 0;\\n            for(int j=i; j<n; j++){\\n                if(find(dictionary.begin(), dictionary.end(), s.substr(i,j-i+1)) != dictionary.end()){\\n                    found = 1;\\n                    x = j;\\n                }\\n            }\\n            if(found == 1){\\n                i = x;\\n            }\\n            else{\\n                ans++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "aditya13451",
                        "content": "[@user3954sk](/user3954sk) Ohhhkkayy right, thanks bro"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Consider these two test cases.  Your program will fail for both of them.\\n\"abc\", [\"a\",\"ab\",\"bc\"]\\n\"abcd\",[\"ab\",\"bcd\"]"
                    }
                ]
            },
            {
                "id": 2042587,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "kinda tough seeing the dp recurrence relation "
                    },
                    {
                        "username": "miglani_9121",
                        "content": "why my answer is coming wrong at this testcase while i am solving the question brutly\\ns=\"kevlplxozaizdhxoimmraiakbak\"\\ndict =[\"yv\",\"bmab\",\"hv\",\"bnsll\",\"mra\",\"jjqf\",\"g\",\"aiyzi\",\"ip\",\"pfctr\",\"flr\",\"ybbcl\",\"biu\",\"ke\",\"lpl\",\"iak\",\"pirua\",\"ilhqd\",\"zdhx\",\"fux\",\"xaw\",\"pdfvt\",\"xf\",\"t\",\"wq\",\"r\",\"cgmud\",\"aokas\",\"xv\",\"jf\",\"cyys\",\"wcaz\",\"rvegf\",\"ysg\",\"xo\",\"uwb\",\"lw\",\"okgk\",\"vbmi\",\"v\",\"mvo\",\"fxyx\",\"ad\",\"e\"]\\n\\nmy ans coming 8 and ans is 9\\n\\nmy code is\\n\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<string, int> m;\\n        cout<<s.size()<<endl;\\n        for(int i = 0; i<dictionary.size(); i++)\\n        {\\n            m[dictionary[i]]++;\\n        }\\n        int n=s.size();\\n        vector<int> v(n, -1);\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string temp = \"\";\\n            temp+=s[i];\\n            // cout<<temp<<endl;\\n            if(m.find(temp)!=m.end())\\n            {\\n                v[i]=max(v[i], i);\\n            }\\n            for(int j=i+1;j<s.size();j++)\\n            {\\n                temp+=s[j];\\n                // cout<<temp<<endl;\\n                if(m.find(temp)!=m.end())\\n                {\\n                    v[i]=max(v[i], j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<v.size();i++) cout<<v[i]<<\" \";\\n        cout << endl;\\n        for(int i = 0; i<v.size(); i++)\\n        {\\n            if(v[i]!=-1)\\n            {\\n                for(int j = i; j<=v[i]; j++) if(s[j]!= \\'-1\\') s[j]=\\'1\\';\\n            }\\n        }\\n        cout<<s<<endl;\\n        int count = 0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]!=\\'1\\') count++;\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "breathermachine",
                        "content": "```\\nkevlplxo---zdhx---mraiak---\\nkevlplxozaizdhxoimmraiakbak\\n```"
                    },
                    {
                        "username": "therealgeraldsy",
                        "content": "I am also stuck here! got an answer of 8, but leetcode said its 9"
                    },
                    {
                        "username": "Manu_7122001",
                        "content": "please tell me"
                    },
                    {
                        "username": "lexuankyxd",
                        "content": "Java array list adding new numbers from no where?\\n\\nSo basically, i have a static list<integer> object called list in Node class. At the bottom of node class, it checks if current node has any children, if not then add the number of spaces left behind into the list. And whenever it adds something to the list a System.out.println is executed so I know if they are adding stuff to the list. My problem is when somehow numbers are being added out of nowhere. This happens for the 2nd test case. Can anyone tell me why this is happening or what might have something to do with it. Much appreciated.\\n\\n\\ncode that check print out the list\\n\\nfor(int i = 0; i < Node.list.size(); i ++){\\n            if(Node.list.get(i) < min) min = Node.list.get(i);\\n            System.out.println(Node.list.get(i));\\n        }\\n        return min;\\n\\n\\ncode that add stuff to the list \\n\\nif(nodes.size() == 0) {\\n            int f = 0;\\n            for(boolean c: a){\\n                if(c) f++;\\n            }\\n            for(boolean asd: a){\\n                System.out.print(asd?1 + \" \":0 + \" \");\\n            }\\n            System.out.println(\"| \" + (string.length() - f));\\n            list.add( (string.length() - f)); // this is the only place where stuff get added to the list.\\n        }"
                    },
                    {
                        "username": "basurahan",
                        "content": "I don\\'t know why I am failing this test case my actual is 8 but the testcase expected is 9. I dont see my mistake. Can someone tell me why its supposed to be 9?\\n\\nMine is 8 and here are they:\\nCharPoint(char=k, points=1)\\nCharPoint(char=e, points=2)\\nCharPoint(char=v, points=1)\\nCharPoint(char=l, points=1)\\nCharPoint(char=p, points=1)\\nCharPoint(char=l, points=1)\\nCharPoint(char=x, points=1)\\nCharPoint(char=o, points=1)\\nCharPoint(char=z, points=0)\\nCharPoint(char=a, points=0)\\nCharPoint(char=i, points=0)\\nCharPoint(char=z, points=1)\\nCharPoint(char=d, points=1)\\nCharPoint(char=h, points=1)\\nCharPoint(char=x, points=2)\\nCharPoint(char=o, points=1)\\nCharPoint(char=i, points=0)\\nCharPoint(char=m, points=0)\\nCharPoint(char=m, points=1)\\nCharPoint(char=r, points=2)\\nCharPoint(char=a, points=1)\\nCharPoint(char=i, points=1)\\nCharPoint(char=a, points=1)\\nCharPoint(char=k, points=1)\\nCharPoint(char=b, points=0)\\nCharPoint(char=a, points=0)\\nCharPoint(char=k, points=0)\\n\\n\\ns = \"kevlplxozaizdhxoimmraiakbak\"\\ndictionary = [\"yv\",\"bmab\",\"hv\",\"bnsll\",\"mra\",\"jjqf\",\"g\",\"aiyzi\",\"ip\",\"pfctr\",\"flr\",\"ybbcl\",\"biu\",\"ke\",\"lpl\",\"iak\",\"pirua\",\"ilhqd\",\"zdhx\",\"fux\",\"xaw\",\"pdfvt\",\"xf\",\"t\",\"wq\",\"r\",\"cgmud\",\"aokas\",\"xv\",\"jf\",\"cyys\",\"wcaz\",\"rvegf\",\"ysg\",\"xo\",\"uwb\",\"lw\",\"okgk\",\"vbmi\",\"v\",\"mvo\",\"fxyx\",\"ad\",\"e\"]"
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@sapercq](/sapercq) So which word/words can handle `zdh`?"
                    },
                    {
                        "username": "sapercq",
                        "content": "[@sapercq](/sapercq) so you can build \"XO\" and gain -1 letter"
                    },
                    {
                        "username": "sapercq",
                        "content": "[@breathermachine](/breathermachine) Why not kevlplxo---zdhxo--mraiak---?????\\nbcs we have xo in dictionary\\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "```\\nkevlplxo---zdhx---mraiak---\\nkevlplxozaizdhxoimmraiakbak\\n```\\n9 characters not mapped to any substring"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I have a doubt regarding this question, what if some part of the given string is \"_______yy___\" and in the dictionary i have a string \"y\" -> then i should remove only 1 y or both y's from the given string ?\n\nAny help is appreciated."
                    },
                    {
                        "username": "aakashsrh",
                        "content": "[@sergei99](/sergei99) Thank you, Sir."
                    },
                    {
                        "username": "sergei99",
                        "content": "A single 'y' in the string won't match 'yy' in the dictionary. It's just all or nothing match.\nThe other way around (dictionary's 'y' and string's 'yy') is fine. Both 'y's will be removed from the string."
                    },
                    {
                        "username": "ArtemBaykov",
                        "content": "HELP! I NEED SOMEBODY) where is a mistake?\\nOutput\\n8\\nExpected\\n9\\nwhich index  is not counted?\\n{8, 9, 10, 16, 17, 24, 25, 26}\\n\\n\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        d = {w:s.count(w) for w in dictionary if s.count(w)!=0}\\n        res = []\\n        for key in d:\\n            if d[key]!=0:\\n                print(\\'key:\\',key, d[key])\\n                in_start = 0\\n                count = s.index(key)\\n                for i in range(d[key]):\\n                    in_w = s[in_start:].index(key)\\n                    l = [x for x in range(in_w + in_start, in_start+in_w + len(key))]\\n                    print(l)\\n                    res += l\\n                    in_start = max(l)+1\\n\\n                \\n        print(sorted(res))\\n        y = [x for x in range(len(s))]\\n        print(y)\\n        print(set(y).difference(set(res)))\\n        return len(set(y).difference(set(res)))\\n\\n"
                    },
                    {
                        "username": "mstuebs",
                        "content": "\"zzyyxxwwvvuuttssrrqqppoonnmmllkkjjiihhggffeeddccbb\"\n[\"ffeed\", \"kkjji\", \"ppoon\", \"uutts\", \"zzyyx\", \"ccb\", \"dcc\", \"ddc\", \"eed\", \"fee\", \"ffe\", \"ggf\", \"hgg\", \"hhg\", \"iih\", \"jii\", \"jji\", \"kkj\", \"lkk\", \"llk\", \"mml\", \"nmm\", \"nnm\", \"oon\", \"poo\", \"ppo\", \"qqp\", \"rqq\", \"rrq\", \"ssr\", \"tss\", \"tts\", \"uut\", \"vuu\", \"vvu\", \"wwv\", \"xww\", \"xxw\", \"yyx\", \"zyy\", \"zzy\"]"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Guys I think I\\'ve reached a bottleneck. No matter how much I practice, I\\'m just not getting better ..."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "To pick or not to pick."
                    },
                    {
                        "username": "aditya13451",
                        "content": "What is wrong in this implementation it\\'s showing wrong answer on test case 1995 i.e.\\ns = \"metzeaencgpgvsckjrqafkxgyzbe\"\\ndictionary =\\n[\"zdzz\",\"lgrhy\",\"r\",\"ohk\",\"zkowk\",\"g\",\"zqpn\",\"anoni\",\"ka\",\"qafkx\",\"t\",\"jr\",\"xdye\",\"mppc\",\"bqqb\",\"encgp\",\"yf\",\"vl\",\"ctsxk\",\"gn\",\"cujh\",\"ce\",\"rwrpq\",\"tze\",\"zxhg\",\"yzbe\",\"c\",\"o\",\"hnk\",\"gv\",\"uzbc\",\"xn\",\"kk\",\"ujjd\",\"vv\",\"mxhmv\",\"ugn\",\"at\",\"kumr\",\"ensv\",\"x\",\"uy\",\"gb\",\"ae\",\"jljuo\",\"xqkgj\"]\\n\\nclass Solution {\\npublic:\\n\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        int n = s.size();\\n        int x;\\n        int found = 0;\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            found = 0;\\n            for(int j=i; j<n; j++){\\n                if(find(dictionary.begin(), dictionary.end(), s.substr(i,j-i+1)) != dictionary.end()){\\n                    found = 1;\\n                    x = j;\\n                }\\n            }\\n            if(found == 1){\\n                i = x;\\n            }\\n            else{\\n                ans++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "aditya13451",
                        "content": "[@user3954sk](/user3954sk) Ohhhkkayy right, thanks bro"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Consider these two test cases.  Your program will fail for both of them.\\n\"abc\", [\"a\",\"ab\",\"bc\"]\\n\"abcd\",[\"ab\",\"bcd\"]"
                    }
                ]
            },
            {
                "id": 2041518,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "kinda tough seeing the dp recurrence relation "
                    },
                    {
                        "username": "miglani_9121",
                        "content": "why my answer is coming wrong at this testcase while i am solving the question brutly\\ns=\"kevlplxozaizdhxoimmraiakbak\"\\ndict =[\"yv\",\"bmab\",\"hv\",\"bnsll\",\"mra\",\"jjqf\",\"g\",\"aiyzi\",\"ip\",\"pfctr\",\"flr\",\"ybbcl\",\"biu\",\"ke\",\"lpl\",\"iak\",\"pirua\",\"ilhqd\",\"zdhx\",\"fux\",\"xaw\",\"pdfvt\",\"xf\",\"t\",\"wq\",\"r\",\"cgmud\",\"aokas\",\"xv\",\"jf\",\"cyys\",\"wcaz\",\"rvegf\",\"ysg\",\"xo\",\"uwb\",\"lw\",\"okgk\",\"vbmi\",\"v\",\"mvo\",\"fxyx\",\"ad\",\"e\"]\\n\\nmy ans coming 8 and ans is 9\\n\\nmy code is\\n\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<string, int> m;\\n        cout<<s.size()<<endl;\\n        for(int i = 0; i<dictionary.size(); i++)\\n        {\\n            m[dictionary[i]]++;\\n        }\\n        int n=s.size();\\n        vector<int> v(n, -1);\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string temp = \"\";\\n            temp+=s[i];\\n            // cout<<temp<<endl;\\n            if(m.find(temp)!=m.end())\\n            {\\n                v[i]=max(v[i], i);\\n            }\\n            for(int j=i+1;j<s.size();j++)\\n            {\\n                temp+=s[j];\\n                // cout<<temp<<endl;\\n                if(m.find(temp)!=m.end())\\n                {\\n                    v[i]=max(v[i], j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<v.size();i++) cout<<v[i]<<\" \";\\n        cout << endl;\\n        for(int i = 0; i<v.size(); i++)\\n        {\\n            if(v[i]!=-1)\\n            {\\n                for(int j = i; j<=v[i]; j++) if(s[j]!= \\'-1\\') s[j]=\\'1\\';\\n            }\\n        }\\n        cout<<s<<endl;\\n        int count = 0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]!=\\'1\\') count++;\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "breathermachine",
                        "content": "```\\nkevlplxo---zdhx---mraiak---\\nkevlplxozaizdhxoimmraiakbak\\n```"
                    },
                    {
                        "username": "therealgeraldsy",
                        "content": "I am also stuck here! got an answer of 8, but leetcode said its 9"
                    },
                    {
                        "username": "Manu_7122001",
                        "content": "please tell me"
                    },
                    {
                        "username": "lexuankyxd",
                        "content": "Java array list adding new numbers from no where?\\n\\nSo basically, i have a static list<integer> object called list in Node class. At the bottom of node class, it checks if current node has any children, if not then add the number of spaces left behind into the list. And whenever it adds something to the list a System.out.println is executed so I know if they are adding stuff to the list. My problem is when somehow numbers are being added out of nowhere. This happens for the 2nd test case. Can anyone tell me why this is happening or what might have something to do with it. Much appreciated.\\n\\n\\ncode that check print out the list\\n\\nfor(int i = 0; i < Node.list.size(); i ++){\\n            if(Node.list.get(i) < min) min = Node.list.get(i);\\n            System.out.println(Node.list.get(i));\\n        }\\n        return min;\\n\\n\\ncode that add stuff to the list \\n\\nif(nodes.size() == 0) {\\n            int f = 0;\\n            for(boolean c: a){\\n                if(c) f++;\\n            }\\n            for(boolean asd: a){\\n                System.out.print(asd?1 + \" \":0 + \" \");\\n            }\\n            System.out.println(\"| \" + (string.length() - f));\\n            list.add( (string.length() - f)); // this is the only place where stuff get added to the list.\\n        }"
                    },
                    {
                        "username": "basurahan",
                        "content": "I don\\'t know why I am failing this test case my actual is 8 but the testcase expected is 9. I dont see my mistake. Can someone tell me why its supposed to be 9?\\n\\nMine is 8 and here are they:\\nCharPoint(char=k, points=1)\\nCharPoint(char=e, points=2)\\nCharPoint(char=v, points=1)\\nCharPoint(char=l, points=1)\\nCharPoint(char=p, points=1)\\nCharPoint(char=l, points=1)\\nCharPoint(char=x, points=1)\\nCharPoint(char=o, points=1)\\nCharPoint(char=z, points=0)\\nCharPoint(char=a, points=0)\\nCharPoint(char=i, points=0)\\nCharPoint(char=z, points=1)\\nCharPoint(char=d, points=1)\\nCharPoint(char=h, points=1)\\nCharPoint(char=x, points=2)\\nCharPoint(char=o, points=1)\\nCharPoint(char=i, points=0)\\nCharPoint(char=m, points=0)\\nCharPoint(char=m, points=1)\\nCharPoint(char=r, points=2)\\nCharPoint(char=a, points=1)\\nCharPoint(char=i, points=1)\\nCharPoint(char=a, points=1)\\nCharPoint(char=k, points=1)\\nCharPoint(char=b, points=0)\\nCharPoint(char=a, points=0)\\nCharPoint(char=k, points=0)\\n\\n\\ns = \"kevlplxozaizdhxoimmraiakbak\"\\ndictionary = [\"yv\",\"bmab\",\"hv\",\"bnsll\",\"mra\",\"jjqf\",\"g\",\"aiyzi\",\"ip\",\"pfctr\",\"flr\",\"ybbcl\",\"biu\",\"ke\",\"lpl\",\"iak\",\"pirua\",\"ilhqd\",\"zdhx\",\"fux\",\"xaw\",\"pdfvt\",\"xf\",\"t\",\"wq\",\"r\",\"cgmud\",\"aokas\",\"xv\",\"jf\",\"cyys\",\"wcaz\",\"rvegf\",\"ysg\",\"xo\",\"uwb\",\"lw\",\"okgk\",\"vbmi\",\"v\",\"mvo\",\"fxyx\",\"ad\",\"e\"]"
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@sapercq](/sapercq) So which word/words can handle `zdh`?"
                    },
                    {
                        "username": "sapercq",
                        "content": "[@sapercq](/sapercq) so you can build \"XO\" and gain -1 letter"
                    },
                    {
                        "username": "sapercq",
                        "content": "[@breathermachine](/breathermachine) Why not kevlplxo---zdhxo--mraiak---?????\\nbcs we have xo in dictionary\\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "```\\nkevlplxo---zdhx---mraiak---\\nkevlplxozaizdhxoimmraiakbak\\n```\\n9 characters not mapped to any substring"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I have a doubt regarding this question, what if some part of the given string is \"_______yy___\" and in the dictionary i have a string \"y\" -> then i should remove only 1 y or both y's from the given string ?\n\nAny help is appreciated."
                    },
                    {
                        "username": "aakashsrh",
                        "content": "[@sergei99](/sergei99) Thank you, Sir."
                    },
                    {
                        "username": "sergei99",
                        "content": "A single 'y' in the string won't match 'yy' in the dictionary. It's just all or nothing match.\nThe other way around (dictionary's 'y' and string's 'yy') is fine. Both 'y's will be removed from the string."
                    },
                    {
                        "username": "ArtemBaykov",
                        "content": "HELP! I NEED SOMEBODY) where is a mistake?\\nOutput\\n8\\nExpected\\n9\\nwhich index  is not counted?\\n{8, 9, 10, 16, 17, 24, 25, 26}\\n\\n\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        d = {w:s.count(w) for w in dictionary if s.count(w)!=0}\\n        res = []\\n        for key in d:\\n            if d[key]!=0:\\n                print(\\'key:\\',key, d[key])\\n                in_start = 0\\n                count = s.index(key)\\n                for i in range(d[key]):\\n                    in_w = s[in_start:].index(key)\\n                    l = [x for x in range(in_w + in_start, in_start+in_w + len(key))]\\n                    print(l)\\n                    res += l\\n                    in_start = max(l)+1\\n\\n                \\n        print(sorted(res))\\n        y = [x for x in range(len(s))]\\n        print(y)\\n        print(set(y).difference(set(res)))\\n        return len(set(y).difference(set(res)))\\n\\n"
                    },
                    {
                        "username": "mstuebs",
                        "content": "\"zzyyxxwwvvuuttssrrqqppoonnmmllkkjjiihhggffeeddccbb\"\n[\"ffeed\", \"kkjji\", \"ppoon\", \"uutts\", \"zzyyx\", \"ccb\", \"dcc\", \"ddc\", \"eed\", \"fee\", \"ffe\", \"ggf\", \"hgg\", \"hhg\", \"iih\", \"jii\", \"jji\", \"kkj\", \"lkk\", \"llk\", \"mml\", \"nmm\", \"nnm\", \"oon\", \"poo\", \"ppo\", \"qqp\", \"rqq\", \"rrq\", \"ssr\", \"tss\", \"tts\", \"uut\", \"vuu\", \"vvu\", \"wwv\", \"xww\", \"xxw\", \"yyx\", \"zyy\", \"zzy\"]"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Guys I think I\\'ve reached a bottleneck. No matter how much I practice, I\\'m just not getting better ..."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "To pick or not to pick."
                    },
                    {
                        "username": "aditya13451",
                        "content": "What is wrong in this implementation it\\'s showing wrong answer on test case 1995 i.e.\\ns = \"metzeaencgpgvsckjrqafkxgyzbe\"\\ndictionary =\\n[\"zdzz\",\"lgrhy\",\"r\",\"ohk\",\"zkowk\",\"g\",\"zqpn\",\"anoni\",\"ka\",\"qafkx\",\"t\",\"jr\",\"xdye\",\"mppc\",\"bqqb\",\"encgp\",\"yf\",\"vl\",\"ctsxk\",\"gn\",\"cujh\",\"ce\",\"rwrpq\",\"tze\",\"zxhg\",\"yzbe\",\"c\",\"o\",\"hnk\",\"gv\",\"uzbc\",\"xn\",\"kk\",\"ujjd\",\"vv\",\"mxhmv\",\"ugn\",\"at\",\"kumr\",\"ensv\",\"x\",\"uy\",\"gb\",\"ae\",\"jljuo\",\"xqkgj\"]\\n\\nclass Solution {\\npublic:\\n\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        int n = s.size();\\n        int x;\\n        int found = 0;\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            found = 0;\\n            for(int j=i; j<n; j++){\\n                if(find(dictionary.begin(), dictionary.end(), s.substr(i,j-i+1)) != dictionary.end()){\\n                    found = 1;\\n                    x = j;\\n                }\\n            }\\n            if(found == 1){\\n                i = x;\\n            }\\n            else{\\n                ans++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "aditya13451",
                        "content": "[@user3954sk](/user3954sk) Ohhhkkayy right, thanks bro"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Consider these two test cases.  Your program will fail for both of them.\\n\"abc\", [\"a\",\"ab\",\"bc\"]\\n\"abcd\",[\"ab\",\"bcd\"]"
                    }
                ]
            },
            {
                "id": 2041514,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "kinda tough seeing the dp recurrence relation "
                    },
                    {
                        "username": "miglani_9121",
                        "content": "why my answer is coming wrong at this testcase while i am solving the question brutly\\ns=\"kevlplxozaizdhxoimmraiakbak\"\\ndict =[\"yv\",\"bmab\",\"hv\",\"bnsll\",\"mra\",\"jjqf\",\"g\",\"aiyzi\",\"ip\",\"pfctr\",\"flr\",\"ybbcl\",\"biu\",\"ke\",\"lpl\",\"iak\",\"pirua\",\"ilhqd\",\"zdhx\",\"fux\",\"xaw\",\"pdfvt\",\"xf\",\"t\",\"wq\",\"r\",\"cgmud\",\"aokas\",\"xv\",\"jf\",\"cyys\",\"wcaz\",\"rvegf\",\"ysg\",\"xo\",\"uwb\",\"lw\",\"okgk\",\"vbmi\",\"v\",\"mvo\",\"fxyx\",\"ad\",\"e\"]\\n\\nmy ans coming 8 and ans is 9\\n\\nmy code is\\n\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<string, int> m;\\n        cout<<s.size()<<endl;\\n        for(int i = 0; i<dictionary.size(); i++)\\n        {\\n            m[dictionary[i]]++;\\n        }\\n        int n=s.size();\\n        vector<int> v(n, -1);\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string temp = \"\";\\n            temp+=s[i];\\n            // cout<<temp<<endl;\\n            if(m.find(temp)!=m.end())\\n            {\\n                v[i]=max(v[i], i);\\n            }\\n            for(int j=i+1;j<s.size();j++)\\n            {\\n                temp+=s[j];\\n                // cout<<temp<<endl;\\n                if(m.find(temp)!=m.end())\\n                {\\n                    v[i]=max(v[i], j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<v.size();i++) cout<<v[i]<<\" \";\\n        cout << endl;\\n        for(int i = 0; i<v.size(); i++)\\n        {\\n            if(v[i]!=-1)\\n            {\\n                for(int j = i; j<=v[i]; j++) if(s[j]!= \\'-1\\') s[j]=\\'1\\';\\n            }\\n        }\\n        cout<<s<<endl;\\n        int count = 0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]!=\\'1\\') count++;\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "breathermachine",
                        "content": "```\\nkevlplxo---zdhx---mraiak---\\nkevlplxozaizdhxoimmraiakbak\\n```"
                    },
                    {
                        "username": "therealgeraldsy",
                        "content": "I am also stuck here! got an answer of 8, but leetcode said its 9"
                    },
                    {
                        "username": "Manu_7122001",
                        "content": "please tell me"
                    },
                    {
                        "username": "lexuankyxd",
                        "content": "Java array list adding new numbers from no where?\\n\\nSo basically, i have a static list<integer> object called list in Node class. At the bottom of node class, it checks if current node has any children, if not then add the number of spaces left behind into the list. And whenever it adds something to the list a System.out.println is executed so I know if they are adding stuff to the list. My problem is when somehow numbers are being added out of nowhere. This happens for the 2nd test case. Can anyone tell me why this is happening or what might have something to do with it. Much appreciated.\\n\\n\\ncode that check print out the list\\n\\nfor(int i = 0; i < Node.list.size(); i ++){\\n            if(Node.list.get(i) < min) min = Node.list.get(i);\\n            System.out.println(Node.list.get(i));\\n        }\\n        return min;\\n\\n\\ncode that add stuff to the list \\n\\nif(nodes.size() == 0) {\\n            int f = 0;\\n            for(boolean c: a){\\n                if(c) f++;\\n            }\\n            for(boolean asd: a){\\n                System.out.print(asd?1 + \" \":0 + \" \");\\n            }\\n            System.out.println(\"| \" + (string.length() - f));\\n            list.add( (string.length() - f)); // this is the only place where stuff get added to the list.\\n        }"
                    },
                    {
                        "username": "basurahan",
                        "content": "I don\\'t know why I am failing this test case my actual is 8 but the testcase expected is 9. I dont see my mistake. Can someone tell me why its supposed to be 9?\\n\\nMine is 8 and here are they:\\nCharPoint(char=k, points=1)\\nCharPoint(char=e, points=2)\\nCharPoint(char=v, points=1)\\nCharPoint(char=l, points=1)\\nCharPoint(char=p, points=1)\\nCharPoint(char=l, points=1)\\nCharPoint(char=x, points=1)\\nCharPoint(char=o, points=1)\\nCharPoint(char=z, points=0)\\nCharPoint(char=a, points=0)\\nCharPoint(char=i, points=0)\\nCharPoint(char=z, points=1)\\nCharPoint(char=d, points=1)\\nCharPoint(char=h, points=1)\\nCharPoint(char=x, points=2)\\nCharPoint(char=o, points=1)\\nCharPoint(char=i, points=0)\\nCharPoint(char=m, points=0)\\nCharPoint(char=m, points=1)\\nCharPoint(char=r, points=2)\\nCharPoint(char=a, points=1)\\nCharPoint(char=i, points=1)\\nCharPoint(char=a, points=1)\\nCharPoint(char=k, points=1)\\nCharPoint(char=b, points=0)\\nCharPoint(char=a, points=0)\\nCharPoint(char=k, points=0)\\n\\n\\ns = \"kevlplxozaizdhxoimmraiakbak\"\\ndictionary = [\"yv\",\"bmab\",\"hv\",\"bnsll\",\"mra\",\"jjqf\",\"g\",\"aiyzi\",\"ip\",\"pfctr\",\"flr\",\"ybbcl\",\"biu\",\"ke\",\"lpl\",\"iak\",\"pirua\",\"ilhqd\",\"zdhx\",\"fux\",\"xaw\",\"pdfvt\",\"xf\",\"t\",\"wq\",\"r\",\"cgmud\",\"aokas\",\"xv\",\"jf\",\"cyys\",\"wcaz\",\"rvegf\",\"ysg\",\"xo\",\"uwb\",\"lw\",\"okgk\",\"vbmi\",\"v\",\"mvo\",\"fxyx\",\"ad\",\"e\"]"
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@sapercq](/sapercq) So which word/words can handle `zdh`?"
                    },
                    {
                        "username": "sapercq",
                        "content": "[@sapercq](/sapercq) so you can build \"XO\" and gain -1 letter"
                    },
                    {
                        "username": "sapercq",
                        "content": "[@breathermachine](/breathermachine) Why not kevlplxo---zdhxo--mraiak---?????\\nbcs we have xo in dictionary\\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "```\\nkevlplxo---zdhx---mraiak---\\nkevlplxozaizdhxoimmraiakbak\\n```\\n9 characters not mapped to any substring"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I have a doubt regarding this question, what if some part of the given string is \"_______yy___\" and in the dictionary i have a string \"y\" -> then i should remove only 1 y or both y's from the given string ?\n\nAny help is appreciated."
                    },
                    {
                        "username": "aakashsrh",
                        "content": "[@sergei99](/sergei99) Thank you, Sir."
                    },
                    {
                        "username": "sergei99",
                        "content": "A single 'y' in the string won't match 'yy' in the dictionary. It's just all or nothing match.\nThe other way around (dictionary's 'y' and string's 'yy') is fine. Both 'y's will be removed from the string."
                    },
                    {
                        "username": "ArtemBaykov",
                        "content": "HELP! I NEED SOMEBODY) where is a mistake?\\nOutput\\n8\\nExpected\\n9\\nwhich index  is not counted?\\n{8, 9, 10, 16, 17, 24, 25, 26}\\n\\n\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        d = {w:s.count(w) for w in dictionary if s.count(w)!=0}\\n        res = []\\n        for key in d:\\n            if d[key]!=0:\\n                print(\\'key:\\',key, d[key])\\n                in_start = 0\\n                count = s.index(key)\\n                for i in range(d[key]):\\n                    in_w = s[in_start:].index(key)\\n                    l = [x for x in range(in_w + in_start, in_start+in_w + len(key))]\\n                    print(l)\\n                    res += l\\n                    in_start = max(l)+1\\n\\n                \\n        print(sorted(res))\\n        y = [x for x in range(len(s))]\\n        print(y)\\n        print(set(y).difference(set(res)))\\n        return len(set(y).difference(set(res)))\\n\\n"
                    },
                    {
                        "username": "mstuebs",
                        "content": "\"zzyyxxwwvvuuttssrrqqppoonnmmllkkjjiihhggffeeddccbb\"\n[\"ffeed\", \"kkjji\", \"ppoon\", \"uutts\", \"zzyyx\", \"ccb\", \"dcc\", \"ddc\", \"eed\", \"fee\", \"ffe\", \"ggf\", \"hgg\", \"hhg\", \"iih\", \"jii\", \"jji\", \"kkj\", \"lkk\", \"llk\", \"mml\", \"nmm\", \"nnm\", \"oon\", \"poo\", \"ppo\", \"qqp\", \"rqq\", \"rrq\", \"ssr\", \"tss\", \"tts\", \"uut\", \"vuu\", \"vvu\", \"wwv\", \"xww\", \"xxw\", \"yyx\", \"zyy\", \"zzy\"]"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Guys I think I\\'ve reached a bottleneck. No matter how much I practice, I\\'m just not getting better ..."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "To pick or not to pick."
                    },
                    {
                        "username": "aditya13451",
                        "content": "What is wrong in this implementation it\\'s showing wrong answer on test case 1995 i.e.\\ns = \"metzeaencgpgvsckjrqafkxgyzbe\"\\ndictionary =\\n[\"zdzz\",\"lgrhy\",\"r\",\"ohk\",\"zkowk\",\"g\",\"zqpn\",\"anoni\",\"ka\",\"qafkx\",\"t\",\"jr\",\"xdye\",\"mppc\",\"bqqb\",\"encgp\",\"yf\",\"vl\",\"ctsxk\",\"gn\",\"cujh\",\"ce\",\"rwrpq\",\"tze\",\"zxhg\",\"yzbe\",\"c\",\"o\",\"hnk\",\"gv\",\"uzbc\",\"xn\",\"kk\",\"ujjd\",\"vv\",\"mxhmv\",\"ugn\",\"at\",\"kumr\",\"ensv\",\"x\",\"uy\",\"gb\",\"ae\",\"jljuo\",\"xqkgj\"]\\n\\nclass Solution {\\npublic:\\n\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        int n = s.size();\\n        int x;\\n        int found = 0;\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            found = 0;\\n            for(int j=i; j<n; j++){\\n                if(find(dictionary.begin(), dictionary.end(), s.substr(i,j-i+1)) != dictionary.end()){\\n                    found = 1;\\n                    x = j;\\n                }\\n            }\\n            if(found == 1){\\n                i = x;\\n            }\\n            else{\\n                ans++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "aditya13451",
                        "content": "[@user3954sk](/user3954sk) Ohhhkkayy right, thanks bro"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Consider these two test cases.  Your program will fail for both of them.\\n\"abc\", [\"a\",\"ab\",\"bc\"]\\n\"abcd\",[\"ab\",\"bcd\"]"
                    }
                ]
            },
            {
                "id": 2041351,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "kinda tough seeing the dp recurrence relation "
                    },
                    {
                        "username": "miglani_9121",
                        "content": "why my answer is coming wrong at this testcase while i am solving the question brutly\\ns=\"kevlplxozaizdhxoimmraiakbak\"\\ndict =[\"yv\",\"bmab\",\"hv\",\"bnsll\",\"mra\",\"jjqf\",\"g\",\"aiyzi\",\"ip\",\"pfctr\",\"flr\",\"ybbcl\",\"biu\",\"ke\",\"lpl\",\"iak\",\"pirua\",\"ilhqd\",\"zdhx\",\"fux\",\"xaw\",\"pdfvt\",\"xf\",\"t\",\"wq\",\"r\",\"cgmud\",\"aokas\",\"xv\",\"jf\",\"cyys\",\"wcaz\",\"rvegf\",\"ysg\",\"xo\",\"uwb\",\"lw\",\"okgk\",\"vbmi\",\"v\",\"mvo\",\"fxyx\",\"ad\",\"e\"]\\n\\nmy ans coming 8 and ans is 9\\n\\nmy code is\\n\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<string, int> m;\\n        cout<<s.size()<<endl;\\n        for(int i = 0; i<dictionary.size(); i++)\\n        {\\n            m[dictionary[i]]++;\\n        }\\n        int n=s.size();\\n        vector<int> v(n, -1);\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string temp = \"\";\\n            temp+=s[i];\\n            // cout<<temp<<endl;\\n            if(m.find(temp)!=m.end())\\n            {\\n                v[i]=max(v[i], i);\\n            }\\n            for(int j=i+1;j<s.size();j++)\\n            {\\n                temp+=s[j];\\n                // cout<<temp<<endl;\\n                if(m.find(temp)!=m.end())\\n                {\\n                    v[i]=max(v[i], j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<v.size();i++) cout<<v[i]<<\" \";\\n        cout << endl;\\n        for(int i = 0; i<v.size(); i++)\\n        {\\n            if(v[i]!=-1)\\n            {\\n                for(int j = i; j<=v[i]; j++) if(s[j]!= \\'-1\\') s[j]=\\'1\\';\\n            }\\n        }\\n        cout<<s<<endl;\\n        int count = 0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]!=\\'1\\') count++;\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "breathermachine",
                        "content": "```\\nkevlplxo---zdhx---mraiak---\\nkevlplxozaizdhxoimmraiakbak\\n```"
                    },
                    {
                        "username": "therealgeraldsy",
                        "content": "I am also stuck here! got an answer of 8, but leetcode said its 9"
                    },
                    {
                        "username": "Manu_7122001",
                        "content": "please tell me"
                    },
                    {
                        "username": "lexuankyxd",
                        "content": "Java array list adding new numbers from no where?\\n\\nSo basically, i have a static list<integer> object called list in Node class. At the bottom of node class, it checks if current node has any children, if not then add the number of spaces left behind into the list. And whenever it adds something to the list a System.out.println is executed so I know if they are adding stuff to the list. My problem is when somehow numbers are being added out of nowhere. This happens for the 2nd test case. Can anyone tell me why this is happening or what might have something to do with it. Much appreciated.\\n\\n\\ncode that check print out the list\\n\\nfor(int i = 0; i < Node.list.size(); i ++){\\n            if(Node.list.get(i) < min) min = Node.list.get(i);\\n            System.out.println(Node.list.get(i));\\n        }\\n        return min;\\n\\n\\ncode that add stuff to the list \\n\\nif(nodes.size() == 0) {\\n            int f = 0;\\n            for(boolean c: a){\\n                if(c) f++;\\n            }\\n            for(boolean asd: a){\\n                System.out.print(asd?1 + \" \":0 + \" \");\\n            }\\n            System.out.println(\"| \" + (string.length() - f));\\n            list.add( (string.length() - f)); // this is the only place where stuff get added to the list.\\n        }"
                    },
                    {
                        "username": "basurahan",
                        "content": "I don\\'t know why I am failing this test case my actual is 8 but the testcase expected is 9. I dont see my mistake. Can someone tell me why its supposed to be 9?\\n\\nMine is 8 and here are they:\\nCharPoint(char=k, points=1)\\nCharPoint(char=e, points=2)\\nCharPoint(char=v, points=1)\\nCharPoint(char=l, points=1)\\nCharPoint(char=p, points=1)\\nCharPoint(char=l, points=1)\\nCharPoint(char=x, points=1)\\nCharPoint(char=o, points=1)\\nCharPoint(char=z, points=0)\\nCharPoint(char=a, points=0)\\nCharPoint(char=i, points=0)\\nCharPoint(char=z, points=1)\\nCharPoint(char=d, points=1)\\nCharPoint(char=h, points=1)\\nCharPoint(char=x, points=2)\\nCharPoint(char=o, points=1)\\nCharPoint(char=i, points=0)\\nCharPoint(char=m, points=0)\\nCharPoint(char=m, points=1)\\nCharPoint(char=r, points=2)\\nCharPoint(char=a, points=1)\\nCharPoint(char=i, points=1)\\nCharPoint(char=a, points=1)\\nCharPoint(char=k, points=1)\\nCharPoint(char=b, points=0)\\nCharPoint(char=a, points=0)\\nCharPoint(char=k, points=0)\\n\\n\\ns = \"kevlplxozaizdhxoimmraiakbak\"\\ndictionary = [\"yv\",\"bmab\",\"hv\",\"bnsll\",\"mra\",\"jjqf\",\"g\",\"aiyzi\",\"ip\",\"pfctr\",\"flr\",\"ybbcl\",\"biu\",\"ke\",\"lpl\",\"iak\",\"pirua\",\"ilhqd\",\"zdhx\",\"fux\",\"xaw\",\"pdfvt\",\"xf\",\"t\",\"wq\",\"r\",\"cgmud\",\"aokas\",\"xv\",\"jf\",\"cyys\",\"wcaz\",\"rvegf\",\"ysg\",\"xo\",\"uwb\",\"lw\",\"okgk\",\"vbmi\",\"v\",\"mvo\",\"fxyx\",\"ad\",\"e\"]"
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@sapercq](/sapercq) So which word/words can handle `zdh`?"
                    },
                    {
                        "username": "sapercq",
                        "content": "[@sapercq](/sapercq) so you can build \"XO\" and gain -1 letter"
                    },
                    {
                        "username": "sapercq",
                        "content": "[@breathermachine](/breathermachine) Why not kevlplxo---zdhxo--mraiak---?????\\nbcs we have xo in dictionary\\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "```\\nkevlplxo---zdhx---mraiak---\\nkevlplxozaizdhxoimmraiakbak\\n```\\n9 characters not mapped to any substring"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I have a doubt regarding this question, what if some part of the given string is \"_______yy___\" and in the dictionary i have a string \"y\" -> then i should remove only 1 y or both y's from the given string ?\n\nAny help is appreciated."
                    },
                    {
                        "username": "aakashsrh",
                        "content": "[@sergei99](/sergei99) Thank you, Sir."
                    },
                    {
                        "username": "sergei99",
                        "content": "A single 'y' in the string won't match 'yy' in the dictionary. It's just all or nothing match.\nThe other way around (dictionary's 'y' and string's 'yy') is fine. Both 'y's will be removed from the string."
                    },
                    {
                        "username": "ArtemBaykov",
                        "content": "HELP! I NEED SOMEBODY) where is a mistake?\\nOutput\\n8\\nExpected\\n9\\nwhich index  is not counted?\\n{8, 9, 10, 16, 17, 24, 25, 26}\\n\\n\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        d = {w:s.count(w) for w in dictionary if s.count(w)!=0}\\n        res = []\\n        for key in d:\\n            if d[key]!=0:\\n                print(\\'key:\\',key, d[key])\\n                in_start = 0\\n                count = s.index(key)\\n                for i in range(d[key]):\\n                    in_w = s[in_start:].index(key)\\n                    l = [x for x in range(in_w + in_start, in_start+in_w + len(key))]\\n                    print(l)\\n                    res += l\\n                    in_start = max(l)+1\\n\\n                \\n        print(sorted(res))\\n        y = [x for x in range(len(s))]\\n        print(y)\\n        print(set(y).difference(set(res)))\\n        return len(set(y).difference(set(res)))\\n\\n"
                    },
                    {
                        "username": "mstuebs",
                        "content": "\"zzyyxxwwvvuuttssrrqqppoonnmmllkkjjiihhggffeeddccbb\"\n[\"ffeed\", \"kkjji\", \"ppoon\", \"uutts\", \"zzyyx\", \"ccb\", \"dcc\", \"ddc\", \"eed\", \"fee\", \"ffe\", \"ggf\", \"hgg\", \"hhg\", \"iih\", \"jii\", \"jji\", \"kkj\", \"lkk\", \"llk\", \"mml\", \"nmm\", \"nnm\", \"oon\", \"poo\", \"ppo\", \"qqp\", \"rqq\", \"rrq\", \"ssr\", \"tss\", \"tts\", \"uut\", \"vuu\", \"vvu\", \"wwv\", \"xww\", \"xxw\", \"yyx\", \"zyy\", \"zzy\"]"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Guys I think I\\'ve reached a bottleneck. No matter how much I practice, I\\'m just not getting better ..."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "To pick or not to pick."
                    },
                    {
                        "username": "aditya13451",
                        "content": "What is wrong in this implementation it\\'s showing wrong answer on test case 1995 i.e.\\ns = \"metzeaencgpgvsckjrqafkxgyzbe\"\\ndictionary =\\n[\"zdzz\",\"lgrhy\",\"r\",\"ohk\",\"zkowk\",\"g\",\"zqpn\",\"anoni\",\"ka\",\"qafkx\",\"t\",\"jr\",\"xdye\",\"mppc\",\"bqqb\",\"encgp\",\"yf\",\"vl\",\"ctsxk\",\"gn\",\"cujh\",\"ce\",\"rwrpq\",\"tze\",\"zxhg\",\"yzbe\",\"c\",\"o\",\"hnk\",\"gv\",\"uzbc\",\"xn\",\"kk\",\"ujjd\",\"vv\",\"mxhmv\",\"ugn\",\"at\",\"kumr\",\"ensv\",\"x\",\"uy\",\"gb\",\"ae\",\"jljuo\",\"xqkgj\"]\\n\\nclass Solution {\\npublic:\\n\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        int n = s.size();\\n        int x;\\n        int found = 0;\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            found = 0;\\n            for(int j=i; j<n; j++){\\n                if(find(dictionary.begin(), dictionary.end(), s.substr(i,j-i+1)) != dictionary.end()){\\n                    found = 1;\\n                    x = j;\\n                }\\n            }\\n            if(found == 1){\\n                i = x;\\n            }\\n            else{\\n                ans++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "aditya13451",
                        "content": "[@user3954sk](/user3954sk) Ohhhkkayy right, thanks bro"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Consider these two test cases.  Your program will fail for both of them.\\n\"abc\", [\"a\",\"ab\",\"bc\"]\\n\"abcd\",[\"ab\",\"bcd\"]"
                    }
                ]
            },
            {
                "id": 2041333,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "kinda tough seeing the dp recurrence relation "
                    },
                    {
                        "username": "miglani_9121",
                        "content": "why my answer is coming wrong at this testcase while i am solving the question brutly\\ns=\"kevlplxozaizdhxoimmraiakbak\"\\ndict =[\"yv\",\"bmab\",\"hv\",\"bnsll\",\"mra\",\"jjqf\",\"g\",\"aiyzi\",\"ip\",\"pfctr\",\"flr\",\"ybbcl\",\"biu\",\"ke\",\"lpl\",\"iak\",\"pirua\",\"ilhqd\",\"zdhx\",\"fux\",\"xaw\",\"pdfvt\",\"xf\",\"t\",\"wq\",\"r\",\"cgmud\",\"aokas\",\"xv\",\"jf\",\"cyys\",\"wcaz\",\"rvegf\",\"ysg\",\"xo\",\"uwb\",\"lw\",\"okgk\",\"vbmi\",\"v\",\"mvo\",\"fxyx\",\"ad\",\"e\"]\\n\\nmy ans coming 8 and ans is 9\\n\\nmy code is\\n\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<string, int> m;\\n        cout<<s.size()<<endl;\\n        for(int i = 0; i<dictionary.size(); i++)\\n        {\\n            m[dictionary[i]]++;\\n        }\\n        int n=s.size();\\n        vector<int> v(n, -1);\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string temp = \"\";\\n            temp+=s[i];\\n            // cout<<temp<<endl;\\n            if(m.find(temp)!=m.end())\\n            {\\n                v[i]=max(v[i], i);\\n            }\\n            for(int j=i+1;j<s.size();j++)\\n            {\\n                temp+=s[j];\\n                // cout<<temp<<endl;\\n                if(m.find(temp)!=m.end())\\n                {\\n                    v[i]=max(v[i], j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<v.size();i++) cout<<v[i]<<\" \";\\n        cout << endl;\\n        for(int i = 0; i<v.size(); i++)\\n        {\\n            if(v[i]!=-1)\\n            {\\n                for(int j = i; j<=v[i]; j++) if(s[j]!= \\'-1\\') s[j]=\\'1\\';\\n            }\\n        }\\n        cout<<s<<endl;\\n        int count = 0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]!=\\'1\\') count++;\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "breathermachine",
                        "content": "```\\nkevlplxo---zdhx---mraiak---\\nkevlplxozaizdhxoimmraiakbak\\n```"
                    },
                    {
                        "username": "therealgeraldsy",
                        "content": "I am also stuck here! got an answer of 8, but leetcode said its 9"
                    },
                    {
                        "username": "Manu_7122001",
                        "content": "please tell me"
                    },
                    {
                        "username": "lexuankyxd",
                        "content": "Java array list adding new numbers from no where?\\n\\nSo basically, i have a static list<integer> object called list in Node class. At the bottom of node class, it checks if current node has any children, if not then add the number of spaces left behind into the list. And whenever it adds something to the list a System.out.println is executed so I know if they are adding stuff to the list. My problem is when somehow numbers are being added out of nowhere. This happens for the 2nd test case. Can anyone tell me why this is happening or what might have something to do with it. Much appreciated.\\n\\n\\ncode that check print out the list\\n\\nfor(int i = 0; i < Node.list.size(); i ++){\\n            if(Node.list.get(i) < min) min = Node.list.get(i);\\n            System.out.println(Node.list.get(i));\\n        }\\n        return min;\\n\\n\\ncode that add stuff to the list \\n\\nif(nodes.size() == 0) {\\n            int f = 0;\\n            for(boolean c: a){\\n                if(c) f++;\\n            }\\n            for(boolean asd: a){\\n                System.out.print(asd?1 + \" \":0 + \" \");\\n            }\\n            System.out.println(\"| \" + (string.length() - f));\\n            list.add( (string.length() - f)); // this is the only place where stuff get added to the list.\\n        }"
                    },
                    {
                        "username": "basurahan",
                        "content": "I don\\'t know why I am failing this test case my actual is 8 but the testcase expected is 9. I dont see my mistake. Can someone tell me why its supposed to be 9?\\n\\nMine is 8 and here are they:\\nCharPoint(char=k, points=1)\\nCharPoint(char=e, points=2)\\nCharPoint(char=v, points=1)\\nCharPoint(char=l, points=1)\\nCharPoint(char=p, points=1)\\nCharPoint(char=l, points=1)\\nCharPoint(char=x, points=1)\\nCharPoint(char=o, points=1)\\nCharPoint(char=z, points=0)\\nCharPoint(char=a, points=0)\\nCharPoint(char=i, points=0)\\nCharPoint(char=z, points=1)\\nCharPoint(char=d, points=1)\\nCharPoint(char=h, points=1)\\nCharPoint(char=x, points=2)\\nCharPoint(char=o, points=1)\\nCharPoint(char=i, points=0)\\nCharPoint(char=m, points=0)\\nCharPoint(char=m, points=1)\\nCharPoint(char=r, points=2)\\nCharPoint(char=a, points=1)\\nCharPoint(char=i, points=1)\\nCharPoint(char=a, points=1)\\nCharPoint(char=k, points=1)\\nCharPoint(char=b, points=0)\\nCharPoint(char=a, points=0)\\nCharPoint(char=k, points=0)\\n\\n\\ns = \"kevlplxozaizdhxoimmraiakbak\"\\ndictionary = [\"yv\",\"bmab\",\"hv\",\"bnsll\",\"mra\",\"jjqf\",\"g\",\"aiyzi\",\"ip\",\"pfctr\",\"flr\",\"ybbcl\",\"biu\",\"ke\",\"lpl\",\"iak\",\"pirua\",\"ilhqd\",\"zdhx\",\"fux\",\"xaw\",\"pdfvt\",\"xf\",\"t\",\"wq\",\"r\",\"cgmud\",\"aokas\",\"xv\",\"jf\",\"cyys\",\"wcaz\",\"rvegf\",\"ysg\",\"xo\",\"uwb\",\"lw\",\"okgk\",\"vbmi\",\"v\",\"mvo\",\"fxyx\",\"ad\",\"e\"]"
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@sapercq](/sapercq) So which word/words can handle `zdh`?"
                    },
                    {
                        "username": "sapercq",
                        "content": "[@sapercq](/sapercq) so you can build \"XO\" and gain -1 letter"
                    },
                    {
                        "username": "sapercq",
                        "content": "[@breathermachine](/breathermachine) Why not kevlplxo---zdhxo--mraiak---?????\\nbcs we have xo in dictionary\\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "```\\nkevlplxo---zdhx---mraiak---\\nkevlplxozaizdhxoimmraiakbak\\n```\\n9 characters not mapped to any substring"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I have a doubt regarding this question, what if some part of the given string is \"_______yy___\" and in the dictionary i have a string \"y\" -> then i should remove only 1 y or both y's from the given string ?\n\nAny help is appreciated."
                    },
                    {
                        "username": "aakashsrh",
                        "content": "[@sergei99](/sergei99) Thank you, Sir."
                    },
                    {
                        "username": "sergei99",
                        "content": "A single 'y' in the string won't match 'yy' in the dictionary. It's just all or nothing match.\nThe other way around (dictionary's 'y' and string's 'yy') is fine. Both 'y's will be removed from the string."
                    },
                    {
                        "username": "ArtemBaykov",
                        "content": "HELP! I NEED SOMEBODY) where is a mistake?\\nOutput\\n8\\nExpected\\n9\\nwhich index  is not counted?\\n{8, 9, 10, 16, 17, 24, 25, 26}\\n\\n\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        d = {w:s.count(w) for w in dictionary if s.count(w)!=0}\\n        res = []\\n        for key in d:\\n            if d[key]!=0:\\n                print(\\'key:\\',key, d[key])\\n                in_start = 0\\n                count = s.index(key)\\n                for i in range(d[key]):\\n                    in_w = s[in_start:].index(key)\\n                    l = [x for x in range(in_w + in_start, in_start+in_w + len(key))]\\n                    print(l)\\n                    res += l\\n                    in_start = max(l)+1\\n\\n                \\n        print(sorted(res))\\n        y = [x for x in range(len(s))]\\n        print(y)\\n        print(set(y).difference(set(res)))\\n        return len(set(y).difference(set(res)))\\n\\n"
                    },
                    {
                        "username": "mstuebs",
                        "content": "\"zzyyxxwwvvuuttssrrqqppoonnmmllkkjjiihhggffeeddccbb\"\n[\"ffeed\", \"kkjji\", \"ppoon\", \"uutts\", \"zzyyx\", \"ccb\", \"dcc\", \"ddc\", \"eed\", \"fee\", \"ffe\", \"ggf\", \"hgg\", \"hhg\", \"iih\", \"jii\", \"jji\", \"kkj\", \"lkk\", \"llk\", \"mml\", \"nmm\", \"nnm\", \"oon\", \"poo\", \"ppo\", \"qqp\", \"rqq\", \"rrq\", \"ssr\", \"tss\", \"tts\", \"uut\", \"vuu\", \"vvu\", \"wwv\", \"xww\", \"xxw\", \"yyx\", \"zyy\", \"zzy\"]"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Guys I think I\\'ve reached a bottleneck. No matter how much I practice, I\\'m just not getting better ..."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "To pick or not to pick."
                    },
                    {
                        "username": "aditya13451",
                        "content": "What is wrong in this implementation it\\'s showing wrong answer on test case 1995 i.e.\\ns = \"metzeaencgpgvsckjrqafkxgyzbe\"\\ndictionary =\\n[\"zdzz\",\"lgrhy\",\"r\",\"ohk\",\"zkowk\",\"g\",\"zqpn\",\"anoni\",\"ka\",\"qafkx\",\"t\",\"jr\",\"xdye\",\"mppc\",\"bqqb\",\"encgp\",\"yf\",\"vl\",\"ctsxk\",\"gn\",\"cujh\",\"ce\",\"rwrpq\",\"tze\",\"zxhg\",\"yzbe\",\"c\",\"o\",\"hnk\",\"gv\",\"uzbc\",\"xn\",\"kk\",\"ujjd\",\"vv\",\"mxhmv\",\"ugn\",\"at\",\"kumr\",\"ensv\",\"x\",\"uy\",\"gb\",\"ae\",\"jljuo\",\"xqkgj\"]\\n\\nclass Solution {\\npublic:\\n\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        int n = s.size();\\n        int x;\\n        int found = 0;\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            found = 0;\\n            for(int j=i; j<n; j++){\\n                if(find(dictionary.begin(), dictionary.end(), s.substr(i,j-i+1)) != dictionary.end()){\\n                    found = 1;\\n                    x = j;\\n                }\\n            }\\n            if(found == 1){\\n                i = x;\\n            }\\n            else{\\n                ans++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "aditya13451",
                        "content": "[@user3954sk](/user3954sk) Ohhhkkayy right, thanks bro"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Consider these two test cases.  Your program will fail for both of them.\\n\"abc\", [\"a\",\"ab\",\"bc\"]\\n\"abcd\",[\"ab\",\"bcd\"]"
                    }
                ]
            },
            {
                "id": 2041230,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "kinda tough seeing the dp recurrence relation "
                    },
                    {
                        "username": "miglani_9121",
                        "content": "why my answer is coming wrong at this testcase while i am solving the question brutly\\ns=\"kevlplxozaizdhxoimmraiakbak\"\\ndict =[\"yv\",\"bmab\",\"hv\",\"bnsll\",\"mra\",\"jjqf\",\"g\",\"aiyzi\",\"ip\",\"pfctr\",\"flr\",\"ybbcl\",\"biu\",\"ke\",\"lpl\",\"iak\",\"pirua\",\"ilhqd\",\"zdhx\",\"fux\",\"xaw\",\"pdfvt\",\"xf\",\"t\",\"wq\",\"r\",\"cgmud\",\"aokas\",\"xv\",\"jf\",\"cyys\",\"wcaz\",\"rvegf\",\"ysg\",\"xo\",\"uwb\",\"lw\",\"okgk\",\"vbmi\",\"v\",\"mvo\",\"fxyx\",\"ad\",\"e\"]\\n\\nmy ans coming 8 and ans is 9\\n\\nmy code is\\n\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<string, int> m;\\n        cout<<s.size()<<endl;\\n        for(int i = 0; i<dictionary.size(); i++)\\n        {\\n            m[dictionary[i]]++;\\n        }\\n        int n=s.size();\\n        vector<int> v(n, -1);\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string temp = \"\";\\n            temp+=s[i];\\n            // cout<<temp<<endl;\\n            if(m.find(temp)!=m.end())\\n            {\\n                v[i]=max(v[i], i);\\n            }\\n            for(int j=i+1;j<s.size();j++)\\n            {\\n                temp+=s[j];\\n                // cout<<temp<<endl;\\n                if(m.find(temp)!=m.end())\\n                {\\n                    v[i]=max(v[i], j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<v.size();i++) cout<<v[i]<<\" \";\\n        cout << endl;\\n        for(int i = 0; i<v.size(); i++)\\n        {\\n            if(v[i]!=-1)\\n            {\\n                for(int j = i; j<=v[i]; j++) if(s[j]!= \\'-1\\') s[j]=\\'1\\';\\n            }\\n        }\\n        cout<<s<<endl;\\n        int count = 0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]!=\\'1\\') count++;\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "breathermachine",
                        "content": "```\\nkevlplxo---zdhx---mraiak---\\nkevlplxozaizdhxoimmraiakbak\\n```"
                    },
                    {
                        "username": "therealgeraldsy",
                        "content": "I am also stuck here! got an answer of 8, but leetcode said its 9"
                    },
                    {
                        "username": "Manu_7122001",
                        "content": "please tell me"
                    },
                    {
                        "username": "lexuankyxd",
                        "content": "Java array list adding new numbers from no where?\\n\\nSo basically, i have a static list<integer> object called list in Node class. At the bottom of node class, it checks if current node has any children, if not then add the number of spaces left behind into the list. And whenever it adds something to the list a System.out.println is executed so I know if they are adding stuff to the list. My problem is when somehow numbers are being added out of nowhere. This happens for the 2nd test case. Can anyone tell me why this is happening or what might have something to do with it. Much appreciated.\\n\\n\\ncode that check print out the list\\n\\nfor(int i = 0; i < Node.list.size(); i ++){\\n            if(Node.list.get(i) < min) min = Node.list.get(i);\\n            System.out.println(Node.list.get(i));\\n        }\\n        return min;\\n\\n\\ncode that add stuff to the list \\n\\nif(nodes.size() == 0) {\\n            int f = 0;\\n            for(boolean c: a){\\n                if(c) f++;\\n            }\\n            for(boolean asd: a){\\n                System.out.print(asd?1 + \" \":0 + \" \");\\n            }\\n            System.out.println(\"| \" + (string.length() - f));\\n            list.add( (string.length() - f)); // this is the only place where stuff get added to the list.\\n        }"
                    },
                    {
                        "username": "basurahan",
                        "content": "I don\\'t know why I am failing this test case my actual is 8 but the testcase expected is 9. I dont see my mistake. Can someone tell me why its supposed to be 9?\\n\\nMine is 8 and here are they:\\nCharPoint(char=k, points=1)\\nCharPoint(char=e, points=2)\\nCharPoint(char=v, points=1)\\nCharPoint(char=l, points=1)\\nCharPoint(char=p, points=1)\\nCharPoint(char=l, points=1)\\nCharPoint(char=x, points=1)\\nCharPoint(char=o, points=1)\\nCharPoint(char=z, points=0)\\nCharPoint(char=a, points=0)\\nCharPoint(char=i, points=0)\\nCharPoint(char=z, points=1)\\nCharPoint(char=d, points=1)\\nCharPoint(char=h, points=1)\\nCharPoint(char=x, points=2)\\nCharPoint(char=o, points=1)\\nCharPoint(char=i, points=0)\\nCharPoint(char=m, points=0)\\nCharPoint(char=m, points=1)\\nCharPoint(char=r, points=2)\\nCharPoint(char=a, points=1)\\nCharPoint(char=i, points=1)\\nCharPoint(char=a, points=1)\\nCharPoint(char=k, points=1)\\nCharPoint(char=b, points=0)\\nCharPoint(char=a, points=0)\\nCharPoint(char=k, points=0)\\n\\n\\ns = \"kevlplxozaizdhxoimmraiakbak\"\\ndictionary = [\"yv\",\"bmab\",\"hv\",\"bnsll\",\"mra\",\"jjqf\",\"g\",\"aiyzi\",\"ip\",\"pfctr\",\"flr\",\"ybbcl\",\"biu\",\"ke\",\"lpl\",\"iak\",\"pirua\",\"ilhqd\",\"zdhx\",\"fux\",\"xaw\",\"pdfvt\",\"xf\",\"t\",\"wq\",\"r\",\"cgmud\",\"aokas\",\"xv\",\"jf\",\"cyys\",\"wcaz\",\"rvegf\",\"ysg\",\"xo\",\"uwb\",\"lw\",\"okgk\",\"vbmi\",\"v\",\"mvo\",\"fxyx\",\"ad\",\"e\"]"
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@sapercq](/sapercq) So which word/words can handle `zdh`?"
                    },
                    {
                        "username": "sapercq",
                        "content": "[@sapercq](/sapercq) so you can build \"XO\" and gain -1 letter"
                    },
                    {
                        "username": "sapercq",
                        "content": "[@breathermachine](/breathermachine) Why not kevlplxo---zdhxo--mraiak---?????\\nbcs we have xo in dictionary\\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "```\\nkevlplxo---zdhx---mraiak---\\nkevlplxozaizdhxoimmraiakbak\\n```\\n9 characters not mapped to any substring"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I have a doubt regarding this question, what if some part of the given string is \"_______yy___\" and in the dictionary i have a string \"y\" -> then i should remove only 1 y or both y's from the given string ?\n\nAny help is appreciated."
                    },
                    {
                        "username": "aakashsrh",
                        "content": "[@sergei99](/sergei99) Thank you, Sir."
                    },
                    {
                        "username": "sergei99",
                        "content": "A single 'y' in the string won't match 'yy' in the dictionary. It's just all or nothing match.\nThe other way around (dictionary's 'y' and string's 'yy') is fine. Both 'y's will be removed from the string."
                    },
                    {
                        "username": "ArtemBaykov",
                        "content": "HELP! I NEED SOMEBODY) where is a mistake?\\nOutput\\n8\\nExpected\\n9\\nwhich index  is not counted?\\n{8, 9, 10, 16, 17, 24, 25, 26}\\n\\n\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        d = {w:s.count(w) for w in dictionary if s.count(w)!=0}\\n        res = []\\n        for key in d:\\n            if d[key]!=0:\\n                print(\\'key:\\',key, d[key])\\n                in_start = 0\\n                count = s.index(key)\\n                for i in range(d[key]):\\n                    in_w = s[in_start:].index(key)\\n                    l = [x for x in range(in_w + in_start, in_start+in_w + len(key))]\\n                    print(l)\\n                    res += l\\n                    in_start = max(l)+1\\n\\n                \\n        print(sorted(res))\\n        y = [x for x in range(len(s))]\\n        print(y)\\n        print(set(y).difference(set(res)))\\n        return len(set(y).difference(set(res)))\\n\\n"
                    },
                    {
                        "username": "mstuebs",
                        "content": "\"zzyyxxwwvvuuttssrrqqppoonnmmllkkjjiihhggffeeddccbb\"\n[\"ffeed\", \"kkjji\", \"ppoon\", \"uutts\", \"zzyyx\", \"ccb\", \"dcc\", \"ddc\", \"eed\", \"fee\", \"ffe\", \"ggf\", \"hgg\", \"hhg\", \"iih\", \"jii\", \"jji\", \"kkj\", \"lkk\", \"llk\", \"mml\", \"nmm\", \"nnm\", \"oon\", \"poo\", \"ppo\", \"qqp\", \"rqq\", \"rrq\", \"ssr\", \"tss\", \"tts\", \"uut\", \"vuu\", \"vvu\", \"wwv\", \"xww\", \"xxw\", \"yyx\", \"zyy\", \"zzy\"]"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Guys I think I\\'ve reached a bottleneck. No matter how much I practice, I\\'m just not getting better ..."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "To pick or not to pick."
                    },
                    {
                        "username": "aditya13451",
                        "content": "What is wrong in this implementation it\\'s showing wrong answer on test case 1995 i.e.\\ns = \"metzeaencgpgvsckjrqafkxgyzbe\"\\ndictionary =\\n[\"zdzz\",\"lgrhy\",\"r\",\"ohk\",\"zkowk\",\"g\",\"zqpn\",\"anoni\",\"ka\",\"qafkx\",\"t\",\"jr\",\"xdye\",\"mppc\",\"bqqb\",\"encgp\",\"yf\",\"vl\",\"ctsxk\",\"gn\",\"cujh\",\"ce\",\"rwrpq\",\"tze\",\"zxhg\",\"yzbe\",\"c\",\"o\",\"hnk\",\"gv\",\"uzbc\",\"xn\",\"kk\",\"ujjd\",\"vv\",\"mxhmv\",\"ugn\",\"at\",\"kumr\",\"ensv\",\"x\",\"uy\",\"gb\",\"ae\",\"jljuo\",\"xqkgj\"]\\n\\nclass Solution {\\npublic:\\n\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        int n = s.size();\\n        int x;\\n        int found = 0;\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            found = 0;\\n            for(int j=i; j<n; j++){\\n                if(find(dictionary.begin(), dictionary.end(), s.substr(i,j-i+1)) != dictionary.end()){\\n                    found = 1;\\n                    x = j;\\n                }\\n            }\\n            if(found == 1){\\n                i = x;\\n            }\\n            else{\\n                ans++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "aditya13451",
                        "content": "[@user3954sk](/user3954sk) Ohhhkkayy right, thanks bro"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Consider these two test cases.  Your program will fail for both of them.\\n\"abc\", [\"a\",\"ab\",\"bc\"]\\n\"abcd\",[\"ab\",\"bcd\"]"
                    }
                ]
            },
            {
                "id": 2040706,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "kinda tough seeing the dp recurrence relation "
                    },
                    {
                        "username": "miglani_9121",
                        "content": "why my answer is coming wrong at this testcase while i am solving the question brutly\\ns=\"kevlplxozaizdhxoimmraiakbak\"\\ndict =[\"yv\",\"bmab\",\"hv\",\"bnsll\",\"mra\",\"jjqf\",\"g\",\"aiyzi\",\"ip\",\"pfctr\",\"flr\",\"ybbcl\",\"biu\",\"ke\",\"lpl\",\"iak\",\"pirua\",\"ilhqd\",\"zdhx\",\"fux\",\"xaw\",\"pdfvt\",\"xf\",\"t\",\"wq\",\"r\",\"cgmud\",\"aokas\",\"xv\",\"jf\",\"cyys\",\"wcaz\",\"rvegf\",\"ysg\",\"xo\",\"uwb\",\"lw\",\"okgk\",\"vbmi\",\"v\",\"mvo\",\"fxyx\",\"ad\",\"e\"]\\n\\nmy ans coming 8 and ans is 9\\n\\nmy code is\\n\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        unordered_map<string, int> m;\\n        cout<<s.size()<<endl;\\n        for(int i = 0; i<dictionary.size(); i++)\\n        {\\n            m[dictionary[i]]++;\\n        }\\n        int n=s.size();\\n        vector<int> v(n, -1);\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string temp = \"\";\\n            temp+=s[i];\\n            // cout<<temp<<endl;\\n            if(m.find(temp)!=m.end())\\n            {\\n                v[i]=max(v[i], i);\\n            }\\n            for(int j=i+1;j<s.size();j++)\\n            {\\n                temp+=s[j];\\n                // cout<<temp<<endl;\\n                if(m.find(temp)!=m.end())\\n                {\\n                    v[i]=max(v[i], j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<v.size();i++) cout<<v[i]<<\" \";\\n        cout << endl;\\n        for(int i = 0; i<v.size(); i++)\\n        {\\n            if(v[i]!=-1)\\n            {\\n                for(int j = i; j<=v[i]; j++) if(s[j]!= \\'-1\\') s[j]=\\'1\\';\\n            }\\n        }\\n        cout<<s<<endl;\\n        int count = 0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]!=\\'1\\') count++;\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "breathermachine",
                        "content": "```\\nkevlplxo---zdhx---mraiak---\\nkevlplxozaizdhxoimmraiakbak\\n```"
                    },
                    {
                        "username": "therealgeraldsy",
                        "content": "I am also stuck here! got an answer of 8, but leetcode said its 9"
                    },
                    {
                        "username": "Manu_7122001",
                        "content": "please tell me"
                    },
                    {
                        "username": "lexuankyxd",
                        "content": "Java array list adding new numbers from no where?\\n\\nSo basically, i have a static list<integer> object called list in Node class. At the bottom of node class, it checks if current node has any children, if not then add the number of spaces left behind into the list. And whenever it adds something to the list a System.out.println is executed so I know if they are adding stuff to the list. My problem is when somehow numbers are being added out of nowhere. This happens for the 2nd test case. Can anyone tell me why this is happening or what might have something to do with it. Much appreciated.\\n\\n\\ncode that check print out the list\\n\\nfor(int i = 0; i < Node.list.size(); i ++){\\n            if(Node.list.get(i) < min) min = Node.list.get(i);\\n            System.out.println(Node.list.get(i));\\n        }\\n        return min;\\n\\n\\ncode that add stuff to the list \\n\\nif(nodes.size() == 0) {\\n            int f = 0;\\n            for(boolean c: a){\\n                if(c) f++;\\n            }\\n            for(boolean asd: a){\\n                System.out.print(asd?1 + \" \":0 + \" \");\\n            }\\n            System.out.println(\"| \" + (string.length() - f));\\n            list.add( (string.length() - f)); // this is the only place where stuff get added to the list.\\n        }"
                    },
                    {
                        "username": "basurahan",
                        "content": "I don\\'t know why I am failing this test case my actual is 8 but the testcase expected is 9. I dont see my mistake. Can someone tell me why its supposed to be 9?\\n\\nMine is 8 and here are they:\\nCharPoint(char=k, points=1)\\nCharPoint(char=e, points=2)\\nCharPoint(char=v, points=1)\\nCharPoint(char=l, points=1)\\nCharPoint(char=p, points=1)\\nCharPoint(char=l, points=1)\\nCharPoint(char=x, points=1)\\nCharPoint(char=o, points=1)\\nCharPoint(char=z, points=0)\\nCharPoint(char=a, points=0)\\nCharPoint(char=i, points=0)\\nCharPoint(char=z, points=1)\\nCharPoint(char=d, points=1)\\nCharPoint(char=h, points=1)\\nCharPoint(char=x, points=2)\\nCharPoint(char=o, points=1)\\nCharPoint(char=i, points=0)\\nCharPoint(char=m, points=0)\\nCharPoint(char=m, points=1)\\nCharPoint(char=r, points=2)\\nCharPoint(char=a, points=1)\\nCharPoint(char=i, points=1)\\nCharPoint(char=a, points=1)\\nCharPoint(char=k, points=1)\\nCharPoint(char=b, points=0)\\nCharPoint(char=a, points=0)\\nCharPoint(char=k, points=0)\\n\\n\\ns = \"kevlplxozaizdhxoimmraiakbak\"\\ndictionary = [\"yv\",\"bmab\",\"hv\",\"bnsll\",\"mra\",\"jjqf\",\"g\",\"aiyzi\",\"ip\",\"pfctr\",\"flr\",\"ybbcl\",\"biu\",\"ke\",\"lpl\",\"iak\",\"pirua\",\"ilhqd\",\"zdhx\",\"fux\",\"xaw\",\"pdfvt\",\"xf\",\"t\",\"wq\",\"r\",\"cgmud\",\"aokas\",\"xv\",\"jf\",\"cyys\",\"wcaz\",\"rvegf\",\"ysg\",\"xo\",\"uwb\",\"lw\",\"okgk\",\"vbmi\",\"v\",\"mvo\",\"fxyx\",\"ad\",\"e\"]"
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@sapercq](/sapercq) So which word/words can handle `zdh`?"
                    },
                    {
                        "username": "sapercq",
                        "content": "[@sapercq](/sapercq) so you can build \"XO\" and gain -1 letter"
                    },
                    {
                        "username": "sapercq",
                        "content": "[@breathermachine](/breathermachine) Why not kevlplxo---zdhxo--mraiak---?????\\nbcs we have xo in dictionary\\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "```\\nkevlplxo---zdhx---mraiak---\\nkevlplxozaizdhxoimmraiakbak\\n```\\n9 characters not mapped to any substring"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I have a doubt regarding this question, what if some part of the given string is \"_______yy___\" and in the dictionary i have a string \"y\" -> then i should remove only 1 y or both y's from the given string ?\n\nAny help is appreciated."
                    },
                    {
                        "username": "aakashsrh",
                        "content": "[@sergei99](/sergei99) Thank you, Sir."
                    },
                    {
                        "username": "sergei99",
                        "content": "A single 'y' in the string won't match 'yy' in the dictionary. It's just all or nothing match.\nThe other way around (dictionary's 'y' and string's 'yy') is fine. Both 'y's will be removed from the string."
                    },
                    {
                        "username": "ArtemBaykov",
                        "content": "HELP! I NEED SOMEBODY) where is a mistake?\\nOutput\\n8\\nExpected\\n9\\nwhich index  is not counted?\\n{8, 9, 10, 16, 17, 24, 25, 26}\\n\\n\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        d = {w:s.count(w) for w in dictionary if s.count(w)!=0}\\n        res = []\\n        for key in d:\\n            if d[key]!=0:\\n                print(\\'key:\\',key, d[key])\\n                in_start = 0\\n                count = s.index(key)\\n                for i in range(d[key]):\\n                    in_w = s[in_start:].index(key)\\n                    l = [x for x in range(in_w + in_start, in_start+in_w + len(key))]\\n                    print(l)\\n                    res += l\\n                    in_start = max(l)+1\\n\\n                \\n        print(sorted(res))\\n        y = [x for x in range(len(s))]\\n        print(y)\\n        print(set(y).difference(set(res)))\\n        return len(set(y).difference(set(res)))\\n\\n"
                    },
                    {
                        "username": "mstuebs",
                        "content": "\"zzyyxxwwvvuuttssrrqqppoonnmmllkkjjiihhggffeeddccbb\"\n[\"ffeed\", \"kkjji\", \"ppoon\", \"uutts\", \"zzyyx\", \"ccb\", \"dcc\", \"ddc\", \"eed\", \"fee\", \"ffe\", \"ggf\", \"hgg\", \"hhg\", \"iih\", \"jii\", \"jji\", \"kkj\", \"lkk\", \"llk\", \"mml\", \"nmm\", \"nnm\", \"oon\", \"poo\", \"ppo\", \"qqp\", \"rqq\", \"rrq\", \"ssr\", \"tss\", \"tts\", \"uut\", \"vuu\", \"vvu\", \"wwv\", \"xww\", \"xxw\", \"yyx\", \"zyy\", \"zzy\"]"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Guys I think I\\'ve reached a bottleneck. No matter how much I practice, I\\'m just not getting better ..."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "To pick or not to pick."
                    },
                    {
                        "username": "aditya13451",
                        "content": "What is wrong in this implementation it\\'s showing wrong answer on test case 1995 i.e.\\ns = \"metzeaencgpgvsckjrqafkxgyzbe\"\\ndictionary =\\n[\"zdzz\",\"lgrhy\",\"r\",\"ohk\",\"zkowk\",\"g\",\"zqpn\",\"anoni\",\"ka\",\"qafkx\",\"t\",\"jr\",\"xdye\",\"mppc\",\"bqqb\",\"encgp\",\"yf\",\"vl\",\"ctsxk\",\"gn\",\"cujh\",\"ce\",\"rwrpq\",\"tze\",\"zxhg\",\"yzbe\",\"c\",\"o\",\"hnk\",\"gv\",\"uzbc\",\"xn\",\"kk\",\"ujjd\",\"vv\",\"mxhmv\",\"ugn\",\"at\",\"kumr\",\"ensv\",\"x\",\"uy\",\"gb\",\"ae\",\"jljuo\",\"xqkgj\"]\\n\\nclass Solution {\\npublic:\\n\\n    int minExtraChar(string s, vector<string>& dictionary) {\\n        int n = s.size();\\n        int x;\\n        int found = 0;\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            found = 0;\\n            for(int j=i; j<n; j++){\\n                if(find(dictionary.begin(), dictionary.end(), s.substr(i,j-i+1)) != dictionary.end()){\\n                    found = 1;\\n                    x = j;\\n                }\\n            }\\n            if(found == 1){\\n                i = x;\\n            }\\n            else{\\n                ans++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "aditya13451",
                        "content": "[@user3954sk](/user3954sk) Ohhhkkayy right, thanks bro"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Consider these two test cases.  Your program will fail for both of them.\\n\"abc\", [\"a\",\"ab\",\"bc\"]\\n\"abcd\",[\"ab\",\"bcd\"]"
                    }
                ]
            },
            {
                "id": 2040643,
                "content": [
                    {
                        "username": "Dalt0nik",
                        "content": "Is it normal for a program to suddenly fail a test #2000+ ? Failed with Output `6`, expected `5`  on  `\"metzeaencgpgvsckjrqafkxgyzbe\"`  `[\"zdzz\",\"lgrhy\",\"r\",\"ohk\",\"zkowk\",\"g\",\"zqpn\",\"anoni\",\"ka\",\"qafkx\",\"t\",\"jr\",\"xdye\",\"mppc\",\"bqqb\",\"encgp\",\"yf\",\"vl\",\"ctsxk\",\"gn\",\"cujh\",\"ce\",\"rwrpq\",\"tze\",\"zxhg\",\"yzbe\",\"c\",\"o\",\"hnk\",\"gv\",\"uzbc\",\"xn\",\"kk\",\"ujjd\",\"vv\",\"mxhmv\",\"ugn\",\"at\",\"kumr\",\"ensv\",\"x\",\"uy\",\"gb\",\"ae\",\"jljuo\",\"xqkgj\"]`"
                    },
                    {
                        "username": "Dalt0nik",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Yes, thank you for a detailed answer. My mistake was me not considering the fact, that the biggest suitable substring in a dictionary is not always the best fit."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I'd guess you didn't cover some special case, or that the previous 1999 test cases were too similar.  \nFor this particular test case, here are the words of the `dictionary` as they appear in `s`:\n```\nmetzeaencgpgvsckjrqafkxgyzbe\n  tze\n  t\n     ae\n      encgp\n        c\n         g\n           g\n           gv\n              c\n                jr\n                 r\n                  qafkx\n                      x\n                       g\n                        yzbe\n```\nWith `5` extra characters you can build `s` like this:\n```\n1 2 tze 3 encgp gv 4 c 5 jr qafkx g yzbe\n```"
                    },
                    {
                        "username": "algoacer",
                        "content": "**Solve each question thinking independently**. \\n\\nI have solved Word Break-139 and tried this after checking that first. \\nResult: I couldn\\'t do this myself.\\n\\nThen thought of it as a new question, referred the solution and it was straight forward. \\n**Past experience sometimes misleads, past concepts never.**"
                    },
                    {
                        "username": "Selithrarion",
                        "content": "699th \\uD83D\\uDE33\\uD83D\\uDE33\\uD83D\\uDE33\\uD83D\\uDE33"
                    },
                    {
                        "username": "engixLC",
                        "content": "Failing test case 1991 / 2028 :\\ns = \"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\n\\ndictionary = [\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"]\\n\\nGetting output as 14 vs expected 15; is my code better than what it expects. Lol"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\n```\nazvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\nazv\n   zul\n    u\n          wobow\n            b\n               i\n                 i\n                  yeb\n                    b\n                        kecv\n                                 maqnv\n                                    n\n                                      na\n                                      n\n                                         maqnv\n                                            n\n```\nWith `15` extra characters you can produce this:\n```\nazv zul _ _ _ _ wobow i _ i yeb _ _ _ kecv _ _ _ _ _ maqnv na _ maqnv _\n```\nI don't see how it would be possible with `14` extra characters.  \nDid you maybe forget the `'f'` at the end?"
                    },
                    {
                        "username": "Yusif10",
                        "content": "Which is the unused character"
                    },
                    {
                        "username": "nikhilvashisht50",
                        "content": "yaar fir wohi dp"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "When you want to **practice + showoff** ability to handle complexity: Use Trie in Such question\nWhen in an **interview**: Use Hash Table, takes much less time and has neater code"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "2028 testcases. hahaha, go touch some grass, then get a life. \n\nTypical those who are always ready to stay in the office upto next day, cuz they don't have any hobbies. \n\nStaying in the office to write 2028 testcases for leetcode.  The badge 'Stapler of the month' is unlocked. jajajaja"
                    },
                    {
                        "username": "maheshsvm",
                        "content": "A small trick can solve the entire question."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Used this type of code but facing so many testcase error anyone can help me??\\n\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dict) {\\n        auto compareByLength = [](const string& a, const string& b) {\\n        return a.size() > b.size();\\n    };\\n    \\n    sort(dict.begin(), dict.end(), compareByLength);\\n\\n\\n        for(int i=0;i<dict.size();i++)\\n        {\\n            int a=dict[i].size();\\n            size_t index=s.find(dict[i]);\\n             if (index != string::npos) {\\n               {s.erase(index,a);\\n               i=-1;\\n               }\\n    }\\n\\n        }\\n        \\n\\n        return s.size();\\n    }\\n};"
                    },
                    {
                        "username": "0x34c",
                        "content": "cause this is not a greedy problem. You can\\'t just pick the shortest one. Consider this case:\\n\\ns = \"leetscoders\", dictionary = [\"leet\",\"code\",\"leetscode\"]\\n\\nHere, the solution is obviously 2 (leetscode is in dictionary and rs is added). However, your solution would output 3 (leet + s + code + rs)."
                    }
                ]
            },
            {
                "id": 2040636,
                "content": [
                    {
                        "username": "Dalt0nik",
                        "content": "Is it normal for a program to suddenly fail a test #2000+ ? Failed with Output `6`, expected `5`  on  `\"metzeaencgpgvsckjrqafkxgyzbe\"`  `[\"zdzz\",\"lgrhy\",\"r\",\"ohk\",\"zkowk\",\"g\",\"zqpn\",\"anoni\",\"ka\",\"qafkx\",\"t\",\"jr\",\"xdye\",\"mppc\",\"bqqb\",\"encgp\",\"yf\",\"vl\",\"ctsxk\",\"gn\",\"cujh\",\"ce\",\"rwrpq\",\"tze\",\"zxhg\",\"yzbe\",\"c\",\"o\",\"hnk\",\"gv\",\"uzbc\",\"xn\",\"kk\",\"ujjd\",\"vv\",\"mxhmv\",\"ugn\",\"at\",\"kumr\",\"ensv\",\"x\",\"uy\",\"gb\",\"ae\",\"jljuo\",\"xqkgj\"]`"
                    },
                    {
                        "username": "Dalt0nik",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Yes, thank you for a detailed answer. My mistake was me not considering the fact, that the biggest suitable substring in a dictionary is not always the best fit."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I'd guess you didn't cover some special case, or that the previous 1999 test cases were too similar.  \nFor this particular test case, here are the words of the `dictionary` as they appear in `s`:\n```\nmetzeaencgpgvsckjrqafkxgyzbe\n  tze\n  t\n     ae\n      encgp\n        c\n         g\n           g\n           gv\n              c\n                jr\n                 r\n                  qafkx\n                      x\n                       g\n                        yzbe\n```\nWith `5` extra characters you can build `s` like this:\n```\n1 2 tze 3 encgp gv 4 c 5 jr qafkx g yzbe\n```"
                    },
                    {
                        "username": "algoacer",
                        "content": "**Solve each question thinking independently**. \\n\\nI have solved Word Break-139 and tried this after checking that first. \\nResult: I couldn\\'t do this myself.\\n\\nThen thought of it as a new question, referred the solution and it was straight forward. \\n**Past experience sometimes misleads, past concepts never.**"
                    },
                    {
                        "username": "Selithrarion",
                        "content": "699th \\uD83D\\uDE33\\uD83D\\uDE33\\uD83D\\uDE33\\uD83D\\uDE33"
                    },
                    {
                        "username": "engixLC",
                        "content": "Failing test case 1991 / 2028 :\\ns = \"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\n\\ndictionary = [\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"]\\n\\nGetting output as 14 vs expected 15; is my code better than what it expects. Lol"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\n```\nazvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\nazv\n   zul\n    u\n          wobow\n            b\n               i\n                 i\n                  yeb\n                    b\n                        kecv\n                                 maqnv\n                                    n\n                                      na\n                                      n\n                                         maqnv\n                                            n\n```\nWith `15` extra characters you can produce this:\n```\nazv zul _ _ _ _ wobow i _ i yeb _ _ _ kecv _ _ _ _ _ maqnv na _ maqnv _\n```\nI don't see how it would be possible with `14` extra characters.  \nDid you maybe forget the `'f'` at the end?"
                    },
                    {
                        "username": "Yusif10",
                        "content": "Which is the unused character"
                    },
                    {
                        "username": "nikhilvashisht50",
                        "content": "yaar fir wohi dp"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "When you want to **practice + showoff** ability to handle complexity: Use Trie in Such question\nWhen in an **interview**: Use Hash Table, takes much less time and has neater code"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "2028 testcases. hahaha, go touch some grass, then get a life. \n\nTypical those who are always ready to stay in the office upto next day, cuz they don't have any hobbies. \n\nStaying in the office to write 2028 testcases for leetcode.  The badge 'Stapler of the month' is unlocked. jajajaja"
                    },
                    {
                        "username": "maheshsvm",
                        "content": "A small trick can solve the entire question."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Used this type of code but facing so many testcase error anyone can help me??\\n\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dict) {\\n        auto compareByLength = [](const string& a, const string& b) {\\n        return a.size() > b.size();\\n    };\\n    \\n    sort(dict.begin(), dict.end(), compareByLength);\\n\\n\\n        for(int i=0;i<dict.size();i++)\\n        {\\n            int a=dict[i].size();\\n            size_t index=s.find(dict[i]);\\n             if (index != string::npos) {\\n               {s.erase(index,a);\\n               i=-1;\\n               }\\n    }\\n\\n        }\\n        \\n\\n        return s.size();\\n    }\\n};"
                    },
                    {
                        "username": "0x34c",
                        "content": "cause this is not a greedy problem. You can\\'t just pick the shortest one. Consider this case:\\n\\ns = \"leetscoders\", dictionary = [\"leet\",\"code\",\"leetscode\"]\\n\\nHere, the solution is obviously 2 (leetscode is in dictionary and rs is added). However, your solution would output 3 (leet + s + code + rs)."
                    }
                ]
            },
            {
                "id": 2040629,
                "content": [
                    {
                        "username": "Dalt0nik",
                        "content": "Is it normal for a program to suddenly fail a test #2000+ ? Failed with Output `6`, expected `5`  on  `\"metzeaencgpgvsckjrqafkxgyzbe\"`  `[\"zdzz\",\"lgrhy\",\"r\",\"ohk\",\"zkowk\",\"g\",\"zqpn\",\"anoni\",\"ka\",\"qafkx\",\"t\",\"jr\",\"xdye\",\"mppc\",\"bqqb\",\"encgp\",\"yf\",\"vl\",\"ctsxk\",\"gn\",\"cujh\",\"ce\",\"rwrpq\",\"tze\",\"zxhg\",\"yzbe\",\"c\",\"o\",\"hnk\",\"gv\",\"uzbc\",\"xn\",\"kk\",\"ujjd\",\"vv\",\"mxhmv\",\"ugn\",\"at\",\"kumr\",\"ensv\",\"x\",\"uy\",\"gb\",\"ae\",\"jljuo\",\"xqkgj\"]`"
                    },
                    {
                        "username": "Dalt0nik",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Yes, thank you for a detailed answer. My mistake was me not considering the fact, that the biggest suitable substring in a dictionary is not always the best fit."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I'd guess you didn't cover some special case, or that the previous 1999 test cases were too similar.  \nFor this particular test case, here are the words of the `dictionary` as they appear in `s`:\n```\nmetzeaencgpgvsckjrqafkxgyzbe\n  tze\n  t\n     ae\n      encgp\n        c\n         g\n           g\n           gv\n              c\n                jr\n                 r\n                  qafkx\n                      x\n                       g\n                        yzbe\n```\nWith `5` extra characters you can build `s` like this:\n```\n1 2 tze 3 encgp gv 4 c 5 jr qafkx g yzbe\n```"
                    },
                    {
                        "username": "algoacer",
                        "content": "**Solve each question thinking independently**. \\n\\nI have solved Word Break-139 and tried this after checking that first. \\nResult: I couldn\\'t do this myself.\\n\\nThen thought of it as a new question, referred the solution and it was straight forward. \\n**Past experience sometimes misleads, past concepts never.**"
                    },
                    {
                        "username": "Selithrarion",
                        "content": "699th \\uD83D\\uDE33\\uD83D\\uDE33\\uD83D\\uDE33\\uD83D\\uDE33"
                    },
                    {
                        "username": "engixLC",
                        "content": "Failing test case 1991 / 2028 :\\ns = \"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\n\\ndictionary = [\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"]\\n\\nGetting output as 14 vs expected 15; is my code better than what it expects. Lol"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\n```\nazvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\nazv\n   zul\n    u\n          wobow\n            b\n               i\n                 i\n                  yeb\n                    b\n                        kecv\n                                 maqnv\n                                    n\n                                      na\n                                      n\n                                         maqnv\n                                            n\n```\nWith `15` extra characters you can produce this:\n```\nazv zul _ _ _ _ wobow i _ i yeb _ _ _ kecv _ _ _ _ _ maqnv na _ maqnv _\n```\nI don't see how it would be possible with `14` extra characters.  \nDid you maybe forget the `'f'` at the end?"
                    },
                    {
                        "username": "Yusif10",
                        "content": "Which is the unused character"
                    },
                    {
                        "username": "nikhilvashisht50",
                        "content": "yaar fir wohi dp"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "When you want to **practice + showoff** ability to handle complexity: Use Trie in Such question\nWhen in an **interview**: Use Hash Table, takes much less time and has neater code"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "2028 testcases. hahaha, go touch some grass, then get a life. \n\nTypical those who are always ready to stay in the office upto next day, cuz they don't have any hobbies. \n\nStaying in the office to write 2028 testcases for leetcode.  The badge 'Stapler of the month' is unlocked. jajajaja"
                    },
                    {
                        "username": "maheshsvm",
                        "content": "A small trick can solve the entire question."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Used this type of code but facing so many testcase error anyone can help me??\\n\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dict) {\\n        auto compareByLength = [](const string& a, const string& b) {\\n        return a.size() > b.size();\\n    };\\n    \\n    sort(dict.begin(), dict.end(), compareByLength);\\n\\n\\n        for(int i=0;i<dict.size();i++)\\n        {\\n            int a=dict[i].size();\\n            size_t index=s.find(dict[i]);\\n             if (index != string::npos) {\\n               {s.erase(index,a);\\n               i=-1;\\n               }\\n    }\\n\\n        }\\n        \\n\\n        return s.size();\\n    }\\n};"
                    },
                    {
                        "username": "0x34c",
                        "content": "cause this is not a greedy problem. You can\\'t just pick the shortest one. Consider this case:\\n\\ns = \"leetscoders\", dictionary = [\"leet\",\"code\",\"leetscode\"]\\n\\nHere, the solution is obviously 2 (leetscode is in dictionary and rs is added). However, your solution would output 3 (leet + s + code + rs)."
                    }
                ]
            },
            {
                "id": 2040593,
                "content": [
                    {
                        "username": "Dalt0nik",
                        "content": "Is it normal for a program to suddenly fail a test #2000+ ? Failed with Output `6`, expected `5`  on  `\"metzeaencgpgvsckjrqafkxgyzbe\"`  `[\"zdzz\",\"lgrhy\",\"r\",\"ohk\",\"zkowk\",\"g\",\"zqpn\",\"anoni\",\"ka\",\"qafkx\",\"t\",\"jr\",\"xdye\",\"mppc\",\"bqqb\",\"encgp\",\"yf\",\"vl\",\"ctsxk\",\"gn\",\"cujh\",\"ce\",\"rwrpq\",\"tze\",\"zxhg\",\"yzbe\",\"c\",\"o\",\"hnk\",\"gv\",\"uzbc\",\"xn\",\"kk\",\"ujjd\",\"vv\",\"mxhmv\",\"ugn\",\"at\",\"kumr\",\"ensv\",\"x\",\"uy\",\"gb\",\"ae\",\"jljuo\",\"xqkgj\"]`"
                    },
                    {
                        "username": "Dalt0nik",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Yes, thank you for a detailed answer. My mistake was me not considering the fact, that the biggest suitable substring in a dictionary is not always the best fit."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I'd guess you didn't cover some special case, or that the previous 1999 test cases were too similar.  \nFor this particular test case, here are the words of the `dictionary` as they appear in `s`:\n```\nmetzeaencgpgvsckjrqafkxgyzbe\n  tze\n  t\n     ae\n      encgp\n        c\n         g\n           g\n           gv\n              c\n                jr\n                 r\n                  qafkx\n                      x\n                       g\n                        yzbe\n```\nWith `5` extra characters you can build `s` like this:\n```\n1 2 tze 3 encgp gv 4 c 5 jr qafkx g yzbe\n```"
                    },
                    {
                        "username": "algoacer",
                        "content": "**Solve each question thinking independently**. \\n\\nI have solved Word Break-139 and tried this after checking that first. \\nResult: I couldn\\'t do this myself.\\n\\nThen thought of it as a new question, referred the solution and it was straight forward. \\n**Past experience sometimes misleads, past concepts never.**"
                    },
                    {
                        "username": "Selithrarion",
                        "content": "699th \\uD83D\\uDE33\\uD83D\\uDE33\\uD83D\\uDE33\\uD83D\\uDE33"
                    },
                    {
                        "username": "engixLC",
                        "content": "Failing test case 1991 / 2028 :\\ns = \"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\n\\ndictionary = [\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"]\\n\\nGetting output as 14 vs expected 15; is my code better than what it expects. Lol"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\n```\nazvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\nazv\n   zul\n    u\n          wobow\n            b\n               i\n                 i\n                  yeb\n                    b\n                        kecv\n                                 maqnv\n                                    n\n                                      na\n                                      n\n                                         maqnv\n                                            n\n```\nWith `15` extra characters you can produce this:\n```\nazv zul _ _ _ _ wobow i _ i yeb _ _ _ kecv _ _ _ _ _ maqnv na _ maqnv _\n```\nI don't see how it would be possible with `14` extra characters.  \nDid you maybe forget the `'f'` at the end?"
                    },
                    {
                        "username": "Yusif10",
                        "content": "Which is the unused character"
                    },
                    {
                        "username": "nikhilvashisht50",
                        "content": "yaar fir wohi dp"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "When you want to **practice + showoff** ability to handle complexity: Use Trie in Such question\nWhen in an **interview**: Use Hash Table, takes much less time and has neater code"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "2028 testcases. hahaha, go touch some grass, then get a life. \n\nTypical those who are always ready to stay in the office upto next day, cuz they don't have any hobbies. \n\nStaying in the office to write 2028 testcases for leetcode.  The badge 'Stapler of the month' is unlocked. jajajaja"
                    },
                    {
                        "username": "maheshsvm",
                        "content": "A small trick can solve the entire question."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Used this type of code but facing so many testcase error anyone can help me??\\n\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dict) {\\n        auto compareByLength = [](const string& a, const string& b) {\\n        return a.size() > b.size();\\n    };\\n    \\n    sort(dict.begin(), dict.end(), compareByLength);\\n\\n\\n        for(int i=0;i<dict.size();i++)\\n        {\\n            int a=dict[i].size();\\n            size_t index=s.find(dict[i]);\\n             if (index != string::npos) {\\n               {s.erase(index,a);\\n               i=-1;\\n               }\\n    }\\n\\n        }\\n        \\n\\n        return s.size();\\n    }\\n};"
                    },
                    {
                        "username": "0x34c",
                        "content": "cause this is not a greedy problem. You can\\'t just pick the shortest one. Consider this case:\\n\\ns = \"leetscoders\", dictionary = [\"leet\",\"code\",\"leetscode\"]\\n\\nHere, the solution is obviously 2 (leetscode is in dictionary and rs is added). However, your solution would output 3 (leet + s + code + rs)."
                    }
                ]
            },
            {
                "id": 2040572,
                "content": [
                    {
                        "username": "Dalt0nik",
                        "content": "Is it normal for a program to suddenly fail a test #2000+ ? Failed with Output `6`, expected `5`  on  `\"metzeaencgpgvsckjrqafkxgyzbe\"`  `[\"zdzz\",\"lgrhy\",\"r\",\"ohk\",\"zkowk\",\"g\",\"zqpn\",\"anoni\",\"ka\",\"qafkx\",\"t\",\"jr\",\"xdye\",\"mppc\",\"bqqb\",\"encgp\",\"yf\",\"vl\",\"ctsxk\",\"gn\",\"cujh\",\"ce\",\"rwrpq\",\"tze\",\"zxhg\",\"yzbe\",\"c\",\"o\",\"hnk\",\"gv\",\"uzbc\",\"xn\",\"kk\",\"ujjd\",\"vv\",\"mxhmv\",\"ugn\",\"at\",\"kumr\",\"ensv\",\"x\",\"uy\",\"gb\",\"ae\",\"jljuo\",\"xqkgj\"]`"
                    },
                    {
                        "username": "Dalt0nik",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Yes, thank you for a detailed answer. My mistake was me not considering the fact, that the biggest suitable substring in a dictionary is not always the best fit."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I'd guess you didn't cover some special case, or that the previous 1999 test cases were too similar.  \nFor this particular test case, here are the words of the `dictionary` as they appear in `s`:\n```\nmetzeaencgpgvsckjrqafkxgyzbe\n  tze\n  t\n     ae\n      encgp\n        c\n         g\n           g\n           gv\n              c\n                jr\n                 r\n                  qafkx\n                      x\n                       g\n                        yzbe\n```\nWith `5` extra characters you can build `s` like this:\n```\n1 2 tze 3 encgp gv 4 c 5 jr qafkx g yzbe\n```"
                    },
                    {
                        "username": "algoacer",
                        "content": "**Solve each question thinking independently**. \\n\\nI have solved Word Break-139 and tried this after checking that first. \\nResult: I couldn\\'t do this myself.\\n\\nThen thought of it as a new question, referred the solution and it was straight forward. \\n**Past experience sometimes misleads, past concepts never.**"
                    },
                    {
                        "username": "Selithrarion",
                        "content": "699th \\uD83D\\uDE33\\uD83D\\uDE33\\uD83D\\uDE33\\uD83D\\uDE33"
                    },
                    {
                        "username": "engixLC",
                        "content": "Failing test case 1991 / 2028 :\\ns = \"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\n\\ndictionary = [\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"]\\n\\nGetting output as 14 vs expected 15; is my code better than what it expects. Lol"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\n```\nazvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\nazv\n   zul\n    u\n          wobow\n            b\n               i\n                 i\n                  yeb\n                    b\n                        kecv\n                                 maqnv\n                                    n\n                                      na\n                                      n\n                                         maqnv\n                                            n\n```\nWith `15` extra characters you can produce this:\n```\nazv zul _ _ _ _ wobow i _ i yeb _ _ _ kecv _ _ _ _ _ maqnv na _ maqnv _\n```\nI don't see how it would be possible with `14` extra characters.  \nDid you maybe forget the `'f'` at the end?"
                    },
                    {
                        "username": "Yusif10",
                        "content": "Which is the unused character"
                    },
                    {
                        "username": "nikhilvashisht50",
                        "content": "yaar fir wohi dp"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "When you want to **practice + showoff** ability to handle complexity: Use Trie in Such question\nWhen in an **interview**: Use Hash Table, takes much less time and has neater code"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "2028 testcases. hahaha, go touch some grass, then get a life. \n\nTypical those who are always ready to stay in the office upto next day, cuz they don't have any hobbies. \n\nStaying in the office to write 2028 testcases for leetcode.  The badge 'Stapler of the month' is unlocked. jajajaja"
                    },
                    {
                        "username": "maheshsvm",
                        "content": "A small trick can solve the entire question."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Used this type of code but facing so many testcase error anyone can help me??\\n\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dict) {\\n        auto compareByLength = [](const string& a, const string& b) {\\n        return a.size() > b.size();\\n    };\\n    \\n    sort(dict.begin(), dict.end(), compareByLength);\\n\\n\\n        for(int i=0;i<dict.size();i++)\\n        {\\n            int a=dict[i].size();\\n            size_t index=s.find(dict[i]);\\n             if (index != string::npos) {\\n               {s.erase(index,a);\\n               i=-1;\\n               }\\n    }\\n\\n        }\\n        \\n\\n        return s.size();\\n    }\\n};"
                    },
                    {
                        "username": "0x34c",
                        "content": "cause this is not a greedy problem. You can\\'t just pick the shortest one. Consider this case:\\n\\ns = \"leetscoders\", dictionary = [\"leet\",\"code\",\"leetscode\"]\\n\\nHere, the solution is obviously 2 (leetscode is in dictionary and rs is added). However, your solution would output 3 (leet + s + code + rs)."
                    }
                ]
            },
            {
                "id": 2040561,
                "content": [
                    {
                        "username": "Dalt0nik",
                        "content": "Is it normal for a program to suddenly fail a test #2000+ ? Failed with Output `6`, expected `5`  on  `\"metzeaencgpgvsckjrqafkxgyzbe\"`  `[\"zdzz\",\"lgrhy\",\"r\",\"ohk\",\"zkowk\",\"g\",\"zqpn\",\"anoni\",\"ka\",\"qafkx\",\"t\",\"jr\",\"xdye\",\"mppc\",\"bqqb\",\"encgp\",\"yf\",\"vl\",\"ctsxk\",\"gn\",\"cujh\",\"ce\",\"rwrpq\",\"tze\",\"zxhg\",\"yzbe\",\"c\",\"o\",\"hnk\",\"gv\",\"uzbc\",\"xn\",\"kk\",\"ujjd\",\"vv\",\"mxhmv\",\"ugn\",\"at\",\"kumr\",\"ensv\",\"x\",\"uy\",\"gb\",\"ae\",\"jljuo\",\"xqkgj\"]`"
                    },
                    {
                        "username": "Dalt0nik",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Yes, thank you for a detailed answer. My mistake was me not considering the fact, that the biggest suitable substring in a dictionary is not always the best fit."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I'd guess you didn't cover some special case, or that the previous 1999 test cases were too similar.  \nFor this particular test case, here are the words of the `dictionary` as they appear in `s`:\n```\nmetzeaencgpgvsckjrqafkxgyzbe\n  tze\n  t\n     ae\n      encgp\n        c\n         g\n           g\n           gv\n              c\n                jr\n                 r\n                  qafkx\n                      x\n                       g\n                        yzbe\n```\nWith `5` extra characters you can build `s` like this:\n```\n1 2 tze 3 encgp gv 4 c 5 jr qafkx g yzbe\n```"
                    },
                    {
                        "username": "algoacer",
                        "content": "**Solve each question thinking independently**. \\n\\nI have solved Word Break-139 and tried this after checking that first. \\nResult: I couldn\\'t do this myself.\\n\\nThen thought of it as a new question, referred the solution and it was straight forward. \\n**Past experience sometimes misleads, past concepts never.**"
                    },
                    {
                        "username": "Selithrarion",
                        "content": "699th \\uD83D\\uDE33\\uD83D\\uDE33\\uD83D\\uDE33\\uD83D\\uDE33"
                    },
                    {
                        "username": "engixLC",
                        "content": "Failing test case 1991 / 2028 :\\ns = \"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\n\\ndictionary = [\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"]\\n\\nGetting output as 14 vs expected 15; is my code better than what it expects. Lol"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\n```\nazvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\nazv\n   zul\n    u\n          wobow\n            b\n               i\n                 i\n                  yeb\n                    b\n                        kecv\n                                 maqnv\n                                    n\n                                      na\n                                      n\n                                         maqnv\n                                            n\n```\nWith `15` extra characters you can produce this:\n```\nazv zul _ _ _ _ wobow i _ i yeb _ _ _ kecv _ _ _ _ _ maqnv na _ maqnv _\n```\nI don't see how it would be possible with `14` extra characters.  \nDid you maybe forget the `'f'` at the end?"
                    },
                    {
                        "username": "Yusif10",
                        "content": "Which is the unused character"
                    },
                    {
                        "username": "nikhilvashisht50",
                        "content": "yaar fir wohi dp"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "When you want to **practice + showoff** ability to handle complexity: Use Trie in Such question\nWhen in an **interview**: Use Hash Table, takes much less time and has neater code"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "2028 testcases. hahaha, go touch some grass, then get a life. \n\nTypical those who are always ready to stay in the office upto next day, cuz they don't have any hobbies. \n\nStaying in the office to write 2028 testcases for leetcode.  The badge 'Stapler of the month' is unlocked. jajajaja"
                    },
                    {
                        "username": "maheshsvm",
                        "content": "A small trick can solve the entire question."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Used this type of code but facing so many testcase error anyone can help me??\\n\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dict) {\\n        auto compareByLength = [](const string& a, const string& b) {\\n        return a.size() > b.size();\\n    };\\n    \\n    sort(dict.begin(), dict.end(), compareByLength);\\n\\n\\n        for(int i=0;i<dict.size();i++)\\n        {\\n            int a=dict[i].size();\\n            size_t index=s.find(dict[i]);\\n             if (index != string::npos) {\\n               {s.erase(index,a);\\n               i=-1;\\n               }\\n    }\\n\\n        }\\n        \\n\\n        return s.size();\\n    }\\n};"
                    },
                    {
                        "username": "0x34c",
                        "content": "cause this is not a greedy problem. You can\\'t just pick the shortest one. Consider this case:\\n\\ns = \"leetscoders\", dictionary = [\"leet\",\"code\",\"leetscode\"]\\n\\nHere, the solution is obviously 2 (leetscode is in dictionary and rs is added). However, your solution would output 3 (leet + s + code + rs)."
                    }
                ]
            },
            {
                "id": 2040503,
                "content": [
                    {
                        "username": "Dalt0nik",
                        "content": "Is it normal for a program to suddenly fail a test #2000+ ? Failed with Output `6`, expected `5`  on  `\"metzeaencgpgvsckjrqafkxgyzbe\"`  `[\"zdzz\",\"lgrhy\",\"r\",\"ohk\",\"zkowk\",\"g\",\"zqpn\",\"anoni\",\"ka\",\"qafkx\",\"t\",\"jr\",\"xdye\",\"mppc\",\"bqqb\",\"encgp\",\"yf\",\"vl\",\"ctsxk\",\"gn\",\"cujh\",\"ce\",\"rwrpq\",\"tze\",\"zxhg\",\"yzbe\",\"c\",\"o\",\"hnk\",\"gv\",\"uzbc\",\"xn\",\"kk\",\"ujjd\",\"vv\",\"mxhmv\",\"ugn\",\"at\",\"kumr\",\"ensv\",\"x\",\"uy\",\"gb\",\"ae\",\"jljuo\",\"xqkgj\"]`"
                    },
                    {
                        "username": "Dalt0nik",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Yes, thank you for a detailed answer. My mistake was me not considering the fact, that the biggest suitable substring in a dictionary is not always the best fit."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I'd guess you didn't cover some special case, or that the previous 1999 test cases were too similar.  \nFor this particular test case, here are the words of the `dictionary` as they appear in `s`:\n```\nmetzeaencgpgvsckjrqafkxgyzbe\n  tze\n  t\n     ae\n      encgp\n        c\n         g\n           g\n           gv\n              c\n                jr\n                 r\n                  qafkx\n                      x\n                       g\n                        yzbe\n```\nWith `5` extra characters you can build `s` like this:\n```\n1 2 tze 3 encgp gv 4 c 5 jr qafkx g yzbe\n```"
                    },
                    {
                        "username": "algoacer",
                        "content": "**Solve each question thinking independently**. \\n\\nI have solved Word Break-139 and tried this after checking that first. \\nResult: I couldn\\'t do this myself.\\n\\nThen thought of it as a new question, referred the solution and it was straight forward. \\n**Past experience sometimes misleads, past concepts never.**"
                    },
                    {
                        "username": "Selithrarion",
                        "content": "699th \\uD83D\\uDE33\\uD83D\\uDE33\\uD83D\\uDE33\\uD83D\\uDE33"
                    },
                    {
                        "username": "engixLC",
                        "content": "Failing test case 1991 / 2028 :\\ns = \"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\n\\ndictionary = [\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"]\\n\\nGetting output as 14 vs expected 15; is my code better than what it expects. Lol"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\n```\nazvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\nazv\n   zul\n    u\n          wobow\n            b\n               i\n                 i\n                  yeb\n                    b\n                        kecv\n                                 maqnv\n                                    n\n                                      na\n                                      n\n                                         maqnv\n                                            n\n```\nWith `15` extra characters you can produce this:\n```\nazv zul _ _ _ _ wobow i _ i yeb _ _ _ kecv _ _ _ _ _ maqnv na _ maqnv _\n```\nI don't see how it would be possible with `14` extra characters.  \nDid you maybe forget the `'f'` at the end?"
                    },
                    {
                        "username": "Yusif10",
                        "content": "Which is the unused character"
                    },
                    {
                        "username": "nikhilvashisht50",
                        "content": "yaar fir wohi dp"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "When you want to **practice + showoff** ability to handle complexity: Use Trie in Such question\nWhen in an **interview**: Use Hash Table, takes much less time and has neater code"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "2028 testcases. hahaha, go touch some grass, then get a life. \n\nTypical those who are always ready to stay in the office upto next day, cuz they don't have any hobbies. \n\nStaying in the office to write 2028 testcases for leetcode.  The badge 'Stapler of the month' is unlocked. jajajaja"
                    },
                    {
                        "username": "maheshsvm",
                        "content": "A small trick can solve the entire question."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Used this type of code but facing so many testcase error anyone can help me??\\n\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dict) {\\n        auto compareByLength = [](const string& a, const string& b) {\\n        return a.size() > b.size();\\n    };\\n    \\n    sort(dict.begin(), dict.end(), compareByLength);\\n\\n\\n        for(int i=0;i<dict.size();i++)\\n        {\\n            int a=dict[i].size();\\n            size_t index=s.find(dict[i]);\\n             if (index != string::npos) {\\n               {s.erase(index,a);\\n               i=-1;\\n               }\\n    }\\n\\n        }\\n        \\n\\n        return s.size();\\n    }\\n};"
                    },
                    {
                        "username": "0x34c",
                        "content": "cause this is not a greedy problem. You can\\'t just pick the shortest one. Consider this case:\\n\\ns = \"leetscoders\", dictionary = [\"leet\",\"code\",\"leetscode\"]\\n\\nHere, the solution is obviously 2 (leetscode is in dictionary and rs is added). However, your solution would output 3 (leet + s + code + rs)."
                    }
                ]
            },
            {
                "id": 2040387,
                "content": [
                    {
                        "username": "Dalt0nik",
                        "content": "Is it normal for a program to suddenly fail a test #2000+ ? Failed with Output `6`, expected `5`  on  `\"metzeaencgpgvsckjrqafkxgyzbe\"`  `[\"zdzz\",\"lgrhy\",\"r\",\"ohk\",\"zkowk\",\"g\",\"zqpn\",\"anoni\",\"ka\",\"qafkx\",\"t\",\"jr\",\"xdye\",\"mppc\",\"bqqb\",\"encgp\",\"yf\",\"vl\",\"ctsxk\",\"gn\",\"cujh\",\"ce\",\"rwrpq\",\"tze\",\"zxhg\",\"yzbe\",\"c\",\"o\",\"hnk\",\"gv\",\"uzbc\",\"xn\",\"kk\",\"ujjd\",\"vv\",\"mxhmv\",\"ugn\",\"at\",\"kumr\",\"ensv\",\"x\",\"uy\",\"gb\",\"ae\",\"jljuo\",\"xqkgj\"]`"
                    },
                    {
                        "username": "Dalt0nik",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Yes, thank you for a detailed answer. My mistake was me not considering the fact, that the biggest suitable substring in a dictionary is not always the best fit."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I'd guess you didn't cover some special case, or that the previous 1999 test cases were too similar.  \nFor this particular test case, here are the words of the `dictionary` as they appear in `s`:\n```\nmetzeaencgpgvsckjrqafkxgyzbe\n  tze\n  t\n     ae\n      encgp\n        c\n         g\n           g\n           gv\n              c\n                jr\n                 r\n                  qafkx\n                      x\n                       g\n                        yzbe\n```\nWith `5` extra characters you can build `s` like this:\n```\n1 2 tze 3 encgp gv 4 c 5 jr qafkx g yzbe\n```"
                    },
                    {
                        "username": "algoacer",
                        "content": "**Solve each question thinking independently**. \\n\\nI have solved Word Break-139 and tried this after checking that first. \\nResult: I couldn\\'t do this myself.\\n\\nThen thought of it as a new question, referred the solution and it was straight forward. \\n**Past experience sometimes misleads, past concepts never.**"
                    },
                    {
                        "username": "Selithrarion",
                        "content": "699th \\uD83D\\uDE33\\uD83D\\uDE33\\uD83D\\uDE33\\uD83D\\uDE33"
                    },
                    {
                        "username": "engixLC",
                        "content": "Failing test case 1991 / 2028 :\\ns = \"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\n\\ndictionary = [\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"]\\n\\nGetting output as 14 vs expected 15; is my code better than what it expects. Lol"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\n```\nazvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\nazv\n   zul\n    u\n          wobow\n            b\n               i\n                 i\n                  yeb\n                    b\n                        kecv\n                                 maqnv\n                                    n\n                                      na\n                                      n\n                                         maqnv\n                                            n\n```\nWith `15` extra characters you can produce this:\n```\nazv zul _ _ _ _ wobow i _ i yeb _ _ _ kecv _ _ _ _ _ maqnv na _ maqnv _\n```\nI don't see how it would be possible with `14` extra characters.  \nDid you maybe forget the `'f'` at the end?"
                    },
                    {
                        "username": "Yusif10",
                        "content": "Which is the unused character"
                    },
                    {
                        "username": "nikhilvashisht50",
                        "content": "yaar fir wohi dp"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "When you want to **practice + showoff** ability to handle complexity: Use Trie in Such question\nWhen in an **interview**: Use Hash Table, takes much less time and has neater code"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "2028 testcases. hahaha, go touch some grass, then get a life. \n\nTypical those who are always ready to stay in the office upto next day, cuz they don't have any hobbies. \n\nStaying in the office to write 2028 testcases for leetcode.  The badge 'Stapler of the month' is unlocked. jajajaja"
                    },
                    {
                        "username": "maheshsvm",
                        "content": "A small trick can solve the entire question."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Used this type of code but facing so many testcase error anyone can help me??\\n\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dict) {\\n        auto compareByLength = [](const string& a, const string& b) {\\n        return a.size() > b.size();\\n    };\\n    \\n    sort(dict.begin(), dict.end(), compareByLength);\\n\\n\\n        for(int i=0;i<dict.size();i++)\\n        {\\n            int a=dict[i].size();\\n            size_t index=s.find(dict[i]);\\n             if (index != string::npos) {\\n               {s.erase(index,a);\\n               i=-1;\\n               }\\n    }\\n\\n        }\\n        \\n\\n        return s.size();\\n    }\\n};"
                    },
                    {
                        "username": "0x34c",
                        "content": "cause this is not a greedy problem. You can\\'t just pick the shortest one. Consider this case:\\n\\ns = \"leetscoders\", dictionary = [\"leet\",\"code\",\"leetscode\"]\\n\\nHere, the solution is obviously 2 (leetscode is in dictionary and rs is added). However, your solution would output 3 (leet + s + code + rs)."
                    }
                ]
            },
            {
                "id": 2040373,
                "content": [
                    {
                        "username": "Dalt0nik",
                        "content": "Is it normal for a program to suddenly fail a test #2000+ ? Failed with Output `6`, expected `5`  on  `\"metzeaencgpgvsckjrqafkxgyzbe\"`  `[\"zdzz\",\"lgrhy\",\"r\",\"ohk\",\"zkowk\",\"g\",\"zqpn\",\"anoni\",\"ka\",\"qafkx\",\"t\",\"jr\",\"xdye\",\"mppc\",\"bqqb\",\"encgp\",\"yf\",\"vl\",\"ctsxk\",\"gn\",\"cujh\",\"ce\",\"rwrpq\",\"tze\",\"zxhg\",\"yzbe\",\"c\",\"o\",\"hnk\",\"gv\",\"uzbc\",\"xn\",\"kk\",\"ujjd\",\"vv\",\"mxhmv\",\"ugn\",\"at\",\"kumr\",\"ensv\",\"x\",\"uy\",\"gb\",\"ae\",\"jljuo\",\"xqkgj\"]`"
                    },
                    {
                        "username": "Dalt0nik",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Yes, thank you for a detailed answer. My mistake was me not considering the fact, that the biggest suitable substring in a dictionary is not always the best fit."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I'd guess you didn't cover some special case, or that the previous 1999 test cases were too similar.  \nFor this particular test case, here are the words of the `dictionary` as they appear in `s`:\n```\nmetzeaencgpgvsckjrqafkxgyzbe\n  tze\n  t\n     ae\n      encgp\n        c\n         g\n           g\n           gv\n              c\n                jr\n                 r\n                  qafkx\n                      x\n                       g\n                        yzbe\n```\nWith `5` extra characters you can build `s` like this:\n```\n1 2 tze 3 encgp gv 4 c 5 jr qafkx g yzbe\n```"
                    },
                    {
                        "username": "algoacer",
                        "content": "**Solve each question thinking independently**. \\n\\nI have solved Word Break-139 and tried this after checking that first. \\nResult: I couldn\\'t do this myself.\\n\\nThen thought of it as a new question, referred the solution and it was straight forward. \\n**Past experience sometimes misleads, past concepts never.**"
                    },
                    {
                        "username": "Selithrarion",
                        "content": "699th \\uD83D\\uDE33\\uD83D\\uDE33\\uD83D\\uDE33\\uD83D\\uDE33"
                    },
                    {
                        "username": "engixLC",
                        "content": "Failing test case 1991 / 2028 :\\ns = \"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\n\\ndictionary = [\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"]\\n\\nGetting output as 14 vs expected 15; is my code better than what it expects. Lol"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\n```\nazvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\nazv\n   zul\n    u\n          wobow\n            b\n               i\n                 i\n                  yeb\n                    b\n                        kecv\n                                 maqnv\n                                    n\n                                      na\n                                      n\n                                         maqnv\n                                            n\n```\nWith `15` extra characters you can produce this:\n```\nazv zul _ _ _ _ wobow i _ i yeb _ _ _ kecv _ _ _ _ _ maqnv na _ maqnv _\n```\nI don't see how it would be possible with `14` extra characters.  \nDid you maybe forget the `'f'` at the end?"
                    },
                    {
                        "username": "Yusif10",
                        "content": "Which is the unused character"
                    },
                    {
                        "username": "nikhilvashisht50",
                        "content": "yaar fir wohi dp"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "When you want to **practice + showoff** ability to handle complexity: Use Trie in Such question\nWhen in an **interview**: Use Hash Table, takes much less time and has neater code"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "2028 testcases. hahaha, go touch some grass, then get a life. \n\nTypical those who are always ready to stay in the office upto next day, cuz they don't have any hobbies. \n\nStaying in the office to write 2028 testcases for leetcode.  The badge 'Stapler of the month' is unlocked. jajajaja"
                    },
                    {
                        "username": "maheshsvm",
                        "content": "A small trick can solve the entire question."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Used this type of code but facing so many testcase error anyone can help me??\\n\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dict) {\\n        auto compareByLength = [](const string& a, const string& b) {\\n        return a.size() > b.size();\\n    };\\n    \\n    sort(dict.begin(), dict.end(), compareByLength);\\n\\n\\n        for(int i=0;i<dict.size();i++)\\n        {\\n            int a=dict[i].size();\\n            size_t index=s.find(dict[i]);\\n             if (index != string::npos) {\\n               {s.erase(index,a);\\n               i=-1;\\n               }\\n    }\\n\\n        }\\n        \\n\\n        return s.size();\\n    }\\n};"
                    },
                    {
                        "username": "0x34c",
                        "content": "cause this is not a greedy problem. You can\\'t just pick the shortest one. Consider this case:\\n\\ns = \"leetscoders\", dictionary = [\"leet\",\"code\",\"leetscode\"]\\n\\nHere, the solution is obviously 2 (leetscode is in dictionary and rs is added). However, your solution would output 3 (leet + s + code + rs)."
                    }
                ]
            },
            {
                "id": 2040360,
                "content": [
                    {
                        "username": "Dalt0nik",
                        "content": "Is it normal for a program to suddenly fail a test #2000+ ? Failed with Output `6`, expected `5`  on  `\"metzeaencgpgvsckjrqafkxgyzbe\"`  `[\"zdzz\",\"lgrhy\",\"r\",\"ohk\",\"zkowk\",\"g\",\"zqpn\",\"anoni\",\"ka\",\"qafkx\",\"t\",\"jr\",\"xdye\",\"mppc\",\"bqqb\",\"encgp\",\"yf\",\"vl\",\"ctsxk\",\"gn\",\"cujh\",\"ce\",\"rwrpq\",\"tze\",\"zxhg\",\"yzbe\",\"c\",\"o\",\"hnk\",\"gv\",\"uzbc\",\"xn\",\"kk\",\"ujjd\",\"vv\",\"mxhmv\",\"ugn\",\"at\",\"kumr\",\"ensv\",\"x\",\"uy\",\"gb\",\"ae\",\"jljuo\",\"xqkgj\"]`"
                    },
                    {
                        "username": "Dalt0nik",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Yes, thank you for a detailed answer. My mistake was me not considering the fact, that the biggest suitable substring in a dictionary is not always the best fit."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I'd guess you didn't cover some special case, or that the previous 1999 test cases were too similar.  \nFor this particular test case, here are the words of the `dictionary` as they appear in `s`:\n```\nmetzeaencgpgvsckjrqafkxgyzbe\n  tze\n  t\n     ae\n      encgp\n        c\n         g\n           g\n           gv\n              c\n                jr\n                 r\n                  qafkx\n                      x\n                       g\n                        yzbe\n```\nWith `5` extra characters you can build `s` like this:\n```\n1 2 tze 3 encgp gv 4 c 5 jr qafkx g yzbe\n```"
                    },
                    {
                        "username": "algoacer",
                        "content": "**Solve each question thinking independently**. \\n\\nI have solved Word Break-139 and tried this after checking that first. \\nResult: I couldn\\'t do this myself.\\n\\nThen thought of it as a new question, referred the solution and it was straight forward. \\n**Past experience sometimes misleads, past concepts never.**"
                    },
                    {
                        "username": "Selithrarion",
                        "content": "699th \\uD83D\\uDE33\\uD83D\\uDE33\\uD83D\\uDE33\\uD83D\\uDE33"
                    },
                    {
                        "username": "engixLC",
                        "content": "Failing test case 1991 / 2028 :\\ns = \"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\n\\ndictionary = [\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"]\\n\\nGetting output as 14 vs expected 15; is my code better than what it expects. Lol"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Here are the words of the `dictionary` as they appear in `s`:\n```\nazvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\nazv\n   zul\n    u\n          wobow\n            b\n               i\n                 i\n                  yeb\n                    b\n                        kecv\n                                 maqnv\n                                    n\n                                      na\n                                      n\n                                         maqnv\n                                            n\n```\nWith `15` extra characters you can produce this:\n```\nazv zul _ _ _ _ wobow i _ i yeb _ _ _ kecv _ _ _ _ _ maqnv na _ maqnv _\n```\nI don't see how it would be possible with `14` extra characters.  \nDid you maybe forget the `'f'` at the end?"
                    },
                    {
                        "username": "Yusif10",
                        "content": "Which is the unused character"
                    },
                    {
                        "username": "nikhilvashisht50",
                        "content": "yaar fir wohi dp"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "When you want to **practice + showoff** ability to handle complexity: Use Trie in Such question\nWhen in an **interview**: Use Hash Table, takes much less time and has neater code"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "2028 testcases. hahaha, go touch some grass, then get a life. \n\nTypical those who are always ready to stay in the office upto next day, cuz they don't have any hobbies. \n\nStaying in the office to write 2028 testcases for leetcode.  The badge 'Stapler of the month' is unlocked. jajajaja"
                    },
                    {
                        "username": "maheshsvm",
                        "content": "A small trick can solve the entire question."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Used this type of code but facing so many testcase error anyone can help me??\\n\\nclass Solution {\\npublic:\\n    int minExtraChar(string s, vector<string>& dict) {\\n        auto compareByLength = [](const string& a, const string& b) {\\n        return a.size() > b.size();\\n    };\\n    \\n    sort(dict.begin(), dict.end(), compareByLength);\\n\\n\\n        for(int i=0;i<dict.size();i++)\\n        {\\n            int a=dict[i].size();\\n            size_t index=s.find(dict[i]);\\n             if (index != string::npos) {\\n               {s.erase(index,a);\\n               i=-1;\\n               }\\n    }\\n\\n        }\\n        \\n\\n        return s.size();\\n    }\\n};"
                    },
                    {
                        "username": "0x34c",
                        "content": "cause this is not a greedy problem. You can\\'t just pick the shortest one. Consider this case:\\n\\ns = \"leetscoders\", dictionary = [\"leet\",\"code\",\"leetscode\"]\\n\\nHere, the solution is obviously 2 (leetscode is in dictionary and rs is added). However, your solution would output 3 (leet + s + code + rs)."
                    }
                ]
            },
            {
                "id": 2040353,
                "content": [
                    {
                        "username": "Noobcoooooder",
                        "content": "If You Know Dp everything Seems Ezyyy"
                    },
                    {
                        "username": "nt34542",
                        "content": "Le Average Leetcode  User : This description sucks"
                    },
                    {
                        "username": "supperr-coder",
                        "content": "For one of the test case i got an output which is SMALLER than the expected output. \nHow my algorithm does it is that ill sort the dictionary in descending order of the length of its element first, \nthen for every elements in the dictionary, ill go through the string s by an increment of 1 to check whether any of the substring of s matches to that element in the dictionary. \nIf it does, ill remove that substring and continue to search for the match until the new length of s is reaches. \nThis process is repeated until all elements in dictionary has been searched through \nand I return the final length of s. \nI manage to get 1990 / 2028 testcases passed but was stuck with this particular testcase: \ns = \"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\ndictionary = [\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"\npcmatm\",\"maqnv\"]\nmy output is: 14\nexpected output: 15\n\nWould appreciate anyone who can point out the flaw of my algorithm thank you "
                    },
                    {
                        "username": "Notsickfox",
                        "content": "replacing the matched substring with \"\" creates combinations that didnt exist before"
                    },
                    {
                        "username": "vigneshramamoorthi1",
                        "content": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass Solution {\n    int minimum=Integer.MAX_VALUE;\n    public void find(String s,List<String> dict,int i,int count,int nonMatchedCount){\n        if(nonMatchedCount>=minimum)\n            return;\n        if(i>=s.length()){\n            String m=s.substring(count,s.length());\n            int notMatched=0;\n            if(dict.indexOf(m)==-1)\n                notMatched+=m.length();\n            minimum=Math.min(minimum,nonMatchedCount+notMatched);\n            return;\n        }\n        String s1=s.substring(count,i+1);\n\n        // The substring which is not in the dictionary\n        int notMatched=0;\n        if(dict.indexOf(s1)==-1)\n            notMatched+=s1.length();\n        //Using with and without techinique\n        find(s,dict,i+1,count+s1.length(),nonMatchedCount+notMatched);\n        find(s,dict,i+1,count,nonMatchedCount);\n    }\n    public int minExtraChar(String s, String[] dictionary) {\n        List<String> dict=Arrays.asList(dictionary);\n        find(s,dict,0,0,0);\n        return minimum;\n    }\n}\n\nCan anyone please tell me how to use dynamic programming in this code?"
                    },
                    {
                        "username": "deeprai2218",
                        "content": "so many test cases more than 1k."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Now consider point of view of person who proposed this question, what would he suppose to do after knowing number of extra chars without knowing exact position of them?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "let me guess, their depression magnitude is directly proportional to returned value of solution"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Do we need to sort the dictionary of words first for better lookup time ?\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "`Update :` I rather put all those `dictionary` words in a `hash set` to improve the look up time."
                    },
                    {
                        "username": "user3954sk",
                        "content": "For 50 length and 50 words, no.  I used a Trie and it was slower than a brute force \"test every word against every substring\" approach.  There are a number of other ways to improve on \"brute force\", but with such small constraints they end up being slower...."
                    },
                    {
                        "username": "vsmore2001",
                        "content": "How can I solve this problem without using recursion?"
                    },
                    {
                        "username": "abhirajsinha",
                        "content": "Can anyone please guide me why this solution is giving wrong answer for this testcase? \n\nAs first i'm trying to solve this using brute force approach..\n\n\"dwmodizxvvbosxxw\"\n[\"ox\",\"lb\",\"diz\",\"gu\",\"v\",\"ksv\",\"o\",\"nuq\",\"r\",\"txhe\",\"e\",\"wmo\",\"cehy\",\"tskz\",\"ds\",\"kzbu\"]\n\n `class Solution {\n    public int minExtraChar(String s, String[] dictionary) {\n        int len = 0;\n        Set<String> st = new HashSet<>(Arrays.asList(dictionary));\n\n        for (int i = 0; i <= s.length(); i++) {\n            for (int j = i + 1; j <= s.length(); j++) {\n                String str = s.substring(i, j);\n\n                if (st.contains(str)) {\n                    len += str.length();\n                }\n            }\n        }\n\n        return s.length() - len;\n    }\n}`"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Consider the case \"ab\", [\"a\",\"ab\"].\\nThe string contains a - length +=1\\nThe string contains \"ab\" - length += 2 (=3)\\nYour result is therefore 2-3 = -1.\\nYou are not checking that the words are not overlapping so you will be double counting some characters"
                    },
                    {
                        "username": "aditi61",
                        "content": "class Solution {\\npublic: int minExtraChar(String s, String[] dictionary) {\\n        unordered_map<char, int> mp;\\n        for (int i = 0; i < dictionary.size(); i++) {\\n            string s1 = dictionary[i];\\n            for (int j = 0; j < s1.size(); j++) {\\n                mp[s1[j]]++;\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            if (mp.find(s[i]) == mp.end()) {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nthis code is giving error can anyone tell me what is the problem"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2040347,
                "content": [
                    {
                        "username": "Noobcoooooder",
                        "content": "If You Know Dp everything Seems Ezyyy"
                    },
                    {
                        "username": "nt34542",
                        "content": "Le Average Leetcode  User : This description sucks"
                    },
                    {
                        "username": "supperr-coder",
                        "content": "For one of the test case i got an output which is SMALLER than the expected output. \nHow my algorithm does it is that ill sort the dictionary in descending order of the length of its element first, \nthen for every elements in the dictionary, ill go through the string s by an increment of 1 to check whether any of the substring of s matches to that element in the dictionary. \nIf it does, ill remove that substring and continue to search for the match until the new length of s is reaches. \nThis process is repeated until all elements in dictionary has been searched through \nand I return the final length of s. \nI manage to get 1990 / 2028 testcases passed but was stuck with this particular testcase: \ns = \"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\ndictionary = [\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"\npcmatm\",\"maqnv\"]\nmy output is: 14\nexpected output: 15\n\nWould appreciate anyone who can point out the flaw of my algorithm thank you "
                    },
                    {
                        "username": "Notsickfox",
                        "content": "replacing the matched substring with \"\" creates combinations that didnt exist before"
                    },
                    {
                        "username": "vigneshramamoorthi1",
                        "content": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass Solution {\n    int minimum=Integer.MAX_VALUE;\n    public void find(String s,List<String> dict,int i,int count,int nonMatchedCount){\n        if(nonMatchedCount>=minimum)\n            return;\n        if(i>=s.length()){\n            String m=s.substring(count,s.length());\n            int notMatched=0;\n            if(dict.indexOf(m)==-1)\n                notMatched+=m.length();\n            minimum=Math.min(minimum,nonMatchedCount+notMatched);\n            return;\n        }\n        String s1=s.substring(count,i+1);\n\n        // The substring which is not in the dictionary\n        int notMatched=0;\n        if(dict.indexOf(s1)==-1)\n            notMatched+=s1.length();\n        //Using with and without techinique\n        find(s,dict,i+1,count+s1.length(),nonMatchedCount+notMatched);\n        find(s,dict,i+1,count,nonMatchedCount);\n    }\n    public int minExtraChar(String s, String[] dictionary) {\n        List<String> dict=Arrays.asList(dictionary);\n        find(s,dict,0,0,0);\n        return minimum;\n    }\n}\n\nCan anyone please tell me how to use dynamic programming in this code?"
                    },
                    {
                        "username": "deeprai2218",
                        "content": "so many test cases more than 1k."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Now consider point of view of person who proposed this question, what would he suppose to do after knowing number of extra chars without knowing exact position of them?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "let me guess, their depression magnitude is directly proportional to returned value of solution"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Do we need to sort the dictionary of words first for better lookup time ?\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "`Update :` I rather put all those `dictionary` words in a `hash set` to improve the look up time."
                    },
                    {
                        "username": "user3954sk",
                        "content": "For 50 length and 50 words, no.  I used a Trie and it was slower than a brute force \"test every word against every substring\" approach.  There are a number of other ways to improve on \"brute force\", but with such small constraints they end up being slower...."
                    },
                    {
                        "username": "vsmore2001",
                        "content": "How can I solve this problem without using recursion?"
                    },
                    {
                        "username": "abhirajsinha",
                        "content": "Can anyone please guide me why this solution is giving wrong answer for this testcase? \n\nAs first i'm trying to solve this using brute force approach..\n\n\"dwmodizxvvbosxxw\"\n[\"ox\",\"lb\",\"diz\",\"gu\",\"v\",\"ksv\",\"o\",\"nuq\",\"r\",\"txhe\",\"e\",\"wmo\",\"cehy\",\"tskz\",\"ds\",\"kzbu\"]\n\n `class Solution {\n    public int minExtraChar(String s, String[] dictionary) {\n        int len = 0;\n        Set<String> st = new HashSet<>(Arrays.asList(dictionary));\n\n        for (int i = 0; i <= s.length(); i++) {\n            for (int j = i + 1; j <= s.length(); j++) {\n                String str = s.substring(i, j);\n\n                if (st.contains(str)) {\n                    len += str.length();\n                }\n            }\n        }\n\n        return s.length() - len;\n    }\n}`"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Consider the case \"ab\", [\"a\",\"ab\"].\\nThe string contains a - length +=1\\nThe string contains \"ab\" - length += 2 (=3)\\nYour result is therefore 2-3 = -1.\\nYou are not checking that the words are not overlapping so you will be double counting some characters"
                    },
                    {
                        "username": "aditi61",
                        "content": "class Solution {\\npublic: int minExtraChar(String s, String[] dictionary) {\\n        unordered_map<char, int> mp;\\n        for (int i = 0; i < dictionary.size(); i++) {\\n            string s1 = dictionary[i];\\n            for (int j = 0; j < s1.size(); j++) {\\n                mp[s1[j]]++;\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            if (mp.find(s[i]) == mp.end()) {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nthis code is giving error can anyone tell me what is the problem"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2040343,
                "content": [
                    {
                        "username": "Noobcoooooder",
                        "content": "If You Know Dp everything Seems Ezyyy"
                    },
                    {
                        "username": "nt34542",
                        "content": "Le Average Leetcode  User : This description sucks"
                    },
                    {
                        "username": "supperr-coder",
                        "content": "For one of the test case i got an output which is SMALLER than the expected output. \nHow my algorithm does it is that ill sort the dictionary in descending order of the length of its element first, \nthen for every elements in the dictionary, ill go through the string s by an increment of 1 to check whether any of the substring of s matches to that element in the dictionary. \nIf it does, ill remove that substring and continue to search for the match until the new length of s is reaches. \nThis process is repeated until all elements in dictionary has been searched through \nand I return the final length of s. \nI manage to get 1990 / 2028 testcases passed but was stuck with this particular testcase: \ns = \"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\ndictionary = [\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"\npcmatm\",\"maqnv\"]\nmy output is: 14\nexpected output: 15\n\nWould appreciate anyone who can point out the flaw of my algorithm thank you "
                    },
                    {
                        "username": "Notsickfox",
                        "content": "replacing the matched substring with \"\" creates combinations that didnt exist before"
                    },
                    {
                        "username": "vigneshramamoorthi1",
                        "content": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass Solution {\n    int minimum=Integer.MAX_VALUE;\n    public void find(String s,List<String> dict,int i,int count,int nonMatchedCount){\n        if(nonMatchedCount>=minimum)\n            return;\n        if(i>=s.length()){\n            String m=s.substring(count,s.length());\n            int notMatched=0;\n            if(dict.indexOf(m)==-1)\n                notMatched+=m.length();\n            minimum=Math.min(minimum,nonMatchedCount+notMatched);\n            return;\n        }\n        String s1=s.substring(count,i+1);\n\n        // The substring which is not in the dictionary\n        int notMatched=0;\n        if(dict.indexOf(s1)==-1)\n            notMatched+=s1.length();\n        //Using with and without techinique\n        find(s,dict,i+1,count+s1.length(),nonMatchedCount+notMatched);\n        find(s,dict,i+1,count,nonMatchedCount);\n    }\n    public int minExtraChar(String s, String[] dictionary) {\n        List<String> dict=Arrays.asList(dictionary);\n        find(s,dict,0,0,0);\n        return minimum;\n    }\n}\n\nCan anyone please tell me how to use dynamic programming in this code?"
                    },
                    {
                        "username": "deeprai2218",
                        "content": "so many test cases more than 1k."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Now consider point of view of person who proposed this question, what would he suppose to do after knowing number of extra chars without knowing exact position of them?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "let me guess, their depression magnitude is directly proportional to returned value of solution"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Do we need to sort the dictionary of words first for better lookup time ?\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "`Update :` I rather put all those `dictionary` words in a `hash set` to improve the look up time."
                    },
                    {
                        "username": "user3954sk",
                        "content": "For 50 length and 50 words, no.  I used a Trie and it was slower than a brute force \"test every word against every substring\" approach.  There are a number of other ways to improve on \"brute force\", but with such small constraints they end up being slower...."
                    },
                    {
                        "username": "vsmore2001",
                        "content": "How can I solve this problem without using recursion?"
                    },
                    {
                        "username": "abhirajsinha",
                        "content": "Can anyone please guide me why this solution is giving wrong answer for this testcase? \n\nAs first i'm trying to solve this using brute force approach..\n\n\"dwmodizxvvbosxxw\"\n[\"ox\",\"lb\",\"diz\",\"gu\",\"v\",\"ksv\",\"o\",\"nuq\",\"r\",\"txhe\",\"e\",\"wmo\",\"cehy\",\"tskz\",\"ds\",\"kzbu\"]\n\n `class Solution {\n    public int minExtraChar(String s, String[] dictionary) {\n        int len = 0;\n        Set<String> st = new HashSet<>(Arrays.asList(dictionary));\n\n        for (int i = 0; i <= s.length(); i++) {\n            for (int j = i + 1; j <= s.length(); j++) {\n                String str = s.substring(i, j);\n\n                if (st.contains(str)) {\n                    len += str.length();\n                }\n            }\n        }\n\n        return s.length() - len;\n    }\n}`"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Consider the case \"ab\", [\"a\",\"ab\"].\\nThe string contains a - length +=1\\nThe string contains \"ab\" - length += 2 (=3)\\nYour result is therefore 2-3 = -1.\\nYou are not checking that the words are not overlapping so you will be double counting some characters"
                    },
                    {
                        "username": "aditi61",
                        "content": "class Solution {\\npublic: int minExtraChar(String s, String[] dictionary) {\\n        unordered_map<char, int> mp;\\n        for (int i = 0; i < dictionary.size(); i++) {\\n            string s1 = dictionary[i];\\n            for (int j = 0; j < s1.size(); j++) {\\n                mp[s1[j]]++;\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            if (mp.find(s[i]) == mp.end()) {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nthis code is giving error can anyone tell me what is the problem"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2040326,
                "content": [
                    {
                        "username": "Noobcoooooder",
                        "content": "If You Know Dp everything Seems Ezyyy"
                    },
                    {
                        "username": "nt34542",
                        "content": "Le Average Leetcode  User : This description sucks"
                    },
                    {
                        "username": "supperr-coder",
                        "content": "For one of the test case i got an output which is SMALLER than the expected output. \nHow my algorithm does it is that ill sort the dictionary in descending order of the length of its element first, \nthen for every elements in the dictionary, ill go through the string s by an increment of 1 to check whether any of the substring of s matches to that element in the dictionary. \nIf it does, ill remove that substring and continue to search for the match until the new length of s is reaches. \nThis process is repeated until all elements in dictionary has been searched through \nand I return the final length of s. \nI manage to get 1990 / 2028 testcases passed but was stuck with this particular testcase: \ns = \"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\ndictionary = [\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"\npcmatm\",\"maqnv\"]\nmy output is: 14\nexpected output: 15\n\nWould appreciate anyone who can point out the flaw of my algorithm thank you "
                    },
                    {
                        "username": "Notsickfox",
                        "content": "replacing the matched substring with \"\" creates combinations that didnt exist before"
                    },
                    {
                        "username": "vigneshramamoorthi1",
                        "content": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass Solution {\n    int minimum=Integer.MAX_VALUE;\n    public void find(String s,List<String> dict,int i,int count,int nonMatchedCount){\n        if(nonMatchedCount>=minimum)\n            return;\n        if(i>=s.length()){\n            String m=s.substring(count,s.length());\n            int notMatched=0;\n            if(dict.indexOf(m)==-1)\n                notMatched+=m.length();\n            minimum=Math.min(minimum,nonMatchedCount+notMatched);\n            return;\n        }\n        String s1=s.substring(count,i+1);\n\n        // The substring which is not in the dictionary\n        int notMatched=0;\n        if(dict.indexOf(s1)==-1)\n            notMatched+=s1.length();\n        //Using with and without techinique\n        find(s,dict,i+1,count+s1.length(),nonMatchedCount+notMatched);\n        find(s,dict,i+1,count,nonMatchedCount);\n    }\n    public int minExtraChar(String s, String[] dictionary) {\n        List<String> dict=Arrays.asList(dictionary);\n        find(s,dict,0,0,0);\n        return minimum;\n    }\n}\n\nCan anyone please tell me how to use dynamic programming in this code?"
                    },
                    {
                        "username": "deeprai2218",
                        "content": "so many test cases more than 1k."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Now consider point of view of person who proposed this question, what would he suppose to do after knowing number of extra chars without knowing exact position of them?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "let me guess, their depression magnitude is directly proportional to returned value of solution"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Do we need to sort the dictionary of words first for better lookup time ?\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "`Update :` I rather put all those `dictionary` words in a `hash set` to improve the look up time."
                    },
                    {
                        "username": "user3954sk",
                        "content": "For 50 length and 50 words, no.  I used a Trie and it was slower than a brute force \"test every word against every substring\" approach.  There are a number of other ways to improve on \"brute force\", but with such small constraints they end up being slower...."
                    },
                    {
                        "username": "vsmore2001",
                        "content": "How can I solve this problem without using recursion?"
                    },
                    {
                        "username": "abhirajsinha",
                        "content": "Can anyone please guide me why this solution is giving wrong answer for this testcase? \n\nAs first i'm trying to solve this using brute force approach..\n\n\"dwmodizxvvbosxxw\"\n[\"ox\",\"lb\",\"diz\",\"gu\",\"v\",\"ksv\",\"o\",\"nuq\",\"r\",\"txhe\",\"e\",\"wmo\",\"cehy\",\"tskz\",\"ds\",\"kzbu\"]\n\n `class Solution {\n    public int minExtraChar(String s, String[] dictionary) {\n        int len = 0;\n        Set<String> st = new HashSet<>(Arrays.asList(dictionary));\n\n        for (int i = 0; i <= s.length(); i++) {\n            for (int j = i + 1; j <= s.length(); j++) {\n                String str = s.substring(i, j);\n\n                if (st.contains(str)) {\n                    len += str.length();\n                }\n            }\n        }\n\n        return s.length() - len;\n    }\n}`"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Consider the case \"ab\", [\"a\",\"ab\"].\\nThe string contains a - length +=1\\nThe string contains \"ab\" - length += 2 (=3)\\nYour result is therefore 2-3 = -1.\\nYou are not checking that the words are not overlapping so you will be double counting some characters"
                    },
                    {
                        "username": "aditi61",
                        "content": "class Solution {\\npublic: int minExtraChar(String s, String[] dictionary) {\\n        unordered_map<char, int> mp;\\n        for (int i = 0; i < dictionary.size(); i++) {\\n            string s1 = dictionary[i];\\n            for (int j = 0; j < s1.size(); j++) {\\n                mp[s1[j]]++;\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            if (mp.find(s[i]) == mp.end()) {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nthis code is giving error can anyone tell me what is the problem"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2040278,
                "content": [
                    {
                        "username": "Noobcoooooder",
                        "content": "If You Know Dp everything Seems Ezyyy"
                    },
                    {
                        "username": "nt34542",
                        "content": "Le Average Leetcode  User : This description sucks"
                    },
                    {
                        "username": "supperr-coder",
                        "content": "For one of the test case i got an output which is SMALLER than the expected output. \nHow my algorithm does it is that ill sort the dictionary in descending order of the length of its element first, \nthen for every elements in the dictionary, ill go through the string s by an increment of 1 to check whether any of the substring of s matches to that element in the dictionary. \nIf it does, ill remove that substring and continue to search for the match until the new length of s is reaches. \nThis process is repeated until all elements in dictionary has been searched through \nand I return the final length of s. \nI manage to get 1990 / 2028 testcases passed but was stuck with this particular testcase: \ns = \"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\ndictionary = [\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"\npcmatm\",\"maqnv\"]\nmy output is: 14\nexpected output: 15\n\nWould appreciate anyone who can point out the flaw of my algorithm thank you "
                    },
                    {
                        "username": "Notsickfox",
                        "content": "replacing the matched substring with \"\" creates combinations that didnt exist before"
                    },
                    {
                        "username": "vigneshramamoorthi1",
                        "content": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass Solution {\n    int minimum=Integer.MAX_VALUE;\n    public void find(String s,List<String> dict,int i,int count,int nonMatchedCount){\n        if(nonMatchedCount>=minimum)\n            return;\n        if(i>=s.length()){\n            String m=s.substring(count,s.length());\n            int notMatched=0;\n            if(dict.indexOf(m)==-1)\n                notMatched+=m.length();\n            minimum=Math.min(minimum,nonMatchedCount+notMatched);\n            return;\n        }\n        String s1=s.substring(count,i+1);\n\n        // The substring which is not in the dictionary\n        int notMatched=0;\n        if(dict.indexOf(s1)==-1)\n            notMatched+=s1.length();\n        //Using with and without techinique\n        find(s,dict,i+1,count+s1.length(),nonMatchedCount+notMatched);\n        find(s,dict,i+1,count,nonMatchedCount);\n    }\n    public int minExtraChar(String s, String[] dictionary) {\n        List<String> dict=Arrays.asList(dictionary);\n        find(s,dict,0,0,0);\n        return minimum;\n    }\n}\n\nCan anyone please tell me how to use dynamic programming in this code?"
                    },
                    {
                        "username": "deeprai2218",
                        "content": "so many test cases more than 1k."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Now consider point of view of person who proposed this question, what would he suppose to do after knowing number of extra chars without knowing exact position of them?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "let me guess, their depression magnitude is directly proportional to returned value of solution"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Do we need to sort the dictionary of words first for better lookup time ?\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "`Update :` I rather put all those `dictionary` words in a `hash set` to improve the look up time."
                    },
                    {
                        "username": "user3954sk",
                        "content": "For 50 length and 50 words, no.  I used a Trie and it was slower than a brute force \"test every word against every substring\" approach.  There are a number of other ways to improve on \"brute force\", but with such small constraints they end up being slower...."
                    },
                    {
                        "username": "vsmore2001",
                        "content": "How can I solve this problem without using recursion?"
                    },
                    {
                        "username": "abhirajsinha",
                        "content": "Can anyone please guide me why this solution is giving wrong answer for this testcase? \n\nAs first i'm trying to solve this using brute force approach..\n\n\"dwmodizxvvbosxxw\"\n[\"ox\",\"lb\",\"diz\",\"gu\",\"v\",\"ksv\",\"o\",\"nuq\",\"r\",\"txhe\",\"e\",\"wmo\",\"cehy\",\"tskz\",\"ds\",\"kzbu\"]\n\n `class Solution {\n    public int minExtraChar(String s, String[] dictionary) {\n        int len = 0;\n        Set<String> st = new HashSet<>(Arrays.asList(dictionary));\n\n        for (int i = 0; i <= s.length(); i++) {\n            for (int j = i + 1; j <= s.length(); j++) {\n                String str = s.substring(i, j);\n\n                if (st.contains(str)) {\n                    len += str.length();\n                }\n            }\n        }\n\n        return s.length() - len;\n    }\n}`"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Consider the case \"ab\", [\"a\",\"ab\"].\\nThe string contains a - length +=1\\nThe string contains \"ab\" - length += 2 (=3)\\nYour result is therefore 2-3 = -1.\\nYou are not checking that the words are not overlapping so you will be double counting some characters"
                    },
                    {
                        "username": "aditi61",
                        "content": "class Solution {\\npublic: int minExtraChar(String s, String[] dictionary) {\\n        unordered_map<char, int> mp;\\n        for (int i = 0; i < dictionary.size(); i++) {\\n            string s1 = dictionary[i];\\n            for (int j = 0; j < s1.size(); j++) {\\n                mp[s1[j]]++;\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            if (mp.find(s[i]) == mp.end()) {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nthis code is giving error can anyone tell me what is the problem"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2040255,
                "content": [
                    {
                        "username": "Noobcoooooder",
                        "content": "If You Know Dp everything Seems Ezyyy"
                    },
                    {
                        "username": "nt34542",
                        "content": "Le Average Leetcode  User : This description sucks"
                    },
                    {
                        "username": "supperr-coder",
                        "content": "For one of the test case i got an output which is SMALLER than the expected output. \nHow my algorithm does it is that ill sort the dictionary in descending order of the length of its element first, \nthen for every elements in the dictionary, ill go through the string s by an increment of 1 to check whether any of the substring of s matches to that element in the dictionary. \nIf it does, ill remove that substring and continue to search for the match until the new length of s is reaches. \nThis process is repeated until all elements in dictionary has been searched through \nand I return the final length of s. \nI manage to get 1990 / 2028 testcases passed but was stuck with this particular testcase: \ns = \"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\ndictionary = [\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"\npcmatm\",\"maqnv\"]\nmy output is: 14\nexpected output: 15\n\nWould appreciate anyone who can point out the flaw of my algorithm thank you "
                    },
                    {
                        "username": "Notsickfox",
                        "content": "replacing the matched substring with \"\" creates combinations that didnt exist before"
                    },
                    {
                        "username": "vigneshramamoorthi1",
                        "content": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass Solution {\n    int minimum=Integer.MAX_VALUE;\n    public void find(String s,List<String> dict,int i,int count,int nonMatchedCount){\n        if(nonMatchedCount>=minimum)\n            return;\n        if(i>=s.length()){\n            String m=s.substring(count,s.length());\n            int notMatched=0;\n            if(dict.indexOf(m)==-1)\n                notMatched+=m.length();\n            minimum=Math.min(minimum,nonMatchedCount+notMatched);\n            return;\n        }\n        String s1=s.substring(count,i+1);\n\n        // The substring which is not in the dictionary\n        int notMatched=0;\n        if(dict.indexOf(s1)==-1)\n            notMatched+=s1.length();\n        //Using with and without techinique\n        find(s,dict,i+1,count+s1.length(),nonMatchedCount+notMatched);\n        find(s,dict,i+1,count,nonMatchedCount);\n    }\n    public int minExtraChar(String s, String[] dictionary) {\n        List<String> dict=Arrays.asList(dictionary);\n        find(s,dict,0,0,0);\n        return minimum;\n    }\n}\n\nCan anyone please tell me how to use dynamic programming in this code?"
                    },
                    {
                        "username": "deeprai2218",
                        "content": "so many test cases more than 1k."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Now consider point of view of person who proposed this question, what would he suppose to do after knowing number of extra chars without knowing exact position of them?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "let me guess, their depression magnitude is directly proportional to returned value of solution"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Do we need to sort the dictionary of words first for better lookup time ?\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "`Update :` I rather put all those `dictionary` words in a `hash set` to improve the look up time."
                    },
                    {
                        "username": "user3954sk",
                        "content": "For 50 length and 50 words, no.  I used a Trie and it was slower than a brute force \"test every word against every substring\" approach.  There are a number of other ways to improve on \"brute force\", but with such small constraints they end up being slower...."
                    },
                    {
                        "username": "vsmore2001",
                        "content": "How can I solve this problem without using recursion?"
                    },
                    {
                        "username": "abhirajsinha",
                        "content": "Can anyone please guide me why this solution is giving wrong answer for this testcase? \n\nAs first i'm trying to solve this using brute force approach..\n\n\"dwmodizxvvbosxxw\"\n[\"ox\",\"lb\",\"diz\",\"gu\",\"v\",\"ksv\",\"o\",\"nuq\",\"r\",\"txhe\",\"e\",\"wmo\",\"cehy\",\"tskz\",\"ds\",\"kzbu\"]\n\n `class Solution {\n    public int minExtraChar(String s, String[] dictionary) {\n        int len = 0;\n        Set<String> st = new HashSet<>(Arrays.asList(dictionary));\n\n        for (int i = 0; i <= s.length(); i++) {\n            for (int j = i + 1; j <= s.length(); j++) {\n                String str = s.substring(i, j);\n\n                if (st.contains(str)) {\n                    len += str.length();\n                }\n            }\n        }\n\n        return s.length() - len;\n    }\n}`"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Consider the case \"ab\", [\"a\",\"ab\"].\\nThe string contains a - length +=1\\nThe string contains \"ab\" - length += 2 (=3)\\nYour result is therefore 2-3 = -1.\\nYou are not checking that the words are not overlapping so you will be double counting some characters"
                    },
                    {
                        "username": "aditi61",
                        "content": "class Solution {\\npublic: int minExtraChar(String s, String[] dictionary) {\\n        unordered_map<char, int> mp;\\n        for (int i = 0; i < dictionary.size(); i++) {\\n            string s1 = dictionary[i];\\n            for (int j = 0; j < s1.size(); j++) {\\n                mp[s1[j]]++;\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            if (mp.find(s[i]) == mp.end()) {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nthis code is giving error can anyone tell me what is the problem"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2040211,
                "content": [
                    {
                        "username": "Noobcoooooder",
                        "content": "If You Know Dp everything Seems Ezyyy"
                    },
                    {
                        "username": "nt34542",
                        "content": "Le Average Leetcode  User : This description sucks"
                    },
                    {
                        "username": "supperr-coder",
                        "content": "For one of the test case i got an output which is SMALLER than the expected output. \nHow my algorithm does it is that ill sort the dictionary in descending order of the length of its element first, \nthen for every elements in the dictionary, ill go through the string s by an increment of 1 to check whether any of the substring of s matches to that element in the dictionary. \nIf it does, ill remove that substring and continue to search for the match until the new length of s is reaches. \nThis process is repeated until all elements in dictionary has been searched through \nand I return the final length of s. \nI manage to get 1990 / 2028 testcases passed but was stuck with this particular testcase: \ns = \"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\ndictionary = [\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"\npcmatm\",\"maqnv\"]\nmy output is: 14\nexpected output: 15\n\nWould appreciate anyone who can point out the flaw of my algorithm thank you "
                    },
                    {
                        "username": "Notsickfox",
                        "content": "replacing the matched substring with \"\" creates combinations that didnt exist before"
                    },
                    {
                        "username": "vigneshramamoorthi1",
                        "content": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass Solution {\n    int minimum=Integer.MAX_VALUE;\n    public void find(String s,List<String> dict,int i,int count,int nonMatchedCount){\n        if(nonMatchedCount>=minimum)\n            return;\n        if(i>=s.length()){\n            String m=s.substring(count,s.length());\n            int notMatched=0;\n            if(dict.indexOf(m)==-1)\n                notMatched+=m.length();\n            minimum=Math.min(minimum,nonMatchedCount+notMatched);\n            return;\n        }\n        String s1=s.substring(count,i+1);\n\n        // The substring which is not in the dictionary\n        int notMatched=0;\n        if(dict.indexOf(s1)==-1)\n            notMatched+=s1.length();\n        //Using with and without techinique\n        find(s,dict,i+1,count+s1.length(),nonMatchedCount+notMatched);\n        find(s,dict,i+1,count,nonMatchedCount);\n    }\n    public int minExtraChar(String s, String[] dictionary) {\n        List<String> dict=Arrays.asList(dictionary);\n        find(s,dict,0,0,0);\n        return minimum;\n    }\n}\n\nCan anyone please tell me how to use dynamic programming in this code?"
                    },
                    {
                        "username": "deeprai2218",
                        "content": "so many test cases more than 1k."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Now consider point of view of person who proposed this question, what would he suppose to do after knowing number of extra chars without knowing exact position of them?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "let me guess, their depression magnitude is directly proportional to returned value of solution"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Do we need to sort the dictionary of words first for better lookup time ?\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "`Update :` I rather put all those `dictionary` words in a `hash set` to improve the look up time."
                    },
                    {
                        "username": "user3954sk",
                        "content": "For 50 length and 50 words, no.  I used a Trie and it was slower than a brute force \"test every word against every substring\" approach.  There are a number of other ways to improve on \"brute force\", but with such small constraints they end up being slower...."
                    },
                    {
                        "username": "vsmore2001",
                        "content": "How can I solve this problem without using recursion?"
                    },
                    {
                        "username": "abhirajsinha",
                        "content": "Can anyone please guide me why this solution is giving wrong answer for this testcase? \n\nAs first i'm trying to solve this using brute force approach..\n\n\"dwmodizxvvbosxxw\"\n[\"ox\",\"lb\",\"diz\",\"gu\",\"v\",\"ksv\",\"o\",\"nuq\",\"r\",\"txhe\",\"e\",\"wmo\",\"cehy\",\"tskz\",\"ds\",\"kzbu\"]\n\n `class Solution {\n    public int minExtraChar(String s, String[] dictionary) {\n        int len = 0;\n        Set<String> st = new HashSet<>(Arrays.asList(dictionary));\n\n        for (int i = 0; i <= s.length(); i++) {\n            for (int j = i + 1; j <= s.length(); j++) {\n                String str = s.substring(i, j);\n\n                if (st.contains(str)) {\n                    len += str.length();\n                }\n            }\n        }\n\n        return s.length() - len;\n    }\n}`"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Consider the case \"ab\", [\"a\",\"ab\"].\\nThe string contains a - length +=1\\nThe string contains \"ab\" - length += 2 (=3)\\nYour result is therefore 2-3 = -1.\\nYou are not checking that the words are not overlapping so you will be double counting some characters"
                    },
                    {
                        "username": "aditi61",
                        "content": "class Solution {\\npublic: int minExtraChar(String s, String[] dictionary) {\\n        unordered_map<char, int> mp;\\n        for (int i = 0; i < dictionary.size(); i++) {\\n            string s1 = dictionary[i];\\n            for (int j = 0; j < s1.size(); j++) {\\n                mp[s1[j]]++;\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            if (mp.find(s[i]) == mp.end()) {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nthis code is giving error can anyone tell me what is the problem"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2040198,
                "content": [
                    {
                        "username": "Noobcoooooder",
                        "content": "If You Know Dp everything Seems Ezyyy"
                    },
                    {
                        "username": "nt34542",
                        "content": "Le Average Leetcode  User : This description sucks"
                    },
                    {
                        "username": "supperr-coder",
                        "content": "For one of the test case i got an output which is SMALLER than the expected output. \nHow my algorithm does it is that ill sort the dictionary in descending order of the length of its element first, \nthen for every elements in the dictionary, ill go through the string s by an increment of 1 to check whether any of the substring of s matches to that element in the dictionary. \nIf it does, ill remove that substring and continue to search for the match until the new length of s is reaches. \nThis process is repeated until all elements in dictionary has been searched through \nand I return the final length of s. \nI manage to get 1990 / 2028 testcases passed but was stuck with this particular testcase: \ns = \"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\ndictionary = [\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"\npcmatm\",\"maqnv\"]\nmy output is: 14\nexpected output: 15\n\nWould appreciate anyone who can point out the flaw of my algorithm thank you "
                    },
                    {
                        "username": "Notsickfox",
                        "content": "replacing the matched substring with \"\" creates combinations that didnt exist before"
                    },
                    {
                        "username": "vigneshramamoorthi1",
                        "content": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass Solution {\n    int minimum=Integer.MAX_VALUE;\n    public void find(String s,List<String> dict,int i,int count,int nonMatchedCount){\n        if(nonMatchedCount>=minimum)\n            return;\n        if(i>=s.length()){\n            String m=s.substring(count,s.length());\n            int notMatched=0;\n            if(dict.indexOf(m)==-1)\n                notMatched+=m.length();\n            minimum=Math.min(minimum,nonMatchedCount+notMatched);\n            return;\n        }\n        String s1=s.substring(count,i+1);\n\n        // The substring which is not in the dictionary\n        int notMatched=0;\n        if(dict.indexOf(s1)==-1)\n            notMatched+=s1.length();\n        //Using with and without techinique\n        find(s,dict,i+1,count+s1.length(),nonMatchedCount+notMatched);\n        find(s,dict,i+1,count,nonMatchedCount);\n    }\n    public int minExtraChar(String s, String[] dictionary) {\n        List<String> dict=Arrays.asList(dictionary);\n        find(s,dict,0,0,0);\n        return minimum;\n    }\n}\n\nCan anyone please tell me how to use dynamic programming in this code?"
                    },
                    {
                        "username": "deeprai2218",
                        "content": "so many test cases more than 1k."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Now consider point of view of person who proposed this question, what would he suppose to do after knowing number of extra chars without knowing exact position of them?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "let me guess, their depression magnitude is directly proportional to returned value of solution"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Do we need to sort the dictionary of words first for better lookup time ?\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "`Update :` I rather put all those `dictionary` words in a `hash set` to improve the look up time."
                    },
                    {
                        "username": "user3954sk",
                        "content": "For 50 length and 50 words, no.  I used a Trie and it was slower than a brute force \"test every word against every substring\" approach.  There are a number of other ways to improve on \"brute force\", but with such small constraints they end up being slower...."
                    },
                    {
                        "username": "vsmore2001",
                        "content": "How can I solve this problem without using recursion?"
                    },
                    {
                        "username": "abhirajsinha",
                        "content": "Can anyone please guide me why this solution is giving wrong answer for this testcase? \n\nAs first i'm trying to solve this using brute force approach..\n\n\"dwmodizxvvbosxxw\"\n[\"ox\",\"lb\",\"diz\",\"gu\",\"v\",\"ksv\",\"o\",\"nuq\",\"r\",\"txhe\",\"e\",\"wmo\",\"cehy\",\"tskz\",\"ds\",\"kzbu\"]\n\n `class Solution {\n    public int minExtraChar(String s, String[] dictionary) {\n        int len = 0;\n        Set<String> st = new HashSet<>(Arrays.asList(dictionary));\n\n        for (int i = 0; i <= s.length(); i++) {\n            for (int j = i + 1; j <= s.length(); j++) {\n                String str = s.substring(i, j);\n\n                if (st.contains(str)) {\n                    len += str.length();\n                }\n            }\n        }\n\n        return s.length() - len;\n    }\n}`"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Consider the case \"ab\", [\"a\",\"ab\"].\\nThe string contains a - length +=1\\nThe string contains \"ab\" - length += 2 (=3)\\nYour result is therefore 2-3 = -1.\\nYou are not checking that the words are not overlapping so you will be double counting some characters"
                    },
                    {
                        "username": "aditi61",
                        "content": "class Solution {\\npublic: int minExtraChar(String s, String[] dictionary) {\\n        unordered_map<char, int> mp;\\n        for (int i = 0; i < dictionary.size(); i++) {\\n            string s1 = dictionary[i];\\n            for (int j = 0; j < s1.size(); j++) {\\n                mp[s1[j]]++;\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            if (mp.find(s[i]) == mp.end()) {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nthis code is giving error can anyone tell me what is the problem"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2040179,
                "content": [
                    {
                        "username": "Noobcoooooder",
                        "content": "If You Know Dp everything Seems Ezyyy"
                    },
                    {
                        "username": "nt34542",
                        "content": "Le Average Leetcode  User : This description sucks"
                    },
                    {
                        "username": "supperr-coder",
                        "content": "For one of the test case i got an output which is SMALLER than the expected output. \nHow my algorithm does it is that ill sort the dictionary in descending order of the length of its element first, \nthen for every elements in the dictionary, ill go through the string s by an increment of 1 to check whether any of the substring of s matches to that element in the dictionary. \nIf it does, ill remove that substring and continue to search for the match until the new length of s is reaches. \nThis process is repeated until all elements in dictionary has been searched through \nand I return the final length of s. \nI manage to get 1990 / 2028 testcases passed but was stuck with this particular testcase: \ns = \"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\ndictionary = [\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"\npcmatm\",\"maqnv\"]\nmy output is: 14\nexpected output: 15\n\nWould appreciate anyone who can point out the flaw of my algorithm thank you "
                    },
                    {
                        "username": "Notsickfox",
                        "content": "replacing the matched substring with \"\" creates combinations that didnt exist before"
                    },
                    {
                        "username": "vigneshramamoorthi1",
                        "content": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass Solution {\n    int minimum=Integer.MAX_VALUE;\n    public void find(String s,List<String> dict,int i,int count,int nonMatchedCount){\n        if(nonMatchedCount>=minimum)\n            return;\n        if(i>=s.length()){\n            String m=s.substring(count,s.length());\n            int notMatched=0;\n            if(dict.indexOf(m)==-1)\n                notMatched+=m.length();\n            minimum=Math.min(minimum,nonMatchedCount+notMatched);\n            return;\n        }\n        String s1=s.substring(count,i+1);\n\n        // The substring which is not in the dictionary\n        int notMatched=0;\n        if(dict.indexOf(s1)==-1)\n            notMatched+=s1.length();\n        //Using with and without techinique\n        find(s,dict,i+1,count+s1.length(),nonMatchedCount+notMatched);\n        find(s,dict,i+1,count,nonMatchedCount);\n    }\n    public int minExtraChar(String s, String[] dictionary) {\n        List<String> dict=Arrays.asList(dictionary);\n        find(s,dict,0,0,0);\n        return minimum;\n    }\n}\n\nCan anyone please tell me how to use dynamic programming in this code?"
                    },
                    {
                        "username": "deeprai2218",
                        "content": "so many test cases more than 1k."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Now consider point of view of person who proposed this question, what would he suppose to do after knowing number of extra chars without knowing exact position of them?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "let me guess, their depression magnitude is directly proportional to returned value of solution"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Do we need to sort the dictionary of words first for better lookup time ?\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "`Update :` I rather put all those `dictionary` words in a `hash set` to improve the look up time."
                    },
                    {
                        "username": "user3954sk",
                        "content": "For 50 length and 50 words, no.  I used a Trie and it was slower than a brute force \"test every word against every substring\" approach.  There are a number of other ways to improve on \"brute force\", but with such small constraints they end up being slower...."
                    },
                    {
                        "username": "vsmore2001",
                        "content": "How can I solve this problem without using recursion?"
                    },
                    {
                        "username": "abhirajsinha",
                        "content": "Can anyone please guide me why this solution is giving wrong answer for this testcase? \n\nAs first i'm trying to solve this using brute force approach..\n\n\"dwmodizxvvbosxxw\"\n[\"ox\",\"lb\",\"diz\",\"gu\",\"v\",\"ksv\",\"o\",\"nuq\",\"r\",\"txhe\",\"e\",\"wmo\",\"cehy\",\"tskz\",\"ds\",\"kzbu\"]\n\n `class Solution {\n    public int minExtraChar(String s, String[] dictionary) {\n        int len = 0;\n        Set<String> st = new HashSet<>(Arrays.asList(dictionary));\n\n        for (int i = 0; i <= s.length(); i++) {\n            for (int j = i + 1; j <= s.length(); j++) {\n                String str = s.substring(i, j);\n\n                if (st.contains(str)) {\n                    len += str.length();\n                }\n            }\n        }\n\n        return s.length() - len;\n    }\n}`"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Consider the case \"ab\", [\"a\",\"ab\"].\\nThe string contains a - length +=1\\nThe string contains \"ab\" - length += 2 (=3)\\nYour result is therefore 2-3 = -1.\\nYou are not checking that the words are not overlapping so you will be double counting some characters"
                    },
                    {
                        "username": "aditi61",
                        "content": "class Solution {\\npublic: int minExtraChar(String s, String[] dictionary) {\\n        unordered_map<char, int> mp;\\n        for (int i = 0; i < dictionary.size(); i++) {\\n            string s1 = dictionary[i];\\n            for (int j = 0; j < s1.size(); j++) {\\n                mp[s1[j]]++;\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            if (mp.find(s[i]) == mp.end()) {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nthis code is giving error can anyone tell me what is the problem"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2040173,
                "content": [
                    {
                        "username": "Noobcoooooder",
                        "content": "If You Know Dp everything Seems Ezyyy"
                    },
                    {
                        "username": "nt34542",
                        "content": "Le Average Leetcode  User : This description sucks"
                    },
                    {
                        "username": "supperr-coder",
                        "content": "For one of the test case i got an output which is SMALLER than the expected output. \nHow my algorithm does it is that ill sort the dictionary in descending order of the length of its element first, \nthen for every elements in the dictionary, ill go through the string s by an increment of 1 to check whether any of the substring of s matches to that element in the dictionary. \nIf it does, ill remove that substring and continue to search for the match until the new length of s is reaches. \nThis process is repeated until all elements in dictionary has been searched through \nand I return the final length of s. \nI manage to get 1990 / 2028 testcases passed but was stuck with this particular testcase: \ns = \"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\ndictionary = [\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"\npcmatm\",\"maqnv\"]\nmy output is: 14\nexpected output: 15\n\nWould appreciate anyone who can point out the flaw of my algorithm thank you "
                    },
                    {
                        "username": "Notsickfox",
                        "content": "replacing the matched substring with \"\" creates combinations that didnt exist before"
                    },
                    {
                        "username": "vigneshramamoorthi1",
                        "content": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass Solution {\n    int minimum=Integer.MAX_VALUE;\n    public void find(String s,List<String> dict,int i,int count,int nonMatchedCount){\n        if(nonMatchedCount>=minimum)\n            return;\n        if(i>=s.length()){\n            String m=s.substring(count,s.length());\n            int notMatched=0;\n            if(dict.indexOf(m)==-1)\n                notMatched+=m.length();\n            minimum=Math.min(minimum,nonMatchedCount+notMatched);\n            return;\n        }\n        String s1=s.substring(count,i+1);\n\n        // The substring which is not in the dictionary\n        int notMatched=0;\n        if(dict.indexOf(s1)==-1)\n            notMatched+=s1.length();\n        //Using with and without techinique\n        find(s,dict,i+1,count+s1.length(),nonMatchedCount+notMatched);\n        find(s,dict,i+1,count,nonMatchedCount);\n    }\n    public int minExtraChar(String s, String[] dictionary) {\n        List<String> dict=Arrays.asList(dictionary);\n        find(s,dict,0,0,0);\n        return minimum;\n    }\n}\n\nCan anyone please tell me how to use dynamic programming in this code?"
                    },
                    {
                        "username": "deeprai2218",
                        "content": "so many test cases more than 1k."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Now consider point of view of person who proposed this question, what would he suppose to do after knowing number of extra chars without knowing exact position of them?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "let me guess, their depression magnitude is directly proportional to returned value of solution"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Do we need to sort the dictionary of words first for better lookup time ?\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "`Update :` I rather put all those `dictionary` words in a `hash set` to improve the look up time."
                    },
                    {
                        "username": "user3954sk",
                        "content": "For 50 length and 50 words, no.  I used a Trie and it was slower than a brute force \"test every word against every substring\" approach.  There are a number of other ways to improve on \"brute force\", but with such small constraints they end up being slower...."
                    },
                    {
                        "username": "vsmore2001",
                        "content": "How can I solve this problem without using recursion?"
                    },
                    {
                        "username": "abhirajsinha",
                        "content": "Can anyone please guide me why this solution is giving wrong answer for this testcase? \n\nAs first i'm trying to solve this using brute force approach..\n\n\"dwmodizxvvbosxxw\"\n[\"ox\",\"lb\",\"diz\",\"gu\",\"v\",\"ksv\",\"o\",\"nuq\",\"r\",\"txhe\",\"e\",\"wmo\",\"cehy\",\"tskz\",\"ds\",\"kzbu\"]\n\n `class Solution {\n    public int minExtraChar(String s, String[] dictionary) {\n        int len = 0;\n        Set<String> st = new HashSet<>(Arrays.asList(dictionary));\n\n        for (int i = 0; i <= s.length(); i++) {\n            for (int j = i + 1; j <= s.length(); j++) {\n                String str = s.substring(i, j);\n\n                if (st.contains(str)) {\n                    len += str.length();\n                }\n            }\n        }\n\n        return s.length() - len;\n    }\n}`"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Consider the case \"ab\", [\"a\",\"ab\"].\\nThe string contains a - length +=1\\nThe string contains \"ab\" - length += 2 (=3)\\nYour result is therefore 2-3 = -1.\\nYou are not checking that the words are not overlapping so you will be double counting some characters"
                    },
                    {
                        "username": "aditi61",
                        "content": "class Solution {\\npublic: int minExtraChar(String s, String[] dictionary) {\\n        unordered_map<char, int> mp;\\n        for (int i = 0; i < dictionary.size(); i++) {\\n            string s1 = dictionary[i];\\n            for (int j = 0; j < s1.size(); j++) {\\n                mp[s1[j]]++;\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            if (mp.find(s[i]) == mp.end()) {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nthis code is giving error can anyone tell me what is the problem"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2040132,
                "content": [
                    {
                        "username": "hanse413",
                        "content": "class Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        dictionary.sort(key = lambda x:len(x),reverse = True)\\n        while True:\\n            a = False\\n            for x in dictionary:\\n                if x in s:\\n                    s=s.replace(x,\"\", 1)\\n                    a = True\\n                    break\\n            if a == False:\\n                break\\n                \\n        return len(s)\\n\\nfor testcase:\\ns =\\n\"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\ndictionary =\\n[\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"]\\nOutput\\n14\\nExpected\\n15\\n\\nI believe the answer for this testcase is wrong? I even double check using the code below help!:\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: list[str]) -> int:\\n        dictionary.sort(key = lambda x:len(x),reverse = True)\\n        print(len(s))\\n        while True:\\n            a = False\\n            for x in dictionary:\\n                if x in s:\\n                    s=s.replace(x,\"\", 1)\\n                    print(f\"removed {x} \\\\n {s}\")\\n                    print(len(s))\\n                    a = True\\n                    break\\n            if a == False:\\n                break\\n                \\n        return len(s)\\n        \\ns =\"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\ndictionary =[\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"]\\nx = Solution()\\nprint(x.minExtraChar(s,dictionary))"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dikshawali",
                        "content": "2000+ test cases :O yo kidding me"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "https://leetcode.com/problems/extra-characters-in-a-string/solutions/3990522/beats-100-with-proper-explanation-and-diagram-dp/\\nimage explanation"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[found this helpful for the question](https://leetcode.com/problems/extra-characters-in-a-string/solutions/3990522/beats-100-with-proper-explanation-and-diagram-dp/)"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "this should be marked hard(after looking at the editorial)"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "top down solution isn\\'t worth hard status"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "The total test case is 2028 right now. Unreal stuff."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Editorial was useful for this one."
                    },
                    {
                        "username": "sauravk21",
                        "content": "This is a variant of MCM question.  "
                    },
                    {
                        "username": "Prajju22",
                        "content": "try to think take and not take approach...(knapsack)"
                    },
                    {
                        "username": "Luffy2020",
                        "content": "Can any one tell why my answer is coming wrong for this testcase?\\nInput\\ns =\\n\"kevlplxozaizdhxoimmraiakbak\"\\ndictionary =\\n[\"yv\",\"bmab\",\"hv\",\"bnsll\",\"mra\",\"jjqf\",\"g\",\"aiyzi\",\"ip\",\"pfctr\",\"flr\",\"ybbcl\",\"biu\",\"ke\",\"lpl\",\"iak\",\"pirua\",\"ilhqd\",\"zdhx\",\"fux\",\"xaw\",\"pdfvt\",\"xf\",\"t\",\"wq\",\"r\",\"cgmud\",\"aokas\",\"xv\",\"jf\",\"cyys\",\"wcaz\",\"rvegf\",\"ysg\",\"xo\",\"uwb\",\"lw\",\"okgk\",\"vbmi\",\"v\",\"mvo\",\"fxyx\",\"ad\",\"e\"]\\n `class Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        \\n        Set<String> set = new HashSet<>();\\n        for(String item : dictionary){\\n            set.add(item);\\n        }\\n        \\n        int[] vis = new int[s.length()];\\n        Arrays.fill(vis,-1);\\n        \\n        for(int i=0 ;i<s.length();i++){\\n            StringBuilder str = new StringBuilder();\\n            for(int j=i; j<s.length() ; j++ ){\\n                str.append(s.charAt(j));\\n                System.out.println(str.toString());\\n                if(set.contains(str.toString())){\\n                    for(int k=i ; k<=j ;k++){\\n                        vis[k]=0;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            if(vis[i]==-1) count++;\\n        }\\n        return count; \\n        \\n    }\\n}.`"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Consider the test case\\n\"abcde\",[\"bcd\",\"ab\",\"de\"]\\nYour code will return 0 I think."
                    }
                ]
            },
            {
                "id": 2040109,
                "content": [
                    {
                        "username": "hanse413",
                        "content": "class Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        dictionary.sort(key = lambda x:len(x),reverse = True)\\n        while True:\\n            a = False\\n            for x in dictionary:\\n                if x in s:\\n                    s=s.replace(x,\"\", 1)\\n                    a = True\\n                    break\\n            if a == False:\\n                break\\n                \\n        return len(s)\\n\\nfor testcase:\\ns =\\n\"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\ndictionary =\\n[\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"]\\nOutput\\n14\\nExpected\\n15\\n\\nI believe the answer for this testcase is wrong? I even double check using the code below help!:\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: list[str]) -> int:\\n        dictionary.sort(key = lambda x:len(x),reverse = True)\\n        print(len(s))\\n        while True:\\n            a = False\\n            for x in dictionary:\\n                if x in s:\\n                    s=s.replace(x,\"\", 1)\\n                    print(f\"removed {x} \\\\n {s}\")\\n                    print(len(s))\\n                    a = True\\n                    break\\n            if a == False:\\n                break\\n                \\n        return len(s)\\n        \\ns =\"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\ndictionary =[\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"]\\nx = Solution()\\nprint(x.minExtraChar(s,dictionary))"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dikshawali",
                        "content": "2000+ test cases :O yo kidding me"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "https://leetcode.com/problems/extra-characters-in-a-string/solutions/3990522/beats-100-with-proper-explanation-and-diagram-dp/\\nimage explanation"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[found this helpful for the question](https://leetcode.com/problems/extra-characters-in-a-string/solutions/3990522/beats-100-with-proper-explanation-and-diagram-dp/)"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "this should be marked hard(after looking at the editorial)"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "top down solution isn\\'t worth hard status"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "The total test case is 2028 right now. Unreal stuff."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Editorial was useful for this one."
                    },
                    {
                        "username": "sauravk21",
                        "content": "This is a variant of MCM question.  "
                    },
                    {
                        "username": "Prajju22",
                        "content": "try to think take and not take approach...(knapsack)"
                    },
                    {
                        "username": "Luffy2020",
                        "content": "Can any one tell why my answer is coming wrong for this testcase?\\nInput\\ns =\\n\"kevlplxozaizdhxoimmraiakbak\"\\ndictionary =\\n[\"yv\",\"bmab\",\"hv\",\"bnsll\",\"mra\",\"jjqf\",\"g\",\"aiyzi\",\"ip\",\"pfctr\",\"flr\",\"ybbcl\",\"biu\",\"ke\",\"lpl\",\"iak\",\"pirua\",\"ilhqd\",\"zdhx\",\"fux\",\"xaw\",\"pdfvt\",\"xf\",\"t\",\"wq\",\"r\",\"cgmud\",\"aokas\",\"xv\",\"jf\",\"cyys\",\"wcaz\",\"rvegf\",\"ysg\",\"xo\",\"uwb\",\"lw\",\"okgk\",\"vbmi\",\"v\",\"mvo\",\"fxyx\",\"ad\",\"e\"]\\n `class Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        \\n        Set<String> set = new HashSet<>();\\n        for(String item : dictionary){\\n            set.add(item);\\n        }\\n        \\n        int[] vis = new int[s.length()];\\n        Arrays.fill(vis,-1);\\n        \\n        for(int i=0 ;i<s.length();i++){\\n            StringBuilder str = new StringBuilder();\\n            for(int j=i; j<s.length() ; j++ ){\\n                str.append(s.charAt(j));\\n                System.out.println(str.toString());\\n                if(set.contains(str.toString())){\\n                    for(int k=i ; k<=j ;k++){\\n                        vis[k]=0;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            if(vis[i]==-1) count++;\\n        }\\n        return count; \\n        \\n    }\\n}.`"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Consider the test case\\n\"abcde\",[\"bcd\",\"ab\",\"de\"]\\nYour code will return 0 I think."
                    }
                ]
            },
            {
                "id": 2040082,
                "content": [
                    {
                        "username": "hanse413",
                        "content": "class Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        dictionary.sort(key = lambda x:len(x),reverse = True)\\n        while True:\\n            a = False\\n            for x in dictionary:\\n                if x in s:\\n                    s=s.replace(x,\"\", 1)\\n                    a = True\\n                    break\\n            if a == False:\\n                break\\n                \\n        return len(s)\\n\\nfor testcase:\\ns =\\n\"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\ndictionary =\\n[\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"]\\nOutput\\n14\\nExpected\\n15\\n\\nI believe the answer for this testcase is wrong? I even double check using the code below help!:\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: list[str]) -> int:\\n        dictionary.sort(key = lambda x:len(x),reverse = True)\\n        print(len(s))\\n        while True:\\n            a = False\\n            for x in dictionary:\\n                if x in s:\\n                    s=s.replace(x,\"\", 1)\\n                    print(f\"removed {x} \\\\n {s}\")\\n                    print(len(s))\\n                    a = True\\n                    break\\n            if a == False:\\n                break\\n                \\n        return len(s)\\n        \\ns =\"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\ndictionary =[\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"]\\nx = Solution()\\nprint(x.minExtraChar(s,dictionary))"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dikshawali",
                        "content": "2000+ test cases :O yo kidding me"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "https://leetcode.com/problems/extra-characters-in-a-string/solutions/3990522/beats-100-with-proper-explanation-and-diagram-dp/\\nimage explanation"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[found this helpful for the question](https://leetcode.com/problems/extra-characters-in-a-string/solutions/3990522/beats-100-with-proper-explanation-and-diagram-dp/)"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "this should be marked hard(after looking at the editorial)"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "top down solution isn\\'t worth hard status"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "The total test case is 2028 right now. Unreal stuff."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Editorial was useful for this one."
                    },
                    {
                        "username": "sauravk21",
                        "content": "This is a variant of MCM question.  "
                    },
                    {
                        "username": "Prajju22",
                        "content": "try to think take and not take approach...(knapsack)"
                    },
                    {
                        "username": "Luffy2020",
                        "content": "Can any one tell why my answer is coming wrong for this testcase?\\nInput\\ns =\\n\"kevlplxozaizdhxoimmraiakbak\"\\ndictionary =\\n[\"yv\",\"bmab\",\"hv\",\"bnsll\",\"mra\",\"jjqf\",\"g\",\"aiyzi\",\"ip\",\"pfctr\",\"flr\",\"ybbcl\",\"biu\",\"ke\",\"lpl\",\"iak\",\"pirua\",\"ilhqd\",\"zdhx\",\"fux\",\"xaw\",\"pdfvt\",\"xf\",\"t\",\"wq\",\"r\",\"cgmud\",\"aokas\",\"xv\",\"jf\",\"cyys\",\"wcaz\",\"rvegf\",\"ysg\",\"xo\",\"uwb\",\"lw\",\"okgk\",\"vbmi\",\"v\",\"mvo\",\"fxyx\",\"ad\",\"e\"]\\n `class Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        \\n        Set<String> set = new HashSet<>();\\n        for(String item : dictionary){\\n            set.add(item);\\n        }\\n        \\n        int[] vis = new int[s.length()];\\n        Arrays.fill(vis,-1);\\n        \\n        for(int i=0 ;i<s.length();i++){\\n            StringBuilder str = new StringBuilder();\\n            for(int j=i; j<s.length() ; j++ ){\\n                str.append(s.charAt(j));\\n                System.out.println(str.toString());\\n                if(set.contains(str.toString())){\\n                    for(int k=i ; k<=j ;k++){\\n                        vis[k]=0;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            if(vis[i]==-1) count++;\\n        }\\n        return count; \\n        \\n    }\\n}.`"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Consider the test case\\n\"abcde\",[\"bcd\",\"ab\",\"de\"]\\nYour code will return 0 I think."
                    }
                ]
            },
            {
                "id": 2040081,
                "content": [
                    {
                        "username": "hanse413",
                        "content": "class Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        dictionary.sort(key = lambda x:len(x),reverse = True)\\n        while True:\\n            a = False\\n            for x in dictionary:\\n                if x in s:\\n                    s=s.replace(x,\"\", 1)\\n                    a = True\\n                    break\\n            if a == False:\\n                break\\n                \\n        return len(s)\\n\\nfor testcase:\\ns =\\n\"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\ndictionary =\\n[\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"]\\nOutput\\n14\\nExpected\\n15\\n\\nI believe the answer for this testcase is wrong? I even double check using the code below help!:\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: list[str]) -> int:\\n        dictionary.sort(key = lambda x:len(x),reverse = True)\\n        print(len(s))\\n        while True:\\n            a = False\\n            for x in dictionary:\\n                if x in s:\\n                    s=s.replace(x,\"\", 1)\\n                    print(f\"removed {x} \\\\n {s}\")\\n                    print(len(s))\\n                    a = True\\n                    break\\n            if a == False:\\n                break\\n                \\n        return len(s)\\n        \\ns =\"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\ndictionary =[\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"]\\nx = Solution()\\nprint(x.minExtraChar(s,dictionary))"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dikshawali",
                        "content": "2000+ test cases :O yo kidding me"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "https://leetcode.com/problems/extra-characters-in-a-string/solutions/3990522/beats-100-with-proper-explanation-and-diagram-dp/\\nimage explanation"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[found this helpful for the question](https://leetcode.com/problems/extra-characters-in-a-string/solutions/3990522/beats-100-with-proper-explanation-and-diagram-dp/)"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "this should be marked hard(after looking at the editorial)"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "top down solution isn\\'t worth hard status"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "The total test case is 2028 right now. Unreal stuff."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Editorial was useful for this one."
                    },
                    {
                        "username": "sauravk21",
                        "content": "This is a variant of MCM question.  "
                    },
                    {
                        "username": "Prajju22",
                        "content": "try to think take and not take approach...(knapsack)"
                    },
                    {
                        "username": "Luffy2020",
                        "content": "Can any one tell why my answer is coming wrong for this testcase?\\nInput\\ns =\\n\"kevlplxozaizdhxoimmraiakbak\"\\ndictionary =\\n[\"yv\",\"bmab\",\"hv\",\"bnsll\",\"mra\",\"jjqf\",\"g\",\"aiyzi\",\"ip\",\"pfctr\",\"flr\",\"ybbcl\",\"biu\",\"ke\",\"lpl\",\"iak\",\"pirua\",\"ilhqd\",\"zdhx\",\"fux\",\"xaw\",\"pdfvt\",\"xf\",\"t\",\"wq\",\"r\",\"cgmud\",\"aokas\",\"xv\",\"jf\",\"cyys\",\"wcaz\",\"rvegf\",\"ysg\",\"xo\",\"uwb\",\"lw\",\"okgk\",\"vbmi\",\"v\",\"mvo\",\"fxyx\",\"ad\",\"e\"]\\n `class Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        \\n        Set<String> set = new HashSet<>();\\n        for(String item : dictionary){\\n            set.add(item);\\n        }\\n        \\n        int[] vis = new int[s.length()];\\n        Arrays.fill(vis,-1);\\n        \\n        for(int i=0 ;i<s.length();i++){\\n            StringBuilder str = new StringBuilder();\\n            for(int j=i; j<s.length() ; j++ ){\\n                str.append(s.charAt(j));\\n                System.out.println(str.toString());\\n                if(set.contains(str.toString())){\\n                    for(int k=i ; k<=j ;k++){\\n                        vis[k]=0;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            if(vis[i]==-1) count++;\\n        }\\n        return count; \\n        \\n    }\\n}.`"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Consider the test case\\n\"abcde\",[\"bcd\",\"ab\",\"de\"]\\nYour code will return 0 I think."
                    }
                ]
            },
            {
                "id": 2040030,
                "content": [
                    {
                        "username": "hanse413",
                        "content": "class Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        dictionary.sort(key = lambda x:len(x),reverse = True)\\n        while True:\\n            a = False\\n            for x in dictionary:\\n                if x in s:\\n                    s=s.replace(x,\"\", 1)\\n                    a = True\\n                    break\\n            if a == False:\\n                break\\n                \\n        return len(s)\\n\\nfor testcase:\\ns =\\n\"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\ndictionary =\\n[\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"]\\nOutput\\n14\\nExpected\\n15\\n\\nI believe the answer for this testcase is wrong? I even double check using the code below help!:\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: list[str]) -> int:\\n        dictionary.sort(key = lambda x:len(x),reverse = True)\\n        print(len(s))\\n        while True:\\n            a = False\\n            for x in dictionary:\\n                if x in s:\\n                    s=s.replace(x,\"\", 1)\\n                    print(f\"removed {x} \\\\n {s}\")\\n                    print(len(s))\\n                    a = True\\n                    break\\n            if a == False:\\n                break\\n                \\n        return len(s)\\n        \\ns =\"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\ndictionary =[\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"]\\nx = Solution()\\nprint(x.minExtraChar(s,dictionary))"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dikshawali",
                        "content": "2000+ test cases :O yo kidding me"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "https://leetcode.com/problems/extra-characters-in-a-string/solutions/3990522/beats-100-with-proper-explanation-and-diagram-dp/\\nimage explanation"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[found this helpful for the question](https://leetcode.com/problems/extra-characters-in-a-string/solutions/3990522/beats-100-with-proper-explanation-and-diagram-dp/)"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "this should be marked hard(after looking at the editorial)"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "top down solution isn\\'t worth hard status"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "The total test case is 2028 right now. Unreal stuff."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Editorial was useful for this one."
                    },
                    {
                        "username": "sauravk21",
                        "content": "This is a variant of MCM question.  "
                    },
                    {
                        "username": "Prajju22",
                        "content": "try to think take and not take approach...(knapsack)"
                    },
                    {
                        "username": "Luffy2020",
                        "content": "Can any one tell why my answer is coming wrong for this testcase?\\nInput\\ns =\\n\"kevlplxozaizdhxoimmraiakbak\"\\ndictionary =\\n[\"yv\",\"bmab\",\"hv\",\"bnsll\",\"mra\",\"jjqf\",\"g\",\"aiyzi\",\"ip\",\"pfctr\",\"flr\",\"ybbcl\",\"biu\",\"ke\",\"lpl\",\"iak\",\"pirua\",\"ilhqd\",\"zdhx\",\"fux\",\"xaw\",\"pdfvt\",\"xf\",\"t\",\"wq\",\"r\",\"cgmud\",\"aokas\",\"xv\",\"jf\",\"cyys\",\"wcaz\",\"rvegf\",\"ysg\",\"xo\",\"uwb\",\"lw\",\"okgk\",\"vbmi\",\"v\",\"mvo\",\"fxyx\",\"ad\",\"e\"]\\n `class Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        \\n        Set<String> set = new HashSet<>();\\n        for(String item : dictionary){\\n            set.add(item);\\n        }\\n        \\n        int[] vis = new int[s.length()];\\n        Arrays.fill(vis,-1);\\n        \\n        for(int i=0 ;i<s.length();i++){\\n            StringBuilder str = new StringBuilder();\\n            for(int j=i; j<s.length() ; j++ ){\\n                str.append(s.charAt(j));\\n                System.out.println(str.toString());\\n                if(set.contains(str.toString())){\\n                    for(int k=i ; k<=j ;k++){\\n                        vis[k]=0;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            if(vis[i]==-1) count++;\\n        }\\n        return count; \\n        \\n    }\\n}.`"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Consider the test case\\n\"abcde\",[\"bcd\",\"ab\",\"de\"]\\nYour code will return 0 I think."
                    }
                ]
            },
            {
                "id": 2040028,
                "content": [
                    {
                        "username": "hanse413",
                        "content": "class Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        dictionary.sort(key = lambda x:len(x),reverse = True)\\n        while True:\\n            a = False\\n            for x in dictionary:\\n                if x in s:\\n                    s=s.replace(x,\"\", 1)\\n                    a = True\\n                    break\\n            if a == False:\\n                break\\n                \\n        return len(s)\\n\\nfor testcase:\\ns =\\n\"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\ndictionary =\\n[\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"]\\nOutput\\n14\\nExpected\\n15\\n\\nI believe the answer for this testcase is wrong? I even double check using the code below help!:\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: list[str]) -> int:\\n        dictionary.sort(key = lambda x:len(x),reverse = True)\\n        print(len(s))\\n        while True:\\n            a = False\\n            for x in dictionary:\\n                if x in s:\\n                    s=s.replace(x,\"\", 1)\\n                    print(f\"removed {x} \\\\n {s}\")\\n                    print(len(s))\\n                    a = True\\n                    break\\n            if a == False:\\n                break\\n                \\n        return len(s)\\n        \\ns =\"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\ndictionary =[\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"]\\nx = Solution()\\nprint(x.minExtraChar(s,dictionary))"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dikshawali",
                        "content": "2000+ test cases :O yo kidding me"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "https://leetcode.com/problems/extra-characters-in-a-string/solutions/3990522/beats-100-with-proper-explanation-and-diagram-dp/\\nimage explanation"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[found this helpful for the question](https://leetcode.com/problems/extra-characters-in-a-string/solutions/3990522/beats-100-with-proper-explanation-and-diagram-dp/)"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "this should be marked hard(after looking at the editorial)"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "top down solution isn\\'t worth hard status"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "The total test case is 2028 right now. Unreal stuff."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Editorial was useful for this one."
                    },
                    {
                        "username": "sauravk21",
                        "content": "This is a variant of MCM question.  "
                    },
                    {
                        "username": "Prajju22",
                        "content": "try to think take and not take approach...(knapsack)"
                    },
                    {
                        "username": "Luffy2020",
                        "content": "Can any one tell why my answer is coming wrong for this testcase?\\nInput\\ns =\\n\"kevlplxozaizdhxoimmraiakbak\"\\ndictionary =\\n[\"yv\",\"bmab\",\"hv\",\"bnsll\",\"mra\",\"jjqf\",\"g\",\"aiyzi\",\"ip\",\"pfctr\",\"flr\",\"ybbcl\",\"biu\",\"ke\",\"lpl\",\"iak\",\"pirua\",\"ilhqd\",\"zdhx\",\"fux\",\"xaw\",\"pdfvt\",\"xf\",\"t\",\"wq\",\"r\",\"cgmud\",\"aokas\",\"xv\",\"jf\",\"cyys\",\"wcaz\",\"rvegf\",\"ysg\",\"xo\",\"uwb\",\"lw\",\"okgk\",\"vbmi\",\"v\",\"mvo\",\"fxyx\",\"ad\",\"e\"]\\n `class Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        \\n        Set<String> set = new HashSet<>();\\n        for(String item : dictionary){\\n            set.add(item);\\n        }\\n        \\n        int[] vis = new int[s.length()];\\n        Arrays.fill(vis,-1);\\n        \\n        for(int i=0 ;i<s.length();i++){\\n            StringBuilder str = new StringBuilder();\\n            for(int j=i; j<s.length() ; j++ ){\\n                str.append(s.charAt(j));\\n                System.out.println(str.toString());\\n                if(set.contains(str.toString())){\\n                    for(int k=i ; k<=j ;k++){\\n                        vis[k]=0;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            if(vis[i]==-1) count++;\\n        }\\n        return count; \\n        \\n    }\\n}.`"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Consider the test case\\n\"abcde\",[\"bcd\",\"ab\",\"de\"]\\nYour code will return 0 I think."
                    }
                ]
            },
            {
                "id": 2040000,
                "content": [
                    {
                        "username": "hanse413",
                        "content": "class Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        dictionary.sort(key = lambda x:len(x),reverse = True)\\n        while True:\\n            a = False\\n            for x in dictionary:\\n                if x in s:\\n                    s=s.replace(x,\"\", 1)\\n                    a = True\\n                    break\\n            if a == False:\\n                break\\n                \\n        return len(s)\\n\\nfor testcase:\\ns =\\n\"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\ndictionary =\\n[\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"]\\nOutput\\n14\\nExpected\\n15\\n\\nI believe the answer for this testcase is wrong? I even double check using the code below help!:\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: list[str]) -> int:\\n        dictionary.sort(key = lambda x:len(x),reverse = True)\\n        print(len(s))\\n        while True:\\n            a = False\\n            for x in dictionary:\\n                if x in s:\\n                    s=s.replace(x,\"\", 1)\\n                    print(f\"removed {x} \\\\n {s}\")\\n                    print(len(s))\\n                    a = True\\n                    break\\n            if a == False:\\n                break\\n                \\n        return len(s)\\n        \\ns =\"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\ndictionary =[\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"]\\nx = Solution()\\nprint(x.minExtraChar(s,dictionary))"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dikshawali",
                        "content": "2000+ test cases :O yo kidding me"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "https://leetcode.com/problems/extra-characters-in-a-string/solutions/3990522/beats-100-with-proper-explanation-and-diagram-dp/\\nimage explanation"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[found this helpful for the question](https://leetcode.com/problems/extra-characters-in-a-string/solutions/3990522/beats-100-with-proper-explanation-and-diagram-dp/)"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "this should be marked hard(after looking at the editorial)"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "top down solution isn\\'t worth hard status"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "The total test case is 2028 right now. Unreal stuff."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Editorial was useful for this one."
                    },
                    {
                        "username": "sauravk21",
                        "content": "This is a variant of MCM question.  "
                    },
                    {
                        "username": "Prajju22",
                        "content": "try to think take and not take approach...(knapsack)"
                    },
                    {
                        "username": "Luffy2020",
                        "content": "Can any one tell why my answer is coming wrong for this testcase?\\nInput\\ns =\\n\"kevlplxozaizdhxoimmraiakbak\"\\ndictionary =\\n[\"yv\",\"bmab\",\"hv\",\"bnsll\",\"mra\",\"jjqf\",\"g\",\"aiyzi\",\"ip\",\"pfctr\",\"flr\",\"ybbcl\",\"biu\",\"ke\",\"lpl\",\"iak\",\"pirua\",\"ilhqd\",\"zdhx\",\"fux\",\"xaw\",\"pdfvt\",\"xf\",\"t\",\"wq\",\"r\",\"cgmud\",\"aokas\",\"xv\",\"jf\",\"cyys\",\"wcaz\",\"rvegf\",\"ysg\",\"xo\",\"uwb\",\"lw\",\"okgk\",\"vbmi\",\"v\",\"mvo\",\"fxyx\",\"ad\",\"e\"]\\n `class Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        \\n        Set<String> set = new HashSet<>();\\n        for(String item : dictionary){\\n            set.add(item);\\n        }\\n        \\n        int[] vis = new int[s.length()];\\n        Arrays.fill(vis,-1);\\n        \\n        for(int i=0 ;i<s.length();i++){\\n            StringBuilder str = new StringBuilder();\\n            for(int j=i; j<s.length() ; j++ ){\\n                str.append(s.charAt(j));\\n                System.out.println(str.toString());\\n                if(set.contains(str.toString())){\\n                    for(int k=i ; k<=j ;k++){\\n                        vis[k]=0;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            if(vis[i]==-1) count++;\\n        }\\n        return count; \\n        \\n    }\\n}.`"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Consider the test case\\n\"abcde\",[\"bcd\",\"ab\",\"de\"]\\nYour code will return 0 I think."
                    }
                ]
            },
            {
                "id": 2000059,
                "content": [
                    {
                        "username": "hanse413",
                        "content": "class Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        dictionary.sort(key = lambda x:len(x),reverse = True)\\n        while True:\\n            a = False\\n            for x in dictionary:\\n                if x in s:\\n                    s=s.replace(x,\"\", 1)\\n                    a = True\\n                    break\\n            if a == False:\\n                break\\n                \\n        return len(s)\\n\\nfor testcase:\\ns =\\n\"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\ndictionary =\\n[\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"]\\nOutput\\n14\\nExpected\\n15\\n\\nI believe the answer for this testcase is wrong? I even double check using the code below help!:\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: list[str]) -> int:\\n        dictionary.sort(key = lambda x:len(x),reverse = True)\\n        print(len(s))\\n        while True:\\n            a = False\\n            for x in dictionary:\\n                if x in s:\\n                    s=s.replace(x,\"\", 1)\\n                    print(f\"removed {x} \\\\n {s}\")\\n                    print(len(s))\\n                    a = True\\n                    break\\n            if a == False:\\n                break\\n                \\n        return len(s)\\n        \\ns =\"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\ndictionary =[\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"]\\nx = Solution()\\nprint(x.minExtraChar(s,dictionary))"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dikshawali",
                        "content": "2000+ test cases :O yo kidding me"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "https://leetcode.com/problems/extra-characters-in-a-string/solutions/3990522/beats-100-with-proper-explanation-and-diagram-dp/\\nimage explanation"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[found this helpful for the question](https://leetcode.com/problems/extra-characters-in-a-string/solutions/3990522/beats-100-with-proper-explanation-and-diagram-dp/)"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "this should be marked hard(after looking at the editorial)"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "top down solution isn\\'t worth hard status"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "The total test case is 2028 right now. Unreal stuff."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Editorial was useful for this one."
                    },
                    {
                        "username": "sauravk21",
                        "content": "This is a variant of MCM question.  "
                    },
                    {
                        "username": "Prajju22",
                        "content": "try to think take and not take approach...(knapsack)"
                    },
                    {
                        "username": "Luffy2020",
                        "content": "Can any one tell why my answer is coming wrong for this testcase?\\nInput\\ns =\\n\"kevlplxozaizdhxoimmraiakbak\"\\ndictionary =\\n[\"yv\",\"bmab\",\"hv\",\"bnsll\",\"mra\",\"jjqf\",\"g\",\"aiyzi\",\"ip\",\"pfctr\",\"flr\",\"ybbcl\",\"biu\",\"ke\",\"lpl\",\"iak\",\"pirua\",\"ilhqd\",\"zdhx\",\"fux\",\"xaw\",\"pdfvt\",\"xf\",\"t\",\"wq\",\"r\",\"cgmud\",\"aokas\",\"xv\",\"jf\",\"cyys\",\"wcaz\",\"rvegf\",\"ysg\",\"xo\",\"uwb\",\"lw\",\"okgk\",\"vbmi\",\"v\",\"mvo\",\"fxyx\",\"ad\",\"e\"]\\n `class Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        \\n        Set<String> set = new HashSet<>();\\n        for(String item : dictionary){\\n            set.add(item);\\n        }\\n        \\n        int[] vis = new int[s.length()];\\n        Arrays.fill(vis,-1);\\n        \\n        for(int i=0 ;i<s.length();i++){\\n            StringBuilder str = new StringBuilder();\\n            for(int j=i; j<s.length() ; j++ ){\\n                str.append(s.charAt(j));\\n                System.out.println(str.toString());\\n                if(set.contains(str.toString())){\\n                    for(int k=i ; k<=j ;k++){\\n                        vis[k]=0;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            if(vis[i]==-1) count++;\\n        }\\n        return count; \\n        \\n    }\\n}.`"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Consider the test case\\n\"abcde\",[\"bcd\",\"ab\",\"de\"]\\nYour code will return 0 I think."
                    }
                ]
            },
            {
                "id": 1908883,
                "content": [
                    {
                        "username": "hanse413",
                        "content": "class Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        dictionary.sort(key = lambda x:len(x),reverse = True)\\n        while True:\\n            a = False\\n            for x in dictionary:\\n                if x in s:\\n                    s=s.replace(x,\"\", 1)\\n                    a = True\\n                    break\\n            if a == False:\\n                break\\n                \\n        return len(s)\\n\\nfor testcase:\\ns =\\n\"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\ndictionary =\\n[\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"]\\nOutput\\n14\\nExpected\\n15\\n\\nI believe the answer for this testcase is wrong? I even double check using the code below help!:\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: list[str]) -> int:\\n        dictionary.sort(key = lambda x:len(x),reverse = True)\\n        print(len(s))\\n        while True:\\n            a = False\\n            for x in dictionary:\\n                if x in s:\\n                    s=s.replace(x,\"\", 1)\\n                    print(f\"removed {x} \\\\n {s}\")\\n                    print(len(s))\\n                    a = True\\n                    break\\n            if a == False:\\n                break\\n                \\n        return len(s)\\n        \\ns =\"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\ndictionary =[\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"]\\nx = Solution()\\nprint(x.minExtraChar(s,dictionary))"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dikshawali",
                        "content": "2000+ test cases :O yo kidding me"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "https://leetcode.com/problems/extra-characters-in-a-string/solutions/3990522/beats-100-with-proper-explanation-and-diagram-dp/\\nimage explanation"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[found this helpful for the question](https://leetcode.com/problems/extra-characters-in-a-string/solutions/3990522/beats-100-with-proper-explanation-and-diagram-dp/)"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "this should be marked hard(after looking at the editorial)"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "top down solution isn\\'t worth hard status"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "The total test case is 2028 right now. Unreal stuff."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Editorial was useful for this one."
                    },
                    {
                        "username": "sauravk21",
                        "content": "This is a variant of MCM question.  "
                    },
                    {
                        "username": "Prajju22",
                        "content": "try to think take and not take approach...(knapsack)"
                    },
                    {
                        "username": "Luffy2020",
                        "content": "Can any one tell why my answer is coming wrong for this testcase?\\nInput\\ns =\\n\"kevlplxozaizdhxoimmraiakbak\"\\ndictionary =\\n[\"yv\",\"bmab\",\"hv\",\"bnsll\",\"mra\",\"jjqf\",\"g\",\"aiyzi\",\"ip\",\"pfctr\",\"flr\",\"ybbcl\",\"biu\",\"ke\",\"lpl\",\"iak\",\"pirua\",\"ilhqd\",\"zdhx\",\"fux\",\"xaw\",\"pdfvt\",\"xf\",\"t\",\"wq\",\"r\",\"cgmud\",\"aokas\",\"xv\",\"jf\",\"cyys\",\"wcaz\",\"rvegf\",\"ysg\",\"xo\",\"uwb\",\"lw\",\"okgk\",\"vbmi\",\"v\",\"mvo\",\"fxyx\",\"ad\",\"e\"]\\n `class Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        \\n        Set<String> set = new HashSet<>();\\n        for(String item : dictionary){\\n            set.add(item);\\n        }\\n        \\n        int[] vis = new int[s.length()];\\n        Arrays.fill(vis,-1);\\n        \\n        for(int i=0 ;i<s.length();i++){\\n            StringBuilder str = new StringBuilder();\\n            for(int j=i; j<s.length() ; j++ ){\\n                str.append(s.charAt(j));\\n                System.out.println(str.toString());\\n                if(set.contains(str.toString())){\\n                    for(int k=i ; k<=j ;k++){\\n                        vis[k]=0;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            if(vis[i]==-1) count++;\\n        }\\n        return count; \\n        \\n    }\\n}.`"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Consider the test case\\n\"abcde\",[\"bcd\",\"ab\",\"de\"]\\nYour code will return 0 I think."
                    }
                ]
            },
            {
                "id": 1908599,
                "content": [
                    {
                        "username": "hanse413",
                        "content": "class Solution:\\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        dictionary.sort(key = lambda x:len(x),reverse = True)\\n        while True:\\n            a = False\\n            for x in dictionary:\\n                if x in s:\\n                    s=s.replace(x,\"\", 1)\\n                    a = True\\n                    break\\n            if a == False:\\n                break\\n                \\n        return len(s)\\n\\nfor testcase:\\ns =\\n\"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\ndictionary =\\n[\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"]\\nOutput\\n14\\nExpected\\n15\\n\\nI believe the answer for this testcase is wrong? I even double check using the code below help!:\\nclass Solution:\\n    def minExtraChar(self, s: str, dictionary: list[str]) -> int:\\n        dictionary.sort(key = lambda x:len(x),reverse = True)\\n        print(len(s))\\n        while True:\\n            a = False\\n            for x in dictionary:\\n                if x in s:\\n                    s=s.replace(x,\"\", 1)\\n                    print(f\"removed {x} \\\\n {s}\")\\n                    print(len(s))\\n                    a = True\\n                    break\\n            if a == False:\\n                break\\n                \\n        return len(s)\\n        \\ns =\"azvzulhlwxwobowijiyebeaskecvtjqwkmaqnvnaomaqnvf\"\\ndictionary =[\"na\",\"i\",\"edd\",\"wobow\",\"kecv\",\"b\",\"n\",\"or\",\"jj\",\"zul\",\"vk\",\"yeb\",\"qnfac\",\"azv\",\"grtjba\",\"yswmjn\",\"xowio\",\"u\",\"xi\",\"pcmatm\",\"maqnv\"]\\nx = Solution()\\nprint(x.minExtraChar(s,dictionary))"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dikshawali",
                        "content": "2000+ test cases :O yo kidding me"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "https://leetcode.com/problems/extra-characters-in-a-string/solutions/3990522/beats-100-with-proper-explanation-and-diagram-dp/\\nimage explanation"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[found this helpful for the question](https://leetcode.com/problems/extra-characters-in-a-string/solutions/3990522/beats-100-with-proper-explanation-and-diagram-dp/)"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "this should be marked hard(after looking at the editorial)"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "top down solution isn\\'t worth hard status"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "The total test case is 2028 right now. Unreal stuff."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Editorial was useful for this one."
                    },
                    {
                        "username": "sauravk21",
                        "content": "This is a variant of MCM question.  "
                    },
                    {
                        "username": "Prajju22",
                        "content": "try to think take and not take approach...(knapsack)"
                    },
                    {
                        "username": "Luffy2020",
                        "content": "Can any one tell why my answer is coming wrong for this testcase?\\nInput\\ns =\\n\"kevlplxozaizdhxoimmraiakbak\"\\ndictionary =\\n[\"yv\",\"bmab\",\"hv\",\"bnsll\",\"mra\",\"jjqf\",\"g\",\"aiyzi\",\"ip\",\"pfctr\",\"flr\",\"ybbcl\",\"biu\",\"ke\",\"lpl\",\"iak\",\"pirua\",\"ilhqd\",\"zdhx\",\"fux\",\"xaw\",\"pdfvt\",\"xf\",\"t\",\"wq\",\"r\",\"cgmud\",\"aokas\",\"xv\",\"jf\",\"cyys\",\"wcaz\",\"rvegf\",\"ysg\",\"xo\",\"uwb\",\"lw\",\"okgk\",\"vbmi\",\"v\",\"mvo\",\"fxyx\",\"ad\",\"e\"]\\n `class Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        \\n        Set<String> set = new HashSet<>();\\n        for(String item : dictionary){\\n            set.add(item);\\n        }\\n        \\n        int[] vis = new int[s.length()];\\n        Arrays.fill(vis,-1);\\n        \\n        for(int i=0 ;i<s.length();i++){\\n            StringBuilder str = new StringBuilder();\\n            for(int j=i; j<s.length() ; j++ ){\\n                str.append(s.charAt(j));\\n                System.out.println(str.toString());\\n                if(set.contains(str.toString())){\\n                    for(int k=i ; k<=j ;k++){\\n                        vis[k]=0;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            if(vis[i]==-1) count++;\\n        }\\n        return count; \\n        \\n    }\\n}.`"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Consider the test case\\n\"abcde\",[\"bcd\",\"ab\",\"de\"]\\nYour code will return 0 I think."
                    }
                ]
            }
        ]
    }
]