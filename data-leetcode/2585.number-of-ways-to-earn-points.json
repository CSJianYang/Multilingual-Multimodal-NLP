[
    {
        "title": "Number of Ways to Earn Points",
        "question_content": "There is a test that has n types of questions. You are given an integer target and a 0-indexed 2D integer array types where types[i] = [counti, marksi] indicates that there are counti questions of the ith type, and each one of them is worth marksi points.\n\n\nReturn the number of ways you can earn exactly target points in the exam. Since the answer may be too large, return it modulo 109 + 7.\nNote that questions of the same type are indistinguishable.\n\n\tFor example, if there are 3 questions of the same type, then solving the 1st and 2nd questions is the same as solving the 1st and 3rd questions, or the 2nd and 3rd questions.\n\n&nbsp;\nExample 1:\n\nInput: target = 6, types = [[6,1],[3,2],[2,3]]\nOutput: 7\nExplanation: You can earn 6 points in one of the seven ways:\n- Solve 6 questions of the 0th type: 1 + 1 + 1 + 1 + 1 + 1 = 6\n- Solve 4 questions of the 0th type and 1 question of the 1st type: 1 + 1 + 1 + 1 + 2 = 6\n- Solve 2 questions of the 0th type and 2 questions of the 1st type: 1 + 1 + 2 + 2 = 6\n- Solve 3 questions of the 0th type and 1 question of the 2nd type: 1 + 1 + 1 + 3 = 6\n- Solve 1 question of the 0th type, 1 question of the 1st type and 1 question of the 2nd type: 1 + 2 + 3 = 6\n- Solve 3 questions of the 1st type: 2 + 2 + 2 = 6\n- Solve 2 questions of the 2nd type: 3 + 3 = 6\n\nExample 2:\n\nInput: target = 5, types = [[50,1],[50,2],[50,5]]\nOutput: 4\nExplanation: You can earn 5 points in one of the four ways:\n- Solve 5 questions of the 0th type: 1 + 1 + 1 + 1 + 1 = 5\n- Solve 3 questions of the 0th type and 1 question of the 1st type: 1 + 1 + 1 + 2 = 5\n- Solve 1 questions of the 0th type and 2 questions of the 1st type: 1 + 2 + 2 = 5\n- Solve 1 question of the 2nd type: 5\n\nExample 3:\n\nInput: target = 18, types = [[6,1],[3,2],[2,3]]\nOutput: 1\nExplanation: You can only earn 18 points by answering all questions.\n\n&nbsp;\nConstraints:\n\n\t1 <= target <= 1000\n\tn == types.length\n\t1 <= n <= 50\n\ttypes[i].length == 2\n\t1 <= counti, marksi <= 50",
        "solutions": [
            {
                "id": 3258120,
                "title": "java-c-python-knapsack-dp",
                "content": "# **Intuition**\\nClassical [Knapsack Problems](https://en.wikipedia.org/wiki/List_of_knapsack_problems)\\n<br>\\n\\n# **Explanation**\\n`dp[i]` means the ways to reach `i` points.\\n\\nIterative each `[count, mark]` in question of all `types`.\\nwe can do `1,2...,count` question right,\\n`dp[i]` can be reached from `dp[i - mark], dp[i - mark * 2] ... dp[i - mark * count]`.\\n\\n\\nNote that `dp[big]` depends on `dp[small]`,\\nif you change `dp[small]`first, we need to update `dp[big]` from old `dp[small]`.\\nSo here I iterative from `dp[big]` to `dp[small]`.\\n\\nWe continuely do this and finally return `dp[target`.\\n<br>\\n\\n# **Complexity**\\nTime `O(target * n * count)`\\nSpace `O(target)`\\n<br>\\n\\n**Java**\\n```java\\n    public int waysToReachTarget(int target, int[][] types) {\\n        int mod = (int)1e9 + 7, dp[] = new int[target + 1];\\n        dp[0] = 1;\\n        for (int[] t : types)\\n            for (int i = target; i > 0; --i)\\n                for (int k = 1; k <= t[0] && i - t[1] * k >= 0; ++k)\\n                    dp[i] = (dp[i] + dp[i - t[1] * k]) % mod;\\n        return dp[target];\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        vector<int> dp(target + 1);\\n        dp[0] = 1;\\n        int mod = 1e9 + 7;\\n        for (auto& t : types)\\n            for (int i = target; i > 0; --i)\\n                for (int k = 1; k <= t[0] && i - t[1] * k >= 0; ++k)\\n                    dp[i] = (dp[i] + dp[i - t[1] * k]) % mod;\\n        return dp[target];\\n    }\\n```\\n\\n**Python**\\n```py\\n    def waysToReachTarget(self, target, types):\\n        dp = [1] + [0] * target\\n        mod = 10 ** 9 + 7\\n        for c,m in types:\\n            for i in range(target,-1,-1):\\n                for k in range(1, min(c, i // m) + 1):\\n                    dp[i] = (dp[i] + dp[i - m * k]) % mod\\n        return dp[-1]\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int waysToReachTarget(int target, int[][] types) {\\n        int mod = (int)1e9 + 7, dp[] = new int[target + 1];\\n        dp[0] = 1;\\n        for (int[] t : types)\\n            for (int i = target; i > 0; --i)\\n                for (int k = 1; k <= t[0] && i - t[1] * k >= 0; ++k)\\n                    dp[i] = (dp[i] + dp[i - t[1] * k]) % mod;\\n        return dp[target];\\n    }\\n```\n```cpp\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        vector<int> dp(target + 1);\\n        dp[0] = 1;\\n        int mod = 1e9 + 7;\\n        for (auto& t : types)\\n            for (int i = target; i > 0; --i)\\n                for (int k = 1; k <= t[0] && i - t[1] * k >= 0; ++k)\\n                    dp[i] = (dp[i] + dp[i - t[1] * k]) % mod;\\n        return dp[target];\\n    }\\n```\n```py\\n    def waysToReachTarget(self, target, types):\\n        dp = [1] + [0] * target\\n        mod = 10 ** 9 + 7\\n        for c,m in types:\\n            for i in range(target,-1,-1):\\n                for k in range(1, min(c, i // m) + 1):\\n                    dp[i] = (dp[i] + dp[i - m * k]) % mod\\n        return dp[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3258089,
                "title": "c-java-python3-short-top-down-dp-explained",
                "content": "# Intuition\\nSince the constraints are small we can explore a DP approach. Start with the `target` and then subtract combinations of question `types` from it. Our function definiton of the recursive function will have 2 variables, (target, i). `target` signifies the remaining `target` and `i` siginifies the ith question type.\\n\\n# Approach\\nThe base cases for the `dfs` function are:\\n* If the remaining `target` is 0, then return 1 as one way to reach the target has been found.\\n* If the index `i` is greater than or equal to the number of `types` of questions or `target` is less than 0, then return 0 as no more ways to reach the `target` can be found.\\n\\nIn the recursive case, the `dfs` function calculates the sum of the number of ways to reach the target by considering different numbers of questions of the current type. It does this by iterating over j from 0 to the maximum number of questions of the current type (types[i][0]) and calling the `dfs` function with the updated `target` value `(target - j * types[i][1])` and the index of the next type of question `(i + 1)`. `types[i][1]` is the `value` of the ith question\\n\\nThe final result is the modulo `10^9 + 7` of the total number of ways to reach the target found by the `dfs` function.\\n\\nThe solution uses memoization to avoid redundant calculations and returns the answer modulo `10^9 + 7` to prevent integer overflow.\\n\\n\\n# Complexity\\n- Time complexity: `O(target * len(types) * max(count))`\\n\\n- Space complexity: `O(target * len(types))`\\n\\n# Code\\n**Python3**:\\n```\\ndef waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\\n    @cache\\n    def dfs(i, target):\\n        if target == 0: return 1\\n        if i >= len(types) or target < 0: return 0\\n        return sum(dfs(i + 1, target - j * types[i][1]) for j in range(types[i][0] + 1)) % 1000000007\\n    return dfs(0, target)\\n```\\n*Just for fun*\\n```\\ndef waysToReachTarget(self, target, T, mod = 1000000007):\\n    return (lambda dp: dp(dp, 0, target))(lru_cache(maxsize=None)(lambda f, i, t: 1 if t == 0 else 0 if i >= len(T) or t < 0 else sum(f(f, i+1, t-j*T[i][1]) for j in range(T[i][0]+1)) % mod))\\n```\\n\\n**C++**:\\n```\\nint cache[1001][51] = {};\\nint waysToReachTarget(int target, vector<vector<int>>& types) {\\n    memset(cache, -1, sizeof(cache)); // initialize cache with -1\\n    function<int(int, int)> dfs = [&](int i, int target) {\\n        if (target == 0) return 1;\\n        if (i >= types.size() || target < 0) return 0;\\n        if (cache[target][i] != -1) return cache[target][i];\\n        int ans = 0;\\n        for (int j = 0; j <= types[i][0]; j++)\\n            ans = (ans + dfs(i + 1, target - j * types[i][1])) % 1000000007;\\n        return cache[target][i] = ans;\\n    };\\n    return dfs(0, target);\\n}\\n```\\n\\n**Java**:\\n```\\nint[][] cache;\\npublic int waysToReachTarget(int target, int[][] types) {\\n    cache = new int[target + 1][types.length + 1];\\n    Arrays.stream(cache).forEach(a -> Arrays.fill(a, -1)); // init cache with -1\\n    return dfs(0, target, types);\\n}\\nprivate int dfs(int i, int target, int[][] types) {\\n    if (target == 0) return 1;\\n    if (i >= types.length || target < 0) return 0;\\n    if (cache[target][i] != -1) return cache[target][i];\\n    int ans = 0;\\n    for (int j = 0; j <= types[i][0]; j++)\\n        ans = (ans + dfs(i + 1, target - j * types[i][1], types)) % 1000000007;\\n    cache[target][i] = ans;\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```\\ndef waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\\n    @cache\\n    def dfs(i, target):\\n        if target == 0: return 1\\n        if i >= len(types) or target < 0: return 0\\n        return sum(dfs(i + 1, target - j * types[i][1]) for j in range(types[i][0] + 1)) % 1000000007\\n    return dfs(0, target)\\n```\n```\\ndef waysToReachTarget(self, target, T, mod = 1000000007):\\n    return (lambda dp: dp(dp, 0, target))(lru_cache(maxsize=None)(lambda f, i, t: 1 if t == 0 else 0 if i >= len(T) or t < 0 else sum(f(f, i+1, t-j*T[i][1]) for j in range(T[i][0]+1)) % mod))\\n```\n```\\nint cache[1001][51] = {};\\nint waysToReachTarget(int target, vector<vector<int>>& types) {\\n    memset(cache, -1, sizeof(cache)); // initialize cache with -1\\n    function<int(int, int)> dfs = [&](int i, int target) {\\n        if (target == 0) return 1;\\n        if (i >= types.size() || target < 0) return 0;\\n        if (cache[target][i] != -1) return cache[target][i];\\n        int ans = 0;\\n        for (int j = 0; j <= types[i][0]; j++)\\n            ans = (ans + dfs(i + 1, target - j * types[i][1])) % 1000000007;\\n        return cache[target][i] = ans;\\n    };\\n    return dfs(0, target);\\n}\\n```\n```\\nint[][] cache;\\npublic int waysToReachTarget(int target, int[][] types) {\\n    cache = new int[target + 1][types.length + 1];\\n    Arrays.stream(cache).forEach(a -> Arrays.fill(a, -1)); // init cache with -1\\n    return dfs(0, target, types);\\n}\\nprivate int dfs(int i, int target, int[][] types) {\\n    if (target == 0) return 1;\\n    if (i >= types.length || target < 0) return 0;\\n    if (cache[target][i] != -1) return cache[target][i];\\n    int ans = 0;\\n    for (int j = 0; j <= types[i][0]; j++)\\n        ans = (ans + dfs(i + 1, target - j * types[i][1], types)) % 1000000007;\\n    cache[target][i] = ans;\\n    return ans;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3258410,
                "title": "100-faster-beginner-friendly-c-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int mod=1e9+7;\\n    long long solve(int i,int n,vector<vector<int>>&a,int target){\\n        if(target==0){        //if target is 0 then we have 1 answer\\n            return 1;\\n        }\\n        if(i==n){\\n            return target==0;       //if we have reached last index and our value of target is 0 then we have answer\\n        }\\n        if(dp[i][target]!=-1){       //checking if this state is calculated or not\\n            return dp[i][target]%mod;       //returning the state if calculated\\n        }\\n        long long res=0;            \\n        for(int j=0;j<=a[i][0];j++){         //j tells the number of times this index is picked it can be 0,1,2,....a[i][0](max freq)\\n            if(target-a[i][1]*j>=0){          //if picking this index j times will keep the target >=0 then we will pick it and store the result\\n                res+=solve(i+1,n,a,target-a[i][1]*j);\\n            }\\n            else\\n                break;\\n        }\\n        return dp[i][target]=res%mod;       //saving the state and returing the answer\\n    }\\n    long long waysToReachTarget(int target, vector<vector<int>>& types) {\\n        dp.resize(types.size()+1,vector<int>(target+1,-1));\\n        return solve(0,types.size(),types,target);\\n    }\\n};\\n```\\n\\n\\n\\n**NOTE:**\\nIf you find this post helpful then please **upvote**. It keeps me **motivated** to post such helpful solutions. Thanks!",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int mod=1e9+7;\\n    long long solve(int i,int n,vector<vector<int>>&a,int target){\\n        if(target==0){        //if target is 0 then we have 1 answer\\n            return 1;\\n        }\\n        if(i==n){\\n            return target==0;       //if we have reached last index and our value of target is 0 then we have answer\\n        }\\n        if(dp[i][target]!=-1){       //checking if this state is calculated or not\\n            return dp[i][target]%mod;       //returning the state if calculated\\n        }\\n        long long res=0;            \\n        for(int j=0;j<=a[i][0];j++){         //j tells the number of times this index is picked it can be 0,1,2,....a[i][0](max freq)\\n            if(target-a[i][1]*j>=0){          //if picking this index j times will keep the target >=0 then we will pick it and store the result\\n                res+=solve(i+1,n,a,target-a[i][1]*j);\\n            }\\n            else\\n                break;\\n        }\\n        return dp[i][target]=res%mod;       //saving the state and returing the answer\\n    }\\n    long long waysToReachTarget(int target, vector<vector<int>>& types) {\\n        dp.resize(types.size()+1,vector<int>(target+1,-1));\\n        return solve(0,types.size(),types,target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258125,
                "title": "limited-coin-change",
                "content": "I was surprised LeetCode did not have this problem till now.\\n\\n**C++**\\n```cpp\\nint waysToReachTarget(int target, vector<vector<int>>& types) {\\n    int dp[1001] = {1}, mod = 1000000007;\\n    for (const auto &c : types)\\n        for (int i = target; i >= 0; --i)\\n            for (int v = c[1]; v <= c[0] * c[1] && i - v >= 0; v += c[1])\\n                dp[i] = (dp[i] + dp[i - v]) % mod;\\n    return dp[target];\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint waysToReachTarget(int target, vector<vector<int>>& types) {\\n    int dp[1001] = {1}, mod = 1000000007;\\n    for (const auto &c : types)\\n        for (int i = target; i >= 0; --i)\\n            for (int v = c[1]; v <= c[0] * c[1] && i - v >= 0; v += c[1])\\n                dp[i] = (dp[i] + dp[i - v]) % mod;\\n    return dp[target];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3259413,
                "title": "white-board-solution-dp-knapsack-video-solution-intution",
                "content": "# Video Solution\\nhttps://www.youtube.com/watch?v=n4ARPujScnk\\n\\n# Approach & Intution\\n<!-- Describe your approach to solving the problem. -->\\n![image.png](https://assets.leetcode.com/users/images/dfc895c6-6e0b-4f45-8ef2-533a4de8fd1f_1678004411.645218.png)\\n![image.png](https://assets.leetcode.com/users/images/c69aec4a-389b-4ece-9714-d70e975c56da_1678004420.4441066.png)\\n![image.png](https://assets.leetcode.com/users/images/bb2ecb17-3d42-47e9-8711-cfda42480c3c_1678004425.4564896.png)\\n![image.png](https://assets.leetcode.com/users/images/d1203348-fad9-4ef5-ab68-1fad81e1d6d0_1678004431.3208816.png)\\n![image.png](https://assets.leetcode.com/users/images/847124a8-4c90-4058-9e6b-c1a944a651ed_1678004439.3327928.png)\\n![image.png](https://assets.leetcode.com/users/images/3e15c5dd-d321-4560-994e-cfdf22a23bb0_1678004451.1287217.png)\\n![image.png](https://assets.leetcode.com/users/images/1d9fc0e5-032a-4a8a-aa5a-67fd7ebaf539_1678004463.0245879.png)\\n\\n\\n\\n# Complexity\\nTime O(target * n * count)\\nSpace O(target)\\n\\n# Code\\n```\\n#define mod 1000000007;\\n\\nclass Solution {\\npublic:\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        vector<int> dp(target+1, 0);\\n        dp[0] = 1;\\n        \\n        for(auto t : types){\\n            int counts = t[0];\\n            int marks = t[1];\\n            \\n            for(int i=target; i>=1; i--){\\n                for(int count=1; count <= counts; count++){\\n                    if(i-marks*count >= 0)\\n                        dp[i] = (dp[i] + dp[i - marks*count])%mod;\\n                }\\n            }\\n        }\\n        \\n        return dp[target];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define mod 1000000007;\\n\\nclass Solution {\\npublic:\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        vector<int> dp(target+1, 0);\\n        dp[0] = 1;\\n        \\n        for(auto t : types){\\n            int counts = t[0];\\n            int marks = t[1];\\n            \\n            for(int i=target; i>=1; i--){\\n                for(int count=1; count <= counts; count++){\\n                    if(i-marks*count >= 0)\\n                        dp[i] = (dp[i] + dp[i - marks*count])%mod;\\n                }\\n            }\\n        }\\n        \\n        return dp[target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258226,
                "title": "c-solution-using-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    long long dp[52][1050];\\n    long long find(vector<vector<int>>&nums,int index,int target)\\n    {\\n        if(index>=nums.size())\\n        {\\n            return target==0;\\n        }\\n        if(target<0)\\n        {\\n            return 0;\\n        }\\n        if(dp[index][target]!=-1)\\n        {\\n            return dp[index][target]%mod;\\n        }\\n        long long ans=find(nums,index+1,target);\\n        for(int i=0;i<nums[index][0];i++)\\n        {\\n            if(target-(i+1)*nums[index][1]>=0)\\n            {\\n                ans+=find(nums,index+1,target-(i+1)*nums[index][1]);\\n            }\\n            else\\n            {\\n                 break;\\n            }\\n        }\\n        return dp[index][target]= ans%mod;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        memset(dp,-1,sizeof(dp));\\n        return find(types,0,target)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    long long dp[52][1050];\\n    long long find(vector<vector<int>>&nums,int index,int target)\\n    {\\n        if(index>=nums.size())\\n        {\\n            return target==0;\\n        }\\n        if(target<0)\\n        {\\n            return 0;\\n        }\\n        if(dp[index][target]!=-1)\\n        {\\n            return dp[index][target]%mod;\\n        }\\n        long long ans=find(nums,index+1,target);\\n        for(int i=0;i<nums[index][0];i++)\\n        {\\n            if(target-(i+1)*nums[index][1]>=0)\\n            {\\n                ans+=find(nums,index+1,target-(i+1)*nums[index][1]);\\n            }\\n            else\\n            {\\n                 break;\\n            }\\n        }\\n        return dp[index][target]= ans%mod;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        memset(dp,-1,sizeof(dp));\\n        return find(types,0,target)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258131,
                "title": "c-very-easy-solution-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7; \\n    \\n    int cal(int i ,int n , vector<vector<int>>& types , int sum , int tar  , vector<vector<int>>& dp)\\n    {\\n        if(sum>tar)\\n            return 0 ; \\n        \\n      if(sum==tar)\\n          return 1; \\n        \\n        if(i==n)\\n        {\\n            return tar==sum; \\n        }\\n        \\n        if(dp[i][sum]!=-1)\\n            return dp[i][sum] ;\\n        \\n         int take=0 , nottake=0 ; \\n        \\n        // take\\n        for(int k=1;k<=types[i][0];k++)\\n        {\\n            \\n            take=(take+cal(i+1 , n, types , sum+k*types[i][1] , tar, dp))%mod; \\n        }\\n        nottake=(nottake+ cal(i+1 , n , types , sum , tar  ,dp ))%mod; \\n        \\n        \\n        return dp[i][sum] =  (take+nottake)%mod; \\n        \\n        \\n    }\\n    \\n    \\n    \\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        \\n        \\n      vector<vector<int>>dp(types.size() , vector<int>(target+100 , -1)) ; \\n        return cal(0 , types.size(),  types , 0 ,  target , dp  ) ;\\n        \\n        \\n        \\n    }\\n};\\n// Please Upvote\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7; \\n    \\n    int cal(int i ,int n , vector<vector<int>>& types , int sum , int tar  , vector<vector<int>>& dp)\\n    {\\n        if(sum>tar)\\n            return 0 ; \\n        \\n      if(sum==tar)\\n          return 1; \\n        \\n        if(i==n)\\n        {\\n            return tar==sum; \\n        }\\n        \\n        if(dp[i][sum]!=-1)\\n            return dp[i][sum] ;\\n        \\n         int take=0 , nottake=0 ; \\n        \\n        // take\\n        for(int k=1;k<=types[i][0];k++)\\n        {\\n            \\n            take=(take+cal(i+1 , n, types , sum+k*types[i][1] , tar, dp))%mod; \\n        }\\n        nottake=(nottake+ cal(i+1 , n , types , sum , tar  ,dp ))%mod; \\n        \\n        \\n        return dp[i][sum] =  (take+nottake)%mod; \\n        \\n        \\n    }\\n    \\n    \\n    \\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        \\n        \\n      vector<vector<int>>dp(types.size() , vector<int>(target+100 , -1)) ; \\n        return cal(0 , types.size(),  types , 0 ,  target , dp  ) ;\\n        \\n        \\n        \\n    }\\n};\\n// Please Upvote\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261412,
                "title": "c-dp-solution-using-recursion-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are asked to return the possible `number of ways` to achieve a `target` sum. So a DP approach.\\nWe subtract all possible combinations of `types` from the `target`. Finally that combination gets accepted which makes `target=0`\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere, I have sorted given 2D integer array `types` based on the `marks[i]`  values and updated the `[count[i], marks[i]]` to `[marks[i], count[i]]`. \\n\\nSorting of the 2D array according to marks is done so that if a `marks[i]` is picked, then the next `marks[j]` will be picked from `i <= j <= n-1` (0-indexed). So, there is no need to go to previous values once they are traversed.  \\n\\nComing to recursive part\\n- If `target` becomes `0`, a combination of marks is recevied and so `1` is returned.\\n- If `target` becomes less than `0`, no possible combination further can achieve the required result, so returned `0`.\\n- Then for each possible count of `types[i]`, we check if a combination is possible that makes `target=0` . So in a loop where `j` is from `0` to `count[i]`, we pick `j` counts of `marks[i]` (So `tmp = j*marks[i]` is subtracted from `target`) and call EarnPoints function with updated `target`.\\n- Finally ans variable stores the result which is modular addition of `ans` and function call.\\n\\nThe entry `dp[i][tar]` represents the number of ways to make the sum `tar` using the first `i` items.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this dynamic programming (DP) code is `O(n * k * max_q)`, where `n` is the number of types, `k` is the target sum, and `max_q` is the maximum quantity of any type.\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is `O(len(types) * target)`.\\n\\n# Code\\n```\\nclass Solution {\\n\\npublic:\\n    \\n    int ModAdd(int a, int b){\\n        a=a%1000000007;\\n        b=b%1000000007;\\n        return ((((a+b)%1000000007)+1000000007)%1000000007);\\n    }\\n    \\n    int EarnPoints(int i, int tar, int n, vector<vector<int>> &vv, vector<vector<int>> &dp){\\n    if(tar==0){\\n        return 1;\\n    }\\n    if(tar<0 || i==n){\\n        return 0;\\n    }\\n    if(dp[i][tar]!=-1){\\n        return dp[i][tar];\\n    }\\n    int ans=0;\\n    for(int j=0; j<=vv[i][1]; ++j){\\n        int tmp=j*vv[i][0];\\n        ans=ModAdd(ans, EarnPoints(i+1, tar-tmp, n, vv, dp));\\n    }\\n    return dp[i][tar]=ans;\\n}\\n    \\npublic:\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int i, n=types.size();\\n        for(i=0; i<n; ++i){\\n            reverse(types[i].begin(), types[i].end());\\n        }\\n        sort(types.begin(), types.end());\\n        vector<vector<int>> dp(n, vector<int>(target+1, -1));\\n        int ans=EarnPoints(0, target, n, types, dp);\\n        return ans%1000000007;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Sort",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    \\n    int ModAdd(int a, int b){\\n        a=a%1000000007;\\n        b=b%1000000007;\\n        return ((((a+b)%1000000007)+1000000007)%1000000007);\\n    }\\n    \\n    int EarnPoints(int i, int tar, int n, vector<vector<int>> &vv, vector<vector<int>> &dp){\\n    if(tar==0){\\n        return 1;\\n    }\\n    if(tar<0 || i==n){\\n        return 0;\\n    }\\n    if(dp[i][tar]!=-1){\\n        return dp[i][tar];\\n    }\\n    int ans=0;\\n    for(int j=0; j<=vv[i][1]; ++j){\\n        int tmp=j*vv[i][0];\\n        ans=ModAdd(ans, EarnPoints(i+1, tar-tmp, n, vv, dp));\\n    }\\n    return dp[i][tar]=ans;\\n}\\n    \\npublic:\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int i, n=types.size();\\n        for(i=0; i<n; ++i){\\n            reverse(types[i].begin(), types[i].end());\\n        }\\n        sort(types.begin(), types.end());\\n        vector<vector<int>> dp(n, vector<int>(target+1, -1));\\n        int ans=EarnPoints(0, target, n, types, dp);\\n        return ans%1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258126,
                "title": "6310-number-of-ways-to-earn-points-java-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int waysToReachTarget(int target, int[][] types) {\\n    int n = types.length;\\n    int mod = 1000000007;\\n    int[] dp = new int[target + 1];\\n    dp[0] = 1;\\n    for (int i = 0; i < n; i++) {\\n        int count = types[i][0];\\n        int mark = types[i][1];\\n        for (int j = target; j >= mark; j--) {\\n            for (int k = 1; k <= count && j - k * mark >= 0; k++) {\\n                dp[j] = (dp[j] + dp[j - k * mark]) % mod;\\n            }\\n        }\\n    }\\n    return dp[target];     \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int waysToReachTarget(int target, int[][] types) {\\n    int n = types.length;\\n    int mod = 1000000007;\\n    int[] dp = new int[target + 1];\\n    dp[0] = 1;\\n    for (int i = 0; i < n; i++) {\\n        int count = types[i][0];\\n        int mark = types[i][1];\\n        for (int j = target; j >= mark; j--) {\\n            for (int k = 1; k <= count && j - k * mark >= 0; k++) {\\n                dp[j] = (dp[j] + dp[j - k * mark]) % mod;\\n            }\\n        }\\n    }\\n    return dp[target];     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3458045,
                "title": "my-01-knapsack-solution-c-easy-to-understand-recursive-memoised-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere\\'s a step-by-step breakdown of the code:\\n\\nThe first line declares a class called Solution.\\n\\nThe using statement declares an alias for unsigned long long called ull.\\n\\nThe solve function is a recursive function that takes four arguments: nums, size, target, and dp.\\n\\nnums is a 2D vector representing the numbers that can be used and their respective frequencies. Each row of the vector contains two elements: the first element is the frequency of the number, and the second element is the value of the number.\\n\\nsize is the size of the nums vector, which is used to determine the base case of the recursion.\\n\\ntarget is the target sum that needs to be reached.\\n\\ndp is a 2D vector that is used to store the results of subproblems to avoid recomputing them. It is initialized to -1.\\n\\nThe first conditional statement checks if the current subproblem has already been computed and stored in the dp array. If so, it returns the stored result.\\n\\nThe second conditional statement checks if the target sum has been reached. If so, it returns 1 since there is only one way to reach the target sum.\\n\\nThe third conditional statement checks if there are no more numbers left to use. If so, it returns 0 since it is impossible to reach the target sum using the remaining numbers.\\n\\nThe take variable is initialized to 0 and is used to store the number of ways to reach the target sum by taking the current number.\\n\\nThe for loop iterates from 1 to the frequency of the current number (nums[size-1][0]) and checks if using i instances of the current number does not exceed the target sum. If so, it recursively calls solve with a reduced size (size-1) and a reduced target sum (target-i*nums[size-1][1]). It then adds the result to take.\\n\\nThe notTake variable is assigned the result of recursively calling solve with a reduced size (size-1) and the same target sum (target).\\n\\nThe final return statement stores the sum of take and notTake in the dp array at the current subproblem index and returns the sum modulo 1000000007.\\n\\nThe waysToReachTarget function takes two arguments: target and types.\\n\\nIt initializes the dp array with dimensions 51 and 1001.\\n\\nIt returns the result of calling the solve function with types, types.size(), target, and dp.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    using ull = unsigned long long;\\n    unsigned long long solve(vector<vector<int>>& nums,int size,int target,vector<vector<ull>>& dp){\\n        if(dp[size][target]!=-1){\\n            return dp[size][target];\\n        }\\n        if(target==0){\\n            return 1;\\n        }\\n        if(size==0){\\n            return 0;\\n        }\\n        unsigned long long take=0;\\n        for(int i=1;i<=nums[size-1][0];i++){\\n            if(i*nums[size-1][1]<=target){\\n                take += solve(nums,size-1,target-i*nums[size-1][1],dp)%1000000007;\\n            }\\n        }\\n        unsigned long long notTake = solve(nums,size-1,target,dp)%1000000007;\\n        return dp[size][target]=(take+notTake)%1000000007;\\n\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        vector<vector<ull>> dp(51,vector<ull>(1001,-1));\\n        return solve(types,types.size(),target,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using ull = unsigned long long;\\n    unsigned long long solve(vector<vector<int>>& nums,int size,int target,vector<vector<ull>>& dp){\\n        if(dp[size][target]!=-1){\\n            return dp[size][target];\\n        }\\n        if(target==0){\\n            return 1;\\n        }\\n        if(size==0){\\n            return 0;\\n        }\\n        unsigned long long take=0;\\n        for(int i=1;i<=nums[size-1][0];i++){\\n            if(i*nums[size-1][1]<=target){\\n                take += solve(nums,size-1,target-i*nums[size-1][1],dp)%1000000007;\\n            }\\n        }\\n        unsigned long long notTake = solve(nums,size-1,target,dp)%1000000007;\\n        return dp[size][target]=(take+notTake)%1000000007;\\n\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        vector<vector<ull>> dp(51,vector<ull>(1001,-1));\\n        return solve(types,types.size(),target,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268811,
                "title": "recursion-memoization-tabulation-c",
                "content": "Recursion\\n```\\n    \\n    int solve(int ind, vector<vector<int>> &vec, int target) {\\n        if (target == 0) {\\n            return 1;\\n        }\\n        \\n        if (target < 0 or vec.size() == ind) {\\n            return 0;\\n        }\\n \\n        // decide to solve this one\\n        int take = 0; \\n        \\n        for (int i = 1; i <= vec[ind][0]; i++) {\\n            int sum = target - (i * vec[ind][1]);\\n            if (sum >= 0) \\n                take += solve(ind + 1, vec, sum);\\n            \\n            take %= mod;\\n        }\\n        \\n        // decide not to take\\n        int notTake = solve(ind + 1, vec, target);\\n        \\n        return (take + notTake) % mod;\\n    }\\n\\t\\n\\tint waysToReachTarget(int T, vector<vector<int>>& types) {\\n        int n = types.size();\\n        return solve(0, types, target);\\n    }\\n```\\n\\nMemoization\\n\\n```\\n    int solve(int ind, vector<vector<int>> &vec, int target, vector<vector<int>> &dp) {\\n        if (target == 0) {\\n            return 1;\\n        }\\n        \\n        if (target < 0 or vec.size() == ind) {\\n            return 0;\\n        }\\n \\n        if (dp[ind][target] != -1)\\n            return dp[ind][target];\\n        \\n        // decide to solve this one\\n        int take = 0; \\n        \\n        for (int i = 1; i <= vec[ind][0]; i++) {\\n            int sum = target - (i * vec[ind][1]);\\n            if (sum >= 0) \\n                take += solve(ind + 1, vec, sum, dp);\\n            \\n            take %= mod;\\n        }\\n        \\n        // decide not to take\\n        int notTake = solve(ind + 1, vec, target, dp);\\n        \\n        return dp[ind][target] = (take + notTake) % mod;\\n    }\\n\\t\\n\\tint waysToReachTarget(int T, vector<vector<int>>& types) {\\n        int n = types.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(T + 1));\\n        return solve(0, types, target, dp);\\n    }\\n```\\n\\nTabulation\\n```\\n    int waysToReachTarget(int T, vector<vector<int>>& types) {\\n        int n = types.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(T + 1));\\n        \\n        for (int i = 0; i <= n; i++) dp[i][0] = 1;\\n        \\n        for (int ind = n - 1; ind >= 0; ind--) {\\n            for (int target = 1; target <= T; target++) {\\n                int take = 0; \\n        \\n                for (int i = 1; i <= types[ind][0]; i++) {\\n                    int sum = target - (i * types[ind][1]);\\n                    if (sum >= 0) \\n                        take += dp[ind + 1][sum];\\n\\n                    take %= mod;\\n                }\\n\\n                int notTake = dp[ind + 1][target];\\n\\n                dp[ind][target] = (take + notTake) % mod;\\n            }\\n        }\\n        \\n        \\n        return dp[0][T];\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n    \\n    int solve(int ind, vector<vector<int>> &vec, int target) {\\n        if (target == 0) {\\n            return 1;\\n        }\\n        \\n        if (target < 0 or vec.size() == ind) {\\n            return 0;\\n        }\\n \\n        // decide to solve this one\\n        int take = 0; \\n        \\n        for (int i = 1; i <= vec[ind][0]; i++) {\\n            int sum = target - (i * vec[ind][1]);\\n            if (sum >= 0) \\n                take += solve(ind + 1, vec, sum);\\n            \\n            take %= mod;\\n        }\\n        \\n        // decide not to take\\n        int notTake = solve(ind + 1, vec, target);\\n        \\n        return (take + notTake) % mod;\\n    }\\n\\t\\n\\tint waysToReachTarget(int T, vector<vector<int>>& types) {\\n        int n = types.size();\\n        return solve(0, types, target);\\n    }\\n```\n```\\n    int solve(int ind, vector<vector<int>> &vec, int target, vector<vector<int>> &dp) {\\n        if (target == 0) {\\n            return 1;\\n        }\\n        \\n        if (target < 0 or vec.size() == ind) {\\n            return 0;\\n        }\\n \\n        if (dp[ind][target] != -1)\\n            return dp[ind][target];\\n        \\n        // decide to solve this one\\n        int take = 0; \\n        \\n        for (int i = 1; i <= vec[ind][0]; i++) {\\n            int sum = target - (i * vec[ind][1]);\\n            if (sum >= 0) \\n                take += solve(ind + 1, vec, sum, dp);\\n            \\n            take %= mod;\\n        }\\n        \\n        // decide not to take\\n        int notTake = solve(ind + 1, vec, target, dp);\\n        \\n        return dp[ind][target] = (take + notTake) % mod;\\n    }\\n\\t\\n\\tint waysToReachTarget(int T, vector<vector<int>>& types) {\\n        int n = types.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(T + 1));\\n        return solve(0, types, target, dp);\\n    }\\n```\n```\\n    int waysToReachTarget(int T, vector<vector<int>>& types) {\\n        int n = types.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(T + 1));\\n        \\n        for (int i = 0; i <= n; i++) dp[i][0] = 1;\\n        \\n        for (int ind = n - 1; ind >= 0; ind--) {\\n            for (int target = 1; target <= T; target++) {\\n                int take = 0; \\n        \\n                for (int i = 1; i <= types[ind][0]; i++) {\\n                    int sum = target - (i * types[ind][1]);\\n                    if (sum >= 0) \\n                        take += dp[ind + 1][sum];\\n\\n                    take %= mod;\\n                }\\n\\n                int notTake = dp[ind + 1][target];\\n\\n                dp[ind][target] = (take + notTake) % mod;\\n            }\\n        }\\n        \\n        \\n        return dp[0][T];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3259640,
                "title": "simple-solution-python",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n * target * count)$$ \\n\\n\\n\\n- Space complexity:\\n$$O(target)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\\n        mod = 10**9 + 7\\n        dp = [0]*(target + 1)\\n        dp[0] = 1\\n\\n        for count, mark in types:\\n            # Repeat in reverse order to avoid duplication \\n            for i in range(target, -1, -1):\\n                for j in range(1, count + 1):\\n                    if i - mark*j >= 0:\\n                        dp[i] += dp[i - mark*j]\\n                        dp[i] %= mod\\n        \\n        return dp[target]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\\n        mod = 10**9 + 7\\n        dp = [0]*(target + 1)\\n        dp[0] = 1\\n\\n        for count, mark in types:\\n            # Repeat in reverse order to avoid duplication \\n            for i in range(target, -1, -1):\\n                for j in range(1, count + 1):\\n                    if i - mark*j >= 0:\\n                        dp[i] += dp[i - mark*j]\\n                        dp[i] %= mod\\n        \\n        return dp[target]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258379,
                "title": "simple-c-recursion-memoization-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        vector<vector<vector<int>>> memo(1001, vector<vector<int>>(51, vector<int> (51, -1)));\\n        return dfs(target, types, 0, 0, memo);\\n    }\\n    int dfs(int target, vector<vector<int>>& types, int i, int j, vector<vector<vector<int>>>& memo) {\\n        if (target < 0 || i == types.size() || j > types[i][0]) return 0;\\n        if (target == 0) {\\n            return 1;\\n        }\\n        if (memo[target][i][j] != -1) return memo[target][i][j];\\n\\n        int ways = 0;\\n        ways+= dfs(target - types[i][1], types, i, j + 1, memo);\\n        ways+= dfs(target, types, i + 1, 0, memo);\\n        ways %= (1000000000 + 7);\\n        memo[target][i][j] = ways;\\n        return ways;  \\n    }\\n    \\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        vector<vector<vector<int>>> memo(1001, vector<vector<int>>(51, vector<int> (51, -1)));\\n        return dfs(target, types, 0, 0, memo);\\n    }\\n    int dfs(int target, vector<vector<int>>& types, int i, int j, vector<vector<vector<int>>>& memo) {\\n        if (target < 0 || i == types.size() || j > types[i][0]) return 0;\\n        if (target == 0) {\\n            return 1;\\n        }\\n        if (memo[target][i][j] != -1) return memo[target][i][j];\\n\\n        int ways = 0;\\n        ways+= dfs(target - types[i][1], types, i, j + 1, memo);\\n        ways+= dfs(target, types, i + 1, 0, memo);\\n        ways %= (1000000000 + 7);\\n        memo[target][i][j] = ways;\\n        return ways;  \\n    }\\n    \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258315,
                "title": "python3-bottom-up-dp",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/e3093716659ec141e47ca013abcf405967592686) for solutions of weekly 335. \\n\\n**Intuition**\\nDefine `dp[i][j]` as the number of ways to earn `i` points using questions starting from `j` forward. \\n* The recurrence relationship is `dp[i][j] = dp[i-x*m][j+1]` for all `x = 0, 1, 2, ..., c` and `i-x*m >= 0` where `c` is count of questions of type `j` and `m` is mark of questions of type `j`. \\n* What\\'s asked is to compute `dp[target][0]`. \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\\n        n = len(types)\\n        dp = [[0]*(1+n) for _ in range(target+1)]\\n        for j in range(n+1): dp[0][j] = 1\\n        for i in range(1, target+1): \\n            for j in range(n-1, -1, -1): \\n                c, m = types[j]\\n                for x in range(c+1): \\n                    if i - x*m >= 0: dp[i][j] += dp[i-x*m][j+1]\\n                    else: break \\n                dp[i][j] %= 1_000_000_007\\n        return dp[target][0]\\n```\\n**Complexity**\\nTime `O(MN)`\\nSpace `O(MN)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\\n        n = len(types)\\n        dp = [[0]*(1+n) for _ in range(target+1)]\\n        for j in range(n+1): dp[0][j] = 1\\n        for i in range(1, target+1): \\n            for j in range(n-1, -1, -1): \\n                c, m = types[j]\\n                for x in range(c+1): \\n                    if i - x*m >= 0: dp[i][j] += dp[i-x*m][j+1]\\n                    else: break \\n                dp[i][j] %= 1_000_000_007\\n        return dp[target][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258188,
                "title": "java-using-backtracking-memoization",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int waysToReachTarget(int target, int[][] types) {\\n        int[][] memo = new int[target + 1][types.length + 1];\\n        for (int[] ints : memo) {\\n            Arrays.fill(ints, -1);\\n        }\\n        return (int) backtrack(target, types, 0, memo);\\n    }\\n    \\n    private long backtrack(int target, int[][] types, int start, int[][] memo) {\\n        if (target == 0) {\\n            return 1;\\n        }\\n        if (target < 0) {\\n            return 0;\\n        }\\n        if (memo[target][start] != -1) {\\n            return memo[target][start];\\n        }\\n        long res = 0;\\n        for (int i = start; i < types.length; i++) {\\n            for (int j = 1; j <= types[i][0]; j++) {\\n                if (target - j * types[i][1] < 0) {\\n                    break;\\n                }\\n                long temp = backtrack(target - j * types[i][1], types, i + 1, memo);\\n                res = (res + temp) % 1_000_000_007;\\n            }\\n        }\\n        memo[target][start] = (int) res;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int waysToReachTarget(int target, int[][] types) {\\n        int[][] memo = new int[target + 1][types.length + 1];\\n        for (int[] ints : memo) {\\n            Arrays.fill(ints, -1);\\n        }\\n        return (int) backtrack(target, types, 0, memo);\\n    }\\n    \\n    private long backtrack(int target, int[][] types, int start, int[][] memo) {\\n        if (target == 0) {\\n            return 1;\\n        }\\n        if (target < 0) {\\n            return 0;\\n        }\\n        if (memo[target][start] != -1) {\\n            return memo[target][start];\\n        }\\n        long res = 0;\\n        for (int i = start; i < types.length; i++) {\\n            for (int j = 1; j <= types[i][0]; j++) {\\n                if (target - j * types[i][1] < 0) {\\n                    break;\\n                }\\n                long temp = backtrack(target - j * types[i][1], types, i + 1, memo);\\n                res = (res + temp) % 1_000_000_007;\\n            }\\n        }\\n        memo[target][start] = (int) res;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258135,
                "title": "memoization-tabulation-dp-c",
                "content": "# Memoization\\n```\\nclass Solution {\\n    int mod = 1e9 + 7;\\n    int dfs(int i, int t, int n, vector<vector<int>> &types, vector<vector<int>> &dp) {\\n        if(!t) return 1;\\n        if(i == n) return 0;\\n        if(dp[i][t] != -1) return dp[i][t];\\n        \\n        long long ans = 0;\\n        for(int j=0; j<=types[i][0] * types[i][1]; j += types[i][1]) {\\n            if(t - j >= 0) ans = (ans + dfs(i + 1, t - j, n, types, dp)) % mod;\\n        }\\n        return dp[i][t] = ans;\\n    }\\npublic:\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n = types.size();\\n        vector<vector<int>> dp(n, vector<int>(target + 1, -1));\\n        return dfs(0, target, n, types, dp);\\n    }\\n};\\n```\\n\\n# Tabulation\\n```\\nclass Solution {\\npublic:\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n = types.size(), mod = 1e9 + 7;\\n        vector<vector<int>> dp(n + 1, vector<int>(target + 1));\\n        for(int i=0; i<=n; i++) dp[i][0] = 1;\\n\\n        for(int i=n-1; i>=0; i--) {\\n            for(int t=target; t>=0; t--) {\\n                long long ans = 0;\\n                for(int j=0; j<=types[i][0] * types[i][1]; j += types[i][1]) {\\n                    if(t - j >= 0) ans = (ans + dp[i + 1][t - j]) % mod;\\n                }\\n                dp[i][t] = ans;\\n            }\\n        }\\n        return dp[0][target];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int mod = 1e9 + 7;\\n    int dfs(int i, int t, int n, vector<vector<int>> &types, vector<vector<int>> &dp) {\\n        if(!t) return 1;\\n        if(i == n) return 0;\\n        if(dp[i][t] != -1) return dp[i][t];\\n        \\n        long long ans = 0;\\n        for(int j=0; j<=types[i][0] * types[i][1]; j += types[i][1]) {\\n            if(t - j >= 0) ans = (ans + dfs(i + 1, t - j, n, types, dp)) % mod;\\n        }\\n        return dp[i][t] = ans;\\n    }\\npublic:\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n = types.size();\\n        vector<vector<int>> dp(n, vector<int>(target + 1, -1));\\n        return dfs(0, target, n, types, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n = types.size(), mod = 1e9 + 7;\\n        vector<vector<int>> dp(n + 1, vector<int>(target + 1));\\n        for(int i=0; i<=n; i++) dp[i][0] = 1;\\n\\n        for(int i=n-1; i>=0; i--) {\\n            for(int t=target; t>=0; t--) {\\n                long long ans = 0;\\n                for(int j=0; j<=types[i][0] * types[i][1]; j += types[i][1]) {\\n                    if(t - j >= 0) ans = (ans + dp[i + 1][t - j]) % mod;\\n                }\\n                dp[i][t] = ans;\\n            }\\n        }\\n        return dp[0][target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258110,
                "title": "c-dp-memoization",
                "content": "```\\nclass Solution {\\n    int m = 1e9+7;\\n    int dp[51][1001];\\npublic:\\n    int dfs(int target, vector<vector<int>>& types, int result, int i) {\\n        \\n        if(target == result)return 1;\\n        if(result > target)return 0;\\n        if(i >= size(types))return 0;\\n        \\n        if(dp[i][result] != -1)return dp[i][result];\\n        \\n        int res = 0, marks = 0;\\n        \\n        for(int j = 0; j <= types[i][0]; j++) {\\n            \\n            res = (res + dfs(target,types,result+marks,i+1))%m;\\n            \\n            marks += types[i][1];\\n        }\\n        \\n        return dp[i][result] =  res;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        \\n        memset(dp,-1,sizeof dp);\\n        \\n        return dfs(target,types,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int m = 1e9+7;\\n    int dp[51][1001];\\npublic:\\n    int dfs(int target, vector<vector<int>>& types, int result, int i) {\\n        \\n        if(target == result)return 1;\\n        if(result > target)return 0;\\n        if(i >= size(types))return 0;\\n        \\n        if(dp[i][result] != -1)return dp[i][result];\\n        \\n        int res = 0, marks = 0;\\n        \\n        for(int j = 0; j <= types[i][0]; j++) {\\n            \\n            res = (res + dfs(target,types,result+marks,i+1))%m;\\n            \\n            marks += types[i][1];\\n        }\\n        \\n        return dp[i][result] =  res;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        \\n        memset(dp,-1,sizeof dp);\\n        \\n        return dfs(target,types,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585829,
                "title": "easy-to-understand-java-dp-solution",
                "content": "dyn# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int mod=(int)Math.pow(10,9)+7;\\n    public int waysToReachTarget(int target, int[][] types) {\\n        int n=types.length;\\n        int dp[][]=new int[n][target+1];\\n        for(int i=0;i<n;i++)\\n        {\\n            Arrays.fill(dp[i],-1);\\n        }\\n        return solve(n-1,target,types,dp);\\n    }\\n    public int solve(int ind,int target,int types[][],int[][]dp)\\n    {\\n        if(target==0)\\n        {\\n            return 1;\\n        }\\n        if(ind<0)\\n        {\\n            return 0;\\n        }\\n        if(dp[ind][target]!=-1)\\n        {\\n            return dp[ind][target]%mod;\\n\\n        }\\n        int ans=0;\\n        for(int i=0;i<=types[ind][0];i++)\\n        {\\n            if(i*types[ind][1]<=target)\\n                ans=((ans%mod)+solve(ind-1,target-(i*types[ind][1]),types,dp)%mod)%mod;\\n        }\\n        return dp[ind][target]=ans%mod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int mod=(int)Math.pow(10,9)+7;\\n    public int waysToReachTarget(int target, int[][] types) {\\n        int n=types.length;\\n        int dp[][]=new int[n][target+1];\\n        for(int i=0;i<n;i++)\\n        {\\n            Arrays.fill(dp[i],-1);\\n        }\\n        return solve(n-1,target,types,dp);\\n    }\\n    public int solve(int ind,int target,int types[][],int[][]dp)\\n    {\\n        if(target==0)\\n        {\\n            return 1;\\n        }\\n        if(ind<0)\\n        {\\n            return 0;\\n        }\\n        if(dp[ind][target]!=-1)\\n        {\\n            return dp[ind][target]%mod;\\n\\n        }\\n        int ans=0;\\n        for(int i=0;i<=types[ind][0];i++)\\n        {\\n            if(i*types[ind][1]<=target)\\n                ans=((ans%mod)+solve(ind-1,target-(i*types[ind][1]),types,dp)%mod)%mod;\\n        }\\n        return dp[ind][target]=ans%mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315887,
                "title": "simple-recursion-and-memoization-with-comments",
                "content": "\\n```\\nclass Solution {int m=1000000007;\\n    public int waysToReachTarget(int target, int[][] types) {int ans=0;\\n                     int dp[][]=new int[types.length+1][target+1];//Making an array for storing the number of ways of achieving  particular target at an index\\n                    for(int ar[]:dp){Arrays.fill(ar,-1);}//initially filling the array with -1;\\n                                                             ans=(ans+find(0,types,dp,0,target))%m;\\n                                                             return ans;\\n    }\\n    int find(int j,int[][]type,int dp[][],int sum,int target){ \\n        if(sum==target){ //sum of elements equals to target then add 1 to ans\\n            return 1;}\\n        if(j==type.length){return 0;}\\n        if(sum>target){return 0 ;}//sum is greater then target then no way to get way from it so return 0\\n        if(dp[j][sum]!=-1){\\n            return dp[j][sum];//already calculated the value \\n        }\\n        int ans=0;\\n        ans+=find(j+1,type,dp,sum,target);//not taking any value from present index marks\\n        for(int i=1;i<=type[j][0];i++){\\n           ans=(ans+find(j+1,type,dp,sum+(type[j][1]*i),target))%m;//consider each possible way to get sum equals to target\\n        }\\n        return dp[j][sum]=ans;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {int m=1000000007;\\n    public int waysToReachTarget(int target, int[][] types) {int ans=0;\\n                     int dp[][]=new int[types.length+1][target+1];//Making an array for storing the number of ways of achieving  particular target at an index\\n                    for(int ar[]:dp){Arrays.fill(ar,-1);}//initially filling the array with -1;\\n                                                             ans=(ans+find(0,types,dp,0,target))%m;\\n                                                             return ans;\\n    }\\n    int find(int j,int[][]type,int dp[][],int sum,int target){ \\n        if(sum==target){ //sum of elements equals to target then add 1 to ans\\n            return 1;}\\n        if(j==type.length){return 0;}\\n        if(sum>target){return 0 ;}//sum is greater then target then no way to get way from it so return 0\\n        if(dp[j][sum]!=-1){\\n            return dp[j][sum];//already calculated the value \\n        }\\n        int ans=0;\\n        ans+=find(j+1,type,dp,sum,target);//not taking any value from present index marks\\n        for(int i=1;i<=type[j][0];i++){\\n           ans=(ans+find(j+1,type,dp,sum+(type[j][1]*i),target))%m;//consider each possible way to get sum equals to target\\n        }\\n        return dp[j][sum]=ans;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260267,
                "title": "memoized-solution-in-java",
                "content": "# Intuition\\nIt is a problem where we can pick from 0 to number of question of certain type for each given type. \\n\\n# Approach\\nWe can use recursion to do the job either picking the element from count 0 to number of available questions. The we can memoize the same solution\\n\\n# Code\\n```\\nclass Solution {\\n    int mod = 1000000007;\\n    int solve(int[][] types, int i, int n, int target, int[][] dp){\\n        if(target == 0){\\n            return 1;\\n        }\\n        if(i == n){\\n            return 0;\\n        }\\n        if(dp[i][target] != -1){\\n            return dp[i][target]%mod;\\n        }\\n        int currC = types[i][0];\\n        int currV = types[i][1];\\n        int ans = 0;\\n        for(int j=0; j<=currC; j++){\\n            int cv = currV*j;\\n            if(target - cv >= 0){\\n                ans = (ans%mod + solve(types, i+1, n, target - cv, dp)%mod)%mod;\\n            }\\n        }\\n        return dp[i][target] = ans;\\n    }\\n    public int waysToReachTarget(int target, int[][] types) {\\n        int n = types.length;\\n        int[][] dp = new int[n+1][target+1];\\n        for(int[]item: dp){\\n            Arrays.fill(item, -1);\\n        }\\n        return solve(types, 0, n, target, dp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int mod = 1000000007;\\n    int solve(int[][] types, int i, int n, int target, int[][] dp){\\n        if(target == 0){\\n            return 1;\\n        }\\n        if(i == n){\\n            return 0;\\n        }\\n        if(dp[i][target] != -1){\\n            return dp[i][target]%mod;\\n        }\\n        int currC = types[i][0];\\n        int currV = types[i][1];\\n        int ans = 0;\\n        for(int j=0; j<=currC; j++){\\n            int cv = currV*j;\\n            if(target - cv >= 0){\\n                ans = (ans%mod + solve(types, i+1, n, target - cv, dp)%mod)%mod;\\n            }\\n        }\\n        return dp[i][target] = ans;\\n    }\\n    public int waysToReachTarget(int target, int[][] types) {\\n        int n = types.length;\\n        int[][] dp = new int[n+1][target+1];\\n        for(int[]item: dp){\\n            Arrays.fill(item, -1);\\n        }\\n        return solve(types, 0, n, target, dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260069,
                "title": "c-simplest-solution-recursion-memoization-knapsack-pattern-dynamic-programming",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(int ind, int target, vector<int>& ques, vector<int>& marks, int n, vector<vector<int>> & dp) {\\n        int mod = 1e9 + 7;\\n        if (target == 0) return 1;\\n        if (target < 0 || ind < 0) return 0;\\n        if (dp[ind][target] != -1) return dp[ind][target];\\n        int ans = 0;\\n        for (int i=0; i<=ques[ind]; i++) {\\n            ans = (ans + dfs(ind-1, target-marks[ind]*i, ques, marks, n, dp))% mod;\\n        }\\n        return dp[ind][target] = ans;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n = types.size();\\n        vector<int> ques, marks;\\n        vector<vector<int>> dp(n, vector<int>(target+1, -1));\\n        for (auto &type:types) {\\n            ques.emplace_back(type[0]);\\n            marks.emplace_back(type[1]);\\n        }\\n        return dfs(n-1, target, ques, marks, n, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int ind, int target, vector<int>& ques, vector<int>& marks, int n, vector<vector<int>> & dp) {\\n        int mod = 1e9 + 7;\\n        if (target == 0) return 1;\\n        if (target < 0 || ind < 0) return 0;\\n        if (dp[ind][target] != -1) return dp[ind][target];\\n        int ans = 0;\\n        for (int i=0; i<=ques[ind]; i++) {\\n            ans = (ans + dfs(ind-1, target-marks[ind]*i, ques, marks, n, dp))% mod;\\n        }\\n        return dp[ind][target] = ans;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n = types.size();\\n        vector<int> ques, marks;\\n        vector<vector<int>> dp(n, vector<int>(target+1, -1));\\n        for (auto &type:types) {\\n            ques.emplace_back(type[0]);\\n            marks.emplace_back(type[1]);\\n        }\\n        return dfs(n-1, target, ques, marks, n, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258381,
                "title": "c-recursive-memoization-iterative",
                "content": "**RECURSIVE + MEMOIZATION**\\n```\\nclass Solution {\\npublic:\\n   int mod=1e9+7;\\n    int solve(int idx,int target,vector<vector<int>>& types,vector<vector<int>>& dp)\\n    {\\n        if(target<0) return 0;\\n        if(idx==types.size())\\n        {\\n            return target==0;\\n        }\\n        if(dp[idx][target]!=-1)\\n            return dp[idx][target];\\n        int ans=0;\\n        for(int i=0;i<=types[idx][0];i++)\\n        {\\n            ans=(ans+solve(idx+1,target-i*types[idx][1],types,dp))%mod;\\n            \\n        }\\n        return dp[idx][target]=ans%mod;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n=types.size();\\n        vector<vector<int>> dp(n+1,vector<int>(target+1,-1));\\n        return solve(0,target,types,dp);\\n        \\n    }\\n};\\n```\\n\\n**ITERATIVE**\\n```\\nclass Solution {\\npublic:\\n   \\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n=types.size();\\n        int mod=1e9+7;\\n        vector<int> dp(target+1,0);\\n        dp[0]=1;\\n        for(int i=0;i<types.size();i++)\\n        {\\n            for(int j=target;j>=0;j--)\\n            {\\n                int val=types[i][0];\\n                for(int k=1;k<=val;k++)\\n                {\\n                    int cnt=types[i][1];\\n                    if(j-k*cnt>=0)\\n                    dp[j]=(dp[j]+dp[j-k*cnt])%mod;\\n                }\\n            }\\n        }\\n        return dp[target]%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int mod=1e9+7;\\n    int solve(int idx,int target,vector<vector<int>>& types,vector<vector<int>>& dp)\\n    {\\n        if(target<0) return 0;\\n        if(idx==types.size())\\n        {\\n            return target==0;\\n        }\\n        if(dp[idx][target]!=-1)\\n            return dp[idx][target];\\n        int ans=0;\\n        for(int i=0;i<=types[idx][0];i++)\\n        {\\n            ans=(ans+solve(idx+1,target-i*types[idx][1],types,dp))%mod;\\n            \\n        }\\n        return dp[idx][target]=ans%mod;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n=types.size();\\n        vector<vector<int>> dp(n+1,vector<int>(target+1,-1));\\n        return solve(0,target,types,dp);\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n   \\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n=types.size();\\n        int mod=1e9+7;\\n        vector<int> dp(target+1,0);\\n        dp[0]=1;\\n        for(int i=0;i<types.size();i++)\\n        {\\n            for(int j=target;j>=0;j--)\\n            {\\n                int val=types[i][0];\\n                for(int k=1;k<=val;k++)\\n                {\\n                    int cnt=types[i][1];\\n                    if(j-k*cnt>=0)\\n                    dp[j]=(dp[j]+dp[j-k*cnt])%mod;\\n                }\\n            }\\n        }\\n        return dp[target]%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258165,
                "title": "easy-memoization-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n\\t// simple choice dp , take or don\\'t take\\t\\n    long long dp[1001][1001];\\n    int mod = 1000000007;\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,target,types);\\n    }\\n    long long solve(int pos,int target,vector<vector<int>> &types) {\\n         if(target==0) return 1;  // found a valid subset\\n         if(target<0 || pos>=types.size()) return 0;\\n         long long sm = 0;\\n         if(dp[pos][target]!=-1) return dp[pos][target];\\n\\t\\t // if you take 1..ith question of a type..\\n\\t\\t // then you solve for the state [pos+1] and [target - (question type value * i(number of questions taken)] \\n         for(int i=1; i<=types[pos][0]; i++) sm = (sm + solve(pos+1,target-(types[pos][1] * i),types)) % mod; \\n         sm = (sm + solve(pos+1,target,types)) % mod;  // skip this question type\\n         return dp[pos][target] = sm;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t// simple choice dp , take or don\\'t take\\t\\n    long long dp[1001][1001];\\n    int mod = 1000000007;\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,target,types);\\n    }\\n    long long solve(int pos,int target,vector<vector<int>> &types) {\\n         if(target==0) return 1;  // found a valid subset\\n         if(target<0 || pos>=types.size()) return 0;\\n         long long sm = 0;\\n         if(dp[pos][target]!=-1) return dp[pos][target];\\n\\t\\t // if you take 1..ith question of a type..\\n\\t\\t // then you solve for the state [pos+1] and [target - (question type value * i(number of questions taken)] \\n         for(int i=1; i<=types[pos][0]; i++) sm = (sm + solve(pos+1,target-(types[pos][1] * i),types)) % mod; \\n         sm = (sm + solve(pos+1,target,types)) % mod;  // skip this question type\\n         return dp[pos][target] = sm;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258103,
                "title": "python-memoization",
                "content": "```\\nclass Solution:\\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\\n        n = len(types)\\n        \\n        @lru_cache(None)\\n        def dfs(i, total):\\n            if total == target:\\n                return 1\\n            if i == n or total > target:\\n                return 0\\n            \\n            res = 0\\n            for j in range(types[i][0]):\\n                next_total = total + types[i][1] * (j + 1)\\n                if j == 0:\\n                    res += dfs(i + 1, total) # cover case for no marks\\n                res += dfs(i + 1, next_total)\\n                \\n            return res\\n        \\n        return dfs(0, 0) % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\\n        n = len(types)\\n        \\n        @lru_cache(None)\\n        def dfs(i, total):\\n            if total == target:\\n                return 1\\n            if i == n or total > target:\\n                return 0\\n            \\n            res = 0\\n            for j in range(types[i][0]):\\n                next_total = total + types[i][1] * (j + 1)\\n                if j == 0:\\n                    res += dfs(i + 1, total) # cover case for no marks\\n                res += dfs(i + 1, next_total)\\n                \\n            return res\\n        \\n        return dfs(0, 0) % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702688,
                "title": "backtracking-memoization-dp",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def waysToReachTarget(self, target: int, arr: List[List[int]]) -> int:\\n        n = len(arr)\\n        mod = 10**9+7\\n        dp = {}\\n        def fun(ind,curr):\\n            if curr == target:\\n                return 1\\n            ans = 0\\n            if ind == n or curr>target:\\n                return ans\\n            if (ind,curr) in dp:\\n                return dp[(ind,curr)]\\n            c,m = arr[ind]\\n            for i in range(c+1):\\n                ans=(ans%mod + fun(ind+1,curr+(i*m))%mod)%mod\\n            dp[(ind,curr)] = ans\\n            return ans\\n        return fun(0,0)\\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def waysToReachTarget(self, target: int, arr: List[List[int]]) -> int:\\n        n = len(arr)\\n        mod = 10**9+7\\n        dp = {}\\n        def fun(ind,curr):\\n            if curr == target:\\n                return 1\\n            ans = 0\\n            if ind == n or curr>target:\\n                return ans\\n            if (ind,curr) in dp:\\n                return dp[(ind,curr)]\\n            c,m = arr[ind]\\n            for i in range(c+1):\\n                ans=(ans%mod + fun(ind+1,curr+(i*m))%mod)%mod\\n            dp[(ind,curr)] = ans\\n            return ans\\n        return fun(0,0)\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486253,
                "title": "2585-number-of-ways-to-earn-points-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem statement is to find the number of ways to reach a given target by choosing from a set of items, where each item has a weight and a count. The goal is to use the items in such a way that the sum of their weights adds up to the target. We are required to find the number of ways we can do so.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in the given code is a recursive approach with memoization. The main idea is to try every possible combination of the items to reach the target and count the number of ways to do so. We start with the target value and subtract the weight of each item until we reach zero or a negative value. If we reach zero, we have found a valid combination, and if we reach a negative value, we know that the combination we are trying is not valid.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(target * n)\\n\\nThe code uses memoization to avoid recomputing the same results, so the time complexity is reduced from an exponential time complexity to a polynomial time complexity.\\n\\nThe main function waysToReachTarget creates a memoization array of size (target + 1) * (n + 1) and then calls the backtrack function, which is a recursive function that calculates the number of ways to reach the target using the types array starting from a specific index.\\n\\nThe backtrack function loops through the types array and tries to use each element to reach the target. It has a nested loop that iterates from 1 to the maximum number of times the current type can be used to reach the target. The inner loop has a maximum of target iterations, so the time complexity of the loop is O(target). Inside the loop, it recursively calls itself to compute the number of ways to reach the remaining target using the remaining types, and then it accumulates the results. Since the backtrack function is called recursively for each possible combination of types, its time complexity is O(target * n).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(target * n)\\n\\nThe space complexity of the code is O(target * n), due to the memoization array. The backtrack function has a space complexity of O(target), due to the recursive calls on the call stack. Therefore, the total space complexity is dominated by the memoization array.\\n\\n# JavaScript Code\\n```\\n/**\\n * @param {number} target\\n * @param {number[][]} types\\n * @return {number}\\n */\\nfunction waysToReachTarget(target, types) {\\n  const memo = Array.from({ length: target + 1 }, () =>\\n    Array.from({ length: types.length + 1 }, () => -1),\\n  );\\n  return backtrack(target, types, 0, memo);\\n}\\n\\nfunction backtrack(target, types, start, memo) {\\n  if (target == 0) {\\n    return 1;\\n  }\\n  if (target < 0) {\\n    return 0;\\n  }\\n  if (memo[target][start] != -1) {\\n    return memo[target][start];\\n  }\\n  let res = 0;\\n  for (let i = start; i < types.length; i++) {\\n    for (let j = 1; j <= types[i][0]; j++) {\\n      if (target - j * types[i][1] < 0) {\\n        break;\\n      }\\n      const temp = backtrack(target - j * types[i][1], types, i + 1, memo);\\n      res = (res + temp) % 1_000_000_007;\\n    }\\n  }\\n  memo[target][start] = res;\\n  return res;\\n}\\n```\\n\\n`If This Helps You Really , Then Please Give Me An Up-Vote . Thank You.`",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number} target\\n * @param {number[][]} types\\n * @return {number}\\n */\\nfunction waysToReachTarget(target, types) {\\n  const memo = Array.from({ length: target + 1 }, () =>\\n    Array.from({ length: types.length + 1 }, () => -1),\\n  );\\n  return backtrack(target, types, 0, memo);\\n}\\n\\nfunction backtrack(target, types, start, memo) {\\n  if (target == 0) {\\n    return 1;\\n  }\\n  if (target < 0) {\\n    return 0;\\n  }\\n  if (memo[target][start] != -1) {\\n    return memo[target][start];\\n  }\\n  let res = 0;\\n  for (let i = start; i < types.length; i++) {\\n    for (let j = 1; j <= types[i][0]; j++) {\\n      if (target - j * types[i][1] < 0) {\\n        break;\\n      }\\n      const temp = backtrack(target - j * types[i][1], types, i + 1, memo);\\n      res = (res + temp) % 1_000_000_007;\\n    }\\n  }\\n  memo[target][start] = res;\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3358038,
                "title": "python3-solution-o-n-target-100-faster-dp",
                "content": "# Complexity\\n- Time complexity: $$O(n * target)$$\\n- Space complexity: $$O(target)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def waysToReachTarget(self, T, A):\\n        dp = [1] + [0] * T\\n        mod = 10 ** 9 + 7\\n        for c, m in A:\\n            for i in range(m, T + 1):\\n                dp[i] += dp[i - m]\\n            for i in range(T, (c + 1) * m - 1, -1):\\n                dp[i] = (dp[i] - dp[i - (c + 1) * m]) % mod\\n        return dp[-1] % mod\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def waysToReachTarget(self, T, A):\\n        dp = [1] + [0] * T\\n        mod = 10 ** 9 + 7\\n        for c, m in A:\\n            for i in range(m, T + 1):\\n                dp[i] += dp[i - m]\\n            for i in range(T, (c + 1) * m - 1, -1):\\n                dp[i] = (dp[i] - dp[i - (c + 1) * m]) % mod\\n        return dp[-1] % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284625,
                "title": "javascript-dp-122ms",
                "content": "```\\nconst mod = 1e9 + 7;\\nconst waysToReachTarget = (target, types) => {\\n    let dp = Array(target + 1).fill(0);\\n    dp[0] = 1;\\n    for (const [cnt, x] of types) {\\n        let ndp = Array(target + 1).fill(0);\\n        for (let use = 0; use <= cnt; use++) {\\n            for (let i = 0; i + use * x <= target; i++) {\\n                ndp[i + use * x] += dp[i];\\n                ndp[i + use * x] %= mod;\\n            }\\n        }\\n        dp = ndp;\\n    }\\n    return dp[target];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nconst mod = 1e9 + 7;\\nconst waysToReachTarget = (target, types) => {\\n    let dp = Array(target + 1).fill(0);\\n    dp[0] = 1;\\n    for (const [cnt, x] of types) {\\n        let ndp = Array(target + 1).fill(0);\\n        for (let use = 0; use <= cnt; use++) {\\n            for (let i = 0; i + use * x <= target; i++) {\\n                ndp[i + use * x] += dp[i];\\n                ndp[i + use * x] %= mod;\\n            }\\n        }\\n        dp = ndp;\\n    }\\n    return dp[target];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3272366,
                "title": "dart-knapsack-coin-change-memoization",
                "content": "# Code\\n```\\nclass Solution {\\n  int waysToReachTarget(int target, List<List<int>> types) {\\n    int mod = 1000000007;\\n    int n = types.length;\\n    List<List<List<int?>>> dp = List.generate(\\n        n + 1,\\n        (index) => List.generate(\\n              target + 1,\\n              (index) => List.filled(51, null),\\n            ));\\n\\n    int f(int i, int target, int count) {\\n      if (target == 0) {\\n        return 1;\\n      }\\n      if (target < 0 || i == n) {\\n        return 0;\\n      }\\n      if (dp[i][target][count] != null) {\\n        return dp[i][target][count]!;\\n      }\\n      int pick = 0;\\n      if (count - 1 >= 0) {\\n        pick = f(i, target - types[i][1], count - 1);\\n      }\\n      \\n      int notPick = 0;\\n      if (i + 1 < n) {\\n        notPick = f(i + 1, target, types[i + 1][0]);\\n      }\\n\\n      return dp[i][target][count] = (pick + notPick) % mod;\\n    }\\n\\n    return f(0, target, types[0][0]);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int waysToReachTarget(int target, List<List<int>> types) {\\n    int mod = 1000000007;\\n    int n = types.length;\\n    List<List<List<int?>>> dp = List.generate(\\n        n + 1,\\n        (index) => List.generate(\\n              target + 1,\\n              (index) => List.filled(51, null),\\n            ));\\n\\n    int f(int i, int target, int count) {\\n      if (target == 0) {\\n        return 1;\\n      }\\n      if (target < 0 || i == n) {\\n        return 0;\\n      }\\n      if (dp[i][target][count] != null) {\\n        return dp[i][target][count]!;\\n      }\\n      int pick = 0;\\n      if (count - 1 >= 0) {\\n        pick = f(i, target - types[i][1], count - 1);\\n      }\\n      \\n      int notPick = 0;\\n      if (i + 1 < n) {\\n        notPick = f(i + 1, target, types[i + 1][0]);\\n      }\\n\\n      return dp[i][target][count] = (pick + notPick) % mod;\\n    }\\n\\n    return f(0, target, types[0][0]);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266742,
                "title": "c-dynamic-programming-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStep Wise Dynamic Programming Approach\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nHere, the greedy solution would NOT work, thus we will have to try out all possible combinations.\\nFirstly, create a recursion relation . Then , optimizie it by usnig memoization . It wont work because here the Time Complexity will be extremely HIGH.\\nSecondly, we will use TABULTION : that will convert it to O (n * target * number_of_que_of_that_type) with space O(n * target). {this will work}\\nThirdly, we can further optimize it in terms of space ie from O(n*target) we can take it to O(2*target);\\n\\n![download (2).jfif](https://assets.leetcode.com/users/images/ae355fcd-4dde-4d66-af2f-f15fe27a4fb0_1678159089.8321543.jpeg)\\n\\n\\n# Complexity\\n- Time complexity   :   O (n * target * number_of_que_of_that_type)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity  :   O(2*target)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int mod = 1e9+7;\\npublic:\\n\\n    // // RECURSION + MEMOIZATION : gives TLE\\n    // int fun(int idx, int target, vector<vector<int>> arr, vector<vector<int>> &dp) {\\n\\n    //     if(idx==0)  {\\n    //         if(target%arr[0][1]==0)  {\\n    //             if(target/arr[0][1] <= arr[0][0])\\n    //                 return 1;\\n    //         }\\n    //         return 0;\\n    //     }\\n\\n    //     if(dp[idx][target]!=-1)\\n    //         return dp[idx][target];\\n\\n    //     int mxq = arr[idx][0];\\n    //     int val = arr[idx][1];\\n    //     int take = 0;\\n\\n    //     int not_take = fun(idx-1,target,arr,dp);\\n    //     for(int i=1; val*i <= target && i<=mxq; i++)  {\\n    //         int curr = fun(idx-1,target-(val*i),arr,dp);\\n    //         if(curr>0)\\n    //             take += curr;\\n    //         take %= mod;\\n    //     }\\n\\n    //     return dp[idx][target] = (take + not_take) % mod;\\n    // }\\n\\n    // int waysToReachTarget(int target, vector<vector<int>>& arr) {\\n    //     int n = arr.size();\\n\\n    //     vector<vector<int>> dp (n, vector<int> (target+1,-1));\\n\\n    //     int res = fun(n-1,target,arr,dp);\\n        \\n    //     return res>=1e8 ? -1 : res;\\n    // }\\n\\n\\n\\n\\n\\n    //  TABULATION  + SPACE OPTIMIZATION\\n    int waysToReachTarget(int target, vector<vector<int>>& arr) {\\n        int n = arr.size();\\n\\n        vector<int> prev (target+1,0);\\n        vector<int> curr (target+1,0);\\n\\n        for(int i=0; i<target+1; i++)  {\\n            if(i%arr[0][1]==0 && i/arr[0][1]<=arr[0][0])\\n                prev[i] = 1;\\n        }\\n\\n        for(int idx=1; idx<n; idx++)  {\\n            int val = arr[idx][1];\\n            int mq = arr[idx][0];\\n            for(int t=0; t<=target; t++)    {\\n                int not_take = prev[t]; \\n\\n                int take = 0;\\n                for(int i=1; val*i<=t && i<=mq ; i++)  {\\n                    int curr = prev[t-(val*i)];\\n                    take += curr;\\n                    take %= mod;\\n                }\\n\\n                curr[t] = (take + not_take) % mod;\\n            }\\n\\n            prev = curr;\\n        }\\n        \\n        return prev[target];\\n    }\\n};\\n```\\n\\n![images.jfif](https://assets.leetcode.com/users/images/ce6f9e00-da81-43cc-8a70-47f624375905_1678159116.8828201.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    int mod = 1e9+7;\\npublic:\\n\\n    // // RECURSION + MEMOIZATION : gives TLE\\n    // int fun(int idx, int target, vector<vector<int>> arr, vector<vector<int>> &dp) {\\n\\n    //     if(idx==0)  {\\n    //         if(target%arr[0][1]==0)  {\\n    //             if(target/arr[0][1] <= arr[0][0])\\n    //                 return 1;\\n    //         }\\n    //         return 0;\\n    //     }\\n\\n    //     if(dp[idx][target]!=-1)\\n    //         return dp[idx][target];\\n\\n    //     int mxq = arr[idx][0];\\n    //     int val = arr[idx][1];\\n    //     int take = 0;\\n\\n    //     int not_take = fun(idx-1,target,arr,dp);\\n    //     for(int i=1; val*i <= target && i<=mxq; i++)  {\\n    //         int curr = fun(idx-1,target-(val*i),arr,dp);\\n    //         if(curr>0)\\n    //             take += curr;\\n    //         take %= mod;\\n    //     }\\n\\n    //     return dp[idx][target] = (take + not_take) % mod;\\n    // }\\n\\n    // int waysToReachTarget(int target, vector<vector<int>>& arr) {\\n    //     int n = arr.size();\\n\\n    //     vector<vector<int>> dp (n, vector<int> (target+1,-1));\\n\\n    //     int res = fun(n-1,target,arr,dp);\\n        \\n    //     return res>=1e8 ? -1 : res;\\n    // }\\n\\n\\n\\n\\n\\n    //  TABULATION  + SPACE OPTIMIZATION\\n    int waysToReachTarget(int target, vector<vector<int>>& arr) {\\n        int n = arr.size();\\n\\n        vector<int> prev (target+1,0);\\n        vector<int> curr (target+1,0);\\n\\n        for(int i=0; i<target+1; i++)  {\\n            if(i%arr[0][1]==0 && i/arr[0][1]<=arr[0][0])\\n                prev[i] = 1;\\n        }\\n\\n        for(int idx=1; idx<n; idx++)  {\\n            int val = arr[idx][1];\\n            int mq = arr[idx][0];\\n            for(int t=0; t<=target; t++)    {\\n                int not_take = prev[t]; \\n\\n                int take = 0;\\n                for(int i=1; val*i<=t && i<=mq ; i++)  {\\n                    int curr = prev[t-(val*i)];\\n                    take += curr;\\n                    take %= mod;\\n                }\\n\\n                curr[t] = (take + not_take) % mod;\\n            }\\n\\n            prev = curr;\\n        }\\n        \\n        return prev[target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3264179,
                "title": "python-dp-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI read some posts and had a hard time understanding some of the posted solutions. Then I figured out they are space optimized (if I am not understanding them incorrectly). I used a 2d dp here to kinda unfolded the things and to make it more easier to understand\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSay we have ``m`` types and the target is ``n``, initialize a 2d dp array of ``(m+1) * (n+1)``. ``dp[i][j]`` denotes the number of solutions to hit ``target = j`` using at most the first ``i`` types.\\n\\nSo at row ``0``, no question is available and we have exactly ``1`` way to hit ``target = 0`` and ``0`` way to hit any positve target. \\n```\\ndp[0][j] = 0 if j != 0 else 1\\n```\\n\\nGiven ``dp[i][:]``, if we denote the number of available type ``i+1`` question by ``c``, the number of used question here can be any value between ``[0, c]`` and thus \\n```\\nfor j in range(target+1):\\n    for k in range(c+1):\\n        if j + k*v > target: break \\n        dp[i+1][j+k*v] = dp[i+1][j+k*v] + dp[i][j]\\n\\n```\\n\\nAnd it is easy to prove that no duplicate solutions are counted here (denoted by H). Suppose H is true for ``dp[i][:]`` (and ``dp[j][:]`` for ``j<i``). If there is a solution counted for multiploe times for ``dp[i+1][:]``, for example, it is counted in ``dp[i+1][j1]`` and ``do[i+1][j2]`` and ``j1 != j2``. And suppose for this solution (or trajectory), we used ``x`` type ``i+1`` quesitons, then there must be duplicate solutions (trajectories) in both ``dp[i][j1-x]`` and ``dp[i][j2-x]``, which violates our intial assumption. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m\\\\*n\\\\*c)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m\\\\*n)\\n# Code\\n```\\nclass Solution:\\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\\n        dp = [[0]*(target+1) for _ in range(len(types) + 1)]\\n        dp[0][0] = 1\\n        for i in range(len(types)):\\n            c, v = types[i]\\n            for j in range(target+1):\\n                for k in range(c+1):\\n                    if j + k*v > target: break\\n                    dp[i+1][j+k*v] = dp[i+1][j+k*v] + dp[i][j]\\n        return dp[-1][-1] % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\ndp[0][j] = 0 if j != 0 else 1\\n```\n```\\nfor j in range(target+1):\\n    for k in range(c+1):\\n        if j + k*v > target: break \\n        dp[i+1][j+k*v] = dp[i+1][j+k*v] + dp[i][j]\\n\\n```\n```\\nclass Solution:\\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\\n        dp = [[0]*(target+1) for _ in range(len(types) + 1)]\\n        dp[0][0] = 1\\n        for i in range(len(types)):\\n            c, v = types[i]\\n            for j in range(target+1):\\n                for k in range(c+1):\\n                    if j + k*v > target: break\\n                    dp[i+1][j+k*v] = dp[i+1][j+k*v] + dp[i][j]\\n        return dp[-1][-1] % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260809,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<vector<long long>> dp;\\n    long long mod = 1000000007;\\n    \\n    long long solve(int i, int n, int target, vector<vector<int>>& types){\\n        // base case\\n        if(target == 0) return 1;\\n        if(i >= n) return 0;\\n        if(target < 0) return 0;\\n        \\n        if(dp[i][target] != -1) return dp[i][target];\\n        \\n        int noOfQues = types[i][0];\\n        int marksPerQues = types[i][1];\\n        \\n        // do that ques + skip that ques\\n        \\n        long long ans = 0;\\n        for(int choice = 0; choice <= noOfQues; choice++){\\n            int total = choice*marksPerQues;\\n            long long temp = solve(i+1, n, target-total, types)%mod;\\n            ans += temp;\\n        }\\n        return dp[i][target] = ans%mod;\\n    }\\npublic:\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n = types.size();\\n        dp.resize(n+1, vector<long long> (target+1, -1));\\n        return solve(0, n, target, types)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<vector<long long>> dp;\\n    long long mod = 1000000007;\\n    \\n    long long solve(int i, int n, int target, vector<vector<int>>& types){\\n        // base case\\n        if(target == 0) return 1;\\n        if(i >= n) return 0;\\n        if(target < 0) return 0;\\n        \\n        if(dp[i][target] != -1) return dp[i][target];\\n        \\n        int noOfQues = types[i][0];\\n        int marksPerQues = types[i][1];\\n        \\n        // do that ques + skip that ques\\n        \\n        long long ans = 0;\\n        for(int choice = 0; choice <= noOfQues; choice++){\\n            int total = choice*marksPerQues;\\n            long long temp = solve(i+1, n, target-total, types)%mod;\\n            ans += temp;\\n        }\\n        return dp[i][target] = ans%mod;\\n    }\\npublic:\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n = types.size();\\n        dp.resize(n+1, vector<long long> (target+1, -1));\\n        return solve(0, n, target, types)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260577,
                "title": "c-dp-memoization-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    // [[6,1],[3,2],[2,3]]\\n    int backtrack(int ind,vector<vector<int>>& types,vector<vector<int>>&dp,int target,int sum)\\n    {\\n        if(sum>target) return 0;\\n        if(sum==target) return 1;\\n        if(ind>=types.size()) return sum==target;\\n        if(dp[ind][sum]!=-1) return dp[ind][sum];\\n        int pick=0,nonpick=0;\\n        for(int i=1;i<=types[ind][0];i++){\\n            pick+=backtrack(ind+1,types,dp,target,sum+(i*types[ind][1]));\\n            pick%=1000000007;\\n        }\\n        nonpick+=backtrack(ind+1,types,dp,target,sum);\\n        nonpick%=1000000007;\\n        return dp[ind][sum]=(pick+nonpick)%1000000007;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n=types.size();\\n        vector<vector<int>>dp(n,vector<int>(target+1,-1));\\n        return backtrack(0,types,dp,target,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // [[6,1],[3,2],[2,3]]\\n    int backtrack(int ind,vector<vector<int>>& types,vector<vector<int>>&dp,int target,int sum)\\n    {\\n        if(sum>target) return 0;\\n        if(sum==target) return 1;\\n        if(ind>=types.size()) return sum==target;\\n        if(dp[ind][sum]!=-1) return dp[ind][sum];\\n        int pick=0,nonpick=0;\\n        for(int i=1;i<=types[ind][0];i++){\\n            pick+=backtrack(ind+1,types,dp,target,sum+(i*types[ind][1]));\\n            pick%=1000000007;\\n        }\\n        nonpick+=backtrack(ind+1,types,dp,target,sum);\\n        nonpick%=1000000007;\\n        return dp[ind][sum]=(pick+nonpick)%1000000007;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n=types.size();\\n        vector<vector<int>>dp(n,vector<int>(target+1,-1));\\n        return backtrack(0,types,dp,target,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259200,
                "title": "c-dynamic-programming-memorization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**This is dynamic programming question.**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis is dynamic programming question. there are two recursion calls first is if you stand any index then you have two option pick or notpick if notpick then move to second index and if you pick then you have types[i][0] option like take only one marks or take two marks and so on so we run a loop from 1 to types[i][1] and make calls.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*target)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n*target)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[1000][1005];\\n    int mod=1e9+7;\\n    int solve(int i,vector<vector<int>>& v,int tar)\\n    {\\n        // if you stand in first index\\n        if(i==0)\\n        {\\n            // if you can make tar by using first index marks\\n            if(tar%v[i][1]==0)\\n            {\\n                if(v[i][0]*v[i][1]>=tar)\\n                    return 1;\\n                return 0;\\n            }\\n            return 0;\\n        }\\n        if(dp[i][tar]!=-1)\\n            return dp[i][tar];\\n        int npick=solve(i-1,v,tar)%mod;\\n        int pick=0;\\n        for(int j=1;j<=v[i][0];j++)\\n        {\\n            if(tar>=v[i][1]*j){\\n            int cost=solve(i-1,v,tar-v[i][1]*j)%mod;\\n                pick=(pick+cost)%mod;\\n            }\\n        }\\n        return dp[i][tar]= (pick+npick)%mod;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        memset(dp,-1,sizeof(dp));\\n        int n=types.size();\\n        return solve(n-1,types,target)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1000][1005];\\n    int mod=1e9+7;\\n    int solve(int i,vector<vector<int>>& v,int tar)\\n    {\\n        // if you stand in first index\\n        if(i==0)\\n        {\\n            // if you can make tar by using first index marks\\n            if(tar%v[i][1]==0)\\n            {\\n                if(v[i][0]*v[i][1]>=tar)\\n                    return 1;\\n                return 0;\\n            }\\n            return 0;\\n        }\\n        if(dp[i][tar]!=-1)\\n            return dp[i][tar];\\n        int npick=solve(i-1,v,tar)%mod;\\n        int pick=0;\\n        for(int j=1;j<=v[i][0];j++)\\n        {\\n            if(tar>=v[i][1]*j){\\n            int cost=solve(i-1,v,tar-v[i][1]*j)%mod;\\n                pick=(pick+cost)%mod;\\n            }\\n        }\\n        return dp[i][tar]= (pick+npick)%mod;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        memset(dp,-1,sizeof(dp));\\n        int n=types.size();\\n        return solve(n-1,types,target)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258818,
                "title": "think-of-choosing-multipliers-for-each-question",
                "content": "# Intuition - Model it with Mathematical Equations\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nLet us frame it in a different way. Let the marks of each question $$a_1, a_2, \\\\dots , a_n$$ and the number of these questions be $$b_1, b_2, \\\\dots , b_n$$. \\n\\n\\nWe there be another array called multipliers representing the number of each type of questions that we have attempted $$M_1, M_2, \\\\dots , M_n$$\\n\\nWe want to count the number of $$M_1, M_2, \\\\dots , M_n$$ subject to two conditions - \\n\\n* $$M_1 \\\\times a_1 + M_2 \\\\times a_2 + M_3 \\\\times a_3 + \\\\dots + M_n \\\\times a_n = T$$\\n* $$0 \\\\le M_i \\\\lt b_i, \\\\forall i$$\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n[GitHub Link](https://github.com/MathProgrammer/LeetCode/blob/master/Contests/Weekly%20Contest%20335/Explanations/Number%20of%20Ways%20to%20Earn%20Points%20Explanation.txt)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToReachTarget(int target, vector<vector<int>>& types) \\n    {\\n        const int MOD = 1e9 + 7;\\n        int no_of_questions = types.size();\\n        vector <int> multiplier(no_of_questions + 1);\\n        vector <long long> no_of_ways(target + 1);\\n        no_of_ways[0] = 1;\\n        \\n        for(int i = 0; i < no_of_questions; i++)\\n        {\\n            vector <long long> no_of_ways_here(target + 1);\\n            \\n            int current_count = types[i][0], current_weight = types[i][1];\\n            for(int multiplier = 0; multiplier*current_weight <= target && multiplier <= current_count; multiplier++)\\n            {\\n                int current_sum = multiplier*current_weight;\\n                for(int previous_sum = 0; previous_sum + multiplier*current_weight <= target; previous_sum++)\\n                {\\n                    int total_sum = previous_sum + current_sum;\\n                    no_of_ways_here[total_sum] += no_of_ways[previous_sum];\\n                    no_of_ways_here[total_sum] %= MOD;\\n                }\\n            }\\n            \\n            no_of_ways = no_of_ways_here;\\n        }\\n        \\n        return no_of_ways[target];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToReachTarget(int target, vector<vector<int>>& types) \\n    {\\n        const int MOD = 1e9 + 7;\\n        int no_of_questions = types.size();\\n        vector <int> multiplier(no_of_questions + 1);\\n        vector <long long> no_of_ways(target + 1);\\n        no_of_ways[0] = 1;\\n        \\n        for(int i = 0; i < no_of_questions; i++)\\n        {\\n            vector <long long> no_of_ways_here(target + 1);\\n            \\n            int current_count = types[i][0], current_weight = types[i][1];\\n            for(int multiplier = 0; multiplier*current_weight <= target && multiplier <= current_count; multiplier++)\\n            {\\n                int current_sum = multiplier*current_weight;\\n                for(int previous_sum = 0; previous_sum + multiplier*current_weight <= target; previous_sum++)\\n                {\\n                    int total_sum = previous_sum + current_sum;\\n                    no_of_ways_here[total_sum] += no_of_ways[previous_sum];\\n                    no_of_ways_here[total_sum] %= MOD;\\n                }\\n            }\\n            \\n            no_of_ways = no_of_ways_here;\\n        }\\n        \\n        return no_of_ways[target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258553,
                "title": "video-explanation-building-solution-with-intuition",
                "content": "# Explanation\\n\\nhttps://youtu.be/sFsaQ0lKdNg\\n\\n[Click here if the preview above doesn\\'t works](https://youtu.be/sFsaQ0lKdNg)\\n\\n# Code\\n```\\nconst int MOD = 1e9+7;\\n\\nclass Solution {\\n    vector<vector<int>> dp;\\n    \\n    int WaysToGetTarget (int ind, int target, const vector<vector<int>>& types) {\\n        if (target <  0) return 0;\\n        if (target == 0) return 1;\\n        if (ind == types.size()) return 0;\\n        \\n        int& ans = dp[ind][target];\\n        if (ans != -1) return ans;\\n        \\n        ans = 0;\\n        for (int i = 0; i <= types[ind][0]; i ++) {\\n            ans = (ans + WaysToGetTarget (ind+1, target, types)) % MOD;\\n            target -= types[ind][1];\\n        }\\n        \\n        return ans;\\n    }\\n    \\npublic:\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n = types.size();\\n        \\n        dp.clear();\\n        dp.resize(n, vector<int>(target+1, -1));\\n        \\n        return WaysToGetTarget (0, target, types);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nconst int MOD = 1e9+7;\\n\\nclass Solution {\\n    vector<vector<int>> dp;\\n    \\n    int WaysToGetTarget (int ind, int target, const vector<vector<int>>& types) {\\n        if (target <  0) return 0;\\n        if (target == 0) return 1;\\n        if (ind == types.size()) return 0;\\n        \\n        int& ans = dp[ind][target];\\n        if (ans != -1) return ans;\\n        \\n        ans = 0;\\n        for (int i = 0; i <= types[ind][0]; i ++) {\\n            ans = (ans + WaysToGetTarget (ind+1, target, types)) % MOD;\\n            target -= types[ind][1];\\n        }\\n        \\n        return ans;\\n    }\\n    \\npublic:\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n = types.size();\\n        \\n        dp.clear();\\n        dp.resize(n, vector<int>(target+1, -1));\\n        \\n        return WaysToGetTarget (0, target, types);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258431,
                "title": "python-simple-top-down-dp",
                "content": "# Code\\n```\\nfrom functools import cache\\nclass Solution:\\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\\n        MOD = 10**9 + 7\\n        n = len(types)\\n        @cache\\n        def dfs(i, prev):\\n            if prev > target: return 0\\n            if prev == target: return 1\\n            if i == n: return 0\\n            count, mark = types[i]\\n            res = 0\\n            for j in range(count + 1):\\n                res = (res + dfs(i+1, prev + j*mark)) % MOD\\n            return res\\n        return dfs(0, 0)\\n                \\n            \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom functools import cache\\nclass Solution:\\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\\n        MOD = 10**9 + 7\\n        n = len(types)\\n        @cache\\n        def dfs(i, prev):\\n            if prev > target: return 0\\n            if prev == target: return 1\\n            if i == n: return 0\\n            count, mark = types[i]\\n            res = 0\\n            for j in range(count + 1):\\n                res = (res + dfs(i+1, prev + j*mark)) % MOD\\n            return res\\n        return dfs(0, 0)\\n                \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258376,
                "title": "c-knapsack-dp-easy-to-understand",
                "content": "# Intuition\\nKnapSack DP\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int N = 1e9+7;\\n    int fun(int i,int target,int cnt,vector<vector<int>>& types,int n,vector<vector<vector<int>>>& dp){\\n        if(i==n-1){\\n            if((target%types[i][1]) == 0){\\n                if((target/types[i][1]) <= types[i][0]) return 1;\\n                else return 0;\\n            }\\n            else return 0;\\n        }\\n        if(dp[i][target][cnt]!=-1) return dp[i][target][cnt];\\n        int take = 0,not_take = 0;\\n        if(target>=types[i][1] && cnt<types[i][0]){\\n            take = fun(i,target-types[i][1],cnt+1,types,n,dp);\\n            not_take = fun(i+1,target,0,types,n,dp);\\n        }\\n        else not_take = fun(i+1,target,0,types,n,dp);\\n        return dp[i][target][cnt]=((take%N) + (not_take%N))%N;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n = types.size();\\n        vector<vector<vector<int>>> dp(n+1,vector<vector<int>>(target+1,vector<int>(51,-1)));\\n        return fun(0,target,0,types,n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int N = 1e9+7;\\n    int fun(int i,int target,int cnt,vector<vector<int>>& types,int n,vector<vector<vector<int>>>& dp){\\n        if(i==n-1){\\n            if((target%types[i][1]) == 0){\\n                if((target/types[i][1]) <= types[i][0]) return 1;\\n                else return 0;\\n            }\\n            else return 0;\\n        }\\n        if(dp[i][target][cnt]!=-1) return dp[i][target][cnt];\\n        int take = 0,not_take = 0;\\n        if(target>=types[i][1] && cnt<types[i][0]){\\n            take = fun(i,target-types[i][1],cnt+1,types,n,dp);\\n            not_take = fun(i+1,target,0,types,n,dp);\\n        }\\n        else not_take = fun(i+1,target,0,types,n,dp);\\n        return dp[i][target][cnt]=((take%N) + (not_take%N))%N;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n = types.size();\\n        vector<vector<vector<int>>> dp(n+1,vector<vector<int>>(target+1,vector<int>(51,-1)));\\n        return fun(0,target,0,types,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258102,
                "title": "knapsack-dp-top-down-memoization",
                "content": "```\\n// TC: O(Target * N * M), where n is the length of the array & m is the average count value of ith quesiton\\n// SC: O(Target * N)\\n#define ll long long\\nclass Solution {\\n    ll memo[1001][51];\\n    const ll MOD = 1e9 + 7;\\npublic:\\n    ll rec(ll target, vector<vector<int>> &types, int i){\\n        if(target == 0) return 1;\\n  \\n        if(i == types.size()) return 0;\\n        \\n        ll ans = rec(target, types, i + 1)%MOD;\\n        \\n        if(memo[target][i] != -1) return memo[target][i];\\n        \\n        for(int j = 0; j < types[i][0]; j++){\\n            if((target - (types[i][1] * (j + 1))) >= 0){\\n                ll currentAns = -1;\\n                if(memo[target - (types[i][1] * (j + 1))][i + 1] != -1) currentAns = memo[target - (types[i][1] * (j + 1))][i + 1];\\n                else currentAns = rec(target - (types[i][1] * (j + 1)), types, i + 1)%MOD;\\n                \\n\\t\\t\\t\\tans = (ans%MOD + currentAns)%MOD;\\n            }else break;\\n        }\\n        \\n        return memo[target][i] = ans%MOD;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        memset(memo, -1, sizeof(memo));\\n        return rec(target, types, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n// TC: O(Target * N * M), where n is the length of the array & m is the average count value of ith quesiton\\n// SC: O(Target * N)\\n#define ll long long\\nclass Solution {\\n    ll memo[1001][51];\\n    const ll MOD = 1e9 + 7;\\npublic:\\n    ll rec(ll target, vector<vector<int>> &types, int i){\\n        if(target == 0) return 1;\\n  \\n        if(i == types.size()) return 0;\\n        \\n        ll ans = rec(target, types, i + 1)%MOD;\\n        \\n        if(memo[target][i] != -1) return memo[target][i];\\n        \\n        for(int j = 0; j < types[i][0]; j++){\\n            if((target - (types[i][1] * (j + 1))) >= 0){\\n                ll currentAns = -1;\\n                if(memo[target - (types[i][1] * (j + 1))][i + 1] != -1) currentAns = memo[target - (types[i][1] * (j + 1))][i + 1];\\n                else currentAns = rec(target - (types[i][1] * (j + 1)), types, i + 1)%MOD;\\n                \\n\\t\\t\\t\\tans = (ans%MOD + currentAns)%MOD;\\n            }else break;\\n        }\\n        \\n        return memo[target][i] = ans%MOD;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        memset(memo, -1, sizeof(memo));\\n        return rec(target, types, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013981,
                "title": "c-beginner-solution-easy-to-catch-dp-iit-roorkee",
                "content": "# Complexity\\n- Time complexity:O(N*N)\\n- Space complexity:O(N*N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[51][1001];\\n    int calc(int index,int tr,vector<vector<int>>& tp)\\n    {\\n        if(tr<0)\\n        {\\n            return 0;\\n        }\\n        if(tr==0)\\n        {\\n            return 1;\\n        }\\n        if(index>=tp.size())\\n        {\\n            return 0;\\n        }\\n        if(dp[index][tr]!=-1)\\n        {\\n            return dp[index][tr];\\n        }\\n        int ans=0;\\n        for(int i=0;i<=tp[index][0];i++)\\n        {\\n            ans+=calc(index+1,tr-i*tp[index][1],tp);\\n            ans=ans%1000000007;\\n        }\\n        return dp[index][tr]=ans;\\n    }\\n    int waysToReachTarget(int tr, vector<vector<int>>& tp)\\n    {\\n        memset(dp,-1,sizeof(dp));\\n        return calc(0,tr,tp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[51][1001];\\n    int calc(int index,int tr,vector<vector<int>>& tp)\\n    {\\n        if(tr<0)\\n        {\\n            return 0;\\n        }\\n        if(tr==0)\\n        {\\n            return 1;\\n        }\\n        if(index>=tp.size())\\n        {\\n            return 0;\\n        }\\n        if(dp[index][tr]!=-1)\\n        {\\n            return dp[index][tr];\\n        }\\n        int ans=0;\\n        for(int i=0;i<=tp[index][0];i++)\\n        {\\n            ans+=calc(index+1,tr-i*tp[index][1],tp);\\n            ans=ans%1000000007;\\n        }\\n        return dp[index][tr]=ans;\\n    }\\n    int waysToReachTarget(int tr, vector<vector<int>>& tp)\\n    {\\n        memset(dp,-1,sizeof(dp));\\n        return calc(0,tr,tp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005789,
                "title": "dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 +7;\\n    int solve(int x,vector<vector<int>>& types, int idx ,vector<vector<int>>& dp){\\n        if(x ==0)return 1;\\n        if(x < 0 || idx >= types.size())return 0;\\n        if(dp[idx][x] != -1)return dp[idx][x];\\n        \\n        int cnt =0;\\n        for(int i=0;i<=types[idx][0];i++){\\n            cnt =  (cnt + solve(x -i*types[idx][1],types,idx+1,dp)) % mod;\\n        }\\n        return dp[idx][x] = cnt;\\n    }\\n\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n = types.size();\\n        vector<vector<int>> dp(n,vector<int>(target+1,-1));\\n        return solve(target,types,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 +7;\\n    int solve(int x,vector<vector<int>>& types, int idx ,vector<vector<int>>& dp){\\n        if(x ==0)return 1;\\n        if(x < 0 || idx >= types.size())return 0;\\n        if(dp[idx][x] != -1)return dp[idx][x];\\n        \\n        int cnt =0;\\n        for(int i=0;i<=types[idx][0];i++){\\n            cnt =  (cnt + solve(x -i*types[idx][1],types,idx+1,dp)) % mod;\\n        }\\n        return dp[idx][x] = cnt;\\n    }\\n\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n = types.size();\\n        vector<vector<int>> dp(n,vector<int>(target+1,-1));\\n        return solve(target,types,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4004356,
                "title": "c-dp-memoization",
                "content": "# Intuition\\nJust check all possible ways of picking the point with number of available counts possible. \\nAnd whenever you find some answer we can just memoize it and use it whenever it\\'s getting called again for the computation.\\n\\n# Complexity\\n- Time complexity:\\nO(N * Avg(count) * target)\\n\\n- Space complexity:\\nO(N*Target) + O(N)(stack space) ~ O(N+target)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int MOD = (int)(1e9 + 7);\\n    int goFind(vector<vector<int>> &types, int &target, int idx, int curr, vector<vector<int>> &dp) {\\n        if(curr > target) return 0;\\n        if(idx == (types.size()-1)) {\\n            if((target-curr)%types[idx][1] == 0) {\\n                int diff = (target-curr);\\n                int tot = diff/types[idx][1];\\n                if(tot <= types[idx][0]) {\\n                    return 1;\\n                }\\n                return 0;\\n            }\\n            return 0;\\n        }\\n        if(target == curr) {\\n            return 1;\\n        }\\n        if(dp[idx][curr] != -1) {\\n            return dp[idx][curr];\\n        }\\n        int possibleWays = 0;\\n        for(int i = 0;i<=types[idx][0];i++) {\\n            if((curr + (types[idx][1] * i)) <= target) {\\n                possibleWays = (possibleWays + goFind(types, target, idx+1, curr + (types[idx][1] * i), dp))%MOD;\\n            }\\n            else break;\\n        }\\n        return dp[idx][curr] = possibleWays;\\n\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n = types.size();\\n        vector<vector<int>> dp(n, vector<int> (target+1, -1));\\n        return goFind(types, target, 0, 0, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int MOD = (int)(1e9 + 7);\\n    int goFind(vector<vector<int>> &types, int &target, int idx, int curr, vector<vector<int>> &dp) {\\n        if(curr > target) return 0;\\n        if(idx == (types.size()-1)) {\\n            if((target-curr)%types[idx][1] == 0) {\\n                int diff = (target-curr);\\n                int tot = diff/types[idx][1];\\n                if(tot <= types[idx][0]) {\\n                    return 1;\\n                }\\n                return 0;\\n            }\\n            return 0;\\n        }\\n        if(target == curr) {\\n            return 1;\\n        }\\n        if(dp[idx][curr] != -1) {\\n            return dp[idx][curr];\\n        }\\n        int possibleWays = 0;\\n        for(int i = 0;i<=types[idx][0];i++) {\\n            if((curr + (types[idx][1] * i)) <= target) {\\n                possibleWays = (possibleWays + goFind(types, target, idx+1, curr + (types[idx][1] * i), dp))%MOD;\\n            }\\n            else break;\\n        }\\n        return dp[idx][curr] = possibleWays;\\n\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n = types.size();\\n        vector<vector<int>> dp(n, vector<int> (target+1, -1));\\n        return goFind(types, target, 0, 0, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001323,
                "title": "silly-difficult-tag",
                "content": "please dont be fooled by the hard tag and yes you are correct, its a very simple knapsack solution",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 3994851,
                "title": "memoization-and-bottom-up-approach-space-optimized",
                "content": "## Typescrip/Javascript (Space optmized)\\n```\\n\\nfunction waysToReachTarget(tar: number, types: number[][]): number {\\n                const mod = 1e9+7;\\n                let n = types.length;\\n                let prev = new Array(tar+1).fill(0);\\n                prev[0]=1;\\n\\n                for(let i=1;i<=tar;i++){\\n                    let flag = 0;\\n                    for(let j=1;j<=types[0][0];j++){\\n                            let sub = types[0][1]*j;\\n                            if(sub==i){\\n                                prev[i] =1;\\n                                flag = 1;\\n                                break;\\n                                \\n                            }\\n                    }  \\n\\n                    if(flag == 0){\\n                        prev[i]=0;\\n                    }\\n                }\\n            \\n\\n                for(let i =1;i<n;i++){\\n                    let temp = new Array(tar+1).fill(0);\\n                    temp[0]=1;\\n                    for(let j =1;j<=tar;j++){\\n                        let not_take = prev[j];\\n                        let take = 0;\\n                        for(let k=1;k<=types[i][0];k++){\\n                            let sub = types[i][1]*k;\\n                            if(sub<=j){\\n                                take = (take + prev[j-sub])%mod;\\n                            }\\n                        }\\n\\n                        temp[j]= (take+not_take)%mod;\\n                    }\\n                    prev = temp;\\n                }\\n\\n\\n                return  prev[tar];\\n};\\n```\\n# CPP\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int sol(vector<vector<int>>& types, int tar, int i, vector<vector<int>> & dp){\\n        //base case\\n        if(tar==0){\\n            return 1;\\n        }\\n\\n        if(i==0){\\n                for(int j=1;j<=types[0][0];j++){\\n                    int sub = types[i][1]*j;\\n                    if(sub==tar){\\n                        return 1;\\n                    }\\n                }    \\n                return 0;\\n        }\\n\\n        if(dp[i][tar]!=-1) return dp[i][tar];\\n\\n        int not_take = sol(types,tar,i-1,dp);\\n        int take = 0;\\n        for(int j=1;j<=types[i][0];j++){\\n            int sub = types[i][1]*j;\\n            if(sub<=tar){\\n                take = (take + sol(types,tar-sub,i-1,dp))%mod;\\n            }\\n        }\\n\\n        return dp[i][tar]= (take+not_take)%mod;\\n    }\\n    int waysToReachTarget(int tar, vector<vector<int>>& types) {\\n        int n = types.size();\\n        vector<vector<int>>dp(n,vector<int>(tar+1,0));\\n        for(int i=0;i<n;i++){\\n            dp[i][0] =1;\\n        }\\n\\n        for(int i=1;i<=tar;i++){\\n            int flag = 0;\\n             for(int j=1;j<=types[0][0];j++){\\n                    int sub = types[0][1]*j;\\n                    if(sub==i){\\n                        dp[0][i] =1;\\n                        flag = 1;\\n                        break;\\n                        \\n                    }\\n             }  \\n\\n             if(flag == 0){\\n                 dp[0][i]=0;\\n            }\\n        }\\n       \\n\\n        for(int i =1;i<n;i++){\\n            for(int j =1;j<=tar;j++){\\n                int not_take = dp[i-1][j];\\n                int take = 0;\\n                for(int k=1;k<=types[i][0];k++){\\n                    int sub = types[i][1]*k;\\n                    if(sub<=j){\\n                        take = (take + dp[i-1][j-sub])%mod;\\n                    }\\n                }\\n\\n                dp[i][j]= (take+not_take)%mod;\\n            }\\n        }\\n\\n\\n        return  dp[n-1][tar];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "JavaScript",
                    "TypeScript",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n\\nfunction waysToReachTarget(tar: number, types: number[][]): number {\\n                const mod = 1e9+7;\\n                let n = types.length;\\n                let prev = new Array(tar+1).fill(0);\\n                prev[0]=1;\\n\\n                for(let i=1;i<=tar;i++){\\n                    let flag = 0;\\n                    for(let j=1;j<=types[0][0];j++){\\n                            let sub = types[0][1]*j;\\n                            if(sub==i){\\n                                prev[i] =1;\\n                                flag = 1;\\n                                break;\\n                                \\n                            }\\n                    }  \\n\\n                    if(flag == 0){\\n                        prev[i]=0;\\n                    }\\n                }\\n            \\n\\n                for(let i =1;i<n;i++){\\n                    let temp = new Array(tar+1).fill(0);\\n                    temp[0]=1;\\n                    for(let j =1;j<=tar;j++){\\n                        let not_take = prev[j];\\n                        let take = 0;\\n                        for(let k=1;k<=types[i][0];k++){\\n                            let sub = types[i][1]*k;\\n                            if(sub<=j){\\n                                take = (take + prev[j-sub])%mod;\\n                            }\\n                        }\\n\\n                        temp[j]= (take+not_take)%mod;\\n                    }\\n                    prev = temp;\\n                }\\n\\n\\n                return  prev[tar];\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int sol(vector<vector<int>>& types, int tar, int i, vector<vector<int>> & dp){\\n        //base case\\n        if(tar==0){\\n            return 1;\\n        }\\n\\n        if(i==0){\\n                for(int j=1;j<=types[0][0];j++){\\n                    int sub = types[i][1]*j;\\n                    if(sub==tar){\\n                        return 1;\\n                    }\\n                }    \\n                return 0;\\n        }\\n\\n        if(dp[i][tar]!=-1) return dp[i][tar];\\n\\n        int not_take = sol(types,tar,i-1,dp);\\n        int take = 0;\\n        for(int j=1;j<=types[i][0];j++){\\n            int sub = types[i][1]*j;\\n            if(sub<=tar){\\n                take = (take + sol(types,tar-sub,i-1,dp))%mod;\\n            }\\n        }\\n\\n        return dp[i][tar]= (take+not_take)%mod;\\n    }\\n    int waysToReachTarget(int tar, vector<vector<int>>& types) {\\n        int n = types.size();\\n        vector<vector<int>>dp(n,vector<int>(tar+1,0));\\n        for(int i=0;i<n;i++){\\n            dp[i][0] =1;\\n        }\\n\\n        for(int i=1;i<=tar;i++){\\n            int flag = 0;\\n             for(int j=1;j<=types[0][0];j++){\\n                    int sub = types[0][1]*j;\\n                    if(sub==i){\\n                        dp[0][i] =1;\\n                        flag = 1;\\n                        break;\\n                        \\n                    }\\n             }  \\n\\n             if(flag == 0){\\n                 dp[0][i]=0;\\n            }\\n        }\\n       \\n\\n        for(int i =1;i<n;i++){\\n            for(int j =1;j<=tar;j++){\\n                int not_take = dp[i-1][j];\\n                int take = 0;\\n                for(int k=1;k<=types[i][0];k++){\\n                    int sub = types[i][1]*k;\\n                    if(sub<=j){\\n                        take = (take + dp[i-1][j-sub])%mod;\\n                    }\\n                }\\n\\n                dp[i][j]= (take+not_take)%mod;\\n            }\\n        }\\n\\n\\n        return  dp[n-1][tar];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994835,
                "title": "memoization-and-bottom-up-approach",
                "content": "\\n# CPP\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int sol(vector<vector<int>>& types, int tar, int i, vector<vector<int>> & dp){\\n        //base case\\n        if(tar==0){\\n            return 1;\\n        }\\n\\n        if(i==0){\\n                for(int j=1;j<=types[0][0];j++){\\n                    int sub = types[i][1]*j;\\n                    if(sub==tar){\\n                        return 1;\\n                    }\\n                }    \\n                return 0;\\n        }\\n\\n        if(dp[i][tar]!=-1) return dp[i][tar];\\n\\n        int not_take = sol(types,tar,i-1,dp);\\n        int take = 0;\\n        for(int j=1;j<=types[i][0];j++){\\n            int sub = types[i][1]*j;\\n            if(sub<=tar){\\n                take = (take + sol(types,tar-sub,i-1,dp))%mod;\\n            }\\n        }\\n\\n        return dp[i][tar]= (take+not_take)%mod;\\n    }\\n    int waysToReachTarget(int tar, vector<vector<int>>& types) {\\n        int n = types.size();\\n        vector<vector<int>>dp(n,vector<int>(tar+1,0));\\n        for(int i=0;i<n;i++){\\n            dp[i][0] =1;\\n        }\\n\\n        for(int i=1;i<=tar;i++){\\n            int flag = 0;\\n             for(int j=1;j<=types[0][0];j++){\\n                    int sub = types[0][1]*j;\\n                    if(sub==i){\\n                        dp[0][i] =1;\\n                        flag = 1;\\n                        break;\\n                        \\n                    }\\n             }  \\n\\n             if(flag == 0){\\n                 dp[0][i]=0;\\n            }\\n        }\\n       \\n\\n        for(int i =1;i<n;i++){\\n            for(int j =1;j<=tar;j++){\\n                int not_take = dp[i-1][j];\\n                int take = 0;\\n                for(int k=1;k<=types[i][0];k++){\\n                    int sub = types[i][1]*k;\\n                    if(sub<=j){\\n                        take = (take + dp[i-1][j-sub])%mod;\\n                    }\\n                }\\n\\n                dp[i][j]= (take+not_take)%mod;\\n            }\\n        }\\n\\n\\n        return  dp[n-1][tar];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int sol(vector<vector<int>>& types, int tar, int i, vector<vector<int>> & dp){\\n        //base case\\n        if(tar==0){\\n            return 1;\\n        }\\n\\n        if(i==0){\\n                for(int j=1;j<=types[0][0];j++){\\n                    int sub = types[i][1]*j;\\n                    if(sub==tar){\\n                        return 1;\\n                    }\\n                }    \\n                return 0;\\n        }\\n\\n        if(dp[i][tar]!=-1) return dp[i][tar];\\n\\n        int not_take = sol(types,tar,i-1,dp);\\n        int take = 0;\\n        for(int j=1;j<=types[i][0];j++){\\n            int sub = types[i][1]*j;\\n            if(sub<=tar){\\n                take = (take + sol(types,tar-sub,i-1,dp))%mod;\\n            }\\n        }\\n\\n        return dp[i][tar]= (take+not_take)%mod;\\n    }\\n    int waysToReachTarget(int tar, vector<vector<int>>& types) {\\n        int n = types.size();\\n        vector<vector<int>>dp(n,vector<int>(tar+1,0));\\n        for(int i=0;i<n;i++){\\n            dp[i][0] =1;\\n        }\\n\\n        for(int i=1;i<=tar;i++){\\n            int flag = 0;\\n             for(int j=1;j<=types[0][0];j++){\\n                    int sub = types[0][1]*j;\\n                    if(sub==i){\\n                        dp[0][i] =1;\\n                        flag = 1;\\n                        break;\\n                        \\n                    }\\n             }  \\n\\n             if(flag == 0){\\n                 dp[0][i]=0;\\n            }\\n        }\\n       \\n\\n        for(int i =1;i<n;i++){\\n            for(int j =1;j<=tar;j++){\\n                int not_take = dp[i-1][j];\\n                int take = 0;\\n                for(int k=1;k<=types[i][0];k++){\\n                    int sub = types[i][1]*k;\\n                    if(sub<=j){\\n                        take = (take + dp[i-1][j-sub])%mod;\\n                    }\\n                }\\n\\n                dp[i][j]= (take+not_take)%mod;\\n            }\\n        }\\n\\n\\n        return  dp[n-1][tar];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990645,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    vector<vector<int>>dp;\\n    int solve(int target,vector<vector<int>>& types,int i){\\n        if(target == 0)\\n            return 1;\\n        if(target < 0 || i >= types.size())\\n            return 0;\\n        if(dp[i][target] != -1)\\n            return dp[i][target];\\n        int marks = types[i][1];\\n        int take = 0;\\n        for(int j = 0;j <= types[i][0];j++)\\n            take = (take + solve(target-marks*j,types,i+1))%mod;\\n        return dp[i][target] = take%mod;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        dp = vector<vector<int>>(types.size(),vector<int>(target+1,-1));\\n        return solve(target,types,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    vector<vector<int>>dp;\\n    int solve(int target,vector<vector<int>>& types,int i){\\n        if(target == 0)\\n            return 1;\\n        if(target < 0 || i >= types.size())\\n            return 0;\\n        if(dp[i][target] != -1)\\n            return dp[i][target];\\n        int marks = types[i][1];\\n        int take = 0;\\n        for(int j = 0;j <= types[i][0];j++)\\n            take = (take + solve(target-marks*j,types,i+1))%mod;\\n        return dp[i][target] = take%mod;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        dp = vector<vector<int>>(types.size(),vector<int>(target+1,-1));\\n        return solve(target,types,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990641,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    vector<vector<int>>dp;\\n    int solve(int target,vector<vector<int>>& types,int i){\\n        if(target == 0)\\n            return 1;\\n        if(target < 0)\\n            return 0;\\n        if(i >= types.size())\\n            return 0;\\n        if(dp[i][target] != -1)\\n            return dp[i][target];\\n        int count = types[i][0];\\n        int marks = types[i][1];\\n        int take = 0;\\n        int notTake = 0;\\n        for(int j = 0;j <= count;j++)\\n            take = (take + solve(target-marks*j,types,i+1))%mod;\\n        return dp[i][target] = take%mod;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        dp = vector<vector<int>>(types.size(),vector<int>(target+1,-1));\\n        return solve(target,types,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    vector<vector<int>>dp;\\n    int solve(int target,vector<vector<int>>& types,int i){\\n        if(target == 0)\\n            return 1;\\n        if(target < 0)\\n            return 0;\\n        if(i >= types.size())\\n            return 0;\\n        if(dp[i][target] != -1)\\n            return dp[i][target];\\n        int count = types[i][0];\\n        int marks = types[i][1];\\n        int take = 0;\\n        int notTake = 0;\\n        for(int j = 0;j <= count;j++)\\n            take = (take + solve(target-marks*j,types,i+1))%mod;\\n        return dp[i][target] = take%mod;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        dp = vector<vector<int>>(types.size(),vector<int>(target+1,-1));\\n        return solve(target,types,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984482,
                "title": "memoization-tabulation-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    Getting a hint of trying a take some number of points from the current index and getting the remaining from the rest.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    First of all we try to iterate on the indexes and try to take tar number of points from the current index where 0<=tar<=types[i][1]*types[i][0], and getting the rest of the points from the further types of questions. At any moment if we got to know that target=0 we return a 1 saying that in this current way i can get my sum equal to target.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*Target)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N*Target)\\n# Code\\n```\\n//Memoization Solution\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    long long f(int i,int target,vector<vector<int>>& types,vector<vector<long long>> &dp)\\n    {\\n        int n=types.size();\\n        if(target==0) return 1;\\n        if(i>=n) return 0;\\n        if(dp[i][target]!=-1) return dp[i][target];\\n        long long ans=0;\\n        int count=types[i][0],marks=types[i][1];\\n        for(int ind=0;ind<=count;ind++)\\n        {\\n            long long take=0;\\n            if(target>=ind*marks)\\n            {\\n                take=f(i+1,target-ind*marks,types,dp);\\n            }\\n            ans=(ans%mod + take%mod)%mod;\\n        }\\n        return dp[i][target]=ans%mod;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n=types.size();\\n        vector<vector<long long>> dp(n,vector<long long> (target+1,-1));\\n        return (int)f(0,target,types,dp);\\n    }\\n};\\n```\\n```\\n//Tabulation solution\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n=types.size();\\n        vector<vector<long long>> dp(n+1,vector<long long> (target+1,0));\\n        for(int i=0;i<=n;i++) dp[i][0]=1;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            for(int tar=0;tar<=target;tar++)\\n            {\\n                long long ans=0;\\n                int count=types[i][0],marks=types[i][1];\\n                for(int ind=0;ind<=count;ind++)\\n                {\\n                    long long take=0;\\n                    if(tar>=ind*marks)\\n                    {\\n                        take=dp[i+1][tar-ind*marks];\\n                    }\\n                    ans=(ans%mod + take%mod)%mod;\\n                }\\n                dp[i][tar]=ans%mod;\\n            }\\n        }\\n        return (int)dp[0][target];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\n//Memoization Solution\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    long long f(int i,int target,vector<vector<int>>& types,vector<vector<long long>> &dp)\\n    {\\n        int n=types.size();\\n        if(target==0) return 1;\\n        if(i>=n) return 0;\\n        if(dp[i][target]!=-1) return dp[i][target];\\n        long long ans=0;\\n        int count=types[i][0],marks=types[i][1];\\n        for(int ind=0;ind<=count;ind++)\\n        {\\n            long long take=0;\\n            if(target>=ind*marks)\\n            {\\n                take=f(i+1,target-ind*marks,types,dp);\\n            }\\n            ans=(ans%mod + take%mod)%mod;\\n        }\\n        return dp[i][target]=ans%mod;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n=types.size();\\n        vector<vector<long long>> dp(n,vector<long long> (target+1,-1));\\n        return (int)f(0,target,types,dp);\\n    }\\n};\\n```\n```\\n//Tabulation solution\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n=types.size();\\n        vector<vector<long long>> dp(n+1,vector<long long> (target+1,0));\\n        for(int i=0;i<=n;i++) dp[i][0]=1;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            for(int tar=0;tar<=target;tar++)\\n            {\\n                long long ans=0;\\n                int count=types[i][0],marks=types[i][1];\\n                for(int ind=0;ind<=count;ind++)\\n                {\\n                    long long take=0;\\n                    if(tar>=ind*marks)\\n                    {\\n                        take=dp[i+1][tar-ind*marks];\\n                    }\\n                    ans=(ans%mod + take%mod)%mod;\\n                }\\n                dp[i][tar]=ans%mod;\\n            }\\n        }\\n        return (int)dp[0][target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977166,
                "title": "easy-dp-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef long long int ll;\\n    ll dp[1001][51];\\n    const int M=1e9+7;\\n    ll solve(int t,vector<vector<int>>&v,int index){\\n        if(t==0) return 1;\\n        if(index==v.size()) return 0;\\n        if(dp[t][index]!=-1) return dp[t][index];\\n        ll ans=solve(t,v,index+1)%M;    \\n        for(int i=0;i<v[index][0];i++){\\n            if(t-(i+1)*(v[index][1])>=0){\\n                ll curr=solve(t-(i+1)*(v[index][1]),v,index+1)%M;\\n                ans=(ans%M+curr%M)%M;\\n            }\\n            else break;\\n        }\\n        return dp[t][index]=ans%M;\\n    }\\n    int waysToReachTarget(int t, vector<vector<int>>& v) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(t,v,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long int ll;\\n    ll dp[1001][51];\\n    const int M=1e9+7;\\n    ll solve(int t,vector<vector<int>>&v,int index){\\n        if(t==0) return 1;\\n        if(index==v.size()) return 0;\\n        if(dp[t][index]!=-1) return dp[t][index];\\n        ll ans=solve(t,v,index+1)%M;    \\n        for(int i=0;i<v[index][0];i++){\\n            if(t-(i+1)*(v[index][1])>=0){\\n                ll curr=solve(t-(i+1)*(v[index][1]),v,index+1)%M;\\n                ans=(ans%M+curr%M)%M;\\n            }\\n            else break;\\n        }\\n        return dp[t][index]=ans%M;\\n    }\\n    int waysToReachTarget(int t, vector<vector<int>>& v) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(t,v,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975925,
                "title": "easy-dp-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int f(int idx,vector<vector<int>> &types,int target,vector<vector<int>> &dp){\\n        if(target == 0) return 1;\\n        if(target<0 || idx>=types.size()) return 0;\\n        if(dp[idx][target]!=-1) return dp[idx][target];\\n        long long take = 0;\\n        for(int i=0;i<=types[idx][0];i++){\\n            if(target>=i*types[idx][1]) take = (take + f(idx+1,types,target - i*types[idx][1],dp))%mod;\\n            else break;\\n        }\\n        return dp[idx][target] = take%mod;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        vector<vector<int>> dp(types.size(),vector<int>(target+1,-1));\\n        return f(0,types,target,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int f(int idx,vector<vector<int>> &types,int target,vector<vector<int>> &dp){\\n        if(target == 0) return 1;\\n        if(target<0 || idx>=types.size()) return 0;\\n        if(dp[idx][target]!=-1) return dp[idx][target];\\n        long long take = 0;\\n        for(int i=0;i<=types[idx][0];i++){\\n            if(target>=i*types[idx][1]) take = (take + f(idx+1,types,target - i*types[idx][1],dp))%mod;\\n            else break;\\n        }\\n        return dp[idx][target] = take%mod;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        vector<vector<int>> dp(types.size(),vector<int>(target+1,-1));\\n        return f(0,types,target,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966148,
                "title": "easy-to-understand-code-solved-using-memoization",
                "content": "# Intuition\\nJust travel the types array and at each index I have the option to choose some number of question until the number of ques and index*marks <=target\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(len(types)*target)\\n\\n- Space complexity:\\nO(len(types*target)) \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int helper(int idx,int target, vector<vector<int>>& types, vector<vector<int>>&dp){\\n        if(target==0) return 1;\\n\\n        if(idx>=types.size()) return 0;\\n\\n        if(dp[idx][target]!=-1) return dp[idx][target];\\n\\n        int numQues=types[idx][0];\\n        int marks=types[idx][1];\\n\\n        int ans=0;\\n\\n\\n        for(int i=0;i<=numQues;i++){\\n            int marksGained=marks*i;\\n            if(marksGained>target) break;\\n\\n            ans=(ans%mod+helper(idx+1,target-marksGained,types,dp)%mod)%mod;\\n\\n        }\\n\\n        return dp[idx][target]=ans%mod;\\n\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        vector<vector<int>>dp(types.size(),vector<int>(target+1,-1));\\n        return helper(0,target,types,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int helper(int idx,int target, vector<vector<int>>& types, vector<vector<int>>&dp){\\n        if(target==0) return 1;\\n\\n        if(idx>=types.size()) return 0;\\n\\n        if(dp[idx][target]!=-1) return dp[idx][target];\\n\\n        int numQues=types[idx][0];\\n        int marks=types[idx][1];\\n\\n        int ans=0;\\n\\n\\n        for(int i=0;i<=numQues;i++){\\n            int marksGained=marks*i;\\n            if(marksGained>target) break;\\n\\n            ans=(ans%mod+helper(idx+1,target-marksGained,types,dp)%mod)%mod;\\n\\n        }\\n\\n        return dp[idx][target]=ans%mod;\\n\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        vector<vector<int>>dp(types.size(),vector<int>(target+1,-1));\\n        return helper(0,target,types,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3959249,
                "title": "memoization-made-easy",
                "content": "# Complexity\\n- Time complexity: $$O(n*target)$$ \\n\\n- Space complexity: $$O(n*target)$$ \\n\\n# Code\\n```\\nclass Solution {\\n    int solve(int i, int target, vector<vector<int>>& types,vector<vector<int>>& dp)\\n    {   //base cases\\n        if(target == 0)\\n         return 1;\\n        if(i == types.size()|| target < 0)\\n         return 0;\\n        //memoization step\\n        if(dp[i][target] != -1)\\n         return dp[i][target];\\n\\n        long long take = 0, notTake = 0;\\n        //we can take any no. of questions avaliable of current type \\n        for(int count=1; count<=types[i][0]; count++){\\n         take += solve(i+1,target - count*types[i][1],types,dp);\\n        } //or skip current type questions\\n        notTake = solve(i+1,target,types,dp);\\n        //add all possibilities in dp table\\n        return dp[i][target] = (take + notTake) % 1000000007; \\n    }\\npublic:\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n = types.size();\\n        vector<vector<int>> dp(n,vector<int>(target+1,-1));\\n        return solve(0,target,types,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int solve(int i, int target, vector<vector<int>>& types,vector<vector<int>>& dp)\\n    {   //base cases\\n        if(target == 0)\\n         return 1;\\n        if(i == types.size()|| target < 0)\\n         return 0;\\n        //memoization step\\n        if(dp[i][target] != -1)\\n         return dp[i][target];\\n\\n        long long take = 0, notTake = 0;\\n        //we can take any no. of questions avaliable of current type \\n        for(int count=1; count<=types[i][0]; count++){\\n         take += solve(i+1,target - count*types[i][1],types,dp);\\n        } //or skip current type questions\\n        notTake = solve(i+1,target,types,dp);\\n        //add all possibilities in dp table\\n        return dp[i][target] = (take + notTake) % 1000000007; \\n    }\\npublic:\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n = types.size();\\n        vector<vector<int>> dp(n,vector<int>(target+1,-1));\\n        return solve(0,target,types,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916796,
                "title": "same-old-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom functools import lru_cache\\nclass Solution:\\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\\n        @lru_cache(maxsize=None)\\n        def helper(i,cur_target):\\n            if cur_target < 0:\\n                return 0\\n            if cur_target == 0:\\n                    return 1\\n            if i == len(types):\\n                return 0\\n            res = 0\\n            for count in range(types[i][0]+1):\\n                res += helper(i+1, cur_target-count*types[i][1])\\n            return res % (10**9+7)\\n        res_final = helper(0,target)\\n\\n        return res_final\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom functools import lru_cache\\nclass Solution:\\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\\n        @lru_cache(maxsize=None)\\n        def helper(i,cur_target):\\n            if cur_target < 0:\\n                return 0\\n            if cur_target == 0:\\n                    return 1\\n            if i == len(types):\\n                return 0\\n            res = 0\\n            for count in range(types[i][0]+1):\\n                res += helper(i+1, cur_target-count*types[i][1])\\n            return res % (10**9+7)\\n        res_final = helper(0,target)\\n\\n        return res_final\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908546,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int waysToReachTarget(int target, vector<vector<int>>& types) {\\n    constexpr int kMod = 1\\'000\\'000\\'007;\\n    // dp[i][j] := # of ways to earn j points with first i types\\n    vector<vector<int>> dp(types.size() + 1, vector<int>(target + 1));\\n    dp[0][0] = 1;\\n\\n    for (int i = 1; i <= types.size(); ++i) {\\n      const int count = types[i - 1][0];\\n      const int mark = types[i - 1][1];\\n      for (int j = 0; j <= target; ++j)\\n        for (int solved = 0; solved <= count; ++solved)\\n          if (j - solved * mark >= 0) {\\n            dp[i][j] += dp[i - 1][j - solved * mark];\\n            dp[i][j] %= kMod;\\n          }\\n    }\\n\\n    return dp[types.size()][target];\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int waysToReachTarget(int target, vector<vector<int>>& types) {\\n    constexpr int kMod = 1\\'000\\'000\\'007;\\n    // dp[i][j] := # of ways to earn j points with first i types\\n    vector<vector<int>> dp(types.size() + 1, vector<int>(target + 1));\\n    dp[0][0] = 1;\\n\\n    for (int i = 1; i <= types.size(); ++i) {\\n      const int count = types[i - 1][0];\\n      const int mark = types[i - 1][1];\\n      for (int j = 0; j <= target; ++j)\\n        for (int solved = 0; solved <= count; ++solved)\\n          if (j - solved * mark >= 0) {\\n            dp[i][j] += dp[i - 1][j - solved * mark];\\n            dp[i][j] %= kMod;\\n          }\\n    }\\n\\n    return dp[types.size()][target];\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3896383,
                "title": "0-1-knapsack-variation-c-easy-solution-memoization",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    int solve(int i,vector<vector<int>>& types,int target,vector<vector<long long>>& dp){\\n        if(i==types.size() || target==0){\\n            if(target==0) return 1;\\n            else return 0;\\n        }\\n        if(dp[i][target]!=-1) return dp[i][target]%mod\\n        long long ans=solve(i+1,types,target,dp)%mod;\\n        for(int j=1;j<=types[i][0];j++){\\n        \\n            if(j*types[i][1]<=target){\\n                ans+=(solve(i+1,types,target-(j*(types[i][1])),dp)%mod);\\n            }\\n            else break;\\n        }\\n        return dp[i][target]=ans%mod;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        vector<vector<long long>> dp(types.size()+1,vector<long long>(target+1,-1));\\n        return solve(0,types,target,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    int solve(int i,vector<vector<int>>& types,int target,vector<vector<long long>>& dp){\\n        if(i==types.size() || target==0){\\n            if(target==0) return 1;\\n            else return 0;\\n        }\\n        if(dp[i][target]!=-1) return dp[i][target]%mod\\n        long long ans=solve(i+1,types,target,dp)%mod;\\n        for(int j=1;j<=types[i][0];j++){\\n        \\n            if(j*types[i][1]<=target){\\n                ans+=(solve(i+1,types,target-(j*(types[i][1])),dp)%mod);\\n            }\\n            else break;\\n        }\\n        return dp[i][target]=ans%mod;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        vector<vector<long long>> dp(types.size()+1,vector<long long>(target+1,-1));\\n        return solve(0,types,target,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894803,
                "title": "easy-memorization-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int rec(int t, vector<vector<int>>& ty, int i,vector<vector<int>>&d){\\n        if(i==ty.size()){\\n            if(t==0) return 1;\\n            return 0;\\n        }\\n        if(d[i][t]!=-1) return d[i][t];\\n        int ans=0;\\n        ans=(ans+rec(t,ty,i+1,d)%mod)%mod;\\n        for(int j=1;j<=ty[i][0];j++){\\n            int x=ty[i][1];\\n            if(t>=j*x){\\n                ans=(ans+rec(t-j*x,ty,i+1,d)%mod)%mod;\\n            }\\n            else break;\\n        }\\n        return d[i][t]=ans%mod;\\n    }\\n    int waysToReachTarget(int t, vector<vector<int>>& ty) {\\n        vector<vector<int>>d(ty.size()+1,vector<int>(t+1,-1));\\n        return rec(t,ty,0,d);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int rec(int t, vector<vector<int>>& ty, int i,vector<vector<int>>&d){\\n        if(i==ty.size()){\\n            if(t==0) return 1;\\n            return 0;\\n        }\\n        if(d[i][t]!=-1) return d[i][t];\\n        int ans=0;\\n        ans=(ans+rec(t,ty,i+1,d)%mod)%mod;\\n        for(int j=1;j<=ty[i][0];j++){\\n            int x=ty[i][1];\\n            if(t>=j*x){\\n                ans=(ans+rec(t-j*x,ty,i+1,d)%mod)%mod;\\n            }\\n            else break;\\n        }\\n        return d[i][t]=ans%mod;\\n    }\\n    int waysToReachTarget(int t, vector<vector<int>>& ty) {\\n        vector<vector<int>>d(ty.size()+1,vector<int>(t+1,-1));\\n        return rec(t,ty,0,d);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894237,
                "title": "simple-cpp-solution-with-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int m = 1000000007;\\n    int solve(int target ,vector<vector<int>>& types,int crntMarks ,int crnt,vector<vector<int>>& dp){\\n\\n        if(crntMarks==target) return 1;\\n        if(crnt==types.size()) return 0;\\n        if(crntMarks>target) return 0;\\n\\n        if(dp[crnt][crntMarks]!=-1) return dp[crnt][crntMarks];\\n\\n        int questions = types[crnt][0];\\n        int marks = types[crnt][1];\\n\\n        int ans = 0;\\n       \\n        for(auto x=0;x<=questions;x++){\\n            \\n            int newMarks = crntMarks + (x*marks);\\n\\n            ans=(ans+solve(target, types,newMarks, crnt+1,dp))%m;\\n        }\\n\\n        return dp[crnt][crntMarks] = ans;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        \\n        vector<vector<int>> dp(types.size()+1, vector<int>(10001,-1));\\n        return solve(target,types,0,0,dp)%m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int m = 1000000007;\\n    int solve(int target ,vector<vector<int>>& types,int crntMarks ,int crnt,vector<vector<int>>& dp){\\n\\n        if(crntMarks==target) return 1;\\n        if(crnt==types.size()) return 0;\\n        if(crntMarks>target) return 0;\\n\\n        if(dp[crnt][crntMarks]!=-1) return dp[crnt][crntMarks];\\n\\n        int questions = types[crnt][0];\\n        int marks = types[crnt][1];\\n\\n        int ans = 0;\\n       \\n        for(auto x=0;x<=questions;x++){\\n            \\n            int newMarks = crntMarks + (x*marks);\\n\\n            ans=(ans+solve(target, types,newMarks, crnt+1,dp))%m;\\n        }\\n\\n        return dp[crnt][crntMarks] = ans;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        \\n        vector<vector<int>> dp(types.size()+1, vector<int>(10001,-1));\\n        return solve(target,types,0,0,dp)%m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894124,
                "title": "c-beats-100-very-easy-solution-recursion-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[1001][51][51];\\n    int mod = 1e9 + 7;\\n    int helper(vector<vector<int>>& types, int target, int end, int last_count){\\n        if(target == 0) return 1;\\n        if(end == 0) return 0;\\n        if(dp[target][end][last_count] != -1) return dp[target][end][last_count];\\n        int take = 0;\\n        if(target >= types[end - 1][1] && last_count > 0){\\n            take += helper(types, target - types[end-1][1], end, last_count-1)%mod;\\n        }\\n        int not_take = 0;\\n        if(end > 1) not_take += helper(types, target, end-1, types[end-2][0])%mod;\\n\\n        return dp[target][end][last_count] = (take + not_take)%mod;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n = types.size();\\n        memset(dp, -1, sizeof(dp));\\n        return helper(types, target, n, types[n-1][0]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][51][51];\\n    int mod = 1e9 + 7;\\n    int helper(vector<vector<int>>& types, int target, int end, int last_count){\\n        if(target == 0) return 1;\\n        if(end == 0) return 0;\\n        if(dp[target][end][last_count] != -1) return dp[target][end][last_count];\\n        int take = 0;\\n        if(target >= types[end - 1][1] && last_count > 0){\\n            take += helper(types, target - types[end-1][1], end, last_count-1)%mod;\\n        }\\n        int not_take = 0;\\n        if(end > 1) not_take += helper(types, target, end-1, types[end-2][0])%mod;\\n\\n        return dp[target][end][last_count] = (take + not_take)%mod;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n = types.size();\\n        memset(dp, -1, sizeof(dp));\\n        return helper(types, target, n, types[n-1][0]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893140,
                "title": "simple-take-and-not-take-approach",
                "content": "# Complexity\\n- Time complexity:O(N.target.M)\\n- N= types.size()\\n- M=maximum count of any points .\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N.target.M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    const int mod=1e9+7;\\npublic:\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n=types.size();\\n        vector<vector<vector<int>>>dp(n+1,vector<vector<int>>(target+1,vector<int>(51,0)));\\n        dp[n][0][0]=1;\\n        for(int i=n-1;i>=0;i--){\\n            for(int needed_val=0;needed_val<=target;needed_val++){\\n                for(int count=types[i][0];count>=0;count--){\\n                    int notTake=dp[i+1][needed_val][0];\\n                    int take=0;\\n                    if(needed_val>=types[i][1]&count<types[i][0]){\\n                        take=dp[i][needed_val-types[i][1]][count+1];\\n                    }\\n                    dp[i][needed_val][count]=int(((long long)take+(long long)notTake)%mod);\\n                }\\n            }\\n        }\\n        return dp[0][target][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    const int mod=1e9+7;\\npublic:\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n=types.size();\\n        vector<vector<vector<int>>>dp(n+1,vector<vector<int>>(target+1,vector<int>(51,0)));\\n        dp[n][0][0]=1;\\n        for(int i=n-1;i>=0;i--){\\n            for(int needed_val=0;needed_val<=target;needed_val++){\\n                for(int count=types[i][0];count>=0;count--){\\n                    int notTake=dp[i+1][needed_val][0];\\n                    int take=0;\\n                    if(needed_val>=types[i][1]&count<types[i][0]){\\n                        take=dp[i][needed_val-types[i][1]][count+1];\\n                    }\\n                    dp[i][needed_val][count]=int(((long long)take+(long long)notTake)%mod);\\n                }\\n            }\\n        }\\n        return dp[0][target][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892771,
                "title": "knapsack-with-repetition",
                "content": "```\\nM = 10 ** 9 + 7\\n\\nclass Solution:\\n    def count(self, types, i, n, used, rem):\\n        if rem < 0:\\n            return 0\\n        if i >= n:\\n            return int(rem == 0)\\n        key = (i, used, rem)\\n        if key in self.cache:\\n            return self.cache[key]\\n        res = 0\\n        if used < types[i][0]:\\n            res += self.count(types, i, n, used + 1, rem - types[i][1])\\n        res += self.count(types, i + 1, n, 0, rem)\\n        res %= M\\n        self.cache[key] = res\\n        return res\\n    \\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\\n        self.cache = {}\\n        return self.count(types, 0, len(types), 0, target)\\n```",
                "solutionTags": [],
                "code": "```\\nM = 10 ** 9 + 7\\n\\nclass Solution:\\n    def count(self, types, i, n, used, rem):\\n        if rem < 0:\\n            return 0\\n        if i >= n:\\n            return int(rem == 0)\\n        key = (i, used, rem)\\n        if key in self.cache:\\n            return self.cache[key]\\n        res = 0\\n        if used < types[i][0]:\\n            res += self.count(types, i, n, used + 1, rem - types[i][1])\\n        res += self.count(types, i + 1, n, 0, rem)\\n        res %= M\\n        self.cache[key] = res\\n        return res\\n    \\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\\n        self.cache = {}\\n        return self.count(types, 0, len(types), 0, target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890200,
                "title": "c-python-knapsack-dp-solution-with-explanation",
                "content": "### \\n\\n```dp[i][j]``` is ways to get score ```j``` from ```type[0: i+1]```problems.\\n\\n```dp[i][j] = dp[i-1][j] + dp[i-1][j - mark_i+1] + dp[i-1][j - 2 * mark_i+1] + .. if dp[i-1][.] is valid```\\n\\nand ```dp[.][0]``` = 1.\\n\\n\\ntc is O(target * types.size()*  count), sc is O(target * types.size() ).\\n### python\\n```python\\nmod = int(1e9+7)\\nclass Solution:\\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\\n        dp = [[0] * (target + 1) for _ in range(len(types) + 1)]\\n        for i in range(len(types) + 1): dp[i][0] = 1\\n        cur_max = 0\\n        for i, (cnt, val) in enumerate(types):\\n            cur_max += cnt * val\\n            cur_max = min(cur_max, target)\\n            for j in range(1, cur_max + 1):\\n                for k in range(j, max(-1, j - cnt * val - 1), -val):\\n                    dp[i+1][j] += dp[i][k]\\n                    if dp[i+1][j] >= mod: dp[i+1][j] -= mod\\n        return dp[len(types)][target]\\n```\\n\\n\\n### c++\\n```cpp\\nconst int mod = 1e9 + 7;\\nclass Solution {\\npublic:\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        vector<vector<int>> dp (types.size() + 1, vector<int> (target + 1));\\n        for (int i = 0; i <= types.size(); i+=1) dp[i][0] = 1;\\n        for (int i = 0, cur_max = 0; i < types.size(); i+=1) {\\n            int& cnt = types[i][0], & val = types[i][1];\\n            cur_max = min(cur_max + cnt * val, target);\\n            for (int j = 1; j <= cur_max; j+=1) {\\n                for (int k = j, t = max(0, j - cnt * val); k >= t; k -= val) {\\n                    dp[i+1][j] += dp[i][k];\\n                    if (dp[i+1][j] >= mod) dp[i+1][j] -= mod;\\n                }\\n            }\\n        }\\n        return dp[types.size()][target];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```dp[i][j]```\n```j```\n```type[0: i+1]```\n```dp[i][j] = dp[i-1][j] + dp[i-1][j - mark_i+1] + dp[i-1][j - 2 * mark_i+1] + .. if dp[i-1][.] is valid```\n```dp[.][0]```\n```python\\nmod = int(1e9+7)\\nclass Solution:\\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\\n        dp = [[0] * (target + 1) for _ in range(len(types) + 1)]\\n        for i in range(len(types) + 1): dp[i][0] = 1\\n        cur_max = 0\\n        for i, (cnt, val) in enumerate(types):\\n            cur_max += cnt * val\\n            cur_max = min(cur_max, target)\\n            for j in range(1, cur_max + 1):\\n                for k in range(j, max(-1, j - cnt * val - 1), -val):\\n                    dp[i+1][j] += dp[i][k]\\n                    if dp[i+1][j] >= mod: dp[i+1][j] -= mod\\n        return dp[len(types)][target]\\n```\n```cpp\\nconst int mod = 1e9 + 7;\\nclass Solution {\\npublic:\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        vector<vector<int>> dp (types.size() + 1, vector<int> (target + 1));\\n        for (int i = 0; i <= types.size(); i+=1) dp[i][0] = 1;\\n        for (int i = 0, cur_max = 0; i < types.size(); i+=1) {\\n            int& cnt = types[i][0], & val = types[i][1];\\n            cur_max = min(cur_max + cnt * val, target);\\n            for (int j = 1; j <= cur_max; j+=1) {\\n                for (int k = j, t = max(0, j - cnt * val); k >= t; k -= val) {\\n                    dp[i+1][j] += dp[i][k];\\n                    if (dp[i+1][j] >= mod) dp[i+1][j] -= mod;\\n                }\\n            }\\n        }\\n        return dp[types.size()][target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848162,
                "title": "easy-c-solution-using-dp",
                "content": "```\\npublic class Solution {\\n    public int WaysToReachTarget(int target, int[][] types) {\\n        int n = types.Length, mod = ((int)1e9) + 7;\\n        int[][] dp = new int[n][];\\n        for(int i = 0; i < n;i++){\\n            dp[i] = new int[target + 1];\\n            Array.Fill(dp[i],-1);\\n        }\\n        int solve(int idx,int remain){\\n            if(remain == 0) return 1;\\n            if(idx >= n) return 0;\\n            if(dp[idx][remain] != -1) return dp[idx][remain];\\n            int res = 0;\\n            for(int i = 0; i <= types[idx][0];i++){\\n                int cost = i * types[idx][1];\\n                if(cost > remain) break;\\n                res = (res % mod + solve(idx + 1,remain - cost) % mod ) % mod; \\n            }\\n            return dp[idx][remain] = res;\\n        }\\n        return solve(0,target);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution {\\n    public int WaysToReachTarget(int target, int[][] types) {\\n        int n = types.Length, mod = ((int)1e9) + 7;\\n        int[][] dp = new int[n][];\\n        for(int i = 0; i < n;i++){\\n            dp[i] = new int[target + 1];\\n            Array.Fill(dp[i],-1);\\n        }\\n        int solve(int idx,int remain){\\n            if(remain == 0) return 1;\\n            if(idx >= n) return 0;\\n            if(dp[idx][remain] != -1) return dp[idx][remain];\\n            int res = 0;\\n            for(int i = 0; i <= types[idx][0];i++){\\n                int cost = i * types[idx][1];\\n                if(cost > remain) break;\\n                res = (res % mod + solve(idx + 1,remain - cost) % mod ) % mod; \\n            }\\n            return dp[idx][remain] = res;\\n        }\\n        return solve(0,target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833748,
                "title": "dp-memorization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimilar to coin change\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRecursion with loop\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int target, vector<vector<int>>& types, int i, vector<vector<int>>&dp){\\n        int mod = 1000000007;\\n        if(target ==0)return 1;\\n        if(i>=types.size())return 0;\\n        //take\\n        if(dp[target][i] !=-1)return dp[target][i];\\n        long long take = 0;\\n        for(int j =1; j<=types[i][0]; j++){\\n            if(target >= types[i][1]*j)\\n                take = (take + solve(target - types[i][1]*j, types, i+1, dp))%mod;\\n        }\\n        int notake = solve(target, types, i+1, dp);\\n\\n        return dp[target][i] = (take + notake)%mod;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        vector<vector<int>>dp(target+1, vector<int>(types.size()+1,-1));\\n        return solve(target, types, 0, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int target, vector<vector<int>>& types, int i, vector<vector<int>>&dp){\\n        int mod = 1000000007;\\n        if(target ==0)return 1;\\n        if(i>=types.size())return 0;\\n        //take\\n        if(dp[target][i] !=-1)return dp[target][i];\\n        long long take = 0;\\n        for(int j =1; j<=types[i][0]; j++){\\n            if(target >= types[i][1]*j)\\n                take = (take + solve(target - types[i][1]*j, types, i+1, dp))%mod;\\n        }\\n        int notake = solve(target, types, i+1, dp);\\n\\n        return dp[target][i] = (take + notake)%mod;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        vector<vector<int>>dp(target+1, vector<int>(types.size()+1,-1));\\n        return solve(target, types, 0, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783405,
                "title": "dynamic-programming-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    KnapSack 0/1 Dp with bounded coin change problem\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    same unbounded coin change problem but also track of cnt[i]\\n    type . take that element until cnt [i]>0 other wise dont take \\n    and sum of both ans;\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N*51* target)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N*51* target)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dp[51][51][1001];\\n    int mod=1e9+7;\\n    int solve(int i,int target,vector<int>&cnt,vector<int>&nums){\\n        int n=nums.size(); \\n        if(target==0){\\n            return 1;\\n        }\\n        if(target<0||i>=n)return 0;\\n        if(dp[i][cnt[i]][target]!=-1)return dp[i][cnt[i]][target];\\n        int ans=solve(i+1,target,cnt,nums)%mod;\\n        cnt[i]-=1;\\n        ans+=cnt[i]>=0?solve(i,target-nums[i],cnt,nums)%mod:0;\\n        cnt[i]+=1;\\n        ans%=mod;\\n        return dp[i][cnt[i]][target]=ans;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n=types.size();\\n        vector<int>cnt(n,0);\\n        vector<int>nums(n,0);\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<n;i++){\\n            cnt[i]=types[i][0];\\n            nums[i]=types[i][1];\\n        }\\n       return solve(0,target,cnt,nums); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[51][51][1001];\\n    int mod=1e9+7;\\n    int solve(int i,int target,vector<int>&cnt,vector<int>&nums){\\n        int n=nums.size(); \\n        if(target==0){\\n            return 1;\\n        }\\n        if(target<0||i>=n)return 0;\\n        if(dp[i][cnt[i]][target]!=-1)return dp[i][cnt[i]][target];\\n        int ans=solve(i+1,target,cnt,nums)%mod;\\n        cnt[i]-=1;\\n        ans+=cnt[i]>=0?solve(i,target-nums[i],cnt,nums)%mod:0;\\n        cnt[i]+=1;\\n        ans%=mod;\\n        return dp[i][cnt[i]][target]=ans;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n=types.size();\\n        vector<int>cnt(n,0);\\n        vector<int>nums(n,0);\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<n;i++){\\n            cnt[i]=types[i][0];\\n            nums[i]=types[i][1];\\n        }\\n       return solve(0,target,cnt,nums); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749520,
                "title": "very-simple-recursion-memorization-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O[n*max(types[i][0])]$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O[n*target]$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    vector<vector<int>> dp;\\n    int waysToReachTargetHelper(int i,vector<vector<int>>& types,int target){\\n        if(target==0){\\n            return 1;\\n        }\\n        if(target<0){\\n            return 0;\\n        }\\n        if(i>=types.size()){\\n            return 0;\\n        }\\n        if(dp[i][target]!=-1){\\n            return dp[i][target];\\n        }\\n        long long int take=0;\\n        for(int k=1;k<=types[i][0];k++){\\n            long long int ans=waysToReachTargetHelper(i+1,types,target-(k*types[i][1]));\\n            ans%=mod;\\n            take+=ans;\\n            take%=mod;\\n        }\\n        long long int notTake=waysToReachTargetHelper(i+1,types,target);\\n        notTake%=mod;\\n        return dp[i][target]=(take+notTake)%mod;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        dp=vector<vector<int>> (types.size()+1,vector<int> (target+1,-1));\\n        return waysToReachTargetHelper(0,types,target);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    vector<vector<int>> dp;\\n    int waysToReachTargetHelper(int i,vector<vector<int>>& types,int target){\\n        if(target==0){\\n            return 1;\\n        }\\n        if(target<0){\\n            return 0;\\n        }\\n        if(i>=types.size()){\\n            return 0;\\n        }\\n        if(dp[i][target]!=-1){\\n            return dp[i][target];\\n        }\\n        long long int take=0;\\n        for(int k=1;k<=types[i][0];k++){\\n            long long int ans=waysToReachTargetHelper(i+1,types,target-(k*types[i][1]));\\n            ans%=mod;\\n            take+=ans;\\n            take%=mod;\\n        }\\n        long long int notTake=waysToReachTargetHelper(i+1,types,target);\\n        notTake%=mod;\\n        return dp[i][target]=(take+notTake)%mod;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        dp=vector<vector<int>> (types.size()+1,vector<int> (target+1,-1));\\n        return waysToReachTargetHelper(0,types,target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748750,
                "title": "simple-c-solution-dynamic-programming-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint mod=1e9+7;\\nlong long hope(int index,int marksleft,int qused,vector<vector<int>>& types,vector<vector<vector<long long>>>&dp){\\n    if(marksleft==0)return 1;\\n    if(marksleft<0)return 0;\\n    if(index>=types.size()){\\n        return 0;\\n    }\\n    if(dp[index][marksleft][qused]!=-1)return dp[index][marksleft][qused];\\n    long long pick=0;\\n    long long not_pick=0;\\n    if(marksleft>=types[index][1] && qused<types[index][0]){\\n        pick=hope(index,marksleft-types[index][1],qused+1,types,dp)%mod;\\n    }\\n    not_pick=hope(index+1,marksleft,0,types,dp)%mod;\\n    return dp[index][marksleft][qused]=(pick+not_pick)%mod;\\n}\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        vector<vector<long long>>dp1(target+1,vector<long long>(51,-1));\\n        vector<vector<vector<long long>>>dp(types.size(),dp1);\\n        long long ans=hope(0,target,0,types,dp);\\n        int answer=ans%mod;\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint mod=1e9+7;\\nlong long hope(int index,int marksleft,int qused,vector<vector<int>>& types,vector<vector<vector<long long>>>&dp){\\n    if(marksleft==0)return 1;\\n    if(marksleft<0)return 0;\\n    if(index>=types.size()){\\n        return 0;\\n    }\\n    if(dp[index][marksleft][qused]!=-1)return dp[index][marksleft][qused];\\n    long long pick=0;\\n    long long not_pick=0;\\n    if(marksleft>=types[index][1] && qused<types[index][0]){\\n        pick=hope(index,marksleft-types[index][1],qused+1,types,dp)%mod;\\n    }\\n    not_pick=hope(index+1,marksleft,0,types,dp)%mod;\\n    return dp[index][marksleft][qused]=(pick+not_pick)%mod;\\n}\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        vector<vector<long long>>dp1(target+1,vector<long long>(51,-1));\\n        vector<vector<vector<long long>>>dp(types.size(),dp1);\\n        long long ans=hope(0,target,0,types,dp);\\n        int answer=ans%mod;\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748529,
                "title": "easy-to-read",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o( n * 50 * target )\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o( target )\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long mod = 1e9 + 7;\\n\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        vector<int>  waysToScoreMarks(target+1);\\n        waysToScoreMarks[0] = 1;\\n        int marks, count;\\n\\n        for(vector<int> type : types){\\n            marks = type[1];  count = type[0];\\n            for(int j = target-marks; j >= 0; j--){\\n                if( waysToScoreMarks[j] == 0 ) continue;\\n                for(int k = 1; k <= count; k++){\\n                    if( j + k*marks > target ) break;\\n                    waysToScoreMarks[ j + k*marks ] = ( (long long)waysToScoreMarks[ j + k*marks ] + waysToScoreMarks[j] ) % mod;\\n                }\\n            }\\n        }\\n\\n        return waysToScoreMarks[target];\\n    }\\n};\\n\\n/*\\n\\nwaysToScoreMarks\\n0  0  1  2  3  4  5  6\\n0  0 -1 -1 -1 -1 -1 -1\\n1  0  1  1  1  1  1  1\\n2  0  1  2  2  3  3  3  \\n3  \\n\\n\\n\\n*/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long mod = 1e9 + 7;\\n\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        vector<int>  waysToScoreMarks(target+1);\\n        waysToScoreMarks[0] = 1;\\n        int marks, count;\\n\\n        for(vector<int> type : types){\\n            marks = type[1];  count = type[0];\\n            for(int j = target-marks; j >= 0; j--){\\n                if( waysToScoreMarks[j] == 0 ) continue;\\n                for(int k = 1; k <= count; k++){\\n                    if( j + k*marks > target ) break;\\n                    waysToScoreMarks[ j + k*marks ] = ( (long long)waysToScoreMarks[ j + k*marks ] + waysToScoreMarks[j] ) % mod;\\n                }\\n            }\\n        }\\n\\n        return waysToScoreMarks[target];\\n    }\\n};\\n\\n/*\\n\\nwaysToScoreMarks\\n0  0  1  2  3  4  5  6\\n0  0 -1 -1 -1 -1 -1 -1\\n1  0  1  1  1  1  1  1\\n2  0  1  2  2  3  3  3  \\n3  \\n\\n\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704521,
                "title": "easy-dp-c-recursive-and-memoized-solution",
                "content": "# Intuition\\nThink Recursively\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int solve(vector<vector<int>> &nums,int idx,int target,vector<vector<int>> &dp){        \\n        \\n        if(idx==nums.size()){\\n            if(target==0) return 1;\\n            return 0;\\n        }\\n        if(dp[idx][target]!=-1){\\n            return dp[idx][target];\\n        }\\n        int nottake=solve(nums,idx+1,target,dp)%mod;\\n        int take=0;\\n        int sum=0;\\n        for(int i=1;i<=nums[idx][0];i++){\\n            sum+=nums[idx][1];\\n            if(sum<=target){\\n                take+=(solve(nums,idx+1,target-sum,dp)%mod)%mod;\\n                take=take%mod;\\n            }\\n            \\n        }\\n        return dp[idx][target] = (take+nottake)%mod;\\n\\n    }\\n\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n=types.size();\\n    vector<vector<int>> dp(n+1,vector<int>(target+1,-1));\\n        return solve(types,0,target,dp)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int solve(vector<vector<int>> &nums,int idx,int target,vector<vector<int>> &dp){        \\n        \\n        if(idx==nums.size()){\\n            if(target==0) return 1;\\n            return 0;\\n        }\\n        if(dp[idx][target]!=-1){\\n            return dp[idx][target];\\n        }\\n        int nottake=solve(nums,idx+1,target,dp)%mod;\\n        int take=0;\\n        int sum=0;\\n        for(int i=1;i<=nums[idx][0];i++){\\n            sum+=nums[idx][1];\\n            if(sum<=target){\\n                take+=(solve(nums,idx+1,target-sum,dp)%mod)%mod;\\n                take=take%mod;\\n            }\\n            \\n        }\\n        return dp[idx][target] = (take+nottake)%mod;\\n\\n    }\\n\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n=types.size();\\n    vector<vector<int>> dp(n+1,vector<int>(target+1,-1));\\n        return solve(types,0,target,dp)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674540,
                "title": "easy-c-knapsack-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere we have to complete our target by choosing some of the problems on any time, So we can got to all of the available problems types and select them or not according to the availability of target.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust iterate from 0 to nums.size()-1 and choose how many questions the specific question from 0 to nums[i][1] and then make recursive calls ahead.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint dp[55][1005];\\nint mod=1e9+7;\\nint solve(vector<vector<int>> &nums,int i,int k){\\n    if(k<0){\\n        return 0;\\n    }\\n    if(k==0){\\n        return 1;\\n    }\\n    if(i>=nums.size()){\\n        if(k==0){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n    if(dp[i][k]!=-1){\\n        return dp[i][k];\\n    }\\n    int a=0;\\n    for(int j=0;j<=nums[i][0];j++){\\n        a=(a+solve(nums,i+1,k-nums[i][1]*j))%mod;\\n    }\\n    return dp[i][k]=a%mod;\\n}\\n    int waysToReachTarget(int target, vector<vector<int>>& nums) {\\n        memset(dp,-1,sizeof dp);\\n        return solve(nums,0,target);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint dp[55][1005];\\nint mod=1e9+7;\\nint solve(vector<vector<int>> &nums,int i,int k){\\n    if(k<0){\\n        return 0;\\n    }\\n    if(k==0){\\n        return 1;\\n    }\\n    if(i>=nums.size()){\\n        if(k==0){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n    if(dp[i][k]!=-1){\\n        return dp[i][k];\\n    }\\n    int a=0;\\n    for(int j=0;j<=nums[i][0];j++){\\n        a=(a+solve(nums,i+1,k-nums[i][1]*j))%mod;\\n    }\\n    return dp[i][k]=a%mod;\\n}\\n    int waysToReachTarget(int target, vector<vector<int>>& nums) {\\n        memset(dp,-1,sizeof dp);\\n        return solve(nums,0,target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672640,
                "title": "c-easy-to-understand-recursion-memoization",
                "content": "** \\u2764KINDLY UPVOTE IF YOU GET ANY HELP FROM THIS SOLUTION.**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int solve(int target, vector<vector<int>>&types, int index,vector<vector<int>>&dp)\\n    {\\n        // Base Case\\n        if(target<0) return 0;\\n        if(index==types.size()) return target==0;\\n       \\n        if(dp[index][target]!=-1) return dp[index][target];\\n\\n        int ans=0;     \\n        // I can choose any no of questions available at current index\\n        int mark=types[index][1];\\n        int ques =types[index][0];\\n\\n        int curMarks=0;\\n        for(int i=1;i<=ques;i++)\\n        {\\n            curMarks+=mark;\\n            ans+=solve(target-curMarks,types,index+1,dp)%mod;\\n            ans%=mod;\\n        }\\n\\n        // I can also choose to not select any question from cur Index\\n        ans+=solve(target,types,index+1,dp)%mod;\\n        return dp[index][target]=ans%mod;\\n    }\\n\\n    int waysToReachTarget(int target, vector<vector<int>>& types) \\n    {\\n        vector<vector<int>>dp(types.size(),vector<int>(target+1,-1));\\n        return solve(target,types,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int solve(int target, vector<vector<int>>&types, int index,vector<vector<int>>&dp)\\n    {\\n        // Base Case\\n        if(target<0) return 0;\\n        if(index==types.size()) return target==0;\\n       \\n        if(dp[index][target]!=-1) return dp[index][target];\\n\\n        int ans=0;     \\n        // I can choose any no of questions available at current index\\n        int mark=types[index][1];\\n        int ques =types[index][0];\\n\\n        int curMarks=0;\\n        for(int i=1;i<=ques;i++)\\n        {\\n            curMarks+=mark;\\n            ans+=solve(target-curMarks,types,index+1,dp)%mod;\\n            ans%=mod;\\n        }\\n\\n        // I can also choose to not select any question from cur Index\\n        ans+=solve(target,types,index+1,dp)%mod;\\n        return dp[index][target]=ans%mod;\\n    }\\n\\n    int waysToReachTarget(int target, vector<vector<int>>& types) \\n    {\\n        vector<vector<int>>dp(types.size(),vector<int>(target+1,-1));\\n        return solve(target,types,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647251,
                "title": "c-knapsack-dp-tabular-dp-easy-to-understand",
                "content": "# Intuition\\nKnapsack DP\\n# Approach\\nWe would try to use all questions from type i starting from zero questions to count questions or to the limit constrained due to marks.\\nOn using questions from type i, we would try to achieve rest marks from [0...i-1] types.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * target * max(cnt))$$\\n\\n- Space complexity:\\n$$O(n*target)$$\\n\\n# Code\\n```\\nclass Solution {\\nint mod = 1000000007;\\npublic:\\n\\tint waysToReachTarget(int target, vector<vector<int>> &types) {\\n\\t\\tvector<vector<int>> dp(types.size() + 1, vector<int>(target + 1));\\n\\n\\t\\tfor(int i = 1; i <= target; ++i) {\\n            dp[0][i] = 0;\\n        }\\n        for(int i = 0; i <= types.size(); ++i) {\\n            dp[i][0] = 1;\\n        }\\n\\n        for(int i = 1; i <= types.size(); ++i) {\\n            for(int j = 1; j <= target; ++j) {\\n                dp[i][j] = 0;\\n\\n                int cnt = types[i - 1][0];\\n                int marks = types[i - 1][1];\\n\\n                for(int k = 0; k <= cnt && k*marks <= j; ++k) {\\n                    dp[i][j] =(1ll*dp[i][j] +  dp[i - 1][j - k * marks])%mod;\\n                }\\n            }\\n        }\\n        return dp[types.size()][target];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nint mod = 1000000007;\\npublic:\\n\\tint waysToReachTarget(int target, vector<vector<int>> &types) {\\n\\t\\tvector<vector<int>> dp(types.size() + 1, vector<int>(target + 1));\\n\\n\\t\\tfor(int i = 1; i <= target; ++i) {\\n            dp[0][i] = 0;\\n        }\\n        for(int i = 0; i <= types.size(); ++i) {\\n            dp[i][0] = 1;\\n        }\\n\\n        for(int i = 1; i <= types.size(); ++i) {\\n            for(int j = 1; j <= target; ++j) {\\n                dp[i][j] = 0;\\n\\n                int cnt = types[i - 1][0];\\n                int marks = types[i - 1][1];\\n\\n                for(int k = 0; k <= cnt && k*marks <= j; ++k) {\\n                    dp[i][j] =(1ll*dp[i][j] +  dp[i - 1][j - k * marks])%mod;\\n                }\\n            }\\n        }\\n        return dp[types.size()][target];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3638404,
                "title": "way-to-raech-target-usin-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int waysToReachTarget(int target, int[][] types) {\\n    final int kMod = 1_000_000_007;\\n    int[][] dp = new int[types.length + 1][target + 1];\\n    dp[0][0] = 1;\\n\\n    for (int i = 1; i <= types.length; ++i) {\\n      final int count = types[i - 1][0];\\n      final int mark = types[i - 1][1];\\n      for (int j = 0; j <= target; ++j)\\n        for (int solved = 0; solved <= count; ++solved)\\n          if (j - solved * mark >= 0) {\\n            dp[i][j] += dp[i - 1][j - solved * mark];\\n            dp[i][j] %= kMod;\\n          }\\n    }\\n\\n    return dp[types.length][target];\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int waysToReachTarget(int target, int[][] types) {\\n    final int kMod = 1_000_000_007;\\n    int[][] dp = new int[types.length + 1][target + 1];\\n    dp[0][0] = 1;\\n\\n    for (int i = 1; i <= types.length; ++i) {\\n      final int count = types[i - 1][0];\\n      final int mark = types[i - 1][1];\\n      for (int j = 0; j <= target; ++j)\\n        for (int solved = 0; solved <= count; ++solved)\\n          if (j - solved * mark >= 0) {\\n            dp[i][j] += dp[i - 1][j - solved * mark];\\n            dp[i][j] %= kMod;\\n          }\\n    }\\n\\n    return dp[types.length][target];\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619763,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\napproach like it is a whole coin with value k*v[i][1] where k<=v[i][0] &&k>=1\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint mod=1e9+7;\\nint f(int i,int target,vector<vector<int>>& types,vector<vector<int>> &dp){\\nif(target==0) return 1;\\nif(i==types.size()) return 0;\\nif(dp[i][target]!=-1) return dp[i][target];\\nlong long int ans=0;\\nfor(int ind=1;ind<=types[i][0];ind++){\\nif(ind*types[i][1]<=target){\\n        \\n        ans=(ans%mod+f(i+1,target-ind*types[i][1],types,dp)%mod)%mod;\\n        \\n    }\\n\\n}\\n    \\n   ans= (ans%mod+f(i+1,target,types,dp)%mod)%mod;\\n    return dp[i][target]= ans;\\n}\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        vector<vector<int>> dp(types.size(),vector<int>(target+1,-1));\\n       return f(0,target,types,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint mod=1e9+7;\\nint f(int i,int target,vector<vector<int>>& types,vector<vector<int>> &dp){\\nif(target==0) return 1;\\nif(i==types.size()) return 0;\\nif(dp[i][target]!=-1) return dp[i][target];\\nlong long int ans=0;\\nfor(int ind=1;ind<=types[i][0];ind++){\\nif(ind*types[i][1]<=target){\\n        \\n        ans=(ans%mod+f(i+1,target-ind*types[i][1],types,dp)%mod)%mod;\\n        \\n    }\\n\\n}\\n    \\n   ans= (ans%mod+f(i+1,target,types,dp)%mod)%mod;\\n    return dp[i][target]= ans;\\n}\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        vector<vector<int>> dp(types.size(),vector<int>(target+1,-1));\\n       return f(0,target,types,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618445,
                "title": "simple-memoization-solution-c",
                "content": "# Complexity\\n- Time complexity: O(Target*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(Target*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int M;\\n    int solv(int target, vector<vector<int>>& types, int i,vector<vector<int>> &dp){\\n        if(i == types.size()){\\n            if(target == 0) return 1;\\n            return 0;\\n        }\\n        if(target == 0) return 1;\\n        // We have found this state before  \\n        if(dp[target][i] != -1) return dp[target][i];\\n        int ans = 0;\\n        // Now we solve this i\\'th question\\n        for(int k=0;k<=types[i][0];k++){\\n            if(target - types[i][1]*k < 0) break;\\n            ans = (ans + solv(target - types[i][1]*k,types,i+1,dp))%M;\\n        }\\n        return dp[target][i] = ans;\\n    }\\n\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int ans = 0;\\n        M = 1e9 + 7;\\n        vector<vector<int>> dp(target+1,vector<int>(types.size()+1,-1));\\n        return solv(target,types,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int M;\\n    int solv(int target, vector<vector<int>>& types, int i,vector<vector<int>> &dp){\\n        if(i == types.size()){\\n            if(target == 0) return 1;\\n            return 0;\\n        }\\n        if(target == 0) return 1;\\n        // We have found this state before  \\n        if(dp[target][i] != -1) return dp[target][i];\\n        int ans = 0;\\n        // Now we solve this i\\'th question\\n        for(int k=0;k<=types[i][0];k++){\\n            if(target - types[i][1]*k < 0) break;\\n            ans = (ans + solv(target - types[i][1]*k,types,i+1,dp))%M;\\n        }\\n        return dp[target][i] = ans;\\n    }\\n\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int ans = 0;\\n        M = 1e9 + 7;\\n        vector<vector<int>> dp(target+1,vector<int>(types.size()+1,-1));\\n        return solv(target,types,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613532,
                "title": "c",
                "content": "```\\nclass Solution {\\n    int M = 1e9 + 7 ;\\npublic:\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n = types.size() ;\\n        vector<vector<long long>>dp(n+1, vector<long long>(target+1, 0)) ;\\n        types.insert(types.begin() ,{0,0}) ;\\n        dp[0][0] = 1 ;\\n        for(int i = 1; i <= n; i++){\\n            for(int j = 0; j <= target; j++){\\n                for(int k = 0; k <= types[i][0]; k++){\\n                    int idx =  j - types[i][1]*k ;\\n                    if(idx < 0)\\n                        break ;\\n                    dp[i][j] += dp[i-1][idx] ;\\n                    dp[i][j] %= M ;                   \\n                }\\n            }            \\n        }           \\n        return dp[n][target] ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int M = 1e9 + 7 ;\\npublic:\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n = types.size() ;\\n        vector<vector<long long>>dp(n+1, vector<long long>(target+1, 0)) ;\\n        types.insert(types.begin() ,{0,0}) ;\\n        dp[0][0] = 1 ;\\n        for(int i = 1; i <= n; i++){\\n            for(int j = 0; j <= target; j++){\\n                for(int k = 0; k <= types[i][0]; k++){\\n                    int idx =  j - types[i][1]*k ;\\n                    if(idx < 0)\\n                        break ;\\n                    dp[i][j] += dp[i-1][idx] ;\\n                    dp[i][j] %= M ;                   \\n                }\\n            }            \\n        }           \\n        return dp[n][target] ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573522,
                "title": "best-dp-question-c-solution-most-space-optimized",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    const int M = 1e9 + 7;\\n    using ll = long long;\\n    int f(int ind,int target,vector<vector<int>>types,vector<vector<int>>&dp){\\n        if(target == 0)return 1;\\n        if(target<0)return 0;\\n        if(ind == types.size()){\\n            if(target == 0)return 1;\\n            else return 0;\\n        }\\n\\n        if(dp[ind][target]!=-1)return dp[ind][target]%M;\\n        int nottake = 0;\\n        int take = 0;\\n        nottake +=f(ind+1,target,types,dp);\\n        for(int i=1;i<=types[ind][0];i++){\\n            if(target>=i*types[ind][1]){\\n                take += f(ind+1,target-i*types[ind][1],types,dp);\\n                take = take%M;\\n            }\\n        }\\n        return dp[ind][target] = (take + nottake)%M;\\n    }\\npublic:\\n    int waysToReachTarget(int t, vector<vector<int>>& types) {\\n        \\n        int n  = types.size();\\n        int T = t;\\n        vector<int>curr(T+1,0);\\n        vector<int> after(T+1,0);\\n        after[0] = 1;//base case is target == 0\\n        for(int ind=n-1;ind>=0;ind--){\\n            for(int target=t;target>=0;target--){\\n                int take = 0;\\n                int nottake = after[target];\\n                for(int i=1;i<=types[ind][0];i++){\\n                    if(target>=i*types[ind][1]){\\n                        take+=after[target-i*types[ind][1]];\\n                        take=take%M;\\n                    }\\n                }\\n                curr[target] = (take + nottake)%M;\\n            }\\n            after = curr;\\n        }\\n        return after[T];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    const int M = 1e9 + 7;\\n    using ll = long long;\\n    int f(int ind,int target,vector<vector<int>>types,vector<vector<int>>&dp){\\n        if(target == 0)return 1;\\n        if(target<0)return 0;\\n        if(ind == types.size()){\\n            if(target == 0)return 1;\\n            else return 0;\\n        }\\n\\n        if(dp[ind][target]!=-1)return dp[ind][target]%M;\\n        int nottake = 0;\\n        int take = 0;\\n        nottake +=f(ind+1,target,types,dp);\\n        for(int i=1;i<=types[ind][0];i++){\\n            if(target>=i*types[ind][1]){\\n                take += f(ind+1,target-i*types[ind][1],types,dp);\\n                take = take%M;\\n            }\\n        }\\n        return dp[ind][target] = (take + nottake)%M;\\n    }\\npublic:\\n    int waysToReachTarget(int t, vector<vector<int>>& types) {\\n        \\n        int n  = types.size();\\n        int T = t;\\n        vector<int>curr(T+1,0);\\n        vector<int> after(T+1,0);\\n        after[0] = 1;//base case is target == 0\\n        for(int ind=n-1;ind>=0;ind--){\\n            for(int target=t;target>=0;target--){\\n                int take = 0;\\n                int nottake = after[target];\\n                for(int i=1;i<=types[ind][0];i++){\\n                    if(target>=i*types[ind][1]){\\n                        take+=after[target-i*types[ind][1]];\\n                        take=take%M;\\n                    }\\n                }\\n                curr[target] = (take + nottake)%M;\\n            }\\n            after = curr;\\n        }\\n        return after[T];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551456,
                "title": "java-recursive-memoization-commented-easy-to-understand-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSomewhat similar to \\nhttps://leetcode.com/problems/maximum-value-of-k-coins-from-piles/description/\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    int mod = 1000000007;\\n    Integer[][] memo;\\n\\n    int helper(int[][] types, int target, int typeIndex){\\n        int n = types.length;\\n\\n        //we have reached end of types[][] and further we can\\'t choose any more\\n        //questions, now if our target is 0 return 1 as there is atleast 1 way\\n        //else return 0\\n        if(typeIndex >= n) return target == 0 ? 1 : 0;\\n\\n        if(memo[typeIndex][target] != null) return memo[typeIndex][target];\\n\\n        int ways = 0;\\n\\n        //2 choices we have,\\n\\n        //1. don\\'t pick the questions of the curr type @typeIndex and simply move\\n        //to next type (==> typeIndex + 1) and since we haven\\'t solved any question\\n        //of curr type we will not consider a single point from this question type\\n        ways = (ways + helper(types, target, typeIndex + 1)) % mod;\\n\\n        //2. pick the questions form the curr type @typeIndex, so if we are picking\\n        //then we can decide how many questions we can do from the curr \\'type\\', if\\n        //we do \\'x\\' amount of question from curr \\'type\\' then we can earn x * points\\n        //from those questions and if we have earned (x * points) then we can reduce\\n        //our target points by (x * points).\\n        //Also to note: if we have solved \\'x\\' questions from curr \\'type\\' then we\\n        //can also move to next type (==> typeIndex + 1) to solve the remaining\\n        //questions and earn remaining points from those \\'type\\'\\n        int currQuestCount = types[typeIndex][0];\\n        int currQuestPoint = types[typeIndex][1];\\n        int pointsEarned = 0;\\n        for(int quest = 1; quest <= currQuestCount; quest++){\\n            //pointsEarned = question * questionPoint\\n            pointsEarned = quest * currQuestPoint;\\n\\n            //break, if we have earned more points than curr target\\n            if(pointsEarned > target) break;\\n\\n            //currently we have solved \\'question\\' out of questionsCount and the\\n            //remaining questions we choose from next type(==> typeIndex + 1)\\n            //but we have earned \\'pointsEarned\\' points by solving \\'question\\'\\n            //so reduce the target with this much pointsEarned\\n            ways = (ways + helper(types, target - pointsEarned, typeIndex + 1)) % mod;\\n        }\\n        return memo[typeIndex][target] = ways;\\n    }\\n\\n    public int waysToReachTarget(int target, int[][] types) {\\n        int n = types.length;\\n        memo = new Integer[n + 1][target + 1];\\n        return helper(types, target, 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n\\n    int mod = 1000000007;\\n    Integer[][] memo;\\n\\n    int helper(int[][] types, int target, int typeIndex){\\n        int n = types.length;\\n\\n        //we have reached end of types[][] and further we can\\'t choose any more\\n        //questions, now if our target is 0 return 1 as there is atleast 1 way\\n        //else return 0\\n        if(typeIndex >= n) return target == 0 ? 1 : 0;\\n\\n        if(memo[typeIndex][target] != null) return memo[typeIndex][target];\\n\\n        int ways = 0;\\n\\n        //2 choices we have,\\n\\n        //1. don\\'t pick the questions of the curr type @typeIndex and simply move\\n        //to next type (==> typeIndex + 1) and since we haven\\'t solved any question\\n        //of curr type we will not consider a single point from this question type\\n        ways = (ways + helper(types, target, typeIndex + 1)) % mod;\\n\\n        //2. pick the questions form the curr type @typeIndex, so if we are picking\\n        //then we can decide how many questions we can do from the curr \\'type\\', if\\n        //we do \\'x\\' amount of question from curr \\'type\\' then we can earn x * points\\n        //from those questions and if we have earned (x * points) then we can reduce\\n        //our target points by (x * points).\\n        //Also to note: if we have solved \\'x\\' questions from curr \\'type\\' then we\\n        //can also move to next type (==> typeIndex + 1) to solve the remaining\\n        //questions and earn remaining points from those \\'type\\'\\n        int currQuestCount = types[typeIndex][0];\\n        int currQuestPoint = types[typeIndex][1];\\n        int pointsEarned = 0;\\n        for(int quest = 1; quest <= currQuestCount; quest++){\\n            //pointsEarned = question * questionPoint\\n            pointsEarned = quest * currQuestPoint;\\n\\n            //break, if we have earned more points than curr target\\n            if(pointsEarned > target) break;\\n\\n            //currently we have solved \\'question\\' out of questionsCount and the\\n            //remaining questions we choose from next type(==> typeIndex + 1)\\n            //but we have earned \\'pointsEarned\\' points by solving \\'question\\'\\n            //so reduce the target with this much pointsEarned\\n            ways = (ways + helper(types, target - pointsEarned, typeIndex + 1)) % mod;\\n        }\\n        return memo[typeIndex][target] = ways;\\n    }\\n\\n    public int waysToReachTarget(int target, int[][] types) {\\n        int n = types.length;\\n        memo = new Integer[n + 1][target + 1];\\n        return helper(types, target, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549806,
                "title": "java-dp-memoization",
                "content": "# Code\\n```\\nclass Solution {\\n    int mod = 1000000007;\\n    public int waysToReachTarget(int target, int[][] types) {\\n        int[][] dp = new int[target+1][types.length];\\n        for(int[] a : dp){\\n            Arrays.fill(a,-1);\\n        }\\n        return find(0,0,dp,types,target);\\n    }\\n\\n    private int find(int sum,int index,int[][] dp,int[][] types,int target){\\n        if(sum == target){\\n            return 1;\\n        }\\n        if(index>=types.length || sum > target){\\n            return 0;\\n        }\\n        if(dp[sum][index]!=-1){            \\n            return dp[sum][index];\\n        }\\n        int ans = find(sum,index+1,dp,types,target)%mod;\\n        int val = types[index][0];\\n        for(int i=1;i<=val;i++){\\n            ans = (ans + find(sum+types[index][1]*i,index+1,dp,types,target)%mod)%mod;\\n        }\\n        return dp[sum][index] = ans;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int mod = 1000000007;\\n    public int waysToReachTarget(int target, int[][] types) {\\n        int[][] dp = new int[target+1][types.length];\\n        for(int[] a : dp){\\n            Arrays.fill(a,-1);\\n        }\\n        return find(0,0,dp,types,target);\\n    }\\n\\n    private int find(int sum,int index,int[][] dp,int[][] types,int target){\\n        if(sum == target){\\n            return 1;\\n        }\\n        if(index>=types.length || sum > target){\\n            return 0;\\n        }\\n        if(dp[sum][index]!=-1){            \\n            return dp[sum][index];\\n        }\\n        int ans = find(sum,index+1,dp,types,target)%mod;\\n        int val = types[index][0];\\n        for(int i=1;i<=val;i++){\\n            ans = (ans + find(sum+types[index][1]*i,index+1,dp,types,target)%mod)%mod;\\n        }\\n        return dp[sum][index] = ans;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524684,
                "title": "dp-memoization-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public long helper(int[][] types,int idx,int marks,int target,long[][] dp){\\n        if(marks>target) return 0;\\n        if(marks==target) return 1;\\n        if(idx==types.length) return 0;\\n        if(dp[idx][marks]!=-1) return dp[idx][marks];\\n        \\n        long ans=0;\\n        for(int j=0;j<=types[idx][0];j++){\\n            ans+=helper(types,idx+1,marks+j*types[idx][1],target,dp);\\n            ans%=1000000007;\\n        }\\n        return dp[idx][marks]=ans;\\n    }\\n    public int waysToReachTarget(int target, int[][] types) {\\n        long[][] dp=new long[types.length][target+1];\\n        for(int i=0;i<dp.length;i++) Arrays.fill(dp[i],-1);\\n        return (int)helper(types,0,0,target,dp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public long helper(int[][] types,int idx,int marks,int target,long[][] dp){\\n        if(marks>target) return 0;\\n        if(marks==target) return 1;\\n        if(idx==types.length) return 0;\\n        if(dp[idx][marks]!=-1) return dp[idx][marks];\\n        \\n        long ans=0;\\n        for(int j=0;j<=types[idx][0];j++){\\n            ans+=helper(types,idx+1,marks+j*types[idx][1],target,dp);\\n            ans%=1000000007;\\n        }\\n        return dp[idx][marks]=ans;\\n    }\\n    public int waysToReachTarget(int target, int[][] types) {\\n        long[][] dp=new long[types.length][target+1];\\n        for(int i=0;i<dp.length;i++) Arrays.fill(dp[i],-1);\\n        return (int)helper(types,0,0,target,dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498604,
                "title": "easy-classic-problem-of-choose-not-choose-c",
                "content": "# Intuition\\n- simple classic recurtion problem of choose not choose \\n- just here we have to decide choose zero,one ,two , three .... for each `type[i]`\\n- write straight forward recursive solution \\n- convert the bottom up solution to top down by reversing the variable parameters.\\n- return the ans\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(target*type.size*50)==>O(target*type.size^2)\\n\\n- Space complexity:\\n- $$O(target*50)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long M=1e9+7;\\n    int dp[1001][51];\\n    Solution()\\n    {\\n        for(int i=0;i<1001;i++)\\n        {\\n            for(int j=0;j<51;j++)\\n            {\\n                dp[i][j]=0;\\n                //dp[i][j=-1//for recurvice solution \\n            }\\n        }\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) \\n    {\\n        // return f(target,types);\\n        return f1(target,types);\\n    }\\n\\n    //recursive solution \\n    int f(int target,vector<vector<int>>&type,int i=0)\\n    {\\n        if (target==0)\\n        {\\n            return 1;\\n        }\\n        if (i==type.size())\\n        {\\n            return 0;\\n        }\\n        if (dp[target][i]!=-1)\\n        {\\n            return dp[target][i];\\n        }\\n        int ans=0;\\n        for(int j=0;j<=type[i][0];j++)\\n        {\\n            if (target-j*type[i][1]<0)\\n            {\\n                break;\\n            }\\n            ans=(ans+f(target-j*type[i][1],type,i+1))%M;\\n        }\\n        return dp[target][i]=ans%M;\\n    }\\n\\n\\n    //iterative solution \\n    int f1(int target,vector<vector<int>>&type)\\n    {\\n        for(int j=0;j<51;j++)\\n        {\\n            dp[0][j]=1;\\n        }\\n        for(int t=1;t<=target;t++)\\n        {\\n            for(int i=type.size()-1;i>=0;i--)\\n            {\\n                int ans=0;\\n                for(int j=0;j<=type[i][0];j++)\\n                {\\n                    if (t-j*type[i][1]<0)\\n                    {\\n                        break;\\n                    }\\n                    ans=(ans+dp[t-j*type[i][1]][i+1])%M;\\n                }\\n                dp[t][i]=ans;\\n            }\\n        }\\n        return dp[target][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long M=1e9+7;\\n    int dp[1001][51];\\n    Solution()\\n    {\\n        for(int i=0;i<1001;i++)\\n        {\\n            for(int j=0;j<51;j++)\\n            {\\n                dp[i][j]=0;\\n                //dp[i][j=-1//for recurvice solution \\n            }\\n        }\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) \\n    {\\n        // return f(target,types);\\n        return f1(target,types);\\n    }\\n\\n    //recursive solution \\n    int f(int target,vector<vector<int>>&type,int i=0)\\n    {\\n        if (target==0)\\n        {\\n            return 1;\\n        }\\n        if (i==type.size())\\n        {\\n            return 0;\\n        }\\n        if (dp[target][i]!=-1)\\n        {\\n            return dp[target][i];\\n        }\\n        int ans=0;\\n        for(int j=0;j<=type[i][0];j++)\\n        {\\n            if (target-j*type[i][1]<0)\\n            {\\n                break;\\n            }\\n            ans=(ans+f(target-j*type[i][1],type,i+1))%M;\\n        }\\n        return dp[target][i]=ans%M;\\n    }\\n\\n\\n    //iterative solution \\n    int f1(int target,vector<vector<int>>&type)\\n    {\\n        for(int j=0;j<51;j++)\\n        {\\n            dp[0][j]=1;\\n        }\\n        for(int t=1;t<=target;t++)\\n        {\\n            for(int i=type.size()-1;i>=0;i--)\\n            {\\n                int ans=0;\\n                for(int j=0;j<=type[i][0];j++)\\n                {\\n                    if (t-j*type[i][1]<0)\\n                    {\\n                        break;\\n                    }\\n                    ans=(ans+dp[t-j*type[i][1]][i+1])%M;\\n                }\\n                dp[t][i]=ans;\\n            }\\n        }\\n        return dp[target][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468996,
                "title": "c-dp-solution-with-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(target * n^count)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(target)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        std::vector<int> dp(target + 1, 0);\\n        dp[0] = 1;\\n        for (int i = 0; i < types.size(); i++) {\\n            std::vector<int> tmp = dp;\\n            for (int j = 1; j <= types[i][0]; j++) {\\n                for (int k = 0; k < dp.size(); k++) {\\n                    if (k + j * types[i][1] < dp.size()) {\\n                        tmp[k + j * types[i][1]] = (tmp[k + j * types[i][1]] + dp[k]) % 1000000007;\\n                    }\\n                }\\n            }\\n            dp = tmp;\\n        }\\n        return dp[dp.size() - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        std::vector<int> dp(target + 1, 0);\\n        dp[0] = 1;\\n        for (int i = 0; i < types.size(); i++) {\\n            std::vector<int> tmp = dp;\\n            for (int j = 1; j <= types[i][0]; j++) {\\n                for (int k = 0; k < dp.size(); k++) {\\n                    if (k + j * types[i][1] < dp.size()) {\\n                        tmp[k + j * types[i][1]] = (tmp[k + j * types[i][1]] + dp[k]) % 1000000007;\\n                    }\\n                }\\n            }\\n            dp = tmp;\\n        }\\n        return dp[dp.size() - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461303,
                "title": "java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    int mod=(int)Math.pow(10,9)+7;\\n    public int waysToReachTarget(int target, int[][] types) {\\n        int n=types.length;\\n        int dp[][]=new int[n][target+1];\\n        for(int r[]:dp)Arrays.fill(r,-1);\\n        return f(n-1,target,types,dp);\\n    }\\n    public int f(int ind,int target,int types[][],int dp[][])\\n    {\\n        if(target==0)return 1;\\n        if(ind<0)return 0;\\n        if(dp[ind][target]!=-1)return dp[ind][target]%mod;\\n        int ans=0;\\n        for(int i=0;i<=types[ind][0];i++)\\n        {\\n            if(i*types[ind][1]<=target)\\n                ans=((ans%mod)+f(ind-1,target-(i*types[ind][1]),types,dp)%mod)%mod;\\n        }\\n        return dp[ind][target]=ans%mod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int mod=(int)Math.pow(10,9)+7;\\n    public int waysToReachTarget(int target, int[][] types) {\\n        int n=types.length;\\n        int dp[][]=new int[n][target+1];\\n        for(int r[]:dp)Arrays.fill(r,-1);\\n        return f(n-1,target,types,dp);\\n    }\\n    public int f(int ind,int target,int types[][],int dp[][])\\n    {\\n        if(target==0)return 1;\\n        if(ind<0)return 0;\\n        if(dp[ind][target]!=-1)return dp[ind][target]%mod;\\n        int ans=0;\\n        for(int i=0;i<=types[ind][0];i++)\\n        {\\n            if(i*types[ind][1]<=target)\\n                ans=((ans%mod)+f(ind-1,target-(i*types[ind][1]),types,dp)%mod)%mod;\\n        }\\n        return dp[ind][target]=ans%mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423055,
                "title": "dp-o-target-types-length-max-types-0",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int dp[51][1001];  // \\u7528\\u524Di\\u79CD\\u7C7B\\u578B\\u62FF\\u5230j\\u5206\\u7684\\u65B9\\u6848\\u6570\\n        memset(dp, 0, sizeof(int) * 51 * 1001);\\n        int n = types.size();\\n        for (int i = 0; i <= n; i++) dp[i][0] = 1;\\n        int MOD = 1e9 + 7;\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= target; j++) {\\n                dp[i][j] = dp[i - 1][j];\\n                for (int k = 1; k <= types[i - 1][0] && j >= k * types[i - 1][1]; k++) {\\n                    dp[i][j] = (1LL * dp[i][j] + dp[i - 1][j - k * types[i - 1][1]]) % MOD;\\n                }\\n            }\\n        }\\n        return dp[n][target];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int dp[51][1001];  // \\u7528\\u524Di\\u79CD\\u7C7B\\u578B\\u62FF\\u5230j\\u5206\\u7684\\u65B9\\u6848\\u6570\\n        memset(dp, 0, sizeof(int) * 51 * 1001);\\n        int n = types.size();\\n        for (int i = 0; i <= n; i++) dp[i][0] = 1;\\n        int MOD = 1e9 + 7;\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= target; j++) {\\n                dp[i][j] = dp[i - 1][j];\\n                for (int k = 1; k <= types[i - 1][0] && j >= k * types[i - 1][1]; k++) {\\n                    dp[i][j] = (1LL * dp[i][j] + dp[i - 1][j - k * types[i - 1][1]]) % MOD;\\n                }\\n            }\\n        }\\n        return dp[n][target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418292,
                "title": "cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int func(vector<vector<int>>&arr , int i , int target , vector<vector<int>>&dp){\\n        int N=1e9+7;\\n        if(target==0) return 1;\\n        if(i>=arr.size()) return 0;\\n        if(dp[i][target]!=-1) return dp[i][target];\\n        int size= arr[i][0];\\n        int j=1 , sum =0 , ans = func(arr , i+1 ,target,dp);\\n        while(j<=size and sum+arr[i][1]<=target){\\n            sum+=arr[i][1];\\n            ans= (ans+ func(arr , i+1, target-arr[i][1]*j, dp))%N;\\n            j++;\\n        }\\n        return dp[i][target]=ans%N;\\n    }\\n\\n\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n=types.size();\\n        vector<vector<int>>dp(n , vector<int>(target+1 , -1));\\n        return func(types , 0 , target , dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int func(vector<vector<int>>&arr , int i , int target , vector<vector<int>>&dp){\\n        int N=1e9+7;\\n        if(target==0) return 1;\\n        if(i>=arr.size()) return 0;\\n        if(dp[i][target]!=-1) return dp[i][target];\\n        int size= arr[i][0];\\n        int j=1 , sum =0 , ans = func(arr , i+1 ,target,dp);\\n        while(j<=size and sum+arr[i][1]<=target){\\n            sum+=arr[i][1];\\n            ans= (ans+ func(arr , i+1, target-arr[i][1]*j, dp))%N;\\n            j++;\\n        }\\n        return dp[i][target]=ans%N;\\n    }\\n\\n\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n=types.size();\\n        vector<vector<int>>dp(n , vector<int>(target+1 , -1));\\n        return func(types , 0 , target , dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417766,
                "title": "number-of-ways-to-earn-points-c-explained-solution",
                "content": "***Do Upvote If Found Helpful !!!*** \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe problem here is quite simple and very much like the basic knapsack problem. The only change is that you have the option of choosing some of the questions of each type. Thus the basic structure of the problem is very similar to knapsack. The rest implementation of the problem is given below : \\n\\n# Complexity\\n- Time complexity: **O(Target * N * max(count[i]))**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(Target * N)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int ways(int target,vector<vector<int>>& types,int i,vector<vector<int>>& dp){\\n        if(i == -1 || target < 0){\\n            if(target == 0){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        else if(dp[target][i] != -1){\\n            return dp[target][i];\\n        }\\n        else{\\n            int ans = 0;\\n            for(int j = 0; j <= types[i][0]; j++){\\n                ans += ways(target-j*types[i][1],types,i-1,dp);\\n                ans %= mod;\\n            }\\n            return dp[target][i] = ans;\\n        }\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        ios_base::sync_with_stdio(0);\\n        int n = types.size();\\n        vector<vector<int>>dp(target+1,vector<int>(n,-1));\\n        return ways(target,types,n-1,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int ways(int target,vector<vector<int>>& types,int i,vector<vector<int>>& dp){\\n        if(i == -1 || target < 0){\\n            if(target == 0){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        else if(dp[target][i] != -1){\\n            return dp[target][i];\\n        }\\n        else{\\n            int ans = 0;\\n            for(int j = 0; j <= types[i][0]; j++){\\n                ans += ways(target-j*types[i][1],types,i-1,dp);\\n                ans %= mod;\\n            }\\n            return dp[target][i] = ans;\\n        }\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        ios_base::sync_with_stdio(0);\\n        int n = types.size();\\n        vector<vector<int>>dp(target+1,vector<int>(n,-1));\\n        return ways(target,types,n-1,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3416080,
                "title": "c-dp",
                "content": "```\\npublic class Solution {\\n    int MOD=1_000_000_007;\\n    public int WaysToReachTarget(int target, int[][] types) {\\n        int[] dp=new int[target+1];\\n        dp[0]=1;\\n        int n=types.Length;\\n        \\n        for(int i=0;i<n;i++){\\n            int[] dp2=new int[target+1];\\n            for(int j=0;j<=target;j++){\\n                for(int c=0;c<=types[i][0];c++){\\n                    if((j+c*types[i][1])<=target)\\n                        dp2[j+c*types[i][1]]=(dp2[j+c*types[i][1]]+dp[j])%MOD;\\n                }\\n                \\n            }\\n            dp=dp2;\\n            \\n            \\n        }\\n            \\n        return dp[target];\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution {\\n    int MOD=1_000_000_007;\\n    public int WaysToReachTarget(int target, int[][] types) {\\n        int[] dp=new int[target+1];\\n        dp[0]=1;\\n        int n=types.Length;\\n        \\n        for(int i=0;i<n;i++){\\n            int[] dp2=new int[target+1];\\n            for(int j=0;j<=target;j++){\\n                for(int c=0;c<=types[i][0];c++){\\n                    if((j+c*types[i][1])<=target)\\n                        dp2[j+c*types[i][1]]=(dp2[j+c*types[i][1]]+dp[j])%MOD;\\n                }\\n                \\n            }\\n            dp=dp2;\\n            \\n            \\n        }\\n            \\n        return dp[target];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3413834,
                "title": "solution-based-on-generating-functions-python3",
                "content": "# Intuition/approach\\nWe\\'re given a list `types` where `type[i] = [count_i, marks_i]` tells us the number of times a question with marks_i arises. Let\\'s call such an entry a *factor*. If we had a single factor, the answer would be simple. A student can get `k * marks_i` points, for `k = 0, 1, ..., count_i`. If `target` is of that form, we return 1, otherwise we return 0.\\n\\nWe can formalize this using the language of generating functions. Let \\n$$P_i(x) = 1 + x^{m_i} + \\\\ldots + x^{m_i c_i} = \\\\sum_{k=0}^{c_i} x^{k \\\\cdot m_i}$$\\nwhere $c_i = $`count_i` and $m_i = $`marks_i`. Then the answer is the coefficient in front of the monomial $x^\\\\text{target}$. Since we never need to deal with polynomials of degree higher than `target`, let\\'s encode the above polynomial as a `List[int]` of length `target+1`. So the above polynomial is encoded by an array `P_i` as follows:\\n\\n```\\nupper_i = min(counts_i * marks_i, target)\\nP_i = list(range(0, upper_i + 1, marks_i))\\n```\\n\\nIn general, there are several factors that contribute. Recall that if we have two polynomials $P = \\\\sum p_k x^k$ and $Q = \\\\sum_j q_j x^j$, and if we only care about monomials up to $x^\\\\text{N}$, then the product $R = P \\\\cdot Q$ is encoded as follows:\\n\\n```\\nR = [0]*(N+1)\\nfor n in range(N+1):\\n    R[n] = sum(p[k]*q[n-k] for k in range(n+1)])\\n```\\n\\nSince the polynomials we deal with are very simple, we don\\'t need completely general code above; instead, we can optimize our code a little bit. This is not crucial.\\n\\nAt the end of the day, we multiply all our polynomials `P_i` together, and we take the coefficient in front of $x^\\\\text{target}$, which is simply the last coefficient in our `list` (since we never kept higher coefficients to begin with).\\n\\n# Complexity\\n- Time complexity:\\nEvery time we multiply two polynomials, we do at most $O(\\\\text{target}^2)$ operations (addition and multiplication). If there are $F$ factors, the total complexity is $O(F \\\\cdot \\\\text{target}^2)$. \\n\\n- Space complexity:\\nWe allocate $O(\\\\text{target})$ integers.\\n\\n# Code\\n```\\nclass Solution:\\n    MAX = 10**9 + 7\\n    \\n    def mult_ar(self, ar: List[int], tt: List[int]) -> List[int]:\\n        \\'\\'\\'\\n        This function takes an array that encodes a polynomial,\\n        and multiplies it by a second polynomial specified by a type\\n        of the form tt = [count, marks].\\n        \\'\\'\\'\\n        out = [0]*(self.N+1)\\n        c, m = tt\\n        for n in range(self.N+1):\\n            upper = min(c*m, n)\\n            out[n] = sum([ar[n-j] for j in range(0, upper+1, m)]) % self.MAX\\n        return out\\n    \\n    def waysToReachTarget(self, target: int, types: list[list[int]]) -> int:\\n        self.N = target\\n        # restrict types to types that can actually contribute; whenever applicable,\\n        # reduce count to the highest possible value, i.e.\\n        #   count <- targets//marks\\n        # after that, filter out all types that don\\'t contribue \\n        for i in range(len(types)):\\n            c, m = types[i]\\n            if c*m > target: types[i][0] = target//m\\n        types = [tt for tt in types if tt[1] > 0] \\n        \\n        # now, multiply all factors into a generating function,\\n        # and read off the leading coefficient\\n        ar = [1] + self.N*[0]\\n        for tt in types:\\n            ar = self.mult_ar(ar, tt)\\n        return ar[-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nupper_i = min(counts_i * marks_i, target)\\nP_i = list(range(0, upper_i + 1, marks_i))\\n```\n```\\nR = [0]*(N+1)\\nfor n in range(N+1):\\n    R[n] = sum(p[k]*q[n-k] for k in range(n+1)])\\n```\n```\\nclass Solution:\\n    MAX = 10**9 + 7\\n    \\n    def mult_ar(self, ar: List[int], tt: List[int]) -> List[int]:\\n        \\'\\'\\'\\n        This function takes an array that encodes a polynomial,\\n        and multiplies it by a second polynomial specified by a type\\n        of the form tt = [count, marks].\\n        \\'\\'\\'\\n        out = [0]*(self.N+1)\\n        c, m = tt\\n        for n in range(self.N+1):\\n            upper = min(c*m, n)\\n            out[n] = sum([ar[n-j] for j in range(0, upper+1, m)]) % self.MAX\\n        return out\\n    \\n    def waysToReachTarget(self, target: int, types: list[list[int]]) -> int:\\n        self.N = target\\n        # restrict types to types that can actually contribute; whenever applicable,\\n        # reduce count to the highest possible value, i.e.\\n        #   count <- targets//marks\\n        # after that, filter out all types that don\\'t contribue \\n        for i in range(len(types)):\\n            c, m = types[i]\\n            if c*m > target: types[i][0] = target//m\\n        types = [tt for tt in types if tt[1] > 0] \\n        \\n        # now, multiply all factors into a generating function,\\n        # and read off the leading coefficient\\n        ar = [1] + self.N*[0]\\n        for tt in types:\\n            ar = self.mult_ar(ar, tt)\\n        return ar[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3390959,
                "title": "python-dp-solution-faster-than-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust like the classical coin problem, we can implement dynamic programming to solve this problem. Be careful for the mark limit when iterating. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nm = target\\nn = len(types)\\nO(m * m * n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m)\\n# Code\\n```\\nclass Solution:\\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\\n        dp = [1] + [0] * target\\n        mod = 10 ** 9 + 7\\n        s = 0\\n        for cnt,mark in types:\\n            temp = [0] * (target + 1)\\n            s += cnt * mark\\n            up_limit = min(target, s)\\n            for score in range(up_limit + 1):\\n                val = 0\\n                down_limit = max(0, score - cnt * mark)\\n                for k in range(score, down_limit - 1, -mark):\\n                    val += dp[k]\\n                temp[score] = val % mod\\n            dp = temp\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\\n        dp = [1] + [0] * target\\n        mod = 10 ** 9 + 7\\n        s = 0\\n        for cnt,mark in types:\\n            temp = [0] * (target + 1)\\n            s += cnt * mark\\n            up_limit = min(target, s)\\n            for score in range(up_limit + 1):\\n                val = 0\\n                down_limit = max(0, score - cnt * mark)\\n                for k in range(score, down_limit - 1, -mark):\\n                    val += dp[k]\\n                temp[score] = val % mod\\n            dp = temp\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378449,
                "title": "dynamic-programming-dp-python3-solution",
                "content": "# Intuition and Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasic approach is to take every possible value from each type and check for the solutions whose sum are target but this would not be efficient so we will use dp for memoization to avoid the repetation of cases.\\n- First intialize an dp dictionary.\\n- Create a function for handling the recursion/backtracking.\\n- store the results in dp and avoid the repetation of cases.\\n- return the result.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\\n        dp = {}\\n        return (self.backtrack(target, types, 0, 0, dp))\\n\\n    def backtrack(self, target, types, i, sm, dp):\\n        if((i, sm) in dp):\\n            return dp[(i, sm)]\\n        if(sm>target):\\n            return 0\\n        if(sm==target):\\n            return 1\\n        if(i==len(types)):\\n            return 0\\n        \\n        ans = 0\\n        for j in range(types[i][0]+1):\\n            ans = (ans + self.backtrack(target, types, i+1, sm + j*types[i][1], dp))%1000000007\\n        dp[(i, sm)] = ans\\n        return dp[(i, sm)]\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\\n        dp = {}\\n        return (self.backtrack(target, types, 0, 0, dp))\\n\\n    def backtrack(self, target, types, i, sm, dp):\\n        if((i, sm) in dp):\\n            return dp[(i, sm)]\\n        if(sm>target):\\n            return 0\\n        if(sm==target):\\n            return 1\\n        if(i==len(types)):\\n            return 0\\n        \\n        ans = 0\\n        for j in range(types[i][0]+1):\\n            ans = (ans + self.backtrack(target, types, i+1, sm + j*types[i][1], dp))%1000000007\\n        dp[(i, sm)] = ans\\n        return dp[(i, sm)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359777,
                "title": "c-top-down-approach",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n*target*max_type).\\n    where n is number of types,target is target sum given in question and max_type is maximum quantity of any type.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    Additional 3D matrix i.e, dp[1001][51][51] is used to store previous results.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const int mod=1e9+7;\\n    int helper(int i,int j,vector<vector<int>>& types,int target,vector<vector<vector<int>>> &dp){\\n        if(target<0 || i==types.size() || j>types[i][0]){\\n            return 0;\\n        }\\n        if(target==0){\\n            return 1;\\n        }\\n        if(dp[target][i][j]!=-1){\\n            return dp[target][i][j];\\n        }\\n        int ways=0;\\n        ways+=helper(i,j+1,types,target-types[i][1],dp)%mod;\\n        ways+=helper(i+1,0,types,target,dp)%mod;\\n        return dp[target][i][j]=ways%mod;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        vector<vector<vector<int>>> dp(1001,vector<vector<int>>(51,vector<int>(51,-1)));\\n        return helper(0,0,types,target,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod=1e9+7;\\n    int helper(int i,int j,vector<vector<int>>& types,int target,vector<vector<vector<int>>> &dp){\\n        if(target<0 || i==types.size() || j>types[i][0]){\\n            return 0;\\n        }\\n        if(target==0){\\n            return 1;\\n        }\\n        if(dp[target][i][j]!=-1){\\n            return dp[target][i][j];\\n        }\\n        int ways=0;\\n        ways+=helper(i,j+1,types,target-types[i][1],dp)%mod;\\n        ways+=helper(i+1,0,types,target,dp)%mod;\\n        return dp[target][i][j]=ways%mod;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        vector<vector<vector<int>>> dp(1001,vector<vector<int>>(51,vector<int>(51,-1)));\\n        return helper(0,0,types,target,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341785,
                "title": "c-dp",
                "content": "```\\n#define MAX_TARGET (1000)\\n\\ntypedef struct Type{\\n\\tint count;\\n\\tint mark;\\n} Type;\\n\\nint waysToReachTarget(\\n\\tconst int target,\\n\\tconst Type * const * const pTypeArr,\\n\\tconst int pTypeArrLen,\\n\\tconst void * const _unused\\n){\\n\\t(void)_unused;\\n\\n\\tassert(target <= MAX_TARGET);\\n\\n\\tint dp[2][MAX_TARGET + 1];\\n\\n\\tmemset( &dp[1], 0, sizeof (dp[1]) );\\n\\tdp[1][0] = 1;\\n\\n\\tfor (int i = 0; i < pTypeArrLen; i += 1){\\n\\t\\tmemcpy( &dp[0], &dp[1], sizeof (dp[1]) );\\n\\t\\tmemset( &dp[1], 0, sizeof (dp[1]) );\\n\\n\\t\\tfor (int j = 0; j < sizeof (dp[0]) / sizeof (dp[0][0]); j += 1){\\n\\t\\t\\tif (dp[0][j] > 0){\\n\\t\\t\\t\\tfor (int k = 0; k <= pTypeArr[i]->count; k += 1){\\n\\t\\t\\t\\t\\tconst int newPoint = j + pTypeArr[i]->mark * k;\\n\\n\\t\\t\\t\\t\\tif (!( newPoint <= MAX_TARGET )){\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tdp[1][newPoint] += dp[0][j];\\n\\t\\t\\t\\t\\tdp[1][newPoint] %= 1000000007;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[1][target];\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define MAX_TARGET (1000)\\n\\ntypedef struct Type{\\n\\tint count;\\n\\tint mark;\\n} Type;\\n\\nint waysToReachTarget(\\n\\tconst int target,\\n\\tconst Type * const * const pTypeArr,\\n\\tconst int pTypeArrLen,\\n\\tconst void * const _unused\\n){\\n\\t(void)_unused;\\n\\n\\tassert(target <= MAX_TARGET);\\n\\n\\tint dp[2][MAX_TARGET + 1];\\n\\n\\tmemset( &dp[1], 0, sizeof (dp[1]) );\\n\\tdp[1][0] = 1;\\n\\n\\tfor (int i = 0; i < pTypeArrLen; i += 1){\\n\\t\\tmemcpy( &dp[0], &dp[1], sizeof (dp[1]) );\\n\\t\\tmemset( &dp[1], 0, sizeof (dp[1]) );\\n\\n\\t\\tfor (int j = 0; j < sizeof (dp[0]) / sizeof (dp[0][0]); j += 1){\\n\\t\\t\\tif (dp[0][j] > 0){\\n\\t\\t\\t\\tfor (int k = 0; k <= pTypeArr[i]->count; k += 1){\\n\\t\\t\\t\\t\\tconst int newPoint = j + pTypeArr[i]->mark * k;\\n\\n\\t\\t\\t\\t\\tif (!( newPoint <= MAX_TARGET )){\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tdp[1][newPoint] += dp[0][j];\\n\\t\\t\\t\\t\\tdp[1][newPoint] %= 1000000007;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[1][target];\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3331691,
                "title": "top-down-dp-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const long long mod = 1e9 + 7 ;\\n    vector<vector<long long>>dp ;\\n    long long rec(vector<vector<int>>&first , int n , int target , int idx){\\n        if(target == 0)\\n            return 1;\\n        if(target < 0)\\n            return 0 ;\\n        if(idx < 0)\\n            return 0 ;\\n        if(dp[idx][target] != -1)\\n            return dp[idx][target];\\n        long long res = 0 ;\\n        // bool a = false ;\\n        res += rec(first , n , target , idx - 1) % mod;\\n        res %= mod ;\\n        for(int i = 0 ; i < first[idx].size() ; i++){\\n            target -= first[idx][i];\\n            res += rec(first , n , target , idx - 1) % mod;\\n            res %= mod;\\n            target += first[idx][i];\\n        }\\n        return dp[idx][target] =   res % mod;\\n        \\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        vector<vector<int>>first ;\\n        int n = types.size();\\n        // dp = vector<long long>(n + 1 , -1);\\n        dp = vector<vector<long long>>(n + 1 , vector<long long>(1001 , -1));\\n        for(int i = 0 ; i < n ; i++){\\n            vector<int>curr ;\\n            int x = types[i][0] , y = types[i][1];\\n            int sum = 0 ;\\n            for(int j = 0 ; j < min(x , target/y) ; j++ ){\\n                sum += y ;\\n                curr.push_back(sum);\\n            }\\n            first.push_back(curr);\\n        }\\n        return rec(first , n , target , n - 1) % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const long long mod = 1e9 + 7 ;\\n    vector<vector<long long>>dp ;\\n    long long rec(vector<vector<int>>&first , int n , int target , int idx){\\n        if(target == 0)\\n            return 1;\\n        if(target < 0)\\n            return 0 ;\\n        if(idx < 0)\\n            return 0 ;\\n        if(dp[idx][target] != -1)\\n            return dp[idx][target];\\n        long long res = 0 ;\\n        // bool a = false ;\\n        res += rec(first , n , target , idx - 1) % mod;\\n        res %= mod ;\\n        for(int i = 0 ; i < first[idx].size() ; i++){\\n            target -= first[idx][i];\\n            res += rec(first , n , target , idx - 1) % mod;\\n            res %= mod;\\n            target += first[idx][i];\\n        }\\n        return dp[idx][target] =   res % mod;\\n        \\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        vector<vector<int>>first ;\\n        int n = types.size();\\n        // dp = vector<long long>(n + 1 , -1);\\n        dp = vector<vector<long long>>(n + 1 , vector<long long>(1001 , -1));\\n        for(int i = 0 ; i < n ; i++){\\n            vector<int>curr ;\\n            int x = types[i][0] , y = types[i][1];\\n            int sum = 0 ;\\n            for(int j = 0 ; j < min(x , target/y) ; j++ ){\\n                sum += y ;\\n                curr.push_back(sum);\\n            }\\n            first.push_back(curr);\\n        }\\n        return rec(first , n , target , n - 1) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324956,
                "title": "recursive-dp-with-memoization",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    int count = 0;\\n    public int waysToReachTarget(int target, int[][] types) {\\n        int dp[][] = new int[target+1][types.length+1];\\n        for (int i=0;i<target+1;i++) {\\n            Arrays.fill(dp[i],-1);\\n        }\\n        int ans = f(target,0,types,dp);\\n        return ans;\\n    }\\n    \\n    public int f(int target, int index,int[][] types, int [][]dp) {\\n        if (index >= types.length) \\n        return target == 0 ? 1 : 0;\\n        if (target == 0) return 1;\\n        if (target < 0) return 0;\\n        if (dp[target][index] != -1) return dp[target][index];\\n        int ans1 = 0;\\n        for (int i=0;i<=types[index][0];i++) {\\n            if (target - (i * types[index][1]) >= 0) {\\n                int answer = f(target- (i * types[index][1]), index+1,types,dp);\\n                 ans1 = (ans1 + answer) % (int)(1e9+7);\\n            } \\n        }\\n        return dp[target][index] = ans1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int count = 0;\\n    public int waysToReachTarget(int target, int[][] types) {\\n        int dp[][] = new int[target+1][types.length+1];\\n        for (int i=0;i<target+1;i++) {\\n            Arrays.fill(dp[i],-1);\\n        }\\n        int ans = f(target,0,types,dp);\\n        return ans;\\n    }\\n    \\n    public int f(int target, int index,int[][] types, int [][]dp) {\\n        if (index >= types.length) \\n        return target == 0 ? 1 : 0;\\n        if (target == 0) return 1;\\n        if (target < 0) return 0;\\n        if (dp[target][index] != -1) return dp[target][index];\\n        int ans1 = 0;\\n        for (int i=0;i<=types[index][0];i++) {\\n            if (target - (i * types[index][1]) >= 0) {\\n                int answer = f(target- (i * types[index][1]), index+1,types,dp);\\n                 ans1 = (ans1 + answer) % (int)(1e9+7);\\n            } \\n        }\\n        return dp[target][index] = ans1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3323074,
                "title": "cpp-easy",
                "content": "class Solution {\\npublic:\\n    int waysToReachTarget(int t, vector<vector<int>>& ty) \\n    {\\n           vector<vector<int>>v(ty.size()+1,vector<int>(t+1,0));\\n           int mo=1E9+7;\\n           int  Fs=0; \\n           for(int i=0;i<ty.size();++i)\\n           {\\n               Fs+=(ty[i][0]*ty[i][1]);\\n               for(int j=1;j<=t;++j)\\n               {\\n                   if(j>(Fs))\\n                           break;\\n                   if(i==0)\\n                   {\\n                           if(j%ty[i][1]==0)\\n                           {\\n                               v[i+1][j]=1;\\n                           }\\n                   }\\n                   else\\n                   {\\n                       long long s=j%ty[i][1];\\n                       long long n=j/ty[i][1];\\n                       if(n>ty[i][0])\\n                       {\\n                           s=s+(n-ty[i][0])*ty[i][1];\\n                           n=ty[i][0];\\n                       }\\n                      \\n                       long long sum=0;\\n                       if(s==0)\\n                       { \\n                           ++sum;\\n                           --n;\\n                           s+=ty[i][1];\\n                       }\\n                       while(n>=0)\\n                       {\\n                           sum=(sum+v[i][s])%mo;\\n                           s+=ty[i][1];\\n                           --n;\\n                       }\\n                       v[i+1][j]=sum;\\n                   }\\n               }\\n           }\\n        \\n        return v[ty.size()][t];\\n           \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int waysToReachTarget(int t, vector<vector<int>>& ty) \\n    {\\n           vector<vector<int>>v(ty.size()+1,vector<int>(t+1,0));\\n           int mo=1E9+7;\\n           int  Fs=0; \\n           for(int i=0;i<ty.size();++i)\\n           {\\n               Fs+=(ty[i][0]*ty[i][1]);\\n               for(int j=1;j<=t;++j)\\n               {\\n                   if(j>(Fs))\\n                           break;\\n                   if(i==0)\\n                   {\\n                           if(j%ty[i][1]==0)\\n                           {\\n                               v[i+1][j]=1;\\n                           }",
                "codeTag": "Java"
            },
            {
                "id": 3321445,
                "title": "python-top-down-and-bottom-up-dp-47-time-55-space",
                "content": "```python []\\nclass Solution:\\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\\n        n = len(types)\\n\\n        # Bottom up\\n        dp = [[0] * (n + 1) for _ in range(target + 1)]\\n        for i in range(n + 1): dp[0][i] = 1\\n\\n        for i in range(1, target + 1):\\n            for j in range(1, n + 1):\\n                c, match = types[j - 1]\\n                for count in range(c + 1):\\n                    points = count * match\\n                    if i - points >= 0:\\n                        dp[i][j] += dp[i - points][j - 1]\\n                        dp[i][j] %= (10 ** 9 + 7)\\n                    else: break\\n        return dp[target][n]\\n\\n        # Top down\\n        @cache\\n        def dp(i, total):\\n            if total == target: return 1\\n            if i == n or total > target: return 0\\n\\n            count, marks = types[i]\\n            skip = dp(i + 1, total)\\n            ways = skip\\n            for j in range(1, count + 1):\\n                ways += dp(i + 1, total + (j * marks))\\n            return ways % (10 ** 9 + 7)\\n\\n        return dp(0, 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python []\\nclass Solution:\\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\\n        n = len(types)\\n\\n        # Bottom up\\n        dp = [[0] * (n + 1) for _ in range(target + 1)]\\n        for i in range(n + 1): dp[0][i] = 1\\n\\n        for i in range(1, target + 1):\\n            for j in range(1, n + 1):\\n                c, match = types[j - 1]\\n                for count in range(c + 1):\\n                    points = count * match\\n                    if i - points >= 0:\\n                        dp[i][j] += dp[i - points][j - 1]\\n                        dp[i][j] %= (10 ** 9 + 7)\\n                    else: break\\n        return dp[target][n]\\n\\n        # Top down\\n        @cache\\n        def dp(i, total):\\n            if total == target: return 1\\n            if i == n or total > target: return 0\\n\\n            count, marks = types[i]\\n            skip = dp(i + 1, total)\\n            ways = skip\\n            for j in range(1, count + 1):\\n                ways += dp(i + 1, total + (j * marks))\\n            return ways % (10 ** 9 + 7)\\n\\n        return dp(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3319585,
                "title": "cpp-dp-memoization",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int mod=1e9+7;  \\n    int recur(int target,int i,vector<vector<int>>& types)\\n    {\\n        if(target==0)return 1;\\n        if(i==types.size())return 0;\\n        if(dp[i][target]!=-1)return dp[i][target]%mod;      \\n        \\n\\n        long long pick=0;\\n\\n        for(int ind=0;ind<=types[i][0];ind++)\\n        {\\n            if(target-ind*(types[i][1])>=0)pick+=recur(target-ind*(types[i][1]),i+1,types);\\n        }\\n        return dp[i][target]=pick%mod;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        dp.resize(types.size()+1,vector<int>(target+1,-1));\\n        return recur(target,0,types);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int mod=1e9+7;  \\n    int recur(int target,int i,vector<vector<int>>& types)\\n    {\\n        if(target==0)return 1;\\n        if(i==types.size())return 0;\\n        if(dp[i][target]!=-1)return dp[i][target]%mod;      \\n        \\n\\n        long long pick=0;\\n\\n        for(int ind=0;ind<=types[i][0];ind++)\\n        {\\n            if(target-ind*(types[i][1])>=0)pick+=recur(target-ind*(types[i][1]),i+1,types);\\n        }\\n        return dp[i][target]=pick%mod;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        dp.resize(types.size()+1,vector<int>(target+1,-1));\\n        return recur(target,0,types);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3307236,
                "title": "dynamic-programming-iterative-approach-java",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    int mod = (int)Math.pow(10,9)+7;\\n    public int waysToReachTarget(int target, int[][] types) {\\n        \\n\\n        long[][] dp = new long[types.length+1][target+1];\\n\\n        for(int i=0;i<dp.length;i++){\\n\\n            dp[i][0]=1;\\n        }\\n\\n        dp[0][0]=1;\\n\\n        for(int i=1;i<dp.length;i++){\\n\\n            for(int j=1;j<dp[0].length;j++){\\n\\n\\n                int len=types[i-1][0];\\n                int mark=types[i-1][1];\\n\\n                long ans = dp[i-1][j];\\n\\n                int k=1;\\n\\n                while(len-- >0){\\n\\n                    if(j-(mark*k)>=0){\\n                        ans=(ans%mod+dp[i-1][j-(mark*k)]%mod)%mod;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n\\n                    k++;\\n                }\\n\\n                dp[i][j]= ans;\\n            }\\n        }\\n\\n    \\n        return (int)dp[types.length][target];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int mod = (int)Math.pow(10,9)+7;\\n    public int waysToReachTarget(int target, int[][] types) {\\n        \\n\\n        long[][] dp = new long[types.length+1][target+1];\\n\\n        for(int i=0;i<dp.length;i++){\\n\\n            dp[i][0]=1;\\n        }\\n\\n        dp[0][0]=1;\\n\\n        for(int i=1;i<dp.length;i++){\\n\\n            for(int j=1;j<dp[0].length;j++){\\n\\n\\n                int len=types[i-1][0];\\n                int mark=types[i-1][1];\\n\\n                long ans = dp[i-1][j];\\n\\n                int k=1;\\n\\n                while(len-- >0){\\n\\n                    if(j-(mark*k)>=0){\\n                        ans=(ans%mod+dp[i-1][j-(mark*k)]%mod)%mod;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n\\n                    k++;\\n                }\\n\\n                dp[i][j]= ans;\\n            }\\n        }\\n\\n    \\n        return (int)dp[types.length][target];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3285332,
                "title": "c-dp-top-down-fast-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    unsigned long long mod=1e9+7;\\n    unsigned long long F[51][1001],A[1001];\\n    unsigned long long Add(unsigned long long a,unsigned long long b)\\n    {\\n        return (a+b) >= mod ? a+b-mod : a+b;\\n    }\\n    unsigned long long Sub(unsigned long long a,unsigned long long b)\\n    {\\n        return a>=b ? a-b : a-b+mod;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        for(int i=0;i<=types.size()-1;i++)\\n        {\\n            memset(A,0,sizeof(A));\\n            for(int j=1;j<=target;j++)\\n            {\\n                if(i==0)\\n                {\\n                    if(j%types[i][1]==0&&j<=types[i][0]*types[i][1])\\n                        F[i][j]=1;\\n                }\\n                else\\n                {\\n                    if(j<types[i][1])\\n                    {\\n                        A[j]=F[i-1][j];\\n                        F[i][j]=F[i-1][j];\\n                    }\\n                    else\\n                    {\\n                        if(j<=types[i][0]*types[i][1])\\n                        {\\n                            A[j]=Add(F[i-1][j],A[j-types[i][1]]);\\n                        }\\n                        else\\n                        {\\n                            A[j]=Sub(Add(F[i-1][j],A[j-types[i][1]]),F[i-1][j-types[i][0]*types[i][1]]);\\n                        }\\n                        if(j%types[i][1]==0&&j<=types[i][0]*types[i][1])\\n                            F[i][j]=1;\\n                        F[i][j]=Add(F[i][j],Add(A[j-types[i][1]],F[i-1][j]));\\n                    }\\n                }\\n            }\\n        }\\n        return F[types.size()-1][target];\\n    }\\n};\\n``",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    unsigned long long mod=1e9+7;\\n    unsigned long long F[51][1001],A[1001];\\n    unsigned long long Add(unsigned long long a,unsigned long long b)\\n    {\\n        return (a+b) >= mod ? a+b-mod : a+b;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3285076,
                "title": "classic-knapsack-problem-coin-change-memoization-top-down-dp",
                "content": "\\n\\n# Approach\\nClassic coin change problem of knapsack only the difference is the boundation on each type hence we run a loop and then check for all the counts which ever is possible and also all the combinations along with it. \\n\\n# Code\\n```\\n//Tabulation\\nclass Solution {\\n    public int waysToReachTarget(int target, int[][] types) {\\n        int mod=1000000007;\\n        int n=types.length;\\n        int dp[][]=new int[n+1][target+1];\\n        for(int i=0;i<=n;i++)\\n        dp[i][0]=1;\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=target;j++){\\n                int count=types[i-1][0];\\n                int val=types[i-1][1];\\n                int res=0;\\n                for(int ind=0;ind<=count;ind++){\\n                    int currv=val*ind;\\n                    if(currv<=j){\\n                        res=(res%mod + dp[i-1][j-currv]%mod)%mod;\\n                    }\\n                }\\n                dp[i][j]=res;\\n            }\\n        }\\n        return dp[n][target];\\n    }\\n}\\n\\n\\n/*Memoization\\nclass Solution {\\n    int mod=1000000007;\\n    public int waysToReachTarget(int target, int[][] types) {\\n        int n=types.length;\\n        int dp[][]=new int[n+1][target+1];\\n        for(int i=0;i<n;i++){\\n            Arrays.fill(dp[i],-1);\\n        }\\n        return helper(n-1,target,types,dp);\\n    }\\n    public int helper(int ind,int tar,int types[][],int dp[][]){\\n        if(tar==0)\\n            return 1;\\n        if(ind<0)\\n            return 0;\\n        if(dp[ind][tar]!=-1) return dp[ind][tar];\\n        int count=types[ind][0];\\n        int val=types[ind][1];\\n        int res=0;\\n        for(int i=0;i<=count;i++){\\n            int currv=val*i;\\n            if(currv<=tar){\\n                res=(res%mod + helper(ind-1,tar-currv,types,dp)%mod)%mod;\\n            }\\n        }\\n        return dp[ind][tar]=res;\\n    }\\n}*/\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n//Tabulation\\nclass Solution {\\n    public int waysToReachTarget(int target, int[][] types) {\\n        int mod=1000000007;\\n        int n=types.length;\\n        int dp[][]=new int[n+1][target+1];\\n        for(int i=0;i<=n;i++)\\n        dp[i][0]=1;\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=target;j++){\\n                int count=types[i-1][0];\\n                int val=types[i-1][1];\\n                int res=0;\\n                for(int ind=0;ind<=count;ind++){\\n                    int currv=val*ind;\\n                    if(currv<=j){\\n                        res=(res%mod + dp[i-1][j-currv]%mod)%mod;\\n                    }\\n                }\\n                dp[i][j]=res;\\n            }\\n        }\\n        return dp[n][target];\\n    }\\n}\\n\\n\\n/*Memoization\\nclass Solution {\\n    int mod=1000000007;\\n    public int waysToReachTarget(int target, int[][] types) {\\n        int n=types.length;\\n        int dp[][]=new int[n+1][target+1];\\n        for(int i=0;i<n;i++){\\n            Arrays.fill(dp[i],-1);\\n        }\\n        return helper(n-1,target,types,dp);\\n    }\\n    public int helper(int ind,int tar,int types[][],int dp[][]){\\n        if(tar==0)\\n            return 1;\\n        if(ind<0)\\n            return 0;\\n        if(dp[ind][tar]!=-1) return dp[ind][tar];\\n        int count=types[ind][0];\\n        int val=types[ind][1];\\n        int res=0;\\n        for(int i=0;i<=count;i++){\\n            int currv=val*i;\\n            if(currv<=tar){\\n                res=(res%mod + helper(ind-1,tar-currv,types,dp)%mod)%mod;\\n            }\\n        }\\n        return dp[ind][tar]=res;\\n    }\\n}*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282321,
                "title": "c-simple-knapsack-dp-intuitive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long \\n    ll mod = 1e9 +7;\\n    ll dp[1005][51];\\n    ll fun(ll t,ll i,vector<vector<int>>& types){\\n        if(t==0)return 1;\\n        if(t<0 || i<0) return 0;\\n        if(dp[t][i]!=-1) return dp[t][i];\\n        ll ans =0;\\n        for(int j=0;j<=types[i][0];j++)\\n       { \\n       ans+=fun(t - j*types[i][1],i-1,types);\\n       ans%=mod;\\n       }\\n       return dp[t][i]=ans; \\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        memset(dp,-1,sizeof(dp));\\n        return fun(target,types.size()-1,types);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long \\n    ll mod = 1e9 +7;\\n    ll dp[1005][51];\\n    ll fun(ll t,ll i,vector<vector<int>>& types){\\n        if(t==0)return 1;\\n        if(t<0 || i<0) return 0;\\n        if(dp[t][i]!=-1) return dp[t][i];\\n        ll ans =0;\\n        for(int j=0;j<=types[i][0];j++)\\n       { \\n       ans+=fun(t - j*types[i][1],i-1,types);\\n       ans%=mod;\\n       }\\n       return dp[t][i]=ans; \\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        memset(dp,-1,sizeof(dp));\\n        return fun(target,types.size()-1,types);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282285,
                "title": "memoization-top-down-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[51][51][1001];\\n    int mod = 1000000000+7;\\n    int help(int target,vector<vector<int>>& types,int index)\\n    {\\n        if(target == 0 ) return 1;\\n        if(index == 0) \\n        {\\n            if(target%types[0][1] == 0)\\n            {\\n                if((target)/types[0][1] <= types[0][0])\\n                {\\n                    return 1;\\n                }\\n                else\\n                {\\n                    return 0;\\n                }\\n            }\\n            else\\n            {\\n                return 0;\\n            }\\n        }\\n        if(target<0 || types[index][0] < 0) return 0;\\n        if(dp[index][types[index][0]][target] != -1) return dp[index][types[index][0]][target];\\n        \\n        int take = 0,not_take = 0;\\n        not_take = help(target,types,index-1);\\n        if(types[index][0] > 0)\\n        {\\n            types[index][0] -= 1;\\n            take += (help(target-types[index][1],types,index))%mod;\\n            take %= mod;\\n            types[index][0] += 1;\\n        }\\n        return dp[index][types[index][0]][target] = (take+not_take)%mod;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n = types.size(); \\n        memset(dp,-1,sizeof(dp));\\n        return    help(target,types,n-1);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[51][51][1001];\\n    int mod = 1000000000+7;\\n    int help(int target,vector<vector<int>>& types,int index)\\n    {\\n        if(target == 0 ) return 1;\\n        if(index == 0) \\n        {\\n            if(target%types[0][1] == 0)\\n            {\\n                if((target)/types[0][1] <= types[0][0])\\n                {\\n                    return 1;\\n                }\\n                else\\n                {\\n                    return 0;\\n                }\\n            }\\n            else\\n            {\\n                return 0;\\n            }\\n        }\\n        if(target<0 || types[index][0] < 0) return 0;\\n        if(dp[index][types[index][0]][target] != -1) return dp[index][types[index][0]][target];\\n        \\n        int take = 0,not_take = 0;\\n        not_take = help(target,types,index-1);\\n        if(types[index][0] > 0)\\n        {\\n            types[index][0] -= 1;\\n            take += (help(target-types[index][1],types,index))%mod;\\n            take %= mod;\\n            types[index][0] += 1;\\n        }\\n        return dp[index][types[index][0]][target] = (take+not_take)%mod;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n = types.size(); \\n        memset(dp,-1,sizeof(dp));\\n        return    help(target,types,n-1);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281134,
                "title": "memoization-knapsack-dp-recursion-most-understable-and-simple-solution",
                "content": "```\\n\\n#define ll long long int\\nint mod=1e9+7;\\nclass Solution {\\n    ll fun(int target,int ind,int cnt,vector<vector<int>>& types,vector<vector<vector<ll>>>&dp){\\n        \\n        if(target<0)return 0;\\n        if(ind>=types.size())return 0;\\n        if(types[ind][0]<cnt)return 0;\\n        if(target==0){return 1;}\\n        if(dp[target][ind][cnt]!=-1)return dp[target][ind][cnt];\\n        ll ans=0;\\n        \\n        if((target-types[ind][1])>=0 ){ans+=fun(target-types[ind][1],ind,cnt+1,types,dp)%mod;}\\n        ans=(ans+ fun(target,ind+1,0,types,dp)%mod+mod)%mod;\\n        \\n        return dp[target][ind][cnt]=ans;                                     \\n                                              \\n    }\\n    \\npublic:\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n         int n=types.size();\\n        vector<vector<vector<ll>>> dp(target+2,vector<vector<ll>>(n+1,vector<ll>(52,-1)));\\n          \\n        return fun(target,0,0,types,dp)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n\\n#define ll long long int\\nint mod=1e9+7;\\nclass Solution {\\n    ll fun(int target,int ind,int cnt,vector<vector<int>>& types,vector<vector<vector<ll>>>&dp){\\n        \\n        if(target<0)return 0;\\n        if(ind>=types.size())return 0;\\n        if(types[ind][0]<cnt)return 0;\\n        if(target==0){return 1;}\\n        if(dp[target][ind][cnt]!=-1)return dp[target][ind][cnt];\\n        ll ans=0;\\n        \\n        if((target-types[ind][1])>=0 ){ans+=fun(target-types[ind][1],ind,cnt+1,types,dp)%mod;}\\n        ans=(ans+ fun(target,ind+1,0,types,dp)%mod+mod)%mod;\\n        \\n        return dp[target][ind][cnt]=ans;                                     \\n                                              \\n    }\\n    \\npublic:\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n         int n=types.size();\\n        vector<vector<vector<ll>>> dp(target+2,vector<vector<ll>>(n+1,vector<ll>(52,-1)));\\n          \\n        return fun(target,0,0,types,dp)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276699,
                "title": "javascript-easy-solution-dp-memoization",
                "content": "# Intuition\\nThe problem statement is to find the number of ways to reach a given target by choosing from a set of items, where each item has a weight and a count. The goal is to use the items in such a way that the sum of their weights adds up to the target. We are required to find the number of ways we can do so.\\n\\n# Approach\\nThe approach used in the given code is a recursive approach with memoization. The main idea is to try every possible combination of the items to reach the target and count the number of ways to do so. We start with the target value and subtract the weight of each item until we reach zero or a negative value. If we reach zero, we have found a valid combination, and if we reach a negative value, we know that the combination we are trying is not valid.\\n\\n# Complexity\\n- Time complexity:\\n\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\n/**\\n * @param {number} target\\n * @param {number[][]} types\\n * @return {number}\\n */\\nfunction waysToReachTarget(target, types) {\\n  const memo = Array.from({ length: target + 1 }, () =>\\n    Array.from({ length: types.length + 1 }, () => -1),\\n  );\\n  return backtrack(target, types, 0, memo);\\n}\\n\\nfunction backtrack(target, types, start, memo) {\\n  if (target == 0) {\\n    return 1;\\n  }\\n  if (target < 0) {\\n    return 0;\\n  }\\n  if (memo[target][start] != -1) {\\n    return memo[target][start];\\n  }\\n  let res = 0;\\n  for (let i = start; i < types.length; i++) {\\n    for (let j = 1; j <= types[i][0]; j++) {\\n      if (target - j * types[i][1] < 0) {\\n        break;\\n      }\\n      const temp = backtrack(target - j * types[i][1], types, i + 1, memo);\\n      res = (res + temp) % 1_000_000_007;\\n    }\\n  }\\n  memo[target][start] = res;\\n  return res;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n/**\\n * @param {number} target\\n * @param {number[][]} types\\n * @return {number}\\n */\\nfunction waysToReachTarget(target, types) {\\n  const memo = Array.from({ length: target + 1 }, () =>\\n    Array.from({ length: types.length + 1 }, () => -1),\\n  );\\n  return backtrack(target, types, 0, memo);\\n}\\n\\nfunction backtrack(target, types, start, memo) {\\n  if (target == 0) {\\n    return 1;\\n  }\\n  if (target < 0) {\\n    return 0;\\n  }\\n  if (memo[target][start] != -1) {\\n    return memo[target][start];\\n  }\\n  let res = 0;\\n  for (let i = start; i < types.length; i++) {\\n    for (let j = 1; j <= types[i][0]; j++) {\\n      if (target - j * types[i][1] < 0) {\\n        break;\\n      }\\n      const temp = backtrack(target - j * types[i][1], types, i + 1, memo);\\n      res = (res + temp) % 1_000_000_007;\\n    }\\n  }\\n  memo[target][start] = res;\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3275877,
                "title": "3d-dp-recusion-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> It is simmilar to the Coin Change 2 problem which is very standard with a slight variation. In this question there is only a finite supply of each coins.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust try to limit the supply by applying constraints.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    int MOD=(int)(1e9+7);\\n    public int waysToReachTarget(int target, int[][] types) {\\n        \\n        int dp[][][]=new int[types.length+1][target+1][51];\\n        for(int i=0;i<types.length+1;i++){\\n            for(int j=0;j<target+1;j++){\\n                for(int k=0;k<51;k++)\\n                   dp[i][j][k]=-1;\\n            }\\n        }\\n        return f(0,types.length,target,types[0][0],types,dp);\\n\\n    }\\n    public int f(int i,int n,int target, int count,int types[][],int dp[][][]) {\\n      //base cases\\n      if (target == 0) {\\n        return 1;\\n      }\\n      if (target < 0 || i == n) {\\n        return 0;\\n      }\\n      //typical memoization technique\\n      if (dp[i][target][count] != -1) {\\n        return dp[i][target][count];\\n      }\\n      //if we are picking the element just see if it is avaible to take by looking at the count. If it is just decrease the count and recurse.\\n      int pick = 0;\\n      if (types[i][1]<=target && count - 1 >= 0) {\\n        pick = f(i,n,target-types[i][1],count-1,types,dp);\\n      }\\n      \\n      // If we dont want to pick the element just increase the index within the limit.\\n      int notPick = 0;\\n      if (i + 1 < n) {\\n        notPick = f(i+1,n,target,types[i + 1][0],types,dp);\\n      }\\n      //total number of ways.\\n      return dp[i][target][count] = (pick + notPick) % MOD;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int MOD=(int)(1e9+7);\\n    public int waysToReachTarget(int target, int[][] types) {\\n        \\n        int dp[][][]=new int[types.length+1][target+1][51];\\n        for(int i=0;i<types.length+1;i++){\\n            for(int j=0;j<target+1;j++){\\n                for(int k=0;k<51;k++)\\n                   dp[i][j][k]=-1;\\n            }\\n        }\\n        return f(0,types.length,target,types[0][0],types,dp);\\n\\n    }\\n    public int f(int i,int n,int target, int count,int types[][],int dp[][][]) {\\n      //base cases\\n      if (target == 0) {\\n        return 1;\\n      }\\n      if (target < 0 || i == n) {\\n        return 0;\\n      }\\n      //typical memoization technique\\n      if (dp[i][target][count] != -1) {\\n        return dp[i][target][count];\\n      }\\n      //if we are picking the element just see if it is avaible to take by looking at the count. If it is just decrease the count and recurse.\\n      int pick = 0;\\n      if (types[i][1]<=target && count - 1 >= 0) {\\n        pick = f(i,n,target-types[i][1],count-1,types,dp);\\n      }\\n      \\n      // If we dont want to pick the element just increase the index within the limit.\\n      int notPick = 0;\\n      if (i + 1 < n) {\\n        notPick = f(i+1,n,target,types[i + 1][0],types,dp);\\n      }\\n      //total number of ways.\\n      return dp[i][target][count] = (pick + notPick) % MOD;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271857,
                "title": "c-golang-dp-sc-o-target",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        const int mod = 1e9 + 7;\\n        vector<vector<int>> DP(2, vector<int>(target + 1, 0));\\n        DP[0][0] = DP[1][0] = 1;\\n        for(int i = 0; i < types.size(); i++) {\\n            for(int j = 1; j <= target; j++) {\\n                DP[(i + 1) % 2][j] = DP[i % 2][j]; \\n                for(int k = 1; k <= types[i][0] && j >= k * types[i][1]; k++) {\\n                    DP[(i + 1) % 2][j] = (DP[(i + 1) % 2][j] + DP[i % 2][j - k * types[i][1]]) % mod;\\n                }\\n            }\\n        }\\n        return DP[types.size() % 2][target];\\n    }\\n};\\n\\n\\n// Golang\\nfunc waysToReachTarget(target int, types [][]int) int {\\n    const mod int = 1e9 + 7\\n    DP := make([][]int, 2)\\n    DP[0] = make([]int, target + 1)\\n    DP[1] = make([]int, target + 1)\\n    DP[0][0], DP[1][0] = 1, 1\\n    for i := 0; i < len(types); i++ {\\n        for j := 1; j <= target; j++ {\\n            DP[(i + 1) % 2][j] = DP[i % 2][j] \\n            for k := 1; k <= types[i][0] && j >= k * types[i][1]; k++ {\\n                DP[(i + 1) % 2][j] = (DP[(i + 1) % 2][j] + DP[i % 2][j - k * types[i][1]]) % mod\\n            }\\n        }\\n    }\\n    return DP[len(types) % 2][target]\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        const int mod = 1e9 + 7;\\n        vector<vector<int>> DP(2, vector<int>(target + 1, 0));\\n        DP[0][0] = DP[1][0] = 1;\\n        for(int i = 0; i < types.size(); i++) {\\n            for(int j = 1; j <= target; j++) {\\n                DP[(i + 1) % 2][j] = DP[i % 2][j]; \\n                for(int k = 1; k <= types[i][0] && j >= k * types[i][1]; k++) {\\n                    DP[(i + 1) % 2][j] = (DP[(i + 1) % 2][j] + DP[i % 2][j - k * types[i][1]]) % mod;\\n                }\\n            }\\n        }\\n        return DP[types.size() % 2][target];\\n    }\\n};\\n\\n\\n// Golang\\nfunc waysToReachTarget(target int, types [][]int) int {\\n    const mod int = 1e9 + 7\\n    DP := make([][]int, 2)\\n    DP[0] = make([]int, target + 1)\\n    DP[1] = make([]int, target + 1)\\n    DP[0][0], DP[1][0] = 1, 1\\n    for i := 0; i < len(types); i++ {\\n        for j := 1; j <= target; j++ {\\n            DP[(i + 1) % 2][j] = DP[i % 2][j] \\n            for k := 1; k <= types[i][0] && j >= k * types[i][1]; k++ {\\n                DP[(i + 1) % 2][j] = (DP[(i + 1) % 2][j] + DP[i % 2][j - k * types[i][1]]) % mod\\n            }\\n        }\\n    }\\n    return DP[len(types) % 2][target]\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271697,
                "title": "python3-dp-o-n-target-2",
                "content": "# Code\\n```\\nclass Solution:\\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\\n        MOD, n = 10 ** 9 + 7, len(types)\\n        dp = [[0] * (target + 1) for _ in range(2)]\\n        dp[0][0] = dp[1][0] = 1\\n        for i in range(n):\\n            count, mark = types[i]\\n            dp[i & 1] = [0] * (target + 1)\\n            for j in range(target + 1):\\n                for k in range(count + 1):\\n                    if j + k * mark > target: break\\n                    dp[i & 1][j + k * mark] = (dp[i & 1][j + k * mark] + dp[(i + 1) & 1][j]) % MOD\\n        return dp[(n - 1) & 1][target]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\\n        MOD, n = 10 ** 9 + 7, len(types)\\n        dp = [[0] * (target + 1) for _ in range(2)]\\n        dp[0][0] = dp[1][0] = 1\\n        for i in range(n):\\n            count, mark = types[i]\\n            dp[i & 1] = [0] * (target + 1)\\n            for j in range(target + 1):\\n                for k in range(count + 1):\\n                    if j + k * mark > target: break\\n                    dp[i & 1][j + k * mark] = (dp[i & 1][j + k * mark] + dp[(i + 1) & 1][j]) % MOD\\n        return dp[(n - 1) & 1][target]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271553,
                "title": "dynamic-programming-solutions-python",
                "content": "1- Two Solution Formats\\n```\\n\"\"\"\\nTreatment: DP\\n\\n\\nFormat-1 1-D DP\\n\\ndp[val] := n_ways to get val from types where 0 <= val <= target\\nThe dp table is of size target + 1.\\nDP update rule: we explain this in coding.\\n\\nFormat-2 2-D DP\\n\\ndp[val][j] = n_ways to earn val points using questions starting from j and forward.\\n\\nThe recurrence relationship is dp[val][j] = sum(dp[val-x*m][j+1] for x = 0, 1, 2, ..., c and i-x*m >= 0) \\nwhere c, m = types[j]\\n\\nwe return dp[val[0]\\n\\nExtension: can you write the dp solution with recursion + memoization/cache?\\n\\n\\n\"\"\"\\nclass Solution:\\n    def waysToReachTarget_v1(self, target: int, types: List[List[int]]) -> int:\\n        \"\"\"\\n        1D DP\\n        \"\"\"\\n        mod = 10 ** 9 + 7 # int(1e9 + 7)\\n        dp = [0] * (target + 1)\\n        dp[0] = 1\\n        \\n        for count, mark in types:\\n            for val in range(target, -1, -1):\\n                for j in range(1, count + 1):\\n                    if val - j * mark >= 0:\\n                        dp[val] += dp[val - j * mark]\\n                        dp[val] %= mod\\n                    else:\\n                        break\\n        return dp[target] # dp[-1]\\n    \\n    \\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\\n        \"\"\"\\n        2D DP\\n        \"\"\"\\n        mod = 10 ** 9 + 7 # int(1e9 + 7)\\n        n = len(types)\\n        dp = [[0] * (1 + n) for _ in range(target + 1)]\\n        \\n        for j in range(n+1):\\n            dp[0][j] = 1\\n            \\n        for val in range(1, target + 1):\\n            for j in range(n-1, -1, -1):\\n                c, m = types[j]\\n                for x in range(c + 1):\\n                    if val - x * m >= 0:\\n                        dp[val][j] += dp[val - x * m][j+1]\\n                    else:\\n                        break\\n                dp[val][j] %= mod\\n        \\n        return dp[target][0]\\n        \\n```\\n2- Video Explanation: [Click Here](https://youtu.be/mkbwbQEt3FE;)\\n\\nFollow up channel for more analysis of problems.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\"\"\"\\nTreatment: DP\\n\\n\\nFormat-1 1-D DP\\n\\ndp[val] := n_ways to get val from types where 0 <= val <= target\\nThe dp table is of size target + 1.\\nDP update rule: we explain this in coding.\\n\\nFormat-2 2-D DP\\n\\ndp[val][j] = n_ways to earn val points using questions starting from j and forward.\\n\\nThe recurrence relationship is dp[val][j] = sum(dp[val-x*m][j+1] for x = 0, 1, 2, ..., c and i-x*m >= 0) \\nwhere c, m = types[j]\\n\\nwe return dp[val[0]\\n\\nExtension: can you write the dp solution with recursion + memoization/cache?\\n\\n\\n\"\"\"\\nclass Solution:\\n    def waysToReachTarget_v1(self, target: int, types: List[List[int]]) -> int:\\n        \"\"\"\\n        1D DP\\n        \"\"\"\\n        mod = 10 ** 9 + 7 # int(1e9 + 7)\\n        dp = [0] * (target + 1)\\n        dp[0] = 1\\n        \\n        for count, mark in types:\\n            for val in range(target, -1, -1):\\n                for j in range(1, count + 1):\\n                    if val - j * mark >= 0:\\n                        dp[val] += dp[val - j * mark]\\n                        dp[val] %= mod\\n                    else:\\n                        break\\n        return dp[target] # dp[-1]\\n    \\n    \\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\\n        \"\"\"\\n        2D DP\\n        \"\"\"\\n        mod = 10 ** 9 + 7 # int(1e9 + 7)\\n        n = len(types)\\n        dp = [[0] * (1 + n) for _ in range(target + 1)]\\n        \\n        for j in range(n+1):\\n            dp[0][j] = 1\\n            \\n        for val in range(1, target + 1):\\n            for j in range(n-1, -1, -1):\\n                c, m = types[j]\\n                for x in range(c + 1):\\n                    if val - x * m >= 0:\\n                        dp[val][j] += dp[val - x * m][j+1]\\n                    else:\\n                        break\\n                dp[val][j] %= mod\\n        \\n        return dp[target][0]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270636,
                "title": "golang-dp",
                "content": "```\\nvar mem [1001][51][51]int\\nfunc waysToReachTarget(target int, types [][]int) int {\\n    for i := 0; i <= target; i++ {\\n        for j := 0; j <= len(types); j++ {\\n            for k := range mem[i][j] {\\n                mem[i][j][k] = -1\\n            }\\n        }\\n    }\\n    var dp func(int, int, int) int\\n    dp = func(ost int,i int,ci int) int {\\n        if i>=len(types) {\\n            if ost == 0 {\\n                return 1\\n            }\\n            return 0\\n        }\\n        if mem[ost][i][ci] != -1 {\\n            return mem[ost][i][ci]\\n        }\\n        a := 0\\n        if i+1<len(types) {\\n            a = dp(ost,i+1,types[i+1][0])\\n        } else {\\n            a = dp(ost,i+1,0)\\n        }\\n        \\n        if types[i][1] <= ost && ci>0 {\\n            a += dp(ost-types[i][1],i,ci-1)\\n        }\\n        mem[ost][i][ci] = a\\n        return a%1000000007\\n    }\\n    \\n    return dp(target,0,types[0][0])\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar mem [1001][51][51]int\\nfunc waysToReachTarget(target int, types [][]int) int {\\n    for i := 0; i <= target; i++ {\\n        for j := 0; j <= len(types); j++ {\\n            for k := range mem[i][j] {\\n                mem[i][j][k] = -1\\n            }\\n        }\\n    }\\n    var dp func(int, int, int) int\\n    dp = func(ost int,i int,ci int) int {\\n        if i>=len(types) {\\n            if ost == 0 {\\n                return 1\\n            }\\n            return 0\\n        }\\n        if mem[ost][i][ci] != -1 {\\n            return mem[ost][i][ci]\\n        }\\n        a := 0\\n        if i+1<len(types) {\\n            a = dp(ost,i+1,types[i+1][0])\\n        } else {\\n            a = dp(ost,i+1,0)\\n        }\\n        \\n        if types[i][1] <= ost && ci>0 {\\n            a += dp(ost-types[i][1],i,ci-1)\\n        }\\n        mem[ost][i][ci] = a\\n        return a%1000000007\\n    }\\n    \\n    return dp(target,0,types[0][0])\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3269070,
                "title": "scala-bottom-up-dp",
                "content": "# Code\\n```\\nobject Solution {\\n  def waysToReachTarget(target: Int, types: Array[Array[Int]]): Int = {\\n    val dp = Array.fill(types.length + 1)(new Array[Long](target + 1))\\n    dp(0)(target) = 1\\n    types.indices.foreach { i =>\\n      val Array(cnt, mark) = types(i)\\n      0.to(target).foreach { j =>\\n        val inds = 0.to(cnt).map(c => j + c * mark).takeWhile(_ <= target).map(dp(i)(_))\\n        dp(i + 1)(j) = inds.foldLeft(0L)((acc, ind) => (acc + ind) % 1000000007)\\n      }\\n    }\\n    dp.last.head.toInt\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def waysToReachTarget(target: Int, types: Array[Array[Int]]): Int = {\\n    val dp = Array.fill(types.length + 1)(new Array[Long](target + 1))\\n    dp(0)(target) = 1\\n    types.indices.foreach { i =>\\n      val Array(cnt, mark) = types(i)\\n      0.to(target).foreach { j =>\\n        val inds = 0.to(cnt).map(c => j + c * mark).takeWhile(_ <= target).map(dp(i)(_))\\n        dp(i + 1)(j) = inds.foldLeft(0L)((acc, ind) => (acc + ind) % 1000000007)\\n      }\\n    }\\n    dp.last.head.toInt\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3268981,
                "title": "c-easy-dp-solution",
                "content": "# Code\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    ll mod=1e9+7;\\n    int waysToReachTarget(int target, vector<vector<int>>& types) \\n    {\\n        int n=types.size();\\n        ll f[n][target+1];\\n        for(int i=0;i<n;i++)for(int j=0;j<=target;j++)f[i][j]=0;\\n        for(int i=0;i<=types[0][0];i++)\\n            if(i*types[0][1]<=target)f[0][i*types[0][1]]=1;\\n        for(int i=1;i<n;i++)\\n            for(int j=0;j<=types[i][0];j++)\\n                for(int k=0;k<=target;k++)\\n                {\\n                    if(k+types[i][1]*j<=target)f[i][k+types[i][1]*j]=(f[i][k+types[i][1]*j]+f[i-1][k])%mod;\\n                    else break;\\n                }\\n        return f[n-1][target];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    ll mod=1e9+7;\\n    int waysToReachTarget(int target, vector<vector<int>>& types) \\n    {\\n        int n=types.size();\\n        ll f[n][target+1];\\n        for(int i=0;i<n;i++)for(int j=0;j<=target;j++)f[i][j]=0;\\n        for(int i=0;i<=types[0][0];i++)\\n            if(i*types[0][1]<=target)f[0][i*types[0][1]]=1;\\n        for(int i=1;i<n;i++)\\n            for(int j=0;j<=types[i][0];j++)\\n                for(int k=0;k<=target;k++)\\n                {\\n                    if(k+types[i][1]*j<=target)f[i][k+types[i][1]*j]=(f[i][k+types[i][1]*j]+f[i-1][k])%mod;\\n                    else break;\\n                }\\n        return f[n-1][target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268380,
                "title": "knapsack-top-down-dp-solution-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nYou can also imagine this question as coin change problem but with the constraint that you can use types[i][1] coin only types[i][0] times at max. \\nAfter that you can use knapsack logic.\\n\\n# Complexity\\n- Time complexity: O(n * k * count)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(target)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToReachTarget(int k, vector<vector<int>>& types) {\\n        // you can also imagine this question as coin change problem but with the constraint \\n        // that you can use types[i][1] coin only types[i][0] times at max\\n\\n        int m = 1e9 + 7;\\n        vector<int> dp(k+1);\\n        dp[0] = 1; // knapsack initialisation\\n        for(auto x : types)\\n        // we should go tar to 0 loop as we cannot score marks in same question 2 times\\n        // bcz if we go from 0 to tar we will be using the questions repeatedly\\n        // try to imagine this by doing hand iterations\\n        for(int i = k; i > 0 ; i--)\\n        for(int j = x[1]; j <= x[0]*x[1] && (i - j) >= 0; j += x[1])\\n            dp[i] = (dp[i] + dp[i-j]) % m;\\n        return dp[k];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToReachTarget(int k, vector<vector<int>>& types) {\\n        // you can also imagine this question as coin change problem but with the constraint \\n        // that you can use types[i][1] coin only types[i][0] times at max\\n\\n        int m = 1e9 + 7;\\n        vector<int> dp(k+1);\\n        dp[0] = 1; // knapsack initialisation\\n        for(auto x : types)\\n        // we should go tar to 0 loop as we cannot score marks in same question 2 times\\n        // bcz if we go from 0 to tar we will be using the questions repeatedly\\n        // try to imagine this by doing hand iterations\\n        for(int i = k; i > 0 ; i--)\\n        for(int j = x[1]; j <= x[0]*x[1] && (i - j) >= 0; j += x[1])\\n            dp[i] = (dp[i] + dp[i-j]) % m;\\n        return dp[k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268089,
                "title": "simple-dp-tabulation-approach-10-lines-faster-than-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem seems to be very much similar to standard 0-1 knapsack problem. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSuggested to first go through the knapsack problem then proceed as I have directly mentioned the tabulation approach and the dp states.\\n\\nFor every question, we can take any value from 1 to types[x][1] as the value of number of questions.\\n\\nNow, for every y questions taken, we have found a new way of scoring y * score i.e sum = y * types[x][1].\\n\\nSo, for every score i from 0 to target, the number of ways of scoring it is increased by dp[i-sum] i.e the current score (i) minus the score of y number of questions (sum).\\n\\nDoing this for every question, we get the desired result.\\n\\n\\n\\n# Complexity\\n- Time complexity:  O(n * target * count)\\n\\n- Space complexity: O( target )\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int mod=1e9+7,dp[target+1];\\n        memset(dp,0,sizeof(dp));\\n        dp[0]=1;\\n        \\n        for(int x=types.size()-1;x>=0;x--){\\n            for(int i=target;i>=0;i--){\\n                for(int y=1,sum=types[x][1];y<=types[x][0] && i>=sum;y++,sum+=types[x][1]){\\n                    dp[i]=(dp[i] + dp[i-sum])%mod;\\n                }\\n            }\\n        }\\n\\n        return dp[target];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int mod=1e9+7,dp[target+1];\\n        memset(dp,0,sizeof(dp));\\n        dp[0]=1;\\n        \\n        for(int x=types.size()-1;x>=0;x--){\\n            for(int i=target;i>=0;i--){\\n                for(int y=1,sum=types[x][1];y<=types[x][0] && i>=sum;y++,sum+=types[x][1]){\\n                    dp[i]=(dp[i] + dp[i-sum])%mod;\\n                }\\n            }\\n        }\\n\\n        return dp[target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267921,
                "title": "c-2d-dp-simple",
                "content": "# Code\\n```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n=types.size();\\n        vector<vector<int>> dp(n+1,vector<int>(target+1,0));\\n        dp[0][0]=1;\\n        for(int i=1;i<=n;i++) for(int k=0;k<=target;k++){\\n            int marks=types[i-1][1];\\n            \\n            dp[i][k]+=dp[i-1][k];\\n            for(int j=1;j<=types[i-1][0];j++){\\n                if(k-j*marks>=0) dp[i][k]+=dp[i-1][k-j*marks];\\n                dp[i][k]%=mod;\\n            }\\n        }\\n        \\n        return dp[n][target];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n=types.size();\\n        vector<vector<int>> dp(n+1,vector<int>(target+1,0));\\n        dp[0][0]=1;\\n        for(int i=1;i<=n;i++) for(int k=0;k<=target;k++){\\n            int marks=types[i-1][1];\\n            \\n            dp[i][k]+=dp[i-1][k];\\n            for(int j=1;j<=types[i-1][0];j++){\\n                if(k-j*marks>=0) dp[i][k]+=dp[i-1][k-j*marks];\\n                dp[i][k]%=mod;\\n            }\\n        }\\n        \\n        return dp[n][target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267884,
                "title": "c-3d-dp-simple-approach-recursion-memoization",
                "content": "For this question, a good approach can be of using a 3-D DP as there are three changing parameters as the question suggests.\\nSo, First we will write the recurrence relation for the problem and then start using the pick and not-pick logic.\\nIf we will choose to pick then target gets decreased by the value of types[i][1]. But if we dont use it, we just move to the next index\\nAnswer will be the summation of both methods\\n\\nFor Recursion,\\nTC: O(2^n) which will give us Time Limit Exceeded.\\nTo handle this we will be using Memoization->which will reduce the time complexity\\n\\nIn this we will create a DP array with 3 changing parameters and will check for overlapping subproblems.\\nIf it is already solved, we can just return the answer.\\n\\nBase Case->\\n1) If we have reached to end of the array.\\n2) If Our count increases the limit\\n3) If target becomes negative\\n\\nTC:O(N^3)\\nSC:O(N^3)+ (Auxilary Stack Space -> Due to Recursion)\\n\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int func(vector<vector<int>>& types,int tar,int i,int cnt,vector<vector<vector<int>>>&dp){\\n        int n=types.size();\\n        //whether cnt has exceeded the count.\\n        if(i==n||tar<0||cnt>types[i][0]){\\n            return 0;\\n        }\\n        //means we have got a way\\n        if(tar==0){\\n            return 1;\\n        }\\n        //overlapping subproblems\\n        if(dp[tar][i][cnt]!=-1){\\n            return dp[tar][i][cnt];\\n        }\\n        //cases of pick,not pick\\n        //if picked->cnt+1; \\n        int pick=func(types,tar-types[i][1],i,cnt+1,dp);\\n        //if not picked move to next index\\n        int dontpick=func(types,tar,i+1,0,dp);\\n        //add both values to get total ways\\n        return dp[tar][i][cnt]= (pick%mod+dontpick%mod)%mod;\\n        \\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n=types.size();\\n        //created the dp array acc to constraints given\\n        vector<vector<vector<int>>>dp(1001,vector<vector<int>>(51,vector<int>(51,-1)));\\n        return func(types,target,0,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int func(vector<vector<int>>& types,int tar,int i,int cnt,vector<vector<vector<int>>>&dp){\\n        int n=types.size();\\n        //whether cnt has exceeded the count.\\n        if(i==n||tar<0||cnt>types[i][0]){\\n            return 0;\\n        }\\n        //means we have got a way\\n        if(tar==0){\\n            return 1;\\n        }\\n        //overlapping subproblems\\n        if(dp[tar][i][cnt]!=-1){\\n            return dp[tar][i][cnt];\\n        }\\n        //cases of pick,not pick\\n        //if picked->cnt+1; \\n        int pick=func(types,tar-types[i][1],i,cnt+1,dp);\\n        //if not picked move to next index\\n        int dontpick=func(types,tar,i+1,0,dp);\\n        //add both values to get total ways\\n        return dp[tar][i][cnt]= (pick%mod+dontpick%mod)%mod;\\n        \\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n=types.size();\\n        //created the dp array acc to constraints given\\n        vector<vector<vector<int>>>dp(1001,vector<vector<int>>(51,vector<int>(51,-1)));\\n        return func(types,target,0,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266780,
                "title": "python-recursive-top-down-dp-solution",
                "content": "```\\nclass Solution:\\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\\n        rows, cols = target + 1, len(types)\\n        cache = [[None for j in range(cols)] for i in range(rows)]\\n        return self.dfs(target, types, cache, 0)\\n        \\n    \\n    def dfs(self, target: int, types: List[List[int]], cache: List[List[int]], index: int) -> int:\\n        \\n        if target < 0:\\n            return 0\\n        \\n        if index == len(types):\\n            return 1 if target == 0 else 0\\n    \\n        #print(str(target) + \" \" + str(index))\\n        if target == 0:\\n            return 1\\n        \\n        if cache[target][index] is not None:\\n            return cache[target][index]\\n        \\n        count = 0\\n        \\n        for i in range(1, types[index][0] + 1):\\n            count = (count + self.dfs(target - i * types[index][1], types, cache, index + 1)) % 1000000007\\n            \\n        count = (count + self.dfs(target, types, cache, index + 1)) % 1000000007\\n        \\n        cache[target][index] = count\\n        return count\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\\n        rows, cols = target + 1, len(types)\\n        cache = [[None for j in range(cols)] for i in range(rows)]\\n        return self.dfs(target, types, cache, 0)\\n        \\n    \\n    def dfs(self, target: int, types: List[List[int]], cache: List[List[int]], index: int) -> int:\\n        \\n        if target < 0:\\n            return 0\\n        \\n        if index == len(types):\\n            return 1 if target == 0 else 0\\n    \\n        #print(str(target) + \" \" + str(index))\\n        if target == 0:\\n            return 1\\n        \\n        if cache[target][index] is not None:\\n            return cache[target][index]\\n        \\n        count = 0\\n        \\n        for i in range(1, types[index][0] + 1):\\n            count = (count + self.dfs(target - i * types[index][1], types, cache, index + 1)) % 1000000007\\n            \\n        count = (count + self.dfs(target, types, cache, index + 1)) % 1000000007\\n        \\n        cache[target][index] = count\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266399,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master) This is a knapsack problem, ie. we `include` *inclusive-or* `exclude` each i<sup>th</sup> item of the input array `A`.  Each i<sup>th</sup> item has a count `cnt` of points we can `take`, so we consider each multiple `x` from `1..cnt` inclusive and increment the number of ways when total `t` equals target `T`.  The number of ways is then accumulated and returned as the recursive stack unwinds.\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n\\n---\\n\\n**Kotlin Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\n    fun waysToReachTarget(T: Int, A: Array<IntArray>): Int {\\n        var N = A.size\\n        fun go(i: Int = 0, t: Int = 0): Int {\\n            if (t == T) return 1\\n            if (i == N) return 0\\n            var (include, exclude) = Pair(0, go(i + 1, t))\\n            var (cnt, take) = A[i]\\n            for (x in 1..cnt)\\n                if (t + take * x <= T)\\n                    include += go(i + 1, t + take * x)\\n            return include + exclude\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\n    fun waysToReachTarget(T: Int, A: Array<IntArray>, MOD: Int = (1e9 + 7).toInt()): Int {\\n        var N = A.size\\n        var m = mutableMapOf<String, Int>()\\n        fun go(i: Int = 0, t: Int = 0): Int {\\n            if (t == T) return 1\\n            if (i == N) return 0\\n            var k = \"$i,$t\"\\n            if (!m.contains(k)) {\\n                var (include, exclude) = Pair(0, go(i + 1, t))\\n                var (cnt, take) = A[i]\\n                for (x in 1..cnt)\\n                    if (t + take * x <= T)\\n                        include = (include + go(i + 1, t + take * x)) % MOD\\n                m[k] = (include + exclude) % MOD\\n            }\\n            return m[k]!!\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\n    fun waysToReachTarget(T: Int, A: Array<IntArray>, MOD: Int = (1e9 + 7).toInt()): Int {\\n        var N = A.size\\n        var dp = Array(N + 1){ IntArray(T + 1) { 0 } }\\n        for (i in 0..N)\\n            dp[i][T] = 1\\n        for (i in N - 1 downTo 0) {\\n            for (t in T - 1 downTo 0) {\\n                var (include, exclude) = Pair(0, dp[i + 1][t])\\n                var (cnt, take) = A[i]\\n                for (x in 1..cnt)\\n                    if (t + take * x <= T)\\n                        include = (include + dp[i + 1][t + take * x]) % MOD\\n                dp[i][t] = (include + exclude) % MOD\\n            }\\n        }\\n        return dp[0][0]\\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nlet waysToReachTarget = (T, A) => {\\n    let N = A.length;\\n    let go = (i = 0, t = 0) => {\\n        if (t == T) return 1;\\n        if (i == N) return 0;\\n        let [include, exclude] = [0, go(i + 1, t)];\\n        let [cnt, take] = A[i];\\n        for (let x = 1; x <= cnt; ++x)\\n            if (t + take * x <= T)\\n                include += go(i + 1, t + take * x);\\n        return include + exclude;\\n    };\\n    return go();\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nlet waysToReachTarget = (T, A, m = new Map(), MOD = Number(1e9 + 7)) => {\\n    let N = A.length;\\n    let go = (i = 0, t = 0) => {\\n        if (t == T) return 1;\\n        if (i == N) return 0;\\n        let k = `${i},${t}`;\\n        if (!m.has(k)) {\\n            let [include, exclude] = [0, go(i + 1, t)];\\n            let [cnt, take] = A[i];\\n            for (let x = 1; x <= cnt; ++x)\\n                if (t + take * x <= T)\\n                    include = (include + go(i + 1, t + take * x)) % MOD;\\n            m.set(k, (include + exclude) % MOD);\\n        }\\n        return m.get(k);\\n    };\\n    return go();\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nlet waysToReachTarget = (T, A, m = new Map(), MOD = Number(1e9 + 7)) => {\\n    let N = A.length;\\n    let dp = [...Array(N + 1)].map(_ => Array(T + 1).fill(0));\\n    for (let i = 0; i <= N; ++i)\\n        dp[i][T] = 1;\\n    for (let i = N - 1; 0 <= i; --i) {\\n        for (let t = T - 1; 0 <= t; --t) {\\n            let [include, exclude] = [0, dp[i + 1][t]];\\n            let [cnt, take] = A[i];\\n            for (let x = 1; x <= cnt; ++x)\\n                if (t + take * x <= T)\\n                    include = (include + dp[i + 1][t + take * x]) % MOD;\\n            dp[i][t] = (include + exclude) % MOD;\\n        }\\n    }\\n    return dp[0][0];\\n};\\n```\\n\\n---\\n\\n**Python3 Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution:\\n    def waysToReachTarget(self, T: int, A: List[List[int]]) -> int:\\n        N = len(A)\\n        def go(i = 0, t = 0):\\n            if t == T: return 1\\n            if i == N: return 0\\n            include, exclude = 0, go(i + 1, t)\\n            cnt, take = A[i]\\n            for x in range(1, cnt + 1):\\n                if t + take * x <= T:\\n                    include += go(i + 1, t + take * x)\\n            return include + exclude\\n        return go()\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution:\\n    def waysToReachTarget(self, T: int, A: List[List[int]], MOD = int(1e9 + 7)) -> int:\\n        N = len(A)\\n        @cache\\n        def go(i = 0, t = 0):\\n            if t == T: return 1\\n            if i == N: return 0\\n            include, exclude = 0, go(i + 1, t)\\n            cnt, take = A[i]\\n            for x in range(1, cnt + 1):\\n                if t + take * x <= T:\\n                    include = (include + go(i + 1, t + take * x)) % MOD\\n            return (include + exclude) % MOD\\n        return go()\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution:\\n    def waysToReachTarget(self, T: int, A: List[List[int]], MOD = int(1e9 + 7)) -> int:\\n        N = len(A)\\n        dp = [[0] * (T + 1) for _ in range(N + 1)]\\n        for i in range(N + 1):\\n            dp[i][T] = 1\\n        for i in reversed(range(N)):\\n            for t in reversed(range(T)):\\n                include, exclude = 0, dp[i + 1][t]\\n                cnt, take = A[i]\\n                for x in range(1, cnt + 1):\\n                    if t + take * x <= T:\\n                        include = (include + dp[i + 1][t + take * x]) % MOD\\n                dp[i][t] = (include + exclude) % MOD\\n        return dp[0][0]\\n```\\n\\n---\\n\\n**Rust Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```rust\\n// TODO: how to write recursive closure with access to outer scope?\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nimpl Solution {\\n    pub fn ways_to_reach_target(T: i32, A: Vec<Vec<i32>>) -> i32 {\\n        let MOD = 1e9 as i32 + 7;\\n        let T = T as usize;\\n        let N = A.len();\\n        let mut dp = vec![vec![0; T + 1]; N + 1]; for i in 0..=N { dp[i][T] = 1; }\\n        for i in (0..N).rev() {\\n            for t in (0..T).rev() {\\n                let (mut include, exclude) = (0, dp[i + 1][t]);\\n                let (cnt, take) = (A[i][0] as usize, A[i][1] as usize);\\n                for x in 1..=cnt {\\n                    if (t + take * x) as usize <= T {\\n                        include = (include + dp[i + 1][(t + take * x) as usize]) % MOD;\\n                    }\\n                }\\n                dp[i][t] = (include + exclude) % MOD;\\n            }\\n        }\\n        dp[0][0]\\n    }\\n}\\n```\\n\\n---\\n\\n**C++ Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using fun = function<int(int, int)>;\\n    int waysToReachTarget(int T, VVI& A) {\\n        auto N = A.size();\\n        fun go = [&](auto i, auto t) {\\n            if (t == T) return 1;\\n            if (i == N) return 0;\\n            auto [include, exclude] = make_pair(0, go(i + 1, t));\\n            auto [cnt, take] = make_pair(A[i][0], A[i][1]);\\n            for (auto x{ 1 }; x <= cnt; ++x)\\n                if (t + take * x <= T)\\n                    include += go(i + 1, t + take * x);\\n            return include + exclude;\\n        };\\n        return go(0, 0);\\n    }\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int waysToReachTarget(int T, VVI& A, Map m = {}, int MOD = 1e9 + 7) {\\n        auto N = A.size();\\n        auto key = [](auto i, auto t) {\\n            stringstream ss; ss << i << \",\" << t;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto t) {\\n            if (t == T) return 1;\\n            if (i == N) return 0;\\n            auto k = key(i, t);\\n            if (m.find(k) != m.end())\\n                return m[k];\\n            auto [include, exclude] = make_pair(0, go(i + 1, t));\\n            auto [cnt, take] = make_pair(A[i][0], A[i][1]);\\n            for (auto x{ 1 }; x <= cnt; ++x)\\n                if (t + take * x <= T)\\n                    include = (include + go(i + 1, t + take * x)) % MOD;\\n            return m[k] = (include + exclude) % MOD;\\n        };\\n        return go(0, 0);\\n    }\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int waysToReachTarget(int T, VVI& A, int MOD = 1e9 + 7) {\\n        int N = A.size();\\n        VVI dp(N + 1, VI(T + 1));\\n        for (auto i{ 0 }; i <= N; ++i)\\n            dp[i][T] = 1;\\n        for (auto i{ N - 1 }; 0 <= i; --i) {\\n            for (auto t{ T - 1 }; 0 <= t; --t) {\\n                auto [include, exclude] = make_pair(0, dp[i + 1][t]);\\n                auto [cnt, take] = make_pair(A[i][0], A[i][1]);\\n                for (auto x{ 1 }; x <= cnt; ++x)\\n                    if (t + take * x <= T)\\n                        include = (include + dp[i + 1][t + take * x]) % MOD;\\n                dp[i][t] = (include + exclude) % MOD;\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun waysToReachTarget(T: Int, A: Array<IntArray>): Int {\\n        var N = A.size\\n        fun go(i: Int = 0, t: Int = 0): Int {\\n            if (t == T) return 1\\n            if (i == N) return 0\\n            var (include, exclude) = Pair(0, go(i + 1, t))\\n            var (cnt, take) = A[i]\\n            for (x in 1..cnt)\\n                if (t + take * x <= T)\\n                    include += go(i + 1, t + take * x)\\n            return include + exclude\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun waysToReachTarget(T: Int, A: Array<IntArray>, MOD: Int = (1e9 + 7).toInt()): Int {\\n        var N = A.size\\n        var m = mutableMapOf<String, Int>()\\n        fun go(i: Int = 0, t: Int = 0): Int {\\n            if (t == T) return 1\\n            if (i == N) return 0\\n            var k = \"$i,$t\"\\n            if (!m.contains(k)) {\\n                var (include, exclude) = Pair(0, go(i + 1, t))\\n                var (cnt, take) = A[i]\\n                for (x in 1..cnt)\\n                    if (t + take * x <= T)\\n                        include = (include + go(i + 1, t + take * x)) % MOD\\n                m[k] = (include + exclude) % MOD\\n            }\\n            return m[k]!!\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun waysToReachTarget(T: Int, A: Array<IntArray>, MOD: Int = (1e9 + 7).toInt()): Int {\\n        var N = A.size\\n        var dp = Array(N + 1){ IntArray(T + 1) { 0 } }\\n        for (i in 0..N)\\n            dp[i][T] = 1\\n        for (i in N - 1 downTo 0) {\\n            for (t in T - 1 downTo 0) {\\n                var (include, exclude) = Pair(0, dp[i + 1][t])\\n                var (cnt, take) = A[i]\\n                for (x in 1..cnt)\\n                    if (t + take * x <= T)\\n                        include = (include + dp[i + 1][t + take * x]) % MOD\\n                dp[i][t] = (include + exclude) % MOD\\n            }\\n        }\\n        return dp[0][0]\\n    }\\n}\\n```\n```\\nlet waysToReachTarget = (T, A) => {\\n    let N = A.length;\\n    let go = (i = 0, t = 0) => {\\n        if (t == T) return 1;\\n        if (i == N) return 0;\\n        let [include, exclude] = [0, go(i + 1, t)];\\n        let [cnt, take] = A[i];\\n        for (let x = 1; x <= cnt; ++x)\\n            if (t + take * x <= T)\\n                include += go(i + 1, t + take * x);\\n        return include + exclude;\\n    };\\n    return go();\\n};\\n```\n```\\nlet waysToReachTarget = (T, A, m = new Map(), MOD = Number(1e9 + 7)) => {\\n    let N = A.length;\\n    let go = (i = 0, t = 0) => {\\n        if (t == T) return 1;\\n        if (i == N) return 0;\\n        let k = `${i},${t}`;\\n        if (!m.has(k)) {\\n            let [include, exclude] = [0, go(i + 1, t)];\\n            let [cnt, take] = A[i];\\n            for (let x = 1; x <= cnt; ++x)\\n                if (t + take * x <= T)\\n                    include = (include + go(i + 1, t + take * x)) % MOD;\\n            m.set(k, (include + exclude) % MOD);\\n        }\\n        return m.get(k);\\n    };\\n    return go();\\n};\\n```\n```\\nlet waysToReachTarget = (T, A, m = new Map(), MOD = Number(1e9 + 7)) => {\\n    let N = A.length;\\n    let dp = [...Array(N + 1)].map(_ => Array(T + 1).fill(0));\\n    for (let i = 0; i <= N; ++i)\\n        dp[i][T] = 1;\\n    for (let i = N - 1; 0 <= i; --i) {\\n        for (let t = T - 1; 0 <= t; --t) {\\n            let [include, exclude] = [0, dp[i + 1][t]];\\n            let [cnt, take] = A[i];\\n            for (let x = 1; x <= cnt; ++x)\\n                if (t + take * x <= T)\\n                    include = (include + dp[i + 1][t + take * x]) % MOD;\\n            dp[i][t] = (include + exclude) % MOD;\\n        }\\n    }\\n    return dp[0][0];\\n};\\n```\n```\\nclass Solution:\\n    def waysToReachTarget(self, T: int, A: List[List[int]]) -> int:\\n        N = len(A)\\n        def go(i = 0, t = 0):\\n            if t == T: return 1\\n            if i == N: return 0\\n            include, exclude = 0, go(i + 1, t)\\n            cnt, take = A[i]\\n            for x in range(1, cnt + 1):\\n                if t + take * x <= T:\\n                    include += go(i + 1, t + take * x)\\n            return include + exclude\\n        return go()\\n```\n```\\nclass Solution:\\n    def waysToReachTarget(self, T: int, A: List[List[int]], MOD = int(1e9 + 7)) -> int:\\n        N = len(A)\\n        @cache\\n        def go(i = 0, t = 0):\\n            if t == T: return 1\\n            if i == N: return 0\\n            include, exclude = 0, go(i + 1, t)\\n            cnt, take = A[i]\\n            for x in range(1, cnt + 1):\\n                if t + take * x <= T:\\n                    include = (include + go(i + 1, t + take * x)) % MOD\\n            return (include + exclude) % MOD\\n        return go()\\n```\n```\\nclass Solution:\\n    def waysToReachTarget(self, T: int, A: List[List[int]], MOD = int(1e9 + 7)) -> int:\\n        N = len(A)\\n        dp = [[0] * (T + 1) for _ in range(N + 1)]\\n        for i in range(N + 1):\\n            dp[i][T] = 1\\n        for i in reversed(range(N)):\\n            for t in reversed(range(T)):\\n                include, exclude = 0, dp[i + 1][t]\\n                cnt, take = A[i]\\n                for x in range(1, cnt + 1):\\n                    if t + take * x <= T:\\n                        include = (include + dp[i + 1][t + take * x]) % MOD\\n                dp[i][t] = (include + exclude) % MOD\\n        return dp[0][0]\\n```\n```rust\\n// TODO: how to write recursive closure with access to outer scope?\\n```\n```\\nimpl Solution {\\n    pub fn ways_to_reach_target(T: i32, A: Vec<Vec<i32>>) -> i32 {\\n        let MOD = 1e9 as i32 + 7;\\n        let T = T as usize;\\n        let N = A.len();\\n        let mut dp = vec![vec![0; T + 1]; N + 1]; for i in 0..=N { dp[i][T] = 1; }\\n        for i in (0..N).rev() {\\n            for t in (0..T).rev() {\\n                let (mut include, exclude) = (0, dp[i + 1][t]);\\n                let (cnt, take) = (A[i][0] as usize, A[i][1] as usize);\\n                for x in 1..=cnt {\\n                    if (t + take * x) as usize <= T {\\n                        include = (include + dp[i + 1][(t + take * x) as usize]) % MOD;\\n                    }\\n                }\\n                dp[i][t] = (include + exclude) % MOD;\\n            }\\n        }\\n        dp[0][0]\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using fun = function<int(int, int)>;\\n    int waysToReachTarget(int T, VVI& A) {\\n        auto N = A.size();\\n        fun go = [&](auto i, auto t) {\\n            if (t == T) return 1;\\n            if (i == N) return 0;\\n            auto [include, exclude] = make_pair(0, go(i + 1, t));\\n            auto [cnt, take] = make_pair(A[i][0], A[i][1]);\\n            for (auto x{ 1 }; x <= cnt; ++x)\\n                if (t + take * x <= T)\\n                    include += go(i + 1, t + take * x);\\n            return include + exclude;\\n        };\\n        return go(0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int waysToReachTarget(int T, VVI& A, Map m = {}, int MOD = 1e9 + 7) {\\n        auto N = A.size();\\n        auto key = [](auto i, auto t) {\\n            stringstream ss; ss << i << \",\" << t;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto t) {\\n            if (t == T) return 1;\\n            if (i == N) return 0;\\n            auto k = key(i, t);\\n            if (m.find(k) != m.end())\\n                return m[k];\\n            auto [include, exclude] = make_pair(0, go(i + 1, t));\\n            auto [cnt, take] = make_pair(A[i][0], A[i][1]);\\n            for (auto x{ 1 }; x <= cnt; ++x)\\n                if (t + take * x <= T)\\n                    include = (include + go(i + 1, t + take * x)) % MOD;\\n            return m[k] = (include + exclude) % MOD;\\n        };\\n        return go(0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int waysToReachTarget(int T, VVI& A, int MOD = 1e9 + 7) {\\n        int N = A.size();\\n        VVI dp(N + 1, VI(T + 1));\\n        for (auto i{ 0 }; i <= N; ++i)\\n            dp[i][T] = 1;\\n        for (auto i{ N - 1 }; 0 <= i; --i) {\\n            for (auto t{ T - 1 }; 0 <= t; --t) {\\n                auto [include, exclude] = make_pair(0, dp[i + 1][t]);\\n                auto [cnt, take] = make_pair(A[i][0], A[i][1]);\\n                for (auto x{ 1 }; x <= cnt; ++x)\\n                    if (t + take * x <= T)\\n                        include = (include + dp[i + 1][t + take * x]) % MOD;\\n                dp[i][t] = (include + exclude) % MOD;\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266394,
                "title": "dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe know that we need to use dynamic programming, because we need to go through some array and each time, we make a choice of how we are going to use the current item (how many times to use this type).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n* We are caching the results based on 2 variables: 1) target remaining 2) pointer to the array index\\n* If the result is 0 (we can\\'t make it). we store the solution as -1 to distinguish from the default int number.\\n*  Be careful to store the intermediate solution as a long type.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(t * n), where t is target, and n is the length of the types array.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(t * n)\\n# Code\\n```\\nclass Solution {\\n    int[][] cache;\\n    int[][] types;\\n    public int waysToReachTarget(int target, int[][] types) {\\n        cache = new int[target + 1][types.length + 1];\\n        this.types = types;\\n        return dp(target, 0);\\n    }\\n    \\n    private int dp(int target, int typeIndex) {\\n        if (typeIndex >= types.length) {\\n            return 0;\\n        }\\n        if (cache[target][typeIndex] > 0L) {\\n            return cache[target][typeIndex];\\n        } else if (cache[target][typeIndex] < 0) {\\n            return 0;\\n        } \\n        long result = 0L + dp(target, typeIndex + 1);\\n        int typeUsed = 1;\\n        int typeScore = typeUsed * types[typeIndex][1];\\n        while (typeUsed <= types[typeIndex][0] && typeScore <= target) {\\n            if (target == typeScore) {\\n                result++;\\n                break;\\n            }\\n            result += dp(target - typeScore, typeIndex + 1);\\n            typeUsed++;\\n            typeScore = typeUsed * types[typeIndex][1];\\n        }\\n        int intResult = (int) (result % ((long) Math.pow(10, 9) + 7));\\n        cache[target][typeIndex] = intResult == 0 ? -1 : intResult;\\n        return intResult;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[][] cache;\\n    int[][] types;\\n    public int waysToReachTarget(int target, int[][] types) {\\n        cache = new int[target + 1][types.length + 1];\\n        this.types = types;\\n        return dp(target, 0);\\n    }\\n    \\n    private int dp(int target, int typeIndex) {\\n        if (typeIndex >= types.length) {\\n            return 0;\\n        }\\n        if (cache[target][typeIndex] > 0L) {\\n            return cache[target][typeIndex];\\n        } else if (cache[target][typeIndex] < 0) {\\n            return 0;\\n        } \\n        long result = 0L + dp(target, typeIndex + 1);\\n        int typeUsed = 1;\\n        int typeScore = typeUsed * types[typeIndex][1];\\n        while (typeUsed <= types[typeIndex][0] && typeScore <= target) {\\n            if (target == typeScore) {\\n                result++;\\n                break;\\n            }\\n            result += dp(target - typeScore, typeIndex + 1);\\n            typeUsed++;\\n            typeScore = typeUsed * types[typeIndex][1];\\n        }\\n        int intResult = (int) (result % ((long) Math.pow(10, 9) + 7));\\n        cache[target][typeIndex] = intResult == 0 ? -1 : intResult;\\n        return intResult;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266108,
                "title": "coin-change-problem-with-limits",
                "content": "\\n# Complexity\\n\\n## Time Complexity\\n\\nO(N * T * M), M denotes amotized count of each type\\n\\n# Code\\n\\n\\n## Top-down Dynamic Programming with Memoization\\n\\nWe can use memoization to overcome the overlapping sub-problems. We will be using a two-dimensional array to store the results of solved sub-problems. As mentioned above, we need to store results for every combination and for every possible target\\n\\n```\\nclass Solution {\\npublic:\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        static int MOD = 1e9+7;\\n        int n = types.size();\\n        \\n        vector<vector<int>> memo(target + 1, vector<int>(n, -1));\\n        function<int(int, int)> solve = [&](int points, int idx) {            \\n            if (points == 0) {\\n                return 1;\\n            }\\n            \\n            if (points < 0 || idx >= n) {\\n                return 0;\\n            }\\n            \\n            if (memo[points][idx] != -1) {\\n                return memo[points][idx];\\n            }\\n            \\n            // now, we can continue to choose current type, we can choose at most types[idx][0]\\n            int sum1 = 0;\\n            for (int cnt = 1; cnt <= types[idx][0] && types[idx][1] * cnt <= points; cnt++) {\\n                sum1 = (sum1 + solve(points - cnt * types[idx][1], idx + 1)) % MOD;\\n            }\\n            \\n            // or continue to use next type\\n            int sum2 = solve(points, idx + 1);\\n            \\n            return memo[points][idx] = (sum1 + sum2) % MOD;\\n        };\\n        \\n        return solve(target, 0);\\n    }\\n};\\n\\n```\\n\\n\\n\\n<!-- ## Bottom-up Dynamic Programming\\n\\nNow, look at the bottom-up dynamic programming approach to solving this problem. To make up total points using n types, we just need to iteratively count the ways in which we can eiher make the points using the nth type or without using it. -->\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        static int MOD = 1e9+7;\\n        int n = types.size();\\n        \\n        vector<vector<int>> memo(target + 1, vector<int>(n, -1));\\n        function<int(int, int)> solve = [&](int points, int idx) {            \\n            if (points == 0) {\\n                return 1;\\n            }\\n            \\n            if (points < 0 || idx >= n) {\\n                return 0;\\n            }\\n            \\n            if (memo[points][idx] != -1) {\\n                return memo[points][idx];\\n            }\\n            \\n            // now, we can continue to choose current type, we can choose at most types[idx][0]\\n            int sum1 = 0;\\n            for (int cnt = 1; cnt <= types[idx][0] && types[idx][1] * cnt <= points; cnt++) {\\n                sum1 = (sum1 + solve(points - cnt * types[idx][1], idx + 1)) % MOD;\\n            }\\n            \\n            // or continue to use next type\\n            int sum2 = solve(points, idx + 1);\\n            \\n            return memo[points][idx] = (sum1 + sum2) % MOD;\\n        };\\n        \\n        return solve(target, 0);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265855,
                "title": "simple-recursion-and-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int f(vector<vector<int>>&types,int i,int target,int sum,vector<vector<int>>&dp){\\n        if(sum>target)return 0;\\n         if(i==types.size())return sum==target;\\n        if(i>types.size())return 0;\\n        \\n        if(sum==target)return 1;\\n        if(dp[i][sum]!=-1)return dp[i][sum];\\n        \\n\\n        int take=0;\\n        int nottake=0;\\n        for(int k=1;k<=types[i][0];k++){\\n            take=(take+f(types,i+1,target,sum+k*types[i][1],dp))%mod;\\n        }\\n        nottake=(nottake+f(types,i+1,target,sum,dp))%mod;\\n        \\n        return dp[i][sum]=(take+nottake)%mod;\\n    } \\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n=types.size();\\n        vector<vector<int>>dp(n,vector<int>(target+100,-1));\\n        return f(types,0,target,0,dp);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int f(vector<vector<int>>&types,int i,int target,int sum,vector<vector<int>>&dp){\\n        if(sum>target)return 0;\\n         if(i==types.size())return sum==target;\\n        if(i>types.size())return 0;\\n        \\n        if(sum==target)return 1;\\n        if(dp[i][sum]!=-1)return dp[i][sum];\\n        \\n\\n        int take=0;\\n        int nottake=0;\\n        for(int k=1;k<=types[i][0];k++){\\n            take=(take+f(types,i+1,target,sum+k*types[i][1],dp))%mod;\\n        }\\n        nottake=(nottake+f(types,i+1,target,sum,dp))%mod;\\n        \\n        return dp[i][sum]=(take+nottake)%mod;\\n    } \\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n=types.size();\\n        vector<vector<int>>dp(n,vector<int>(target+100,-1));\\n        return f(types,0,target,0,dp);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265212,
                "title": "dynamic-programming-detailed-comments-explaining-how-each-step-works",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int WaysToReachTarget(int target, int[][] types) {\\n        int mod = (int)1e9 + 7;\\n        // Initialize array to keep track of the number of ways to reach each sum\\n        int[] numWays = new int[target + 1];\\n        numWays[0] = 1; // There is only one way to reach a sum of 0\\n        // Loop through each type of number\\n        foreach (int[] type in types) {\\n            int typeCount = type[0]; // Number of available numbers of the current type\\n            int typeValue = type[1]; // Value of the current type of number\\n            // Iterate over all possible sums in descending order\\n            for (int sum = target; sum > 0; --sum) {\\n                // Iterate over all possible quantities of the current type of number\\n                for (int i = 1; i <= typeCount && sum - typeValue * i >= 0; ++i) {\\n                    // Update the number of ways to reach the current sum\\n                    numWays[sum] = (numWays[sum] + numWays[sum - typeValue * i]) % mod;\\n                }\\n            }\\n        }\\n        // Return the number of ways to reach the target sum\\n        return numWays[target];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int WaysToReachTarget(int target, int[][] types) {\\n        int mod = (int)1e9 + 7;\\n        // Initialize array to keep track of the number of ways to reach each sum\\n        int[] numWays = new int[target + 1];\\n        numWays[0] = 1; // There is only one way to reach a sum of 0\\n        // Loop through each type of number\\n        foreach (int[] type in types) {\\n            int typeCount = type[0]; // Number of available numbers of the current type\\n            int typeValue = type[1]; // Value of the current type of number\\n            // Iterate over all possible sums in descending order\\n            for (int sum = target; sum > 0; --sum) {\\n                // Iterate over all possible quantities of the current type of number\\n                for (int i = 1; i <= typeCount && sum - typeValue * i >= 0; ++i) {\\n                    // Update the number of ways to reach the current sum\\n                    numWays[sum] = (numWays[sum] + numWays[sum - typeValue * i]) % mod;\\n                }\\n            }\\n        }\\n        // Return the number of ways to reach the target sum\\n        return numWays[target];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265041,
                "title": "c-dp-bottom-to-up",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        vector<int>last(target+1,0);\\n        vector<int>curr(target+1,0);\\n        int mod=1e9+7;\\n        last[0]=1;\\n        curr[0]=1;\\n        for(int i=0;i<types.size();i++)\\n        {\\n            for(int j=1;j<=types[i][0];j++)\\n            {\\n                int sum=j*types[i][1];\\n                if(sum>target)continue;\\n                for(int w=0;w<=target;w++)\\n                {\\n                    if(w+sum>target)continue;\\n                    curr[w+sum]=(curr[w+sum]+last[w])%mod; \\n                }\\n            }\\n            last=curr;\\n        }\\n        return last[target];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        vector<int>last(target+1,0);\\n        vector<int>curr(target+1,0);\\n        int mod=1e9+7;\\n        last[0]=1;\\n        curr[0]=1;\\n        for(int i=0;i<types.size();i++)\\n        {\\n            for(int j=1;j<=types[i][0];j++)\\n            {\\n                int sum=j*types[i][1];\\n                if(sum>target)continue;\\n                for(int w=0;w<=target;w++)\\n                {\\n                    if(w+sum>target)continue;\\n                    curr[w+sum]=(curr[w+sum]+last[w])%mod; \\n                }\\n            }\\n            last=curr;\\n        }\\n        return last[target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3264965,
                "title": "golang-38-ms-2-5-mb",
                "content": "# Complexity\\n- Time complexity: $$O(n^2 * target)$$\\n- Space complexity: $$O(target)$$\\n# Code\\n```\\nfunc waysToReachTarget(target int, types [][]int) int {\\n\\tdp := make([]uint32, target+1)\\n\\tdp[0] = 1\\n\\tfor _, t := range types {\\n\\t\\tfor i := target; i >= 0; i-- {\\n\\t\\t\\tfor j, c := i-t[1], t[0]; j >= 0 && c != 0; j, c = j-t[1], c-1 {\\n\\t\\t\\t\\tdp[i] = (dp[i] + dp[j]) % 1000000007\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn int(dp[target])\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc waysToReachTarget(target int, types [][]int) int {\\n\\tdp := make([]uint32, target+1)\\n\\tdp[0] = 1\\n\\tfor _, t := range types {\\n\\t\\tfor i := target; i >= 0; i-- {\\n\\t\\t\\tfor j, c := i-t[1], t[0]; j >= 0 && c != 0; j, c = j-t[1], c-1 {\\n\\t\\t\\t\\tdp[i] = (dp[i] + dp[j]) % 1000000007\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn int(dp[target])\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3264467,
                "title": "dp-recursion-memoisation-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=(int)(1e9+7);\\n    int f(int i,int j,vector<vector<int>> &types,vector<vector<int>> &dp){\\n        if (j==0) return 1;\\n        if (i==0){\\n            if (j>types[0][0]*types[0][1]) return 0;\\n            if (j<types[0][1]) return 0;\\n            if (j%types[0][1]!=0) return 0;\\n            return 1;\\n        }\\n        if (dp[i][j]!=-1) return dp[i][j];\\n        int ans=0;\\n        for (int k=0;k<=types[i][0];k++){\\n            if (types[i][1]*k>j) break;\\n            else ans=ans%mod+f(i-1,j-types[i][1]*k,types,dp)%mod;\\n        }\\n        return dp[i][j]=ans%mod;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n=types.size();\\n        vector<vector<int>> dp(n,vector<int>(target+1,-1));\\n        return f(types.size()-1,target,types,dp)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=(int)(1e9+7);\\n    int f(int i,int j,vector<vector<int>> &types,vector<vector<int>> &dp){\\n        if (j==0) return 1;\\n        if (i==0){\\n            if (j>types[0][0]*types[0][1]) return 0;\\n            if (j<types[0][1]) return 0;\\n            if (j%types[0][1]!=0) return 0;\\n            return 1;\\n        }\\n        if (dp[i][j]!=-1) return dp[i][j];\\n        int ans=0;\\n        for (int k=0;k<=types[i][0];k++){\\n            if (types[i][1]*k>j) break;\\n            else ans=ans%mod+f(i-1,j-types[i][1]*k,types,dp)%mod;\\n        }\\n        return dp[i][j]=ans%mod;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n=types.size();\\n        vector<vector<int>> dp(n,vector<int>(target+1,-1));\\n        return f(types.size()-1,target,types,dp)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3264032,
                "title": "dynamic-programming-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int waysToReachTarget(int target, int[][] types)\\n    {\\n      int[][] dp=new int[types.length][target+1];\\n      for(int i=0;i<dp.length;i++)\\n      {\\n      for(int j=0;j<=target;j++)\\n      dp[i][j]=-1;\\n      }\\n      int val=solve(types,target,0,0,dp);\\n      return val;  \\n    }\\n    public int solve(int[][] types,int target,int index,int sum,int[][] dp)\\n    {\\n        \\n        if(index>=types.length)\\n        {\\n            return sum==target?1:0;\\n        }\\n        if(sum>target) return 0;\\n        if(dp[index][target-sum]!=-1) {\\n            return dp[index][target-sum];\\n        }\\n        int count=0;\\n        for(int i=0;i<=types[index][0];i++)\\n        {\\n            count+=solve(types,target,index+1,sum+(i*types[index][1]),dp);\\n            count=count%1000000007;\\n        }\\n        return dp[index][target-sum]=count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int waysToReachTarget(int target, int[][] types)\\n    {\\n      int[][] dp=new int[types.length][target+1];\\n      for(int i=0;i<dp.length;i++)\\n      {\\n      for(int j=0;j<=target;j++)\\n      dp[i][j]=-1;\\n      }\\n      int val=solve(types,target,0,0,dp);\\n      return val;  \\n    }\\n    public int solve(int[][] types,int target,int index,int sum,int[][] dp)\\n    {\\n        \\n        if(index>=types.length)\\n        {\\n            return sum==target?1:0;\\n        }\\n        if(sum>target) return 0;\\n        if(dp[index][target-sum]!=-1) {\\n            return dp[index][target-sum];\\n        }\\n        int count=0;\\n        for(int i=0;i<=types[index][0];i++)\\n        {\\n            count+=solve(types,target,index+1,sum+(i*types[index][1]),dp);\\n            count=count%1000000007;\\n        }\\n        return dp[index][target-sum]=count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3263893,
                "title": "java-recursion-memoisation",
                "content": "# Complexity\\n- Time complexity:\\nO(N*target*N)\\n- Space complexity:\\nO(target*N), N~=50, target~=1000\\n# Code\\n```\\nclass Solution {\\n\\n    final int mod = 1_000_000_007;\\n\\n    public int waysToReachTarget(int target, int[][] types) {\\n        int[][] dp = new int[target + 1][types.length + 1];\\n        for (int[] d : dp) Arrays.fill(d, -1);\\n        return helper(target, types, 0, dp);\\n    }\\n\\n    private int helper(int target, int[][] types, int ind, int[][] dp) {\\n        // base case\\n        if (target == 0) return 1;\\n        if (ind >= types.length) return 0;\\n\\n        int ans = 0;\\n        int cnt = types[ind][0];\\n        int value = types[ind][1];\\n\\n        if (dp[target][ind] != -1) return dp[target][ind];\\n        for (int i = 0; i <= cnt; i++) {\\n            if (target - value * i >= 0) {\\n                // take\\n                ans = (ans + helper(target - value * i, types, ind + 1, dp)) % mod;\\n            }\\n        }\\n        return dp[target][ind] = ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    final int mod = 1_000_000_007;\\n\\n    public int waysToReachTarget(int target, int[][] types) {\\n        int[][] dp = new int[target + 1][types.length + 1];\\n        for (int[] d : dp) Arrays.fill(d, -1);\\n        return helper(target, types, 0, dp);\\n    }\\n\\n    private int helper(int target, int[][] types, int ind, int[][] dp) {\\n        // base case\\n        if (target == 0) return 1;\\n        if (ind >= types.length) return 0;\\n\\n        int ans = 0;\\n        int cnt = types[ind][0];\\n        int value = types[ind][1];\\n\\n        if (dp[target][ind] != -1) return dp[target][ind];\\n        for (int i = 0; i <= cnt; i++) {\\n            if (target - value * i >= 0) {\\n                // take\\n                ans = (ans + helper(target - value * i, types, ind + 1, dp)) % mod;\\n            }\\n        }\\n        return dp[target][ind] = ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3263839,
                "title": "100-faster-knapsack-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(n * target * count)\\n\\n- Space complexity: O(n * target)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[51][5001];\\n    int wayCount(int index, int target, int curr, vector<vector<int>>&types){\\n        if(index==types.size()){\\n            return target==0;\\n        }\\n        if(dp[index][target]!=-1) return dp[index][target]%1000000007;\\n        long long ans=0;\\n        for(int i=0; i<=types[index][0]; i++){\\n            if(target-types[index][1]*i>=0){\\n                ans+=wayCount(index+1,target-types[index][1]*i,curr,types);\\n            }\\n            else break;\\n        }\\n        return dp[index][target]=ans%1000000007;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        memset(dp,-1,sizeof(dp));\\n        return wayCount(0,target,0,types);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[51][5001];\\n    int wayCount(int index, int target, int curr, vector<vector<int>>&types){\\n        if(index==types.size()){\\n            return target==0;\\n        }\\n        if(dp[index][target]!=-1) return dp[index][target]%1000000007;\\n        long long ans=0;\\n        for(int i=0; i<=types[index][0]; i++){\\n            if(target-types[index][1]*i>=0){\\n                ans+=wayCount(index+1,target-types[index][1]*i,curr,types);\\n            }\\n            else break;\\n        }\\n        return dp[index][target]=ans%1000000007;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        memset(dp,-1,sizeof(dp));\\n        return wayCount(0,target,0,types);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3262869,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    int MOD = 1000000007;\\n    Integer[][] dp = new Integer[51][1001];\\n    public int waysToReachTarget(int target, int[][] types) {\\n        return solve(types, 0, target);\\n    }\\n    \\n    private  int solve(int[][] types, int curr, int target) {\\n        if(target == 0) return 1;\\n        if(curr == types.length || target < 0) return 0;\\n        if(dp[curr][target] != null) return dp[curr][target];\\n        int result = 0;\\n        for(int q = 0; q <= types[curr][0]; q++) {\\n            int marks = q * types[curr][1];\\n            int ways = solve(types, curr + 1, target - marks) % MOD;\\n            result = ((result % MOD) + ways) % MOD;\\n        }\\n        \\n        return dp[curr][target] = result % MOD;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int MOD = 1000000007;\\n    Integer[][] dp = new Integer[51][1001];\\n    public int waysToReachTarget(int target, int[][] types) {\\n        return solve(types, 0, target);\\n    }\\n    \\n    private  int solve(int[][] types, int curr, int target) {\\n        if(target == 0) return 1;\\n        if(curr == types.length || target < 0) return 0;\\n        if(dp[curr][target] != null) return dp[curr][target];\\n        int result = 0;\\n        for(int q = 0; q <= types[curr][0]; q++) {\\n            int marks = q * types[curr][1];\\n            int ways = solve(types, curr + 1, target - marks) % MOD;\\n            result = ((result % MOD) + ways) % MOD;\\n        }\\n        \\n        return dp[curr][target] = result % MOD;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3262645,
                "title": "100-faster-c-top-down-dp-memoization",
                "content": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\ntypedef long long ll;\\ntypedef pair<int, int> pi;\\n#define forn(i, n) for(int i = 0;i < n;i++)\\n#define forn2(i, s, e) for(int i = s;i < e;i++)\\n#define pb push_back\\ntypedef vector<int> vi;\\ntypedef vector<vector<int>> vvi;\\ntypedef vector<ll> vl;\\ntypedef pair<double, double> pd;\\ntypedef vector<vector<ll>> vvl;\\ntypedef vector<bool> vb;\\ntypedef vector<string> vs;\\ntypedef pair<int, pi>ppi;\\nint mod = 1e9 + 7;\\ntemplate<typename T>\\n \\nvoid printvec(T& data){\\n    forn(i, data.size()){\\n        cout << data[i] << \" \";\\n    }\\n    cout << endl;\\n}\\n\\nclass Solution {\\npublic:\\n    \\n    int dp[51][51][1001];\\n    vvi arr;\\n    \\n    int solve(int pos, int cur_type, int target){\\n        if(target == 0) return 1;\\n        if(pos >= arr.size() || target < 0) return 0;\\n        \\n        if(dp[pos][cur_type][target] != -1) return dp[pos][cur_type][target];\\n        \\n        int output = 0;\\n        if(pos+1 < arr.size()) output = solve(pos+1, arr[pos+1][0], target);\\n        if(cur_type > 0) output = (output + solve(pos, cur_type-1, target - arr[pos][1])) % mod;\\n        \\n        return dp[pos][cur_type][target] = output;\\n    }\\n    \\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        arr = types;\\n        memset(dp, -1, sizeof(dp));\\n        \\n        return solve(0, types[0][0], target);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\ntypedef long long ll;\\ntypedef pair<int, int> pi;\\n#define forn(i, n) for(int i = 0;i < n;i++)\\n#define forn2(i, s, e) for(int i = s;i < e;i++)\\n#define pb push_back\\ntypedef vector<int> vi;\\ntypedef vector<vector<int>> vvi;\\ntypedef vector<ll> vl;\\ntypedef pair<double, double> pd;\\ntypedef vector<vector<ll>> vvl;\\ntypedef vector<bool> vb;\\ntypedef vector<string> vs;\\ntypedef pair<int, pi>ppi;\\nint mod = 1e9 + 7;\\ntemplate<typename T>\\n \\nvoid printvec(T& data){\\n    forn(i, data.size()){\\n        cout << data[i] << \" \";\\n    }\\n    cout << endl;\\n}\\n\\nclass Solution {\\npublic:\\n    \\n    int dp[51][51][1001];\\n    vvi arr;\\n    \\n    int solve(int pos, int cur_type, int target){\\n        if(target == 0) return 1;\\n        if(pos >= arr.size() || target < 0) return 0;\\n        \\n        if(dp[pos][cur_type][target] != -1) return dp[pos][cur_type][target];\\n        \\n        int output = 0;\\n        if(pos+1 < arr.size()) output = solve(pos+1, arr[pos+1][0], target);\\n        if(cur_type > 0) output = (output + solve(pos, cur_type-1, target - arr[pos][1])) % mod;\\n        \\n        return dp[pos][cur_type][target] = output;\\n    }\\n    \\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        arr = types;\\n        memset(dp, -1, sizeof(dp));\\n        \\n        return solve(0, types[0][0], target);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3262535,
                "title": "simple-and-easy-to-understand-python3-solution",
                "content": "\\n# Code\\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\\n              \\n        dp = [1]+ [0] * target\\n        mod = 10 ** 9 + 7\\n        for tp in types:\\n            counts = tp[0]\\n            mark = tp[1]\\n            for i in range(target, 0, -1):\\n                for count in range(1, counts+1):\\n                    if i >= mark*count:\\n                        dp[i] = (dp[i] + dp[i-mark*count])\\n                        #print(dp)\\n                #print(dp)\\n            #print(dp)\\n        return dp[target] % mod\\n             \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\n# Code\\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\\n              \\n        dp = [1]+ [0] * target\\n        mod = 10 ** 9 + 7\\n        for tp in types:\\n            counts = tp[0]\\n            mark = tp[1]\\n            for i in range(target, 0, -1):\\n                for count in range(1, counts+1):\\n                    if i >= mark*count:\\n                        dp[i] = (dp[i] + dp[i-mark*count])\\n                        #print(dp)\\n                #print(dp)\\n            #print(dp)\\n        return dp[target] % mod\\n             \\n\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3262408,
                "title": "recursion-memoization-solution",
                "content": "**Recursion code:** *Time Limit Exceeded*\\n\\n```\\n    private final int MOD = (int)1e9 + 7;\\n    public int waysToReachTarget(int target, int[][] types) {\\n        int n = types.length;\\n        return helper(0, n, 0, target, types) % MOD;\\n    }\\n    \\n    private int helper(int index, int n, int currentSum, int target, int [][] types){\\n        if(currentSum == target){\\n            return 1;\\n        }\\n        if(currentSum > target){\\n            return 0;\\n        }\\n        if(index == n){\\n            if(target == currentSum){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        \\n        \\n        int take = 0, notTake = 0;\\n        \\n        for(int i=1;i<=types[index][0];i++){\\n            take = (take + (helper(index+1, n, currentSum + i*types[index][1], target, types)) % MOD) % MOD;\\n        }\\n        \\n        notTake = (notTake + (helper(index+1, n, currentSum, target, types)) % MOD) % MOD;\\n            \\n        return (take + notTake) % MOD;\\n    }\\n```\\n\\n**Memoization code:** *Accepted*\\n\\n```\\n\\tprivate final int MOD = (int)1e9 + 7;\\n    public int waysToReachTarget(int target, int[][] types) {\\n        int n = types.length;\\n        int [][] memo = new int[n][target+1];\\n        for(int i=0;i<memo.length;i++){\\n            Arrays.fill(memo[i], -1);\\n        }\\n        return helper(0, n, 0, target, types, memo) % MOD;\\n    }\\n    \\n    private int helper(int index, int n, int currentSum, int target, int [][] types, int [][] memo){\\n        if(currentSum == target){\\n            return 1;\\n        }\\n        if(currentSum > target){\\n            return 0;\\n        }\\n        if(index == n){\\n            if(target == currentSum){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        \\n        if(memo[index][currentSum] != -1){\\n            return memo[index][currentSum];\\n        }\\n        \\n        \\n        int take = 0, notTake = 0;\\n        \\n        for(int i=1;i<=types[index][0];i++){\\n            take = (take + (helper(index+1, n, currentSum + i*types[index][1], target, types, memo)) % MOD) % MOD;\\n        }\\n        \\n        notTake = (notTake + (helper(index+1, n, currentSum, target, types, memo)) % MOD) % MOD;\\n            \\n        return memo[index][currentSum] = (take + notTake) % MOD;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n    private final int MOD = (int)1e9 + 7;\\n    public int waysToReachTarget(int target, int[][] types) {\\n        int n = types.length;\\n        return helper(0, n, 0, target, types) % MOD;\\n    }\\n    \\n    private int helper(int index, int n, int currentSum, int target, int [][] types){\\n        if(currentSum == target){\\n            return 1;\\n        }\\n        if(currentSum > target){\\n            return 0;\\n        }\\n        if(index == n){\\n            if(target == currentSum){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        \\n        \\n        int take = 0, notTake = 0;\\n        \\n        for(int i=1;i<=types[index][0];i++){\\n            take = (take + (helper(index+1, n, currentSum + i*types[index][1], target, types)) % MOD) % MOD;\\n        }\\n        \\n        notTake = (notTake + (helper(index+1, n, currentSum, target, types)) % MOD) % MOD;\\n            \\n        return (take + notTake) % MOD;\\n    }\\n```\n```\\n\\tprivate final int MOD = (int)1e9 + 7;\\n    public int waysToReachTarget(int target, int[][] types) {\\n        int n = types.length;\\n        int [][] memo = new int[n][target+1];\\n        for(int i=0;i<memo.length;i++){\\n            Arrays.fill(memo[i], -1);\\n        }\\n        return helper(0, n, 0, target, types, memo) % MOD;\\n    }\\n    \\n    private int helper(int index, int n, int currentSum, int target, int [][] types, int [][] memo){\\n        if(currentSum == target){\\n            return 1;\\n        }\\n        if(currentSum > target){\\n            return 0;\\n        }\\n        if(index == n){\\n            if(target == currentSum){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        \\n        if(memo[index][currentSum] != -1){\\n            return memo[index][currentSum];\\n        }\\n        \\n        \\n        int take = 0, notTake = 0;\\n        \\n        for(int i=1;i<=types[index][0];i++){\\n            take = (take + (helper(index+1, n, currentSum + i*types[index][1], target, types, memo)) % MOD) % MOD;\\n        }\\n        \\n        notTake = (notTake + (helper(index+1, n, currentSum, target, types, memo)) % MOD) % MOD;\\n            \\n        return memo[index][currentSum] = (take + notTake) % MOD;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3262333,
                "title": "c-coin-change",
                "content": "```\\nclass Solution {\\npublic:\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int mod = 1e9 + 7;\\n        vector<int> ways(target + 1);\\n        ways[0] = 1;\\n        \\n        for (auto& q : types) {\\n            vector<int> nxt = ways;\\n            for (int j = 0; j < q[0]; ++j) {\\n                int c = (j + 1) * q[1];\\n                for (int s = c; s <= target; ++s) {\\n                    nxt[s] = (nxt[s] + ways[s - c]) % mod;\\n                }\\n            }\\n            swap(nxt, ways);\\n        }\\n        return ways[target];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int mod = 1e9 + 7;\\n        vector<int> ways(target + 1);\\n        ways[0] = 1;\\n        \\n        for (auto& q : types) {\\n            vector<int> nxt = ways;\\n            for (int j = 0; j < q[0]; ++j) {\\n                int c = (j + 1) * q[1];\\n                for (int s = c; s <= target; ++s) {\\n                    nxt[s] = (nxt[s] + ways[s - c]) % mod;\\n                }\\n            }\\n            swap(nxt, ways);\\n        }\\n        return ways[target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3262150,
                "title": "rust-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn ways_to_reach_target(target: i32, types: Vec<Vec<i32>>) -> i32 {\\n        let n = types.len();\\n        let mut dp = vec![-1; target as usize + 1];\\n\\n        for k in 0 ..= target / types[0][1] {\\n            if k > types[0][0] { break }\\n            dp[(k * types[0][1]) as usize] = 1;\\n        }\\n\\n        for i in 1 .. types.len() {\\n            let mut temp = vec![-1; target as usize + 1];\\n            for j in 0 ..= target {\\n                for k in 0 ..= j / types[i][1] {\\n                    if k > types[i][0] { break }\\n                    \\n                    let r = j - k * types[i][1];\\n                    if dp[r as usize] == -1 { continue }\\n\\n                    if temp[j as usize] == -1 { temp[j as usize] = 0; }\\n                    temp[j as usize] = (temp[j as usize] + dp[r as usize]) % 1_000_000_007;\\n                }\\n            }\\n            dp = temp;\\n        }\\n        if dp[target as usize] == -1 { 0 } else { dp[target as usize] }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn ways_to_reach_target(target: i32, types: Vec<Vec<i32>>) -> i32 {\\n        let n = types.len();\\n        let mut dp = vec![-1; target as usize + 1];\\n\\n        for k in 0 ..= target / types[0][1] {\\n            if k > types[0][0] { break }\\n            dp[(k * types[0][1]) as usize] = 1;\\n        }\\n\\n        for i in 1 .. types.len() {\\n            let mut temp = vec![-1; target as usize + 1];\\n            for j in 0 ..= target {\\n                for k in 0 ..= j / types[i][1] {\\n                    if k > types[i][0] { break }\\n                    \\n                    let r = j - k * types[i][1];\\n                    if dp[r as usize] == -1 { continue }\\n\\n                    if temp[j as usize] == -1 { temp[j as usize] = 0; }\\n                    temp[j as usize] = (temp[j as usize] + dp[r as usize]) % 1_000_000_007;\\n                }\\n            }\\n            dp = temp;\\n        }\\n        if dp[target as usize] == -1 { 0 } else { dp[target as usize] }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3261975,
                "title": "intuition-top-down-memoization-explanation-100-runtime-100-memory",
                "content": "# Intuition\\nIntuition is to generate each combination of question and their marks to reach target. In that process, keep a track of already taken counts of each question and store intermediate results to optimize. \\n# Approach\\nAt each level, we check if we are left with at least 1 count of testType=Index. If we are, we use it and subtract it for the target and recursively call function with reduced target. \\n\\nQuestion does not mention, but we do not take any questions `before` (index). Meaning, if we take 2 count of Question1 and 1 count of Question0, that is not allowed, so we only go for questions which are `after` (index) \\n\\n\\n# Code\\n```\\nclass Solution {\\n    int max = 1000000007;\\n    int[][][] memo;\\n    public int waysToReachTarget(int target, int[][] types) {\\n        memo = new int[types.length + 1][51][target+1];\\n        for(int[][] a : memo) {\\n            for(int[] aa : a) \\n            Arrays.fill(aa,-1);\\n        }\\n        return dfs(0, target, 0, types, new int[types.length]);\\n    }\\n    \\n    private int dfs(int index, int target, int ways, int[][] types, int[] taken) {\\n        // If we reach target, return 1 \"way\" to meet target \\n\\n        if (target == 0) return 1;\\n\\n        // If test index is greater than available, or target goes below 0, we return 0 \"ways\" . \\n        // Question mentions \"no of ways to reach exact at target\", so anything < target is not acceptable \\n\\n        if (index >= types.length || target < 0) return 0;\\n        /**\\n        At each [index] , and total utilzied coutns of that index taken[index] and given target ,\\n        we check whether we saw that combo before or not. If yes, we return it. \\n\\n        It would be incorrect to just look at Index & Target combination, as No_Of_Ways to reach target depends \\n        on how many time given test at index has been chose before. \\n\\n        taken[index] gives us the count of how many time given test at index was taken before reach at current state. \\n         */\\n        if (memo[index][taken[index]][target] != -1) return memo[index][taken[index]][target];\\n        int ans = 0;\\n        // At each level, we can not take any tests before (index-1), so we start at index \\n        // At test index, if max no of those tests are taken, we can not proceed, hence we check for taken[i] < types[i][0]\\n        for(int i = index; i < types.length; i++) {\\n            if (taken[i] < types[i][0]) {\\n                taken[i]++;\\n                int count = dfs(i, target - types[i][1], ways, types, taken);\\n                //if (count != -1) ans += count;\\n                ans += count;\\n                ans = ans % max;\\n                taken[i]--;\\n            }\\n        }\\n        // Result is specific to [test at Index][PReviously taken count of test at index][Current target] , so we store it in memoization\\n        memo[index][taken[index]][target] = ans % max;\\n        return ans % max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int max = 1000000007;\\n    int[][][] memo;\\n    public int waysToReachTarget(int target, int[][] types) {\\n        memo = new int[types.length + 1][51][target+1];\\n        for(int[][] a : memo) {\\n            for(int[] aa : a) \\n            Arrays.fill(aa,-1);\\n        }\\n        return dfs(0, target, 0, types, new int[types.length]);\\n    }\\n    \\n    private int dfs(int index, int target, int ways, int[][] types, int[] taken) {\\n        // If we reach target, return 1 \"way\" to meet target \\n\\n        if (target == 0) return 1;\\n\\n        // If test index is greater than available, or target goes below 0, we return 0 \"ways\" . \\n        // Question mentions \"no of ways to reach exact at target\", so anything < target is not acceptable \\n\\n        if (index >= types.length || target < 0) return 0;\\n        /**\\n        At each [index] , and total utilzied coutns of that index taken[index] and given target ,\\n        we check whether we saw that combo before or not. If yes, we return it. \\n\\n        It would be incorrect to just look at Index & Target combination, as No_Of_Ways to reach target depends \\n        on how many time given test at index has been chose before. \\n\\n        taken[index] gives us the count of how many time given test at index was taken before reach at current state. \\n         */\\n        if (memo[index][taken[index]][target] != -1) return memo[index][taken[index]][target];\\n        int ans = 0;\\n        // At each level, we can not take any tests before (index-1), so we start at index \\n        // At test index, if max no of those tests are taken, we can not proceed, hence we check for taken[i] < types[i][0]\\n        for(int i = index; i < types.length; i++) {\\n            if (taken[i] < types[i][0]) {\\n                taken[i]++;\\n                int count = dfs(i, target - types[i][1], ways, types, taken);\\n                //if (count != -1) ans += count;\\n                ans += count;\\n                ans = ans % max;\\n                taken[i]--;\\n            }\\n        }\\n        // Result is specific to [test at Index][PReviously taken count of test at index][Current target] , so we store it in memoization\\n        memo[index][taken[index]][target] = ans % max;\\n        return ans % max;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3261974,
                "title": "java-2d-dp-solution-inspired-from-coin-change-ii",
                "content": "Slight modification from [Coin Change II](https://leetcode.com/problems/coin-change-ii/)\\n\\nIn Coin Change II, each coin can be used infinite times.\\n\\nIn this question, each question can be used up to `count` times.\\n\\ndp[i][j]: choose from [0,..,j-1] first j questions that can earn i points. \\n\\nFor jth question, we can use up to `count` times. Question j is worth `point` points.\\n\\n`dp[i][j] = dp[i-0*point][j-1] + dp[i-1*point][j-1] + dp[i-2*point][j-1] + ... + dp[i-count*point][j-1] `\\n\\n```\\n    public int waysToReachTarget(int target, int[][] types) {\\n        int n = types.length;\\n        // dp[i][j]: choose from [0,...,j-1] first j questions that can earn i points\\n        int[][] dp = new int[target + 1][n + 1];\\n        \\n        for(int j=0;j<=n;j++) dp[0][j] = 1;\\n        \\n        for(int i=1;i<=n;i++){\\n            int count = types[i-1][0];\\n            int point = types[i-1][1];\\n            for(int k=1;k<=target;k++){\\n                for(int c=0;c<=count;c++){\\n                    if(k-c*point<0) break;\\n                    dp[k][i] = (dp[k][i] + dp[k-c*point][i-1])%1000000007;\\n                }\\n            }\\n        }\\n        return dp[target][n];\\n    }",
                "solutionTags": [],
                "code": "Slight modification from [Coin Change II](https://leetcode.com/problems/coin-change-ii/)\\n\\nIn Coin Change II, each coin can be used infinite times.\\n\\nIn this question, each question can be used up to `count` times.\\n\\ndp[i][j]: choose from [0,..,j-1] first j questions that can earn i points. \\n\\nFor jth question, we can use up to `count` times. Question j is worth `point` points.\\n\\n`dp[i][j] = dp[i-0*point][j-1] + dp[i-1*point][j-1] + dp[i-2*point][j-1] + ... + dp[i-count*point][j-1] `\\n\\n```\\n    public int waysToReachTarget(int target, int[][] types) {\\n        int n = types.length;\\n        // dp[i][j]: choose from [0,...,j-1] first j questions that can earn i points\\n        int[][] dp = new int[target + 1][n + 1];\\n        \\n        for(int j=0;j<=n;j++) dp[0][j] = 1;\\n        \\n        for(int i=1;i<=n;i++){\\n            int count = types[i-1][0];\\n            int point = types[i-1][1];\\n            for(int k=1;k<=target;k++){\\n                for(int c=0;c<=count;c++){\\n                    if(k-c*point<0) break;\\n                    dp[k][i] = (dp[k][i] + dp[k-c*point][i-1])%1000000007;\\n                }\\n            }\\n        }\\n        return dp[target][n];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3261966,
                "title": "python-dp-memorization-explained",
                "content": "Just a straight forward dp solution.\\n\\n(1) We have `n` types of different problems to choose;\\n(2) For each of type of problem at index `i`, we can select `from 0 to types[i][0]` questions, which can give us `from 0 to types[i][0] * types[i][1]` score;\\n(3) We start from index 0, count the total number of options we have at each index. For example, at index 0, we can get score `[0, types[0][1], 2 * types[0][1], 3 * types[0][1], ...., types[0][0] * types[0][1]]` \\n(4) After we pick the score at index 0, we can move to the next index and solve some number of problems to reach the `new_target = target - score_at_index0`\\n(5) repeat the above step, until the `new_target == 0`, or we reach the end of the types list.\\n\\n\\n```\\nclass Solution:\\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\\n        self.dp = collections.defaultdict(lambda: None)\\n        self.len_types = len(types)\\n        self.types = types\\n        \\n        ans = self.dfsFind(0, target)\\n        return ans % 1000000007\\n    \\n        \\n    def dfsFind(self, i, target):\\n        if i >= self.len_types:\\n            if target == 0:\\n                self.dp[i, target] = 1\\n            else:\\n                self.dp[i, target] = 0\\n                \\n        if self.dp[i, target] is None:\\n            options = 0\\n            questions = self.types[i]\\n            max_sum = questions[0] * questions[1]\\n            for s in range(0, max_sum + 1, questions[1]):\\n                ntarget = target - s\\n                if ntarget >= 0:\\n                    options += self.dfsFind(i + 1, ntarget)\\n            self.dp[i, target] = options\\n        \\n        return self.dp[i, target]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\\n        self.dp = collections.defaultdict(lambda: None)\\n        self.len_types = len(types)\\n        self.types = types\\n        \\n        ans = self.dfsFind(0, target)\\n        return ans % 1000000007\\n    \\n        \\n    def dfsFind(self, i, target):\\n        if i >= self.len_types:\\n            if target == 0:\\n                self.dp[i, target] = 1\\n            else:\\n                self.dp[i, target] = 0\\n                \\n        if self.dp[i, target] is None:\\n            options = 0\\n            questions = self.types[i]\\n            max_sum = questions[0] * questions[1]\\n            for s in range(0, max_sum + 1, questions[1]):\\n                ntarget = target - s\\n                if ntarget >= 0:\\n                    options += self.dfsFind(i + 1, ntarget)\\n            self.dp[i, target] = options\\n        \\n        return self.dp[i, target]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261945,
                "title": "top-down-dp",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int mod = 1E9 + 7;\\n        // dp[i][score] = ways to make up score using types[i : -1]\\n        vector<vector<int>> dp(types.size(), vector<int>(1001, -1));\\n\\n        function<int(int, int)> dfs = [&](int start, int target) -> int\\n        {\\n            // base case\\n            if (target == 0) return 1;\\n            if (start >= types.size()) return 0;\\n            if (dp[start][target] >= 0) return dp[start][target];\\n\\n            int ans = 0;\\n            for (int i = 0; i <= types[start][0]; i ++)\\n            {\\n                if (target - i * types[start][1] < 0) break;\\n                ans += dfs(start + 1, target - i * types[start][1]);\\n                ans %= mod;\\n            }\\n            dp[start][target] = ans;\\n            return ans;\\n        };\\n        return dfs(0, target);;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int mod = 1E9 + 7;\\n        // dp[i][score] = ways to make up score using types[i : -1]\\n        vector<vector<int>> dp(types.size(), vector<int>(1001, -1));\\n\\n        function<int(int, int)> dfs = [&](int start, int target) -> int\\n        {\\n            // base case\\n            if (target == 0) return 1;\\n            if (start >= types.size()) return 0;\\n            if (dp[start][target] >= 0) return dp[start][target];\\n\\n            int ans = 0;\\n            for (int i = 0; i <= types[start][0]; i ++)\\n            {\\n                if (target - i * types[start][1] < 0) break;\\n                ans += dfs(start + 1, target - i * types[start][1]);\\n                ans %= mod;\\n            }\\n            dp[start][target] = ans;\\n            return ans;\\n        };\\n        return dfs(0, target);;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261889,
                "title": "number-of-ways-to-earn-points",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long mod=1e9+7;\\n    vector<vector<int>>dp;\\n    long long  rec(int i,int j,int target,vector<vector<int>>& types)\\n    { int n=types.size();\\n           if(target<=0)return target==0;\\n        if(i>=n )return 0;\\n       long long x=0,ans=0;\\n       if(dp[target][i]!=-1)return dp[target][i];\\n      for(int k=1;k<=types[i][0];k++)\\n      {\\n          ans=(ans+rec(i+1,1,target-k*types[i][1],types))%mod;\\n      }\\n      ans=(ans+rec(i+1,1,target,types))%mod;\\n     \\n        \\n       \\n       \\n     return (long long)(dp[target][i]=(int)ans);\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        dp.clear();\\n        dp=vector<vector<int>>(1004,vector<int>(51,-1));\\n        return (int)rec(0,1,target,types);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long mod=1e9+7;\\n    vector<vector<int>>dp;\\n    long long  rec(int i,int j,int target,vector<vector<int>>& types)\\n    { int n=types.size();\\n           if(target<=0)return target==0;\\n        if(i>=n )return 0;\\n       long long x=0,ans=0;\\n       if(dp[target][i]!=-1)return dp[target][i];\\n      for(int k=1;k<=types[i][0];k++)\\n      {\\n          ans=(ans+rec(i+1,1,target-k*types[i][1],types))%mod;\\n      }\\n      ans=(ans+rec(i+1,1,target,types))%mod;\\n     \\n        \\n       \\n       \\n     return (long long)(dp[target][i]=(int)ans);\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        dp.clear();\\n        dp=vector<vector<int>>(1004,vector<int>(51,-1));\\n        return (int)rec(0,1,target,types);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261566,
                "title": "easy-to-understand-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        vector<int> dp(target+1,0);\\n        dp[0] = 1;\\n        int mod = 1e9 + 7;\\n        // iterate on all types of questions\\n        for (auto &q : types) {\\n            // try all possible targets with given question type\\n            for (int t = target; t > 0; t--) {\\n                int maxScore = q[1]*q[0];\\n                // iterate over till we hit max score possible with given question type and count\\n                for (int score = q[1]; (score <= maxScore) && ((t-score) >= 0); score += q[1]) {\\n                    dp[t] = (dp[t] + dp[t-score]) % mod;\\n                }\\n            }\\n        }\\n        return dp[target];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        vector<int> dp(target+1,0);\\n        dp[0] = 1;\\n        int mod = 1e9 + 7;\\n        // iterate on all types of questions\\n        for (auto &q : types) {\\n            // try all possible targets with given question type\\n            for (int t = target; t > 0; t--) {\\n                int maxScore = q[1]*q[0];\\n                // iterate over till we hit max score possible with given question type and count\\n                for (int score = q[1]; (score <= maxScore) && ((t-score) >= 0); score += q[1]) {\\n                    dp[t] = (dp[t] + dp[t-score]) % mod;\\n                }\\n            }\\n        }\\n        return dp[target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261332,
                "title": "swift-knapsack-dp-easy-solution-beats-100",
                "content": "# Complexity\\n- Time complexity: O(NMK)\\n- Space complexity: O(N)\\nN = target\\nM = types\\nK = max number of type\\n\\n# Code\\n```\\nclass Solution {\\n    func waysToReachTarget(_ target: Int, _ types: [[Int]]) -> Int {\\n        let n = types.count\\n        let modulo = 1000000007\\n        var dp = Array(repeating: 0, count: target + 1)\\n        dp[0] = 1\\n        for type in types {\\n            let val = type[1]\\n            guard val <= target else { continue }\\n            for trg in (val...target).reversed() {\\n                for k in 1...type[0] {\\n                    guard k * val <= trg else { break }\\n                    dp[trg] = (dp[trg] + dp[trg-k*val]) % modulo\\n                }\\n            }\\n        }\\n        return dp[target]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    func waysToReachTarget(_ target: Int, _ types: [[Int]]) -> Int {\\n        let n = types.count\\n        let modulo = 1000000007\\n        var dp = Array(repeating: 0, count: target + 1)\\n        dp[0] = 1\\n        for type in types {\\n            let val = type[1]\\n            guard val <= target else { continue }\\n            for trg in (val...target).reversed() {\\n                for k in 1...type[0] {\\n                    guard k * val <= trg else { break }\\n                    dp[trg] = (dp[trg] + dp[trg-k*val]) % modulo\\n                }\\n            }\\n        }\\n        return dp[target]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261256,
                "title": "c-dynamic-programming-faster-than-100-with-o-m-n-time-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    unsigned long long mod=1e9+7;\\n    unsigned long long F[51][1001],A[1001];\\n    unsigned long long Add(unsigned long long a,unsigned long long b)\\n    {\\n        return (a+b) >= mod ? a+b-mod : a+b;\\n    }\\n    unsigned long long Sub(unsigned long long a,unsigned long long b)\\n    {\\n        return a>=b ? a-b : a-b+mod;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        for(int i=0;i<=types.size()-1;i++)\\n        {\\n            memset(A,0,sizeof(A));\\n            for(int j=1;j<=target;j++)\\n            {\\n                if(i==0)\\n                {\\n                    if(j%types[i][1]==0&&j<=types[i][0]*types[i][1])\\n                        F[i][j]=1;\\n                }\\n                else\\n                {\\n                    if(j<types[i][1])\\n                    {\\n                        A[j]=F[i-1][j];\\n                        F[i][j]=F[i-1][j];\\n                    }\\n                    else\\n                    {\\n                        if(j<=types[i][0]*types[i][1])\\n                        {\\n                            A[j]=Add(F[i-1][j],A[j-types[i][1]]);\\n                        }\\n                        else\\n                        {\\n                            A[j]=Sub(Add(F[i-1][j],A[j-types[i][1]]),F[i-1][j-types[i][0]*types[i][1]]);\\n                        }\\n                        if(j%types[i][1]==0&&j<=types[i][0]*types[i][1])\\n                            F[i][j]=1;\\n                        F[i][j]=Add(F[i][j],Add(A[j-types[i][1]],F[i-1][j]));\\n                    }\\n                }\\n            }\\n        }\\n        return F[types.size()-1][target];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unsigned long long mod=1e9+7;\\n    unsigned long long F[51][1001],A[1001];\\n    unsigned long long Add(unsigned long long a,unsigned long long b)\\n    {\\n        return (a+b) >= mod ? a+b-mod : a+b;\\n    }\\n    unsigned long long Sub(unsigned long long a,unsigned long long b)\\n    {\\n        return a>=b ? a-b : a-b+mod;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        for(int i=0;i<=types.size()-1;i++)\\n        {\\n            memset(A,0,sizeof(A));\\n            for(int j=1;j<=target;j++)\\n            {\\n                if(i==0)\\n                {\\n                    if(j%types[i][1]==0&&j<=types[i][0]*types[i][1])\\n                        F[i][j]=1;\\n                }\\n                else\\n                {\\n                    if(j<types[i][1])\\n                    {\\n                        A[j]=F[i-1][j];\\n                        F[i][j]=F[i-1][j];\\n                    }\\n                    else\\n                    {\\n                        if(j<=types[i][0]*types[i][1])\\n                        {\\n                            A[j]=Add(F[i-1][j],A[j-types[i][1]]);\\n                        }\\n                        else\\n                        {\\n                            A[j]=Sub(Add(F[i-1][j],A[j-types[i][1]]),F[i-1][j-types[i][0]*types[i][1]]);\\n                        }\\n                        if(j%types[i][1]==0&&j<=types[i][0]*types[i][1])\\n                            F[i][j]=1;\\n                        F[i][j]=Add(F[i][j],Add(A[j-types[i][1]],F[i-1][j]));\\n                    }\\n                }\\n            }\\n        }\\n        return F[types.size()-1][target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261175,
                "title": "easy-coin-change-with-limited-coins",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ncoin change\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncoin change with limited coins \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n *target^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n*target)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static const int MOD = 1e9 + 7;\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n = types.size();\\n        \\n        long long  dp[n][target+1];\\n        \\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<=target; j++){\\n                if(j==0){\\n                    dp[i][j] = 1;\\n                }else if(i==0){\\n                    int count = types[i][0];\\n                    int coin = types[i][1];\\n                    if(j%coin==0 && j<=coin*count){\\n                        dp[i][j] = 1;\\n                    }else{\\n                        dp[i][j] = 0;\\n                    }\\n                    \\n                }\\n                else{\\n                    int it = j;\\n                    long long int ans = 0;\\n                    int cnt = types[i][0];\\n                    \\n                    while(it>=0 && cnt>=0){\\n                        ans+=dp[i-1][it]%MOD;\\n                        cnt--;\\n                        it  = it-types[i][1];\\n                    }\\n                    \\n                    dp[i][j] = ans%MOD;\\n                }\\n            }\\n        }\\n        \\n        return dp[n-1][target];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static const int MOD = 1e9 + 7;\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n = types.size();\\n        \\n        long long  dp[n][target+1];\\n        \\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<=target; j++){\\n                if(j==0){\\n                    dp[i][j] = 1;\\n                }else if(i==0){\\n                    int count = types[i][0];\\n                    int coin = types[i][1];\\n                    if(j%coin==0 && j<=coin*count){\\n                        dp[i][j] = 1;\\n                    }else{\\n                        dp[i][j] = 0;\\n                    }\\n                    \\n                }\\n                else{\\n                    int it = j;\\n                    long long int ans = 0;\\n                    int cnt = types[i][0];\\n                    \\n                    while(it>=0 && cnt>=0){\\n                        ans+=dp[i-1][it]%MOD;\\n                        cnt--;\\n                        it  = it-types[i][1];\\n                    }\\n                    \\n                    dp[i][j] = ans%MOD;\\n                }\\n            }\\n        }\\n        \\n        return dp[n-1][target];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261173,
                "title": "knapsack-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\\n        MOD = 10**9+7\\n        table = [1] + [0] * target\\n\\n        for count, point in types:\\n            prev = list(table)\\n            for k in range(1, count+1):\\n                amount = k * point\\n                for i in range(amount, target+1):\\n                    if i - amount >= 0: table[i] += prev[i-amount]\\n\\n        return table[target] % MOD\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\\n        MOD = 10**9+7\\n        table = [1] + [0] * target\\n\\n        for count, point in types:\\n            prev = list(table)\\n            for k in range(1, count+1):\\n                amount = k * point\\n                for i in range(amount, target+1):\\n                    if i - amount >= 0: table[i] += prev[i-amount]\\n\\n        return table[target] % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261078,
                "title": "python-clean-and-short-dp-memo-top-down",
                "content": "# Intuition\\nLet `f(t,i)` be amount of ways to earn exactly `t` points by using only `0..i` questions. Let\\'s define all possibilities where can we get from state `f(t,i)`:\\n1. We used nothing from `i`th type question. Then `f(t,i) -> f(t,i-1)`\\n2. We used some count `1 <= c <= count[i]` of `i`th type. Then `f(t,i) -> f(t-c*mark[i], i-1)`\\n\\nGeneralizing above we get recursive equation:\\n$f(t,i) = \\\\sum_{c=0}^{count[i]}f(t-mark[i]*c,i-1)$ with edge cases  edge cases $f(0,i) = 1, i\\\\ge0 $ and $f(t,i) = 0, t\\\\lt0 \\\\space or \\\\space i \\\\lt0$\\n\\n# Approach\\nImplement recursive equation from above, stop conditions, and leverage memoization via `@cache`.\\n\\n# Complexity\\n- Time complexity: $O(target*n*max(count))$\\n- Space complexity: $O(target*n)$\\n\\n# Code\\n```\\nclass Solution:\\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\\n        MOD = 10**9+7\\n        @cache\\n        def f(t, i):\\n            if t == 0: return 1\\n            if t < 0 or i < 0: return 0            \\n            c,m = types[i]\\n            return sum(f(t-m*j, i-1) for j in range(0, c+1))%MOD \\n        return f(target, len(types)-1)\\n            \\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\\n        MOD = 10**9+7\\n        @cache\\n        def f(t, i):\\n            if t == 0: return 1\\n            if t < 0 or i < 0: return 0            \\n            c,m = types[i]\\n            return sum(f(t-m*j, i-1) for j in range(0, c+1))%MOD \\n        return f(target, len(types)-1)\\n            \\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260811,
                "title": "dp-solution-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nconst int MOD = 1e9 + 7;\\nint numWays(int target, vector<vector<int>>& types) {\\n    int n = types.size();\\n    vector<int> dp(target+1);\\n    dp[0] = 1;\\n    for (int i = 0; i < n; i++) {\\n        for (int j = target; j >= types[i][1]; j--) {\\n            for (int k = 1; k <= types[i][0]; k++) {\\n                if (j - k*types[i][1] >= 0) {\\n                    dp[j] = (dp[j] + dp[j - k*types[i][1]]) % MOD;\\n                }\\n            }\\n        }\\n    }\\n    return dp[target];\\n}\\n    \\n\\nint waysToReachTarget(int target, vector<vector<int>>& ty) {\\n       \\n        \\n        return numWays(target,ty);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nconst int MOD = 1e9 + 7;\\nint numWays(int target, vector<vector<int>>& types) {\\n    int n = types.size();\\n    vector<int> dp(target+1);\\n    dp[0] = 1;\\n    for (int i = 0; i < n; i++) {\\n        for (int j = target; j >= types[i][1]; j--) {\\n            for (int k = 1; k <= types[i][0]; k++) {\\n                if (j - k*types[i][1] >= 0) {\\n                    dp[j] = (dp[j] + dp[j - k*types[i][1]]) % MOD;\\n                }\\n            }\\n        }\\n    }\\n    return dp[target];\\n}\\n    \\n\\nint waysToReachTarget(int target, vector<vector<int>>& ty) {\\n       \\n        \\n        return numWays(target,ty);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260721,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn ways_to_reach_target(target: i32, types: Vec<Vec<i32>>) -> i32 {\\n        let mut dp = vec![0; target as usize + 1];\\n        dp[0] = 1;\\n        let mod_ = 1_000_000_007;\\n        for c in types {\\n            let mut i = target;\\n            while i >= 0 {\\n                let mut v = c[1];\\n                while v <= c[0] * c[1] && i - v >= 0 {\\n                    dp[i as usize] = (dp[i as usize] + dp[(i - v) as usize]) % mod_;\\n                    v += c[1];\\n                }\\n                i -= 1;\\n            }\\n        }\\n        dp[target as usize]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn ways_to_reach_target(target: i32, types: Vec<Vec<i32>>) -> i32 {\\n        let mut dp = vec![0; target as usize + 1];\\n        dp[0] = 1;\\n        let mod_ = 1_000_000_007;\\n        for c in types {\\n            let mut i = target;\\n            while i >= 0 {\\n                let mut v = c[1];\\n                while v <= c[0] * c[1] && i - v >= 0 {\\n                    dp[i as usize] = (dp[i as usize] + dp[(i - v) as usize]) % mod_;\\n                    v += c[1];\\n                }\\n                i -= 1;\\n            }\\n        }\\n        dp[target as usize]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3260720,
                "title": "recursion-memoziation-bottom-up-tabulation-top-down-standard-knap-sack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTry all the possible ways.\\n\\n\\n# Recursion\\n```\\nclass Solution {\\n    long mod = 1000000007;\\n\\n    long f(int[][] types, int target, int n) {\\n        if (target == 0) return 1;\\n        if (n < 0 || target < 0) return 0;\\n\\n        long ways = 0;\\n\\n        for (int q = 0; q <= types[n][0]; q++) {\\n            ways = ways % mod + f(types, target - types[n][1] * q, n - 1) % mod;\\n        }\\n        return ways % mod;\\n    }    \\n\\n    public int waysToReachTarget(int target, int[][] types) {\\n        int n = types.length;\\n        Arrays.sort(types, (x, y) -> y[1] - x[1]);\\n        return (int)f(types, target, n - 1, dp);\\n    }\\n}\\n```\\n## Complexity\\n- Time complexity: O(target ^ N)\\n\\n- Space complexity: O(N)\\n\\n\\n# Memoziation (Bottom-Up)\\n```\\nclass Solution {\\n    long mod = 1000000007;\\n\\n    long f(int[][] types, int target, int n, long[][] dp) {\\n        if (target == 0) return 1;\\n        if (n < 0 || target < 0) return 0;\\n        if (dp[target][n] != -1) return dp[target][n];\\n\\n        long ways = 0;\\n\\n        for (int q = 0; q <= types[n][0]; q++) {\\n            ways = ways % mod + f(types, target - types[n][1] * q, n - 1, dp) % mod;\\n        }\\n        dp[target][n] = ways % mod;\\n\\n        return dp[target][n];\\n    }    \\n\\n    public int waysToReachTarget(int target, int[][] types) {\\n        int n = types.length;\\n        Arrays.sort(types, (x, y) -> y[1] - x[1]);\\n\\n        long[][] dp = new long[n + 1][target + 1];\\n\\n        for (int i = 0; i <= target; i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n\\n        return (int)f(types, target, n - 1, dp);\\n    }\\n}\\n``` \\n## Complexity\\n- Time complexity: O(N * Target * Target)\\n\\n- Space complexity: O(N * Target)\\n\\n# Tabulation (Top-Down)\\n```\\nclass Solution {\\n    long mod = 1000000007;\\n\\n    public int waysToReachTarget(int target, int[][] types) {\\n        int n = types.length;\\n        Arrays.sort(types, (x, y) -> y[1] - x[1]);\\n\\n        long[][] dp = new long[n + 1][target + 1];\\n\\n        for (int i = 0; i <= n; i++) {\\n            dp[i][0] = 1;\\n        }\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= target; j++) {\\n                long ways = 0;\\n                for (int k = 0; k <= types[i - 1][0]; k++) {\\n                    int marks = types[i - 1][1] * k;\\n                    if (j - marks < 0 ) break;\\n                    ways = ways % mod + dp[i - 1][j - marks] % mod;\\n                }\\n                dp[i][j] = ways % mod;\\n            }\\n        }\\n\\n        return (int)dp[n][target];\\n    }\\n}\\n```\\n## Complexity\\n- Time complexity: O(N * Target * Target)\\n\\n- Space complexity: O(N * Target)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    long mod = 1000000007;\\n\\n    long f(int[][] types, int target, int n) {\\n        if (target == 0) return 1;\\n        if (n < 0 || target < 0) return 0;\\n\\n        long ways = 0;\\n\\n        for (int q = 0; q <= types[n][0]; q++) {\\n            ways = ways % mod + f(types, target - types[n][1] * q, n - 1) % mod;\\n        }\\n        return ways % mod;\\n    }    \\n\\n    public int waysToReachTarget(int target, int[][] types) {\\n        int n = types.length;\\n        Arrays.sort(types, (x, y) -> y[1] - x[1]);\\n        return (int)f(types, target, n - 1, dp);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    long mod = 1000000007;\\n\\n    long f(int[][] types, int target, int n, long[][] dp) {\\n        if (target == 0) return 1;\\n        if (n < 0 || target < 0) return 0;\\n        if (dp[target][n] != -1) return dp[target][n];\\n\\n        long ways = 0;\\n\\n        for (int q = 0; q <= types[n][0]; q++) {\\n            ways = ways % mod + f(types, target - types[n][1] * q, n - 1, dp) % mod;\\n        }\\n        dp[target][n] = ways % mod;\\n\\n        return dp[target][n];\\n    }    \\n\\n    public int waysToReachTarget(int target, int[][] types) {\\n        int n = types.length;\\n        Arrays.sort(types, (x, y) -> y[1] - x[1]);\\n\\n        long[][] dp = new long[n + 1][target + 1];\\n\\n        for (int i = 0; i <= target; i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n\\n        return (int)f(types, target, n - 1, dp);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    long mod = 1000000007;\\n\\n    public int waysToReachTarget(int target, int[][] types) {\\n        int n = types.length;\\n        Arrays.sort(types, (x, y) -> y[1] - x[1]);\\n\\n        long[][] dp = new long[n + 1][target + 1];\\n\\n        for (int i = 0; i <= n; i++) {\\n            dp[i][0] = 1;\\n        }\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= target; j++) {\\n                long ways = 0;\\n                for (int k = 0; k <= types[i - 1][0]; k++) {\\n                    int marks = types[i - 1][1] * k;\\n                    if (j - marks < 0 ) break;\\n                    ways = ways % mod + dp[i - 1][j - marks] % mod;\\n                }\\n                dp[i][j] = ways % mod;\\n            }\\n        }\\n\\n        return (int)dp[n][target];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260626,
                "title": "java-dp-easy-to-understand-memomization",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    int mod=(int)(1000000007);\\n    public int waysToReachTarget(int target, int[][] types) {\\n        return ways(target,types,0,new Integer[types.length][target+1]);\\n    }\\n    public int ways(int target,int [][]types,int i,Integer [][]dp){\\n        if(target==0){\\n            return 1;      \\n\\n        }\\n        if(i==types.length){\\n            return 0;      \\n\\n        }\\n        \\n        int count=types[i][0]; \\n        int marks=types[i][1]; \\n        int Ways=0;    \\n        int t1=target;\\n\\n        if(dp[i][target]!=null){\\n            return dp[i][target];\\n        }\\n\\n        for(int j=0;j<=count;j++){\\n            if(target<0){\\n                break;\\n            }\\n            Ways=(Ways+ways(target,types,i+1,dp))%mod;\\n            target-=marks;\\n\\n        }\\n        return dp[i][t1]=Ways;\\n\\n   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int mod=(int)(1000000007);\\n    public int waysToReachTarget(int target, int[][] types) {\\n        return ways(target,types,0,new Integer[types.length][target+1]);\\n    }\\n    public int ways(int target,int [][]types,int i,Integer [][]dp){\\n        if(target==0){\\n            return 1;      \\n\\n        }\\n        if(i==types.length){\\n            return 0;      \\n\\n        }\\n        \\n        int count=types[i][0]; \\n        int marks=types[i][1]; \\n        int Ways=0;    \\n        int t1=target;\\n\\n        if(dp[i][target]!=null){\\n            return dp[i][target];\\n        }\\n\\n        for(int j=0;j<=count;j++){\\n            if(target<0){\\n                break;\\n            }\\n            Ways=(Ways+ways(target,types,i+1,dp))%mod;\\n            target-=marks;\\n\\n        }\\n        return dp[i][t1]=Ways;\\n\\n   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260244,
                "title": "dp-java-knapsack-dp-solution",
                "content": "# Intuition\\nA variety of coin change problem aka Limited Coin Change.\\n\\n\\n# Complexity\\n- Time complexity: $$O(T*N*C)$$ where T=Target, N=Types, C=Count\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(T*N*C)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java\\nclass Solution {\\n    private static final int MOD = 1000000007;\\n    public int waysToReachTarget(int target, int[][] types) {\\n        int memo[][][] = new int[target+1][51][51];\\n        for(int i=0;i<memo.length;i++) for(int j=0;j<memo[i].length;j++) Arrays.fill(memo[i][j], -1);\\n        return dp(target, types.length-1, types[types.length-1][0], types, memo);\\n    }\\n    \\n    private int dp(int target, int curType, int cur, final int[][] types, final int[][][] memo) {\\n        if(target==0) {\\n            return 1;\\n        }\\n        if(target<0) return 0;\\n        if(memo[target][curType][cur]!=-1) return memo[target][curType][cur];\\n        \\n        int sum = 0;\\n        if(curType>0) sum = dp(target, curType-1, types[curType-1][0], types, memo) % MOD;\\n        if(cur>0) sum = (sum + dp(target-types[curType][1], curType, cur-1, types, memo)) % MOD;\\n        \\n        return memo[target][curType][cur]=sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```java\\nclass Solution {\\n    private static final int MOD = 1000000007;\\n    public int waysToReachTarget(int target, int[][] types) {\\n        int memo[][][] = new int[target+1][51][51];\\n        for(int i=0;i<memo.length;i++) for(int j=0;j<memo[i].length;j++) Arrays.fill(memo[i][j], -1);\\n        return dp(target, types.length-1, types[types.length-1][0], types, memo);\\n    }\\n    \\n    private int dp(int target, int curType, int cur, final int[][] types, final int[][][] memo) {\\n        if(target==0) {\\n            return 1;\\n        }\\n        if(target<0) return 0;\\n        if(memo[target][curType][cur]!=-1) return memo[target][curType][cur];\\n        \\n        int sum = 0;\\n        if(curType>0) sum = dp(target, curType-1, types[curType-1][0], types, memo) % MOD;\\n        if(cur>0) sum = (sum + dp(target-types[curType][1], curType, cur-1, types, memo)) % MOD;\\n        \\n        return memo[target][curType][cur]=sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260157,
                "title": "recursion-memoization-dp-very-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int dp[51][1001];\\n    int mod=1e9+7;\\n    int f(int i, int target, vector<vector<int>>& types)\\n    {\\n        if(target==0) return 1;\\n        if(i==types.size() || target<0) return 0;\\n        if(dp[i][target]!=-1) return dp[i][target];\\n        int ans=0, c=0;\\n        for(int y=0; y<=types[i][0]; y++)\\n        {\\n            ans=(ans+f(i+1,target-c,types))%mod;\\n            c+=types[i][1];\\n        }\\n        return dp[i][target]=ans;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        return f(0,target,types);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int dp[51][1001];\\n    int mod=1e9+7;\\n    int f(int i, int target, vector<vector<int>>& types)\\n    {\\n        if(target==0) return 1;\\n        if(i==types.size() || target<0) return 0;\\n        if(dp[i][target]!=-1) return dp[i][target];\\n        int ans=0, c=0;\\n        for(int y=0; y<=types[i][0]; y++)\\n        {\\n            ans=(ans+f(i+1,target-c,types))%mod;\\n            c+=types[i][1];\\n        }\\n        return dp[i][target]=ans;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        return f(0,target,types);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259917,
                "title": "c-dp-o-n-target-count-number-of-ways-to-earn-points",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[55][1010];\\n    int MOD = 1e9+7;\\n    int rec(int level, int target, int n, vector<vector<int>> &types){\\n        if(level==n){\\n            if(target==0) return 1;\\n            return 0;\\n        }\\n        if(dp[level][target] != -1) return dp[level][target];\\n        int ans = 0;\\n        int tot = types[level][0];\\n        int mark = types[level][1];\\n        for(int i=0; i<=tot; i++){\\n            if(target>=(i*mark)){\\n                ans = (ans+rec(level+1,target-i*mark,n,types)%MOD)%MOD;\\n            }\\n        }\\n        return dp[level][target]=ans%MOD;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n = types.size();\\n        for(int i=0; i<=n; i++){\\n            for(int j=0; j<=target; j++){\\n                dp[i][j]=-1;\\n            }\\n        }\\n        return rec(0,target,n,types);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[55][1010];\\n    int MOD = 1e9+7;\\n    int rec(int level, int target, int n, vector<vector<int>> &types){\\n        if(level==n){\\n            if(target==0) return 1;\\n            return 0;\\n        }\\n        if(dp[level][target] != -1) return dp[level][target];\\n        int ans = 0;\\n        int tot = types[level][0];\\n        int mark = types[level][1];\\n        for(int i=0; i<=tot; i++){\\n            if(target>=(i*mark)){\\n                ans = (ans+rec(level+1,target-i*mark,n,types)%MOD)%MOD;\\n            }\\n        }\\n        return dp[level][target]=ans%MOD;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        int n = types.size();\\n        for(int i=0; i<=n; i++){\\n            for(int j=0; j<=target; j++){\\n                dp[i][j]=-1;\\n            }\\n        }\\n        return rec(0,target,n,types);\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2010225,
                "content": [
                    {
                        "username": "user8272RT",
                        "content": "I struggled with this one. Took me a while to figure out why the number of questions must be tracked in the dp table."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "unbounded knapsack\\nmemoize the count of questions too"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Can anyone help me find out what mistake I am doing here??\\n\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int count(vector<int> &nums,int n,int target,vector<vector<int>> &dp,unordered_map<int,int> &m)\\n    {\\n        if(target==0) return 1;\\n        if(n==0)\\n        {\\n            if(target%nums[n]==0)\\n            {\\n                if(m[nums[n]]>=target/nums[n]) return 1;\\n            }\\n            return 0;\\n        }\\n        if(m[nums[n]]<0) return 0;\\n        if(dp[n][target]!=-1) return dp[n][target];\\n        int nottake=count(nums,n-1,target,dp,m);\\n        int take=0;\\n        if(nums[n]<=target)\\n        {\\n            m[nums[n]]--;\\n            take=count(nums,n,target-nums[n],dp,m);\\n            m[nums[n]]++;\\n        }\\n        return dp[n][target]=(take+nottake)%mod;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        unordered_map<int,int> m;\\n        int n=types.size();\\n        vector<int> nums(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i]=types[i][1];\\n            m[types[i][1]]=types[i][0];\\n        }\\n        vector<vector<int>> dp(n,vector<int> (target+1,-1));\\n        return count(nums,n-1,target,dp,m);\\n    }\\n};"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Can anyone help me please, to figure out why my memoisation is not working properly. Is i\\'m defining the states in wrong way?\\nAny help will be highly appreciated!\\n```\\nclass Solution1 {\\npublic:\\n    int n;\\n    \\n    #define ll long long\\n    const long long int mod = 1e9 + 7;\\n    \\n    ll solve(int target ,int i, vector<vector<int>> &types,vector<vector<ll>> &dp){\\n        \\n        if(i == n || target < 0) return 0;\\n        if(target == 0) return 1;\\n        \\n        if(dp[i][target] != -1) return dp[i][target];\\n        \\n        ll pick = 0;\\n        if(types[i][0] > 0){\\n            types[i][0]--;\\n            pick = solve(target-types[i][1], i , types,dp)%mod;\\n            types[i][0]++;\\n        }\\n        \\n        ll not_pick = solve(target,i+1,types,dp)%mod;\\n        \\n        return dp[i][target] = (pick + not_pick)%mod;\\n    }\\n    \\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        \\n        n = types.size();\\n        vector<vector<ll>> dp(n, vector<ll>(target+1,-1));\\n\\n        return  solve(target,0,types,dp);\\n        \\n    }\\n};\\n```"
                    },
                    {
                        "username": "SJha_2001",
                        "content": "[@the_coder_8297](/the_coder_8297)  Add one more state to your dp, to keep track of count of questions of \"i\"th type"
                    },
                    {
                        "username": "RamKumarGoyal",
                        "content": "you have to add one more state in your dp, i.e count of the ith type of ques and interchange the first two lines of code"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "[@M_yousuf](/M_yousuf) I just interchanged the first two lines, \\nif(target == 0) return 1;\\nif(i == n || target < 0) return 0;\\n\\nStill i\\'m getting the wrong answer, for the third test case [[6,1],[3,2],[2,3] , my code is displaying answer as 14,  while correct answer is 1."
                    },
                    {
                        "username": "M_yousuf",
                        "content": "\nif(i==n and target == 0) this should also return 1\n but your code will going to return 0 \ncheck if(target == 0) before the condition if(i==n || target<0)"
                    },
                    {
                        "username": "yjianghong",
                        "content": "Man what a joke, this problem is easier than the one before it"
                    },
                    {
                        "username": "2uringTested",
                        "content": "so? who said it would have to be harder?"
                    }
                ]
            },
            {
                "id": 2009165,
                "content": [
                    {
                        "username": "user8272RT",
                        "content": "I struggled with this one. Took me a while to figure out why the number of questions must be tracked in the dp table."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "unbounded knapsack\\nmemoize the count of questions too"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Can anyone help me find out what mistake I am doing here??\\n\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int count(vector<int> &nums,int n,int target,vector<vector<int>> &dp,unordered_map<int,int> &m)\\n    {\\n        if(target==0) return 1;\\n        if(n==0)\\n        {\\n            if(target%nums[n]==0)\\n            {\\n                if(m[nums[n]]>=target/nums[n]) return 1;\\n            }\\n            return 0;\\n        }\\n        if(m[nums[n]]<0) return 0;\\n        if(dp[n][target]!=-1) return dp[n][target];\\n        int nottake=count(nums,n-1,target,dp,m);\\n        int take=0;\\n        if(nums[n]<=target)\\n        {\\n            m[nums[n]]--;\\n            take=count(nums,n,target-nums[n],dp,m);\\n            m[nums[n]]++;\\n        }\\n        return dp[n][target]=(take+nottake)%mod;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        unordered_map<int,int> m;\\n        int n=types.size();\\n        vector<int> nums(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i]=types[i][1];\\n            m[types[i][1]]=types[i][0];\\n        }\\n        vector<vector<int>> dp(n,vector<int> (target+1,-1));\\n        return count(nums,n-1,target,dp,m);\\n    }\\n};"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Can anyone help me please, to figure out why my memoisation is not working properly. Is i\\'m defining the states in wrong way?\\nAny help will be highly appreciated!\\n```\\nclass Solution1 {\\npublic:\\n    int n;\\n    \\n    #define ll long long\\n    const long long int mod = 1e9 + 7;\\n    \\n    ll solve(int target ,int i, vector<vector<int>> &types,vector<vector<ll>> &dp){\\n        \\n        if(i == n || target < 0) return 0;\\n        if(target == 0) return 1;\\n        \\n        if(dp[i][target] != -1) return dp[i][target];\\n        \\n        ll pick = 0;\\n        if(types[i][0] > 0){\\n            types[i][0]--;\\n            pick = solve(target-types[i][1], i , types,dp)%mod;\\n            types[i][0]++;\\n        }\\n        \\n        ll not_pick = solve(target,i+1,types,dp)%mod;\\n        \\n        return dp[i][target] = (pick + not_pick)%mod;\\n    }\\n    \\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        \\n        n = types.size();\\n        vector<vector<ll>> dp(n, vector<ll>(target+1,-1));\\n\\n        return  solve(target,0,types,dp);\\n        \\n    }\\n};\\n```"
                    },
                    {
                        "username": "SJha_2001",
                        "content": "[@the_coder_8297](/the_coder_8297)  Add one more state to your dp, to keep track of count of questions of \"i\"th type"
                    },
                    {
                        "username": "RamKumarGoyal",
                        "content": "you have to add one more state in your dp, i.e count of the ith type of ques and interchange the first two lines of code"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "[@M_yousuf](/M_yousuf) I just interchanged the first two lines, \\nif(target == 0) return 1;\\nif(i == n || target < 0) return 0;\\n\\nStill i\\'m getting the wrong answer, for the third test case [[6,1],[3,2],[2,3] , my code is displaying answer as 14,  while correct answer is 1."
                    },
                    {
                        "username": "M_yousuf",
                        "content": "\nif(i==n and target == 0) this should also return 1\n but your code will going to return 0 \ncheck if(target == 0) before the condition if(i==n || target<0)"
                    },
                    {
                        "username": "yjianghong",
                        "content": "Man what a joke, this problem is easier than the one before it"
                    },
                    {
                        "username": "2uringTested",
                        "content": "so? who said it would have to be harder?"
                    }
                ]
            },
            {
                "id": 1861034,
                "content": [
                    {
                        "username": "user8272RT",
                        "content": "I struggled with this one. Took me a while to figure out why the number of questions must be tracked in the dp table."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "unbounded knapsack\\nmemoize the count of questions too"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Can anyone help me find out what mistake I am doing here??\\n\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int count(vector<int> &nums,int n,int target,vector<vector<int>> &dp,unordered_map<int,int> &m)\\n    {\\n        if(target==0) return 1;\\n        if(n==0)\\n        {\\n            if(target%nums[n]==0)\\n            {\\n                if(m[nums[n]]>=target/nums[n]) return 1;\\n            }\\n            return 0;\\n        }\\n        if(m[nums[n]]<0) return 0;\\n        if(dp[n][target]!=-1) return dp[n][target];\\n        int nottake=count(nums,n-1,target,dp,m);\\n        int take=0;\\n        if(nums[n]<=target)\\n        {\\n            m[nums[n]]--;\\n            take=count(nums,n,target-nums[n],dp,m);\\n            m[nums[n]]++;\\n        }\\n        return dp[n][target]=(take+nottake)%mod;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        unordered_map<int,int> m;\\n        int n=types.size();\\n        vector<int> nums(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i]=types[i][1];\\n            m[types[i][1]]=types[i][0];\\n        }\\n        vector<vector<int>> dp(n,vector<int> (target+1,-1));\\n        return count(nums,n-1,target,dp,m);\\n    }\\n};"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Can anyone help me please, to figure out why my memoisation is not working properly. Is i\\'m defining the states in wrong way?\\nAny help will be highly appreciated!\\n```\\nclass Solution1 {\\npublic:\\n    int n;\\n    \\n    #define ll long long\\n    const long long int mod = 1e9 + 7;\\n    \\n    ll solve(int target ,int i, vector<vector<int>> &types,vector<vector<ll>> &dp){\\n        \\n        if(i == n || target < 0) return 0;\\n        if(target == 0) return 1;\\n        \\n        if(dp[i][target] != -1) return dp[i][target];\\n        \\n        ll pick = 0;\\n        if(types[i][0] > 0){\\n            types[i][0]--;\\n            pick = solve(target-types[i][1], i , types,dp)%mod;\\n            types[i][0]++;\\n        }\\n        \\n        ll not_pick = solve(target,i+1,types,dp)%mod;\\n        \\n        return dp[i][target] = (pick + not_pick)%mod;\\n    }\\n    \\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        \\n        n = types.size();\\n        vector<vector<ll>> dp(n, vector<ll>(target+1,-1));\\n\\n        return  solve(target,0,types,dp);\\n        \\n    }\\n};\\n```"
                    },
                    {
                        "username": "SJha_2001",
                        "content": "[@the_coder_8297](/the_coder_8297)  Add one more state to your dp, to keep track of count of questions of \"i\"th type"
                    },
                    {
                        "username": "RamKumarGoyal",
                        "content": "you have to add one more state in your dp, i.e count of the ith type of ques and interchange the first two lines of code"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "[@M_yousuf](/M_yousuf) I just interchanged the first two lines, \\nif(target == 0) return 1;\\nif(i == n || target < 0) return 0;\\n\\nStill i\\'m getting the wrong answer, for the third test case [[6,1],[3,2],[2,3] , my code is displaying answer as 14,  while correct answer is 1."
                    },
                    {
                        "username": "M_yousuf",
                        "content": "\nif(i==n and target == 0) this should also return 1\n but your code will going to return 0 \ncheck if(target == 0) before the condition if(i==n || target<0)"
                    },
                    {
                        "username": "yjianghong",
                        "content": "Man what a joke, this problem is easier than the one before it"
                    },
                    {
                        "username": "2uringTested",
                        "content": "so? who said it would have to be harder?"
                    }
                ]
            },
            {
                "id": 1822552,
                "content": [
                    {
                        "username": "user8272RT",
                        "content": "I struggled with this one. Took me a while to figure out why the number of questions must be tracked in the dp table."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "unbounded knapsack\\nmemoize the count of questions too"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Can anyone help me find out what mistake I am doing here??\\n\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int count(vector<int> &nums,int n,int target,vector<vector<int>> &dp,unordered_map<int,int> &m)\\n    {\\n        if(target==0) return 1;\\n        if(n==0)\\n        {\\n            if(target%nums[n]==0)\\n            {\\n                if(m[nums[n]]>=target/nums[n]) return 1;\\n            }\\n            return 0;\\n        }\\n        if(m[nums[n]]<0) return 0;\\n        if(dp[n][target]!=-1) return dp[n][target];\\n        int nottake=count(nums,n-1,target,dp,m);\\n        int take=0;\\n        if(nums[n]<=target)\\n        {\\n            m[nums[n]]--;\\n            take=count(nums,n,target-nums[n],dp,m);\\n            m[nums[n]]++;\\n        }\\n        return dp[n][target]=(take+nottake)%mod;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        unordered_map<int,int> m;\\n        int n=types.size();\\n        vector<int> nums(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i]=types[i][1];\\n            m[types[i][1]]=types[i][0];\\n        }\\n        vector<vector<int>> dp(n,vector<int> (target+1,-1));\\n        return count(nums,n-1,target,dp,m);\\n    }\\n};"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Can anyone help me please, to figure out why my memoisation is not working properly. Is i\\'m defining the states in wrong way?\\nAny help will be highly appreciated!\\n```\\nclass Solution1 {\\npublic:\\n    int n;\\n    \\n    #define ll long long\\n    const long long int mod = 1e9 + 7;\\n    \\n    ll solve(int target ,int i, vector<vector<int>> &types,vector<vector<ll>> &dp){\\n        \\n        if(i == n || target < 0) return 0;\\n        if(target == 0) return 1;\\n        \\n        if(dp[i][target] != -1) return dp[i][target];\\n        \\n        ll pick = 0;\\n        if(types[i][0] > 0){\\n            types[i][0]--;\\n            pick = solve(target-types[i][1], i , types,dp)%mod;\\n            types[i][0]++;\\n        }\\n        \\n        ll not_pick = solve(target,i+1,types,dp)%mod;\\n        \\n        return dp[i][target] = (pick + not_pick)%mod;\\n    }\\n    \\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        \\n        n = types.size();\\n        vector<vector<ll>> dp(n, vector<ll>(target+1,-1));\\n\\n        return  solve(target,0,types,dp);\\n        \\n    }\\n};\\n```"
                    },
                    {
                        "username": "SJha_2001",
                        "content": "[@the_coder_8297](/the_coder_8297)  Add one more state to your dp, to keep track of count of questions of \"i\"th type"
                    },
                    {
                        "username": "RamKumarGoyal",
                        "content": "you have to add one more state in your dp, i.e count of the ith type of ques and interchange the first two lines of code"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "[@M_yousuf](/M_yousuf) I just interchanged the first two lines, \\nif(target == 0) return 1;\\nif(i == n || target < 0) return 0;\\n\\nStill i\\'m getting the wrong answer, for the third test case [[6,1],[3,2],[2,3] , my code is displaying answer as 14,  while correct answer is 1."
                    },
                    {
                        "username": "M_yousuf",
                        "content": "\nif(i==n and target == 0) this should also return 1\n but your code will going to return 0 \ncheck if(target == 0) before the condition if(i==n || target<0)"
                    },
                    {
                        "username": "yjianghong",
                        "content": "Man what a joke, this problem is easier than the one before it"
                    },
                    {
                        "username": "2uringTested",
                        "content": "so? who said it would have to be harder?"
                    }
                ]
            },
            {
                "id": 1822489,
                "content": [
                    {
                        "username": "user8272RT",
                        "content": "I struggled with this one. Took me a while to figure out why the number of questions must be tracked in the dp table."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "unbounded knapsack\\nmemoize the count of questions too"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Can anyone help me find out what mistake I am doing here??\\n\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int count(vector<int> &nums,int n,int target,vector<vector<int>> &dp,unordered_map<int,int> &m)\\n    {\\n        if(target==0) return 1;\\n        if(n==0)\\n        {\\n            if(target%nums[n]==0)\\n            {\\n                if(m[nums[n]]>=target/nums[n]) return 1;\\n            }\\n            return 0;\\n        }\\n        if(m[nums[n]]<0) return 0;\\n        if(dp[n][target]!=-1) return dp[n][target];\\n        int nottake=count(nums,n-1,target,dp,m);\\n        int take=0;\\n        if(nums[n]<=target)\\n        {\\n            m[nums[n]]--;\\n            take=count(nums,n,target-nums[n],dp,m);\\n            m[nums[n]]++;\\n        }\\n        return dp[n][target]=(take+nottake)%mod;\\n    }\\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        unordered_map<int,int> m;\\n        int n=types.size();\\n        vector<int> nums(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i]=types[i][1];\\n            m[types[i][1]]=types[i][0];\\n        }\\n        vector<vector<int>> dp(n,vector<int> (target+1,-1));\\n        return count(nums,n-1,target,dp,m);\\n    }\\n};"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Can anyone help me please, to figure out why my memoisation is not working properly. Is i\\'m defining the states in wrong way?\\nAny help will be highly appreciated!\\n```\\nclass Solution1 {\\npublic:\\n    int n;\\n    \\n    #define ll long long\\n    const long long int mod = 1e9 + 7;\\n    \\n    ll solve(int target ,int i, vector<vector<int>> &types,vector<vector<ll>> &dp){\\n        \\n        if(i == n || target < 0) return 0;\\n        if(target == 0) return 1;\\n        \\n        if(dp[i][target] != -1) return dp[i][target];\\n        \\n        ll pick = 0;\\n        if(types[i][0] > 0){\\n            types[i][0]--;\\n            pick = solve(target-types[i][1], i , types,dp)%mod;\\n            types[i][0]++;\\n        }\\n        \\n        ll not_pick = solve(target,i+1,types,dp)%mod;\\n        \\n        return dp[i][target] = (pick + not_pick)%mod;\\n    }\\n    \\n    int waysToReachTarget(int target, vector<vector<int>>& types) {\\n        \\n        n = types.size();\\n        vector<vector<ll>> dp(n, vector<ll>(target+1,-1));\\n\\n        return  solve(target,0,types,dp);\\n        \\n    }\\n};\\n```"
                    },
                    {
                        "username": "SJha_2001",
                        "content": "[@the_coder_8297](/the_coder_8297)  Add one more state to your dp, to keep track of count of questions of \"i\"th type"
                    },
                    {
                        "username": "RamKumarGoyal",
                        "content": "you have to add one more state in your dp, i.e count of the ith type of ques and interchange the first two lines of code"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "[@M_yousuf](/M_yousuf) I just interchanged the first two lines, \\nif(target == 0) return 1;\\nif(i == n || target < 0) return 0;\\n\\nStill i\\'m getting the wrong answer, for the third test case [[6,1],[3,2],[2,3] , my code is displaying answer as 14,  while correct answer is 1."
                    },
                    {
                        "username": "M_yousuf",
                        "content": "\nif(i==n and target == 0) this should also return 1\n but your code will going to return 0 \ncheck if(target == 0) before the condition if(i==n || target<0)"
                    },
                    {
                        "username": "yjianghong",
                        "content": "Man what a joke, this problem is easier than the one before it"
                    },
                    {
                        "username": "2uringTested",
                        "content": "so? who said it would have to be harder?"
                    }
                ]
            }
        ]
    }
]