[
    {
        "title": "Unique Email Addresses",
        "question_content": "Every valid email consists of a local name and a domain name, separated by the '@' sign. Besides lowercase letters, the email may contain one or more '.' or '+'.\n\n\tFor example, in \"alice@leetcode.com\", \"alice\" is the local name, and \"leetcode.com\" is the domain name.\n\nIf you add periods '.' between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name. Note that this rule does not apply to domain names.\n\n\tFor example, \"alice.z@leetcode.com\" and \"alicez@leetcode.com\" forward to the same email address.\n\nIf you add a plus '+' in the local name, everything after the first plus sign will be ignored. This allows certain emails to be filtered. Note that this rule does not apply to domain names.\n\n\tFor example, \"m.y+name@email.com\" will be forwarded to \"my@email.com\".\n\nIt is possible to use both of these rules at the same time.\nGiven an array of strings emails where we send one email to each emails[i], return the number of different addresses that actually receive mails.\n&nbsp;\nExample 1:\n\nInput: emails = [\"test.email+alex@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"]\nOutput: 2\nExplanation: \"testemail@leetcode.com\" and \"testemail@lee.tcode.com\" actually receive mails.\n\nExample 2:\n\nInput: emails = [\"a@leetcode.com\",\"b@leetcode.com\",\"c@leetcode.com\"]\nOutput: 3\n\n&nbsp;\nConstraints:\n\n\t1 <= emails.length <= 100\n\t1 <= emails[i].length <= 100\n\temails[i] consist of lowercase English letters, '+', '.' and '@'.\n\tEach emails[i] contains exactly one '@' character.\n\tAll local and domain names are non-empty.\n\tLocal names do not start with a '+' character.\n\tDomain names end with the \".com\" suffix.",
        "solutions": [
            {
                "id": 186798,
                "title": "java-python-3-7-and-6-liners-with-comment-and-analysis",
                "content": "```java\\n    public int numUniqueEmails(String[] emails) {\\n        Set<String> normalized = new HashSet<>(); // used to save simplified email address, cost O(n) sapce.\\n        for (String email : emails) {\\n            String[] parts = email.split(\"@\"); // split into local and domain parts.\\n            String[] local = parts[0].split(\"\\\\\\\\+\"); // split local by \\'+\\'.\\n            normalized.add(local[0].replace(\".\", \"\") + \"@\" + parts[1]); // remove all \\'.\\', and concatenate \\'@\\' and domain.        \\n        }\\n        return normalized.size();\\n    }\\n```\\n```python\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        seen = set()\\n        for email in emails:\\n            name, domain = email.split(\\'@\\') \\n            local = name.split(\\'+\\')[0].replace(\\'.\\', \\'\\')\\n            seen.add(local + \\'@\\' + domain)\\n        return len(seen)\\n```\\n**Analysis**\\nLet `n` be the total characters in the input array `emails`. The HashSet `normalized` and the for loop both cost `O(n)`, in terms of space and time, respectively. \\n\\n**Time & space: O(n).**\\n# --------------------\\n\\n**Q & A**\\n\\n**Q1**: What is Java metacharacter?\\n**A1**: A metacharacter \\u2014 a character with special meaning interpreted by the Java regular expression engine / matcher.\\nhttps://en.wikipedia.org/wiki/Metacharacter\\nhttps://docs.oracle.com/javase/tutorial/essential/regex/literals.html. \\n\\n**Q2**: Why does Java regular expression use `\\\\\\\\`, instead of `\\\\`, to escape metacharacter such as `+, ., *`, etc?\\n\\n**A2**: I guess the reason is that the backslash character is an escape character in Java String literals already. \\n\\n**Update:**\\n\\nCredit to @helengu1996 for her [link](https://stackoverflow.com/a/25145826/4150692):\\n\\n*\"There are two \"escapings\" going on here. The first backslash is to escape the second backslash for the Java language, to create an actual backslash character. The backslash character is what escapes the + or the s for interpretation by the regular expression engine. That\\'s why you need two backslashes -- one for Java, one for the regular expression engine. With only one backslash, Java reports \\\\s and \\\\+ as illegal escape characters -- not for regular expressions, but for an actual character in the Java language.\"*\\n\\n----\\n\\nSimilar solution:\\n\\n[1592. Rearrange Spaces Between Words](https://leetcode.com/problems/rearrange-spaces-between-words/discuss/855335/JavaPython-3-6-liners.)",
                "solutionTags": [],
                "code": "```java\\n    public int numUniqueEmails(String[] emails) {\\n        Set<String> normalized = new HashSet<>(); // used to save simplified email address, cost O(n) sapce.\\n        for (String email : emails) {\\n            String[] parts = email.split(\"@\"); // split into local and domain parts.\\n            String[] local = parts[0].split(\"\\\\\\\\+\"); // split local by \\'+\\'.\\n            normalized.add(local[0].replace(\".\", \"\") + \"@\" + parts[1]); // remove all \\'.\\', and concatenate \\'@\\' and domain.        \\n        }\\n        return normalized.size();\\n    }\\n```\n```python\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        seen = set()\\n        for email in emails:\\n            name, domain = email.split(\\'@\\') \\n            local = name.split(\\'+\\')[0].replace(\\'.\\', \\'\\')\\n            seen.add(local + \\'@\\' + domain)\\n        return len(seen)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 317207,
                "title": "c-concise-solution",
                "content": "For each email address in `emails`, clean up the local name, append the domain name, and add the cleaned up email to a set.\\n\\nReturn the size of the set.\\n \\n\\tint numUniqueEmails(vector<string>& emails) {\\n        unordered_set<string> st;\\n        for(string &email : emails) {\\n            string cleanEmail;\\n            for(char c : email) {\\n                if(c == \\'+\\' || c == \\'@\\') break;\\n                if(c == \\'.\\') continue;\\n                cleanEmail += c;\\n            }\\n            cleanEmail += email.substr(email.find(\\'@\\'));\\n            st.insert(cleanEmail);\\n        }\\n        return st.size();\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "For each email address in `emails`, clean up the local name, append the domain name, and add the cleaned up email to a set.\\n\\nReturn the size of the set.\\n \\n\\tint numUniqueEmails(vector<string>& emails) {\\n        unordered_set<string> st;\\n        for(string &email : emails) {\\n            string cleanEmail;\\n            for(char c : email) {\\n                if(c == \\'+\\' || c == \\'@\\') break;\\n                if(c == \\'.\\') continue;\\n                cleanEmail += c;\\n            }\\n            cleanEmail += email.substr(email.find(\\'@\\'));\\n            st.insert(cleanEmail);\\n        }\\n        return st.size();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 187527,
                "title": "python-solution",
                "content": "```\nclass Solution:\n    def numUniqueEmails(self, emails):\n        \"\"\"\n        :type emails: List[str]\n        :rtype: int\n        \"\"\"\n        email_set = set()\n        for email in emails:\n            local_name,domain_name = email.split(\"@\")\n            local_name =\"\".join(local_name.split('+')[0].split('.'))\n            email = local_name +'@' + domain_name\n            email_set.add(email)\n        return len(email_set)\n ```       ",
                "solutionTags": [],
                "code": "```\nclass Solution:\n    def numUniqueEmails(self, emails):\n        \"\"\"\n        :type emails: List[str]\n        :rtype: int\n        \"\"\"\n        email_set = set()\n        for email in emails:\n            local_name,domain_name = email.split(\"@\")\n            local_name =\"\".join(local_name.split('+')[0].split('.'))\n            email = local_name +'@' + domain_name\n            email_set.add(email)\n        return len(email_set)\n ```",
                "codeTag": "Java"
            },
            {
                "id": 198062,
                "title": "please-update-the-test-cases",
                "content": "Please add this or something similar to the test cases:\\n*[\"a@leetcode.com\",\"b@leetcode.com\",\"c@leetcode.com\"]*\\n\\nMany of the fastest accepted solutions look like this:\\n\\n```\\nSet<String> seen = new HashSet();\\n        for (String email: emails) {\\n            int i = email.indexOf(\\'@\\');\\n            String rest = email.substring(i);\\n            seen.add(rest);\\n        }\\n        return seen.size();\\n```\\n\\nThe fact that this is an accepted solution shows a gap in the test cases. E.g., the proposed test case fails with the above code even though the code is accepted.",
                "solutionTags": [],
                "code": "```\\nSet<String> seen = new HashSet();\\n        for (String email: emails) {\\n            int i = email.indexOf(\\'@\\');\\n            String rest = email.substring(i);\\n            seen.add(rest);\\n        }\\n        return seen.size();\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 195263,
                "title": "clean-java-beats-99-single-pass-without-split-replace-or-indexof",
                "content": "it seems best to just iterate once through each email string, since using String split() or replace() or indexOf() implicitly iterates through the email string at each usage.\\nAt each character:\\n1. If \\'.\\' is encountered: skip to check next character\\n2. If \\'+\\' is encountered: keep moving index to look for \\'@\\', then append rest of substring to StringBuilder; break\\n3. If \\'@\\' is encountered: append rest of substring to StringBuilder; break\\n4. For all other characters encountered, append to StringBuilder, then continue to check next character\\n5. Build email string and add to set\\n\\nThe set size is result.\\n```\\n    public int numUniqueEmails(String[] emails) {\\n      if (emails == null) {\\n        return 0;\\n      }\\n\\n      Set<String> addresses = new HashSet<>();\\n\\t  \\n      for (String email : emails) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < email.length(); i++) {\\n          char ch = email.charAt(i);\\n          switch (ch) {\\n            case \\'.\\':\\n              break;\\n            case \\'+\\':\\n              while (ch != \\'@\\') {\\n                ch = email.charAt(++i);\\n              }\\n              sb.append(email.substring(i));\\n              i = email.length();\\n              break;\\n            case \\'@\\':\\n              sb.append(email.substring(i));\\n              i = email.length();\\n            default:\\n              sb.append(ch);\\n          }\\n        }\\n        addresses.add(sb.toString());\\n      }\\n     \\n      return addresses.size();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int numUniqueEmails(String[] emails) {\\n      if (emails == null) {\\n        return 0;\\n      }\\n\\n      Set<String> addresses = new HashSet<>();\\n\\t  \\n      for (String email : emails) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < email.length(); i++) {\\n          char ch = email.charAt(i);\\n          switch (ch) {\\n            case \\'.\\':\\n              break;\\n            case \\'+\\':\\n              while (ch != \\'@\\') {\\n                ch = email.charAt(++i);\\n              }\\n              sb.append(email.substring(i));\\n              i = email.length();\\n              break;\\n            case \\'@\\':\\n              sb.append(email.substring(i));\\n              i = email.length();\\n            default:\\n              sb.append(ch);\\n          }\\n        }\\n        addresses.add(sb.toString());\\n      }\\n     \\n      return addresses.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 261959,
                "title": "easy-understanding-python-solution-44ms-faster-than-99-3",
                "content": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        def parse(email):\\n            local, domain = email.split(\\'@\\')\\n            local = local.split(\\'+\\')[0].replace(\\'.\\',\"\")\\n            return f\"{local}@{domain}\"\\n        \\n        return len(set(map(parse, emails)))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        def parse(email):\\n            local, domain = email.split(\\'@\\')\\n            local = local.split(\\'+\\')[0].replace(\\'.\\',\"\")\\n            return f\"{local}@{domain}\"\\n        \\n        return len(set(map(parse, emails)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 210025,
                "title": "javascript-1-line-solution-and-explanation",
                "content": "```\\nconst numUniqueEmails = emails => new Set(emails.map(mail => `${mail.split(\\'@\\')[0].replace(/\\\\+.*$|\\\\./g, \\'\\')}@${mail.split(\\'@\\')[1]}`)).size\\n```\\n\\n* Skills:\\n\\t1. ES6(arrow function, template literals)\\n\\t2. Set\\n\\t3. \\tString(split, replace)\\n\\t4. \\tRegular Expression\\n* Explanation:\\n\\tIn this piece of code, I took lots of times to recall **regex**, and it is the most unreadable part, so let me explain: \\n\\t```\\n\\t\\t/\\\\+.*$|\\\\./g\\n\\t```\\n\\t1. `+` is a specail char, so adds `\\\\`.\\n\\t2. `.*` means any character after `+`.\\n\\t3. `$`, in regex, it represents the end of string.\\n\\t4. `|` equals to `or`.\\n\\t5. `.` is also a special char, so adds `\\\\`.\\n\\t6. In the end of regex, `g`, global search, means finding all matches in input and replace them.\\n\\t7. In sum, replace the substring that after sign `+` or the char `.` with empty string.\\n\\nI\\'m a Taiwanese, this is my first try to share my solution and explanation, please feel free to leave comments if you have any better approach or idea :).",
                "solutionTags": [],
                "code": "```\\nconst numUniqueEmails = emails => new Set(emails.map(mail => `${mail.split(\\'@\\')[0].replace(/\\\\+.*$|\\\\./g, \\'\\')}@${mail.split(\\'@\\')[1]}`)).size\\n```\n```\\n\\t\\t/\\\\+.*$|\\\\./g\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1488812,
                "title": "python-short-solution-explained",
                "content": "What we need to do in this problem is carefully check cases and use functionality of strings in python.\\n1. First, split each `mail`, using `@` symbol.\\n2. Then, remove all `.` in local part of mail.\\n3. If we found `+` in string, remove all symbols after this symbol.\\n4. Finally, update `d[local + \"@\" + domain]`, increasing it by one.\\n5. In the end calculate number of unique clean emails.\\n\\n#### Complexity\\nIt is `O(m)` for time, where `m` is total length of all `emails`, space is potentially `O(m)` as well.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def numUniqueEmails(self, emails):\\n        d = Counter()\\n        for mail in emails:\\n            local, domain = mail.split(\"@\")\\n            local = local.replace(\".\", \"\")\\n            if \"+\" in local: local = local[:local.index(\"+\")]\\n            d[local + \"@\" + domain] += 1\\n            \\n        return len(d)\\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [
                    "String"
                ],
                "code": "```python\\nclass Solution:\\n    def numUniqueEmails(self, emails):\\n        d = Counter()\\n        for mail in emails:\\n            local, domain = mail.split(\"@\")\\n            local = local.replace(\".\", \"\")\\n            if \"+\" in local: local = local[:local.index(\"+\")]\\n            d[local + \"@\" + domain] += 1\\n            \\n        return len(d)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1489525,
                "title": "fastest-and-easiest-in-place-c-solution-using-stl",
                "content": "The code is pretty self-explanatory due to variable names.\\n```\\nint numUniqueEmails(vector<string>& emails)\\n    {\\n        for(auto& email:emails){\\n            auto at_location = find(email.begin(),email.end(),\\'@\\');\\n            auto end_after_removing_dots = remove(email.begin(),at_location,\\'.\\');\\n\\t\\t\\tauto plus_location = find(email.begin(),end_after_removing_dots,\\'+\\');\\n            email.erase(plus_location,at_location);\\n        }\\n        return unordered_set(emails.begin(),emails.end()).size();\\n    }\\n```\\nIf you have any doubts or suggestions, feel free to comment.\\nIf you found this solution useful, you know where the upvote is :)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint numUniqueEmails(vector<string>& emails)\\n    {\\n        for(auto& email:emails){\\n            auto at_location = find(email.begin(),email.end(),\\'@\\');\\n            auto end_after_removing_dots = remove(email.begin(),at_location,\\'.\\');\\n\\t\\t\\tauto plus_location = find(email.begin(),end_after_removing_dots,\\'+\\');\\n            email.erase(plus_location,at_location);\\n        }\\n        return unordered_set(emails.begin(),emails.end()).size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1488791,
                "title": "easy-simple-well-defined-code-for-beginners",
                "content": "\\'\\'\\'\\n\\n\\tclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        \\n        res = set()\\n        for email in emails:\\n            local,domain = email.split(\\'@\\')\\n            tmp = \"\"\\n            for c in local:\\n                if c==\".\": continue\\n                elif c==\"+\": break\\n                else: tmp+=c\\n            res.add(tmp+\"@\"+domain)\\n        \\n        return len(res)\\n\\n### **If you got the idea please Upvote !!!\\uD83E\\uDD1E**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\'\\'\\'\\n\\n\\tclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        \\n        res = set()\\n        for email in emails:\\n            local,domain = email.split(\\'@\\')\\n            tmp = \"\"\\n            for c in local:\\n                if c==\".\": continue\\n                elif c==\"+\": break\\n                else: tmp+=c\\n            res.add(tmp+\"@\"+domain)\\n        \\n        return len(res)\\n\\n### **If you got the idea please Upvote !!!\\uD83E\\uDD1E**",
                "codeTag": "Java"
            },
            {
                "id": 236993,
                "title": "python-solution-runtime-99-66-faster-memory-usage-100-lesser",
                "content": "```\\nclass Solution(object):\\n    def numUniqueEmails(self, emails):\\n        \"\"\"\\n        :type emails: List[str]\\n        :rtype: int\\n        \"\"\"\\n        actual = set()\\n        for email in  emails:\\n            x = email.split(\"@\")\\n            y = x[0].split(\"+\")\\n            z = y[0].replace(\".\", \"\")\\n            x = z + \"@\" + x[1]\\n            actual.add(x)\\n        return len(actual)\\n```",
                "solutionTags": [
                    "Array",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution(object):\\n    def numUniqueEmails(self, emails):\\n        \"\"\"\\n        :type emails: List[str]\\n        :rtype: int\\n        \"\"\"\\n        actual = set()\\n        for email in  emails:\\n            x = email.split(\"@\")\\n            y = x[0].split(\"+\")\\n            z = y[0].replace(\".\", \"\")\\n            x = z + \"@\" + x[1]\\n            actual.add(x)\\n        return len(actual)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 310272,
                "title": "clean-javascript-4-lines-solution-without-regex",
                "content": "```js\\nvar numUniqueEmails = function(emails) {\\n  return (new Set(emails.map(email => {\\n    const [local, domain] = email.split(\\'@\\');\\n    return local.split(\\'+\\').shift().split(\\'.\\').join(\\'\\') + \\'@\\' + domain;\\n  }))).size;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nvar numUniqueEmails = function(emails) {\\n  return (new Set(emails.map(email => {\\n    const [local, domain] = email.split(\\'@\\');\\n    return local.split(\\'+\\').shift().split(\\'.\\').join(\\'\\') + \\'@\\' + domain;\\n  }))).size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 474109,
                "title": "python-3-with-explanations",
                "content": "```Python 3\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n\\t\\t# Create set which may contain only unique values\\n\\t\\ts = set()\\n\\t\\t# For every entry in the list\\n        for e in emails:\\n\\t\\t\\t# If entry is not empty\\n            if len(e) > 0:\\n\\t\\t\\t\\t# Split entry into two parts - before and after @ sign\\n                a = e.split(\\'@\\')[0]\\n                b = e.split(\\'@\\')[1]\\n\\t\\t\\t\\t# If first part (local) contains + sign\\n                if \\'+\\' in a:\\n\\t\\t\\t\\t\\t# Split this part again into two parts - before and after + sign\\n\\t\\t\\t\\t\\t# and replace dots in the first part with nothing, i.e. remove them\\n\\t\\t\\t\\t\\t# then reconstruct mail address by adding @ and the second part\\n                    s.add(a.split(\\'+\\')[0].replace(\\'.\\', \\'\\') + \\'@\\' + b)\\n                else:\\n\\t\\t\\t\\t\\t# If there is no + sign in the first part, then only remove dots\\n\\t\\t\\t\\t\\t# and reconstruct mail address by adding @ and the second part\\n                    s.add(a.replace(\\'.\\', \\'\\') + \\'@\\' + b)\\n\\t\\t# Return length of our set, i.e. number of entries\\n        return len(s)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```Python 3\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n\\t\\t# Create set which may contain only unique values\\n\\t\\ts = set()\\n\\t\\t# For every entry in the list\\n        for e in emails:\\n\\t\\t\\t# If entry is not empty\\n            if len(e) > 0:\\n\\t\\t\\t\\t# Split entry into two parts - before and after @ sign\\n                a = e.split(\\'@\\')[0]\\n                b = e.split(\\'@\\')[1]\\n\\t\\t\\t\\t# If first part (local) contains + sign\\n                if \\'+\\' in a:\\n\\t\\t\\t\\t\\t# Split this part again into two parts - before and after + sign\\n\\t\\t\\t\\t\\t# and replace dots in the first part with nothing, i.e. remove them\\n\\t\\t\\t\\t\\t# then reconstruct mail address by adding @ and the second part\\n                    s.add(a.split(\\'+\\')[0].replace(\\'.\\', \\'\\') + \\'@\\' + b)\\n                else:\\n\\t\\t\\t\\t\\t# If there is no + sign in the first part, then only remove dots\\n\\t\\t\\t\\t\\t# and reconstruct mail address by adding @ and the second part\\n                    s.add(a.replace(\\'.\\', \\'\\') + \\'@\\' + b)\\n\\t\\t# Return length of our set, i.e. number of entries\\n        return len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186655,
                "title": "a-few-solutions",
                "content": "Erase `\\'.\\'` chars and all chars following `\\'+\\'` inclusive from the user-part, then concatenate the user/domain-parts into a `unique` set.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun numUniqueEmails(A: Array<String>): Int {\\n        var unique = mutableSetOf<String>()\\n        for (email in A) {\\n            var (user, domain) = email.split(\"@\")\\n            user = user.split(\"\").filter{ it != \".\" }.joinToString(\"\")\\n            var i = user.indexOf(\\'+\\')\\n            if (-1 < i)\\n                user = user.substring(0, i)\\n            unique.add(\"$user@$domain\")\\n        }\\n        return unique.size\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet numUniqueEmails = (A, unique = new Set()) => {\\n    for (let email of A) {\\n        let [user, domain] = email.split(\\'@\\');\\n        user = user.split(\\'\\').filter(c => c != \\'.\\').join(\\'\\');\\n        let i = user.indexOf(\\'+\\');\\n        if (-1 < i)\\n            user = user.substring(0, i);\\n        unique.add(`${user}@${domain}`);\\n    }\\n    return unique.size;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def numUniqueEmails(self, A: List[str]) -> int:\\n        unique = set()\\n        for email in A:\\n            user, domain = email.split(\\'@\\')\\n            user = user.replace(\\'.\\', \\'\\')\\n            i = user.find(\\'+\\')\\n            if -1 < i:\\n                user = user[0 : i]\\n            unique.add(f\\'{user}@{domain}\\')\\n        return len(unique)\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using Set = unordered_set<string>;\\n    int numUniqueEmails(VS& A, Set unique = {}) {\\n        for (auto& email: A) {\\n            auto pivot = email.find(\\'@\\');\\n            auto user = email.substr(0, pivot),\\n                 domain = email.substr(pivot + 1);\\n            user.erase(remove_if(user.begin(), user.end(), [](auto c) { return c == \\'.\\'; }), user.end());\\n            auto i = user.find(\\'+\\');\\n            if (i != string::npos)\\n                user = user.substr(0, i);\\n            unique.insert(user + \\'@\\' + domain);\\n        }\\n        return unique.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun numUniqueEmails(A: Array<String>): Int {\\n        var unique = mutableSetOf<String>()\\n        for (email in A) {\\n            var (user, domain) = email.split(\"@\")\\n            user = user.split(\"\").filter{ it != \".\" }.joinToString(\"\")\\n            var i = user.indexOf(\\'+\\')\\n            if (-1 < i)\\n                user = user.substring(0, i)\\n            unique.add(\"$user@$domain\")\\n        }\\n        return unique.size\\n    }\\n}\\n```\n```\\nlet numUniqueEmails = (A, unique = new Set()) => {\\n    for (let email of A) {\\n        let [user, domain] = email.split(\\'@\\');\\n        user = user.split(\\'\\').filter(c => c != \\'.\\').join(\\'\\');\\n        let i = user.indexOf(\\'+\\');\\n        if (-1 < i)\\n            user = user.substring(0, i);\\n        unique.add(`${user}@${domain}`);\\n    }\\n    return unique.size;\\n};\\n```\n```\\nclass Solution:\\n    def numUniqueEmails(self, A: List[str]) -> int:\\n        unique = set()\\n        for email in A:\\n            user, domain = email.split(\\'@\\')\\n            user = user.replace(\\'.\\', \\'\\')\\n            i = user.find(\\'+\\')\\n            if -1 < i:\\n                user = user[0 : i]\\n            unique.add(f\\'{user}@{domain}\\')\\n        return len(unique)\\n```\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using Set = unordered_set<string>;\\n    int numUniqueEmails(VS& A, Set unique = {}) {\\n        for (auto& email: A) {\\n            auto pivot = email.find(\\'@\\');\\n            auto user = email.substr(0, pivot),\\n                 domain = email.substr(pivot + 1);\\n            user.erase(remove_if(user.begin(), user.end(), [](auto c) { return c == \\'.\\'; }), user.end());\\n            auto i = user.find(\\'+\\');\\n            if (i != string::npos)\\n                user = user.substr(0, i);\\n            unique.insert(user + \\'@\\' + domain);\\n        }\\n        return unique.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 841942,
                "title": "2-approaches-set-easy-understanding",
                "content": "```\\n//1.\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        set<string> s;\\n        for(auto email:emails){\\n            int i=email.find(\\'@\\');\\n            string temp=email.substr(0,i);\\n            string last=email.substr(i);\\n            if(temp.find(\\'+\\')){\\n                temp=temp.substr(0,temp.find(\\'+\\'));\\n            }\\n            temp.erase(remove(temp.begin(), temp.end(), \\'.\\'), temp.end());\\n            s.insert(temp+last);\\n        }\\n        return s.size();\\n    }\\n};\\n//2.\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n    set<string> s;\\n    for(string &email : emails) {\\n        string cleanEmail;\\n        for(char c : email) {\\n            if(c == \\'+\\' || c == \\'@\\') break;\\n            if(c == \\'.\\') continue;\\n            cleanEmail += c;\\n        }\\n        cleanEmail += email.substr(email.find(\\'@\\'));\\n        s.insert(cleanEmail);\\n    }\\n    return s.size();\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\n//1.\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        set<string> s;\\n        for(auto email:emails){\\n            int i=email.find(\\'@\\');\\n            string temp=email.substr(0,i);\\n            string last=email.substr(i);\\n            if(temp.find(\\'+\\')){\\n                temp=temp.substr(0,temp.find(\\'+\\'));\\n            }\\n            temp.erase(remove(temp.begin(), temp.end(), \\'.\\'), temp.end());\\n            s.insert(temp+last);\\n        }\\n        return s.size();\\n    }\\n};\\n//2.\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n    set<string> s;\\n    for(string &email : emails) {\\n        string cleanEmail;\\n        for(char c : email) {\\n            if(c == \\'+\\' || c == \\'@\\') break;\\n            if(c == \\'.\\') continue;\\n            cleanEmail += c;\\n        }\\n        cleanEmail += email.substr(email.find(\\'@\\'));\\n        s.insert(cleanEmail);\\n    }\\n    return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488854,
                "title": "python-just-split-then-hashset-clean-concise",
                "content": "```python\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        def normalize(localName):\\n            parts = localName.split(\"+\")\\n            return parts[0].replace(\".\", \"\")\\n        \\n        uniqueEmails = set()\\n        for email in emails:\\n            localName, domainName = email.split(\"@\")\\n            uniqueEmails.add(normalize(localName) + \"@\" + domainName)\\n            \\n        return len(uniqueEmails)\\n```\\nComplexity:\\n- Time: `O(N * M)`, where `N <= 100` is number of `emails`, `M <= 100` is length of each email.\\n- Space: `O(N * M)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        def normalize(localName):\\n            parts = localName.split(\"+\")\\n            return parts[0].replace(\".\", \"\")\\n        \\n        uniqueEmails = set()\\n        for email in emails:\\n            localName, domainName = email.split(\"@\")\\n            uniqueEmails.add(normalize(localName) + \"@\" + domainName)\\n            \\n        return len(uniqueEmails)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2510279,
                "title": "my-java-solution",
                "content": "```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        Set<String> set = new HashSet();\\n        int count=0;\\n        for(String email: emails){\\n            int atIndex = email.indexOf(\"@\");\\n            int plusIndex= email.indexOf(\"+\");\\n            String str1 = \"\";\\n            if(plusIndex>=0) str1 = email.substring(0,plusIndex);\\n            else str1 = email.substring(0,atIndex);\\n            str1 = str1.replace(\".\",\"\") + email.substring(atIndex);\\n            if(set.add(str1)) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        Set<String> set = new HashSet();\\n        int count=0;\\n        for(String email: emails){\\n            int atIndex = email.indexOf(\"@\");\\n            int plusIndex= email.indexOf(\"+\");\\n            String str1 = \"\";\\n            if(plusIndex>=0) str1 = email.substring(0,plusIndex);\\n            else str1 = email.substring(0,atIndex);\\n            str1 = str1.replace(\".\",\"\") + email.substring(atIndex);\\n            if(set.add(str1)) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 187215,
                "title": "java-beat-100",
                "content": "```\nclass Solution {\n    public int numUniqueEmails(String[] emails) {\n        Set<String> set = new HashSet<>();\n        for(String email : emails) {\n            StringBuilder sb = new StringBuilder();\n            for(char c: email.toCharArray()) {\n                if (c == '.') continue;\n                if (c == '+') break;\n                sb.append(c);\n            }\n            String cur = sb.toString() + email.substring(email.indexOf('@'));\n            set.add(cur);\n        }\n        return set.size();\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    public int numUniqueEmails(String[] emails) {\n        Set<String> set = new HashSet<>();\n        for(String email : emails) {\n            StringBuilder sb = new StringBuilder();\n            for(char c: email.toCharArray()) {\n                if (c == '.') continue;\n                if (c == '+') break;\n                sb.append(c);\n            }\n            String cur = sb.toString() + email.substring(email.indexOf('@'));\n            set.add(cur);\n        }\n        return set.size();\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777703,
                "title": "python-split-then-replace-with-detailed-comments",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs trivial string operations. Time complexity is linear: **O(N)**. Space complexity is linear: **O(N)**.\\n\\n```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        unique = set()\\n        for e in emails:\\n            loc, dom = e.split(\"@\")                                 # get parts of email\\n            fwd = loc.split(\"+\")[0].replace(\".\", \"\") + \"@\" + dom    # build forward email\\n            unique.add(fwd)\\n        return len(unique)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        unique = set()\\n        for e in emails:\\n            loc, dom = e.split(\"@\")                                 # get parts of email\\n            fwd = loc.split(\"+\")[0].replace(\".\", \"\") + \"@\" + dom    # build forward email\\n            unique.add(fwd)\\n        return len(unique)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488901,
                "title": "easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        set<string> s;\\n        for(auto e : emails)\\n        {\\n            string mail=\"\";\\n            for(char c : e)\\n            {\\n                if(c==\\'+\\' || c==\\'@\\')\\n                    break;\\n                if(c==\\'.\\')\\n                    continue;\\n                mail+=c;\\n            }\\n            mail+=e.substr(e.find(\\'@\\'));\\n            s.insert(mail);\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        set<string> s;\\n        for(auto e : emails)\\n        {\\n            string mail=\"\";\\n            for(char c : e)\\n            {\\n                if(c==\\'+\\' || c==\\'@\\')\\n                    break;\\n                if(c==\\'.\\')\\n                    continue;\\n                mail+=c;\\n            }\\n            mail+=e.substr(e.find(\\'@\\'));\\n            s.insert(mail);\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 534125,
                "title": "javascript-4-lines-2-solutions",
                "content": "1. Add all of filtered email addresses in to the Set\\n2. Return a size of the Set.\\n- Time Complexity: O(N)\\n- Space Complexity: O(N)\\n```JavaScript\\n/**\\n * @param {string[]} emails\\n * @return {number}\\n */\\nvar numUniqueEmails = emails => new Set(emails.map(a => {\\n    const [local, domain] = a.split(\\'@\\');\\n    return `${local.split(\\'+\\')[0].split(\\'.\\').join(\\'\\')}@${domain}`;\\n})).size;\\n```\\n\\nUsing regex\\n```JavaScript\\n/**\\n * @param {string[]} emails\\n * @return {number}\\n */\\nvar numUniqueEmails = emails => new Set(emails.map(a => {\\n    const [local, domain] = a.split(\\'@\\');\\n    return `${local.replace(/\\\\+.*/, \\'\\').replace(/\\\\./g, \\'\\')}@${domain}`;\\n})).size;\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```JavaScript\\n/**\\n * @param {string[]} emails\\n * @return {number}\\n */\\nvar numUniqueEmails = emails => new Set(emails.map(a => {\\n    const [local, domain] = a.split(\\'@\\');\\n    return `${local.split(\\'+\\')[0].split(\\'.\\').join(\\'\\')}@${domain}`;\\n})).size;\\n```\n```JavaScript\\n/**\\n * @param {string[]} emails\\n * @return {number}\\n */\\nvar numUniqueEmails = emails => new Set(emails.map(a => {\\n    const [local, domain] = a.split(\\'@\\');\\n    return `${local.replace(/\\\\+.*/, \\'\\').replace(/\\\\./g, \\'\\')}@${domain}`;\\n})).size;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 217094,
                "title": "javascript-no-split-slice-or-regex",
                "content": "```\\nlet trim = (email) => {\\n  let trimmed = \"\";\\n  let ignore = false;\\n  let domain = false;\\n\\n  for (let i = 0; i < email.length; i++) {\\n    if (email[i] === \\'@\\') domain = true;\\n    if (email[i] === \\'+\\') ignore = true;\\n    if (!ignore && email[i] !== \\'.\\' || domain) trimmed += email[i];\\n  }\\n  return trimmed;\\n}\\n\\nlet numUniqueEmails = (emails) => {\\n  return new Set(emails.map(email => trim(email))).size;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nlet trim = (email) => {\\n  let trimmed = \"\";\\n  let ignore = false;\\n  let domain = false;\\n\\n  for (let i = 0; i < email.length; i++) {\\n    if (email[i] === \\'@\\') domain = true;\\n    if (email[i] === \\'+\\') ignore = true;\\n    if (!ignore && email[i] !== \\'.\\' || domain) trimmed += email[i];\\n  }\\n  return trimmed;\\n}\\n\\nlet numUniqueEmails = (emails) => {\\n  return new Set(emails.map(email => trim(email))).size;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 379182,
                "title": "easy-c-solution-24ms-faster-than-97",
                "content": "Runtime: 24 ms, faster than 97.76% of C++ online submissions for Unique Email Addresses.\\nMemory Usage: 14 MB, less than 26.19% of C++ online submissions for Unique Email Addresses.\\n\\n```\\nint numUniqueEmails(vector<string>& emails) {\\n        \\n        unordered_set<string> s;\\n        for(string email : emails)\\n        {\\n            string localName = email.substr(0,email.find_first_of(\\'@\\'));\\n            string domain = email.substr(email.find_first_of(\\'@\\'));\\n            \\n            if(localName.find(\\'+\\') != string::npos)\\n                localName.erase(localName.find_first_of(\\'+\\'));\\n            \\n            localName.erase(remove(localName.begin(), localName.end(), \\'.\\'), localName.end());\\n            s.insert(localName+domain);\\n        }\\n        \\n        return s.size();\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "Runtime: 24 ms, faster than 97.76% of C++ online submissions for Unique Email Addresses.\\nMemory Usage: 14 MB, less than 26.19% of C++ online submissions for Unique Email Addresses.\\n\\n```\\nint numUniqueEmails(vector<string>& emails) {\\n        \\n        unordered_set<string> s;\\n        for(string email : emails)\\n        {\\n            string localName = email.substr(0,email.find_first_of(\\'@\\'));\\n            string domain = email.substr(email.find_first_of(\\'@\\'));\\n            \\n            if(localName.find(\\'+\\') != string::npos)\\n                localName.erase(localName.find_first_of(\\'+\\'));\\n            \\n            localName.erase(remove(localName.begin(), localName.end(), \\'.\\'), localName.end());\\n            s.insert(localName+domain);\\n        }\\n        \\n        return s.size();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 199801,
                "title": "javascript-one-liner-two-solutions-76ms-88ms",
                "content": "the one with Regexp, 76ms\\n```\\nreturn new Set(emails.map(email => `${/(.*?)\\\\+/.exec(email.split(\\'@\\')[0].replace(/\\\\./g,\\'\\'))[1]}@${email.split(\\'@\\')[1]}`)).size\\n```\\nanother, 88ms\\n```\\nreturn new Set(emails.map(email => `${email.split(\\'@\\')[0].split(\\'+\\')[0].split(\\'.\\').join(\\'\\')}@${email.split(\\'@\\')[1]}`)).size\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nreturn new Set(emails.map(email => `${/(.*?)\\\\+/.exec(email.split(\\'@\\')[0].replace(/\\\\./g,\\'\\'))[1]}@${email.split(\\'@\\')[1]}`)).size\\n```\n```\\nreturn new Set(emails.map(email => `${email.split(\\'@\\')[0].split(\\'+\\')[0].split(\\'.\\').join(\\'\\')}@${email.split(\\'@\\')[1]}`)).size\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1258774,
                "title": "easy-java-solution",
                "content": "class Solution {\\n    Set<String> set=new HashSet<>();\\n    public int numUniqueEmails(String[] emails) {\\n        \\n        for(String s: emails)\\n        {\\n            String d[]=s.split(\"@\");\\n            StringBuilder ans=new StringBuilder(\"\");\\n            for(int i=0;i<d[0].length();i++)\\n            {\\n                \\n                if(d[0].charAt(i)==\\'+\\')\\n                    break;\\n                if(d[0].charAt(i)!=\\'.\\')\\n                ans=ans.append(d[0].charAt(i));       \\n            }\\n            // System.out.println(ans+\"@\"+d[1]);\\n                ans.append(\"@\");\\n                ans.append(d[1]);\\n            set.add(ans.toString());\\n        }\\n        return set.size(); \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String",
                    "Ordered Set"
                ],
                "code": "class Solution {\\n    Set<String> set=new HashSet<>();\\n    public int numUniqueEmails(String[] emails) {\\n        \\n        for(String s: emails)\\n        {\\n            String d[]=s.split(\"@\");\\n            StringBuilder ans=new StringBuilder(\"\");\\n            for(int i=0;i<d[0].length();i++)\\n            {\\n                \\n                if(d[0].charAt(i)==\\'+\\')\\n                    break;\\n                if(d[0].charAt(i)!=\\'.\\')\\n                ans=ans.append(d[0].charAt(i));       \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 204817,
                "title": "weak-test-cases",
                "content": "The below solution gives 100% result\\nbut will fail for many cases like\\n{\"test.emailalex@leetcode.com\",\"test.e.mailbob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"}\\nExpected output : 3\\nOutput : 2\\n```\\n    public int numUniqueEmails(String[] emails) {\\n        Set<String> seen = new HashSet();\\n        for (String email: emails) {\\n            int i = email.indexOf(\\'@\\');\\n            String rest = email.substring(i);\\n            seen.add(rest);\\n        }\\n        return seen.size();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int numUniqueEmails(String[] emails) {\\n        Set<String> seen = new HashSet();\\n        for (String email: emails) {\\n            int i = email.indexOf(\\'@\\');\\n            String rest = email.substring(i);\\n            seen.add(rest);\\n        }\\n        return seen.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 189057,
                "title": "c-solution-8ms-100",
                "content": "```\\nint numUniqueEmails(char** emails, int emailsSize) {\\n    char unique[100][100] = {0};\\n    char email[100] = {0};\\n    int uniquesize = 0;\\n    int j;\\n    int k;\\n    int keepon;\\n    int found;\\n\\n    for (int i = 0; i < emailsSize; i++){\\n        keepon = 1;\\n        j = 0;\\n        k = 0;\\n        found = 0;\\n        while (emails[i][j] != \\'@\\'){\\n            if (emails[i][j] == \\'+\\')\\n                keepon = 0;\\n            else if (keepon && emails[i][j] != \\'.\\')\\n                email[k++] = emails[i][j];\\n            j++;\\n        }\\n        while (emails[i][j])\\n            email[k++] = emails[i][j++];\\n        email[k] = 0;\\n        for (int u = 0; u < uniquesize && !found; u++)\\n            if (strcmp(unique[u], email) == 0)\\n                found = 1;\\n        if (!found)\\n            strcpy(unique[uniquesize++], email);\\n    }\\n    return uniquesize;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint numUniqueEmails(char** emails, int emailsSize) {\\n    char unique[100][100] = {0};\\n    char email[100] = {0};\\n    int uniquesize = 0;\\n    int j;\\n    int k;\\n    int keepon;\\n    int found;\\n\\n    for (int i = 0; i < emailsSize; i++){\\n        keepon = 1;\\n        j = 0;\\n        k = 0;\\n        found = 0;\\n        while (emails[i][j] != \\'@\\'){\\n            if (emails[i][j] == \\'+\\')\\n                keepon = 0;\\n            else if (keepon && emails[i][j] != \\'.\\')\\n                email[k++] = emails[i][j];\\n            j++;\\n        }\\n        while (emails[i][j])\\n            email[k++] = emails[i][j++];\\n        email[k] = 0;\\n        for (int u = 0; u < uniquesize && !found; u++)\\n            if (strcmp(unique[u], email) == 0)\\n                found = 1;\\n        if (!found)\\n            strcpy(unique[uniquesize++], email);\\n    }\\n    return uniquesize;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3261011,
                "title": "90-beatable-js-sol-explained-with-approach",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe algorithm uses a **Set** to store *unique email addresses* and then iterates through the *array of email addresses*.\\n\\n- For each email address, it performs the following steps:\\n\\n1. Split the email address into local and domain parts using the **\"@\"** symbol.\\n\\n2. Remove any dots **(\".\")** from the local part of the email address.\\n\\n3. Find the index of the first **\"+\"** symbol in the local part of the email address, if it exists.\\n\\n4. If a **\"+\"** symbol is found, remove all characters after it in the local part.\\n\\n5. Add the modified email address **(local@domain)** to the **Set**.\\n\\n6. Finally, the algorithm returns the size of the **Set**, which represents the **number of unique email addresses**.\\n\\n- The approach works because it effectively removes any characters in the local part of the email address that do not affect its uniqueness. \\n\\n- By doing this, it ensures that each unique email address is only added to the *Set* once, even if it appears in the input array multiple times with different variations.\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n1. Here **n** is the number of email addresses and **m** is the length of the longest email address. \\n\\n2. This is because the algorithm loops through each email address and performs operations that take O(m) time (e.g. splitting the email address into local and domain parts, replacing dots, etc.). \\n\\n3. The set operation to add an email address to the set has an amortized time complexity of O(1).\\n\\n\\n\\n\\n- Space complexity: $$O(n*m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n1. This is because the set used to store unique email addresses can potentially store up to n unique email addresses, each with a maximum length of m.\\n\\n2. Additionally, the local and domain variables created during each iteration also have a maximum length of m. \\n\\n3. Therefore, the total space used by this algorithm is proportional to **nm**.\\n\\n\\n\\n\\n\\n\\n\\n# Code\\n```\\n/**\\n * @param {string[]} emails\\n * @return {number}\\n */\\n \\nvar numUniqueEmails = function(emails) {\\n    \\n    let uniqueEmails = new Set();  // to store unique email addresses\\n    \\n    for (let email of emails) {\\n        \\n        let [local, domain] = email.split(\\'@\\');  // split local and domain parts\\n\\n        local = local.replace(/\\\\./g, \\'\\');  // remove dots from local part\\n\\n        let plusIndex = local.indexOf(\\'+\\');  // find index of plus sign\\n\\n            if (plusIndex !== -1) {\\n                \\n                local = local.substring(0, plusIndex); // remove everything after plus sign\\n            }\\n            \\n            uniqueEmails.add(local + \\'@\\' + domain); // add modified email to set\\n    }\\n    \\n    return uniqueEmails.size; // return number of unique email addresses\\n  \\n};\\n```\\n\\n![cat img for upvote on LC.jpeg](https://assets.leetcode.com/users/images/242bd8b8-8a1a-4bd6-b87f-9d290d6548ab_1678033187.7374706.jpeg)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\n/**\\n * @param {string[]} emails\\n * @return {number}\\n */\\n \\nvar numUniqueEmails = function(emails) {\\n    \\n    let uniqueEmails = new Set();  // to store unique email addresses\\n    \\n    for (let email of emails) {\\n        \\n        let [local, domain] = email.split(\\'@\\');  // split local and domain parts\\n\\n        local = local.replace(/\\\\./g, \\'\\');  // remove dots from local part\\n\\n        let plusIndex = local.indexOf(\\'+\\');  // find index of plus sign\\n\\n            if (plusIndex !== -1) {\\n                \\n                local = local.substring(0, plusIndex); // remove everything after plus sign\\n            }\\n            \\n            uniqueEmails.add(local + \\'@\\' + domain); // add modified email to set\\n    }\\n    \\n    return uniqueEmails.size; // return number of unique email addresses\\n  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 749161,
                "title": "c-easiest-and-simplest",
                "content": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        set<string> ans;\\n        for(string email : emails)\\n        {\\n            string temp = \"\";\\n            int i;\\n            for(i=0; email[i] != \\'@\\'; i++)\\n            {\\n                if(email[i] == \\'.\\')\\n                    continue;\\n                else if(email[i] == \\'+\\')\\n                    break;\\n                else\\n                    temp += email[i];\\n            }\\n            i = email.find(\\'@\\');\\n            temp += email.substr(i, email.length()-i);\\n            ans.insert(temp);\\n        }\\n        return ans.size();\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        set<string> ans;\\n        for(string email : emails)\\n        {\\n            string temp = \"\";\\n            int i;\\n            for(i=0; email[i] != \\'@\\'; i++)\\n            {\\n                if(email[i] == \\'.\\')\\n                    continue;\\n                else if(email[i] == \\'+\\')\\n                    break;\\n                else\\n                    temp += email[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 568641,
                "title": "javascript-solution",
                "content": "```\\nvar numUniqueEmails = function(emails) {\\n    const set = new Set()\\n    \\n    for (let email of emails) {\\n        const address = normalizeEmail(email)\\n        set.add(address)\\n    }\\n    \\n    return set.size\\n};\\n\\nfunction normalizeEmail(email) {\\n    let [local, domain] = email.split(\"@\");\\n    local = local.replace(/(\\\\.)|(\\\\+.*)/g, \"\")\\n    return local + \"@\" + domain\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numUniqueEmails = function(emails) {\\n    const set = new Set()\\n    \\n    for (let email of emails) {\\n        const address = normalizeEmail(email)\\n        set.add(address)\\n    }\\n    \\n    return set.size\\n};\\n\\nfunction normalizeEmail(email) {\\n    let [local, domain] = email.split(\"@\");\\n    local = local.replace(/(\\\\.)|(\\\\+.*)/g, \"\")\\n    return local + \"@\" + domain\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 461836,
                "title": "c-single-line",
                "content": "* For each string\\n  * Split by \\'@\\'\\n  * Remove all after the first \\'+\\' in the local name\\n  * Remove all dots in the local name\\n  * Concat the results back together to 1 string\\n* Return the distinct elements\\n```csharp\\npublic int NumUniqueEmails(string[] emails) \\n\\t=> emails.Select(x => x.Split(\\'@\\')).Select(split => split[0].Split(\\'+\\')[0].Replace(\".\", \"\") + \"@\" + split[1]).Distinct().Count();\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int NumUniqueEmails(string[] emails) \\n\\t=> emails.Select(x => x.Split(\\'@\\')).Select(split => split[0].Split(\\'+\\')[0].Replace(\".\", \"\") + \"@\" + split[1]).Distinct().Count();\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 242996,
                "title": "c-accepted-solution-beats-100-c",
                "content": "```\\npublic int NumUniqueEmails(string[] emails)\\n{\\n\\tHashSet<string> uEmails = new HashSet<string>();\\n\\tforeach (var email in emails)\\n\\t{\\n\\t\\tvar emailArr  = email.Split(\\'@\\');\\n\\t\\tstring emailId = emailArr[0];\\n\\t\\tif(emailId.IndexOf(\\'+\\')!=-1)\\n\\t\\t{\\n\\t\\t\\temailId = emailId.Substring(0, emailId.IndexOf(\\'+\\'));\\n\\t\\t}\\n\\t\\tuEmails.Add($\"{emailId.Replace(\".\", \"\")}@{emailArr[1]}\");\\n\\t}\\n\\treturn uEmails.Count();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int NumUniqueEmails(string[] emails)\\n{\\n\\tHashSet<string> uEmails = new HashSet<string>();\\n\\tforeach (var email in emails)\\n\\t{\\n\\t\\tvar emailArr  = email.Split(\\'@\\');\\n\\t\\tstring emailId = emailArr[0];\\n\\t\\tif(emailId.IndexOf(\\'+\\')!=-1)\\n\\t\\t{\\n\\t\\t\\temailId = emailId.Substring(0, emailId.IndexOf(\\'+\\'));\\n\\t\\t}\\n\\t\\tuEmails.Add($\"{emailId.Replace(\".\", \"\")}@{emailArr[1]}\");\\n\\t}\\n\\treturn uEmails.Count();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1489706,
                "title": "a-collection-of-1-line-solutions-in-different-languages",
                "content": "**C#**\\n```\\npublic class Solution {\\n    public int NumUniqueEmails(string[] emails) =>\\n        emails.Select(email => email.Substring(0, System.Text.RegularExpressions.Regex.Match(email, \"[+@]\").Index).Replace(\".\", \"\") + email.Substring(email.IndexOf(\\'@\\'))).Distinct().Count();\\n}\\n```\\n**JavaScript**\\n```\\n/**\\n * @param {string[]} emails\\n * @return {number}\\n */\\nfunction numUniqueEmails(emails) {\\n    return new Set(emails.map(email => email.substr(0, email.search(/[+@]/)).replaceAll(\\'.\\', \\'\\') + email.substr(email.search(\\'@\\')))).size\\n}\\n```\\n**Python**\\n```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        return len(set(map(lambda email: email[:re.search(r\\'[+@]\\', email).start()].replace(\\'.\\', \\'\\') + email[email.find(\\'@\\'):], emails)))\\n```\\n**Ruby**\\n```\\n# @param {String[]} emails\\n# @return {Integer}\\ndef num_unique_emails(emails)\\n    emails.map{|email| email[0, email.index(/[+@]/)].gsub(\\'.\\', \\'\\') + email[email.index(\\'@\\')..]}.uniq.size\\nend\\n```\\n**Scala**\\n```\\nobject Solution {\\n    def numUniqueEmails(emails: Array[String]): Int =\\n        emails.map(email => email.substring(0, \"[+@]\".r.findFirstMatchIn(email).map(_.start).get).replace(\".\", \"\") + email.substring(email.indexOf(\"@\"))).distinct.length\\n}\\n```\\n**TypeScript**\\n```\\nfunction numUniqueEmails(emails: string[]): number {\\n    return new Set(emails.map(email => email.substr(0, email.search(/[+@]/)).replace(/\\\\.+/g, \\'\\') + email.substr(email.search(\\'@\\')))).size\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "JavaScript",
                    "Ruby",
                    "Scala",
                    "TypeScript"
                ],
                "code": "```\\npublic class Solution {\\n    public int NumUniqueEmails(string[] emails) =>\\n        emails.Select(email => email.Substring(0, System.Text.RegularExpressions.Regex.Match(email, \"[+@]\").Index).Replace(\".\", \"\") + email.Substring(email.IndexOf(\\'@\\'))).Distinct().Count();\\n}\\n```\n```\\n/**\\n * @param {string[]} emails\\n * @return {number}\\n */\\nfunction numUniqueEmails(emails) {\\n    return new Set(emails.map(email => email.substr(0, email.search(/[+@]/)).replaceAll(\\'.\\', \\'\\') + email.substr(email.search(\\'@\\')))).size\\n}\\n```\n```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        return len(set(map(lambda email: email[:re.search(r\\'[+@]\\', email).start()].replace(\\'.\\', \\'\\') + email[email.find(\\'@\\'):], emails)))\\n```\n```\\n# @param {String[]} emails\\n# @return {Integer}\\ndef num_unique_emails(emails)\\n    emails.map{|email| email[0, email.index(/[+@]/)].gsub(\\'.\\', \\'\\') + email[email.index(\\'@\\')..]}.uniq.size\\nend\\n```\n```\\nobject Solution {\\n    def numUniqueEmails(emails: Array[String]): Int =\\n        emails.map(email => email.substring(0, \"[+@]\".r.findFirstMatchIn(email).map(_.start).get).replace(\".\", \"\") + email.substring(email.indexOf(\"@\"))).distinct.length\\n}\\n```\n```\\nfunction numUniqueEmails(emails: string[]): number {\\n    return new Set(emails.map(email => email.substr(0, email.search(/[+@]/)).replace(/\\\\.+/g, \\'\\') + email.substr(email.search(\\'@\\')))).size\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 941657,
                "title": "rust-functional",
                "content": "```rust\\nuse std::collections::HashSet;\\n\\nfn clean_email(email: String) -> String {\\n    let v: Vec<&str> = email.split(\\'@\\').collect();\\n    \\n    let left = v[0]\\n        .chars()\\n        .take_while(|&c| c != \\'+\\')\\n        .filter(|&c| c != \\'.\\')\\n        .collect::<String>();\\n    [&left, v[1]].join(\"@\")\\n}\\n\\nimpl Solution {\\n    pub fn num_unique_emails(emails: Vec<String>) -> i32 {\\n        emails\\n            .into_iter()\\n            .map(clean_email)\\n            .collect::<HashSet<_>>()\\n            .len() as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::collections::HashSet;\\n\\nfn clean_email(email: String) -> String {\\n    let v: Vec<&str> = email.split(\\'@\\').collect();\\n    \\n    let left = v[0]\\n        .chars()\\n        .take_while(|&c| c != \\'+\\')\\n        .filter(|&c| c != \\'.\\')\\n        .collect::<String>();\\n    [&left, v[1]].join(\"@\")\\n}\\n\\nimpl Solution {\\n    pub fn num_unique_emails(emails: Vec<String>) -> i32 {\\n        emails\\n            .into_iter()\\n            .map(clean_email)\\n            .collect::<HashSet<_>>()\\n            .len() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 804556,
                "title": "java-simple-solution",
                "content": "```\\npublic int numUniqueEmails(String[] emails) {\\n\\tSet<String> set = new HashSet<>();\\n\\tfor(String addr : emails) {\\n\\t\\tString[] parts = addr.split(\"@\");\\n\\t\\tparts[0] = parts[0].replaceAll(\"\\\\\\\\.\", \"\");\\n\\t\\tset.add(parts[0].split(\"\\\\\\\\+\")[0]+\"@\"+parts[1]);\\n\\t}\\n\\treturn set.size();\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int numUniqueEmails(String[] emails) {\\n\\tSet<String> set = new HashSet<>();\\n\\tfor(String addr : emails) {\\n\\t\\tString[] parts = addr.split(\"@\");\\n\\t\\tparts[0] = parts[0].replaceAll(\"\\\\\\\\.\", \"\");\\n\\t\\tset.add(parts[0].split(\"\\\\\\\\+\")[0]+\"@\"+parts[1]);\\n\\t}\\n\\treturn set.size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 461090,
                "title": "rust-4-lines",
                "content": "```\\nimpl Solution {\\n    pub fn num_unique_emails(emails: Vec<String>) -> i32 {\\n        emails.iter().map(|e| {\\n            e.chars().take_while(|&e| e != \\'+\\' && e != \\'@\\').filter(|&e| e != \\'.\\')\\n                .chain(e.chars().skip_while(|&e| e != \\'@\\')).collect::<String>()\\n        }).collect::<std::collections::HashSet<_>>().len() as i32\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn num_unique_emails(emails: Vec<String>) -> i32 {\\n        emails.iter().map(|e| {\\n            e.chars().take_while(|&e| e != \\'+\\' && e != \\'@\\').filter(|&e| e != \\'.\\')\\n                .chain(e.chars().skip_while(|&e| e != \\'@\\')).collect::<String>()\\n        }).collect::<std::collections::HashSet<_>>().len() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 440258,
                "title": "python-using-regex",
                "content": "\\n```\\nclass Solution:\\n    def numUniqueEmails(self, emails):\\n        expression, emails_set = r\\'([a-z0-9.]+)\\\\+?.*@(\\\\S+)\\', set()\\n        \\n        for email in emails:\\n            matches = re.findall(expression, email)\\n            email = re.sub(r\\'\\\\.\\', \\'\\', matches[0][0]) + \\'@\\' + matches[0][1]\\n            emails_set.add(email)\\n\\n        return len(emails_set)\\n```\\n\\n\\n\\n---------\\n\\nIf you wish to simplify/update/explore the expression, it\\'s been explained on the top right panel of [regex101.com](https://regex101.com/r/EEfeNu/1/). You can watch the matching steps or modify them in [this debugger link](https://regex101.com/r/EEfeNu/1/debugger), if you\\'d be interested. The debugger demonstrates that how [a RegEx engine](https://en.wikipedia.org/wiki/Comparison_of_regular_expression_engines) might step by step consume some sample input strings and would perform the matching process. \\n\\n---------\\n\\n### RegEx Circuit\\n\\n[jex.im](https://jex.im/regulex/#!flags=&re=%5E(a%7Cb)*%3F%24) visualizes regular expressions: \\n\\n![image](https://assets.leetcode.com/users/emtrade/image_1575064831.png)\\n\\n\\n\\n### Without RegEx\\n\\n```\\nclass Solution:\\n    def numUniqueEmails(self, emails):\\n        visited = set()\\n        for email in emails:\\n            user, site = email.split(\\'@\\')\\n            local = user.split(\\'+\\')[0].replace(\\'.\\', \\'\\')\\n            visited.add(f\\'{local}@{site}\\')\\n\\n        return len(visited)\\n```\\n\\n### Reference\\n\\n[Explains it here](https://leetcode.com/problems/unique-email-addresses/discuss/186798/JavaPython-3-7-and-6-liners-with-comment-and-analysis.)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails):\\n        expression, emails_set = r\\'([a-z0-9.]+)\\\\+?.*@(\\\\S+)\\', set()\\n        \\n        for email in emails:\\n            matches = re.findall(expression, email)\\n            email = re.sub(r\\'\\\\.\\', \\'\\', matches[0][0]) + \\'@\\' + matches[0][1]\\n            emails_set.add(email)\\n\\n        return len(emails_set)\\n```\n```\\nclass Solution:\\n    def numUniqueEmails(self, emails):\\n        visited = set()\\n        for email in emails:\\n            user, site = email.split(\\'@\\')\\n            local = user.split(\\'+\\')[0].replace(\\'.\\', \\'\\')\\n            visited.add(f\\'{local}@{site}\\')\\n\\n        return len(visited)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 296687,
                "title": "javascript-js-one-liner-68-ms-beats-99-69-submissions",
                "content": "JS one-liner with a single regular expression and a set\\n```\\n/**\\n * @param {string[]} emails\\n * @return {number}\\n */\\nvar numUniqueEmails = function(emails) {\\n    return emails.reduce((s, e) => s.add(e.replace(/(\\\\+.*(?=@)|(\\\\.(?=.*@)))/g, \\'\\')), new Set()).size;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} emails\\n * @return {number}\\n */\\nvar numUniqueEmails = function(emails) {\\n    return emails.reduce((s, e) => s.add(e.replace(/(\\\\+.*(?=@)|(\\\\.(?=.*@)))/g, \\'\\')), new Set()).size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 208818,
                "title": "python-solution",
                "content": "`O(n)` time, `O(n)` space, where `n` is the total length of all emails.\\n\\n```\\nclass Solution(object):\\n    def numUniqueEmails(self, emails):\\n        \"\"\"\\n        :type emails: List[str]\\n        :rtype: int\\n        \"\"\"\\n        seen = set()\\n        for email in emails:\\n            local, domain = email.split(\\'@\\')\\n            local = local.split(\\'+\\')[0]\\n            local = local.replace(\\'.\\',\\'\\')\\n            seen.add(local+\\'@\\'+domain)\\n        return len(seen)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numUniqueEmails(self, emails):\\n        \"\"\"\\n        :type emails: List[str]\\n        :rtype: int\\n        \"\"\"\\n        seen = set()\\n        for email in emails:\\n            local, domain = email.split(\\'@\\')\\n            local = local.split(\\'+\\')[0]\\n            local = local.replace(\\'.\\',\\'\\')\\n            seen.add(local+\\'@\\'+domain)\\n        return len(seen)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 190720,
                "title": "i-don-t-think-javascript-solutions-are-working",
                "content": "I tried an accepted solution I had previously submitted, the one posted here, and a new one, and I keep getting runtime errors. Is anybody successfully able to submit a javascript solution at all right now? \n\n```\nvar numUniqueEmails = function(emails) {\n    let map = {};\n    let dupCount = 0;\n    \n    for (email of emails) {\n        email = email.split(\"@\");\n        email = `${email[0].replace(/(\\.)+|(\\+(.*))/mgi, '')}@${email[1]}`;   \n        if (map[email]) dupCount++;\n        else map[email] = true;\n    }\n    \n    return emails.length - dupCount;\n};\n```",
                "solutionTags": [],
                "code": "```\nvar numUniqueEmails = function(emails) {\n    let map = {};\n    let dupCount = 0;\n    \n    for (email of emails) {\n        email = email.split(\"@\");\n        email = `${email[0].replace(/(\\.)+|(\\+(.*))/mgi, '')}@${email[1]}`;   \n        if (map[email]) dupCount++;\n        else map[email] = true;\n    }\n    \n    return emails.length - dupCount;\n};\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 186805,
                "title": "c-short-simple-elegant-solutions-o-n-m-time-o-n-m-space",
                "content": "Simply create a tempary email from each input email. Modifying as follows;\n1. Strip out any `.` before either either a `+` or `@` is encountered.\n2. Exclude anything from `+` to `@` (if a `+` is encounted.\n\nAdd the resulting tempary email to a hashset before finally returning the size of the hashset.\n\n### Fast, single pass. O(n * m) time, O(n * m) space where n is number of emails and m is average string length.\n```cpp\n  int numUniqueEmails(vector<string>& emails) {\n    std::unordered_set<std::string> trimmed_emails;\n    for (auto& email : emails) {\n      std::string tmp;\n\n      // Copy everything that is not a '.' until a '+' or a '@' is encountered\t\t\t\n      auto it = email.begin();\n      for (; '@' != *it && '+' != *it; ++it) {\n        if ('.' != *it) {\n          tmp += *it;\n        }\n      }\n\n      // Copy the domain into our tempary email\n      it = std::find(it, email.end(), '@');\n      tmp.append(it, email.end());\n\n      // Add the trimmed email to our set of emails\n      trimmed_emails.insert(tmp);\n    }\n    return trimmed_emails.size();\n  }\n```\t\n\n### A pure stl solution. O(n * m) time, O(n * m) space\n```cpp\n  int numUniqueEmails(vector<string>& emails) {\n    std::unordered_set<std::string> trimmed_emails;\n    for (auto& email : emails) {\n      std::string tmp;\n\n      // Find the end of the local name\n      auto it = std::find_if(email.begin(), email.end(), [](char c) -> bool { return '+' == c || '@' == c; });\n\n      // Copy the local name, excluding any '.'\n      std::copy_if(email.begin(), it, std::back_inserter(tmp), [](char c) -> bool { return c != '.';});\n\n      // Add the domain\n      it = std::find(it, email.end(), '@');\n      std::copy(it, email.end(), std::back_inserter(tmp));\n\n      trimmed_emails.insert(tmp);\n    }\n    return trimmed_emails.size();\n  }\n```\n\n### Using `std::string` operations rather than stl algorithms. O(n * m^2) time, O(n * m) space\nThe copy from the input email upto either `+` or `@`, then loop around removing `.`. This is quadratic, O(m^2) operation because each removal of a '.' requires shifting the remaining string.\n```cpp\n  int numUniqueEmails(vector<string>& emails) {\n    std::unordered_set<std::string> trimmed_emails;\n    for (auto& email : emails) {\n      auto at_pos = email.find('@');\n      auto end_pos = email.find('+');\n      if (end_pos == std::string::npos) {\n        end_pos = at_pos;\n      }\n     \n      // Copy the local name component\n      std::string tmp = email.substr(0, end_pos);\n    \n      // Quadratically remove '.' from our tempary string\n      auto dot_pos = tmp.find('.'); \n      while (dot_pos != std::string::npos) {\n        tmp.erase(dot_pos, 1);\n        dot_pos = tmp.find('.', dot_pos);\n      }\n     \n      // Add the domain\n      tmp += email.substr(at_pos);\n      \n      trimmed_emails.insert(tmp);\n    }\n    return trimmed_emails.size();\n  }\n```\n\n### Faster string operations solutions. O(n * m) time, O(n * m) space.\nThe quadratic removal of `.`s can be removed by copying the sections between `.`s from the input strings.\n```cpp\n  int numUniqueEmails(vector<string>& emails) {\n    std::unordered_set<std::string> trimmed_emails;\n    for (auto& email : emails) {\n      auto at_pos = email.find('@');\n      auto end_pos = email.find('+');\n      if (end_pos == std::string::npos) {\n        end_pos = at_pos;\n      }\n  \n      std::string tmp;\n\n      // Copy sections of the input email between the '.'s\n      std::string::size_type start = 0;\n      auto dot_pos = email.find('.');\n      while (dot_pos != std::string::npos && dot_pos < end_pos) {\n        tmp += email.substr(start, dot_pos - start);\n        start = dot_pos + 1;\n        dot_pos = email.find('.', start);\n      }\n      tmp += email.substr(start, end_pos - start);\n     \n      // Add the domain\n      tmp += email.substr(at_pos);\n      \n      trimmed_emails.insert(tmp);\n    }\n    return trimmed_emails.size();\n  }\n```\n\nI personally prefer the first solution because it copies the input email as it searches and results in a lot less double handling. I frankly hate the `std::string` operations as they tend to be less efficent, but have added them as suggested in the comments.",
                "solutionTags": [],
                "code": "```cpp\n  int numUniqueEmails(vector<string>& emails) {\n    std::unordered_set<std::string> trimmed_emails;\n    for (auto& email : emails) {\n      std::string tmp;\n\n      // Copy everything that is not a '.' until a '+' or a '@' is encountered\t\t\t\n      auto it = email.begin();\n      for (; '@' != *it && '+' != *it; ++it) {\n        if ('.' != *it) {\n          tmp += *it;\n        }\n      }\n\n      // Copy the domain into our tempary email\n      it = std::find(it, email.end(), '@');\n      tmp.append(it, email.end());\n\n      // Add the trimmed email to our set of emails\n      trimmed_emails.insert(tmp);\n    }\n    return trimmed_emails.size();\n  }\n```\n```cpp\n  int numUniqueEmails(vector<string>& emails) {\n    std::unordered_set<std::string> trimmed_emails;\n    for (auto& email : emails) {\n      std::string tmp;\n\n      // Find the end of the local name\n      auto it = std::find_if(email.begin(), email.end(), [](char c) -> bool { return '+' == c || '@' == c; });\n\n      // Copy the local name, excluding any '.'\n      std::copy_if(email.begin(), it, std::back_inserter(tmp), [](char c) -> bool { return c != '.';});\n\n      // Add the domain\n      it = std::find(it, email.end(), '@');\n      std::copy(it, email.end(), std::back_inserter(tmp));\n\n      trimmed_emails.insert(tmp);\n    }\n    return trimmed_emails.size();\n  }\n```\n```cpp\n  int numUniqueEmails(vector<string>& emails) {\n    std::unordered_set<std::string> trimmed_emails;\n    for (auto& email : emails) {\n      auto at_pos = email.find('@');\n      auto end_pos = email.find('+');\n      if (end_pos == std::string::npos) {\n        end_pos = at_pos;\n      }\n     \n      // Copy the local name component\n      std::string tmp = email.substr(0, end_pos);\n    \n      // Quadratically remove '.' from our tempary string\n      auto dot_pos = tmp.find('.'); \n      while (dot_pos != std::string::npos) {\n        tmp.erase(dot_pos, 1);\n        dot_pos = tmp.find('.', dot_pos);\n      }\n     \n      // Add the domain\n      tmp += email.substr(at_pos);\n      \n      trimmed_emails.insert(tmp);\n    }\n    return trimmed_emails.size();\n  }\n```\n```cpp\n  int numUniqueEmails(vector<string>& emails) {\n    std::unordered_set<std::string> trimmed_emails;\n    for (auto& email : emails) {\n      auto at_pos = email.find('@');\n      auto end_pos = email.find('+');\n      if (end_pos == std::string::npos) {\n        end_pos = at_pos;\n      }\n  \n      std::string tmp;\n\n      // Copy sections of the input email between the '.'s\n      std::string::size_type start = 0;\n      auto dot_pos = email.find('.');\n      while (dot_pos != std::string::npos && dot_pos < end_pos) {\n        tmp += email.substr(start, dot_pos - start);\n        start = dot_pos + 1;\n        dot_pos = email.find('.', start);\n      }\n      tmp += email.substr(start, end_pos - start);\n     \n      // Add the domain\n      tmp += email.substr(at_pos);\n      \n      trimmed_emails.insert(tmp);\n    }\n    return trimmed_emails.size();\n  }\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1775689,
                "title": "c-basic-solution-hash-map",
                "content": "```\\nint numUniqueEmails(vector<string> &emails) {\\n    // can use a hashset too\\n\\tunordered_map<string, int> cnt;\\n\\n    for (int i = 0; i < emails.size(); i++) {\\n        \\n        string temp = \"\";\\n        string now = emails[i];\\n\\n        for (int j = 0; now[j] != \\'@\\'; j++) {\\n            \\n            if (now[j] == \\'+\\')\\n                break;\\n            \\n            if (now[j] == \\'.\\')\\n                continue;\\n            \\n            temp.push_back(now[j]);\\n        }\\n        \\n        int index = now.find(\\'@\\');\\n        \\n        while (index < now.size()) {\\n            temp.push_back(now[index++]);\\n        }\\n        \\n        cnt[temp]++;\\n    }\\n\\n  return cnt.size();\\n\\n}\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint numUniqueEmails(vector<string> &emails) {\\n    // can use a hashset too\\n\\tunordered_map<string, int> cnt;\\n\\n    for (int i = 0; i < emails.size(); i++) {\\n        \\n        string temp = \"\";\\n        string now = emails[i];\\n\\n        for (int j = 0; now[j] != \\'@\\'; j++) {\\n            \\n            if (now[j] == \\'+\\')\\n                break;\\n            \\n            if (now[j] == \\'.\\')\\n                continue;\\n            \\n            temp.push_back(now[j]);\\n        }\\n        \\n        int index = now.find(\\'@\\');\\n        \\n        while (index < now.size()) {\\n            temp.push_back(now[index++]);\\n        }\\n        \\n        cnt[temp]++;\\n    }\\n\\n  return cnt.size();\\n\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1491633,
                "title": "c-solution",
                "content": "```\\nclass Solution\\n{\\n    public:\\n    int numUniqueEmails(vector<string> &emails)\\n    {\\n        std::unordered_set<string> s;\\n        for (const auto &email : emails)\\n        {\\n            s.insert(cleanupAddress(email));\\n        }\\n        return s.size();\\n    }\\n    private:\\n    string cleanupAddress(const string &email)\\n    {\\n        int localEnd = email.find(\\'@\\');\\n        string cleanLocal;\\n        for (int i = 0; i < localEnd; ++i)\\n        {\\n            if (email[i] == \\'+\\')\\n            {\\n                break;\\n            }\\n            else if (email[i] != \\'.\\')\\n            {\\n                cleanLocal += email[i];\\n            }\\n        }\\n        return cleanLocal + email.substr(localEnd);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n    int numUniqueEmails(vector<string> &emails)\\n    {\\n        std::unordered_set<string> s;\\n        for (const auto &email : emails)\\n        {\\n            s.insert(cleanupAddress(email));\\n        }\\n        return s.size();\\n    }\\n    private:\\n    string cleanupAddress(const string &email)\\n    {\\n        int localEnd = email.find(\\'@\\');\\n        string cleanLocal;\\n        for (int i = 0; i < localEnd; ++i)\\n        {\\n            if (email[i] == \\'+\\')\\n            {\\n                break;\\n            }\\n            else if (email[i] != \\'.\\')\\n            {\\n                cleanLocal += email[i];\\n            }\\n        }\\n        return cleanLocal + email.substr(localEnd);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 813240,
                "title": "easy-concise-using-find-erase-c",
                "content": "**Let\\'s start the cleaning process**\\n\\nFeel free to ask anything, these are some basic functions.\\nPreety much it got everything that you already are thinking.\\n\\n```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n            \\n        for(auto &x:emails){\\n            auto pos2 = x.find(\\'@\\');\\n            if(pos2 < x.size())\\n                x.erase(remove(x.begin(),x.begin()+pos2,\\'.\\'),x.begin()+pos2);\\n            \\n            auto pos1 = x.find(\\'+\\');\\n            pos2 = x.find(\\'@\\');\\n            if(pos1 < x.size() and pos2 < x.size())\\n                x.erase(pos1,pos2-pos1);\\n        }\\n        \\n        unordered_set<string> ans(emails.begin(),emails.end());\\n        return ans.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n            \\n        for(auto &x:emails){\\n            auto pos2 = x.find(\\'@\\');\\n            if(pos2 < x.size())\\n                x.erase(remove(x.begin(),x.begin()+pos2,\\'.\\'),x.begin()+pos2);\\n            \\n            auto pos1 = x.find(\\'+\\');\\n            pos2 = x.find(\\'@\\');\\n            if(pos1 < x.size() and pos2 < x.size())\\n                x.erase(pos1,pos2-pos1);\\n        }\\n        \\n        unordered_set<string> ans(emails.begin(),emails.end());\\n        return ans.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 475237,
                "title": "c-80-using-std-unordered-map",
                "content": "class Solution \\n{\\n    public:\\n    \\n    int numUniqueEmails(std::vector<std::string>& e) \\n    {\\n        std::unordered_map<std::string, int> ma;\\n        \\n        for(size_t i = 0; i < e.size(); i++)\\n        {\\n            auto pos = e[i].find(\\'@\\');\\n            \\n            const std::string p2 = e[i].substr(pos);\\n            \\n            std::string p1 = e[i].substr(0, pos);\\n           \\n            p1.erase(std::remove(p1.begin(), p1.end(), \\'.\\'), p1.end());\\n            \\n            pos = p1.find(\\'+\\');\\n            \\n            if(pos != std::string::npos)\\n            {\\n                p1 = p1.substr(0, pos);\\n            }\\n            \\n            ma[p1+p2] = 0;\\n        }\\n        \\n        return ma.size();\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution \\n{\\n    public:\\n    \\n    int numUniqueEmails(std::vector<std::string>& e) \\n    {\\n        std::unordered_map<std::string, int> ma;\\n        \\n        for(size_t i = 0; i < e.size(); i++)\\n        {\\n            auto pos = e[i].find(\\'@\\');\\n            \\n            const std::string p2 = e[i].substr(pos);\\n            \\n            std::string p1 = e[i].substr(0, pos);\\n           \\n            p1.erase(std::remove(p1.begin(), p1.end(), \\'.\\'), p1.end());\\n            \\n            pos = p1.find(\\'+\\');\\n            \\n            if(pos != std::string::npos)\\n            {\\n                p1 = p1.substr(0, pos);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 338553,
                "title": "javascript-one-liner",
                "content": "```Javascript\\n/**\\n * @param {string[]} emails\\n * @return {number}\\n */\\nvar numUniqueEmails = emails => new Set(emails.map(email => `${email.split(\\'@\\')[0].split(\\'+\\')[0].split(\\'.\\').join(\\'\\')}@${email.split(\\'@\\')[1]}`)).size\\n```",
                "solutionTags": [],
                "code": "```Javascript\\n/**\\n * @param {string[]} emails\\n * @return {number}\\n */\\nvar numUniqueEmails = emails => new Set(emails.map(email => `${email.split(\\'@\\')[0].split(\\'+\\')[0].split(\\'.\\').join(\\'\\')}@${email.split(\\'@\\')[1]}`)).size\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 294977,
                "title": "python-beat-99-87",
                "content": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        if not emails:\\n            return 0\\n        addrs = set()\\n        for email in emails:\\n            addr = email.split(\\'@\\')\\n            local_name = addr[0].split(\\'+\\')\\n            local_name = local_name[0].replace(\\'.\\', \\'\\')\\n            addrs.add(local_name + \\'@\\' + addr[-1])\\n        return len(addrs)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        if not emails:\\n            return 0\\n        addrs = set()\\n        for email in emails:\\n            addr = email.split(\\'@\\')\\n            local_name = addr[0].split(\\'+\\')\\n            local_name = local_name[0].replace(\\'.\\', \\'\\')\\n            addrs.add(local_name + \\'@\\' + addr[-1])\\n        return len(addrs)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 289396,
                "title": "java-simple-modular-solution-beats-100",
                "content": "**Explanation:**\\nThe main part of the code is straightforward: process each email as instructed and add it to the hashset which allows to know how many unique emails there are.\\n\\nThe process function examines an email character by character. The last \"if\" condition decides when to add a character. It will only add characters coming from the end of the email, and before the end of the email will ignore all points and all character after any plus symbol.\\n\\n**Analysis:**\\nThis solution is in O(n) time and space. (n being the size of the input array)\\nRuntime: faster than 100%. Memory: less than 98%.\\n```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        Set<String> uniqueEmails = new HashSet<>();\\n        for(String email: emails){\\n            uniqueEmails.add(processEmail(email));\\n        }\\n        return uniqueEmails.size();\\n    }\\n    \\n    \\n    private String processEmail(String email){\\n        StringBuilder outEmail = new StringBuilder();\\n        \\n        boolean afterPlus = false, endEmail = false;\\n        for(char c: email.toCharArray()){\\n            if(c == \\'+\\') afterPlus = true;\\n            if(c == \\'@\\') endEmail = true;\\n            if(endEmail || (!afterPlus && c != \\'.\\')) outEmail.append(c);\\n        }\\n        \\n        return outEmail.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        Set<String> uniqueEmails = new HashSet<>();\\n        for(String email: emails){\\n            uniqueEmails.add(processEmail(email));\\n        }\\n        return uniqueEmails.size();\\n    }\\n    \\n    \\n    private String processEmail(String email){\\n        StringBuilder outEmail = new StringBuilder();\\n        \\n        boolean afterPlus = false, endEmail = false;\\n        for(char c: email.toCharArray()){\\n            if(c == \\'+\\') afterPlus = true;\\n            if(c == \\'@\\') endEmail = true;\\n            if(endEmail || (!afterPlus && c != \\'.\\')) outEmail.append(c);\\n        }\\n        \\n        return outEmail.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 254862,
                "title": "python-10-lines-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails):\\n        uniques = set() # A set can not contain duplicates\\n        for email in emails:\\n            name, domain = email.split(\"@\")\\n            if \"+\" in name:\\n                name = name.split(\"+\")[0].replace(\".\", \"\") # grab everything before \"+\", remove \".\"\\n            else:\\n                name = name.replace(\\'.\\', \"\") # remove \".\"\\n            cleanEmail = name + \"@\" + domain # reassemble emails\\n            uniques.add(cleanEmail) # add cleanEmail to set, which will not accept duplicates\\n        return len(uniques) # return length of uniques to get number of uniques\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails):\\n        uniques = set() # A set can not contain duplicates\\n        for email in emails:\\n            name, domain = email.split(\"@\")\\n            if \"+\" in name:\\n                name = name.split(\"+\")[0].replace(\".\", \"\") # grab everything before \"+\", remove \".\"\\n            else:\\n                name = name.replace(\\'.\\', \"\") # remove \".\"\\n            cleanEmail = name + \"@\" + domain # reassemble emails\\n            uniques.add(cleanEmail) # add cleanEmail to set, which will not accept duplicates\\n        return len(uniques) # return length of uniques to get number of uniques\\n```",
                "codeTag": "Java"
            },
            {
                "id": 234312,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func numUniqueEmails(_ emails: [String]) -> Int {\\n        var processedLocalNames = Set<String>()\\n        emails.forEach {\\n            let components = $0.components(separatedBy: \"@\")\\n            processedLocalNames.insert(\"\\\\(components[0].processedLocalName)@\\\\(components[1])\")\\n        }\\n        return processedLocalNames.count\\n    }\\n}\\n\\nextension String {\\n    var processedLocalName: String {\\n        let prePlus = components(separatedBy: \"+\")[0]\\n        return prePlus.components(separatedBy: \".\").joined()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func numUniqueEmails(_ emails: [String]) -> Int {\\n        var processedLocalNames = Set<String>()\\n        emails.forEach {\\n            let components = $0.components(separatedBy: \"@\")\\n            processedLocalNames.insert(\"\\\\(components[0].processedLocalName)@\\\\(components[1])\")\\n        }\\n        return processedLocalNames.count\\n    }\\n}\\n\\nextension String {\\n    var processedLocalName: String {\\n        let prePlus = components(separatedBy: \"+\")[0]\\n        return prePlus.components(separatedBy: \".\").joined()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590291,
                "title": "simple-solution-using-hashset-and-basic-string-operations",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst locate the index of @, divide the string into two parts local host name before @ and domain name after @. Do the needful by continuing the iteration if \\'.\\' is encountered and break out of the iteration if \\'+\\' is encountered. Build the whole string using Set Builer and add it into set. (Set holds unique values). Find the size of the set as answer.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        HashSet <String> set=new HashSet<>();\\n        for(int i=0;i<emails.length;i++)\\n        {\\n            String current=emails[i];\\n            StringBuilder sb=new StringBuilder();\\n            int indexOfAt=current.indexOf(\\'@\\');\\n            String localName=current.substring(0,indexOfAt);\\n            String domainName=current.substring(indexOfAt);\\n\\n            for(int j=0;j<localName.length();j++)\\n            {\\n                if(localName.charAt(j)==\\'.\\')\\n                {\\n                    continue;\\n                }\\n                if(localName.charAt(j)==\\'+\\')\\n                {\\n                    break;\\n                }\\n                sb.append(localName.charAt(j));\\n            }\\n            sb.append(domainName);\\n            set.add(sb.toString());\\n        }   \\n        return set.size();     \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        HashSet <String> set=new HashSet<>();\\n        for(int i=0;i<emails.length;i++)\\n        {\\n            String current=emails[i];\\n            StringBuilder sb=new StringBuilder();\\n            int indexOfAt=current.indexOf(\\'@\\');\\n            String localName=current.substring(0,indexOfAt);\\n            String domainName=current.substring(indexOfAt);\\n\\n            for(int j=0;j<localName.length();j++)\\n            {\\n                if(localName.charAt(j)==\\'.\\')\\n                {\\n                    continue;\\n                }\\n                if(localName.charAt(j)==\\'+\\')\\n                {\\n                    break;\\n                }\\n                sb.append(localName.charAt(j));\\n            }\\n            sb.append(domainName);\\n            set.add(sb.toString());\\n        }   \\n        return set.size();     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3331797,
                "title": "short-sweet-easy-to-understand-c",
                "content": "````\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        unordered_set<string> s1;\\n        string str = \"\";\\n        int i,n;\\n        bool k = false;\\n        for(auto &s: emails){\\n            str = \"\";\\n            n = s.length();\\n            k = false;\\n            for(i = 0; i < n;i++){\\n                if(s[i]==\\'@\\'){\\n                    str = str +\\'@\\';\\n                    k = true;\\n                }else if(k){\\n                    str = str + s[i];\\n                }else if(s[i]==\\'+\\'){\\n                    while(s[i] != \\'@\\'){\\n                        i++;\\n                    }\\n                    i--;\\n                }else if(s[i]==\\'.\\'){\\n                    continue;\\n                }else{\\n                    str = str+s[i];\\n                }\\n            }\\n            cout<<str<<endl;\\n            s1.insert(str);\\n        }\\n        return s1.size();\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Ordered Set"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        unordered_set<string> s1;\\n        string str = \"\";\\n        int i,n;\\n        bool k = false;\\n        for(auto &s: emails){\\n            str = \"\";\\n            n = s.length();\\n            k = false;\\n            for(i = 0; i < n;i++){\\n                if(s[i]==\\'@\\'){\\n                    str = str +\\'@\\';\\n                    k = true;\\n                }else if(k){\\n                    str = str + s[i];\\n                }else if(s[i]==\\'+\\'){\\n                    while(s[i] != \\'@\\'){\\n                        i++;\\n                    }\\n                    i--;\\n                }else if(s[i]==\\'.\\'){\\n                    continue;\\n                }else{\\n                    str = str+s[i];\\n                }\\n            }\\n            cout<<str<<endl;\\n            s1.insert(str);\\n        }\\n        return s1.size();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2717478,
                "title": "java-straightforward-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        Set<String> set = new HashSet<>();\\n        for (String email : emails) {\\n            int indexOfAt = email.indexOf(\\'@\\');\\n            String front = email.substring(0, indexOfAt);\\n            int index = front.indexOf(\\'+\\');\\n            if (index >= 0) {\\n                front = front.substring(0, index);\\n            }\\n            front = front.replaceAll(\"\\\\\\\\.\", \"\");\\n            String finalString = front + email.substring(indexOfAt);\\n            set.add(finalString);\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        Set<String> set = new HashSet<>();\\n        for (String email : emails) {\\n            int indexOfAt = email.indexOf(\\'@\\');\\n            String front = email.substring(0, indexOfAt);\\n            int index = front.indexOf(\\'+\\');\\n            if (index >= 0) {\\n                front = front.substring(0, index);\\n            }\\n            front = front.replaceAll(\"\\\\\\\\.\", \"\");\\n            String finalString = front + email.substring(indexOfAt);\\n            set.add(finalString);\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2555449,
                "title": "simple-python-solution-faster-than-98-7",
                "content": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        set_ = set()\\n        for i in emails:\\n            final_email = \"\"\\n            email = i.split(\"@\")\\n            email[0] = email[0].replace(\".\",\"\")\\n            if \"+\" in email[0]:\\n                index= email[0].index(\"+\")\\n                email[0] = email[0][:index]\\n            final_email+=email[0]+\"@\"+email[1]\\n            set_.add(final_email)\\n        return len(set_)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        set_ = set()\\n        for i in emails:\\n            final_email = \"\"\\n            email = i.split(\"@\")\\n            email[0] = email[0].replace(\".\",\"\")\\n            if \"+\" in email[0]:\\n                index= email[0].index(\"+\")\\n                email[0] = email[0][:index]\\n            final_email+=email[0]+\"@\"+email[1]\\n            set_.add(final_email)\\n        return len(set_)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2295855,
                "title": "java-solution-using-hashset-faster-than-96-31",
                "content": "```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        String[] copy = new String[emails.length];\\n        HashSet<String> set = new HashSet<>();\\n        for(String email: emails){\\n            StringBuilder localName = new StringBuilder();\\n            boolean local = true;\\n            int index = -1;\\n            for(char c: email.toCharArray()){\\n                index++;\\n                if(c == \\'.\\')\\n                    continue;\\n                if(c == \\'+\\'){\\n                    local = false;\\n                    continue;\\n                }\\n                if(c == \\'@\\')\\n                    break;\\n                else if(local)\\n                    localName.append(c);\\n            }\\n            set.add(localName.toString() + email.substring(index));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        String[] copy = new String[emails.length];\\n        HashSet<String> set = new HashSet<>();\\n        for(String email: emails){\\n            StringBuilder localName = new StringBuilder();\\n            boolean local = true;\\n            int index = -1;\\n            for(char c: email.toCharArray()){\\n                index++;\\n                if(c == \\'.\\')\\n                    continue;\\n                if(c == \\'+\\'){\\n                    local = false;\\n                    continue;\\n                }\\n                if(c == \\'@\\')\\n                    break;\\n                else if(local)\\n                    localName.append(c);\\n            }\\n            set.add(localName.toString() + email.substring(index));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1695954,
                "title": "javascript-time-o-n",
                "content": "## Please upvote, if it helps you!\\n\\n```\\nvar numUniqueEmails = function(emails) {\\n    let uniqueEmails = new Set()\\n    \\n    function removeCharsAfterPlus(email) {\\n        let [localName, domain] = email.split(\\'@\\')\\n        localName = localName.split(\\'+\\')[0]\\n        return localName + \\'@\\' + domain\\n    }\\n    \\n    function getCharsWithoutDots(email) {\\n        let [localName, domain] = email.split(\\'@\\')\\n        localName = localName.split(\\'.\\').join(\\'\\')\\n        return localName + \\'@\\' + domain\\n    }\\n    \\n    for (let email of emails) {\\n        email = removeCharsAfterPlus(email)\\n        email = getCharsWithoutDots(email)\\n        uniqueEmails.add(email)\\n    }\\n    \\n    return uniqueEmails.size\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\nvar numUniqueEmails = function(emails) {\\n    let uniqueEmails = new Set()\\n    \\n    function removeCharsAfterPlus(email) {\\n        let [localName, domain] = email.split(\\'@\\')\\n        localName = localName.split(\\'+\\')[0]\\n        return localName + \\'@\\' + domain\\n    }\\n    \\n    function getCharsWithoutDots(email) {\\n        let [localName, domain] = email.split(\\'@\\')\\n        localName = localName.split(\\'.\\').join(\\'\\')\\n        return localName + \\'@\\' + domain\\n    }\\n    \\n    for (let email of emails) {\\n        email = removeCharsAfterPlus(email)\\n        email = getCharsWithoutDots(email)\\n        uniqueEmails.add(email)\\n    }\\n    \\n    return uniqueEmails.size\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1561527,
                "title": "rust-functional-solution-4-ms",
                "content": "```\\nimpl Solution {\\n    pub fn num_unique_emails(emails: Vec<String>) -> i32 {\\n        use std::collections::HashSet;\\n        emails\\n            .iter()\\n            .map(|s| {\\n                let (mut plus, mut domain) = (false, false);\\n                s.chars()\\n                    .filter(|&c| match c {\\n                        _ if domain => true,\\n                        \\'+\\' => {\\n                            plus = true;\\n                            false\\n                        }\\n                        \\'@\\' => {\\n                            domain = true;\\n                            true\\n                        }\\n                        _ if plus => false,\\n                        \\'.\\' => false,\\n                        _ => true,\\n                    })\\n                    .collect::<String>()\\n            })\\n            .collect::<HashSet<_>>()\\n            .len() as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn num_unique_emails(emails: Vec<String>) -> i32 {\\n        use std::collections::HashSet;\\n        emails\\n            .iter()\\n            .map(|s| {\\n                let (mut plus, mut domain) = (false, false);\\n                s.chars()\\n                    .filter(|&c| match c {\\n                        _ if domain => true,\\n                        \\'+\\' => {\\n                            plus = true;\\n                            false\\n                        }\\n                        \\'@\\' => {\\n                            domain = true;\\n                            true\\n                        }\\n                        _ if plus => false,\\n                        \\'.\\' => false,\\n                        _ => true,\\n                    })\\n                    .collect::<String>()\\n            })\\n            .collect::<HashSet<_>>()\\n            .len() as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1492238,
                "title": "c-linear-solution-explained-100-time-99-space",
                "content": "To solve this problem we will just have to clean up our strings, then use something to remove duplicated - an `unordered_set` works just fine for that.\\n\\nSo, our support variables are going to be:\\n* `tmp`, the string we will build gradually as we clean up each provided one;\\n* `res` is going to be our aforementioned set, convenient to store and avoid duplicates in `O(lgn)`;\\n* `beforeAt` and `plusSeen` are two boolean flags will use to mark specific points in each email.\\n\\nWe will then loop through each string `s` given to us and:\\n* clear `tmp`, ready for another loop;\\n*  reset `beforeAt` and `plusSeen` to be `true` and `false`, respectively;\\n*  loops through each character `c` of `s` and:\\n\\t*  if `c` is a `\\'+\\'`, set `plusSeen` to `true`;\\n\\t*  alternatively, if `c` is `@\\'`, set `beforeAt` to `false` and reset `plusSeen` to `false`;\\n\\t*  check if we found a `\\'.\\'` before the `\\'@\\'` (`beforeAt && c == \\'.\\'`) or if we are after a `\\'+\\'` (`plusSeen`), in which case we just `continue`;\\n\\t*  append `c` to `tmp`;\\n*  finally, insert `tmp` in `res`.\\n\\nOnce done, we can just `return` `res.size()` to get the uniques and be done with it :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        // support variables\\n        string tmp;\\n        unordered_set<string> res;\\n        bool beforeAt, plusSeen;\\n        // parsing emails\\n        for (string &s: emails) {\\n            // resetting loop variables\\n            tmp.clear();\\n            beforeAt = true, plusSeen = false;\\n            for (char c: s) {\\n                if (c == \\'+\\') plusSeen = true;\\n                else if (c == \\'@\\') beforeAt = false, plusSeen = false;\\n                if (beforeAt && c == \\'.\\' || plusSeen) continue;\\n                tmp += c;\\n            }\\n            res.insert(tmp);\\n        }\\n        return res.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        // support variables\\n        string tmp;\\n        unordered_set<string> res;\\n        bool beforeAt, plusSeen;\\n        // parsing emails\\n        for (string &s: emails) {\\n            // resetting loop variables\\n            tmp.clear();\\n            beforeAt = true, plusSeen = false;\\n            for (char c: s) {\\n                if (c == \\'+\\') plusSeen = true;\\n                else if (c == \\'@\\') beforeAt = false, plusSeen = false;\\n                if (beforeAt && c == \\'.\\' || plusSeen) continue;\\n                tmp += c;\\n            }\\n            res.insert(tmp);\\n        }\\n        return res.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1489772,
                "title": "javascript-100-68ms-very-simple-set-solution",
                "content": "![image](https://assets.leetcode.com/users/images/9fd56a9d-0d2c-45aa-a6cb-e73ae82c7fe0_1632762725.68751.png)\\n\\nPosting solutions to dailies.\\n\\n```\\nvar numUniqueEmails = function(emails) {\\n  const res = new Set();\\n  for (let email of emails) {\\n    if (email.includes(\\'+\\')) {\\n      let pIdx = email.indexOf(\\'+\\')\\n      let aIdx = email.indexOf(\\'@\\')\\n      email = email.substr(0, pIdx) + email.substr(aIdx)\\n    }\\n    email = email.split(\\'@\\');\\n    email[0].includes(\\'.\\') && \\n      (email[0] = email[0].replace(/[.]/g, \\'\\'))\\n    email = email.join(\\'@\\')\\n    res.add(email)\\n  }\\n  return res.size\\n};\\n```\\n\\nNote:  You can also do\\n```\\n    let [local, domain] = email.split(\\'@\\');\\n    local = local.replace(/[.]/g, \\'\\')\\n    res.add(local + \\'@\\' + domain)\\n```\\nThis might be a little more readable / easier to work with in an actual code base.  Here on LC, it just adds runtime and space though.  That said, I do like destructuring for readability in cases like this.\\n\\nHere is an alternate string method only version without .split().  I wanted to see if the runtime was faster, it\\'s about the same though.\\n```\\nvar numUniqueEmails = function(emails) {\\n  const res = new Set();\\n  for (let email of emails) {\\n    if (email.includes(\\'+\\')) {\\n      const pIdx = email.indexOf(\\'+\\')\\n      const aIdx = email.indexOf(\\'@\\')\\n      email = email.substr(0, pIdx) + email.substr(aIdx)\\n    }\\n    let splitIdx = email.indexOf(\\'@\\')\\n    email = email.substr(0,splitIdx).replace(/[.]/g, \\'\\') + email.substr(splitIdx)\\n    res.add(email)\\n  }\\n  return res.size\\n};\\n```\\n\\nOne last version, because I thought getting rid of the O(n) .indexOf calls would speed it up markedly.  Performance improvement was negligible though.  It still gets 100%, but 72ms was the best I got in 5x runs.  Technically, I do believe this algorithm does the least amount of work though.  One O(n) for each email to get necessary indexes, another O(local.length) for the replace. O(numEmails * localDomainLength) for all of these solutions.  This one only has to loop through local domain twice though, others do it 3+ times.  Was a small improvement experiment, and completely unnecessary optimization since the results were negligible and readability suffered dramatically.\\n\\n```\\nvar numUniqueEmails = function(emails) {\\n  const res = new Set();\\n  for (let email of emails) {\\n    let pIdx, aIdx, hasP = false;\\n    for (let i = 0; i < email.length; i++) {\\n      if (!pIdx && email[i] === \\'+\\') pIdx = i;\\n      else if (email[i] === \\'@\\') {\\n        aIdx = i;\\n        if (!pIdx) pIdx = i;\\n        break;\\n      } else if (email[i] === \\'.\\') hasP = true;\\n    }\\n    if (pIdx !== aIdx) email = email.substr(0, pIdx) + email.substr(aIdx)\\n    if (hasP) email = email.substr(0, pIdx).replace(/[.]/g, \\'\\') + email.substr(pIdx)\\n    res.add(email)\\n  }\\n  return res.size\\n};\\n```\\n\\nI lied - last, last version.  Here we just simply build up the local and as soon as we reach the @, we add on the rest and put it in the set.\\n\\n```\\nconst numUniqueEmails = emails => {\\n  const res = new Set();\\n  for (let email of emails) {\\n    let formated = \\'\\';\\n    for (let i = 0, char = email[i], afP;\\n         i < email.length; char = email[++i]) {\\n      if (char === \\'@\\') {\\n        formated += email.substr(i);\\n        break;\\n      }\\n      if (char === \\'+\\') afP = true;\\n      if (afP || char === \\'.\\') continue;\\n      formated += char\\n    }\\n    res.add(formated);\\n  }\\n  return res.size;\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/783d5532-9323-4ad3-8f52-9e1019df68e6_1632762735.7302983.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numUniqueEmails = function(emails) {\\n  const res = new Set();\\n  for (let email of emails) {\\n    if (email.includes(\\'+\\')) {\\n      let pIdx = email.indexOf(\\'+\\')\\n      let aIdx = email.indexOf(\\'@\\')\\n      email = email.substr(0, pIdx) + email.substr(aIdx)\\n    }\\n    email = email.split(\\'@\\');\\n    email[0].includes(\\'.\\') && \\n      (email[0] = email[0].replace(/[.]/g, \\'\\'))\\n    email = email.join(\\'@\\')\\n    res.add(email)\\n  }\\n  return res.size\\n};\\n```\n```\\n    let [local, domain] = email.split(\\'@\\');\\n    local = local.replace(/[.]/g, \\'\\')\\n    res.add(local + \\'@\\' + domain)\\n```\n```\\nvar numUniqueEmails = function(emails) {\\n  const res = new Set();\\n  for (let email of emails) {\\n    if (email.includes(\\'+\\')) {\\n      const pIdx = email.indexOf(\\'+\\')\\n      const aIdx = email.indexOf(\\'@\\')\\n      email = email.substr(0, pIdx) + email.substr(aIdx)\\n    }\\n    let splitIdx = email.indexOf(\\'@\\')\\n    email = email.substr(0,splitIdx).replace(/[.]/g, \\'\\') + email.substr(splitIdx)\\n    res.add(email)\\n  }\\n  return res.size\\n};\\n```\n```\\nvar numUniqueEmails = function(emails) {\\n  const res = new Set();\\n  for (let email of emails) {\\n    let pIdx, aIdx, hasP = false;\\n    for (let i = 0; i < email.length; i++) {\\n      if (!pIdx && email[i] === \\'+\\') pIdx = i;\\n      else if (email[i] === \\'@\\') {\\n        aIdx = i;\\n        if (!pIdx) pIdx = i;\\n        break;\\n      } else if (email[i] === \\'.\\') hasP = true;\\n    }\\n    if (pIdx !== aIdx) email = email.substr(0, pIdx) + email.substr(aIdx)\\n    if (hasP) email = email.substr(0, pIdx).replace(/[.]/g, \\'\\') + email.substr(pIdx)\\n    res.add(email)\\n  }\\n  return res.size\\n};\\n```\n```\\nconst numUniqueEmails = emails => {\\n  const res = new Set();\\n  for (let email of emails) {\\n    let formated = \\'\\';\\n    for (let i = 0, char = email[i], afP;\\n         i < email.length; char = email[++i]) {\\n      if (char === \\'@\\') {\\n        formated += email.substr(i);\\n        break;\\n      }\\n      if (char === \\'+\\') afP = true;\\n      if (afP || char === \\'.\\') continue;\\n      formated += char\\n    }\\n    res.add(formated);\\n  }\\n  return res.size;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1489291,
                "title": "unique-emails-c-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        \\n        set<string>st ;\\n        vector<string>::iterator it ;\\n        \\n       // for( it = emails.begin() ; it != emails.end() ; it++ )\\n        \\n        for( auto& I : emails )\\n        {\\n            int n = I.length() ;\\n            string tmp = \"\" ;\\n            int TC = 100 ;\\n            for(int i=0;i<n;i++)\\n            {\\n                if( I[i] == \\'+\\' )\\n                {\\n                    while( I[i] != \\'@\\' )\\n                        i++ ;\\n                    TC = i ;\\n                }\\n                else if( I[i] == \\'@\\' )\\n                    TC = i ;\\n                //cout<<i<<\"  \"<<TC<<endl;\\n                if( I[i] == \\'.\\' && i < TC )\\n                    continue ;\\n                tmp+=I[i] ;\\n                \\n            }\\n            cout<<tmp<<endl ;\\n            if(!st.count(tmp))\\n                st.insert(tmp) ;\\n            \\n        }\\n        \\n        \\n        return st.size() ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        \\n        set<string>st ;\\n        vector<string>::iterator it ;\\n        \\n       // for( it = emails.begin() ; it != emails.end() ; it++ )\\n        \\n        for( auto& I : emails )\\n        {\\n            int n = I.length() ;\\n            string tmp = \"\" ;\\n            int TC = 100 ;\\n            for(int i=0;i<n;i++)\\n            {\\n                if( I[i] == \\'+\\' )\\n                {\\n                    while( I[i] != \\'@\\' )\\n                        i++ ;\\n                    TC = i ;\\n                }\\n                else if( I[i] == \\'@\\' )\\n                    TC = i ;\\n                //cout<<i<<\"  \"<<TC<<endl;\\n                if( I[i] == \\'.\\' && i < TC )\\n                    continue ;\\n                tmp+=I[i] ;\\n                \\n            }\\n            cout<<tmp<<endl ;\\n            if(!st.count(tmp))\\n                st.insert(tmp) ;\\n            \\n        }\\n        \\n        \\n        return st.size() ;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1474475,
                "title": "python-regex",
                "content": "Build a set by using set comprehension by iterating over addresses and subsituting 1. \\'+\\' and anything that follows up to @ and 2. substitute all \\'.\\' in localname only (utilizing positive lookahead). Return length of the set:\\n```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        addresses = { re.sub(   \\'\\\\.(?=.*@)\\',\\n                                \\'\\', \\n                                re.sub( \\'\\\\+.*@\\',\\n                                        \\'@\\',\\n                                        address )) for address in emails }\\n        return len(addresses)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        addresses = { re.sub(   \\'\\\\.(?=.*@)\\',\\n                                \\'\\', \\n                                re.sub( \\'\\\\+.*@\\',\\n                                        \\'@\\',\\n                                        address )) for address in emails }",
                "codeTag": "Java"
            },
            {
                "id": 1238575,
                "title": "c-easy-solution-production-ready-code-using-set-with-explanation-using-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    /*\\n    * Process String to apply rules\\n    */\\n    string processString(string str) {\\n        int zero = 0;\\n        \\n        /*\\n        * Separate local_name, \"@\"+domain_name. Setps:\\n        * 1. get location of \"@\"\\n        * 2. separate local_name using location of \"@\"\\n        * 3. separate \"@{domain_name}\" string\\n        */\\n        int at_loc = str.find(\"@\");\\n        string local_name = str.substr(zero, at_loc);\\n        string domain_name = str.substr(at_loc, str.length());\\n        \\n        /*\\n        * Remove local_name after \"+\". Steps:\\n        * 1. Find location of \"+\"\\n        * 2. If plus exists(i.e. plus_loc != -1) then\\n        * 3. Take local_name before \"+\"\\n        */\\n        int plus_loc = local_name.find(\"+\");\\n        if(plus_loc != -1)\\n            local_name = local_name.substr(zero, plus_loc);\\n        \\n        /*\\n        * Remove each dot in local_name. Steps:\\n        * 1. Find location of \".\"\\n        * 2. If dot exists then\\n        * 3. Replace \".\" with blank string(i.e. \"\")\\n        * 4. Find location of next dot\\n        */\\n        int dot_loc = local_name.find(\".\");\\n        while(dot_loc != -1) {\\n            local_name.replace(dot_loc, 1, \"\");\\n            dot_loc = local_name.find(\".\");\\n        }\\n        \\n        // Finally return local_name + domain_name\\n        return local_name + domain_name;\\n    }\\n    \\n    /*\\n    * Process Each email and put unique values \\n    * into set and finally return size of set\\n    */\\n    int numUniqueEmails(vector<string>& emails) {\\n        /*\\n        * Create a set since set stores only unique values \\n        * and we need to return no. of unique values only\\n        */\\n        set<string> ans;\\n        \\n        /* \\n\\t\\t* Process each input email and put processed \\n        * value in set if it does not exist already.\\n        */\\n        for(auto email: emails) {\\n            string proccessedEmail = processString(email);\\n            if(ans.find(proccessedEmail) == ans.end()) {\\n                ans.insert(proccessedEmail);\\n            }\\n        }\\n        return ans.size();\\n    }\\n};\\n```\\n\\nProcess each email and put processed email in a set if it already does not contain the processed email. Finally return the size of the set.\\n\\n*Do hit the upvote button if you like the solution or find it helpful.*\\n\\n**Thanks. Hope it helps.**\\n~*Sadul Khod*",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    /*\\n    * Process String to apply rules\\n    */\\n    string processString(string str) {\\n        int zero = 0;\\n        \\n        /*\\n        * Separate local_name, \"@\"+domain_name. Setps:\\n        * 1. get location of \"@\"\\n        * 2. separate local_name using location of \"@\"\\n        * 3. separate \"@{domain_name}\" string\\n        */\\n        int at_loc = str.find(\"@\");\\n        string local_name = str.substr(zero, at_loc);\\n        string domain_name = str.substr(at_loc, str.length());\\n        \\n        /*\\n        * Remove local_name after \"+\". Steps:\\n        * 1. Find location of \"+\"\\n        * 2. If plus exists(i.e. plus_loc != -1) then\\n        * 3. Take local_name before \"+\"\\n        */\\n        int plus_loc = local_name.find(\"+\");\\n        if(plus_loc != -1)\\n            local_name = local_name.substr(zero, plus_loc);\\n        \\n        /*\\n        * Remove each dot in local_name. Steps:\\n        * 1. Find location of \".\"\\n        * 2. If dot exists then\\n        * 3. Replace \".\" with blank string(i.e. \"\")\\n        * 4. Find location of next dot\\n        */\\n        int dot_loc = local_name.find(\".\");\\n        while(dot_loc != -1) {\\n            local_name.replace(dot_loc, 1, \"\");\\n            dot_loc = local_name.find(\".\");\\n        }\\n        \\n        // Finally return local_name + domain_name\\n        return local_name + domain_name;\\n    }\\n    \\n    /*\\n    * Process Each email and put unique values \\n    * into set and finally return size of set\\n    */\\n    int numUniqueEmails(vector<string>& emails) {\\n        /*\\n        * Create a set since set stores only unique values \\n        * and we need to return no. of unique values only\\n        */\\n        set<string> ans;\\n        \\n        /* \\n\\t\\t* Process each input email and put processed \\n        * value in set if it does not exist already.\\n        */\\n        for(auto email: emails) {\\n            string proccessedEmail = processString(email);\\n            if(ans.find(proccessedEmail) == ans.end()) {\\n                ans.insert(proccessedEmail);\\n            }\\n        }\\n        return ans.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867547,
                "title": "c-brute-force-solution-beats-100-runtime-95-less-space",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int numUniqueEmails(vector<string> &emails)\\n    {\\n        set<string> res;\\n        for (int i = 0; i < emails.size(); ++i)\\n        {\\n            int count = 0;\\n            for (int j = 0; j < emails[i].length(); ++j)\\n            {\\n                if (emails[i][j] == \\'@\\')\\n                    break;\\n                else if (emails[i][j] == \\'.\\')\\n                {\\n                    emails[i].erase(j, 1);\\n                    --j;\\n                }\\n                else if (emails[i][j] == \\'+\\')\\n                {\\n                    count = j;\\n                    break;\\n                }\\n            }\\n\\n            int pos = emails[i].find(\\'@\\');\\n            if (count != 0)\\n                emails[i].erase(count, pos - count);\\n            res.insert(emails[i]);\\n        }\\n        return res.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int numUniqueEmails(vector<string> &emails)\\n    {\\n        set<string> res;\\n        for (int i = 0; i < emails.size(); ++i)\\n        {\\n            int count = 0;\\n            for (int j = 0; j < emails[i].length(); ++j)\\n            {\\n                if (emails[i][j] == \\'@\\')\\n                    break;\\n                else if (emails[i][j] == \\'.\\')\\n                {\\n                    emails[i].erase(j, 1);\\n                    --j;\\n                }\\n                else if (emails[i][j] == \\'+\\')\\n                {\\n                    count = j;\\n                    break;\\n                }\\n            }\\n\\n            int pos = emails[i].find(\\'@\\');\\n            if (count != 0)\\n                emails[i].erase(count, pos - count);\\n            res.insert(emails[i]);\\n        }\\n        return res.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 385476,
                "title": "cpp-using-unordered-set",
                "content": "Runtime: 36 ms, faster than 51.17% of C++ online submissions for Unique Email Addresses.\\nMemory Usage: 13.2 MB, less than 59.52% of C++ online submissions for Unique Email Addresses.\\n```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        unordered_set<string> ust;\\n        \\n        for (auto str:emails)\\n        {\\n            string tmp;\\n            \\n            for (auto c:str)\\n            {\\n                if (c == \\'.\\') continue;\\n                if (c == \\'+\\' || c == \\'@\\') break;\\n                tmp.push_back(c);\\n            }\\n            ust.insert(tmp + str.substr(str.find(\\'@\\')));\\n        }\\n        \\n        return ust.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        unordered_set<string> ust;\\n        \\n        for (auto str:emails)\\n        {\\n            string tmp;\\n            \\n            for (auto c:str)\\n            {\\n                if (c == \\'.\\') continue;\\n                if (c == \\'+\\' || c == \\'@\\') break;\\n                tmp.push_back(c);\\n            }\\n            ust.insert(tmp + str.substr(str.find(\\'@\\')));\\n        }\\n        \\n        return ust.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 358313,
                "title": "python3-straight-forward-solution",
                "content": "* slipt the email into local and domain\\n*  clean local\\n\\t* \\treplace \\',\\' with \\'\\' in local\\n\\t* \\tslice local from the beginning of local to the index of \\'+\\'\\n*  rebuild the email address using cleaned local and domain \\n*  count the rebuild email address\\n\\n```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        seen = set()\\n        for i in emails:\\n            local,domain = i.split(\\'@\\')\\n            if \\'.\\' in local:\\n                local = local.replace(\\'.\\',\\'\\')\\n            if \\'+\\' in local:\\n                local = local[:local.index(\\'+\\')]\\n            seen.add(local+\\'@\\'+domain)\\n        return len(seen)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        seen = set()\\n        for i in emails:\\n            local,domain = i.split(\\'@\\')\\n            if \\'.\\' in local:\\n                local = local.replace(\\'.\\',\\'\\')\\n            if \\'+\\' in local:\\n                local = local[:local.index(\\'+\\')]\\n            seen.add(local+\\'@\\'+domain)\\n        return len(seen)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 353132,
                "title": "c-very-simple-28-ms-faster-than-93-92",
                "content": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        set<string> ans;\\n        for(int i=0;i<emails.size();i++){\\n            string s=\"\";\\n            int pos=emails[i].find(\"@\");\\n            string sub=emails[i].substr(pos);\\n            for(char x:emails[i]){                \\n                if(x==\\'.\\')continue;\\n                if(x==\\'+\\'||x==\\'@\\')break;\\n                s.push_back(x);                \\n            }\\n            s+=sub;\\n            ans.insert(s);\\n        }\\n        return ans.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        set<string> ans;\\n        for(int i=0;i<emails.size();i++){\\n            string s=\"\";\\n            int pos=emails[i].find(\"@\");\\n            string sub=emails[i].substr(pos);\\n            for(char x:emails[i]){                \\n                if(x==\\'.\\')continue;\\n                if(x==\\'+\\'||x==\\'@\\')break;\\n                s.push_back(x);                \\n            }\\n            s+=sub;\\n            ans.insert(s);\\n        }\\n        return ans.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 320985,
                "title": "javascript-beats-100-in-memory-usage-always-and-100-in-performance-sometimes",
                "content": "```javascript\\n/**\\n * @param {string[]} emails\\n * @return {number}\\n */\\nvar numUniqueEmails = function(emails) {\\n    const r = /(\\\\.(?=[^@]+@))|(\\\\+.+(?=@))/g;\\n    return new Set(emails.map((item) => {\\n        return item.replace(r, \\'\\');\\n    })).size;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```javascript\\n/**\\n * @param {string[]} emails\\n * @return {number}\\n */\\nvar numUniqueEmails = function(emails) {\\n    const r = /(\\\\.(?=[^@]+@))|(\\\\+.+(?=@))/g;\\n    return new Set(emails.map((item) => {\\n        return item.replace(r, \\'\\');\\n    })).size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 278640,
                "title": "swift-solution-clean-and-easy-read-beats-99",
                "content": "```\\nclass Solution {\\n    func numUniqueEmails(_ emails: [String]) -> Int {\\n        guard emails.count > 0 else { return 0 }\\n        var resultSet = Set<String>()\\n        \\n        for email in emails {\\n            let seperated = email.split(separator: \"@\")\\n            let local = seperated[0], validDomain = seperated[1]\\n            var validLocal = String()\\n            \\n            for char in local where char != \".\" {\\n                guard char != \"+\" else { break }\\n                validLocal.append(char)\\n            }\\n            \\n            let validFormat = validLocal + \"@\" + validDomain\\n            resultSet.insert(String(validFormat))\\n        }\\n        return resultSet.count\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func numUniqueEmails(_ emails: [String]) -> Int {\\n        guard emails.count > 0 else { return 0 }\\n        var resultSet = Set<String>()\\n        \\n        for email in emails {\\n            let seperated = email.split(separator: \"@\")\\n            let local = seperated[0], validDomain = seperated[1]\\n            var validLocal = String()\\n            \\n            for char in local where char != \".\" {\\n                guard char != \"+\" else { break }\\n                validLocal.append(char)\\n            }\\n            \\n            let validFormat = validLocal + \"@\" + validDomain\\n            resultSet.insert(String(validFormat))\\n        }\\n        return resultSet.count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 245978,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        Map<String,Integer> m = new HashMap<>();\\n        for(String x:emails){\\n            String[] y = x.split(\"@\");\\n                String s= y[0];\\n                if(s.contains(\"+\")){\\n                    s = s.substring(0,s.indexOf(\"+\"));\\n                }\\n            if(s.contains(\".\")){\\n                String[] tmp = s.split(\".\");\\n                s = Arrays.toString(tmp); \\n            }\\n               \\n            if(!m.containsKey(s+\"@\"+y[1])){\\n                \\n                m.put(s+\"@\"+y[1],1);\\n            }\\n            \\n        }\\n        return m.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        Map<String,Integer> m = new HashMap<>();\\n        for(String x:emails){\\n            String[] y = x.split(\"@\");\\n                String s= y[0];\\n                if(s.contains(\"+\")){\\n                    s = s.substring(0,s.indexOf(\"+\"));\\n                }\\n            if(s.contains(\".\")){\\n                String[] tmp = s.split(\".\");\\n                s = Arrays.toString(tmp); \\n            }\\n               \\n            if(!m.containsKey(s+\"@\"+y[1])){\\n                \\n                m.put(s+\"@\"+y[1],1);\\n            }\\n            \\n        }\\n        return m.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 245711,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        int count=0;\\n        unordered_set<string> storage;\\n        for(auto email:emails){\\n            string temp=\"\";\\n            bool before=true;\\n            for(int i=0;i<email.length();i++){\\n                if(before){\\n                    if(email[i]==\\'.\\') i++;\\n                    if(email[i]==\\'+\\'){while(email[i]!=\\'@\\'){i++;}}\\n                    if(email[i]==\\'@\\') before=false;\\n                }\\n                temp+=email[i];\\n            }\\n            if(storage.find(temp)==storage.end()) count++;\\n            storage.insert(temp);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        int count=0;\\n        unordered_set<string> storage;\\n        for(auto email:emails){\\n            string temp=\"\";\\n            bool before=true;\\n            for(int i=0;i<email.length();i++){\\n                if(before){\\n                    if(email[i]==\\'.\\') i++;\\n                    if(email[i]==\\'+\\'){while(email[i]!=\\'@\\'){i++;}}\\n                    if(email[i]==\\'@\\') before=false;\\n                }\\n                temp+=email[i];\\n            }\\n            if(storage.find(temp)==storage.end()) count++;\\n            storage.insert(temp);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 212286,
                "title": "c-o-n-12-ms-with-fast-i-o",
                "content": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {        \\n        unordered_set<string> s;\\n        char                  str[101];\\n        \\n        for (int i = 0; i < emails.size(); ++i) {\\n            const char*  src = emails[i].c_str();\\n            const char*  end = src + emails[i].length();\\n            char*        dst = str;\\n            \\n            // Process local\\n            while (*src != \\'+\\' && *src != \\'@\\') {\\n                if (*src != \\'.\\') *dst = *src, ++dst;\\n                ++src;\\n            }\\n            \\n            while (*src != \\'@\\') ++src;\\n            \\n            // Process domain\\n            memcpy(dst, src, end - src + 1);\\n            \\n            // Update hash table\\n            s.emplace(str);\\n        }\\n        \\n        return s.size();\\n    }\\n};\\n\\n// Fast I/O\\nstatic bool     _foo = ios::sync_with_stdio(false);\\nstatic ostream* _bar = cin.tie(NULL);\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {        \\n        unordered_set<string> s;\\n        char                  str[101];\\n        \\n        for (int i = 0; i < emails.size(); ++i) {\\n            const char*  src = emails[i].c_str();\\n            const char*  end = src + emails[i].length();\\n            char*        dst = str;\\n            \\n            // Process local\\n            while (*src != \\'+\\' && *src != \\'@\\') {\\n                if (*src != \\'.\\') *dst = *src, ++dst;\\n                ++src;\\n            }\\n            \\n            while (*src != \\'@\\') ++src;\\n            \\n            // Process domain\\n            memcpy(dst, src, end - src + 1);\\n            \\n            // Update hash table\\n            s.emplace(str);\\n        }\\n        \\n        return s.size();\\n    }\\n};\\n\\n// Fast I/O\\nstatic bool     _foo = ios::sync_with_stdio(false);\\nstatic ostream* _bar = cin.tie(NULL);\\n```",
                "codeTag": "Java"
            },
            {
                "id": 207653,
                "title": "rust-simple-state-machine-and-hashset-4ms",
                "content": "```\\nuse std::collections::HashSet;\\n\\n#[derive(Debug, Copy, Clone)]\\nenum EmailParseState {\\n    Name,\\n    Plus,\\n    Domain\\n}\\n\\nimpl Solution {\\n    pub fn num_unique_emails(emails: Vec<String>) -> i32 {\\n        let mut unique_emails = HashSet::new();\\n        for email in emails {\\n            let nemail = Solution::parse_email(&email);\\n            unique_emails.insert(nemail);\\n        }\\n        unique_emails.len() as i32\\n    }\\n    \\n    fn parse_email(email: &String) -> String {\\n        let mut nemail = String::new();\\n        let mut state = EmailParseState::Name;\\n        \\n        for c in email.chars() {\\n            let (new_state, ch) = match (state, c) {\\n                (EmailParseState::Name, \\'.\\') => (state, None),\\n                (EmailParseState::Name, \\'+\\') => (EmailParseState::Plus, None),\\n                (EmailParseState::Name, \\'@\\') => (EmailParseState::Domain, Some(c)),\\n                (EmailParseState::Name, _) => (state, Some(c)),\\n                (EmailParseState::Plus, \\'@\\') => (EmailParseState::Domain, Some(c)),\\n                (EmailParseState::Plus, _) => (state, None),\\n                (EmailParseState::Domain, _) => (state, Some(c)),\\n            };            \\n            if let Some(c) = ch {\\n                nemail.push(c);\\n            }\\n            state = new_state;\\n        };\\n        nemail\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::HashSet;\\n\\n#[derive(Debug, Copy, Clone)]\\nenum EmailParseState {\\n    Name,\\n    Plus,\\n    Domain\\n}\\n\\nimpl Solution {\\n    pub fn num_unique_emails(emails: Vec<String>) -> i32 {\\n        let mut unique_emails = HashSet::new();\\n        for email in emails {\\n            let nemail = Solution::parse_email(&email);\\n            unique_emails.insert(nemail);\\n        }\\n        unique_emails.len() as i32\\n    }\\n    \\n    fn parse_email(email: &String) -> String {\\n        let mut nemail = String::new();\\n        let mut state = EmailParseState::Name;\\n        \\n        for c in email.chars() {\\n            let (new_state, ch) = match (state, c) {\\n                (EmailParseState::Name, \\'.\\') => (state, None),\\n                (EmailParseState::Name, \\'+\\') => (EmailParseState::Plus, None),\\n                (EmailParseState::Name, \\'@\\') => (EmailParseState::Domain, Some(c)),\\n                (EmailParseState::Name, _) => (state, Some(c)),\\n                (EmailParseState::Plus, \\'@\\') => (EmailParseState::Domain, Some(c)),\\n                (EmailParseState::Plus, _) => (state, None),\\n                (EmailParseState::Domain, _) => (state, Some(c)),\\n            };            \\n            if let Some(c) = ch {\\n                nemail.push(c);\\n            }\\n            state = new_state;\\n        };\\n        nemail\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 197936,
                "title": "python-solution-beat-91",
                "content": "```\\nclass Solution(object):\\n    def numUniqueEmails(self, emails):\\n        \"\"\"\\n        :type emails: List[str]\\n        :rtype: int\\n        \"\"\"\\n        if not emails:\\n            return 0\\n        def valid(email):\\n            local,host=email.split(\\'@\\')\\n            local=local.replace(\\'.\\',\\'\\')\\n            #print(local)\\n            local=local.split(\\'+\\')[0]\\n            # print(local)\\n            return local+\\'@\\'+host\\n        res=set()\\n        for email in emails:\\n            res.add(valid(email))\\n        return len(res)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numUniqueEmails(self, emails):\\n        \"\"\"\\n        :type emails: List[str]\\n        :rtype: int\\n        \"\"\"\\n        if not emails:\\n            return 0\\n        def valid(email):\\n            local,host=email.split(\\'@\\')\\n            local=local.replace(\\'.\\',\\'\\')\\n            #print(local)\\n            local=local.split(\\'+\\')[0]\\n            # print(local)\\n            return local+\\'@\\'+host\\n        res=set()\\n        for email in emails:\\n            res.add(valid(email))\\n        return len(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186824,
                "title": "python-self-explanatory-solution",
                "content": "* Self-explanatory\\n```\\nclass Solution:\\n    def numUniqueEmails(self, emails):\\n        addresses = set()\\n        for email in emails:\\n            local, domain = email.split(\"@\")\\n            local = local.split(\"+\")[0].replace(\".\", \"\")\\n            addresses.add(local + \"@\" + domain)\\n        return len(addresses)\\n```\\n* 1-liner Pythonic\\n```\\nclass Solution:\\n    def numUniqueEmails(self, emails):\\n        return len({e.split(\"@\")[0].split(\"+\")[0].replace(\".\", \"\") + e.split(\"@\")[1] for e in emails})\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails):\\n        addresses = set()\\n        for email in emails:\\n            local, domain = email.split(\"@\")\\n            local = local.split(\"+\")[0].replace(\".\", \"\")\\n            addresses.add(local + \"@\" + domain)\\n        return len(addresses)\\n```\n```\\nclass Solution:\\n    def numUniqueEmails(self, emails):\\n        return len({e.split(\"@\")[0].split(\"+\")[0].replace(\".\", \"\") + e.split(\"@\")[1] for e in emails})\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186645,
                "title": "java-clean-o-n-maxstringlen-with-and-without-split",
                "content": "**With split**\\n```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        Set<String> set = new HashSet<>();\\n        for (String email : emails){\\n            String[]parts = email.split(\"@\");\\n            String local = parseLocal(parts[0]);\\n            String domain = parts[1];\\n            set.add(local + \\'@\\' + domain);\\n        }\\n            return set.size();\\n\\n    }\\n    \\n    \\n    String parseLocal(String local){\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : local.toCharArray()){\\n            if (c != \\'.\\'){//Skip the period characters\\n                if (c == \\'+\\') return sb.toString(); //Ignore everything else\\n                sb.append(c); //Not a period and not a + character\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n}\\n\\n```\\n\\n**Without split**\\n```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        Set<String> set = new HashSet<>();\\n        for (String email : emails){\\n            String[]parts = getParts(email);\\n            String local = parseLocal(parts[0]);\\n            String domain = parts[1];\\n            set.add(local + \\'@\\' + domain);\\n        }\\n            return set.size();\\n\\n    }\\n    \\n    \\n    String parseLocal(String local){\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : local.toCharArray()){\\n            if (c != \\'.\\'){//Skip the period characters\\n                if (c == \\'+\\') return sb.toString(); //Ignore everything else\\n                sb.append(c); //Not a period and not a + character\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    String[] getParts(String email){\\n        int i = 0;\\n        while (i < email.length() && email.charAt(i) != \\'@\\') i++;\\n        return new String[]{email.substring(0, i), email.substring(i+1)};\\n    }\\n    \\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        Set<String> set = new HashSet<>();\\n        for (String email : emails){\\n            String[]parts = email.split(\"@\");\\n            String local = parseLocal(parts[0]);\\n            String domain = parts[1];\\n            set.add(local + \\'@\\' + domain);\\n        }\\n            return set.size();\\n\\n    }\\n    \\n    \\n    String parseLocal(String local){\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : local.toCharArray()){\\n            if (c != \\'.\\'){//Skip the period characters\\n                if (c == \\'+\\') return sb.toString(); //Ignore everything else\\n                sb.append(c); //Not a period and not a + character\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n}\\n\\n```\n```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        Set<String> set = new HashSet<>();\\n        for (String email : emails){\\n            String[]parts = getParts(email);\\n            String local = parseLocal(parts[0]);\\n            String domain = parts[1];\\n            set.add(local + \\'@\\' + domain);\\n        }\\n            return set.size();\\n\\n    }\\n    \\n    \\n    String parseLocal(String local){\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : local.toCharArray()){\\n            if (c != \\'.\\'){//Skip the period characters\\n                if (c == \\'+\\') return sb.toString(); //Ignore everything else\\n                sb.append(c); //Not a period and not a + character\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    String[] getParts(String email){\\n        int i = 0;\\n        while (i < email.length() && email.charAt(i) != \\'@\\') i++;\\n        return new String[]{email.substring(0, i), email.substring(i+1)};\\n    }\\n    \\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735159,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        if (emails.length == 1) {\\n            return 1;\\n        }\\n\\n        HashSet<String> emailSet = new HashSet<>();\\n        int result = 0;\\n\\n        for (String email : emails) {\\n            int com = email.indexOf(\"@\");\\n            int plus = email.indexOf(\"+\");\\n            String res = email;\\n            \\n            if (plus > 0) {\\n                res = email.substring(0, plus) + email.substring(com);\\n            }\\n            com = res.indexOf(\"@\");\\n            while (res.indexOf(\".\") < com) {\\n                com = res.indexOf(\"@\");\\n                res = res.substring(0, res.indexOf(\".\")) + res.substring(res.indexOf(\".\") + 1);\\n            }\\n\\n            if (emailSet.contains(res)) {\\n                continue;\\n            }\\n\\n            emailSet.add(res);\\n            result++;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        if (emails.length == 1) {\\n            return 1;\\n        }\\n\\n        HashSet<String> emailSet = new HashSet<>();\\n        int result = 0;\\n\\n        for (String email : emails) {\\n            int com = email.indexOf(\"@\");\\n            int plus = email.indexOf(\"+\");\\n            String res = email;\\n            \\n            if (plus > 0) {\\n                res = email.substring(0, plus) + email.substring(com);\\n            }\\n            com = res.indexOf(\"@\");\\n            while (res.indexOf(\".\") < com) {\\n                com = res.indexOf(\"@\");\\n                res = res.substring(0, res.indexOf(\".\")) + res.substring(res.indexOf(\".\") + 1);\\n            }\\n\\n            if (emailSet.contains(res)) {\\n                continue;\\n            }\\n\\n            emailSet.add(res);\\n            result++;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521760,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        unordered_set<string> uniqEmails;\\n        for(string& email: emails) {\\n            bool inDomain = false;\\n            string actEmail;\\n            int i = 0;\\n            for(int i = 0; i < email.size(); ) {\\n                char c = email[i];\\n                if (inDomain) {\\n                    actEmail.push_back(c);\\n                    i++;\\n                } else {\\n                    if (c == \\'@\\') {\\n                        actEmail.push_back(c);\\n                        inDomain = true;\\n                        i++;\\n                    } else if (c == \\'.\\') {\\n                        i++;\\n                    } else if (c == \\'+\\') {\\n                        while(email[i] != \\'@\\') {\\n                            i++;\\n                        }\\n                    } else {\\n                        actEmail.push_back(c);\\n                        i++;\\n                    }\\n                }\\n            }\\n            uniqEmails.insert(actEmail);\\n        }\\n        return uniqEmails.size();\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        addresses = set()\\n\\n        for email in emails:\\n            local, domain = email.split(\\'@\\')\\n            if \\'+\\' in local:\\n                local = local[:local.index(\\'+\\')]\\n            local = local.replace(\\'.\\', \\'\\')\\n            addresses.add(local + \\'@\\' + domain)\\n        \\n        return len(addresses)\\n```\\n\\n```Java []\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        Set<String> es = new HashSet<>();\\n        \\n        for (String e: emails) {\\n            es.add(strip(e));\\n        }\\n        return es.size();\\n    }\\n    public String strip(String e) {\\n        int i = 0;\\n        StringBuilder res = new StringBuilder();\\n        \\n        while (i < e.length()) {\\n            char c = e.charAt(i);\\n            if (c == \\'+\\') {\\n                i = e.indexOf(\\'@\\');\\n                continue;\\n            } else if (c == \\'@\\') {\\n                res.append(e.substring(i));\\n                return res.toString();\\n            } else if (c != \\'.\\')\\n                res.append(c);\\n            i++;\\n        }\\n        return res.toString();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        unordered_set<string> uniqEmails;\\n        for(string& email: emails) {\\n            bool inDomain = false;\\n            string actEmail;\\n            int i = 0;\\n            for(int i = 0; i < email.size(); ) {\\n                char c = email[i];\\n                if (inDomain) {\\n                    actEmail.push_back(c);\\n                    i++;\\n                } else {\\n                    if (c == \\'@\\') {\\n                        actEmail.push_back(c);\\n                        inDomain = true;\\n                        i++;\\n                    } else if (c == \\'.\\') {\\n                        i++;\\n                    } else if (c == \\'+\\') {\\n                        while(email[i] != \\'@\\') {\\n                            i++;\\n                        }\\n                    } else {\\n                        actEmail.push_back(c);\\n                        i++;\\n                    }\\n                }\\n            }\\n            uniqEmails.insert(actEmail);\\n        }\\n        return uniqEmails.size();\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        addresses = set()\\n\\n        for email in emails:\\n            local, domain = email.split(\\'@\\')\\n            if \\'+\\' in local:\\n                local = local[:local.index(\\'+\\')]\\n            local = local.replace(\\'.\\', \\'\\')\\n            addresses.add(local + \\'@\\' + domain)\\n        \\n        return len(addresses)\\n```\n```Java []\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        Set<String> es = new HashSet<>();\\n        \\n        for (String e: emails) {\\n            es.add(strip(e));\\n        }\\n        return es.size();\\n    }\\n    public String strip(String e) {\\n        int i = 0;\\n        StringBuilder res = new StringBuilder();\\n        \\n        while (i < e.length()) {\\n            char c = e.charAt(i);\\n            if (c == \\'+\\') {\\n                i = e.indexOf(\\'@\\');\\n                continue;\\n            } else if (c == \\'@\\') {\\n                res.append(e.substring(i));\\n                return res.toString();\\n            } else if (c != \\'.\\')\\n                res.append(c);\\n            i++;\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141312,
                "title": "simple-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n*maxsizeof(email element))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        unordered_set<string>s;\\n        string x;\\n        for(int i=0;i<emails.size();i++)\\n        {\\n            x=\"\";\\n            for(int j=0;j<emails[i].length();)\\n            {\\n                if(emails[i][j]==\\'+\\')\\n                {\\n                    while(emails[i][j]!=\\'@\\')\\n                    {\\n                       j++;\\n                    }\\n                    while(j<emails[i].length())\\n                    {\\n                        x+=emails[i][j];\\n                        j++;\\n                    }\\n                }\\n                else if(emails[i][j]==\\'@\\')\\n                {\\n                    while(j<emails[i].length())\\n                    {\\n                        x+=emails[i][j];\\n                        j++;\\n                    }\\n                }\\n                else\\n                {\\n                    if(emails[i][j]==\\'.\\')\\n                    {\\n                        j++;\\n                        continue;\\n                    }\\n                    x+=emails[i][j];\\n                    \\n                }\\n                j++;\\n\\n            }\\n            \\n            s.insert(x);\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        unordered_set<string>s;\\n        string x;\\n        for(int i=0;i<emails.size();i++)\\n        {\\n            x=\"\";\\n            for(int j=0;j<emails[i].length();)\\n            {\\n                if(emails[i][j]==\\'+\\')\\n                {\\n                    while(emails[i][j]!=\\'@\\')\\n                    {\\n                       j++;\\n                    }\\n                    while(j<emails[i].length())\\n                    {\\n                        x+=emails[i][j];\\n                        j++;\\n                    }\\n                }\\n                else if(emails[i][j]==\\'@\\')\\n                {\\n                    while(j<emails[i].length())\\n                    {\\n                        x+=emails[i][j];\\n                        j++;\\n                    }\\n                }\\n                else\\n                {\\n                    if(emails[i][j]==\\'.\\')\\n                    {\\n                        j++;\\n                        continue;\\n                    }\\n                    x+=emails[i][j];\\n                    \\n                }\\n                j++;\\n\\n            }\\n            \\n            s.insert(x);\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962322,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func numUniqueEmails(_ emails: [String]) -> Int {\\n        \\n        func bare(_ s: String) -> String {\\n            let p = s.components(separatedBy: \"@\")\\n            let n = p[0]\\n                .components(separatedBy: \"+\")\\n                .first!\\n                .components(separatedBy: \".\")\\n                .joined()\\n            return \"\\\\(n)@\\\\(p[1])\"\\n        }\\n        \\n        return Set(emails.map(bare)).count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func numUniqueEmails(_ emails: [String]) -> Int {\\n        \\n        func bare(_ s: String) -> String {\\n            let p = s.components(separatedBy: \"@\")\\n            let n = p[0]\\n                .components(separatedBy: \"+\")\\n                .first!\\n                .components(separatedBy: \".\")\\n                .joined()\\n            return \"\\\\(n)@\\\\(p[1])\"\\n        }\\n        \\n        return Set(emails.map(bare)).count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2874912,
                "title": "rust-a-fast-functional-solution",
                "content": "First, here\\'s how you can solve the problem without referencing any crates.\\n\\n```\\nimpl Solution {\\n    pub fn num_unique_emails(emails: Vec<String>) -> i32 {\\n        use std::collections::HashSet;\\n        \\n        emails\\n            .iter()\\n            .map(|string| {\\n                let mut parts = string.split(\\'@\\');\\n                (parts.next().unwrap(), parts.next().unwrap())\\n            })\\n            .map(|(local_name, domain_name)| {\\n                (\\n                    local_name\\n                        .chars()\\n                        .take_while(|char| *char != \\'+\\')\\n                        .filter(|char| *char != \\'.\\')\\n                        .collect::<String>(),\\n                    domain_name.to_owned(),\\n                )\\n            })\\n            .collect::<HashSet<(String, String)>>()\\n            .len() as i32\\n    }\\n}\\n```\\n\\nA bit ugly, but it works. However, if you\\'re fine with adding `itertools` to your project, you can do better.\\n\\n```\\nimpl Solution {\\n    pub fn num_unique_emails(emails: Vec<String>) -> i32 {\\n        use itertools::Itertools;\\n        \\n        emails\\n            .iter()\\n            .map(|string| string.split(\\'@\\').collect_tuple().expect(\"An email adress should consist of two substrings separated by a \\'@\\'.\"))\\n            .map(|(local_name, domain_name)| {\\n                (\\n                    local_name\\n                        .chars()\\n                        .take_while(|char| *char != \\'+\\')\\n                        .filter(|char| *char != \\'.\\')\\n                        .collect::<String>(),\\n                    domain_name.to_owned(),\\n                )\\n            })\\n            .unique()\\n            .count() as i32\\n    }\\n}\\n```\\n\\nNotice that `Itertools::unique()` lets us avoid an explicit `HashSet` definition (though it does something similar under the hood) and, more importantly, how `Itertools::collect_tuple()` lets us avoid two `next()` calls. Since Rust doesn\\'t allow collecting into an array, this is the best we can do.",
                "solutionTags": [
                    "Rust",
                    "String"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn num_unique_emails(emails: Vec<String>) -> i32 {\\n        use std::collections::HashSet;\\n        \\n        emails\\n            .iter()\\n            .map(|string| {\\n                let mut parts = string.split(\\'@\\');\\n                (parts.next().unwrap(), parts.next().unwrap())\\n            })\\n            .map(|(local_name, domain_name)| {\\n                (\\n                    local_name\\n                        .chars()\\n                        .take_while(|char| *char != \\'+\\')\\n                        .filter(|char| *char != \\'.\\')\\n                        .collect::<String>(),\\n                    domain_name.to_owned(),\\n                )\\n            })\\n            .collect::<HashSet<(String, String)>>()\\n            .len() as i32\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn num_unique_emails(emails: Vec<String>) -> i32 {\\n        use itertools::Itertools;\\n        \\n        emails\\n            .iter()\\n            .map(|string| string.split(\\'@\\').collect_tuple().expect(\"An email adress should consist of two substrings separated by a \\'@\\'.\"))\\n            .map(|(local_name, domain_name)| {\\n                (\\n                    local_name\\n                        .chars()\\n                        .take_while(|char| *char != \\'+\\')\\n                        .filter(|char| *char != \\'.\\')\\n                        .collect::<String>(),\\n                    domain_name.to_owned(),\\n                )\\n            })\\n            .unique()\\n            .count() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2842080,
                "title": "very-easy-to-understand-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        unordered_set<string> store;\\n        for(auto& str : emails){\\n            int l=str.size();\\n            int i=0,j=0;\\n            string s =\"\";\\n            bool flag = true;\\n            while(i<l && str[i] != \\'@\\'){\\n                if(str[i]==\\'+\\'){\\n                    flag = false;\\n                }\\n                else if(flag && str[i] != \\'.\\'){\\n                    s += str[i];\\n                }\\n                ++i;\\n            }\\n            for(j=i; j<l; ++j){\\n                s += str[j];\\n            }\\n            store.insert(s);\\n        }\\n        return store.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        unordered_set<string> store;\\n        for(auto& str : emails){\\n            int l=str.size();\\n            int i=0,j=0;\\n            string s =\"\";\\n            bool flag = true;\\n            while(i<l && str[i] != \\'@\\'){\\n                if(str[i]==\\'+\\'){\\n                    flag = false;\\n                }\\n                else if(flag && str[i] != \\'.\\'){\\n                    s += str[i];\\n                }\\n                ++i;\\n            }\\n            for(j=i; j<l; ++j){\\n                s += str[j];\\n            }\\n            store.insert(s);\\n        }\\n        return store.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838282,
                "title": "cpp-very-easy-to-understand-map",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& arr) \\n    {\\n        unordered_map<string,int>mp;\\n        \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            string str = arr[i];\\n            string s =\"\";\\n            \\n            int pos = str.find(\\'@\\');\\n            string temp1 = str.substr(0,pos);\\n            string temp2 = str.substr(pos,str.length());\\n            \\n            int idx = 0;\\n            while(idx < temp1.length())\\n            {\\n                if(temp1[idx]==\\'+\\')\\n                {\\n                    break;\\t\\n                }\\n                else if(temp1[idx]==\\'.\\')\\n                {\\n                    idx++;\\n                }\\n                else \\n                {\\n                    s.push_back(temp1[idx]);\\n                    idx++;\\n                }\\n            }   \\n            mp[s+temp2]++;\\n        }\\n        return mp.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& arr) \\n    {\\n        unordered_map<string,int>mp;\\n        \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            string str = arr[i];\\n            string s =\"\";\\n            \\n            int pos = str.find(\\'@\\');\\n            string temp1 = str.substr(0,pos);\\n            string temp2 = str.substr(pos,str.length());\\n            \\n            int idx = 0;\\n            while(idx < temp1.length())\\n            {\\n                if(temp1[idx]==\\'+\\')\\n                {\\n                    break;\\t\\n                }\\n                else if(temp1[idx]==\\'.\\')\\n                {\\n                    idx++;\\n                }\\n                else \\n                {\\n                    s.push_back(temp1[idx]);\\n                    idx++;\\n                }\\n            }   \\n            mp[s+temp2]++;\\n        }\\n        return mp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833783,
                "title": "java-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n        for(String email : emails){\\n            String[] split = email.split(\"@\");\\n            String localName = split[0].replace(\".\", \"\");\\n            String domainName = split[1];\\n            int index = localName.indexOf(\\'+\\');\\n            if(index >= 0)\\n                localName = localName.substring(0, index);\\n            String address = localName + \\'@\\' + domainName;\\n            map.put(address, map.getOrDefault(address, 0) + 1);\\n        }\\n        return map.keySet().size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n        for(String email : emails){\\n            String[] split = email.split(\"@\");\\n            String localName = split[0].replace(\".\", \"\");\\n            String domainName = split[1];\\n            int index = localName.indexOf(\\'+\\');\\n            if(index >= 0)\\n                localName = localName.substring(0, index);\\n            String address = localName + \\'@\\' + domainName;\\n            map.put(address, map.getOrDefault(address, 0) + 1);\\n        }\\n        return map.keySet().size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788940,
                "title": "100-t-c-easy-fast-short-solution",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```\\n```\\n        HashMap<String, Integer> map = new HashMap<>();\\n        for(String s: emails){\\n            int indMail = s.indexOf(\\'@\\');\\n            StringBuilder sb = new StringBuilder();\\n            for(char c: s.toCharArray()){\\n                if (c == \\'@\\' || c == \\'+\\') break;\\n                if (c != \\'.\\') sb.append(c);\\n            }\\n            sb.append(s.substring(indMail));\\n            map.put(sb.toString(), 1);\\n        }\\n        return map.keySet().size();",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2651452,
                "title": "java-easy-understanding-hashset",
                "content": "```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        HashSet<String> cnt=new LinkedHashSet<>();\\n        int index=0;\\n        for(String email:emails)\\n        {\\n            String arr[]=email.split(\"@\");\\n           index=arr[0].indexOf(\"+\");\\n                if(index>0)\\n            arr[0]=arr[0].substring(0,index);\\n            arr[0]=arr[0].replaceAll(\"\\\\\\\\.\",\"\");\\n            cnt.add(arr[0]+\"@\"+arr[1]);\\n            \\n        }\\n        return cnt.size();\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        HashSet<String> cnt=new LinkedHashSet<>();\\n        int index=0;\\n        for(String email:emails)\\n        {\\n            String arr[]=email.split(\"@\");\\n           index=arr[0].indexOf(\"+\");\\n                if(index>0)\\n            arr[0]=arr[0].substring(0,index);\\n            arr[0]=arr[0].replaceAll(\"\\\\\\\\.\",\"\");\\n            cnt.add(arr[0]+\"@\"+arr[1]);\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2585532,
                "title": "js-simple-solution-with-hashmap",
                "content": "```\\nconst regex = /[.]+/g;\\nconst getLocalName = (name) => {\\n    name = name.split(\\'+\\')[0];\\n    name = name.replace(regex, \\'\\');\\n    return name;\\n};\\n\\nvar numUniqueEmails = function(emails) {\\n    const hashmap = new Map();\\n    let output = 0;\\n    \\n    for (let i = 0; i < emails.length; i++) {\\n        const email = emails[i];\\n        const [localName, domain] = email.split(\\'@\\');\\n        \\n        const baseEmail = `${getLocalName(localName)}@${domain}`;\\n        if (!hashmap.has(baseEmail)) {\\n            hashmap.set(baseEmail, 1);\\n            output++;\\n        }\\n    }\\n    \\n    return output;\\n}; \\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst regex = /[.]+/g;\\nconst getLocalName = (name) => {\\n    name = name.split(\\'+\\')[0];\\n    name = name.replace(regex, \\'\\');\\n    return name;\\n};\\n\\nvar numUniqueEmails = function(emails) {\\n    const hashmap = new Map();\\n    let output = 0;\\n    \\n    for (let i = 0; i < emails.length; i++) {\\n        const email = emails[i];\\n        const [localName, domain] = email.split(\\'@\\');\\n        \\n        const baseEmail = `${getLocalName(localName)}@${domain}`;\\n        if (!hashmap.has(baseEmail)) {\\n            hashmap.set(baseEmail, 1);\\n            output++;\\n        }\\n    }\\n    \\n    return output;\\n}; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2279660,
                "title": "10-lines-simple-python-solution-hashset-python-built-in-functions",
                "content": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        unique = set()\\n        \\n        for e in emails:\\n            local,domain = e.split(\\'@\\')\\n            local = local.split(\\'+\\')[0]\\n            local = local.replace(\\'.\\',\"\")\\n            unique.add((local,domain))\\n        return len(unique)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        unique = set()\\n        \\n        for e in emails:\\n            local,domain = e.split(\\'@\\')\\n            local = local.split(\\'+\\')[0]\\n            local = local.replace(\\'.\\',\"\")\\n            unique.add((local,domain))\\n        return len(unique)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2226436,
                "title": "my-c-solution-without-inbuilt-function",
                "content": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        unordered_set<string> s;\\n        for(int i=0;i<emails.size();i++) {\\n            int j=0;\\n            string str=\"\";\\n            while(emails[i][j]!=\\'@\\') {\\n                if(emails[i][j]==\\'+\\')   break;\\n                if(emails[i][j]!=\\'.\\')    str+=emails[i][j];\\n                j++;\\n            }\\n            while(emails[i][j]!=\\'@\\')    j++;\\n            while(emails[i][j]) str+=emails[i][j++];\\n            s.insert(str);\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        unordered_set<string> s;\\n        for(int i=0;i<emails.size();i++) {\\n            int j=0;\\n            string str=\"\";\\n            while(emails[i][j]!=\\'@\\') {\\n                if(emails[i][j]==\\'+\\')   break;\\n                if(emails[i][j]!=\\'.\\')    str+=emails[i][j];\\n                j++;\\n            }\\n            while(emails[i][j]!=\\'@\\')    j++;\\n            while(emails[i][j]) str+=emails[i][j++];\\n            s.insert(str);\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1971189,
                "title": "python-3-with-comment-explaination",
                "content": "```\\n\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        email_new = []\\n        for email in emails:\\n            #split local and domain\\n            email = email.split(\\'@\\')\\n            #remove \\'.\\' from local\\n            email[0] = email[0].replace(\\'.\\',\\'\\')\\n            #remove after \\'+\\'\\n            email[0] = email[0].split(\"+\")[0]\\n            #combine local and domain\\n            email_new.append(email[0] + \\'@\\' + email[1])\\n        return len(list(set(email_new)))\\n        \\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        email_new = []\\n        for email in emails:\\n            #split local and domain\\n            email = email.split(\\'@\\')\\n            #remove \\'.\\' from local\\n            email[0] = email[0].replace(\\'.\\',\\'\\')\\n            #remove after \\'+\\'\\n            email[0] = email[0].split(\"+\")[0]\\n            #combine local and domain\\n            email_new.append(email[0] + \\'@\\' + email[1])\\n        return len(list(set(email_new)))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1946279,
                "title": "easy-python-beginner-friendly",
                "content": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        m=set()\\n        for i in emails:\\n            if i.count(\".\")>0 and i.count(\"@\")>0:\\n                a,b=map(str,i.split(\"@\"))\\n                a=a.replace(\".\",\"\")\\n                # print(a,b)\\n                k=0\\n                for i in range(len(a)):\\n                    if a[i]!=\"+\":\\n                        k+=1\\n                    else:\\n                        break\\n                # print(a[:k],\"---\",b)\\n                m.add(a[:k]+\"@\"+b)\\n        return len(m)\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        m=set()\\n        for i in emails:\\n            if i.count(\".\")>0 and i.count(\"@\")>0:\\n                a,b=map(str,i.split(\"@\"))\\n                a=a.replace(\".\",\"\")\\n                # print(a,b)\\n                k=0\\n                for i in range(len(a)):\\n                    if a[i]!=\"+\":\\n                        k+=1\\n                    else:\\n                        break\\n                # print(a[:k],\"---\",b)\\n                m.add(a[:k]+\"@\"+b)\\n        return len(m)\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1779664,
                "title": "go-easy",
                "content": "```\\nfunc numUniqueEmails(emails []string) int {\\n    d := make(map[string]bool)\\n    \\n    for _, email := range emails {\\n        parts := strings.Split(email, \"@\")\\n        local := strings.Split(parts[0], \"+\")\\n        check := strings.Replace(local[0], \".\", \"\", -1) + \"@\" + parts[1]\\n        \\n        d[check] = true\\n    }\\n    \\n    return len(d)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc numUniqueEmails(emails []string) int {\\n    d := make(map[string]bool)\\n    \\n    for _, email := range emails {\\n        parts := strings.Split(email, \"@\")\\n        local := strings.Split(parts[0], \"+\")\\n        check := strings.Replace(local[0], \".\", \"\", -1) + \"@\" + parts[1]\\n        \\n        d[check] = true\\n    }\\n    \\n    return len(d)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1598520,
                "title": "c-very-easy-logic-with-explanation-simple-and-best-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        unordered_set<string>us;\\n        for(int i = 0; i<emails.size(); i++){\\n            string s = \"\";\\n            for(int j = 0; j<emails[i].size();j++){\\n                //if we detect a @ then we will append everything behing @ to the newstring we are making to be inserted into the set\\n                if(emails[i][j] == \\'@\\'){\\n                    s.push_back(emails[i][j]);\\n                    string news(emails[i].begin()+j+1, emails[i].end());\\n                    s+=news;\\n                    break;\\n                }\\n                \\n                //if we detect a . (period) we are going todo nothing and just return to the for loop for next iteration\\n                else if(emails[i][j] == \\'.\\'){\\n                    continue;\\n                }\\n                \\n                //if we detect a + then we will increment the position of iterator iterating the string until it sees an @ character\\n                else if(emails[i][j] == \\'+\\'){\\n                    while(emails[i][j+1]!=\\'@\\'){\\n                        j++;\\n                    }\\n                    continue;\\n                }\\n                \\n                s.push_back(emails[i][j]);\\n            }\\n            //after construction of the whole string we will insert it into the set so as to eliminate the duplication\\n            us.insert(s);\\n        }\\n        \\n        return us.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        unordered_set<string>us;\\n        for(int i = 0; i<emails.size(); i++){\\n            string s = \"\";\\n            for(int j = 0; j<emails[i].size();j++){\\n                //if we detect a @ then we will append everything behing @ to the newstring we are making to be inserted into the set\\n                if(emails[i][j] == \\'@\\'){\\n                    s.push_back(emails[i][j]);\\n                    string news(emails[i].begin()+j+1, emails[i].end());\\n                    s+=news;\\n                    break;\\n                }\\n                \\n                //if we detect a . (period) we are going todo nothing and just return to the for loop for next iteration\\n                else if(emails[i][j] == \\'.\\'){\\n                    continue;\\n                }\\n                \\n                //if we detect a + then we will increment the position of iterator iterating the string until it sees an @ character\\n                else if(emails[i][j] == \\'+\\'){\\n                    while(emails[i][j+1]!=\\'@\\'){\\n                        j++;\\n                    }\\n                    continue;\\n                }\\n                \\n                s.push_back(emails[i][j]);\\n            }\\n            //after construction of the whole string we will insert it into the set so as to eliminate the duplication\\n            us.insert(s);\\n        }\\n        \\n        return us.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1493503,
                "title": "5-line-solution-in-python",
                "content": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        for i, email in enumerate(emails):\\n            local_name, domain_name = email.split(\"@\")\\n            local_name = local_name.split(\"+\", 1)[0].replace(\".\", \"\")\\n            emails[i] = f\"{local_name}@{domain_name}\"\\n        return len(set(emails))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        for i, email in enumerate(emails):\\n            local_name, domain_name = email.split(\"@\")\\n            local_name = local_name.split(\"+\", 1)[0].replace(\".\", \"\")\\n            emails[i] = f\"{local_name}@{domain_name}\"\\n        return len(set(emails))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1492496,
                "title": "unique-email-simple-java-solution",
                "content": "```\\nclass Solution {\\npublic int numUniqueEmails(String[] emails) {\\n    if(emails == null || emails.length == 0) {\\n        return -1;\\n    }\\n    Set set = new HashSet<>();\\n    for(String email : emails) {\\n        StringBuilder sb = new StringBuilder();\\n        for(char c: email.toCharArray()) {\\n            if (c == \\'.\\') continue;\\n            if (c == \\'+\\') break;\\n            if (c == \\'@\\') break; // this line need be added to make the older version work.\\n            sb.append(c);\\n        }\\n    String cur = (sb.toString() + email.substring(email.indexOf(\\'@\\'))).toLowerCase();\\n    set.add(cur);\\n    }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic int numUniqueEmails(String[] emails) {\\n    if(emails == null || emails.length == 0) {\\n        return -1;\\n    }\\n    Set set = new HashSet<>();\\n    for(String email : emails) {\\n        StringBuilder sb = new StringBuilder();\\n        for(char c: email.toCharArray()) {\\n            if (c == \\'.\\') continue;\\n            if (c == \\'+\\') break;\\n            if (c == \\'@\\') break; // this line need be added to make the older version work.\\n            sb.append(c);\\n        }\\n    String cur = (sb.toString() + email.substring(email.indexOf(\\'@\\'))).toLowerCase();\\n    set.add(cur);\\n    }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1490672,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n   public int numUniqueEmails(String[] emails) {\\n       Set<String> result = new HashSet<>();\\n       for(String id:emails){\\n           String prt[]=id.split(\"@\");\\n           prt[0]=prt[0].replaceAll(\"\\\\\\\\.\",\"\");\\n           result.add(prt[0].split(\"\\\\\\\\+\")[0]+\"@\"+prt[1]);\\n       }\\n       return result.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public int numUniqueEmails(String[] emails) {\\n       Set<String> result = new HashSet<>();\\n       for(String id:emails){\\n           String prt[]=id.split(\"@\");\\n           prt[0]=prt[0].replaceAll(\"\\\\\\\\.\",\"\");\\n           result.add(prt[0].split(\"\\\\\\\\+\")[0]+\"@\"+prt[1]);\\n       }\\n       return result.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1489507,
                "title": "c-set",
                "content": "class Solution\\n{\\npublic:\\n\\n    int numUniqueEmails(vector<string> &emails)\\n    {\\n        set<string> set;\\n        for (auto i : emails)\\n        {\\n            string str;\\n            for (char j : i)\\n            {\\n                if (j == \\'+\\' or j == \\'@\\')\\n                {\\n                    break;\\n                }\\n\\n                if (j == \\'.\\')\\n                {\\n                    continue;\\n                }\\n                str.push_back(j);\\n            }\\n            str.append(i.substr(i.find(\\'@\\')));\\n            set.insert(str);\\n        }\\n\\n        return set.size();\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution\\n{\\npublic:\\n\\n    int numUniqueEmails(vector<string> &emails)\\n    {\\n        set<string> set;\\n        for (auto i : emails)\\n        {\\n            string str;\\n            for (char j : i)\\n            {\\n                if (j == \\'+\\' or j == \\'@\\')\\n                {\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1488940,
                "title": "python-solution-one-line-regex",
                "content": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        return len(set(map(lambda s: re.sub(\\'\\\\.(?=.*@)|\\\\+.*(?=@)\\', \\'\\', s), emails)))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        return len(set(map(lambda s: re.sub(\\'\\\\.(?=.*@)|\\\\+.*(?=@)\\', \\'\\', s), emails)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488870,
                "title": "python-clean-smooth-with-a-hint-of-lemon-linear-pass-set-explained-o-nm",
                "content": "Please upvote if this has helped you! \\uD83C\\uDF4B\\n\\n```python\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        \"\"\"\\n            To solve this problem, we just need to loop through the emails and sanitize it as specified in the problem above.\\n            We can use a set to find out the number of unique emails after we have cleaned it up.\\n            \\n            Time: O(nm) - we iterate through n emails with worst case m chars. The m chars is from having to call split(), replace(), and index() will at worst case go through all m chars.\\n            Space: O(nm) - our set holds worst case all n strings with m chars if they are not unique.\\n        \"\"\"\\n        \\n        # Replace \\'.\\' with \\'\\'\\n        # Replace everything substring \\'+\\' and use a set\\n        email_set = set()\\n        for email in emails:\\n            name, domain = email.split(\\'@\\')\\n            name = name.replace(\\'.\\', \\'\\')\\n            \\n            if \\'+\\' in name:\\n                name = name[:name.index(\\'+\\')]\\n                \\n            email_set.add(name + \\'@\\' + domain)\\n        \\n        return len(email_set)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        \"\"\"\\n            To solve this problem, we just need to loop through the emails and sanitize it as specified in the problem above.\\n            We can use a set to find out the number of unique emails after we have cleaned it up.\\n            \\n            Time: O(nm) - we iterate through n emails with worst case m chars. The m chars is from having to call split(), replace(), and index() will at worst case go through all m chars.\\n            Space: O(nm) - our set holds worst case all n strings with m chars if they are not unique.\\n        \"\"\"\\n        \\n        # Replace \\'.\\' with \\'\\'\\n        # Replace everything substring \\'+\\' and use a set\\n        email_set = set()\\n        for email in emails:\\n            name, domain = email.split(\\'@\\')\\n            name = name.replace(\\'.\\', \\'\\')\\n            \\n            if \\'+\\' in name:\\n                name = name[:name.index(\\'+\\')]\\n                \\n            email_set.add(name + \\'@\\' + domain)\\n        \\n        return len(email_set)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488819,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string> &emails) \\n    {    \\n        int res = 0;  \\n        unordered_map <string, int> mp;\\n        \\n        for(int i=0; i<emails.size(); i++)\\n        {\\n            string temp = emails[i];\\n            string s = \"\";\\n            int x = 1;\\n            \\n            for(int j=0; temp[j]; j++)\\n            {\\n                if(temp[j] == \\'+\\')\\n                {\\n                    int k = j;\\n                    while(temp[k] != \\'@\\')\\n                        k++;\\n                    j = k;\\n                }\\n                \\n                if(temp[j] == \\'@\\')\\n                    x = 0;   \\n                if(temp[j] == \\'.\\' && x)\\n                    continue;\\n                \\n                s += temp[j];\\n            }\\n            \\n            if(mp[s])\\n                continue;\\n            \\n            mp[s]++;\\n            res++;\\n        }\\n        return res;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string> &emails) \\n    {    \\n        int res = 0;  \\n        unordered_map <string, int> mp;\\n        \\n        for(int i=0; i<emails.size(); i++)\\n        {\\n            string temp = emails[i];\\n            string s = \"\";\\n            int x = 1;\\n            \\n            for(int j=0; temp[j]; j++)\\n            {\\n                if(temp[j] == \\'+\\')\\n                {\\n                    int k = j;\\n                    while(temp[k] != \\'@\\')\\n                        k++;\\n                    j = k;\\n                }\\n                \\n                if(temp[j] == \\'@\\')\\n                    x = 0;   \\n                if(temp[j] == \\'.\\' && x)\\n                    continue;\\n                \\n                s += temp[j];\\n            }\\n            \\n            if(mp[s])\\n                continue;\\n            \\n            mp[s]++;\\n            res++;\\n        }\\n        return res;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1466624,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& arr) {\\n        set<string> st; \\n        int n = arr.size();       \\n        for(int i=0;i<n;i++){\\n            string email = arr[i]; \\n            int pos = email.find(\\'@\\');\\n            string domain = email.substr(pos);\\n            string local = \"\";\\n            int j = 0;\\n            while(j < pos){\\n                if(email[j] == \\'.\\'){\\n                    j++;\\n                    continue;\\n                }else if(email[j] == \\'+\\')\\n                        break;\\n                    else\\n                        local += email[j];\\n                j++;\\n            }\\n            st.insert(local+domain);\\n        }\\n        return st.size();\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& arr) {\\n        set<string> st; \\n        int n = arr.size();       \\n        for(int i=0;i<n;i++){\\n            string email = arr[i]; \\n            int pos = email.find(\\'@\\');\\n            string domain = email.substr(pos);\\n            string local = \"\";\\n            int j = 0;\\n            while(j < pos){\\n                if(email[j] == \\'.\\'){\\n                    j++;\\n                    continue;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1387902,
                "title": "java-solution-using-hashset",
                "content": "```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        HashSet<String> hs = new HashSet<>();\\n        \\n        for(String s : emails){\\n            int split = s.indexOf(\"@\");\\n            String local_name = s.substring(0, split);\\n            String domain_name = s.substring(split);\\n            \\n            if(local_name.contains(\"+\")){\\n                int plus = local_name.indexOf(\"+\");\\n                local_name = local_name.substring(0, plus);\\n            }\\n            \\n            local_name = local_name.replaceAll(\"\\\\\\\\.\",\"\");\\n            String email = local_name + domain_name;\\n            hs.add(email);\\n        }\\n        return hs.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        HashSet<String> hs = new HashSet<>();\\n        \\n        for(String s : emails){\\n            int split = s.indexOf(\"@\");\\n            String local_name = s.substring(0, split);\\n            String domain_name = s.substring(split);\\n            \\n            if(local_name.contains(\"+\")){\\n                int plus = local_name.indexOf(\"+\");\\n                local_name = local_name.substring(0, plus);\\n            }\\n            \\n            local_name = local_name.replaceAll(\"\\\\\\\\.\",\"\");\\n            String email = local_name + domain_name;\\n            hs.add(email);\\n        }\\n        return hs.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359475,
                "title": "c-simple-and-clean",
                "content": "```\\nclass Solution {\\npublic:\\n    string filter(string &s) {\\n        string str = \"\";\\n        int n = s.length();\\n        for(int i = 0; i<n; i++) {\\n            if(s[i] == \\'.\\') continue;\\n            if(s[i] == \\'+\\' || s[i] == \\'@\\') break;\\n            str.push_back(s[i]);\\n        }\\n        return str;\\n    }\\n    int numUniqueEmails(vector<string>& emails) {\\n        set<string> st;\\n\\n        for(string &email : emails) {\\n            string domain = email.substr(email.find(\\'@\\'));\\n            email = filter(email);\\n            st.insert(email+domain);\\n        }\\n        \\n        return (int)st.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string filter(string &s) {\\n        string str = \"\";\\n        int n = s.length();\\n        for(int i = 0; i<n; i++) {\\n            if(s[i] == \\'.\\') continue;\\n            if(s[i] == \\'+\\' || s[i] == \\'@\\') break;\\n            str.push_back(s[i]);\\n        }\\n        return str;\\n    }\\n    int numUniqueEmails(vector<string>& emails) {\\n        set<string> st;\\n\\n        for(string &email : emails) {\\n            string domain = email.substr(email.find(\\'@\\'));\\n            email = filter(email);\\n            st.insert(email+domain);\\n        }\\n        \\n        return (int)st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1205452,
                "title": "simple-solution-in-java",
                "content": "```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        Set<String> set=new HashSet<>();\\n        \\n        for(String email:emails){\\n            //tmp[0]->local name\\n            //tmp[1]->domain name\\n            String[] tmp=email.split(\"@\");\\n            //Splitting local by \\'+\\'\\n            String[] local=tmp[0].split(\"\\\\\\\\+\");\\n            //Adding the email\\n            set.add(local[0].replace(\".\",\"\")+\"@\"+tmp[1]);\\n        }\\n        \\n        return set.size();\\n    }\\n}\\n```\\nPlease **upvote**, if you like the solution:)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        Set<String> set=new HashSet<>();\\n        \\n        for(String email:emails){\\n            //tmp[0]->local name\\n            //tmp[1]->domain name\\n            String[] tmp=email.split(\"@\");\\n            //Splitting local by \\'+\\'\\n            String[] local=tmp[0].split(\"\\\\\\\\+\");\\n            //Adding the email\\n            set.add(local[0].replace(\".\",\"\")+\"@\"+tmp[1]);\\n        }\\n        \\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194322,
                "title": "python-97-85-4-lines-and-1-line-solutions",
                "content": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        for index in range(len(emails)):\\n            left, right = emails[index].split(\\'@\\')\\n            emails[index] = left.replace(\\'.\\', \\'\\').split(\\'+\\')[0] + \\'@\\' + right\\n        return len(set(emails))\\n```\\n\\n```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        return len(set([email.split(\\'@\\')[0].replace(\\'.\\', \\'\\').split(\\'+\\')[0] + \\'@\\' + email.split(\\'@\\')[1] for email in emails]))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        for index in range(len(emails)):\\n            left, right = emails[index].split(\\'@\\')\\n            emails[index] = left.replace(\\'.\\', \\'\\').split(\\'+\\')[0] + \\'@\\' + right\\n        return len(set(emails))\\n```\n```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        return len(set([email.split(\\'@\\')[0].replace(\\'.\\', \\'\\').split(\\'+\\')[0] + \\'@\\' + email.split(\\'@\\')[1] for email in emails]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1047458,
                "title": "python3-simple-solution-using-set",
                "content": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails):\\n        s = set()\\n        for i in emails:\\n            a, b = i.split(\\'@\\')\\n            if \\'+\\' in a:\\n                a = a[:a.index(\\'+\\')]\\n            s.add(a.replace(\\'.\\',\\'\\') + \\'@\\' + b)\\n        return len(s)\\n```\\nIf you like the solution, please vote for this.",
                "solutionTags": [
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails):\\n        s = set()\\n        for i in emails:\\n            a, b = i.split(\\'@\\')\\n            if \\'+\\' in a:\\n                a = a[:a.index(\\'+\\')]\\n            s.add(a.replace(\\'.\\',\\'\\') + \\'@\\' + b)\\n        return len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 965851,
                "title": "c-easy-logic",
                "content": "class Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        set<string> se;\\n        for(auto x:emails)\\n        {\\n            int pos=x.find(\\'@\\');\\n            string ss1=x.substr(0,pos);\\n            string ss2=x.substr(pos);\\n            if(ss1.find(\\'+\\')<ss1.length())\\n            {\\n                int pos2=ss1.find(\\'+\\');\\n                ss1=ss1.substr(0,pos2);\\n            }\\n            while(ss1.find(\\'.\\')<ss1.length())\\n            {\\n                int pos3=ss1.find(\\'.\\');\\n                ss1=ss1.substr(0,pos3)+ss1.substr(pos3+1);\\n            }\\n            se.insert(ss1+ss2);\\n        }\\n        return se.size();\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        set<string> se;\\n        for(auto x:emails)\\n        {\\n            int pos=x.find(\\'@\\');\\n            string ss1=x.substr(0,pos);\\n            string ss2=x.substr(pos);\\n            if(ss1.find(\\'+\\')<ss1.length())\\n            {\\n                int pos2=ss1.find(\\'+\\');\\n                ss1=ss1.substr(0,pos2);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 958851,
                "title": "kotlin",
                "content": "```\\nfun numUniqueEmails(emails: Array<String>): Int = emails.map {\\n        val splitEmail = it.split(\"@\")\\n        val local = splitEmail[0].replaceAfter(\"+\",\"\").replace(\"+\",\"\").replace(\".\",\"\")\\n        \"$local@${splitEmail[1]}\"\\n    }.distinct().size\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun numUniqueEmails(emails: Array<String>): Int = emails.map {\\n        val splitEmail = it.split(\"@\")\\n        val local = splitEmail[0].replaceAfter(\"+\",\"\").replace(\"+\",\"\").replace(\".\",\"\")\\n        \"$local@${splitEmail[1]}\"\\n    }.distinct().size\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 946370,
                "title": "c-program-addresssanitizer-deadlysignal-can-someone-help-me-fix-please",
                "content": "\\n\\n\\n\\nAddressSanitizer:DEADLYSIGNAL\\n==31==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000000 (pc 0x56362d89749c bp 0x7ffca6c3acd0 sp 0x7ffca6c3ac30 T0)\\n==31==The signal is caused by a READ memory access.\\n==31==Hint: address points to the zero page.\\n    #2 0x7f2915e360b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==31==ABORTING\\n\\n```\\n\\nint atsymbol(char* array);\\nint numUniqueEmails(char ** emails, int emailsSize){\\n    char** returnarray = malloc(sizeof(char) * emailsSize * 100); \\n    int k = 0;\\n    for (int i = 0; i < 100; i++){ //for each email address\\n        int atsym = atsymbol(emails[i]);\\n        for (int j = 0; j < 100; j++){ //for each character in email address\\n            \\n           int l = 0;\\n            if (emails[i][j] == \\'+\\'){\\n             for (; l < j; l++){\\n               returnarray[k][l] = emails[i][l];\\n             }\\n             for (int p = atsym; emails[i][p] != \\'\\\\0\\'; p++){\\n               returnarray[k][l] = emails[i][p]; \\n                 l++;\\n             }\\n          }\\n           if (emails[i][j] == \\'.\\'){\\n             for (int l = 0; l < j; l++){\\n               returnarray[k][l] = emails[i][l];\\n             }\\n             for (int l = j; l < 100; l++){\\n               if (emails[i][l] == \\'+\\'){\\n                 l = atsymbol + 1; \\n               }\\n               else{\\n                 returnarray[k][l] = emails[i][j];\\n               }\\n             }\\n           }\\n            \\n        }\\n        k++;\\n    }\\n    return k;\\n}\\n\\nint atsymbol(char* array) {\\n    int j = 0;  \\n    for (; j < 100; j++){ //determines where the @ symbol occurs in the email address\\n        if (array[j] == \\'@\\'){\\n          break;\\n    }\\n      }\\n    return j;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nint atsymbol(char* array);\\nint numUniqueEmails(char ** emails, int emailsSize){\\n    char** returnarray = malloc(sizeof(char) * emailsSize * 100); \\n    int k = 0;\\n    for (int i = 0; i < 100; i++){ //for each email address\\n        int atsym = atsymbol(emails[i]);\\n        for (int j = 0; j < 100; j++){ //for each character in email address\\n            \\n           int l = 0;\\n            if (emails[i][j] == \\'+\\'){\\n             for (; l < j; l++){\\n               returnarray[k][l] = emails[i][l];\\n             }\\n             for (int p = atsym; emails[i][p] != \\'\\\\0\\'; p++){\\n               returnarray[k][l] = emails[i][p]; \\n                 l++;\\n             }\\n          }\\n           if (emails[i][j] == \\'.\\'){\\n             for (int l = 0; l < j; l++){\\n               returnarray[k][l] = emails[i][l];\\n             }\\n             for (int l = j; l < 100; l++){\\n               if (emails[i][l] == \\'+\\'){\\n                 l = atsymbol + 1; \\n               }\\n               else{\\n                 returnarray[k][l] = emails[i][j];\\n               }\\n             }\\n           }\\n            \\n        }\\n        k++;\\n    }\\n    return k;\\n}\\n\\nint atsymbol(char* array) {\\n    int j = 0;  \\n    for (; j < 100; j++){ //determines where the @ symbol occurs in the email address\\n        if (array[j] == \\'@\\'){\\n          break;\\n    }\\n      }\\n    return j;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 916472,
                "title": "python-3-beats-98-21-and-100-in-memory",
                "content": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        eqmail = \"\"\\n        res = []\\n        for email in emails:\\n            eqmail = email.split(\"@\")[0].split(\"+\")[0]\\n            eqmail = \"\".join(eqmail.split(\".\"))\\n            res.append(eqmail + \"@\" + email.split(\"@\")[1])\\n        return len(set(res))\\n\\t",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        eqmail = \"\"\\n        res = []\\n        for email in emails:\\n            eqmail = email.split(\"@\")[0].split(\"+\")[0]\\n            eqmail = \"\".join(eqmail.split(\".\"))\\n            res.append(eqmail + \"@\" + email.split(\"@\")[1])\\n        return len(set(res))\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 806971,
                "title": "clean-python-set-algorithm",
                "content": "**Clean Python | Set Algorithm**\\n\\nEasy Python solution showcasing the use of a beautiful syntax to store all known (unique) email addresses. Enjoy :)\\n\\nPS. The present solution is optimized to avoid unnecessary string concatenation operations. The official LeetCode solution could have avoided the final email reconstruction operation.\\n\\n```\\nclass Solution:\\n    def numUniqueEmails(self, A):\\n        D = set()\\n        for x in A:\\n            a,b = x.split(\\'@\\')\\n            a   = a.split(\\'+\\')[0]\\n            a   = a.replace(\\'.\\',\\'\\')\\n            D.add( (a,b) )\\n        return len(D)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numUniqueEmails(self, A):\\n        D = set()\\n        for x in A:\\n            a,b = x.split(\\'@\\')\\n            a   = a.split(\\'+\\')[0]\\n            a   = a.replace(\\'.\\',\\'\\')\\n            D.add( (a,b) )\\n        return len(D)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 802553,
                "title": "c-beating-97",
                "content": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        unordered_set<string> hashset;\\n        for(int j=0;j<emails.size();j++){\\n            int start=INT_MAX, end=0;\\n            for(int k=0;k<emails[j].size();k++){\\n                if(emails[j][k]==\\'+\\'){\\n                    start=min(k,start);\\n                }\\n                if(emails[j][k]==\\'@\\'){\\n                    end=k;\\n                    break;\\n                }\\n            }\\n            if(start!=INT_MAX) emails[j].erase(emails[j].begin()+start,emails[j].begin()+end);\\n            for(int i=0;i<emails[j].size();i++){\\n                if(emails[j][i]==\\'@\\') break;\\n                if(emails[j][i]==\\'.\\'){\\n                    emails[j].erase(emails[j].begin()+i);\\n                }\\n            }\\n            hashset.insert(emails[j]);\\n        }\\n        return hashset.size();\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        unordered_set<string> hashset;\\n        for(int j=0;j<emails.size();j++){\\n            int start=INT_MAX, end=0;\\n            for(int k=0;k<emails[j].size();k++){\\n                if(emails[j][k]==\\'+\\'){\\n                    start=min(k,start);\\n                }\\n                if(emails[j][k]==\\'@\\'){\\n                    end=k;\\n                    break;\\n                }\\n            }\\n            if(start!=INT_MAX) emails[j].erase(emails[j].begin()+start,emails[j].begin()+end);\\n            for(int i=0;i<emails[j].size();i++){\\n                if(emails[j][i]==\\'@\\') break;\\n                if(emails[j][i]==\\'.\\'){\\n                    emails[j].erase(emails[j].begin()+i);\\n                }\\n            }\\n            hashset.insert(emails[j]);\\n        }\\n        return hashset.size();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697631,
                "title": "python3-easy",
                "content": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        seen = set()\\n        for e in emails:\\n            local,domain = e.split(\\'@\\')\\n            if \\'+\\' in local:\\n                local = local[:local.index(\\'+\\')]\\n            seen.add(local.replace(\\'.\\',\\'\\')+\\'@\\'+domain)\\n        return len(seen)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        seen = set()\\n        for e in emails:\\n            local,domain = e.split(\\'@\\')\\n            if \\'+\\' in local:\\n                local = local[:local.index(\\'+\\')]\\n            seen.add(local.replace(\\'.\\',\\'\\')+\\'@\\'+domain)\\n        return len(seen)",
                "codeTag": "Java"
            },
            {
                "id": 539508,
                "title": "java-solution-from-easy-to-understand-to-concise",
                "content": "Straight forward [6ms]. Beat 96%\\n\\n```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        Set<String> set = new HashSet<>();\\n        for (String s : emails) set.add(refine(s));\\n        return set.size();\\n    }\\n\\n    public String refine(String s) {\\n        String[] arr = s.split(\"@\");\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < arr[0].length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'+\\') break;\\n            if (c != \\'.\\') sb.append(c);\\n        }\\n        sb.append(\"@\").append(arr[1]);\\n        return sb.toString();\\n    }\\n}\\n```\\n\\nShorter solution [22ms]. Beat 40%\\n\\n```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        Set<String> set = new HashSet<>();\\n\\n        for (String s : emails) {\\n            StringBuilder sb = new StringBuilder();\\n            String[] parts = s.split(\"@\");\\n            String local = parts[0].split(\"\\\\\\\\+\")[0].replaceAll(\"\\\\\\\\.\", \"\");\\n            sb.append(local).append(\"@\").append(parts[1]);\\n            set.add(sb.toString());\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        Set<String> set = new HashSet<>();\\n        for (String s : emails) set.add(refine(s));\\n        return set.size();\\n    }\\n\\n    public String refine(String s) {\\n        String[] arr = s.split(\"@\");\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < arr[0].length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'+\\') break;\\n            if (c != \\'.\\') sb.append(c);\\n        }\\n        sb.append(\"@\").append(arr[1]);\\n        return sb.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        Set<String> set = new HashSet<>();\\n\\n        for (String s : emails) {\\n            StringBuilder sb = new StringBuilder();\\n            String[] parts = s.split(\"@\");\\n            String local = parts[0].split(\"\\\\\\\\+\")[0].replaceAll(\"\\\\\\\\.\", \"\");\\n            sb.append(local).append(\"@\").append(parts[1]);\\n            set.add(sb.toString());\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 485611,
                "title": "easy-c-solution",
                "content": "```\\n    public class Solution\\n    {\\n        public int NumUniqueEmails(string[] emails)\\n        {\\n            ISet<string> res = new HashSet<string>();\\n            foreach (var email in emails)\\n            {\\n                var split = email.Split(new char[] {\\'@\\'}, StringSplitOptions.RemoveEmptyEntries);\\n                int plus = split[0].IndexOf(\\'+\\');\\n                if (plus >= 0)\\n                {\\n                    split[0] = split[0].Substring(0, plus);\\n                }\\n                split[0] = split[0].Replace(\".\", \"\");\\n                res.Add($\"{split[0]}@{split[1]}\");\\n            }\\n            return res.Count;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public class Solution\\n    {\\n        public int NumUniqueEmails(string[] emails)\\n        {\\n            ISet<string> res = new HashSet<string>();\\n            foreach (var email in emails)\\n            {\\n                var split = email.Split(new char[] {\\'@\\'}, StringSplitOptions.RemoveEmptyEntries);\\n                int plus = split[0].IndexOf(\\'+\\');\\n                if (plus >= 0)\\n                {\\n                    split[0] = split[0].Substring(0, plus);\\n                }\\n                split[0] = split[0].Replace(\".\", \"\");\\n                res.Add($\"{split[0]}@{split[1]}\");\\n            }\\n            return res.Count;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 481998,
                "title": "javascript-clean-code-beats-81",
                "content": "```javascript\\nconst numUniqueEmails = (emails) => {\\n\\t// validate\\n\\tif(emails === null || emails.length === 0) return 0;\\n\\n\\tconst emailSet = new Set();\\n\\tlet emailCount = 0;\\n\\n\\t// iterate 1 email at a time\\n\\temails.forEach(email => {\\t\\n        // parse and filter to get cleaned up address\\n        const parsed = parseEmail(email);\\n\\n        // verify if already in hash\\n        if(!emailSet.has(parsed)) {\\n            // if not, update\\n            emailSet.add(parsed);\\n            emailCount += 1\\n        }\\n    });\\n\\n\\t// return count\\n\\treturn emailCount;\\n};\\n\\nconst parseEmail = (email) => {\\n\\tlet result = \\'\\';\\n\\tlet afterAt = false;\\n\\tlet hasPlus = false;\\n\\tfor(char of email) {\\n        if(!afterAt) {\\n\\t        if(char === \\'@\\') { \\n                afterAt = true;\\n            } else if (char === \\'+\\') {\\n\\t            hasPlus = true;\\n\\t            continue;\\n            } else if (char === \\'.\\' || hasPlus) {\\n                continue;\\n            }\\n        }\\n\\n        result = `${result}${char}`;\\n    }\\n\\n\\treturn result;\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nconst numUniqueEmails = (emails) => {\\n\\t// validate\\n\\tif(emails === null || emails.length === 0) return 0;\\n\\n\\tconst emailSet = new Set();\\n\\tlet emailCount = 0;\\n\\n\\t// iterate 1 email at a time\\n\\temails.forEach(email => {\\t\\n        // parse and filter to get cleaned up address\\n        const parsed = parseEmail(email);\\n\\n        // verify if already in hash\\n        if(!emailSet.has(parsed)) {\\n            // if not, update\\n            emailSet.add(parsed);\\n            emailCount += 1\\n        }\\n    });\\n\\n\\t// return count\\n\\treturn emailCount;\\n};\\n\\nconst parseEmail = (email) => {\\n\\tlet result = \\'\\';\\n\\tlet afterAt = false;\\n\\tlet hasPlus = false;\\n\\tfor(char of email) {\\n        if(!afterAt) {\\n\\t        if(char === \\'@\\') { \\n                afterAt = true;\\n            } else if (char === \\'+\\') {\\n\\t            hasPlus = true;\\n\\t            continue;\\n            } else if (char === \\'.\\' || hasPlus) {\\n                continue;\\n            }\\n        }\\n\\n        result = `${result}${char}`;\\n    }\\n\\n\\treturn result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 458125,
                "title": "java-solution",
                "content": "```\\npublic int numUniqueEmails(String[] emails) {\\n\\tHashSet<String> set = new HashSet<String>();\\n\\n\\tfor (String email : emails) {\\n\\t\\tString[] parts = email.split(\"@\");\\n\\t\\tString local = parts[0];\\n\\t\\tString domain = parts[1];\\n\\n\\t\\tlocal = local.replace(\".\", \"\");\\n\\t\\tint plusIndex = local.indexOf(\"+\");\\n\\t\\tif (plusIndex > 0) {\\n\\t\\t\\tlocal = local.substring(0, plusIndex);\\n\\t\\t}\\n\\n\\t\\tString result = local + \"@\" + domain;\\n\\t\\tset.add(result);\\n\\t}\\n\\n\\treturn set.size();\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int numUniqueEmails(String[] emails) {\\n\\tHashSet<String> set = new HashSet<String>();\\n\\n\\tfor (String email : emails) {\\n\\t\\tString[] parts = email.split(\"@\");\\n\\t\\tString local = parts[0];\\n\\t\\tString domain = parts[1];\\n\\n\\t\\tlocal = local.replace(\".\", \"\");\\n\\t\\tint plusIndex = local.indexOf(\"+\");\\n\\t\\tif (plusIndex > 0) {\\n\\t\\t\\tlocal = local.substring(0, plusIndex);\\n\\t\\t}\\n\\n\\t\\tString result = local + \"@\" + domain;\\n\\t\\tset.add(result);\\n\\t}\\n\\n\\treturn set.size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 451688,
                "title": "ruby-readable-solution-faster-than-82-42-less-memory-than-100",
                "content": "<img src=\"https://assets.leetcode.com/users/ayacai115/image_1576373869.png\" width=500>\\n\\n```rb\\ndef num_unique_emails(emails)\\n    hash = emails.group_by do |email|\\n      local, domain = email.split(\\'@\\')\\n      local = local.delete(\\'.\\').split(\\'+\\').first\\n\\n      \"#{local}@#{domain}\"\\n    end\\n\\n    hash.keys.count\\nend\\n```",
                "solutionTags": [],
                "code": "```rb\\ndef num_unique_emails(emails)\\n    hash = emails.group_by do |email|\\n      local, domain = email.split(\\'@\\')\\n      local = local.delete(\\'.\\').split(\\'+\\').first\\n\\n      \"#{local}@#{domain}\"\\n    end\\n\\n    hash.keys.count\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 410881,
                "title": "java-simple-7-line-solution",
                "content": "```\\npublic int numUniqueEmails(String[] emails) {\\n\\tHashSet<String> hs = new HashSet<>();\\n\\tfor(String e:emails) {\\n\\t\\tString[] pieces = e.split(\"@\");\\n\\t\\tString name = pieces[0].split(\"\\\\\\\\+\",2)[0], domain = pieces[1];\\n\\t\\tname = name.replace(\".\",\"\");\\n\\t\\ths.add(name+\"@\"+domain);\\n\\t}\\n\\treturn hs.size();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numUniqueEmails(String[] emails) {\\n\\tHashSet<String> hs = new HashSet<>();\\n\\tfor(String e:emails) {\\n\\t\\tString[] pieces = e.split(\"@\");\\n\\t\\tString name = pieces[0].split(\"\\\\\\\\+\",2)[0], domain = pieces[1];\\n\\t\\tname = name.replace(\".\",\"\");\\n\\t\\ths.add(name+\"@\"+domain);\\n\\t}\\n\\treturn hs.size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 340694,
                "title": "clean-python-solution",
                "content": "```\\nclass Solution(object):\\n    def rewriteEmail(self, email):\\n        localName, domainName = email.split(\\'@\\')\\n        plusIndex = localName.find(\\'+\\')\\n        if plusIndex != -1:\\n            localName = localName[:plusIndex]\\n        localName = localName.replace(\\'.\\', \\'\\')\\n        return localName + \\'@\\' + domainName\\n        \\n    def numUniqueEmails(self, emails):\\n        \"\"\"\\n        :type emails: List[str]\\n        :rtype: int\\n        \"\"\"\\n        uniqueEmails = set()\\n        for email in emails:\\n            uniqueEmails.add(self.rewriteEmail(email))\\n        return len(uniqueEmails)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def rewriteEmail(self, email):\\n        localName, domainName = email.split(\\'@\\')\\n        plusIndex = localName.find(\\'+\\')\\n        if plusIndex != -1:\\n            localName = localName[:plusIndex]\\n        localName = localName.replace(\\'.\\', \\'\\')\\n        return localName + \\'@\\' + domainName\\n        \\n    def numUniqueEmails(self, emails):\\n        \"\"\"\\n        :type emails: List[str]\\n        :rtype: int\\n        \"\"\"\\n        uniqueEmails = set()\\n        for email in emails:\\n            uniqueEmails.add(self.rewriteEmail(email))\\n        return len(uniqueEmails)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 315878,
                "title": "java-5ms-99-32-one-pass",
                "content": "```\\npublic int numUniqueEmails(String[] emails) {\\n\\tSet<String> set = new HashSet<>();\\n\\tfor (String s:\\n\\t\\t emails) {\\n\\t\\tint mid = s.indexOf(\\'@\\');\\n\\t\\tset.add(local(s.substring(0, mid)) + s.substring(mid));\\n\\t}\\n\\treturn set.size();\\n}\\n\\nprivate String local(String s) {\\n\\tStringBuilder sb = new StringBuilder();\\n\\tfor (int i = 0; i < s.length(); i++) {\\n\\t\\tchar ch = s.charAt(i);\\n\\t\\tif (ch == \\'+\\') {\\n\\t\\t\\tbreak;\\n\\t\\t} else if (ch != \\'.\\') {\\n\\t\\t\\tsb.append(ch);\\n\\t\\t}\\n\\t}\\n\\treturn sb.toString();\\n}\\n```\\n\\nUsing a hashset to store and do identity validation.",
                "solutionTags": [],
                "code": "```\\npublic int numUniqueEmails(String[] emails) {\\n\\tSet<String> set = new HashSet<>();\\n\\tfor (String s:\\n\\t\\t emails) {\\n\\t\\tint mid = s.indexOf(\\'@\\');\\n\\t\\tset.add(local(s.substring(0, mid)) + s.substring(mid));\\n\\t}\\n\\treturn set.size();\\n}\\n\\nprivate String local(String s) {\\n\\tStringBuilder sb = new StringBuilder();\\n\\tfor (int i = 0; i < s.length(); i++) {\\n\\t\\tchar ch = s.charAt(i);\\n\\t\\tif (ch == \\'+\\') {\\n\\t\\t\\tbreak;\\n\\t\\t} else if (ch != \\'.\\') {\\n\\t\\t\\tsb.append(ch);\\n\\t\\t}\\n\\t}\\n\\treturn sb.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 305311,
                "title": "python-32ms-and-94-faster",
                "content": "```class Solution(object):\\n    def numUniqueEmails(self, emails):\\n        \"\"\"\\n        :type emails: List[str]\\n        :rtype: int\\n        \"\"\"\\n        d = {}\\n        count = 0\\n        for email in emails:\\n            l, domain = email.split(\"@\")\\n            l = l.split(\\'+\\')[0]\\n            l = l.replace(\\'.\\',\\'\\')\\n            e = l + \\'@\\' + domain\\n            if e not in d:\\n                d[e] = 1\\n                count+=1\\n            else:\\n                continue\\n                \\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```class Solution(object):\\n    def numUniqueEmails(self, emails):\\n        \"\"\"\\n        :type emails: List[str]\\n        :rtype: int\\n        \"\"\"\\n        d = {}\\n        count = 0\\n        for email in emails:\\n            l, domain = email.split(\"@\")\\n            l = l.split(\\'+\\')[0]\\n            l = l.replace(\\'.\\',\\'\\')\\n            e = l + \\'@\\' + domain\\n            if e not in d:\\n                d[e] = 1\\n                count+=1\\n            else:\\n                continue\\n                \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 293367,
                "title": "javascript-regexp-set-solution",
                "content": "```js\\n/**\\n * @param {string[]} emails\\n * @return {number}\\n */\\nvar numUniqueEmails = function(emails) {\\n    const set = new Set();\\n    \\n    for (let email of emails) {\\n        const [local, domain] = email.split(\\'@\\');\\n        set.add(\\n          `${local.replace(/\\\\+.*$|\\\\./g, \\'\\')}@${domain}`\\n        );\\n    }\\n    \\n    return set.size;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```js\\n/**\\n * @param {string[]} emails\\n * @return {number}\\n */\\nvar numUniqueEmails = function(emails) {\\n    const set = new Set();\\n    \\n    for (let email of emails) {\\n        const [local, domain] = email.split(\\'@\\');\\n        set.add(\\n          `${local.replace(/\\\\+.*$|\\\\./g, \\'\\')}@${domain}`\\n        );\\n    }\\n    \\n    return set.size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 258990,
                "title": "one-line-python-solution",
                "content": "```python\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        return len(set([x.split(\\'@\\')[0].split(\\'+\\')[0].replace(\\'.\\',\\'\\')+x.split(\\'@\\')[1] for x in emails]))\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        return len(set([x.split(\\'@\\')[0].split(\\'+\\')[0].replace(\\'.\\',\\'\\')+x.split(\\'@\\')[1] for x in emails]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 251508,
                "title": "readable-swift-4-solution",
                "content": "```\\nclass Solution {\\n    func numUniqueEmails(_ emails: [String]) -> Int {\\n        \\n        var  s = Set<String>()\\n        \\n        for e in emails {\\n            let seperated = e.split(separator: \"@\")\\n            let local = seperated[0]\\n            let domain = seperated[1]\\n            var modifiedLocal = \"\"\\n            \\n            innerLoop: for c in local {    \\n               if c == \"+\" {\\n                   break innerLoop\\n               }\\n               if c != \".\" {\\n                   modifiedLocal += [c]\\n               }\\n            }\\n            \\n            let formatted  = modifiedLocal + \"@\" +  domain\\n            s.insert(formatted)\\n        }\\n        \\n        return s.count\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func numUniqueEmails(_ emails: [String]) -> Int {\\n        \\n        var  s = Set<String>()\\n        \\n        for e in emails {\\n            let seperated = e.split(separator: \"@\")\\n            let local = seperated[0]\\n            let domain = seperated[1]\\n            var modifiedLocal = \"\"\\n            \\n            innerLoop: for c in local {    \\n               if c == \"+\" {\\n                   break innerLoop\\n               }\\n               if c != \".\" {\\n                   modifiedLocal += [c]\\n               }\\n            }\\n            \\n            let formatted  = modifiedLocal + \"@\" +  domain\\n            s.insert(formatted)\\n        }\\n        \\n        return s.count\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 246806,
                "title": "javascript-solution",
                "content": "```\\nvar numUniqueEmails = function(emails) {\\n    const uniqueAddress = new Set();\\n    \\n    emails.forEach(email => {\\n        const splitEmail = email.split(\"@\");\\n        let addr = splitEmail[0];\\n        const domain = splitEmail[1];\\n        \\n        //everything before the first +\\n        addr = addr.split(\"+\")[0]\\n        \\n        //remove .\\n        addr = addr.replace(/[.]/g, \\'\\')\\n        uniqueAddress.add(addr+\"@\"+domain);\\n    })\\n    \\n    return uniqueAddress.size;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numUniqueEmails = function(emails) {\\n    const uniqueAddress = new Set();\\n    \\n    emails.forEach(email => {\\n        const splitEmail = email.split(\"@\");\\n        let addr = splitEmail[0];\\n        const domain = splitEmail[1];\\n        \\n        //everything before the first +\\n        addr = addr.split(\"+\")[0]\\n        \\n        //remove .\\n        addr = addr.replace(/[.]/g, \\'\\')\\n        uniqueAddress.add(addr+\"@\"+domain);\\n    })\\n    \\n    return uniqueAddress.size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 240924,
                "title": "java-ac-3-liner-with-explanation",
                "content": "\\t// how many different addresses actually receive mails\\n\\t// \\'.\\' and everything after \\'+\\' are only ignored if before \\'@\\'\\n\\t// parts[0]: local name, parts[1] = domain name \\n```\\n    public static int numUniqueEmails(String[] emails) {\\n    \\t\\tSet<String> unique_emails = new HashSet<>();\\n    \\t\\tfor (String email : emails) {unique_emails.add(email.split(\"\\\\\\\\@\")[0].replace(\".\", \"\").split(\"\\\\\\\\+\")[0] + email.split(\"\\\\\\\\@\")[1]);}\\n    \\t\\treturn unique_emails.size();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public static int numUniqueEmails(String[] emails) {\\n    \\t\\tSet<String> unique_emails = new HashSet<>();\\n    \\t\\tfor (String email : emails) {unique_emails.add(email.split(\"\\\\\\\\@\")[0].replace(\".\", \"\").split(\"\\\\\\\\+\")[0] + email.split(\"\\\\\\\\@\")[1]);}\\n    \\t\\treturn unique_emails.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 239285,
                "title": "c-beats-82-using-unordered-set",
                "content": "\\'\\'\\'\\nclass Solution \\n{\\npublic:\\n    int numUniqueEmails(vector<string>& emails) \\n    {\\n        int len=emails.size();\\n        unordered_set<string>newemail;\\n        string delimiter1=\"+\";\\n        string delimiter2=\"@\";\\n        if(len==0||len==1)\\n            return len;\\n        for(int i=0;i<len;i++)\\n        {\\n            string a =emails[i].substr(0, emails[i].find(delimiter1));\\n            a.erase(remove(a.begin(), a.end(), \\'.\\'), a.end());\\n            string b=emails[i].substr(emails[i].find(delimiter2),emails[i].length()-1 );\\n            // string c=a+b;\\n            // cout<<a+b<<\" \\\\n\";\\n            // cout<<c<<\" \";\\n            newemail.insert(a+b);\\n        }\\n        return newemail.size();\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution \\n{\\npublic:\\n    int numUniqueEmails(vector<string>& emails) \\n    {\\n        int len=emails.size();\\n        unordered_set<string>newemail;\\n        string delimiter1=\"+\";\\n        string delimiter2=\"@\";\\n        if(len==0||len==1)\\n            return len;\\n        for(int i=0;i<len;i++)\\n        {\\n            string a =emails[i].substr(0, emails[i].find(delimiter1));\\n            a.erase(remove(a.begin(), a.end(), \\'.\\'), a.end());\\n            string b=emails[i].substr(emails[i].find(delimiter2),emails[i].length()-1 );\\n            // string c=a+b;\\n            // cout<<a+b<<\" \\\\n\";\\n            // cout<<c<<\" \";\\n            newemail.insert(a+b);\\n        }",
                "codeTag": "C++"
            },
            {
                "id": 237880,
                "title": "optimized-further-python-3",
                "content": "```\\ndef numUniqueEmails(self, emails: \\'List[str]\\') -> \\'int\\':\\n        d = set()\\n        for email in emails:\\n            name, domain = email.split(\\'@\\')\\n            name = name.split(\\'+\\')[0]\\n            name = name.replace(\\'.\\',\\'\\')\\n            email_id = name+\\'@\\'+domain\\n            # replace list d by set for efficiency and removing redundancy\\n            d.add(email_id)\\n            \\n        # print(d)\\n        return len(d)\\n                              \\n                              ```",
                "solutionTags": [],
                "code": "```\\ndef numUniqueEmails(self, emails: \\'List[str]\\') -> \\'int\\':\\n        d = set()\\n        for email in emails:\\n            name, domain = email.split(\\'@\\')\\n            name = name.split(\\'+\\')[0]\\n            name = name.replace(\\'.\\',\\'\\')\\n            email_id = name+\\'@\\'+domain\\n            # replace list d by set for efficiency and removing redundancy\\n            d.add(email_id)\\n            \\n        # print(d)\\n        return len(d)\\n                              \\n                              ```",
                "codeTag": "Python3"
            },
            {
                "id": 232506,
                "title": "readable-fast-python3-99-3-speed",
                "content": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: \\'List[str]\\') -> \\'int\\':\\n        li = []\\n        for email in emails:\\n            domain = email[email.index(\\'@\\'):]\\n            local = email[:email.index(\\'@\\')]\\n            \\n            if \\'+\\' in local:\\n                local = local[:local.index(\\'+\\')]\\n            if \\'.\\' in local:\\n                local = local.replace(\\'.\\', \\'\\')\\n\\n            final = local + domain\\n            if final in li:\\n                continue\\n            else:\\n                li.append(final)\\n        return len(li)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: \\'List[str]\\') -> \\'int\\':\\n        li = []\\n        for email in emails:\\n            domain = email[email.index(\\'@\\'):]\\n            local = email[:email.index(\\'@\\')]\\n            \\n            if \\'+\\' in local:\\n                local = local[:local.index(\\'+\\')]\\n            if \\'.\\' in local:\\n                local = local.replace(\\'.\\', \\'\\')\\n\\n            final = local + domain\\n            if final in li:\\n                continue\\n            else:\\n                li.append(final)\\n        return len(li)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 231520,
                "title": "97-23-c-simple-parser",
                "content": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        unordered_set<string> uniqueEmails;\\n        for (auto email : emails) {\\n            string finalEmail;\\n            bool localName = true;\\n            bool skip = false;\\n            for (char c : email) {\\n                if (c == \\'@\\') {\\n                    localName = false;\\n                    continue;\\n                }\\n                \\n                if (localName && skip) {\\n                    continue;\\n                }\\n                \\n                if (localName && c == \\'.\\') {\\n                    continue;\\n                }\\n                \\n                if (localName && c == \\'+\\') {\\n                    skip = true;\\n                    continue;\\n                }\\n                \\n                finalEmail += c;\\n            }\\n            \\n            uniqueEmails.insert(finalEmail);\\n        }\\n        \\n        return uniqueEmails.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        unordered_set<string> uniqueEmails;\\n        for (auto email : emails) {\\n            string finalEmail;\\n            bool localName = true;\\n            bool skip = false;\\n            for (char c : email) {\\n                if (c == \\'@\\') {\\n                    localName = false;\\n                    continue;\\n                }\\n                \\n                if (localName && skip) {\\n                    continue;\\n                }\\n                \\n                if (localName && c == \\'.\\') {\\n                    continue;\\n                }\\n                \\n                if (localName && c == \\'+\\') {\\n                    skip = true;\\n                    continue;\\n                }\\n                \\n                finalEmail += c;\\n            }\\n            \\n            uniqueEmails.insert(finalEmail);\\n        }\\n        \\n        return uniqueEmails.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 220357,
                "title": "easy-python-6-lines",
                "content": "```py\\nclass Solution(object):\\n    def numUniqueEmails(self, emails):\\n        \"\"\"\\n        :type emails: List[str]\\n        :rtype: int\\n        \"\"\"\\n        s = set()\\n        for email in emails:\\n            prefix, suffix = email.split(\\'@\\')\\n            prefix = prefix.split(\\'+\\')[0].replace(\\'.\\', \\'\\')\\n            s.add((prefix, suffix))\\n        \\n        return len(s)\\n```",
                "solutionTags": [],
                "code": "```py\\nclass Solution(object):\\n    def numUniqueEmails(self, emails):\\n        \"\"\"\\n        :type emails: List[str]\\n        :rtype: int\\n        \"\"\"\\n        s = set()\\n        for email in emails:\\n            prefix, suffix = email.split(\\'@\\')\\n            prefix = prefix.split(\\'+\\')[0].replace(\\'.\\', \\'\\')\\n            s.add((prefix, suffix))\\n        \\n        return len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 203379,
                "title": "c-20-ms-stl-no-useless-copying-short-and-efficient-code-annotated",
                "content": "```\\nclass Solution {\\npublic:\\n  int numUniqueEmails(std::vector<std::string>& emails) {             // take a note: it is not \\'const\\' ;)\\n    if(emails.empty())\\n      return {};\\n\\n    std::unordered_set<std::string> uniques;\\n    for(auto& email : emails)\\n    {\\n      auto at   = std::find(std::begin(email), std::end(email), \\'@\\'); // task guaranteed that there will be one \\'@\\'\\n\\t  auto plus = std::find(std::begin(email), at, \\'+\\');              // search for the first \\'+\\' in range [begin, \\'@\\')\\n\\n      email.erase(std::remove(std::begin(email),                      // very common idiom called \"remove-erase\"\\n                              plus != std::end(email) ? plus : at,    // if there\\'s no \\'+\\' in the name, we trim to \\'@\\'\\n                              \\'.\\'),\\n                  at);\\n\\t  uniques.emplace(email);                                         // construct an \\'email\\' directly inside \\'uniques\\'\\n    }\\n\\n    return static_cast<int>(uniques.size());                          // type safety :)\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  int numUniqueEmails(std::vector<std::string>& emails) {             // take a note: it is not \\'const\\' ;)\\n    if(emails.empty())\\n      return {};\\n\\n    std::unordered_set<std::string> uniques;\\n    for(auto& email : emails)\\n    {\\n      auto at   = std::find(std::begin(email), std::end(email), \\'@\\'); // task guaranteed that there will be one \\'@\\'\\n\\t  auto plus = std::find(std::begin(email), at, \\'+\\');              // search for the first \\'+\\' in range [begin, \\'@\\')\\n\\n      email.erase(std::remove(std::begin(email),                      // very common idiom called \"remove-erase\"\\n                              plus != std::end(email) ? plus : at,    // if there\\'s no \\'+\\' in the name, we trim to \\'@\\'\\n                              \\'.\\'),\\n                  at);\\n\\t  uniques.emplace(email);                                         // construct an \\'email\\' directly inside \\'uniques\\'\\n    }\\n\\n    return static_cast<int>(uniques.size());                          // type safety :)\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 201039,
                "title": "simple-javascript-solution-68ms-99",
                "content": "The fastest one recorded right now (64ms) is actually incorrect... it only counts the number of unique domain names. I submitted a new test case for this problem that will hopefully invalidate it. \\n\\nThis solution achieves the real fastest time (68ms):\\n\\n```\\n/**\\n * @param {string[]} emails\\n * @return {number}\\n */\\nconst numUniqueEmails = emails => {\\n\\tconst hasReceivedMail = {};\\n\\t\\n\\temails.forEach(email =>\\n        hasReceivedMail[email.substring(0, (email.indexOf(\\'+\\') + 1 || email.indexOf(\\'@\\') + 1) - 1).replace(/\\\\./g,\\'\\') + email.substring(email.indexOf(\\'@\\'))] = true\\n    );\\n\\t\\n\\treturn Object.keys(hasReceivedMail).length;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string[]} emails\\n * @return {number}\\n */\\nconst numUniqueEmails = emails => {\\n\\tconst hasReceivedMail = {};\\n\\t\\n\\temails.forEach(email =>\\n        hasReceivedMail[email.substring(0, (email.indexOf(\\'+\\') + 1 || email.indexOf(\\'@\\') + 1) - 1).replace(/\\\\./g,\\'\\') + email.substring(email.indexOf(\\'@\\'))] = true\\n    );\\n\\t\\n\\treturn Object.keys(hasReceivedMail).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 194728,
                "title": "simple-java-solution",
                "content": "```\\n    public int numUniqueEmails(String[] emails) {\\n        HashSet distinctEmails = new HashSet();\\n        for (String email: emails) {\\n            String firstSplit[] = email.split(\"@\");\\n            String secondSplit[] = firstSplit[0].replaceAll(\".\",\"\").split(\"[+]\");\\n            distinctEmails.add(secondSplit[0]+firstSplit[1]);\\n        }\\n        \\n        return distinctEmails.size();\\n    }",
                "solutionTags": [],
                "code": "```\\n    public int numUniqueEmails(String[] emails) {\\n        HashSet distinctEmails = new HashSet();\\n        for (String email: emails) {\\n            String firstSplit[] = email.split(\"@\");\\n            String secondSplit[] = firstSplit[0].replaceAll(\".\",\"\").split(\"[+]\");\\n            distinctEmails.add(secondSplit[0]+firstSplit[1]);\\n        }\\n        \\n        return distinctEmails.size();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 193804,
                "title": "functional-modular-es6-javascript-regex",
                "content": "```\\nconst rule1 = localName => localName.replace(/\\\\./g, \\'\\');\\n\\nconst rule2 = localName => localName.replace(/(\\\\+.*)/, \\'\\');\\n\\nconst localName = email => email.match(/(.*)@/g)[0].replace(\\'@\\',\\'\\');\\n\\nconst domainName = email => email.match(/@(.*)/g)[0].replace(\\'@\\',\\'\\');\\n\\nconst normalizeEmail = email => `${rule2(rule1(localName(email)))}@${domainName(email)}`;\\n\\nconst numUniqueEmails = (emails, uniqueEmails = new Set()) => {\\n  emails.forEach(email => uniqueEmails.add(normalizeEmail(email)));\\n  return uniqueEmails.size; \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst rule1 = localName => localName.replace(/\\\\./g, \\'\\');\\n\\nconst rule2 = localName => localName.replace(/(\\\\+.*)/, \\'\\');\\n\\nconst localName = email => email.match(/(.*)@/g)[0].replace(\\'@\\',\\'\\');\\n\\nconst domainName = email => email.match(/@(.*)/g)[0].replace(\\'@\\',\\'\\');\\n\\nconst normalizeEmail = email => `${rule2(rule1(localName(email)))}@${domainName(email)}`;\\n\\nconst numUniqueEmails = (emails, uniqueEmails = new Set()) => {\\n  emails.forEach(email => uniqueEmails.add(normalizeEmail(email)));\\n  return uniqueEmails.size; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 187654,
                "title": "swift-simple-and-short-solution",
                "content": "```\n    func numUniqueEmails(_ emails: [String]) -> Int {\n        var emailSet:Set<String> = []\n        for s in emails{\n            let address = s.components(separatedBy: \"@\")\n            let name = address[0].components(separatedBy: \"+\").first?.filter({$0 != \".\"})\n            emailSet.insert(name!+address.last!)\n        }\n        return emailSet.count\n    }\n\n```",
                "solutionTags": [],
                "code": "```\n    func numUniqueEmails(_ emails: [String]) -> Int {\n        var emailSet:Set<String> = []\n        for s in emails{\n            let address = s.components(separatedBy: \"@\")\n            let name = address[0].components(separatedBy: \"+\").first?.filter({$0 != \".\"})\n            emailSet.insert(name!+address.last!)\n        }\n        return emailSet.count\n    }\n\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 186785,
                "title": "c-string-processing-easy-to-explain-and-impl-in-5mins-cheers",
                "content": "```\\n#include <vector>\\n#include <string>\\n#include <unordered_set>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        unordered_set<string> res;\\n\\n        for (auto& str : emails) {\\n            string sendto;\\n            int i = 0;\\n            while (str[i] != \\'@\\') {\\n                if (str[i] == \\'+\\') {\\n                    break;\\n                }\\n                if (str[i] != \\'.\\') {\\n                    sendto.push_back(str[i]);\\n                }\\n                ++i;\\n            }\\n\\n            int pos = str.find(\"@\", i);\\n            sendto += str.substr(pos);\\n            res.insert(sendto);\\n        }\\n\\n        return res.size();\\n    }\\n};\\n\\n#if DEBUG\\nint main(int argc, char** argv) {\\n    return 0;\\n}\\n#endif\\n\\n```",
                "solutionTags": [],
                "code": "```\\n#include <vector>\\n#include <string>\\n#include <unordered_set>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        unordered_set<string> res;\\n\\n        for (auto& str : emails) {\\n            string sendto;\\n            int i = 0;\\n            while (str[i] != \\'@\\') {\\n                if (str[i] == \\'+\\') {\\n                    break;\\n                }\\n                if (str[i] != \\'.\\') {\\n                    sendto.push_back(str[i]);\\n                }\\n                ++i;\\n            }\\n\\n            int pos = str.find(\"@\", i);\\n            sendto += str.substr(pos);\\n            res.insert(sendto);\\n        }\\n\\n        return res.size();\\n    }\\n};\\n\\n#if DEBUG\\nint main(int argc, char** argv) {\\n    return 0;\\n}\\n#endif\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 186739,
                "title": "c-readable-code",
                "content": "It is the easy level algorithm. I wrote the code in the weekly contest 108. It took me around 15 minutes since I tested the code first before I submitted. Ideally I think that is should take less than 10 minutes since I used API of string.Join, I did not need to write any loop by myself. \n```\npublic class Solution {\n    public int NumUniqueEmails(string[] emails)\n        {\n            if (emails == null || emails.Length == 0)\n                return 0;\n\n            var hashset = new HashSet<string>(); \n            foreach(var email in emails)\n            {\n                //need to figure out email address\n                var split1 = email.Split('@');\n                var domainName = split1[1];\n                var name = split1[0];\n                var userName = name.Split('+');\n                var withDot = userName[0];\n                var splitWithDot = withDot.Split('.');\n                var address = string.Join(\"\", splitWithDot);\n                hashset.Add(address + \"@\" + domainName); \n            }\n\n            return hashset.Count; \n    }\n}\n```",
                "solutionTags": [],
                "code": "```\npublic class Solution {\n    public int NumUniqueEmails(string[] emails)\n        {\n            if (emails == null || emails.Length == 0)\n                return 0;\n\n            var hashset = new HashSet<string>(); \n            foreach(var email in emails)\n            {\n                //need to figure out email address\n                var split1 = email.Split('@');\n                var domainName = split1[1];\n                var name = split1[0];\n                var userName = name.Split('+');\n                var withDot = userName[0];\n                var splitWithDot = withDot.Split('.');\n                var address = string.Join(\"\", splitWithDot);\n                hashset.Add(address + \"@\" + domainName); \n            }\n\n            return hashset.Count; \n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 186699,
                "title": "javascript-solution",
                "content": "1) Trim the email (i.e. only get the local name without '.' and before the '+'  and \"@\" and domain ); (e.g. \"user.name+123@gmail.com => username@gmail.com)\n2) Added the trimmed names to a set\n3) count the size of the set return the count;\n\n```\n/**\n * @param {string[]} emails\n * @return {number}\n */\nvar numUniqueEmails = function(emails) {\n    let trimmedUniques = new Set();\n    for (let email of emails) {\n        trimmedUniques.add(trimEmail(email));\n    }\n    return trimmedUniques.size;\n};\n\nvar trimEmail = function(email) {\n    let localList = [];\n    let i = 0;\n    while (email[i] !== '@' && email[i] !== '+') {\n        if (email[i] !== '.') localList.push(email[i]);\n        i++;\n    }\n    while (email[i] !== '@') {\n        i++;\n    }\n    let domain = email.substring(i);\n    return localList.join('') + domain;\n}\n```",
                "solutionTags": [],
                "code": "```\n/**\n * @param {string[]} emails\n * @return {number}\n */\nvar numUniqueEmails = function(emails) {\n    let trimmedUniques = new Set();\n    for (let email of emails) {\n        trimmedUniques.add(trimEmail(email));\n    }\n    return trimmedUniques.size;\n};\n\nvar trimEmail = function(email) {\n    let localList = [];\n    let i = 0;\n    while (email[i] !== '@' && email[i] !== '+') {\n        if (email[i] !== '.') localList.push(email[i]);\n        i++;\n    }\n    while (email[i] !== '@') {\n        i++;\n    }\n    let domain = email.substring(i);\n    return localList.join('') + domain;\n}\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3867641,
                "title": "simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        arr=[]\\n        for i in emails:\\n            if \\'@\\' in i:\\n                at = i.index(\\'@\\')\\n                temp=i[:at]\\n                temp=temp.replace(\".\",\"\")\\n                \\n                if \\'+\\' in temp:\\n                    plus = temp.index(\\'+\\')\\n                    temp = temp[0:plus]\\n                temp+=i[at:]\\n                if temp not in arr:\\n                    arr.append(temp)\\n            else:\\n                continue\\n        #print(arr)\\n        return len(arr)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numUniqueEmails(self, emails: List[str]) -> int:\\n        arr=[]\\n        for i in emails:\\n            if \\'@\\' in i:\\n                at = i.index(\\'@\\')\\n                temp=i[:at]\\n                temp=temp.replace(\".\",\"\")\\n                \\n                if \\'+\\' in temp:\\n                    plus = temp.index(\\'+\\')\\n                    temp = temp[0:plus]\\n                temp+=i[at:]\\n                if temp not in arr:\\n                    arr.append(temp)\\n            else:\\n                continue\\n        #print(arr)\\n        return len(arr)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837798,
                "title": "easy-solution-java",
                "content": "# Code\\n```\\nclass Solution{\\n    public int numUniqueEmails(String[] emails){\\n        int n = emails.length;\\n        HashSet<String> ans = new HashSet<>();\\n        for(int i=0; i<n; i++){\\n            String[] tmp = emails[i].split(\"@\");\\n            StringBuilder a = new StringBuilder(\"\");\\n            for(int j=0; j<tmp[0].length(); j++){\\n                if(tmp[0].charAt(j)==\\'+\\') break;\\n                if(tmp[0].charAt(j)!=46) a.append(tmp[0].charAt(j));\\n                \\n            }\\n            a.append(\\'@\\');\\n            a.append(tmp[1]);\\n            ans.add(a.toString());\\n        }\\n        return ans.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution{\\n    public int numUniqueEmails(String[] emails){\\n        int n = emails.length;\\n        HashSet<String> ans = new HashSet<>();\\n        for(int i=0; i<n; i++){\\n            String[] tmp = emails[i].split(\"@\");\\n            StringBuilder a = new StringBuilder(\"\");\\n            for(int j=0; j<tmp[0].length(); j++){\\n                if(tmp[0].charAt(j)==\\'+\\') break;\\n                if(tmp[0].charAt(j)!=46) a.append(tmp[0].charAt(j));\\n                \\n            }\\n            a.append(\\'@\\');\\n            a.append(tmp[1]);\\n            ans.add(a.toString());\\n        }\\n        return ans.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492697,
                "title": "c-hashset-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int NumUniqueEmails(string[] emails) {\\n        HashSet<string> uniqueEmails = new HashSet<string>();\\n        foreach(string email in emails){\\n            string[] emailNames = email.Split(\\'@\\');\\n            string localName = emailNames[0];\\n            string domainName = emailNames[1];\\n            if(localName.Contains(\\'+\\')){\\n                localName = localName.Split(\\'+\\')[0];  \\n            }\\n            localName = localName.Replace(\".\",String.Empty);\\n            string forwardedEmail = localName +\"@\"+ domainName;\\n            uniqueEmails.Add(forwardedEmail);   \\n        }\\n        return uniqueEmails.Count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int NumUniqueEmails(string[] emails) {\\n        HashSet<string> uniqueEmails = new HashSet<string>();\\n        foreach(string email in emails){\\n            string[] emailNames = email.Split(\\'@\\');\\n            string localName = emailNames[0];\\n            string domainName = emailNames[1];\\n            if(localName.Contains(\\'+\\')){\\n                localName = localName.Split(\\'+\\')[0];  \\n            }\\n            localName = localName.Replace(\".\",String.Empty);\\n            string forwardedEmail = localName +\"@\"+ domainName;\\n            uniqueEmails.Add(forwardedEmail);   \\n        }\\n        return uniqueEmails.Count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348698,
                "title": "unique-email-addresses-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^3)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        int i, j, count, flag1=0;\\n        for(i=0 ; i<emails.size() ; i++)\\n        {\\n            j=0;\\n            flag1=0;\\n            while(j<emails[i].size())\\n            {\\n                if(emails[i][j]==\\'.\\' && flag1==0)\\n                {\\n                    emails[i].erase(emails[i].begin()+j);\\n                }\\n                else if(emails[i][j]==\\'@\\')\\n                {\\n                    flag1=1;\\n                    j++;\\n                }\\n                else if(emails[i][j]==\\'+\\' && flag1==0)\\n                {\\n                    while(emails[i][j]!=\\'@\\')\\n                    {\\n                        emails[i].erase(emails[i].begin()+j);\\n                    }\\n                }\\n                else\\n                {\\n                    j++;\\n                }\\n            }\\n        }\\n        i=0;\\n        while(i<emails.size())\\n        {\\n            j=i+1;\\n            while(j<emails.size())\\n            {\\n                if(emails[i]==emails[j])\\n                {\\n                    emails.erase(emails.begin()+j);\\n                }\\n                else\\n                {\\n                    j++;\\n                }\\n            }\\n            i++;\\n        }\\n        count = emails.size();\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        int i, j, count, flag1=0;\\n        for(i=0 ; i<emails.size() ; i++)\\n        {\\n            j=0;\\n            flag1=0;\\n            while(j<emails[i].size())\\n            {\\n                if(emails[i][j]==\\'.\\' && flag1==0)\\n                {\\n                    emails[i].erase(emails[i].begin()+j);\\n                }\\n                else if(emails[i][j]==\\'@\\')\\n                {\\n                    flag1=1;\\n                    j++;\\n                }\\n                else if(emails[i][j]==\\'+\\' && flag1==0)\\n                {\\n                    while(emails[i][j]!=\\'@\\')\\n                    {\\n                        emails[i].erase(emails[i].begin()+j);\\n                    }\\n                }\\n                else\\n                {\\n                    j++;\\n                }\\n            }\\n        }\\n        i=0;\\n        while(i<emails.size())\\n        {\\n            j=i+1;\\n            while(j<emails.size())\\n            {\\n                if(emails[i]==emails[j])\\n                {\\n                    emails.erase(emails.begin()+j);\\n                }\\n                else\\n                {\\n                    j++;\\n                }\\n            }\\n            i++;\\n        }\\n        count = emails.size();\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294872,
                "title": "java-fast-and-simple-solution-hashset-string-methods",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public static int numUniqueEmails(String[] emails) {\\n        Set<String> uniqueEmails = new HashSet<>();\\n        for (String email : emails) {\\n            String localName = email.substring(0, email.indexOf(\\'@\\'));\\n            localName = localName.replace(\".\", \"\");\\n            if (localName.indexOf(\\'+\\') >= 0) {\\n                localName = localName.substring(0, localName.indexOf(\\'+\\'));\\n            }\\n            uniqueEmails.add(localName + email.substring(email.indexOf(\\'@\\')));\\n        }\\n\\n        return uniqueEmails.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n\\n    public static int numUniqueEmails(String[] emails) {\\n        Set<String> uniqueEmails = new HashSet<>();\\n        for (String email : emails) {\\n            String localName = email.substring(0, email.indexOf(\\'@\\'));\\n            localName = localName.replace(\".\", \"\");\\n            if (localName.indexOf(\\'+\\') >= 0) {\\n                localName = localName.substring(0, localName.indexOf(\\'+\\'));\\n            }\\n            uniqueEmails.add(localName + email.substring(email.indexOf(\\'@\\')));\\n        }\\n\\n        return uniqueEmails.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095656,
                "title": "c-929-unique-email-addresses-beats-86-78-with-split-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe Split methods bestest instead of SubString. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nRuntime 92 ms Beats 86.78%\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nMemory 45.1 MB Beats 30.99%\\n\\n# Code\\n```\\npublic class Solution {\\n    public int NumUniqueEmails(string[] emails) {\\n        var uniqueList = new HashSet<string>();\\n        foreach(var email in emails){\\n            var emailSplited =  email.Split(\\'@\\');\\n            var local = emailSplited[0];\\n            var domain = emailSplited[1];\\n\\n            if (local.Contains(\\'+\\')){\\n                local = local.Substring(0,local.IndexOf(\\'+\\'));\\n            }\\n            local = local.Replace(\".\",\"\");\\n            uniqueList.Add(local + \"@\"+domain);\\n        }\\n        return uniqueList.Count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int NumUniqueEmails(string[] emails) {\\n        var uniqueList = new HashSet<string>();\\n        foreach(var email in emails){\\n            var emailSplited =  email.Split(\\'@\\');\\n            var local = emailSplited[0];\\n            var domain = emailSplited[1];\\n\\n            if (local.Contains(\\'+\\')){\\n                local = local.Substring(0,local.IndexOf(\\'+\\'));\\n            }\\n            local = local.Replace(\".\",\"\");\\n            uniqueList.Add(local + \"@\"+domain);\\n        }\\n        return uniqueList.Count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094970,
                "title": "beginner-friendly-and-easy-to-understand-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        HashSet<String> unique_emails = new HashSet();\\n        for(String email : emails){\\n            int split_position = email.indexOf(\"@\");\\n            String local_name = email.substring(0, split_position);\\n            String domain_name = email.substring(split_position);\\n\\n            if(local_name.contains(\"+\")){\\n                int plus_position = local_name.indexOf(\"+\");\\n                local_name = local_name.substring(0, plus_position);\\n            }\\n\\n            local_name = local_name.replaceAll(\"\\\\\\\\.\",\"\");\\n            String new_name = local_name+domain_name;\\n            unique_emails.add(new_name);\\n        }\\n        return unique_emails.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        HashSet<String> unique_emails = new HashSet();\\n        for(String email : emails){\\n            int split_position = email.indexOf(\"@\");\\n            String local_name = email.substring(0, split_position);\\n            String domain_name = email.substring(split_position);\\n\\n            if(local_name.contains(\"+\")){\\n                int plus_position = local_name.indexOf(\"+\");\\n                local_name = local_name.substring(0, plus_position);\\n            }\\n\\n            local_name = local_name.replaceAll(\"\\\\\\\\.\",\"\");\\n            String new_name = local_name+domain_name;\\n            unique_emails.add(new_name);\\n        }\\n        return unique_emails.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078642,
                "title": "easy-to-understand-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        int k=0;\\n        int flag=0;\\n        for(int i=0;i<emails.size();i++){\\n            flag=0;\\n            for(int j=0;j<emails[i].size();j++){\\n                if(emails[i][j]==\\'@\\') break;\\n                if(emails[i][j]==\\'.\\') emails[i].erase(j,1);\\n                else if(emails[i][j]==\\'+\\'){\\n                    flag=1;\\n                    k=j+1;\\n                    while(emails[i][k]!=\\'@\\'){\\n                        k++;\\n                    }\\n                    emails[i].erase(j,(k-j));\\n                }\\n                if(flag==1) break;\\n                k=0;\\n            }\\n        }\\n        set <string> str(emails.begin(),emails.end());\\n        emails.clear();\\n        emails.assign(str.begin(),str.end());\\n         return emails.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        int k=0;\\n        int flag=0;\\n        for(int i=0;i<emails.size();i++){\\n            flag=0;\\n            for(int j=0;j<emails[i].size();j++){\\n                if(emails[i][j]==\\'@\\') break;\\n                if(emails[i][j]==\\'.\\') emails[i].erase(j,1);\\n                else if(emails[i][j]==\\'+\\'){\\n                    flag=1;\\n                    k=j+1;\\n                    while(emails[i][k]!=\\'@\\'){\\n                        k++;\\n                    }\\n                    emails[i].erase(j,(k-j));\\n                }\\n                if(flag==1) break;\\n                k=0;\\n            }\\n        }\\n        set <string> str(emails.begin(),emails.end());\\n        emails.clear();\\n        emails.assign(str.begin(),str.end());\\n         return emails.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3073504,
                "title": "java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        HashSet<String>set = new HashSet();\\n        for(String x:emails){\\n            StringBuilder temp = new StringBuilder();\\n            for(int i=0;i<x.length();i++){\\n                if(x.charAt(i)==\\'@\\' || x.charAt(i)==\\'+\\'){\\n                    break;\\n                }\\n                else if(x.charAt(i)!=\\'.\\'){\\n                       temp.append(x.charAt(i)+\"\"); \\n                }\\n            }\\n            temp.append(x.substring(x.indexOf(\\'@\\'),x.length()));\\n            set.add(temp.toString());\\n            temp.setLength(0);\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        HashSet<String>set = new HashSet();\\n        for(String x:emails){\\n            StringBuilder temp = new StringBuilder();\\n            for(int i=0;i<x.length();i++){\\n                if(x.charAt(i)==\\'@\\' || x.charAt(i)==\\'+\\'){\\n                    break;\\n                }\\n                else if(x.charAt(i)!=\\'.\\'){\\n                       temp.append(x.charAt(i)+\"\"); \\n                }\\n            }\\n            temp.append(x.substring(x.indexOf(\\'@\\'),x.length()));\\n            set.add(temp.toString());\\n            temp.setLength(0);\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2938347,
                "title": "simple-kotlin-solution-for-beginners",
                "content": "```\\nclass Solution {\\n    fun numUniqueEmails(emails: Array<String>): Int {\\n        val set = HashSet<String>()\\n\\n        for (email in emails) {\\n            val parts = email.split(\"@\")\\n            val name = parts[0].split(\"+\")[0].replace(\".\", \"\")\\n            val domain = parts[1].split(\".com\")[0]\\n            set.add(\"$name@$domain\")\\n        }\\n\\n        return set.size\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun numUniqueEmails(emails: Array<String>): Int {\\n        val set = HashSet<String>()\\n\\n        for (email in emails) {\\n            val parts = email.split(\"@\")\\n            val name = parts[0].split(\"+\")[0].replace(\".\", \"\")\\n            val domain = parts[1].split(\".com\")[0]\\n            set.add(\"$name@$domain\")\\n        }\\n\\n        return set.size\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2733123,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        int ans=0;\\n        unordered_set<string>v;\\n        for(int i=0;i<emails.size();i++)\\n        {\\n            string s=emails[i];\\n         \\n            string a=\"\";\\n            int k=0;\\n            for(int i=0;i<s.size();i++)\\n            {\\n                if(s[i]==\\'@\\')\\n                {\\n                    k=i;\\n                break;\\n                }\\n                else{\\n                a.push_back(s[i]);\\n                }\\n                \\n            }\\n            //cout<<a<<\" \";\\n            string b=\"\";\\n            for(int i=0;i<a.size();i++)\\n            {\\n                 if(a[i]==\\'+\\')\\n                {\\n                break;\\n                }\\n                if(a[i]!=\\'.\\')\\n                {\\n                    b.push_back(a[i]);\\n                  \\n                }\\n              \\n               \\n            }\\n             cout<<b<<\" \";\\n            b+=s.substr(k,s.size());\\n           //cout<<b<<\" \";\\n            v.insert(b);\\n        }\\n        return v.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        int ans=0;\\n        unordered_set<string>v;\\n        for(int i=0;i<emails.size();i++)\\n        {\\n            string s=emails[i];\\n         \\n            string a=\"\";\\n            int k=0;\\n            for(int i=0;i<s.size();i++)\\n            {\\n                if(s[i]==\\'@\\')\\n                {\\n                    k=i;\\n                break;\\n                }\\n                else{\\n                a.push_back(s[i]);\\n                }\\n                \\n            }\\n            //cout<<a<<\" \";\\n            string b=\"\";\\n            for(int i=0;i<a.size();i++)\\n            {\\n                 if(a[i]==\\'+\\')\\n                {\\n                break;\\n                }\\n                if(a[i]!=\\'.\\')\\n                {\\n                    b.push_back(a[i]);\\n                  \\n                }\\n              \\n               \\n            }\\n             cout<<b<<\" \";\\n            b+=s.substr(k,s.size());\\n           //cout<<b<<\" \";\\n            v.insert(b);\\n        }\\n        return v.size();\\n    }\\n};\\n```",
                "codeTag": "C++"
            }
        ],
        "discussions": [
            {
                "id": 1575112,
                "content": [
                    {
                        "username": "isabellarochailr",
                        "content": "For the first case example it states that \\n\\' \"testemail@leetcode.com\" and \"testemail@lee.tcode.com\" actually receive mails. \\'\\n;however, \\'\"testemail@lee.tcode.com\"\\' should not receive emails since it has \\'.\\' inside the domain which was stated that it should not be applied to the domain. The correct explanation would have been: \\n\\' \"test.email+alex@leetcode.com\" and \"test.e.mail+bob.cathy@leetcode.com\" actually receive mails. \\'"
                    },
                    {
                        "username": "gjbgpr",
                        "content": "[@Kashish905](/Kashish905) [@isabellarochailr](/isabellarochailr) I actually had the same doubt, since it clearly states\\n\\n\"If you add periods \\'.\\' between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name. **Note that this rule does not apply to domain names.**\""
                    },
                    {
                        "username": "Kashish905",
                        "content": " \"testemail@lee.tcode.com\"  could receive email, maybe you have read the question wrong, \".\" case could be applied to the domain name but not the \"+\" case."
                    },
                    {
                        "username": "Kashish905",
                        "content": "you are wrong buddy."
                    },
                    {
                        "username": "paopao100097",
                        "content": "test case:\\n[\"test.email+alex@leetcode.com\",\"ttest.e.mail+bob.cathy@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"]\\n\\nthe result should be 3, however, the answer by that solution is 2."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think we have three here. The second email has as local name: ttestemail. with \\'tt\\'. "
                    },
                    {
                        "username": "dpauly",
                        "content": "The question description says that dots (.) are ignored in the local part of the email but not ignored for the domain name part of the email (i.e., everything following the \\'@\\' symbol)"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "I ran it, it says the solution is 3"
                    },
                    {
                        "username": "Shyamal122",
                        "content": "Trash Question I have even seen. "
                    },
                    {
                        "username": "afanta",
                        "content": "[\"test.email+alex@leetcode.com\",\"test.email.leet+alex@code.com\"]\\nwhy the expected number is 2? in 183 test case"
                    },
                    {
                        "username": "20A31A05G8",
                        "content": "{\\'testemail@leetcode.com\\', \\'testemailleet@code.com\\'} is result (2 unique emails)"
                    },
                    {
                        "username": "anoop5737v",
                        "content": "class Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        set<string> s;\\n        int l=emails.size();\\n        for(int i=0;i<l;i++)\\n        {\\n            string p=emails[i];\\n            string w;\\n            int y=0;\\n            int pl=emails[i].size();\\n            for(int j=0;j<pl;j++)\\n            {\\n              if(p[j]==\\'@\\')\\n              {\\n                  while(j<pl)\\n                  w[y++]=p[j++];\\n              }\\n              if(p[j]==\\'+\\')\\n              {\\n                  while(p[j]!=\\'@\\')\\n                  j++;\\n                  if(p[j]==\\'@\\')\\n              {\\n                  while(j<pl)\\n                  w[y++]=p[j++];\\n              }\\n              }\\n              if(p[j]!=\\'.\\')\\n              w[y++]=p[j];\\n              \\n            }\\n            s.insert(w);\\n            w.clear();\\n        }\\n        return s.size();\\n        \\n    }\\n};\\n\\n//  this code is giving overflow ,why,please explain any one\\n"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "Man this question fckd me up"
                    },
                    {
                        "username": "mochiball",
                        "content": "lmaooo"
                    },
                    {
                        "username": "jespinos08",
                        "content": "I don\\'t get why my code if failing for test case emails = [\"fg.r.u.uzj+o.pw@kziczvh.com\",\"r.cyo.g+d.h+b.ja@tgsg.z.com\",\"fg.r.u.uzj+o.f.d@kziczvh.com\",\"r.cyo.g+ng.r.iq@tgsg.z.com\",\"fg.r.u.uzj+lp.k@kziczvh.com\",\"r.cyo.g+n.h.e+n.g@tgsg.z.com\",\"fg.r.u.uzj+k+p.j@kziczvh.com\",\"fg.r.u.uzj+w.y+b@kziczvh.com\",\"r.cyo.g+x+d.c+f.t@tgsg.z.com\",\"r.cyo.g+x+t.y.l.i@tgsg.z.com\",\"r.cyo.g+brxxi@tgsg.z.com\",\"r.cyo.g+z+dr.k.u@tgsg.z.com\",\"r.cyo.g+d+l.c.n+g@tgsg.z.com\",\"fg.r.u.uzj+vq.o@kziczvh.com\",\"fg.r.u.uzj+uzq@kziczvh.com\",\"fg.r.u.uzj+mvz@kziczvh.com\",\"fg.r.u.uzj+taj@kziczvh.com\",\"fg.r.u.uzj+fek@kziczvh.com\"]\\n\\nHere\\'s my code:  \\n```\\nvar numUniqueEmails = function(emails) {\\n    let local = [];\\n    let domain = [];\\n    let unique = new Set();\\n\\n    emails.forEach(email => {\\n      email = email.split(\\'@\\');\\n      local.push(email[0]);\\n      domain.push(email[1]);\\n    });\\n\\n    for (let email of local) {\\n      if (email.includes(\\'+\\')) {\\n        email = email.slice(0, email.indexOf(\\'+\\'));        \\n      }\\n      email = email.replaceAll(\\'.\\', \\'\\');\\n\\n      for (const dom of domain) {        \\n          unique.add(email + \\'@\\' + dom);        \\n      }      \\n    }    \\n    console.log(unique);\\n\\n    return unique.size; \\n};\\n``` \\n\\nWhen I log my unique Set, the valid emails I get are:  \\'fgruuzj@kziczvh.com\\',\\n  \\'fgruuzj@tgsg.z.com\\',\\n  \\'rcyog@kziczvh.com\\',\\n  \\'rcyog@tgsg.z.com\\'\\n\\nArent all of those unique and valid? Therefore, the answer should be 4 and not 2?"
                    }
                ]
            },
            {
                "id": 1572424,
                "content": [
                    {
                        "username": "isabellarochailr",
                        "content": "For the first case example it states that \\n\\' \"testemail@leetcode.com\" and \"testemail@lee.tcode.com\" actually receive mails. \\'\\n;however, \\'\"testemail@lee.tcode.com\"\\' should not receive emails since it has \\'.\\' inside the domain which was stated that it should not be applied to the domain. The correct explanation would have been: \\n\\' \"test.email+alex@leetcode.com\" and \"test.e.mail+bob.cathy@leetcode.com\" actually receive mails. \\'"
                    },
                    {
                        "username": "gjbgpr",
                        "content": "[@Kashish905](/Kashish905) [@isabellarochailr](/isabellarochailr) I actually had the same doubt, since it clearly states\\n\\n\"If you add periods \\'.\\' between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name. **Note that this rule does not apply to domain names.**\""
                    },
                    {
                        "username": "Kashish905",
                        "content": " \"testemail@lee.tcode.com\"  could receive email, maybe you have read the question wrong, \".\" case could be applied to the domain name but not the \"+\" case."
                    },
                    {
                        "username": "Kashish905",
                        "content": "you are wrong buddy."
                    },
                    {
                        "username": "paopao100097",
                        "content": "test case:\\n[\"test.email+alex@leetcode.com\",\"ttest.e.mail+bob.cathy@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"]\\n\\nthe result should be 3, however, the answer by that solution is 2."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think we have three here. The second email has as local name: ttestemail. with \\'tt\\'. "
                    },
                    {
                        "username": "dpauly",
                        "content": "The question description says that dots (.) are ignored in the local part of the email but not ignored for the domain name part of the email (i.e., everything following the \\'@\\' symbol)"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "I ran it, it says the solution is 3"
                    },
                    {
                        "username": "Shyamal122",
                        "content": "Trash Question I have even seen. "
                    },
                    {
                        "username": "afanta",
                        "content": "[\"test.email+alex@leetcode.com\",\"test.email.leet+alex@code.com\"]\\nwhy the expected number is 2? in 183 test case"
                    },
                    {
                        "username": "20A31A05G8",
                        "content": "{\\'testemail@leetcode.com\\', \\'testemailleet@code.com\\'} is result (2 unique emails)"
                    },
                    {
                        "username": "anoop5737v",
                        "content": "class Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        set<string> s;\\n        int l=emails.size();\\n        for(int i=0;i<l;i++)\\n        {\\n            string p=emails[i];\\n            string w;\\n            int y=0;\\n            int pl=emails[i].size();\\n            for(int j=0;j<pl;j++)\\n            {\\n              if(p[j]==\\'@\\')\\n              {\\n                  while(j<pl)\\n                  w[y++]=p[j++];\\n              }\\n              if(p[j]==\\'+\\')\\n              {\\n                  while(p[j]!=\\'@\\')\\n                  j++;\\n                  if(p[j]==\\'@\\')\\n              {\\n                  while(j<pl)\\n                  w[y++]=p[j++];\\n              }\\n              }\\n              if(p[j]!=\\'.\\')\\n              w[y++]=p[j];\\n              \\n            }\\n            s.insert(w);\\n            w.clear();\\n        }\\n        return s.size();\\n        \\n    }\\n};\\n\\n//  this code is giving overflow ,why,please explain any one\\n"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "Man this question fckd me up"
                    },
                    {
                        "username": "mochiball",
                        "content": "lmaooo"
                    },
                    {
                        "username": "jespinos08",
                        "content": "I don\\'t get why my code if failing for test case emails = [\"fg.r.u.uzj+o.pw@kziczvh.com\",\"r.cyo.g+d.h+b.ja@tgsg.z.com\",\"fg.r.u.uzj+o.f.d@kziczvh.com\",\"r.cyo.g+ng.r.iq@tgsg.z.com\",\"fg.r.u.uzj+lp.k@kziczvh.com\",\"r.cyo.g+n.h.e+n.g@tgsg.z.com\",\"fg.r.u.uzj+k+p.j@kziczvh.com\",\"fg.r.u.uzj+w.y+b@kziczvh.com\",\"r.cyo.g+x+d.c+f.t@tgsg.z.com\",\"r.cyo.g+x+t.y.l.i@tgsg.z.com\",\"r.cyo.g+brxxi@tgsg.z.com\",\"r.cyo.g+z+dr.k.u@tgsg.z.com\",\"r.cyo.g+d+l.c.n+g@tgsg.z.com\",\"fg.r.u.uzj+vq.o@kziczvh.com\",\"fg.r.u.uzj+uzq@kziczvh.com\",\"fg.r.u.uzj+mvz@kziczvh.com\",\"fg.r.u.uzj+taj@kziczvh.com\",\"fg.r.u.uzj+fek@kziczvh.com\"]\\n\\nHere\\'s my code:  \\n```\\nvar numUniqueEmails = function(emails) {\\n    let local = [];\\n    let domain = [];\\n    let unique = new Set();\\n\\n    emails.forEach(email => {\\n      email = email.split(\\'@\\');\\n      local.push(email[0]);\\n      domain.push(email[1]);\\n    });\\n\\n    for (let email of local) {\\n      if (email.includes(\\'+\\')) {\\n        email = email.slice(0, email.indexOf(\\'+\\'));        \\n      }\\n      email = email.replaceAll(\\'.\\', \\'\\');\\n\\n      for (const dom of domain) {        \\n          unique.add(email + \\'@\\' + dom);        \\n      }      \\n    }    \\n    console.log(unique);\\n\\n    return unique.size; \\n};\\n``` \\n\\nWhen I log my unique Set, the valid emails I get are:  \\'fgruuzj@kziczvh.com\\',\\n  \\'fgruuzj@tgsg.z.com\\',\\n  \\'rcyog@kziczvh.com\\',\\n  \\'rcyog@tgsg.z.com\\'\\n\\nArent all of those unique and valid? Therefore, the answer should be 4 and not 2?"
                    }
                ]
            },
            {
                "id": 2053828,
                "content": [
                    {
                        "username": "isabellarochailr",
                        "content": "For the first case example it states that \\n\\' \"testemail@leetcode.com\" and \"testemail@lee.tcode.com\" actually receive mails. \\'\\n;however, \\'\"testemail@lee.tcode.com\"\\' should not receive emails since it has \\'.\\' inside the domain which was stated that it should not be applied to the domain. The correct explanation would have been: \\n\\' \"test.email+alex@leetcode.com\" and \"test.e.mail+bob.cathy@leetcode.com\" actually receive mails. \\'"
                    },
                    {
                        "username": "gjbgpr",
                        "content": "[@Kashish905](/Kashish905) [@isabellarochailr](/isabellarochailr) I actually had the same doubt, since it clearly states\\n\\n\"If you add periods \\'.\\' between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name. **Note that this rule does not apply to domain names.**\""
                    },
                    {
                        "username": "Kashish905",
                        "content": " \"testemail@lee.tcode.com\"  could receive email, maybe you have read the question wrong, \".\" case could be applied to the domain name but not the \"+\" case."
                    },
                    {
                        "username": "Kashish905",
                        "content": "you are wrong buddy."
                    },
                    {
                        "username": "paopao100097",
                        "content": "test case:\\n[\"test.email+alex@leetcode.com\",\"ttest.e.mail+bob.cathy@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"]\\n\\nthe result should be 3, however, the answer by that solution is 2."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think we have three here. The second email has as local name: ttestemail. with \\'tt\\'. "
                    },
                    {
                        "username": "dpauly",
                        "content": "The question description says that dots (.) are ignored in the local part of the email but not ignored for the domain name part of the email (i.e., everything following the \\'@\\' symbol)"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "I ran it, it says the solution is 3"
                    },
                    {
                        "username": "Shyamal122",
                        "content": "Trash Question I have even seen. "
                    },
                    {
                        "username": "afanta",
                        "content": "[\"test.email+alex@leetcode.com\",\"test.email.leet+alex@code.com\"]\\nwhy the expected number is 2? in 183 test case"
                    },
                    {
                        "username": "20A31A05G8",
                        "content": "{\\'testemail@leetcode.com\\', \\'testemailleet@code.com\\'} is result (2 unique emails)"
                    },
                    {
                        "username": "anoop5737v",
                        "content": "class Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        set<string> s;\\n        int l=emails.size();\\n        for(int i=0;i<l;i++)\\n        {\\n            string p=emails[i];\\n            string w;\\n            int y=0;\\n            int pl=emails[i].size();\\n            for(int j=0;j<pl;j++)\\n            {\\n              if(p[j]==\\'@\\')\\n              {\\n                  while(j<pl)\\n                  w[y++]=p[j++];\\n              }\\n              if(p[j]==\\'+\\')\\n              {\\n                  while(p[j]!=\\'@\\')\\n                  j++;\\n                  if(p[j]==\\'@\\')\\n              {\\n                  while(j<pl)\\n                  w[y++]=p[j++];\\n              }\\n              }\\n              if(p[j]!=\\'.\\')\\n              w[y++]=p[j];\\n              \\n            }\\n            s.insert(w);\\n            w.clear();\\n        }\\n        return s.size();\\n        \\n    }\\n};\\n\\n//  this code is giving overflow ,why,please explain any one\\n"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "Man this question fckd me up"
                    },
                    {
                        "username": "mochiball",
                        "content": "lmaooo"
                    },
                    {
                        "username": "jespinos08",
                        "content": "I don\\'t get why my code if failing for test case emails = [\"fg.r.u.uzj+o.pw@kziczvh.com\",\"r.cyo.g+d.h+b.ja@tgsg.z.com\",\"fg.r.u.uzj+o.f.d@kziczvh.com\",\"r.cyo.g+ng.r.iq@tgsg.z.com\",\"fg.r.u.uzj+lp.k@kziczvh.com\",\"r.cyo.g+n.h.e+n.g@tgsg.z.com\",\"fg.r.u.uzj+k+p.j@kziczvh.com\",\"fg.r.u.uzj+w.y+b@kziczvh.com\",\"r.cyo.g+x+d.c+f.t@tgsg.z.com\",\"r.cyo.g+x+t.y.l.i@tgsg.z.com\",\"r.cyo.g+brxxi@tgsg.z.com\",\"r.cyo.g+z+dr.k.u@tgsg.z.com\",\"r.cyo.g+d+l.c.n+g@tgsg.z.com\",\"fg.r.u.uzj+vq.o@kziczvh.com\",\"fg.r.u.uzj+uzq@kziczvh.com\",\"fg.r.u.uzj+mvz@kziczvh.com\",\"fg.r.u.uzj+taj@kziczvh.com\",\"fg.r.u.uzj+fek@kziczvh.com\"]\\n\\nHere\\'s my code:  \\n```\\nvar numUniqueEmails = function(emails) {\\n    let local = [];\\n    let domain = [];\\n    let unique = new Set();\\n\\n    emails.forEach(email => {\\n      email = email.split(\\'@\\');\\n      local.push(email[0]);\\n      domain.push(email[1]);\\n    });\\n\\n    for (let email of local) {\\n      if (email.includes(\\'+\\')) {\\n        email = email.slice(0, email.indexOf(\\'+\\'));        \\n      }\\n      email = email.replaceAll(\\'.\\', \\'\\');\\n\\n      for (const dom of domain) {        \\n          unique.add(email + \\'@\\' + dom);        \\n      }      \\n    }    \\n    console.log(unique);\\n\\n    return unique.size; \\n};\\n``` \\n\\nWhen I log my unique Set, the valid emails I get are:  \\'fgruuzj@kziczvh.com\\',\\n  \\'fgruuzj@tgsg.z.com\\',\\n  \\'rcyog@kziczvh.com\\',\\n  \\'rcyog@tgsg.z.com\\'\\n\\nArent all of those unique and valid? Therefore, the answer should be 4 and not 2?"
                    }
                ]
            },
            {
                "id": 1813620,
                "content": [
                    {
                        "username": "isabellarochailr",
                        "content": "For the first case example it states that \\n\\' \"testemail@leetcode.com\" and \"testemail@lee.tcode.com\" actually receive mails. \\'\\n;however, \\'\"testemail@lee.tcode.com\"\\' should not receive emails since it has \\'.\\' inside the domain which was stated that it should not be applied to the domain. The correct explanation would have been: \\n\\' \"test.email+alex@leetcode.com\" and \"test.e.mail+bob.cathy@leetcode.com\" actually receive mails. \\'"
                    },
                    {
                        "username": "gjbgpr",
                        "content": "[@Kashish905](/Kashish905) [@isabellarochailr](/isabellarochailr) I actually had the same doubt, since it clearly states\\n\\n\"If you add periods \\'.\\' between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name. **Note that this rule does not apply to domain names.**\""
                    },
                    {
                        "username": "Kashish905",
                        "content": " \"testemail@lee.tcode.com\"  could receive email, maybe you have read the question wrong, \".\" case could be applied to the domain name but not the \"+\" case."
                    },
                    {
                        "username": "Kashish905",
                        "content": "you are wrong buddy."
                    },
                    {
                        "username": "paopao100097",
                        "content": "test case:\\n[\"test.email+alex@leetcode.com\",\"ttest.e.mail+bob.cathy@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"]\\n\\nthe result should be 3, however, the answer by that solution is 2."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think we have three here. The second email has as local name: ttestemail. with \\'tt\\'. "
                    },
                    {
                        "username": "dpauly",
                        "content": "The question description says that dots (.) are ignored in the local part of the email but not ignored for the domain name part of the email (i.e., everything following the \\'@\\' symbol)"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "I ran it, it says the solution is 3"
                    },
                    {
                        "username": "Shyamal122",
                        "content": "Trash Question I have even seen. "
                    },
                    {
                        "username": "afanta",
                        "content": "[\"test.email+alex@leetcode.com\",\"test.email.leet+alex@code.com\"]\\nwhy the expected number is 2? in 183 test case"
                    },
                    {
                        "username": "20A31A05G8",
                        "content": "{\\'testemail@leetcode.com\\', \\'testemailleet@code.com\\'} is result (2 unique emails)"
                    },
                    {
                        "username": "anoop5737v",
                        "content": "class Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        set<string> s;\\n        int l=emails.size();\\n        for(int i=0;i<l;i++)\\n        {\\n            string p=emails[i];\\n            string w;\\n            int y=0;\\n            int pl=emails[i].size();\\n            for(int j=0;j<pl;j++)\\n            {\\n              if(p[j]==\\'@\\')\\n              {\\n                  while(j<pl)\\n                  w[y++]=p[j++];\\n              }\\n              if(p[j]==\\'+\\')\\n              {\\n                  while(p[j]!=\\'@\\')\\n                  j++;\\n                  if(p[j]==\\'@\\')\\n              {\\n                  while(j<pl)\\n                  w[y++]=p[j++];\\n              }\\n              }\\n              if(p[j]!=\\'.\\')\\n              w[y++]=p[j];\\n              \\n            }\\n            s.insert(w);\\n            w.clear();\\n        }\\n        return s.size();\\n        \\n    }\\n};\\n\\n//  this code is giving overflow ,why,please explain any one\\n"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "Man this question fckd me up"
                    },
                    {
                        "username": "mochiball",
                        "content": "lmaooo"
                    },
                    {
                        "username": "jespinos08",
                        "content": "I don\\'t get why my code if failing for test case emails = [\"fg.r.u.uzj+o.pw@kziczvh.com\",\"r.cyo.g+d.h+b.ja@tgsg.z.com\",\"fg.r.u.uzj+o.f.d@kziczvh.com\",\"r.cyo.g+ng.r.iq@tgsg.z.com\",\"fg.r.u.uzj+lp.k@kziczvh.com\",\"r.cyo.g+n.h.e+n.g@tgsg.z.com\",\"fg.r.u.uzj+k+p.j@kziczvh.com\",\"fg.r.u.uzj+w.y+b@kziczvh.com\",\"r.cyo.g+x+d.c+f.t@tgsg.z.com\",\"r.cyo.g+x+t.y.l.i@tgsg.z.com\",\"r.cyo.g+brxxi@tgsg.z.com\",\"r.cyo.g+z+dr.k.u@tgsg.z.com\",\"r.cyo.g+d+l.c.n+g@tgsg.z.com\",\"fg.r.u.uzj+vq.o@kziczvh.com\",\"fg.r.u.uzj+uzq@kziczvh.com\",\"fg.r.u.uzj+mvz@kziczvh.com\",\"fg.r.u.uzj+taj@kziczvh.com\",\"fg.r.u.uzj+fek@kziczvh.com\"]\\n\\nHere\\'s my code:  \\n```\\nvar numUniqueEmails = function(emails) {\\n    let local = [];\\n    let domain = [];\\n    let unique = new Set();\\n\\n    emails.forEach(email => {\\n      email = email.split(\\'@\\');\\n      local.push(email[0]);\\n      domain.push(email[1]);\\n    });\\n\\n    for (let email of local) {\\n      if (email.includes(\\'+\\')) {\\n        email = email.slice(0, email.indexOf(\\'+\\'));        \\n      }\\n      email = email.replaceAll(\\'.\\', \\'\\');\\n\\n      for (const dom of domain) {        \\n          unique.add(email + \\'@\\' + dom);        \\n      }      \\n    }    \\n    console.log(unique);\\n\\n    return unique.size; \\n};\\n``` \\n\\nWhen I log my unique Set, the valid emails I get are:  \\'fgruuzj@kziczvh.com\\',\\n  \\'fgruuzj@tgsg.z.com\\',\\n  \\'rcyog@kziczvh.com\\',\\n  \\'rcyog@tgsg.z.com\\'\\n\\nArent all of those unique and valid? Therefore, the answer should be 4 and not 2?"
                    }
                ]
            },
            {
                "id": 2048817,
                "content": [
                    {
                        "username": "isabellarochailr",
                        "content": "For the first case example it states that \\n\\' \"testemail@leetcode.com\" and \"testemail@lee.tcode.com\" actually receive mails. \\'\\n;however, \\'\"testemail@lee.tcode.com\"\\' should not receive emails since it has \\'.\\' inside the domain which was stated that it should not be applied to the domain. The correct explanation would have been: \\n\\' \"test.email+alex@leetcode.com\" and \"test.e.mail+bob.cathy@leetcode.com\" actually receive mails. \\'"
                    },
                    {
                        "username": "gjbgpr",
                        "content": "[@Kashish905](/Kashish905) [@isabellarochailr](/isabellarochailr) I actually had the same doubt, since it clearly states\\n\\n\"If you add periods \\'.\\' between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name. **Note that this rule does not apply to domain names.**\""
                    },
                    {
                        "username": "Kashish905",
                        "content": " \"testemail@lee.tcode.com\"  could receive email, maybe you have read the question wrong, \".\" case could be applied to the domain name but not the \"+\" case."
                    },
                    {
                        "username": "Kashish905",
                        "content": "you are wrong buddy."
                    },
                    {
                        "username": "paopao100097",
                        "content": "test case:\\n[\"test.email+alex@leetcode.com\",\"ttest.e.mail+bob.cathy@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"]\\n\\nthe result should be 3, however, the answer by that solution is 2."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think we have three here. The second email has as local name: ttestemail. with \\'tt\\'. "
                    },
                    {
                        "username": "dpauly",
                        "content": "The question description says that dots (.) are ignored in the local part of the email but not ignored for the domain name part of the email (i.e., everything following the \\'@\\' symbol)"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "I ran it, it says the solution is 3"
                    },
                    {
                        "username": "Shyamal122",
                        "content": "Trash Question I have even seen. "
                    },
                    {
                        "username": "afanta",
                        "content": "[\"test.email+alex@leetcode.com\",\"test.email.leet+alex@code.com\"]\\nwhy the expected number is 2? in 183 test case"
                    },
                    {
                        "username": "20A31A05G8",
                        "content": "{\\'testemail@leetcode.com\\', \\'testemailleet@code.com\\'} is result (2 unique emails)"
                    },
                    {
                        "username": "anoop5737v",
                        "content": "class Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        set<string> s;\\n        int l=emails.size();\\n        for(int i=0;i<l;i++)\\n        {\\n            string p=emails[i];\\n            string w;\\n            int y=0;\\n            int pl=emails[i].size();\\n            for(int j=0;j<pl;j++)\\n            {\\n              if(p[j]==\\'@\\')\\n              {\\n                  while(j<pl)\\n                  w[y++]=p[j++];\\n              }\\n              if(p[j]==\\'+\\')\\n              {\\n                  while(p[j]!=\\'@\\')\\n                  j++;\\n                  if(p[j]==\\'@\\')\\n              {\\n                  while(j<pl)\\n                  w[y++]=p[j++];\\n              }\\n              }\\n              if(p[j]!=\\'.\\')\\n              w[y++]=p[j];\\n              \\n            }\\n            s.insert(w);\\n            w.clear();\\n        }\\n        return s.size();\\n        \\n    }\\n};\\n\\n//  this code is giving overflow ,why,please explain any one\\n"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "Man this question fckd me up"
                    },
                    {
                        "username": "mochiball",
                        "content": "lmaooo"
                    },
                    {
                        "username": "jespinos08",
                        "content": "I don\\'t get why my code if failing for test case emails = [\"fg.r.u.uzj+o.pw@kziczvh.com\",\"r.cyo.g+d.h+b.ja@tgsg.z.com\",\"fg.r.u.uzj+o.f.d@kziczvh.com\",\"r.cyo.g+ng.r.iq@tgsg.z.com\",\"fg.r.u.uzj+lp.k@kziczvh.com\",\"r.cyo.g+n.h.e+n.g@tgsg.z.com\",\"fg.r.u.uzj+k+p.j@kziczvh.com\",\"fg.r.u.uzj+w.y+b@kziczvh.com\",\"r.cyo.g+x+d.c+f.t@tgsg.z.com\",\"r.cyo.g+x+t.y.l.i@tgsg.z.com\",\"r.cyo.g+brxxi@tgsg.z.com\",\"r.cyo.g+z+dr.k.u@tgsg.z.com\",\"r.cyo.g+d+l.c.n+g@tgsg.z.com\",\"fg.r.u.uzj+vq.o@kziczvh.com\",\"fg.r.u.uzj+uzq@kziczvh.com\",\"fg.r.u.uzj+mvz@kziczvh.com\",\"fg.r.u.uzj+taj@kziczvh.com\",\"fg.r.u.uzj+fek@kziczvh.com\"]\\n\\nHere\\'s my code:  \\n```\\nvar numUniqueEmails = function(emails) {\\n    let local = [];\\n    let domain = [];\\n    let unique = new Set();\\n\\n    emails.forEach(email => {\\n      email = email.split(\\'@\\');\\n      local.push(email[0]);\\n      domain.push(email[1]);\\n    });\\n\\n    for (let email of local) {\\n      if (email.includes(\\'+\\')) {\\n        email = email.slice(0, email.indexOf(\\'+\\'));        \\n      }\\n      email = email.replaceAll(\\'.\\', \\'\\');\\n\\n      for (const dom of domain) {        \\n          unique.add(email + \\'@\\' + dom);        \\n      }      \\n    }    \\n    console.log(unique);\\n\\n    return unique.size; \\n};\\n``` \\n\\nWhen I log my unique Set, the valid emails I get are:  \\'fgruuzj@kziczvh.com\\',\\n  \\'fgruuzj@tgsg.z.com\\',\\n  \\'rcyog@kziczvh.com\\',\\n  \\'rcyog@tgsg.z.com\\'\\n\\nArent all of those unique and valid? Therefore, the answer should be 4 and not 2?"
                    }
                ]
            },
            {
                "id": 2016387,
                "content": [
                    {
                        "username": "isabellarochailr",
                        "content": "For the first case example it states that \\n\\' \"testemail@leetcode.com\" and \"testemail@lee.tcode.com\" actually receive mails. \\'\\n;however, \\'\"testemail@lee.tcode.com\"\\' should not receive emails since it has \\'.\\' inside the domain which was stated that it should not be applied to the domain. The correct explanation would have been: \\n\\' \"test.email+alex@leetcode.com\" and \"test.e.mail+bob.cathy@leetcode.com\" actually receive mails. \\'"
                    },
                    {
                        "username": "gjbgpr",
                        "content": "[@Kashish905](/Kashish905) [@isabellarochailr](/isabellarochailr) I actually had the same doubt, since it clearly states\\n\\n\"If you add periods \\'.\\' between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name. **Note that this rule does not apply to domain names.**\""
                    },
                    {
                        "username": "Kashish905",
                        "content": " \"testemail@lee.tcode.com\"  could receive email, maybe you have read the question wrong, \".\" case could be applied to the domain name but not the \"+\" case."
                    },
                    {
                        "username": "Kashish905",
                        "content": "you are wrong buddy."
                    },
                    {
                        "username": "paopao100097",
                        "content": "test case:\\n[\"test.email+alex@leetcode.com\",\"ttest.e.mail+bob.cathy@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"]\\n\\nthe result should be 3, however, the answer by that solution is 2."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think we have three here. The second email has as local name: ttestemail. with \\'tt\\'. "
                    },
                    {
                        "username": "dpauly",
                        "content": "The question description says that dots (.) are ignored in the local part of the email but not ignored for the domain name part of the email (i.e., everything following the \\'@\\' symbol)"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "I ran it, it says the solution is 3"
                    },
                    {
                        "username": "Shyamal122",
                        "content": "Trash Question I have even seen. "
                    },
                    {
                        "username": "afanta",
                        "content": "[\"test.email+alex@leetcode.com\",\"test.email.leet+alex@code.com\"]\\nwhy the expected number is 2? in 183 test case"
                    },
                    {
                        "username": "20A31A05G8",
                        "content": "{\\'testemail@leetcode.com\\', \\'testemailleet@code.com\\'} is result (2 unique emails)"
                    },
                    {
                        "username": "anoop5737v",
                        "content": "class Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        set<string> s;\\n        int l=emails.size();\\n        for(int i=0;i<l;i++)\\n        {\\n            string p=emails[i];\\n            string w;\\n            int y=0;\\n            int pl=emails[i].size();\\n            for(int j=0;j<pl;j++)\\n            {\\n              if(p[j]==\\'@\\')\\n              {\\n                  while(j<pl)\\n                  w[y++]=p[j++];\\n              }\\n              if(p[j]==\\'+\\')\\n              {\\n                  while(p[j]!=\\'@\\')\\n                  j++;\\n                  if(p[j]==\\'@\\')\\n              {\\n                  while(j<pl)\\n                  w[y++]=p[j++];\\n              }\\n              }\\n              if(p[j]!=\\'.\\')\\n              w[y++]=p[j];\\n              \\n            }\\n            s.insert(w);\\n            w.clear();\\n        }\\n        return s.size();\\n        \\n    }\\n};\\n\\n//  this code is giving overflow ,why,please explain any one\\n"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "Man this question fckd me up"
                    },
                    {
                        "username": "mochiball",
                        "content": "lmaooo"
                    },
                    {
                        "username": "jespinos08",
                        "content": "I don\\'t get why my code if failing for test case emails = [\"fg.r.u.uzj+o.pw@kziczvh.com\",\"r.cyo.g+d.h+b.ja@tgsg.z.com\",\"fg.r.u.uzj+o.f.d@kziczvh.com\",\"r.cyo.g+ng.r.iq@tgsg.z.com\",\"fg.r.u.uzj+lp.k@kziczvh.com\",\"r.cyo.g+n.h.e+n.g@tgsg.z.com\",\"fg.r.u.uzj+k+p.j@kziczvh.com\",\"fg.r.u.uzj+w.y+b@kziczvh.com\",\"r.cyo.g+x+d.c+f.t@tgsg.z.com\",\"r.cyo.g+x+t.y.l.i@tgsg.z.com\",\"r.cyo.g+brxxi@tgsg.z.com\",\"r.cyo.g+z+dr.k.u@tgsg.z.com\",\"r.cyo.g+d+l.c.n+g@tgsg.z.com\",\"fg.r.u.uzj+vq.o@kziczvh.com\",\"fg.r.u.uzj+uzq@kziczvh.com\",\"fg.r.u.uzj+mvz@kziczvh.com\",\"fg.r.u.uzj+taj@kziczvh.com\",\"fg.r.u.uzj+fek@kziczvh.com\"]\\n\\nHere\\'s my code:  \\n```\\nvar numUniqueEmails = function(emails) {\\n    let local = [];\\n    let domain = [];\\n    let unique = new Set();\\n\\n    emails.forEach(email => {\\n      email = email.split(\\'@\\');\\n      local.push(email[0]);\\n      domain.push(email[1]);\\n    });\\n\\n    for (let email of local) {\\n      if (email.includes(\\'+\\')) {\\n        email = email.slice(0, email.indexOf(\\'+\\'));        \\n      }\\n      email = email.replaceAll(\\'.\\', \\'\\');\\n\\n      for (const dom of domain) {        \\n          unique.add(email + \\'@\\' + dom);        \\n      }      \\n    }    \\n    console.log(unique);\\n\\n    return unique.size; \\n};\\n``` \\n\\nWhen I log my unique Set, the valid emails I get are:  \\'fgruuzj@kziczvh.com\\',\\n  \\'fgruuzj@tgsg.z.com\\',\\n  \\'rcyog@kziczvh.com\\',\\n  \\'rcyog@tgsg.z.com\\'\\n\\nArent all of those unique and valid? Therefore, the answer should be 4 and not 2?"
                    }
                ]
            },
            {
                "id": 1832593,
                "content": [
                    {
                        "username": "isabellarochailr",
                        "content": "For the first case example it states that \\n\\' \"testemail@leetcode.com\" and \"testemail@lee.tcode.com\" actually receive mails. \\'\\n;however, \\'\"testemail@lee.tcode.com\"\\' should not receive emails since it has \\'.\\' inside the domain which was stated that it should not be applied to the domain. The correct explanation would have been: \\n\\' \"test.email+alex@leetcode.com\" and \"test.e.mail+bob.cathy@leetcode.com\" actually receive mails. \\'"
                    },
                    {
                        "username": "gjbgpr",
                        "content": "[@Kashish905](/Kashish905) [@isabellarochailr](/isabellarochailr) I actually had the same doubt, since it clearly states\\n\\n\"If you add periods \\'.\\' between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name. **Note that this rule does not apply to domain names.**\""
                    },
                    {
                        "username": "Kashish905",
                        "content": " \"testemail@lee.tcode.com\"  could receive email, maybe you have read the question wrong, \".\" case could be applied to the domain name but not the \"+\" case."
                    },
                    {
                        "username": "Kashish905",
                        "content": "you are wrong buddy."
                    },
                    {
                        "username": "paopao100097",
                        "content": "test case:\\n[\"test.email+alex@leetcode.com\",\"ttest.e.mail+bob.cathy@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"]\\n\\nthe result should be 3, however, the answer by that solution is 2."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think we have three here. The second email has as local name: ttestemail. with \\'tt\\'. "
                    },
                    {
                        "username": "dpauly",
                        "content": "The question description says that dots (.) are ignored in the local part of the email but not ignored for the domain name part of the email (i.e., everything following the \\'@\\' symbol)"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "I ran it, it says the solution is 3"
                    },
                    {
                        "username": "Shyamal122",
                        "content": "Trash Question I have even seen. "
                    },
                    {
                        "username": "afanta",
                        "content": "[\"test.email+alex@leetcode.com\",\"test.email.leet+alex@code.com\"]\\nwhy the expected number is 2? in 183 test case"
                    },
                    {
                        "username": "20A31A05G8",
                        "content": "{\\'testemail@leetcode.com\\', \\'testemailleet@code.com\\'} is result (2 unique emails)"
                    },
                    {
                        "username": "anoop5737v",
                        "content": "class Solution {\\npublic:\\n    int numUniqueEmails(vector<string>& emails) {\\n        set<string> s;\\n        int l=emails.size();\\n        for(int i=0;i<l;i++)\\n        {\\n            string p=emails[i];\\n            string w;\\n            int y=0;\\n            int pl=emails[i].size();\\n            for(int j=0;j<pl;j++)\\n            {\\n              if(p[j]==\\'@\\')\\n              {\\n                  while(j<pl)\\n                  w[y++]=p[j++];\\n              }\\n              if(p[j]==\\'+\\')\\n              {\\n                  while(p[j]!=\\'@\\')\\n                  j++;\\n                  if(p[j]==\\'@\\')\\n              {\\n                  while(j<pl)\\n                  w[y++]=p[j++];\\n              }\\n              }\\n              if(p[j]!=\\'.\\')\\n              w[y++]=p[j];\\n              \\n            }\\n            s.insert(w);\\n            w.clear();\\n        }\\n        return s.size();\\n        \\n    }\\n};\\n\\n//  this code is giving overflow ,why,please explain any one\\n"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "Man this question fckd me up"
                    },
                    {
                        "username": "mochiball",
                        "content": "lmaooo"
                    },
                    {
                        "username": "jespinos08",
                        "content": "I don\\'t get why my code if failing for test case emails = [\"fg.r.u.uzj+o.pw@kziczvh.com\",\"r.cyo.g+d.h+b.ja@tgsg.z.com\",\"fg.r.u.uzj+o.f.d@kziczvh.com\",\"r.cyo.g+ng.r.iq@tgsg.z.com\",\"fg.r.u.uzj+lp.k@kziczvh.com\",\"r.cyo.g+n.h.e+n.g@tgsg.z.com\",\"fg.r.u.uzj+k+p.j@kziczvh.com\",\"fg.r.u.uzj+w.y+b@kziczvh.com\",\"r.cyo.g+x+d.c+f.t@tgsg.z.com\",\"r.cyo.g+x+t.y.l.i@tgsg.z.com\",\"r.cyo.g+brxxi@tgsg.z.com\",\"r.cyo.g+z+dr.k.u@tgsg.z.com\",\"r.cyo.g+d+l.c.n+g@tgsg.z.com\",\"fg.r.u.uzj+vq.o@kziczvh.com\",\"fg.r.u.uzj+uzq@kziczvh.com\",\"fg.r.u.uzj+mvz@kziczvh.com\",\"fg.r.u.uzj+taj@kziczvh.com\",\"fg.r.u.uzj+fek@kziczvh.com\"]\\n\\nHere\\'s my code:  \\n```\\nvar numUniqueEmails = function(emails) {\\n    let local = [];\\n    let domain = [];\\n    let unique = new Set();\\n\\n    emails.forEach(email => {\\n      email = email.split(\\'@\\');\\n      local.push(email[0]);\\n      domain.push(email[1]);\\n    });\\n\\n    for (let email of local) {\\n      if (email.includes(\\'+\\')) {\\n        email = email.slice(0, email.indexOf(\\'+\\'));        \\n      }\\n      email = email.replaceAll(\\'.\\', \\'\\');\\n\\n      for (const dom of domain) {        \\n          unique.add(email + \\'@\\' + dom);        \\n      }      \\n    }    \\n    console.log(unique);\\n\\n    return unique.size; \\n};\\n``` \\n\\nWhen I log my unique Set, the valid emails I get are:  \\'fgruuzj@kziczvh.com\\',\\n  \\'fgruuzj@tgsg.z.com\\',\\n  \\'rcyog@kziczvh.com\\',\\n  \\'rcyog@tgsg.z.com\\'\\n\\nArent all of those unique and valid? Therefore, the answer should be 4 and not 2?"
                    }
                ]
            }
        ]
    }
]