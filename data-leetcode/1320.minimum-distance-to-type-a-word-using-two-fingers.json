[
    {
        "title": "Distinct Echo Substrings",
        "question_content": "Return the number of distinct non-empty substrings of text&nbsp;that can be written as the concatenation of some string with itself (i.e. it can be written as a + a&nbsp;where a is some string).\n&nbsp;\nExample 1:\n\nInput: text = \"abcabcabc\"\nOutput: 3\nExplanation: The 3 substrings are \"abcabc\", \"bcabca\" and \"cabcab\".\n\nExample 2:\n\nInput: text = \"leetcodeleetcode\"\nOutput: 2\nExplanation: The 2 substrings are \"ee\" and \"leetcodeleetcode\".\n\n&nbsp;\nConstraints:\n\n\t1 <= text.length <= 2000\n\ttext&nbsp;has only lowercase English letters.",
        "solutions": [
            {
                "id": 492704,
                "title": "intuitive-100-sliding-counter-with-pictures",
                "content": "**Overview**\\nYou can find here 2 solutions: 1st - Sliding Counter (72%), 2nd - Sliding Counter + Rolling Hash (100%). \\nIf you know similar problems or think of any improvements please let me know in the comments.\\n\\n**Solution I. Sliding Counter**\\n* ***Idea***\\nWe will use 2 pointers `l` and `r` to count equal characters for different lengths of substrings (`len`).\\nLet\\'s consider these 3 cases:\\n\\t* If counter reaches window length (`len`) then we record a substring.\\n<img src=\"https://assets.leetcode.com/users/jkyncmeg2h86/image_1580237915.png\" width=\"350\" height=\"150\" />\\n\\t* We disregard current substring when we encounter chars that are not equal (\\'b\\' and \\'c\\' for example), thus we reset the counter.\\n<img src=\"https://assets.leetcode.com/users/jkyncmeg2h86/image_1580238662.png\" width=\"350\" height=\"210\" />\\n\\t* When we record a substring, we move windows thus leaving a character behind, this means we have to decrease the counter.\\n<img src=\"https://assets.leetcode.com/users/jkyncmeg2h86/image_1580237916.png\" width=\"350\" height=\"150\" />\\n\\n\\n* ***Implementation***\\n\\t```java\\n\\tpublic int distinctEchoSubstrings(String s) {\\n\\t\\tSet<String> set = new HashSet<>();\\n\\t\\tfor (int len = 1; len <= s.length() / 2; len++) {\\n\\t\\t\\tfor (int l = 0, r = len, count = 0; l < s.length() - len; l++, r++) {\\n\\t\\t\\t\\tif (s.charAt(l) == s.charAt(r)) count++;\\n\\t\\t\\t\\telse count = 0;\\n\\n\\t\\t\\t\\tif (count == len) {\\n\\t\\t\\t\\t\\tset.add(s.substring(l - len + 1, l + 1));\\n\\t\\t\\t\\t\\tcount--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn set.size();\\n\\t}\\n\\t```\\n\\n**Solution II. Rolling Hash**\\n* ***Idea***\\nExtended previous solution with rolling hash.\\n\\n* ***Implementation***\\n\\t```java\\n\\timport java.math.*;\\n\\tpublic class Solution {\\n\\t\\tprivate int R = 256; // radix\\n\\t\\tprivate long Q; // large prime\\n\\t\\tprivate long[] powers; // precomputed powers of R\\n\\t\\tprivate long[] hashes; // precomputed hashes of prefixes\\n\\n\\t\\tpublic int distinctEchoSubstrings(String s) {\\n\\t\\t\\tSet<Long> set = new HashSet<>();\\n\\t\\t\\tpreprocess(s.length(), s);\\n\\n\\t\\t\\tfor (int len = 1; len <= s.length() / 2; len++) {\\n\\t\\t\\t\\tfor (int l = 0, r = len, count = 0; l < s.length() - len; l++, r++) {\\n\\t\\t\\t\\t\\tif (s.charAt(l) == s.charAt(r)) count++;\\n\\t\\t\\t\\t\\telse count = 0;\\n\\n\\t\\t\\t\\t\\tif (count == len) {\\n\\t\\t\\t\\t\\t\\tset.add(getHash(l - len + 1, l + 1));\\n\\t\\t\\t\\t\\t\\tcount--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn set.size();\\n\\t\\t}\\n\\n\\t\\tprivate void preprocess(int n, String text) {\\n\\t\\t\\tQ = calculateRandomPrime();\\n\\t\\t\\thashes = new long[n + 1];\\n\\t\\t\\tpowers = new long[n + 1];\\n\\t\\t\\tpowers[0] = 1;\\n\\t\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\t\\thashes[i] = (hashes[i - 1] * R + text.charAt(i - 1)) % Q;\\n\\t\\t\\t\\tpowers[i] = (powers[i - 1] * R) % Q;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tprivate long calculateRandomPrime() {\\n\\t\\t\\tBigInteger prime = BigInteger.probablePrime(31, new Random());\\n\\t\\t\\treturn prime.longValue();\\n\\t\\t}\\n\\n\\t\\tprivate long getHash(int l, int r) {\\n\\t\\t\\treturn (hashes[r] + Q - hashes[l] * powers[r - l] % Q) % Q;\\n\\t\\t}\\n\\t}\\n\\t```\\n\\t\\n\\t\\n**Somewhat similar problems:**\\n* [Longest Duplicate Substring](https://leetcode.com/problems/longest-duplicate-substring/)\\n* [Repeated String Match](https://leetcode.com/problems/repeated-string-match/)\\n* [Permutation in String](https://leetcode.com/problems/permutation-in-string/)\\n* [Shortest Palindrome](https://leetcode.com/problems/shortest-palindrome/)",
                "solutionTags": [],
                "code": "```java\\n\\tpublic int distinctEchoSubstrings(String s) {\\n\\t\\tSet<String> set = new HashSet<>();\\n\\t\\tfor (int len = 1; len <= s.length() / 2; len++) {\\n\\t\\t\\tfor (int l = 0, r = len, count = 0; l < s.length() - len; l++, r++) {\\n\\t\\t\\t\\tif (s.charAt(l) == s.charAt(r)) count++;\\n\\t\\t\\t\\telse count = 0;\\n\\n\\t\\t\\t\\tif (count == len) {\\n\\t\\t\\t\\t\\tset.add(s.substring(l - len + 1, l + 1));\\n\\t\\t\\t\\t\\tcount--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn set.size();\\n\\t}\\n\\t```\n```java\\n\\timport java.math.*;\\n\\tpublic class Solution {\\n\\t\\tprivate int R = 256; // radix\\n\\t\\tprivate long Q; // large prime\\n\\t\\tprivate long[] powers; // precomputed powers of R\\n\\t\\tprivate long[] hashes; // precomputed hashes of prefixes\\n\\n\\t\\tpublic int distinctEchoSubstrings(String s) {\\n\\t\\t\\tSet<Long> set = new HashSet<>();\\n\\t\\t\\tpreprocess(s.length(), s);\\n\\n\\t\\t\\tfor (int len = 1; len <= s.length() / 2; len++) {\\n\\t\\t\\t\\tfor (int l = 0, r = len, count = 0; l < s.length() - len; l++, r++) {\\n\\t\\t\\t\\t\\tif (s.charAt(l) == s.charAt(r)) count++;\\n\\t\\t\\t\\t\\telse count = 0;\\n\\n\\t\\t\\t\\t\\tif (count == len) {\\n\\t\\t\\t\\t\\t\\tset.add(getHash(l - len + 1, l + 1));\\n\\t\\t\\t\\t\\t\\tcount--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn set.size();\\n\\t\\t}\\n\\n\\t\\tprivate void preprocess(int n, String text) {\\n\\t\\t\\tQ = calculateRandomPrime();\\n\\t\\t\\thashes = new long[n + 1];\\n\\t\\t\\tpowers = new long[n + 1];\\n\\t\\t\\tpowers[0] = 1;\\n\\t\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\t\\thashes[i] = (hashes[i - 1] * R + text.charAt(i - 1)) % Q;\\n\\t\\t\\t\\tpowers[i] = (powers[i - 1] * R) % Q;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tprivate long calculateRandomPrime() {\\n\\t\\t\\tBigInteger prime = BigInteger.probablePrime(31, new Random());\\n\\t\\t\\treturn prime.longValue();\\n\\t\\t}\\n\\n\\t\\tprivate long getHash(int l, int r) {\\n\\t\\t\\treturn (hashes[r] + Q - hashes[l] * powers[r - l] % Q) % Q;\\n\\t\\t}\\n\\t}\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 477217,
                "title": "java-brute-force-hash-solution-clean-code",
                "content": "**1. Brute force Solution**\\n```java\\nclass Solution {\\n    public int distinctEchoSubstrings(String str) {\\n        HashSet<String> set = new HashSet<>();\\n        int n = str.length();\\n        for (int i = 0; i < n; i++) {\\n            for (int len = 2; i + len <= n; len += 2) {\\n                int mid = i + len / 2;\\n                String subStr1 = str.substring(i, mid);\\n                String subStr2 = str.substring(mid, i + len);\\n                if (subStr1.equals(subStr2)) set.add(subStr1);\\n            }\\n        }\\n        return set.size();\\n    }\\n}\\n```\\n**Complexity:**\\n- Time: O(n^3), `n` is length of string `str`\\n- Space: O(n)\\n\\n**2. Hash Solution**\\n```java\\nclass Solution {\\n    long BASE = 29L, MOD = 1000000007L;\\n    public int distinctEchoSubstrings(String str) {\\n        HashSet<Long> set = new HashSet<>();\\n        int n = str.length();\\n        long[] hash = new long[n + 1]; // hash[i] is hash value from str[0..i]\\n        long[] pow = new long[n + 1]; // pow[i] = BASE^i\\n        pow[0] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            hash[i] = (hash[i - 1] * BASE + str.charAt(i - 1)) % MOD;\\n            pow[i] = pow[i - 1] * BASE % MOD;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int len = 2; i + len <= n; len += 2) {\\n                int mid = i + len / 2;\\n                long hash1 = getHash(i, mid, hash, pow);\\n                long hash2 = getHash(mid, i + len, hash, pow);\\n                if (hash1 == hash2) set.add(hash1);\\n            }\\n        }\\n        return set.size();\\n    }\\n\\n    long getHash(int l, int r, long[] hash, long[] pow) {\\n        return (hash[r] - hash[l] * pow[r - l] % MOD + MOD) % MOD;\\n    }\\n}\\n```\\n**Complexity**\\n- Time: O(n^2), `n` is length of string `str`\\n- Space: O(n)",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int distinctEchoSubstrings(String str) {\\n        HashSet<String> set = new HashSet<>();\\n        int n = str.length();\\n        for (int i = 0; i < n; i++) {\\n            for (int len = 2; i + len <= n; len += 2) {\\n                int mid = i + len / 2;\\n                String subStr1 = str.substring(i, mid);\\n                String subStr2 = str.substring(mid, i + len);\\n                if (subStr1.equals(subStr2)) set.add(subStr1);\\n            }\\n        }\\n        return set.size();\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    long BASE = 29L, MOD = 1000000007L;\\n    public int distinctEchoSubstrings(String str) {\\n        HashSet<Long> set = new HashSet<>();\\n        int n = str.length();\\n        long[] hash = new long[n + 1]; // hash[i] is hash value from str[0..i]\\n        long[] pow = new long[n + 1]; // pow[i] = BASE^i\\n        pow[0] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            hash[i] = (hash[i - 1] * BASE + str.charAt(i - 1)) % MOD;\\n            pow[i] = pow[i - 1] * BASE % MOD;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int len = 2; i + len <= n; len += 2) {\\n                int mid = i + len / 2;\\n                long hash1 = getHash(i, mid, hash, pow);\\n                long hash2 = getHash(mid, i + len, hash, pow);\\n                if (hash1 == hash2) set.add(hash1);\\n            }\\n        }\\n        return set.size();\\n    }\\n\\n    long getHash(int l, int r, long[] hash, long[] pow) {\\n        return (hash[r] - hash[l] * pow[r - l] % MOD + MOD) % MOD;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477643,
                "title": "rolling-equality-counter",
                "content": "I use two adjacent sliding windows. But instead of two rolling hashes (one for each window), I keep track of at how many places the windows are equal. It\\'s simple and there are no collisions (different strings mistaken for being the same, as can happen with hashes).\\n\\nFor example with string \"xbcabca\":\\n```\\n  0  1  2  3  4  5  6\\n (x  b  c)(a  b  c) a   => 2 places in the windows are the same (middle and right)\\n  x (b  c  a)(b  c  a)  => 3 places in the windows are the same\\n```\\nIn the first row, we were interested in equality at the index pairs (0, 3), (1, 4) and (2, 5).\\nAfter the shift, we are interested in equality at the index pairs (1, 4), (2, 5) and (3, 6).\\nSo the pairs (1, 4) and (2, 5) stayed, we only lost interest in whether (0, 3) were equal, and we gained interest in whether (3, 6) are equal.\\n```\\ndef distinctEchoSubstrings(self, s):\\n    n = len(s)\\n    s += \\'.\\'\\n    some_string = set()\\n    for k in range(1, n//2+1):\\n        same = sum(c == d for c, d in zip(s, s[k:k+k]))\\n        for i in range(n - 2*k + 1):\\n            if same == k:\\n                some_string.add(s[i:i+k])\\n            same += (s[i+k] == s[i+k+k]) - (s[i] == s[i+k])\\n    return len(some_string)\\n```",
                "solutionTags": [],
                "code": "```\\n  0  1  2  3  4  5  6\\n (x  b  c)(a  b  c) a   => 2 places in the windows are the same (middle and right)\\n  x (b  c  a)(b  c  a)  => 3 places in the windows are the same\\n```\n```\\ndef distinctEchoSubstrings(self, s):\\n    n = len(s)\\n    s += \\'.\\'\\n    some_string = set()\\n    for k in range(1, n//2+1):\\n        same = sum(c == d for c, d in zip(s, s[k:k+k]))\\n        for i in range(n - 2*k + 1):\\n            if same == k:\\n                some_string.add(s[i:i+k])\\n            same += (s[i+k] == s[i+k+k]) - (s[i] == s[i+k])\\n    return len(some_string)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 477444,
                "title": "c-with-hash-240ms-without-hash-550ms-but-simpler",
                "content": "Simple brute force without hash:\\n```\\nint distinctEchoSubstrings(string text) {\\n\\tunordered_set<string_view> res;\\n\\tconst char *p = text.c_str();\\n\\tfor (int i=0; i<text.size(); ++i) {\\n\\t\\tfor (int len=1; i+len+len<=text.size(); ++len) {\\n\\t\\t\\tconst string_view a(p+i    , len);\\n\\t\\t\\tconst string_view b(p+i+len, len);\\n\\t\\t\\tif (a==b) {\\n\\t\\t\\t\\tres.insert(a);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res.size();\\n}\\n```\\n\\nWith hash:\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    static constexpr int A = 1000000007, B = 1000000037;\\n    \\n    class Hash {\\n    public:\\n        Hash(const string &s) {\\n            h[0] = s[0] % B;\\n            p[0] = 1;\\n            for (int i=1; i<s.size(); ++i) {\\n                h[i] = (h[i-1]*A + s[i]) % B;\\n                p[i] = (p[i-1]*A) % B;\\n            }\\n        }\\n        \\n        // a and b are inclusive\\n        ll hash(const int a, const int b) {\\n            if (a) {\\n                const auto res = (h[b] - h[a-1] * p[b-a+1]) % B;\\n                return res < 0 ? B + res : res;\\n            }   else {\\n                return h[b];\\n            }\\n        }\\n    private:\\n        ll h[2000], p[2000];\\n    };\\n    \\n    int distinctEchoSubstrings(string text) {\\n        Hash h(text);\\n        \\n        unordered_set<string_view> res;\\n        const char *p = text.c_str();\\n        for (int i=0; i<text.size(); ++i) {\\n            for (int len=1; i+len+len<=text.size(); ++len) {\\n                if (h.hash(i, i+len-1) == h.hash(i+len, i+len+len-1)) {\\n                    res.insert(string_view(p+i, len));\\n                }\\n            }\\n        }\\n        return res.size();\\n    }\\n};\\n```\\nA and B can be any prime numbers. Bigger values reduce probability of collision. After the hash is initialized, comparing two substrings takes constant time by comparing hashes of the substrings. See https://en.wikipedia.org/wiki/Rolling_hash or book \"Guide to Competitive Programming\" by Antti Laaksonen. He explains it well in half a page. IMHO: this is by far the best book about C++ algorithms.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint distinctEchoSubstrings(string text) {\\n\\tunordered_set<string_view> res;\\n\\tconst char *p = text.c_str();\\n\\tfor (int i=0; i<text.size(); ++i) {\\n\\t\\tfor (int len=1; i+len+len<=text.size(); ++len) {\\n\\t\\t\\tconst string_view a(p+i    , len);\\n\\t\\t\\tconst string_view b(p+i+len, len);\\n\\t\\t\\tif (a==b) {\\n\\t\\t\\t\\tres.insert(a);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res.size();\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    static constexpr int A = 1000000007, B = 1000000037;\\n    \\n    class Hash {\\n    public:\\n        Hash(const string &s) {\\n            h[0] = s[0] % B;\\n            p[0] = 1;\\n            for (int i=1; i<s.size(); ++i) {\\n                h[i] = (h[i-1]*A + s[i]) % B;\\n                p[i] = (p[i-1]*A) % B;\\n            }\\n        }\\n        \\n        // a and b are inclusive\\n        ll hash(const int a, const int b) {\\n            if (a) {\\n                const auto res = (h[b] - h[a-1] * p[b-a+1]) % B;\\n                return res < 0 ? B + res : res;\\n            }   else {\\n                return h[b];\\n            }\\n        }\\n    private:\\n        ll h[2000], p[2000];\\n    };\\n    \\n    int distinctEchoSubstrings(string text) {\\n        Hash h(text);\\n        \\n        unordered_set<string_view> res;\\n        const char *p = text.c_str();\\n        for (int i=0; i<text.size(); ++i) {\\n            for (int len=1; i+len+len<=text.size(); ++len) {\\n                if (h.hash(i, i+len-1) == h.hash(i+len, i+len+len-1)) {\\n                    res.insert(string_view(p+i, len));\\n                }\\n            }\\n        }\\n        return res.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477060,
                "title": "accepted-o-n-2-rolling-hash-solution",
                "content": "Looking for two neighboring segments that are identical. \\nIf length is l, we are checking i..i+l and i+l-1...i+2*l\\nIf we move from i to i+1, we can use rolling hash to get the new string hashes for them in O(1)\\n```\\n\\n\\npublic class Solution {\\n    long mod = 100000000000007L;\\n\\n    public int distinctEchoSubstrings(String s) {\\n        int n = s.length();\\n        char[] cs = s.toCharArray();\\n        Set<Long> set = new HashSet<>();\\n        long headexp = 1L;\\n        for (int l = 1; 2 * l - 1 < n; l++) {\\n            headexp *= 26;\\n            headexp %= mod;\\n            long hash1 = initialHash(cs, 0, l - 1);\\n            long hash2 = initialHash(cs, l, 2 * l - 1);\\n            if (hash1 == hash2) {\\n                set.add(hash1);\\n            }\\n            for (int i = 1; i + 2 * l - 1 < n; i++) {\\n                // rolling hash\\n                hash1 = updateHash(cs, hash1, headexp, i - 1, i + l - 1);\\n                hash2 = updateHash(cs, hash2, headexp, i - 1 + l, i + 2 * l - 1);\\n                if (hash1 == hash2) {\\n                    set.add(hash1);\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n\\n    private long initialHash(char[] cs, int i, int j) {\\n        long hash = 0L;\\n        for (int k = i; k <= j; k++) {\\n            hash = hash * 26 + (tocode(cs[k]));\\n            hash %= mod;\\n        }\\n        return hash;\\n    }\\n\\n    private long updateHash(char[] cs, long hash, long headexp, int index1, int index2) {\\n        hash = hash * 26 + (tocode(cs[index2]));\\n        hash = (hash - headexp * tocode(cs[index1])) % mod;\\n        hash = (hash + mod) % mod; // in case hash turns negative from above minus...\\n        return hash;\\n    }\\n\\n    private int tocode(char c) {\\n        return c - \\'a\\' + 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\npublic class Solution {\\n    long mod = 100000000000007L;\\n\\n    public int distinctEchoSubstrings(String s) {\\n        int n = s.length();\\n        char[] cs = s.toCharArray();\\n        Set<Long> set = new HashSet<>();\\n        long headexp = 1L;\\n        for (int l = 1; 2 * l - 1 < n; l++) {\\n            headexp *= 26;\\n            headexp %= mod;\\n            long hash1 = initialHash(cs, 0, l - 1);\\n            long hash2 = initialHash(cs, l, 2 * l - 1);\\n            if (hash1 == hash2) {\\n                set.add(hash1);\\n            }\\n            for (int i = 1; i + 2 * l - 1 < n; i++) {\\n                // rolling hash\\n                hash1 = updateHash(cs, hash1, headexp, i - 1, i + l - 1);\\n                hash2 = updateHash(cs, hash2, headexp, i - 1 + l, i + 2 * l - 1);\\n                if (hash1 == hash2) {\\n                    set.add(hash1);\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n\\n    private long initialHash(char[] cs, int i, int j) {\\n        long hash = 0L;\\n        for (int k = i; k <= j; k++) {\\n            hash = hash * 26 + (tocode(cs[k]));\\n            hash %= mod;\\n        }\\n        return hash;\\n    }\\n\\n    private long updateHash(char[] cs, long hash, long headexp, int index1, int index2) {\\n        hash = hash * 26 + (tocode(cs[index2]));\\n        hash = (hash - headexp * tocode(cs[index1])) % mod;\\n        hash = (hash + mod) % mod; // in case hash turns negative from above minus...\\n        return hash;\\n    }\\n\\n    private int tocode(char c) {\\n        return c - \\'a\\' + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 479342,
                "title": "silly-and-fast",
                "content": "#### Silly ...\\nFor each split point, we are going left and right increasing the size. When the left and right string matches - we add it to the hash set.\\n\\nThis solution gets accepted with ~800 ms runtime. Not bad for a simple idea! Note that I am using string `compare` to make sure we are not creating new strings.\\n```CPP\\nint distinctEchoSubstrings(string tx) {\\n    unordered_set<string> s;\\n    for (auto split = 1; split < tx.size() - 1; ++split) {\\n        for (auto sz = 1; split - sz >= 0 && split + sz - 1 < tx.size(); ++sz) {\\n            if (tx.compare(split - sz, sz, tx, split, sz) == 0)\\n                s.insert(tx.substr(split, sz));\\n        }\\n    }\\n    return s.size();\\n}\\n```\\n#### ... and ...\\nSo, what is hurting the runtime in the solution above? For each candidate, we need up to O(sz) comparisons. If we use a rolling hash approach, it takes O(1) to add a character to the hash, and O(1) to compare the string.\\n\\nFrom the split point, we are rolling hash left (add the next char multiplied by 26 * sz) and right (multiply the hash by 26 and add the next character). When the left and right hashes match, we add the string to the result set.\\n\\n```CPP\\nint distinctEchoSubstrings(string tx) {\\n    unordered_set<string> s;\\n    for (auto split = 1; split < tx.size() - 1; ++split) {\\n        long long sh_l = 0, sh_r = 0, base = 1;\\n        for (auto sz = 1; split - sz >= 0 && split + sz - 1 < tx.size(); ++sz) {\\n            sh_r = ((sh_r * 26) + tx[split + sz - 1]) % 1000000007;\\n            sh_l = (sh_l + tx[split - sz] * base) % 1000000007;\\n            base = (base * 26) % 1000000007;\\n            if (sh_r == sh_l) s.insert(tx.substr(split, sz));\\n        }\\n    }\\n    return s.size();\\n}\\n```\\nThis brings the runtime down to ~500 ms... it\\'s faster but quite disappointing for the amount of extra work we\\'ve done to the first solution.\\n#### ... Fast!\\nWhat is eating our runtime? When we add a string to the hash set, we need to create a substring - O(sz) - and the hash set internally computes a hash - also O(sz). Why do we need to compute a hash again if we already have our rolling hash? So, we can change our hash set to store integers instead of strings.\\n```CPP\\nint distinctEchoSubstrings(string tx) {\\n    unordered_set<int> s;\\n    for (auto split = 1; split < tx.size() - 1; ++split) {\\n        long long sh_l = 0, sh_r = 0, base = 1;\\n        for (auto sz = 1; split - sz >= 0 && split + sz - 1 < tx.size(); ++sz) {\\n            sh_r = ((sh_r * 26) + tx[split + sz - 1]) % 1000000007;\\n            sh_l = (sh_l + tx[split - sz] * base) % 1000000007;\\n            base = (base * 26) % 1000000007;\\n            if (sh_r == sh_l) s.insert(sh_l);\\n        }\\n    }\\n    return s.size();\\n}\\n```\\nThe runtime of this solution is ~72 ms, so our hard work finally paid off! We can do more clever tricks with rolling hash to optimize, but here I wanted to keep the same simple concept as in the initial solution.",
                "solutionTags": [],
                "code": "```CPP\\nint distinctEchoSubstrings(string tx) {\\n    unordered_set<string> s;\\n    for (auto split = 1; split < tx.size() - 1; ++split) {\\n        for (auto sz = 1; split - sz >= 0 && split + sz - 1 < tx.size(); ++sz) {\\n            if (tx.compare(split - sz, sz, tx, split, sz) == 0)\\n                s.insert(tx.substr(split, sz));\\n        }\\n    }\\n    return s.size();\\n}\\n```\n```CPP\\nint distinctEchoSubstrings(string tx) {\\n    unordered_set<string> s;\\n    for (auto split = 1; split < tx.size() - 1; ++split) {\\n        long long sh_l = 0, sh_r = 0, base = 1;\\n        for (auto sz = 1; split - sz >= 0 && split + sz - 1 < tx.size(); ++sz) {\\n            sh_r = ((sh_r * 26) + tx[split + sz - 1]) % 1000000007;\\n            sh_l = (sh_l + tx[split - sz] * base) % 1000000007;\\n            base = (base * 26) % 1000000007;\\n            if (sh_r == sh_l) s.insert(tx.substr(split, sz));\\n        }\\n    }\\n    return s.size();\\n}\\n```\n```CPP\\nint distinctEchoSubstrings(string tx) {\\n    unordered_set<int> s;\\n    for (auto split = 1; split < tx.size() - 1; ++split) {\\n        long long sh_l = 0, sh_r = 0, base = 1;\\n        for (auto sz = 1; split - sz >= 0 && split + sz - 1 < tx.size(); ++sz) {\\n            sh_r = ((sh_r * 26) + tx[split + sz - 1]) % 1000000007;\\n            sh_l = (sh_l + tx[split - sz] * base) % 1000000007;\\n            base = (base * 26) % 1000000007;\\n            if (sh_r == sh_l) s.insert(sh_l);\\n        }\\n    }\\n    return s.size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 478854,
                "title": "c-dp-solution-o-n-3-with-explanation",
                "content": "I found most posts are talking about rolling hash and code is pretty long. So I would like to share my DP solution.\\n`dp[i][j] = k ` stands for two sub strings that start from text[i] and text[j] respectively, are same to at most k characters. \\nLet\\'s say we\\'ve known string s1 starting from i+1 and string s2 starting from j+1 are identical up to dp[i+1][j+1] characters. So for string s1\\' and s2\\' starting from i and j position, if `ch[i] != ch[j]` then this number becomes 0, otherwise we added this current one into account. and recurrence backward until dp table is all computed.\\n\\n`dp[i][j]=dp[i+1][j+1]`\\nThe critical condition for this question is when i +k == j, which means these two strings are \"concatenated\" together without any other character. A little debug actually fix that condition to j-i <= dp[i][j] = k as strings are still valid but k could be greater than j-i. \\n\\nThanks to @vortrubac in below comment. I originally use ordered_set than unordered_set, which takes twice the time.\\n\\n```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        if (text.size() <= 1) return 0;\\n        int N = text.size();\\n        // dp[i][j] = k means strcmp (text.data () + i, text.data() + j, k) == 0\\n        vector<vector<int>> dp (N + 1, vector<int> (N + 1, 0));\\n        unordered_set<string> res;\\n        auto &ch = text;\\n        for (int j = N-1; j > 0; j--) {\\n            for (int i = j-1; i >= 0; i--) {\\n                dp[i][j] = ch[i] == ch[j] ? 1 + dp[i+1][j+1] : 0;\\n                if (dp[i][j] >= j-i) {\\n                    res.insert ( ch.substr(i, j-i)); \\n                }\\n            }\\n        }\\n        return res.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        if (text.size() <= 1) return 0;\\n        int N = text.size();\\n        // dp[i][j] = k means strcmp (text.data () + i, text.data() + j, k) == 0\\n        vector<vector<int>> dp (N + 1, vector<int> (N + 1, 0));\\n        unordered_set<string> res;\\n        auto &ch = text;\\n        for (int j = N-1; j > 0; j--) {\\n            for (int i = j-1; i >= 0; i--) {\\n                dp[i][j] = ch[i] == ch[j] ? 1 + dp[i+1][j+1] : 0;\\n                if (dp[i][j] >= j-i) {\\n                    res.insert ( ch.substr(i, j-i)); \\n                }\\n            }\\n        }\\n        return res.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477503,
                "title": "c-simple-solution-100ms-without-rolling-hash",
                "content": "update: got around 90 - 100ms, with additional check for repeating patterns.\\n\\n```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text)\\n    {\\n        unordered_set<string_view> ddw;\\n        const char* cstr = text.c_str();\\n        int n = text.size() / 2;\\n        for(int i = 1; i <= n; i++)\\n        {\\n            int l = 0, r = i, c = 0;\\n            while(r < text.size())\\n            {\\n                if(cstr[l++] == cstr[r++])\\n                {\\n                    c++;\\n                }\\n                else\\n                {\\n                    c = 0;\\n                }\\n                if(c >= i && c < i * 2) // for c >= i * 2 : \"ababab\" same string repeating\\n                {\\n\\t\\t\\t\\t\\tddw.insert(string_view(cstr + l, i));\\n                }\\n            }\\n        }\\n        return ddw.size();\\n    }\\n};\\n```\\n\\nupdate: 88ms solution without using set\\n\\n```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text)\\n    {\\n        int n = text.size();\\n        vector<int> copy(n + 1, 0);\\n        int res = 0;\\n        for(int i = 1; i < n; i++)\\n        {\\n            int l = 0, r = i, c = 0;\\n            while(r < n)\\n            {\\n                if(text[l++] == text[r++])\\n                {\\n                    c++;\\n                }\\n                else\\n                {\\n                    c = 0;\\n                }\\n                copy[r] = max(copy[r], c);\\n            }\\n        }\\n        for(int i = 1; i <= n / 2; i++)\\n        {\\n            int l = 0, r = i, c = 0;\\n            while(r < n)\\n            {\\n                if(text[l++] == text[r++])\\n                {\\n                    c++;\\n                }\\n                else\\n                {\\n                    c = 0;\\n                }\\n                if(c >= i && copy[r] < i * 2)\\n                {\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text)\\n    {\\n        unordered_set<string_view> ddw;\\n        const char* cstr = text.c_str();\\n        int n = text.size() / 2;\\n        for(int i = 1; i <= n; i++)\\n        {\\n            int l = 0, r = i, c = 0;\\n            while(r < text.size())\\n            {\\n                if(cstr[l++] == cstr[r++])\\n                {\\n                    c++;\\n                }\\n                else\\n                {\\n                    c = 0;\\n                }\\n                if(c >= i && c < i * 2) // for c >= i * 2 : \"ababab\" same string repeating\\n                {\\n\\t\\t\\t\\t\\tddw.insert(string_view(cstr + l, i));\\n                }\\n            }\\n        }\\n        return ddw.size();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text)\\n    {\\n        int n = text.size();\\n        vector<int> copy(n + 1, 0);\\n        int res = 0;\\n        for(int i = 1; i < n; i++)\\n        {\\n            int l = 0, r = i, c = 0;\\n            while(r < n)\\n            {\\n                if(text[l++] == text[r++])\\n                {\\n                    c++;\\n                }\\n                else\\n                {\\n                    c = 0;\\n                }\\n                copy[r] = max(copy[r], c);\\n            }\\n        }\\n        for(int i = 1; i <= n / 2; i++)\\n        {\\n            int l = 0, r = i, c = 0;\\n            while(r < n)\\n            {\\n                if(text[l++] == text[r++])\\n                {\\n                    c++;\\n                }\\n                else\\n                {\\n                    c = 0;\\n                }\\n                if(c >= i && copy[r] < i * 2)\\n                {\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477279,
                "title": "1-liners-python",
                "content": "We want *\"non-empty substrings of text that can be written as the concatenation of **some string** with itself\"*. So I go through each possible **some string** `s[i:j]` and check whether it\\'s followed by itself. And collect the successful **some string**s in a set for uniqueness, whose size I return. Slow but gets accepted.\\n```\\ndef distinctEchoSubstrings(self, s):\\n    return len({s[i:j] for j in range(len(s)) for i in range(j) if s[i:j] == s[j:j+j-i]})\\n```\\nSlight variation:\\n```\\ndef distinctEchoSubstrings(self, s):\\n    return len({s[i:j] for j in range(len(s)) for i in range(j) if s.startswith(s[i:j], j)})\\n```\\nLoop version:\\n```\\ndef distinctEchoSubstrings(self, s):\\n    some_strings = set()\\n    for j in range(len(s)):\\n        for i in range(j):\\n            if s.startswith(s[i:j], j):\\n                some_strings.add(s[i:j])\\n    return len(some_strings)\\n```\\nNote I make `j` the *outer* loop, because that\\'s a bit simpler than the equivalent other way around:\\n```\\n    for i in range(len(s) - 1):\\n        for j in range(i + 1, len(s)):\\n```",
                "solutionTags": [],
                "code": "```\\ndef distinctEchoSubstrings(self, s):\\n    return len({s[i:j] for j in range(len(s)) for i in range(j) if s[i:j] == s[j:j+j-i]})\\n```\n```\\ndef distinctEchoSubstrings(self, s):\\n    return len({s[i:j] for j in range(len(s)) for i in range(j) if s.startswith(s[i:j], j)})\\n```\n```\\ndef distinctEchoSubstrings(self, s):\\n    some_strings = set()\\n    for j in range(len(s)):\\n        for i in range(j):\\n            if s.startswith(s[i:j], j):\\n                some_strings.add(s[i:j])\\n    return len(some_strings)\\n```\n```\\n    for i in range(len(s) - 1):\\n        for j in range(i + 1, len(s)):\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 478515,
                "title": "simple-java-dp-solution",
                "content": "```\\nclass Solution {   \\n    public int distinctEchoSubstrings(String text) {\\n        int n = text.length();\\n        int dp[][] = new int[n][n];\\n        Set<String> set = new LinkedHashSet<>();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i+1; j < n; j++) {\\n                if (text.charAt(i) ==  text.charAt(j)) {\\n                    if (i == 0) {\\n                        dp[i][j] = 1;\\n                    } else {\\n                        dp[i][j] = dp[i - 1][j - 1] + 1;\\n                    }\\n                }\\n                if (dp[i][j] >= j - i) {\\n\\t\\t\\t\\t\\t// take substring i- (j-i) +1 to j+1 \\n                    set.add(text.substring(2 * i - j+1, j+1));\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {   \\n    public int distinctEchoSubstrings(String text) {\\n        int n = text.length();\\n        int dp[][] = new int[n][n];\\n        Set<String> set = new LinkedHashSet<>();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i+1; j < n; j++) {\\n                if (text.charAt(i) ==  text.charAt(j)) {\\n                    if (i == 0) {\\n                        dp[i][j] = 1;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 779620,
                "title": "c-string-hashing-solution-with-explanation",
                "content": "Simple Brute force will be to check every 2 adjacent substring of all lengths. We can improve our solution to O(n^2) using string Hashing. \\nI would recommend reading string hashing in cp-algo website to easily understand this important concept.\\nThe steps followed are:\\n1) Select 2 primes, for many cases based on simple text, p=31 works. The other big prime is taken to be 1000000009.\\n2) Pre calculate the power of p upto n.\\n3) Calculate the hash for all prefix substring of the string. \\n4) Now we consider all substring of length L. We check if the hash of both half of this substring is equal. If yes, we can mark this hash in a map. This handles all the duplicates. \\nRest of the explanation is in code. Comment for any doubt.\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll p=31;\\n    ll m=1000000009;\\n    int distinctEchoSubstrings(string text) {\\n        ll n=text.size();\\n        vector <ll> p_pow(n);\\n        p_pow[0]=1;\\n        for(ll i=1;i<n;i++)\\n            p_pow[i]=(p_pow[i-1]*p)%m;\\n        vector <ll> hash(n+1,0);\\n        for(ll i=0;i<n;i++)\\n        {\\n\\t\\t   hash[i+1]= (hash[i] + (text[i]-\\'a\\'+1)*p_pow[i])%m; //dont forget the 1 here, or else \"aa\" and \"aaa\" will map to the same value\\n        }\\n        //for(int i=0;i<=n;i++)\\n           // cout<<hash[i]<< \" \";\\n        unordered_map <ll ,ll > um;\\n        for(ll l=2;l<=n;l+=2)\\n        {\\n            for(ll i=0;i+l<=n;i++)\\n            {\\n                ll curr1= (hash[i+l/2]+m-hash[i])%m; // +m for ensuring +ve remainder\\n                curr1=(curr1*p_pow[n-i-1])%m; \\n                ll curr2= (hash[i+ l] +m - hash[i+l/2])%m; \\n                curr2=(curr2*p_pow[n-i-1-l/2])%m;\\n                //cout<<curr1<<\" \"<<curr2<<endl;\\n                if(curr1==curr2)\\n                {\\n                    um[curr1]++; //mark this substring\\'s hash as visited\\n                }\\n            }\\n        }\\n        return um.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Rolling Hash"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll p=31;\\n    ll m=1000000009;\\n    int distinctEchoSubstrings(string text) {\\n        ll n=text.size();\\n        vector <ll> p_pow(n);\\n        p_pow[0]=1;\\n        for(ll i=1;i<n;i++)\\n            p_pow[i]=(p_pow[i-1]*p)%m;\\n        vector <ll> hash(n+1,0);\\n        for(ll i=0;i<n;i++)\\n        {\\n\\t\\t   hash[i+1]= (hash[i] + (text[i]-\\'a\\'+1)*p_pow[i])%m; //dont forget the 1 here, or else \"aa\" and \"aaa\" will map to the same value\\n        }\\n        //for(int i=0;i<=n;i++)\\n           // cout<<hash[i]<< \" \";\\n        unordered_map <ll ,ll > um;\\n        for(ll l=2;l<=n;l+=2)\\n        {\\n            for(ll i=0;i+l<=n;i++)\\n            {\\n                ll curr1= (hash[i+l/2]+m-hash[i])%m; // +m for ensuring +ve remainder\\n                curr1=(curr1*p_pow[n-i-1])%m; \\n                ll curr2= (hash[i+ l] +m - hash[i+l/2])%m; \\n                curr2=(curr2*p_pow[n-i-1-l/2])%m;\\n                //cout<<curr1<<\" \"<<curr2<<endl;\\n                if(curr1==curr2)\\n                {\\n                    um[curr1]++; //mark this substring\\'s hash as visited\\n                }\\n            }\\n        }\\n        return um.size();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 477042,
                "title": "python-brute-force",
                "content": "```python\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        res = set()\\n        n = len(text)\\n        def check(s):\\n            l = len(s)\\n            if l % 2 == 0 and s[:l//2] == s[l//2:]:\\n                return True\\n            return False\\n        for i in range(n):\\n            for j in range(i+1, n+1):\\n                if check(text[i:j]):\\n                    res.add(text[i:j])\\n        #print(res)\\n        return len(res)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        res = set()\\n        n = len(text)\\n        def check(s):\\n            l = len(s)\\n            if l % 2 == 0 and s[:l//2] == s[l//2:]:\\n                return True\\n            return False\\n        for i in range(n):\\n            for j in range(i+1, n+1):\\n                if check(text[i:j]):\\n                    res.add(text[i:j])\\n        #print(res)\\n        return len(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831379,
                "title": "python-presum-hash-sliding-window-beats-100-11-lines",
                "content": "**Step-by-step:**\\nThe numbers match the annotations in the code.  \\n\\n**1. Optimization**\\n(#1) Whenever the string consists of only one character, there will be **len(string) // 2** distinct substrings that match the criteria.  \\n```python\\n\"a\" -> {}                      # 1 // 2 = 0\\n\"aa\" -> {\"a\"}                  # 2 // 2 = 1\\n\"aaa\" -> {\"a\"}                 # 3 // 2 = 1\\n\"aaaa\" -> {\"a\", \"aa\"}          # 4 // 2 = 2\\n\"aaaaa\" -> {\"a\", \"aa\"}         # 5 // 2 = 2\\n\"aaaaaa\" -> {\"a\", \"aa\", \"aaa\"} # 6 // 2 = 3\\n```\\n**2. Presum Hash**\\nYou can think of the presum hash as the Rabin-Karp algorithm **(hash = &Sigma; ord(char) &middot; d<sup>i</sup>)** where d = 1 so **hash = &Sigma; ord(char)**.  If you are unfamiliar with the Rabin-Karp algorithm check out this link: <a href=\"https://www.youtube.com/watch?v=BfUejqd07yo\">Rolling Hash Function Tutorial</a>\\n\\n(#2) Next, calculate the hash for **text[:i]** for all indices **(i)** in text, and store them in the array presum.  \\n(#2.1) The hash for string **text[i:j]** can now be found in O(1) time  **hash(text[i:j]) = presum[j] - presum[i]**. \\n\\n**3. Find Echos**\\nFor all echo string lengths **(w)** from 1 to half the length of the text.  Slide **i** along text where **i** is the first index of the echo string.  \\n```python\\n   echo    echo\\n |<--w-->|<--w-->|\\n i      i+w     i+2w\\n\\'abcababcabcabcabcaaabcabc\\'\\n```\\nUse the presum hash described in part 2, to decide if **hash(text[i:i+w]) == hash(text[i+w: i+2*w])** in O(1) time... almost.\\n\\nI say almost because the hash is just **&Sigma; ord(char)** for each echo string.  So when the first and second echo contain the same characters, like **\"cababc\"**, then **text[i:i+w] = \"cab\"** and **text[i+w:i+2*w] = \"abc\"**, the strings are not equal but they will have the same hash: **hash(\\'abc\\') = hash(\\'cab\\') = 97 + 98 + 99 = 294**.  This is called a collision.  \\n\\nTo double check that **text[i+w: i+2*w]** is an echo of **text[i:i+w]**, whenever **hash(text[i:i+w]) == hash(text[i+w: i+2*w])** we must also check that **text[i:i+w] == text[i+w: i+2*w]** (#3).  If the two echo strings are equal, then it is safe to add the full string to our result **(res)**.  \\n\\n```python\\ndef distinctEchoSubstrings(self, text: str) -> int:\\n\\n\\tif len(set(text)) == 1: return len(text)//2 # 1\\n\\n\\tpresum = [0] # 2\\n\\tfor char in text:\\n\\t\\tpresum.append(presum[-1] + ord(char))\\n\\n\\tres = set()\\n\\tfor w in range(1,(2 + len(text)) // 2):\\n\\t\\tfor i in range(len(text) + 1 - 2*w):\\n\\t\\t\\tif presum[i+w] - presum[i] == presum[i+2*w] - presum[i+w]: # 2.1\\n\\t\\t\\t\\tif text[i:i+w] == text[i+w:i+2*w]: # 3\\n\\t\\t\\t\\t\\tres.add(text[i:i+w])\\n\\n\\treturn len(res)\\n```\\n<img src=\"https://assets.leetcode.com/users/images/b38ec8da-b700-44be-95e7-9d52e79e00fc_1599371717.705521.png\" width=\"50%\">\\n\\n",
                "solutionTags": [],
                "code": "```python\\n\"a\" -> {}                      # 1 // 2 = 0\\n\"aa\" -> {\"a\"}                  # 2 // 2 = 1\\n\"aaa\" -> {\"a\"}                 # 3 // 2 = 1\\n\"aaaa\" -> {\"a\", \"aa\"}          # 4 // 2 = 2\\n\"aaaaa\" -> {\"a\", \"aa\"}         # 5 // 2 = 2\\n\"aaaaaa\" -> {\"a\", \"aa\", \"aaa\"} # 6 // 2 = 3\\n```\n```python\\n   echo    echo\\n |<--w-->|<--w-->|\\n i      i+w     i+2w\\n\\'abcababcabcabcabcaaabcabc\\'\\n```\n```python\\ndef distinctEchoSubstrings(self, text: str) -> int:\\n\\n\\tif len(set(text)) == 1: return len(text)//2 # 1\\n\\n\\tpresum = [0] # 2\\n\\tfor char in text:\\n\\t\\tpresum.append(presum[-1] + ord(char))\\n\\n\\tres = set()\\n\\tfor w in range(1,(2 + len(text)) // 2):\\n\\t\\tfor i in range(len(text) + 1 - 2*w):\\n\\t\\t\\tif presum[i+w] - presum[i] == presum[i+2*w] - presum[i+w]: # 2.1\\n\\t\\t\\t\\tif text[i:i+w] == text[i+w:i+2*w]: # 3\\n\\t\\t\\t\\t\\tres.add(text[i:i+w])\\n\\n\\treturn len(res)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 478284,
                "title": "c-using-a-trie-o-n-without-hash-collision-issues",
                "content": "There are some very fast rolling hash solutions out there. But as many have pointed out, those are not 100% reliable because of possible hash collisions. And to store and double-check every match char-by-char would increase worst-case runtime complexity to O(n\\xB3).\\n\\nAn alternative approach is to build a trie, and use the identity (memory address) of the trie nodes to uniquely identify a substring. This is O(n\\xB2) and there can\\'t be any collisions that way, but at the cost of speed. Memory access takes time, and we don\\'t even get the benefit of cache locality. It runs at about 350 ms. Double that if we clean up our Trie nodes afterwards.\\n\\n```C++\\nclass Solution {\\npublic:\\n  int distinctEchoSubstrings(string const& text) {\\n    SSIDStore ssids = constructSubstringIdentifiers(text);\\n    return distinctEchoSubstrings(text, ssids);\\n  }\\n\\nprivate:\\n  /////////// Types ///////////\\n  \\n  struct Trie {\\n    array<Trie*, 26> children_ {};\\n    Trie* append(char c) { return children_[c-\\'a\\'] ? children_[c-\\'a\\'] : (children_[c-\\'a\\'] = new Trie); }\\n    // ~Trie() { for (Trie* child : children_) delete child; } // cleaning up adds about 350ms to the runtime\\n  };\\n  \\n  using SSID      = uint64_t;             // Substring ID\\n  using SSIDStore = vector<vector<SSID>>; // index \\u2192 length \\u2192 id\\n  \\n  /////////// Functions ///////////\\n  \\n  /* For every relevant substring, assign a unique number derived from a Trie address: O(n\\xB2) */\\n  static SSIDStore constructSubstringIdentifiers(string const& text) {\\n    int const N = text.size();\\n    SSIDStore result(N, vector<SSID>(N/2+1));\\n    Trie root;\\n    for (int l = 0; l < N; ++l) {\\n      Trie* node = &root;\\n      int const maxLen = max(min(l, N-l), (N-l)/2);\\n      for (int len = 1; len <= maxLen; ++len) {\\n        node = node->append(text[l+len-1]);\\n        result[l][len] = (SSID)node; // interpret memory address as integer\\n      }\\n    }\\n    return result;\\n  }\\n  \\n  /* Count the number of distinct echo substrings: O(n\\xB2) */\\n  static int distinctEchoSubstrings(string const& text, SSIDStore const& ssids) {\\n    int const N = text.size();\\n    unordered_set<SSID> found;\\n    for (int l = 0; l < N; ++l)\\n      for (int len = 1; len <= (N-l)/2; ++len)\\n        if (ssids[l][len] == ssids[l+len][len])\\n          found.insert(ssids[l][len]);\\n    return found.size();\\n  }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n  int distinctEchoSubstrings(string const& text) {\\n    SSIDStore ssids = constructSubstringIdentifiers(text);\\n    return distinctEchoSubstrings(text, ssids);\\n  }\\n\\nprivate:\\n  /////////// Types ///////////\\n  \\n  struct Trie {\\n    array<Trie*, 26> children_ {};\\n    Trie* append(char c) { return children_[c-\\'a\\'] ? children_[c-\\'a\\'] : (children_[c-\\'a\\'] = new Trie); }\\n    // ~Trie() { for (Trie* child : children_) delete child; } // cleaning up adds about 350ms to the runtime\\n  };\\n  \\n  using SSID      = uint64_t;             // Substring ID\\n  using SSIDStore = vector<vector<SSID>>; // index \\u2192 length \\u2192 id\\n  \\n  /////////// Functions ///////////\\n  \\n  /* For every relevant substring, assign a unique number derived from a Trie address: O(n\\xB2) */\\n  static SSIDStore constructSubstringIdentifiers(string const& text) {\\n    int const N = text.size();\\n    SSIDStore result(N, vector<SSID>(N/2+1));\\n    Trie root;\\n    for (int l = 0; l < N; ++l) {\\n      Trie* node = &root;\\n      int const maxLen = max(min(l, N-l), (N-l)/2);\\n      for (int len = 1; len <= maxLen; ++len) {\\n        node = node->append(text[l+len-1]);\\n        result[l][len] = (SSID)node; // interpret memory address as integer\\n      }\\n    }\\n    return result;\\n  }\\n  \\n  /* Count the number of distinct echo substrings: O(n\\xB2) */\\n  static int distinctEchoSubstrings(string const& text, SSIDStore const& ssids) {\\n    int const N = text.size();\\n    unordered_set<SSID> found;\\n    for (int l = 0; l < N; ++l)\\n      for (int len = 1; len <= (N-l)/2; ++len)\\n        if (ssids[l][len] == ssids[l+len][len])\\n          found.insert(ssids[l][len]);\\n    return found.size();\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2530137,
                "title": "c-simple-c-code-rolling-hashing",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string s) {\\n        int mod = INT_MAX, base = 28, n = s.size();\\n        unordered_map<long long, int> um;\\n        vector<long long> ChkVal(n+1);\\n        long long remove = 1;\\n        for(int i = 1; i <= n/2; i++)\\n        {\\n            long long hash = 0;\\n            int l = 0, appear = 0;\\n            for(int j = 0; j < n; j++)\\n            {\\n                 hash = (( hash * base ) % mod  + (s[j] - \\'a\\' + 1))%mod;\\n                 if(j-l == i-1) \\n                 {\\n                     ChkVal[j]=hash;\\n                     if(appear > 0) \\n                     {\\n                         if(ChkVal[j-i]==hash)\\n                            um[hash]++;\\n                     }\\n                     appear++;\\n                     hash = (hash - ((s[l] - \\'a\\' + 1)*remove)%mod)%mod;\\n                     if(hash<0) hash+=mod;\\n                     l++;\\n                }\\n            }\\n            // cout << i << \" \" << um.size() << endl; \\n            remove = (remove * base)%mod;\\n        }\\n        return um.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Rolling Hash"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string s) {\\n        int mod = INT_MAX, base = 28, n = s.size();\\n        unordered_map<long long, int> um;\\n        vector<long long> ChkVal(n+1);\\n        long long remove = 1;\\n        for(int i = 1; i <= n/2; i++)\\n        {\\n            long long hash = 0;\\n            int l = 0, appear = 0;\\n            for(int j = 0; j < n; j++)\\n            {\\n                 hash = (( hash * base ) % mod  + (s[j] - \\'a\\' + 1))%mod;\\n                 if(j-l == i-1) \\n                 {\\n                     ChkVal[j]=hash;\\n                     if(appear > 0) \\n                     {\\n                         if(ChkVal[j-i]==hash)\\n                            um[hash]++;\\n                     }\\n                     appear++;\\n                     hash = (hash - ((s[l] - \\'a\\' + 1)*remove)%mod)%mod;\\n                     if(hash<0) hash+=mod;\\n                     l++;\\n                }\\n            }\\n            // cout << i << \" \" << um.size() << endl; \\n            remove = (remove * base)%mod;\\n        }\\n        return um.size();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1244285,
                "title": "c-solution-rolling-hash-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    static const int N=2005;\\n    int mod=1e9+7;\\n    int B=31;\\n    long long h[N],p[N],invp[N];\\n    int modexp(int x,int y){\\n        int res=1;\\n        while(y>0){\\n            if(y&1) res=((long long)res*x)%mod;\\n            x=((long long)x*x)%mod;\\n            y=y>>1;\\n        }\\n        return res;\\n    }\\n    int sub_hash(int l,int r){\\n        int ans=h[r];\\n        if(l>0)\\n            ans=((ans+mod-h[l-1])*invp[l]*1LL)%mod;\\n        return ans;\\n    }\\n    int distinctEchoSubstrings(string text) {\\n        set<int> res;\\n        int ans=0;\\n        p[0]=1;invp[0]=1;\\n        for(int i=1;i<2005;i++){\\n            p[i]=(p[i-1]*B)%mod;\\n        }\\n        for(int i=1;i<N;i++){\\n            invp[i]=(invp[i-1]*modexp(B,mod-2))%mod;\\n        }\\n        int n=text.size();\\n        h[0]=(text[0]-\\'a\\'+1);\\n        for(int i=1;i<n;i++){\\n            h[i]=(h[i-1]+((text[i]-\\'a\\'+1)*p[i])*1LL)%mod;\\n        }\\n        for(int len=1;len<=n/2;len++){\\n            for(int i=0;i<n+1-2*len;i++){\\n                int a=sub_hash(i,i+len-1);\\n                int b=sub_hash(i+len,i+2*len-1);\\n                if(a==b){\\n                    if(res.find(a)==res.end()){\\n                        res.insert(a);\\n                        ans++;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static const int N=2005;\\n    int mod=1e9+7;\\n    int B=31;\\n    long long h[N],p[N],invp[N];\\n    int modexp(int x,int y){\\n        int res=1;\\n        while(y>0){\\n            if(y&1) res=((long long)res*x)%mod;\\n            x=((long long)x*x)%mod;\\n            y=y>>1;\\n        }\\n        return res;\\n    }\\n    int sub_hash(int l,int r){\\n        int ans=h[r];\\n        if(l>0)\\n            ans=((ans+mod-h[l-1])*invp[l]*1LL)%mod;\\n        return ans;\\n    }\\n    int distinctEchoSubstrings(string text) {\\n        set<int> res;\\n        int ans=0;\\n        p[0]=1;invp[0]=1;\\n        for(int i=1;i<2005;i++){\\n            p[i]=(p[i-1]*B)%mod;\\n        }\\n        for(int i=1;i<N;i++){\\n            invp[i]=(invp[i-1]*modexp(B,mod-2))%mod;\\n        }\\n        int n=text.size();\\n        h[0]=(text[0]-\\'a\\'+1);\\n        for(int i=1;i<n;i++){\\n            h[i]=(h[i-1]+((text[i]-\\'a\\'+1)*p[i])*1LL)%mod;\\n        }\\n        for(int len=1;len<=n/2;len++){\\n            for(int i=0;i<n+1-2*len;i++){\\n                int a=sub_hash(i,i+len-1);\\n                int b=sub_hash(i+len,i+2*len-1);\\n                if(a==b){\\n                    if(res.find(a)==res.end()){\\n                        res.insert(a);\\n                        ans++;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477896,
                "title": "no-rolling-hash-trie-with-optimization-and-explanation",
                "content": "## **Explanation**\\nUse a trie to find if there is a substring that is exactly same as another substring left adjacent to it. If we find such a pair of substrings, increment result by 1, and in the trie mark the substring as \"found\" so we don\\'t count duplicates.\\nThere is an optimization:\\n```\\nif i - start + 1 > len(text) - i and i - start + 1 > start:\\n    break\\n```\\nWhile we are looking for apair of adjacent substrings `str1 str2`,\\n\\nif `i - start + 1 > len(text) - i`: it will be impossilbe to find a long enough `str2` that matches the `str1` we are looking at,\\nand if `i - start + 1 > start`: it will be impossible to find a long enough `str1` that matches the `str2` we are looking at\\n\\nthen we don\\'t have to look further on the substrings that started from `start`.\\n\\n## **Python code**\\n\\n```\\nimport collections\\nclass Solution(object):\\n    def distinctEchoSubstrings(self, text):\\n        T = lambda: collections.defaultdict(T)\\n        trie = T()\\n        res = 0\\n        for start in xrange(len(text)):\\n            t = trie\\n            for i in xrange(start, len(text)):\\n                t = t[text[i]]\\n                if \"found\" in t:\\n                    continue\\n                if i - start + 1 > len(text) - i and i - start + 1 > start:\\n                    break\\n                t.setdefault(\"indexes\", set()).add(i)\\n                if start - 1 in t[\"indexes\"]:\\n                    res += 1\\n                    t[\"found\"] = True\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nif i - start + 1 > len(text) - i and i - start + 1 > start:\\n    break\\n```\n```\\nimport collections\\nclass Solution(object):\\n    def distinctEchoSubstrings(self, text):\\n        T = lambda: collections.defaultdict(T)\\n        trie = T()\\n        res = 0\\n        for start in xrange(len(text)):\\n            t = trie\\n            for i in xrange(start, len(text)):\\n                t = t[text[i]]\\n                if \"found\" in t:\\n                    continue\\n                if i - start + 1 > len(text) - i and i - start + 1 > start:\\n                    break\\n                t.setdefault(\"indexes\", set()).add(i)\\n                if start - 1 in t[\"indexes\"]:\\n                    res += 1\\n                    t[\"found\"] = True\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 606380,
                "title": "o-n-2-36ms-solution-with-easy-rolling-hash-c",
                "content": "```\\nconst int p = 1e9 + 7;\\nstruct RollingHash {\\n    vector<long> hash;\\n    vector<long> power;\\n    RollingHash(string &s):hash(s.size() + 1), power(s.size() + 1, 1) {\\n        for(int i = 1; i <= s.size(); i++) {\\n            char c = s[i - 1];\\n            hash[i] = (hash[i - 1] * 257 + c) % p;\\n            power[i] = (power[i - 1] * 257 ) % p;\\n        }\\n    }\\n    \\n    int getHash(int i, int j) {\\n        long h = hash[j + 1];\\n        h -= (power[j - i + 1] * hash[i]) % p;\\n        h = (h + p) % p;\\n        return h;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        RollingHash hash(text);\\n        int n = text.size();\\n        int ans = 0;\\n        unordered_set<int> hashes;\\n        for(int i = 0; i < n; i++)\\n            for(int d = (n - i) / 2; d >= 1; d--) {\\n                int h1 = hash.getHash(i, i + d - 1);\\n                if(h1 == hash.getHash(i + d, i + 2 * d - 1)) {\\n                    if(hashes.count(h1))break;\\n                    hashes.insert(h1);\\n                }\\n            }\\n                 \\n        return hashes.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst int p = 1e9 + 7;\\nstruct RollingHash {\\n    vector<long> hash;\\n    vector<long> power;\\n    RollingHash(string &s):hash(s.size() + 1), power(s.size() + 1, 1) {\\n        for(int i = 1; i <= s.size(); i++) {\\n            char c = s[i - 1];\\n            hash[i] = (hash[i - 1] * 257 + c) % p;\\n            power[i] = (power[i - 1] * 257 ) % p;\\n        }\\n    }\\n    \\n    int getHash(int i, int j) {\\n        long h = hash[j + 1];\\n        h -= (power[j - i + 1] * hash[i]) % p;\\n        h = (h + p) % p;\\n        return h;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        RollingHash hash(text);\\n        int n = text.size();\\n        int ans = 0;\\n        unordered_set<int> hashes;\\n        for(int i = 0; i < n; i++)\\n            for(int d = (n - i) / 2; d >= 1; d--) {\\n                int h1 = hash.getHash(i, i + d - 1);\\n                if(h1 == hash.getHash(i + d, i + 2 * d - 1)) {\\n                    if(hashes.count(h1))break;\\n                    hashes.insert(h1);\\n                }\\n            }\\n                 \\n        return hashes.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 565625,
                "title": "java-rolling-haha",
                "content": "```\\nclass Solution {\\n    int mod=1000000007;\\n    long hash[];\\n    long pow[];\\n    public int distinctEchoSubstrings(String text) {\\n        hash=new long[text.length()];\\n        pow=new long[text.length()];\\n        pow[0]=1;\\n        hash[0]=text.charAt(0)%mod;\\n        Set<String>res=new HashSet<>();\\n        for(int i=1;i<text.length();i++){\\n            hash[i]=(hash[i-1]*26+text.charAt(i))%mod;\\n            pow[i]=(pow[i-1]*26)%mod;\\n        }\\n        for(int i=0;i<text.length();i++){\\n            for(int len=1;i+len*2<=text.length();len++){\\n                long hash1=0;long hash2=0;\\n                hash1=gethash(text,i,i+len-1);\\n                hash2=gethash(text,i+len,i+len*2-1);\\n                if(hash1==hash2&&text.substring(i,i+len).equals(text.substring(i+len,i+len*2))){\\n                    res.add(text.substring(i,i+len));\\n                }\\n            }\\n        }\\n        return res.size();\\n    }\\n\\t//similar idea as prefix sum\\n    public long gethash(int left,int right){\\n        if(left==0)return hash[right];\\n        long res=(hash[right]-hash[left-1]*pow[right-left+1])%mod;\\n        if(res<0)res+=mod;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int mod=1000000007;\\n    long hash[];\\n    long pow[];\\n    public int distinctEchoSubstrings(String text) {\\n        hash=new long[text.length()];\\n        pow=new long[text.length()];\\n        pow[0]=1;\\n        hash[0]=text.charAt(0)%mod;\\n        Set<String>res=new HashSet<>();\\n        for(int i=1;i<text.length();i++){\\n            hash[i]=(hash[i-1]*26+text.charAt(i))%mod;\\n            pow[i]=(pow[i-1]*26)%mod;\\n        }\\n        for(int i=0;i<text.length();i++){\\n            for(int len=1;i+len*2<=text.length();len++){\\n                long hash1=0;long hash2=0;\\n                hash1=gethash(text,i,i+len-1);\\n                hash2=gethash(text,i+len,i+len*2-1);\\n                if(hash1==hash2&&text.substring(i,i+len).equals(text.substring(i+len,i+len*2))){\\n                    res.add(text.substring(i,i+len));\\n                }\\n            }\\n        }\\n        return res.size();\\n    }\\n\\t//similar idea as prefix sum\\n    public long gethash(int left,int right){\\n        if(left==0)return hash[right];\\n        long res=(hash[right]-hash[left-1]*pow[right-left+1])%mod;\\n        if(res<0)res+=mod;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477277,
                "title": "c-concise-dp-solution",
                "content": "```\\npublic class Solution {\\n    public int DistinctEchoSubstrings(string text) {\\n        int mod = (int)Math.Pow(10,9) + 7;\\n        int[,] dp = new int[text.Length+1, text.Length+1];\\n        HashSet<int> res = new HashSet<int>();\\n        for (int i = 1; i <= text.Length; i++)\\n        {\\n            for (int j = i; j <= text.Length; j++)\\n            {\\n                dp[i, j] = dp[i, j - 1] * 26 % mod + text[j - 1] - \\'a\\' + 1;\\n                if (i * 2 - j - 1 >= 0 && dp[i * 2 - j - 1, i - 1] == dp[i, j])\\n                    res.Add(dp[i, j]);\\n            }\\n        }\\n        \\n        return res.Count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int DistinctEchoSubstrings(string text) {\\n        int mod = (int)Math.Pow(10,9) + 7;\\n        int[,] dp = new int[text.Length+1, text.Length+1];\\n        HashSet<int> res = new HashSet<int>();\\n        for (int i = 1; i <= text.Length; i++)\\n        {\\n            for (int j = i; j <= text.Length; j++)\\n            {\\n                dp[i, j] = dp[i, j - 1] * 26 % mod + text[j - 1] - \\'a\\' + 1;\\n                if (i * 2 - j - 1 >= 0 && dp[i * 2 - j - 1, i - 1] == dp[i, j])\\n                    res.Add(dp[i, j]);\\n            }\\n        }\\n        \\n        return res.Count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2691157,
                "title": "i-am-dumb-i-can-t-understand-this-task",
                "content": "I can\\'t understand this line, `that can be written as the concatenation of some string with itself (i.e. it can be written as a + a where a is some string).`\\n\\nEvery string can be written as the concatenation of some string with itself.... WTF is this task? I wasted 24+ hours just to understand the test cases but couldn\\'t get anything. \\n\\n\\nSomebody please kill me, I no longer feel the reason to stay alive.",
                "solutionTags": [],
                "code": "I can\\'t understand this line, `that can be written as the concatenation of some string with itself (i.e. it can be written as a + a where a is some string).`\\n\\nEvery string can be written as the concatenation of some string with itself.... WTF is this task? I wasted 24+ hours just to understand the test cases but couldn\\'t get anything. \\n\\n\\nSomebody please kill me, I no longer feel the reason to stay alive.",
                "codeTag": "Unknown"
            },
            {
                "id": 1341886,
                "title": "python-3-rolling-hash-5780ms",
                "content": "```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        n = len(text)\\n\\t\\t\\n        def helper(size):\\n            base = 1 << 5\\n            M = 10 ** 9 + 7\\n            a = pow(base, size, M)\\n            t = 0\\n            vis = defaultdict(set)\\n            vis_pattern = set()\\n            ans = 0\\n            for i in range(n):\\n                t = (base * t + ord(text[i]) - ord(\\'a\\')) % M\\n                if i >= size:\\n                    t -= a * (ord(text[i - size]) - ord(\\'a\\'))\\n                    t %= M\\n                    if t not in vis_pattern and (i - size * 2 + 1) in vis[t]:\\n                        ans += 1\\n                        vis_pattern.add(t)\\n                if i >= size - 1:\\n                    vis[t].add(i - size + 1)\\n            return ans\\n\\n        return sum(helper(size) for size in range(1, n//2+1))",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Rolling Hash"
                ],
                "code": "```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        n = len(text)\\n\\t\\t\\n        def helper(size):\\n            base = 1 << 5\\n            M = 10 ** 9 + 7\\n            a = pow(base, size, M)\\n            t = 0\\n            vis = defaultdict(set)\\n            vis_pattern = set()\\n            ans = 0\\n            for i in range(n):\\n                t = (base * t + ord(text[i]) - ord(\\'a\\')) % M\\n                if i >= size:\\n                    t -= a * (ord(text[i - size]) - ord(\\'a\\'))\\n                    t %= M\\n                    if t not in vis_pattern and (i - size * 2 + 1) in vis[t]:\\n                        ans += 1\\n                        vis_pattern.add(t)\\n                if i >= size - 1:\\n                    vis[t].add(i - size + 1)\\n            return ans\\n\\n        return sum(helper(size) for size in range(1, n//2+1))",
                "codeTag": "Java"
            },
            {
                "id": 1181698,
                "title": "java-clean-o-n-2-rolling-hash-dynamic-programming-solution-with-comments",
                "content": "For those who are not familiar with Rabin-Karp rolling-hash method, I strongly recommand you try this question first. \\n* [28. Implement strStr()](https://leetcode.com/problems/implement-strstr/)\\n\\nYou might also want to try and compare these questions to realize the power of Rabin-Karp\\'s:\\n* [214. Shortest Palindrome](https://leetcode.com/problems/shortest-palindrome/)\\n* [718. Maximum Length of Repeated Subarray](https://leetcode.com/problems/maximum-length-of-repeated-subarray/discuss/1181612/Java-Clean-O(N-logN)-Rolling-Hash-Solution-oror-with-comments)\\n* [1044. Longest Duplicate Substring (collision)](https://leetcode.com/problems/longest-duplicate-substring/discuss/1260058/Java-Rabin-Karp-O(N-logN)-Solution-oror-with-comments)\\n* [1316. Distinct Echo Substrings](https://leetcode.com/problems/distinct-echo-substrings/discuss/1181698/Java-clean-O(n2)-Rolling-Hash-Solution-oror-with-comments)\\n* [1698. Number of Distinct Substrings in a String](https://leetcode.com/problems/number-of-distinct-substrings-in-a-string/discuss/1196782/Java-clean-O(N2)-Rabin-Karp-Solution)\\n\\nAgain, everytime we calculate hash values when implementing Rabin-Karp\\'s, there\\'s some issue to worry about. There are some good practices that will make this algorithm stable: \\n1. taking modulus to avoid overflow\\n2. each time adding a positive number when updating hash value\\n\\nConsider these two ways of updating hash values: \\n``` \\nhash = hash * PRIME + text.charAt(j);\\nhash = hash * PRIME + text.charAt(j) - \\'a\\' + 1;\\nhash = hash * PRIME + text.charAt(j) - \\'a\\';\\n```\\nThe third one will not work here since encountering \\'a\\' leads to adding 0 to hash value. Thus \"a\", \"aa\", \"aa....a\"  will share the same hash value. \\n\\n```\\nclass Solution {\\n    private static final int PRIME = 101;\\n    private static final int MOD = 1_000_000_007;\\n    public int distinctEchoSubstrings(String text) {\\n        int n = text.length();\\n        \\n        // dp[i][j] : hash value of text[i:j]\\n        int[][] dp = new int[n][n];\\n        for (int i = 0; i < n; i++) {\\n            long hash = 0;\\n            for (int j = i; j < n; j++) {\\n                hash = hash * PRIME + (text.charAt(j) - \\'a\\' + 1);\\n                hash %= MOD;\\n                dp[i][j] = (int) hash;\\n            }\\n        }\\n        \\n        Set<Integer> set = new HashSet<>();\\n        int res = 0;\\n        for (int i = 0; i < n-1; i++) {\\n            // compare text[i:j] with text[j+1: 2j-i+1]\\n            for (int j = i; 2*j - i + 1 < n; j++) {\\n                if (dp[i][j] == dp[j+1][2*j - i+1] && set.add(dp[i][j])) res++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\nNote: this Solution is induced by a [Monte Carlo Algorithm](http://people.seas.harvard.edu/~cs125/fall16/section-notes/09.pdf), which might leads to unwanted results due to hash collision. However in real practice, the probability of hash collision is very low due to our choice of PRIME & MOD. If we want to absolutely eliminate any possibility of unwanted results caused by the algorithm, we might compare two String if they have the same hash value; Namely, this solution will be induced by a [Las Vegas Algorithm](http://people.seas.harvard.edu/~cs125/fall16/section-notes/09.pdf).",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Rolling Hash"
                ],
                "code": "``` \\nhash = hash * PRIME + text.charAt(j);\\nhash = hash * PRIME + text.charAt(j) - \\'a\\' + 1;\\nhash = hash * PRIME + text.charAt(j) - \\'a\\';\\n```\n```\\nclass Solution {\\n    private static final int PRIME = 101;\\n    private static final int MOD = 1_000_000_007;\\n    public int distinctEchoSubstrings(String text) {\\n        int n = text.length();\\n        \\n        // dp[i][j] : hash value of text[i:j]\\n        int[][] dp = new int[n][n];\\n        for (int i = 0; i < n; i++) {\\n            long hash = 0;\\n            for (int j = i; j < n; j++) {\\n                hash = hash * PRIME + (text.charAt(j) - \\'a\\' + 1);\\n                hash %= MOD;\\n                dp[i][j] = (int) hash;\\n            }\\n        }\\n        \\n        Set<Integer> set = new HashSet<>();\\n        int res = 0;\\n        for (int i = 0; i < n-1; i++) {\\n            // compare text[i:j] with text[j+1: 2j-i+1]\\n            for (int j = i; 2*j - i + 1 < n; j++) {\\n                if (dp[i][j] == dp[j+1][2*j - i+1] && set.add(dp[i][j])) res++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 616900,
                "title": "c-accepted-o-n-2-method-with-kmp-algorithms",
                "content": "The idea is to use KMP algorithm for finding the cycle period, the vanilla implement is as follows:\\n```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        unordered_set<string> rnt;\\n        while(text.length() >= 2){\\n            helper(text, rnt);\\n            text = text.substr(1, text.length() - 1);\\n        }\\n        return rnt.size();\\n    }\\n    \\n    void helper(string& text, unordered_set<string>& rnt){\\n        vector<int> nexts(text.size() + 1, -1);\\n        int pt = 0, k = -1;\\n        while(pt < text.size()){\\n            if(k == -1 || text[pt] == text[k]){\\n                pt++; k++;\\n                nexts[pt] = k;\\n            }\\n            else\\n                k = nexts[k];\\n        }\\n        for(int i = 2; i <= text.size(); i += 2)\\n            if(i % (i - nexts[i]) == 0 && (i / (i - nexts[i])) % 2 == 0)\\n                rnt.insert(text.substr(0, (i + 1) / 2));\\n        return;\\n    }\\n};\\n```\\n\\nHere, kmp algorithms used to find prefix cost O(N^2) but the \\'unordered_set<string>\\' used to keep distinct substrings is the bottlenect O(N^3) (thank @gorokhovsky for the reminder). A direct optimization may be string hashing to convert the \\'unordered_set<string>\\' to \\'unordered_set<int>\\' (in this way, the complexity is O(N^2)) as in the following hashing solution:\\n\\n```\\nclass Solution {\\npublic:\\n    using LL = unsigned long long;\\n    int distinctEchoSubstrings(string text) {\\n        int n = text.length();\\n        vector<vector<LL>> dp(n, vector<LL>(n, 0));\\n        for(int i = 0; i < n; i ++){\\n            LL tmp = 0;\\n            for(int j = i; j < n; j ++){\\n                tmp = tmp * 29 + (text[j] - \\'a\\' + 1);\\n                dp[i][j] = tmp;\\n            }\\n        }\\n        unordered_set<int> rnt;\\n        for(int i = 0; i < n - 1; i ++){\\n            for(int w = 1; i + 2 * w <= n; w ++)\\n                if(dp[i][i + w - 1] == dp[i + w][i + 2 * w - 1])\\n                    rnt.insert(dp[i][i + w - 1]);\\n        }\\n        return rnt.size();\\n    }\\n};\\n```\\n\\nThe direct use of string hashing can be a simpler solution. But, as far as I am concerned, the KMP solution can be more general for problems like \\'a + a + ... + a\\' rather than the original special case \\'a + a\\'.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        unordered_set<string> rnt;\\n        while(text.length() >= 2){\\n            helper(text, rnt);\\n            text = text.substr(1, text.length() - 1);\\n        }\\n        return rnt.size();\\n    }\\n    \\n    void helper(string& text, unordered_set<string>& rnt){\\n        vector<int> nexts(text.size() + 1, -1);\\n        int pt = 0, k = -1;\\n        while(pt < text.size()){\\n            if(k == -1 || text[pt] == text[k]){\\n                pt++; k++;\\n                nexts[pt] = k;\\n            }\\n            else\\n                k = nexts[k];\\n        }\\n        for(int i = 2; i <= text.size(); i += 2)\\n            if(i % (i - nexts[i]) == 0 && (i / (i - nexts[i])) % 2 == 0)\\n                rnt.insert(text.substr(0, (i + 1) / 2));\\n        return;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using LL = unsigned long long;\\n    int distinctEchoSubstrings(string text) {\\n        int n = text.length();\\n        vector<vector<LL>> dp(n, vector<LL>(n, 0));\\n        for(int i = 0; i < n; i ++){\\n            LL tmp = 0;\\n            for(int j = i; j < n; j ++){\\n                tmp = tmp * 29 + (text[j] - \\'a\\' + 1);\\n                dp[i][j] = tmp;\\n            }\\n        }\\n        unordered_set<int> rnt;\\n        for(int i = 0; i < n - 1; i ++){\\n            for(int w = 1; i + 2 * w <= n; w ++)\\n                if(dp[i][i + w - 1] == dp[i + w][i + 2 * w - 1])\\n                    rnt.insert(dp[i][i + w - 1]);\\n        }\\n        return rnt.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477038,
                "title": "java-easy-to-understand-solution-n-3",
                "content": "```\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        HashSet<String> results = new HashSet<>();\\n        for (int i = 0; i < text.length(); i++) {\\n            for (int j = i+1; j < text.length(); j++) {\\n                if (text.charAt(i) == text.charAt(j) && check(text, i, j)) {\\n\\t\\t\\t\\t\\t// if you find the same solution twice, HashSet only registers it once\\n                    results.add(text.substring(i, j));\\n                }\\n            }\\n        }\\n        return results.size();\\n    }\\n    \\n\\t// two running indeces: a, b\\n\\t// check if the substring of text from a to b index, can be repeated after the index b\\n    private boolean check(String text, int a, int b) {\\n        for (int i = 0; i < b-a; i++) {\\n            if (b+i >= text.length()) {\\t// exceeded the length of the text\\n                return false;\\n            }\\n            if (text.charAt(a+i) != text.charAt(b+i)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        HashSet<String> results = new HashSet<>();\\n        for (int i = 0; i < text.length(); i++) {\\n            for (int j = i+1; j < text.length(); j++) {\\n                if (text.charAt(i) == text.charAt(j) && check(text, i, j)) {\\n\\t\\t\\t\\t\\t// if you find the same solution twice, HashSet only registers it once\\n                    results.add(text.substring(i, j));\\n                }\\n            }\\n        }\\n        return results.size();\\n    }\\n    \\n\\t// two running indeces: a, b\\n\\t// check if the substring of text from a to b index, can be repeated after the index b\\n    private boolean check(String text, int a, int b) {\\n        for (int i = 0; i < b-a; i++) {\\n            if (b+i >= text.length()) {\\t// exceeded the length of the text\\n                return false;\\n            }\\n            if (text.charAt(a+i) != text.charAt(b+i)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2614328,
                "title": "cpp-brute-force",
                "content": "```\\nclass Solution {\\npublic:  \\n    bool check(string &s){\\n        int j=s.size()/2;\\n        \\n        for(int i=0;i<(s.size()/2);i++){\\n            if(s[i]!=s[j])return false;\\n            j++;\\n        }\\n        return true;\\n    }\\n    \\n    int distinctEchoSubstrings(string text) {\\n               \\n        unordered_set<string>s;\\n        \\n        for(int i=0;i<text.size();i++){\\n            string ans=\"\";\\n            for(int j=i;j<text.size();j+=2){\\n                ans+=text[j];\\n                if(j+1<text.size())ans+=text[j+1];\\n                else break;\\n                \\n                if(check(ans))s.insert(ans);\\n            }\\n        }\\n        \\n        return s.size();\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:  \\n    bool check(string &s){\\n        int j=s.size()/2;\\n        \\n        for(int i=0;i<(s.size()/2);i++){\\n            if(s[i]!=s[j])return false;\\n            j++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1779507,
                "title": "regex-solution",
                "content": "```\\nimport re\\n\\n\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        return len(set(re.findall(\"(?=(.+)\\\\\\\\1)\", text)))\\n```\\n\\nJust simple solution of a problem..",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport re\\n\\n\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        return len(set(re.findall(\"(?=(.+)\\\\\\\\1)\", text)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1616142,
                "title": "java-solution",
                "content": "```\\npublic int distinctEchoSubstrings(String text) {\\n        HashSet<String> hs=new HashSet<>();\\n        \\n        for(int len=1;len<=(text.length()/2);len++)\\n        {\\n            int count=0;\\n            for(int i=0,j=len;j<text.length();i++,j++)\\n            {\\n                if(text.charAt(i)==text.charAt(j))\\n                    count++;\\n                else\\n                    count=0;\\n                \\n                if(count==len)\\n                {\\n                 String s=text.substring(i,j+1);\\n                    hs.add(s);\\n                    count--;\\n                    //abcabca ke liye abc count 3 len then bca-bca coun tnhi hoga \\n                    //as count keeps increasing so decrease count jisse bcabca bhi count ho\\n                    //problem when echo substirngs judi hui ho\\n                    //else nhi toh count=0 aur phirse shuru check\\n                }\\n            }\\n        }\\n        \\n        return hs.size();\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int distinctEchoSubstrings(String text) {\\n        HashSet<String> hs=new HashSet<>();\\n        \\n        for(int len=1;len<=(text.length()/2);len++)\\n        {\\n            int count=0;\\n            for(int i=0,j=len;j<text.length();i++,j++)\\n            {\\n                if(text.charAt(i)==text.charAt(j))\\n                    count++;\\n                else\\n                    count=0;\\n                \\n                if(count==len)\\n                {\\n                 String s=text.substring(i,j+1);\\n                    hs.add(s);\\n                    count--;\\n                    //abcabca ke liye abc count 3 len then bca-bca coun tnhi hoga \\n                    //as count keeps increasing so decrease count jisse bcabca bhi count ho\\n                    //problem when echo substirngs judi hui ho\\n                    //else nhi toh count=0 aur phirse shuru check\\n                }\\n            }\\n        }\\n        \\n        return hs.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1464269,
                "title": "a-different-idea-with-hashmap",
                "content": "First, using a HashMap to store where each character appears. Then for the same character located in i and j respectively, checking if there is a substring starting with j which is equal to the substring from i to j.\\n```\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        char[] arr = text.toCharArray();\\n        Map<Character, List<Integer>> map = new HashMap<>();\\n        for(int i=0; i<arr.length; i++)\\n            map.computeIfAbsent(arr[i], c->new ArrayList<>()).add(i);\\n        if(map.size() == 1) return arr.length/2;\\n        \\n        Set<String> set = new HashSet<>();\\n        for(int i=0; i<arr.length; i++){\\n            for(int idx : map.get(arr[i])){\\n                if(idx > i){\\n                    String subStr = text.substring(i, idx);\\n                    if(text.indexOf(subStr, idx) == idx)\\n                        set.add(subStr+subStr);\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        char[] arr = text.toCharArray();\\n        Map<Character, List<Integer>> map = new HashMap<>();\\n        for(int i=0; i<arr.length; i++)\\n            map.computeIfAbsent(arr[i], c->new ArrayList<>()).add(i);\\n        if(map.size() == 1) return arr.length/2;\\n        \\n        Set<String> set = new HashSet<>();\\n        for(int i=0; i<arr.length; i++){\\n            for(int idx : map.get(arr[i])){\\n                if(idx > i){\\n                    String subStr = text.substring(i, idx);\\n                    if(text.indexOf(subStr, idx) == idx)\\n                        set.add(subStr+subStr);\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1235445,
                "title": "c-brute-force-easy-to-understand",
                "content": "I was getting TLE initially, but after using string_view in place of string, the solution got accepted.\\n\\n```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        int n=text.length();\\n        if(n==1) return 0;\\n        if(n==2){\\n            if(text[0]==text[1]) return true;\\n            return false;\\n        }\\n        set<string_view>s;\\n        string_view str=text;\\n        for(int i=0;i<n;i++){\\n           for(int len=2;i+len-1<n;len+=2){\\n               string_view a1=str.substr(i,len/2);\\n               string_view a2=str.substr(i+len/2,len/2);\\n               if(a1==a2){\\n                   \\n                   s.insert(a1);\\n               }\\n                   \\n           }\\n        }\\n        return s.size();\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        int n=text.length();\\n        if(n==1) return 0;\\n        if(n==2){\\n            if(text[0]==text[1]) return true;\\n            return false;\\n        }\\n        set<string_view>s;\\n        string_view str=text;\\n        for(int i=0;i<n;i++){\\n           for(int len=2;i+len-1<n;len+=2){\\n               string_view a1=str.substr(i,len/2);\\n               string_view a2=str.substr(i+len/2,len/2);\\n               if(a1==a2){\\n                   \\n                   s.insert(a1);\\n               }\\n                   \\n           }\\n        }\\n        return s.size();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1019836,
                "title": "rolling-hash-resource-link",
                "content": "[link](https://cp-algorithms.com/string/string-hashing.html)\\n```\\nclass Solution {\\npublic:\\n    \\n    int distinctEchoSubstrings(string s) {\\n        \\n    int n = s.size();\\n    const int p = 31;\\n    const int m = 1e9 + 9;\\n    vector<long long> p_pow(n);\\n    p_pow[0] = 1;\\n    for (int i = 1; i < n; i++)\\n        p_pow[i] = (p_pow[i-1] * p) % m;\\n\\n    vector<long long> h(n + 1, 0);\\n    for (int i = 0; i < n; i++)\\n        h[i+1] = (h[i] + (s[i] - \\'a\\' + 1) * p_pow[i]) % m;\\n\\n    int ans = 0;\\n    unordered_map<int,bool> mp;\\n    for(int len = 2;len<=n;len+=2){\\n        for(int i = 0;i+len-1<n;i++){\\n            int hash_l = (h[i+len/2] - h[i] + m)%m;\\n            int hash_r = (h[i+len] - h[i+len/2] + m)%m;\\n            if(hash_l*p_pow[n-i-1]%m == hash_r * p_pow[n-i-len/2-1]%m && mp[hash_l*p_pow[n-i-1]%m] == false) {\\n                ans++;\\n                mp[hash_l*p_pow[n-i-1]%m] = true;\\n            }\\n        }\\n    }\\n        \\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int distinctEchoSubstrings(string s) {\\n        \\n    int n = s.size();\\n    const int p = 31;\\n    const int m = 1e9 + 9;\\n    vector<long long> p_pow(n);\\n    p_pow[0] = 1;\\n    for (int i = 1; i < n; i++)\\n        p_pow[i] = (p_pow[i-1] * p) % m;\\n\\n    vector<long long> h(n + 1, 0);\\n    for (int i = 0; i < n; i++)\\n        h[i+1] = (h[i] + (s[i] - \\'a\\' + 1) * p_pow[i]) % m;\\n\\n    int ans = 0;\\n    unordered_map<int,bool> mp;\\n    for(int len = 2;len<=n;len+=2){\\n        for(int i = 0;i+len-1<n;i++){\\n            int hash_l = (h[i+len/2] - h[i] + m)%m;\\n            int hash_r = (h[i+len] - h[i+len/2] + m)%m;\\n            if(hash_l*p_pow[n-i-1]%m == hash_r * p_pow[n-i-len/2-1]%m && mp[hash_l*p_pow[n-i-1]%m] == false) {\\n                ans++;\\n                mp[hash_l*p_pow[n-i-1]%m] = true;\\n            }\\n        }\\n    }\\n        \\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 821378,
                "title": "java-straight-forward-solution",
                "content": "```\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        Set<String> result = new HashSet<>();\\n        for (int i = 2; i <= text.length(); i=i+2) {\\n            for (int j = 0; j < text.length() - i+1; j++) {\\n                String sub = text.substring(j, j+i);\\n                if (sub.substring(0,sub.length()/2).equals(sub.substring(sub.length()/2))) {\\n                        result.add(sub);\\n                }\\n            }\\n        }\\n        return result.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        Set<String> result = new HashSet<>();\\n        for (int i = 2; i <= text.length(); i=i+2) {\\n            for (int j = 0; j < text.length() - i+1; j++) {\\n                String sub = text.substring(j, j+i);\\n                if (sub.substring(0,sub.length()/2).equals(sub.substring(sub.length()/2))) {\\n                        result.add(sub);\\n                }\\n            }\\n        }\\n        return result.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 479264,
                "title": "python-204ms-simple-solution-with-explanations",
                "content": "**Improvements** over brute force solution. \\n* For every character, we only need to check previous occurences of itself\\n* Input like `\"a\"*2000` leads to O(n^3), so we handle them seperately in O(1) time.\\n\\n```\\nfrom collections import defaultdict, deque\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        if all(x==text[0] for x in text):\\n            # handle worst case seperately\\n            return len(text)//2\\n        \\n        res = set()\\n        character_locations = defaultdict(lambda:deque())\\n        for i, c in enumerate(text):\\n            for j in character_locations[c]:\\n                if i + (i - j) > len(text): break\\n                    \\n                # Use startswith to improve result slightly                    \\n                if text.startswith(text[i:i+i-j], j):\\n                    res.add(text[j:i+i-j])\\n                    \\n            character_locations[c].appendleft(i)\\n            \\n        return len(res)\\n        # AC: 204 ms\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict, deque\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        if all(x==text[0] for x in text):\\n            # handle worst case seperately\\n            return len(text)//2\\n        \\n        res = set()\\n        character_locations = defaultdict(lambda:deque())\\n        for i, c in enumerate(text):\\n            for j in character_locations[c]:\\n                if i + (i - j) > len(text): break\\n                    \\n                # Use startswith to improve result slightly                    \\n                if text.startswith(text[i:i+i-j], j):\\n                    res.add(text[j:i+i-j])\\n                    \\n            character_locations[c].appendleft(i)\\n            \\n        return len(res)\\n        # AC: 204 ms\\n```",
                "codeTag": "Java"
            },
            {
                "id": 478340,
                "title": "c-dp-rolling-hash-solution",
                "content": "Steps:\\n1.  Two contiguous equal string have this form \"abcabc\", so if you know text[i] == text[j] then probably you are at the end of two contiguos equal sequences. Let l = j - i, this will be the length of the equal strings, so to check if the condition hold you have to check if text[i - l + 1, i] == text[j - l + 1, j], this is a O(n)  linear check, so we will get TLE because your overall time is (n^3) just checking contiguous equal strings. The insight here is: if text[i - l + 1, i] == text[j - l + 1, j] then text[i] == text[j] && text[i - 1] == text[j - 1] &&  text[i - 2] == text[j - 2] ...  text[i - l + 1] == text[j - l + 1], having this info stored you can just check if mem[i, j] == j - i in O(1), but you can have the following case \"abcabcabc\", so position mem[6, 9] = 6 not 3 as we expected, this is because mem[i, j] has all the info of previous suffixs, so the right condition to check if text[i - l + 1, i] == text[j - l + 1, j] is mem[i, j] >= j - i.\\n2.   Now you have to check the number of differents contiguous strings, inserting text.Substring(i + 1, j - i) into a HashSet every time you have mem[i, j] >= j - i will give you the number of different substrings, unfortunately this will end in tle, because text.Substring method is O(l) be l the substring length, so we will end with a O(n^3) algorithm, to tackle this problem we can use Rolling Hash [https://stackoverflow.com/questions/711770/fast-implementation-of-rolling-hash](http://), this will allow to get rid off the substring method, so our algorithm will end up with a overall time of O(n^2).\\n\\n```\\npublic class Solution {\\n    \\n    const long PRIME_BASE = 29;\\n    const long PRIME_MOD = 1000000007;\\n    \\n    public int DistinctEchoSubstrings(string text) {\\n        int n = text.Length;\\n        int[,] mem = new int[n + 1, n + 1];\\n        for(int i = 1; i < n; ++i)\\n            for(int j = i + 1; j <= n; ++j)\\n                mem[i, j] = text[i - 1] == text[j - 1] ? 1 + mem[i - 1, j - 1] : 0;\\n        \\n        int md = n / 2;\\n        HashSet<long> st = new HashSet<long>();\\n    \\n        long power = 1;\\n        for(int i = 1; i <= md; ++i)\\n        {\\n            long hs = 0;\\n            power = (power * PRIME_BASE) % PRIME_MOD;\\n            for(int j = 1; j <= n; ++j)\\n            {\\n                hs = (hs * PRIME_BASE + text[j - 1] - \\'a\\' + 1) % PRIME_MOD;\\n                \\n                if(j > i)\\n                    hs -= power * (text[j - i - 1] - \\'a\\' + 1) % PRIME_MOD;\\n                \\n                if(hs < 0)\\n                    hs += PRIME_MOD;    \\n                \\n                if(j - i >= 1 && mem[j - i, j] >= i)\\n                    st.Add(hs);\\n            }       \\n        }\\n                    \\n        return st.Count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution {\\n    \\n    const long PRIME_BASE = 29;\\n    const long PRIME_MOD = 1000000007;\\n    \\n    public int DistinctEchoSubstrings(string text) {\\n        int n = text.Length;\\n        int[,] mem = new int[n + 1, n + 1];\\n        for(int i = 1; i < n; ++i)\\n            for(int j = i + 1; j <= n; ++j)\\n                mem[i, j] = text[i - 1] == text[j - 1] ? 1 + mem[i - 1, j - 1] : 0;\\n        \\n        int md = n / 2;\\n        HashSet<long> st = new HashSet<long>();\\n    \\n        long power = 1;\\n        for(int i = 1; i <= md; ++i)\\n        {\\n            long hs = 0;\\n            power = (power * PRIME_BASE) % PRIME_MOD;\\n            for(int j = 1; j <= n; ++j)\\n            {\\n                hs = (hs * PRIME_BASE + text[j - 1] - \\'a\\' + 1) % PRIME_MOD;\\n                \\n                if(j > i)\\n                    hs -= power * (text[j - i - 1] - \\'a\\' + 1) % PRIME_MOD;\\n                \\n                if(hs < 0)\\n                    hs += PRIME_MOD;    \\n                \\n                if(j - i >= 1 && mem[j - i, j] >= i)\\n                    st.Add(hs);\\n            }       \\n        }\\n                    \\n        return st.Count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477418,
                "title": "sha1",
                "content": "Here I use SHA1 hashes. It\\'s O(n<sup>2</sup>) but still horribly slow (accepted in 4164 ms), but maybe still interesting.\\n\\n* First I build hashers for all one-character substrings. Each `hasher[i]` will hash the substrings starting at index `i`.\\n* Then in the loop I compute the digests and use them to find the good substrings (those that are a concatenation of some string with itself). For example for input=\"abcabcabc\" and when I\\'m at length=3, my `hasher[1]` will have hashed `text[1:1+3]`=\"bca\" and my `hasher[4]` will have hashed `text[4:4+3]`=\"bca\". So they have the same digest and I store that digest in a set.\\n* Then pop the last hasher, it\\'s not needed anymore because it has already hashed until the end of the string.\\n* Then update each hasher with their next character for the next higher length.\\n* In the end, return how many different good digests were found.\\n```\\ndef distinctEchoSubstrings(self, text):\\n    import hashlib\\n    hashers = map(hashlib.sha1, text)\\n    good_digests = set()\\n    for length in range(1, len(text) / 2 + 1):\\n        digests = [h.digest() for h in hashers]\\n        for d1, d2 in zip(digests, digests[length:]):\\n            if d1 == d2:\\n                good_digests.add(d1)\\n        hashers.pop()\\n        for hasher, char in zip(hashers, text[length:]):\\n            hasher.update(char)\\n    return len(good_digests)\\n```",
                "solutionTags": [],
                "code": "```\\ndef distinctEchoSubstrings(self, text):\\n    import hashlib\\n    hashers = map(hashlib.sha1, text)\\n    good_digests = set()\\n    for length in range(1, len(text) / 2 + 1):\\n        digests = [h.digest() for h in hashers]\\n        for d1, d2 in zip(digests, digests[length:]):\\n            if d1 == d2:\\n                good_digests.add(d1)\\n        hashers.pop()\\n        for hasher, char in zip(hashers, text[length:]):\\n            hasher.update(char)\\n    return len(good_digests)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 477091,
                "title": "java-hash-set-brute-force",
                "content": "Slightly better than n^3 on average I think\\n```\\n    public static int distinctEchoSubstrings(String text) {\\n        final Set<String> found = new HashSet<>();\\n        final char[] chars = text.toCharArray();\\n        for (int i = 0; i < chars.length; i++) {\\n            for (int j = i + 1; j < text.length(); j++) {\\n                if (chars[i] == chars[j]) {\\n                    if (j + j - i <= text.length()) {\\n                        final String first = text.substring(i, j);\\n                        final String second = text.substring(j, j + j - i);\\n                        if (first.equals(second)) {\\n                            found.add(first + second);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return found.size();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public static int distinctEchoSubstrings(String text) {\\n        final Set<String> found = new HashSet<>();\\n        final char[] chars = text.toCharArray();\\n        for (int i = 0; i < chars.length; i++) {\\n            for (int j = i + 1; j < text.length(); j++) {\\n                if (chars[i] == chars[j]) {\\n                    if (j + j - i <= text.length()) {\\n                        final String first = text.substring(i, j);\\n                        final String second = text.substring(j, j + j - i);\\n                        if (first.equals(second)) {\\n                            found.add(first + second);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return found.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2252342,
                "title": "c-rolling-hash-solution-time-o-n-2-n-log-n-space-o-n-2",
                "content": "```\\nclass Solution {\\npublic:\\n    long long base = 31 , mod = 1011001110001111;\\n    long long prev[2001];\\n    unordered_map<long long,int> mp;\\n    int distinctEchoSubstrings(string s) {\\n         int n = s.size();\\n         for(int i=1; i<=n/2; i++) {\\n               long long hash = 0 , limit = 1;\\n               int l = 0;\\n               for(int k=0; k<n; k++) {\\n                     hash = (( hash * base ) % mod  + (s[k] - \\'a\\' + 1))%mod;\\n                     if(k>=i-1) {\\n                         prev[k]=hash;\\n                         if(k >= 2*i - 1 && prev[k-i]==hash) {\\n                              mp[hash]++;\\n                         }\\n                         hash = (hash - ((s[l] - \\'a\\' + 1)*limit)%mod)%mod;\\n                         if(hash<0) hash+=mod;\\n                         l++;\\n                     }else {\\n                         limit =( limit * base ) % mod;\\n                     }\\n               }\\n         }\\n        return mp.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "String",
                    "Sliding Window",
                    "Rolling Hash"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long base = 31 , mod = 1011001110001111;\\n    long long prev[2001];\\n    unordered_map<long long,int> mp;\\n    int distinctEchoSubstrings(string s) {\\n         int n = s.size();\\n         for(int i=1; i<=n/2; i++) {\\n               long long hash = 0 , limit = 1;\\n               int l = 0;\\n               for(int k=0; k<n; k++) {\\n                     hash = (( hash * base ) % mod  + (s[k] - \\'a\\' + 1))%mod;\\n                     if(k>=i-1) {\\n                         prev[k]=hash;\\n                         if(k >= 2*i - 1 && prev[k-i]==hash) {\\n                              mp[hash]++;\\n                         }\\n                         hash = (hash - ((s[l] - \\'a\\' + 1)*limit)%mod)%mod;\\n                         if(hash<0) hash+=mod;\\n                         l++;\\n                     }else {\\n                         limit =( limit * base ) % mod;\\n                     }\\n               }\\n         }\\n        return mp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2029758,
                "title": "c-kmp-o-n-2",
                "content": "**Idea** from Problem: [459. Repeated Substring Pattern](https://leetcode.com/problems/repeated-substring-pattern/).\\nIf a `s` string is made from another string `t`, such that `s` is formed by concatenating `t` by even no. of times, then we can spilt `s` into 2 equal halves. Try to generate all substring, check the validity of substring and store into MAP.\\n```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string s) {\\n        unordered_map<string,int> mp;\\n        for(int i = 0; i<s.size();++i){\\n            string re;\\n            vector<int> nums = {0}; int l = 0;\\n            for(int j = i+1; j<s.size();++j){\\n                re+=string(1,s[j]);\\n                while(l>0 && s[i+l]!=s[j])  l = nums[l-1];\\n                if(s[l+i]==s[j]) {nums.push_back(l+1); l++;}\\n                else nums.push_back(0);\\n                int p = j-i+1 - nums[nums.size()-1];\\n                if((j-i)%2!=0 && (p && (j-i+1)%p==0 && ((j-i+1)/p)%2==0)) mp[re]++; \\n            }\\n        }\\n        return mp.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string s) {\\n        unordered_map<string,int> mp;\\n        for(int i = 0; i<s.size();++i){\\n            string re;\\n            vector<int> nums = {0}; int l = 0;\\n            for(int j = i+1; j<s.size();++j){\\n                re+=string(1,s[j]);\\n                while(l>0 && s[i+l]!=s[j])  l = nums[l-1];\\n                if(s[l+i]==s[j]) {nums.push_back(l+1); l++;}\\n                else nums.push_back(0);\\n                int p = j-i+1 - nums[nums.size()-1];\\n                if((j-i)%2!=0 && (p && (j-i+1)%p==0 && ((j-i+1)/p)%2==0)) mp[re]++; \\n            }\\n        }\\n        return mp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1627969,
                "title": "c-hash-solution-clean-code-easy-understand",
                "content": "\\tusing ll = long long;\\n\\tconst int MOD = 1e9 + 7;\\n\\tconst int base = 131;\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint p[2005];\\n\\t\\tint hash[2005];\\n\\n\\t\\tint get(int l, int r){\\n\\t\\t\\treturn (hash[r] - 1LL * hash[l] * p[r-l] % MOD + MOD) % MOD;\\n\\t\\t}\\n\\t\\tint distinctEchoSubstrings(string s) {\\n\\t\\t\\tint n = s.length();\\n\\t\\t\\tp[0] = 1;\\n\\t\\t\\thash[0] = 0;\\n\\t\\t\\tfor (int i = 1; i <= n; i++){\\n\\t\\t\\t\\thash[i] = (1LL * hash[i-1] * base + s[i-1] - \\'a\\' + 1) % MOD;\\n\\t\\t\\t\\tp[i] = (1LL * p[i-1] * base) % MOD;\\n\\t\\t\\t}\\n\\t\\t\\t//for (int i = 1; i <= n; i++) cout << hash[i] << \" \";\\n\\t\\t\\tunordered_set<int> st;\\n\\t\\t\\tfor (int i = 0; i < n; i++){\\n\\t\\t\\t\\tfor (int l = 2; i + l <= n; l += 2){\\n\\t\\t\\t\\t\\tint mid = i + l / 2;\\n\\t\\t\\t\\t\\tint a = get(i, mid);\\n\\t\\t\\t\\t\\tint b = get(mid, i + l);\\n\\t\\t\\t\\t\\t//cout << a << \" \" << b << endl;\\n\\t\\t\\t\\t\\tif (a == b) st.insert(a);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn st.size();\\n\\t\\t}\\n\\t};\\n\\n**Complexity**\\n* Time: O(n ^ 2) - n is length of string s;\\n* Space: O(n)",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint p[2005];\\n\\t\\tint hash[2005];\\n\\n\\t\\tint get(int l, int r){\\n\\t\\t\\treturn (hash[r] - 1LL * hash[l] * p[r-l] % MOD + MOD) % MOD;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1278602,
                "title": "java-rolling-hash",
                "content": "```\\nclass Solution {\\n    int count = 0;\\n    int p = 31;\\n    int mod = (int) (1e9+9);\\n    Set<String> set = new HashSet();\\n    public int distinctEchoSubstrings(String text) {\\n        if(text == null || text.isEmpty())\\n            return 0;\\n        for (int len = 1; 2* len <= text.length(); len ++){\\n            count += getEchoSubstring(text, len);\\n        }\\n        return count;\\n    }\\n\\n\\n    private int getEchoSubstring(String str, int len){\\n\\n        int i = 0,j = i+ len;\\n        long power1 = 1, power2 = 1;\\n        long hashVal1 = 0, hashval2 = 0;\\n        Map<Integer, Long> map1 = new HashMap();\\n        Map<Integer, Long> map2 = new HashMap();\\n        int count = 0;\\n\\n        for (; j < str.length(); i++, j++){\\n            if(i >= len){\\n                hashVal1 = (hashVal1 - (str.charAt(i-len)-\\'a\\') * map1.get(i-len)) % mod;\\n                hashval2 = (hashval2 - (str.charAt(j-len)-\\'a\\') * map2.get(j-len)) % mod;\\n            }\\n\\n            map1.put(i, power1);\\n            map2.put(j, power2);\\n            hashVal1 = (hashVal1 + ((str.charAt(i)-\\'a\\'+1) * power1)) % mod;\\n            hashval2 = (hashval2 + ((str.charAt(j)-\\'a\\'+1) * power2)) % mod;\\n            power1 = (power1 * p) % mod;\\n            power2 = (power2 * p) % mod;\\n\\n            if(i >= len-1){\\n                if(hashVal1 == hashval2){\\n                    String ans = str.substring(i+1-len, i+1);\\n                    System.out.println(ans);\\n                    if(!set.contains(ans)){\\n                        set.add(ans);\\n                        ++count;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int count = 0;\\n    int p = 31;\\n    int mod = (int) (1e9+9);\\n    Set<String> set = new HashSet();\\n    public int distinctEchoSubstrings(String text) {\\n        if(text == null || text.isEmpty())\\n            return 0;\\n        for (int len = 1; 2* len <= text.length(); len ++){\\n            count += getEchoSubstring(text, len);\\n        }\\n        return count;\\n    }\\n\\n\\n    private int getEchoSubstring(String str, int len){\\n\\n        int i = 0,j = i+ len;\\n        long power1 = 1, power2 = 1;\\n        long hashVal1 = 0, hashval2 = 0;\\n        Map<Integer, Long> map1 = new HashMap();\\n        Map<Integer, Long> map2 = new HashMap();\\n        int count = 0;\\n\\n        for (; j < str.length(); i++, j++){\\n            if(i >= len){\\n                hashVal1 = (hashVal1 - (str.charAt(i-len)-\\'a\\') * map1.get(i-len)) % mod;\\n                hashval2 = (hashval2 - (str.charAt(j-len)-\\'a\\') * map2.get(j-len)) % mod;\\n            }\\n\\n            map1.put(i, power1);\\n            map2.put(j, power2);\\n            hashVal1 = (hashVal1 + ((str.charAt(i)-\\'a\\'+1) * power1)) % mod;\\n            hashval2 = (hashval2 + ((str.charAt(j)-\\'a\\'+1) * power2)) % mod;\\n            power1 = (power1 * p) % mod;\\n            power2 = (power2 * p) % mod;\\n\\n            if(i >= len-1){\\n                if(hashVal1 == hashval2){\\n                    String ans = str.substring(i+1-len, i+1);\\n                    System.out.println(ans);\\n                    if(!set.contains(ans)){\\n                        set.add(ans);\\n                        ++count;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1161604,
                "title": "using-kmp-a-bit-overkill-though",
                "content": "```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        \\n       int n=text.size(),cnt=0;\\n        \\n        if(n==0)return 0;\\n        \\n        //for hashing\\n        long long hash=0,t=31,pw=1,mod=1e9+7;\\n        unordered_map<int,int>m;\\n        \\n        for(int i=0;i<n;i++)\\n        {   \\n            vector<int>pi(n,i);//prefix array for kmp\\n            pw=1;//resetting pw\\n            hash=text[i]-\\'a\\'+1;//hash\\n            pw=(pw*t)%mod;//hash\\n            for(int j=i+1;j<n;j++)\\n            {      \\n                \\n                int c=text[j]-\\'a\\'+1;//hash\\n                hash=(pw*c%mod+hash)%mod;//hash\\n                pw=(pw*t)%mod;//hash\\n                \\n                //running kmp prefix function\\n                \\n                int p=pi[j-1];\\n                while(p>i&&text[j]!=text[p])\\n                    p=pi[p-1];\\n                if(text[j]==text[p])\\n                    p++;\\n                pi[j]=p;\\n                \\n                \\n                int u=pi[j]-i;//resetting size as i>0\\n                \\n                if((j-i+1)%2==0&&u&&m[hash]==0)\\n                {\\n                    int k=(j-i+1)/2;\\n                    if(k%(j-i+1-u)==0){\\n                        m[hash]++;\\n                        cnt++;\\n                    }\\n                }\\n            }\\n        }\\n        return cnt++;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        \\n       int n=text.size(),cnt=0;\\n        \\n        if(n==0)return 0;\\n        \\n        //for hashing\\n        long long hash=0,t=31,pw=1,mod=1e9+7;\\n        unordered_map<int,int>m;\\n        \\n        for(int i=0;i<n;i++)\\n        {   \\n            vector<int>pi(n,i);//prefix array for kmp\\n            pw=1;//resetting pw\\n            hash=text[i]-\\'a\\'+1;//hash\\n            pw=(pw*t)%mod;//hash\\n            for(int j=i+1;j<n;j++)\\n            {      \\n                \\n                int c=text[j]-\\'a\\'+1;//hash\\n                hash=(pw*c%mod+hash)%mod;//hash\\n                pw=(pw*t)%mod;//hash\\n                \\n                //running kmp prefix function\\n                \\n                int p=pi[j-1];\\n                while(p>i&&text[j]!=text[p])\\n                    p=pi[p-1];\\n                if(text[j]==text[p])\\n                    p++;\\n                pi[j]=p;\\n                \\n                \\n                int u=pi[j]-i;//resetting size as i>0\\n                \\n                if((j-i+1)%2==0&&u&&m[hash]==0)\\n                {\\n                    int k=(j-i+1)/2;\\n                    if(k%(j-i+1-u)==0){\\n                        m[hash]++;\\n                        cnt++;\\n                    }\\n                }\\n            }\\n        }\\n        return cnt++;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 941313,
                "title": "java-o-n-2-time-o-n-space-constant-solution",
                "content": "```\\nclass Solution {\\n    //constant(n) window size scan. use hashmap to map what the next substring should be. clear map after each iteration. O(n) space and O(n^2) time\\n    \\n    public int distinctEchoSubstrings(String text) {\\n        HashMap<Integer, String> distinctMap = new HashMap();\\n        Set<String> answers = new HashSet();\\n        int counter = 0;\\n        for(int n = 1; n < 1+text.length()/2; n++)\\n        {\\n            for(int i = 0; i < text.length()-n+1; i++)\\n            {\\n                String sub = text.substring(i, i+n);\\n                if(distinctMap.containsKey(i) && distinctMap.get(i).equals(sub))\\n                {\\n                    answers.add(sub);\\n                }\\n                distinctMap.put(i+n, sub);\\n            }\\n            counter += answers.size();\\n            answers.clear();\\n            distinctMap.clear();\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //constant(n) window size scan. use hashmap to map what the next substring should be. clear map after each iteration. O(n) space and O(n^2) time\\n    \\n    public int distinctEchoSubstrings(String text) {\\n        HashMap<Integer, String> distinctMap = new HashMap();\\n        Set<String> answers = new HashSet();\\n        int counter = 0;\\n        for(int n = 1; n < 1+text.length()/2; n++)\\n        {\\n            for(int i = 0; i < text.length()-n+1; i++)\\n            {\\n                String sub = text.substring(i, i+n);\\n                if(distinctMap.containsKey(i) && distinctMap.get(i).equals(sub))\\n                {\\n                    answers.add(sub);\\n                }\\n                distinctMap.put(i+n, sub);\\n            }\\n            counter += answers.size();\\n            answers.clear();\\n            distinctMap.clear();\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 790851,
                "title": "cpp14-solution-using-hashing",
                "content": "```\\n#include<bits/stdc++.h>\\nusing namespace std;\\ntypedef long long ll;\\nconst ll p = 31;\\nconst ll mod = 1e9 + 7 ;\\nconst ll maxx = 2005;\\nll has[maxx] , mmi[maxx] ;\\n\\nll exp(ll x , ll y)\\n{\\n    if(y == 0) return 1;\\n    if(y == 1) return x % mod ;\\n    ll t = exp(x , y/2) % mod;\\n    if(y & 1) {\\n        return ((x%mod) * (((t % mod) * (t%mod))%mod))%mod;\\n    }\\n    else return ((t % mod) * (t % mod))%mod;\\n}\\n\\nll findhash(ll i , ll j)\\n{\\n    if(i == 0){\\n        ll foo = has[j] % mod ;\\n        return foo ;\\n    }\\n    else {\\n        ll res = has[j] - has[i-1] ;\\n        res%= mod ;\\n        res*=mmi[i];\\n        res%=mod;\\n        return res;\\n    }\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        string s = \"\" ; \\n        s = text; \\n        ll n = s.length() ;\\n    has[0] = s[0] - \\'a\\' + 1;\\n    ll power = p;\\n    for(ll i = 1 ; i < n ; ++i){\\n        ll foo = s[i] - \\'a\\' + 1;\\n        foo = foo * power;\\n        foo = foo % mod;\\n        power = power * p;\\n        power = power % mod ;\\n        has[i] = has[i-1] + foo ;\\n    }\\n    for(int i = 0 ; i < n ; ++i){\\n        ll a = exp(p,i) % mod ;\\n        ll foo = exp(a , mod - 2) % mod ;\\n        mmi[i] = foo ;\\n    }\\n    ll count = 0 ;\\n    unordered_map<ll,ll> occured;\\n    occured.clear();\\n    for(ll i = 0 ; i < n ; ++i){\\n        for(ll j = 0 ; j < i ; ++j){\\n            ll diff = i - j + 1;\\n            if(diff % 2 == 0 ) {\\n                ll from1 = j , to1 = j + (diff / 2) - 1;\\n                ll from2 = j + (diff/2) , to2 = i ;\\n                ll hash1 = findhash(from1 , to1) ;\\n                ll hash2 = findhash(from2 , to2) ;\\n                if(hash1 == hash2 and !occured[hash1]){\\n                    occured[hash1] = 1;\\n                    ++count;\\n                }\\n            }\\n        }\\n    }\\n    return count ; \\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n#include<bits/stdc++.h>\\nusing namespace std;\\ntypedef long long ll;\\nconst ll p = 31;\\nconst ll mod = 1e9 + 7 ;\\nconst ll maxx = 2005;\\nll has[maxx] , mmi[maxx] ;\\n\\nll exp(ll x , ll y)\\n{\\n    if(y == 0) return 1;\\n    if(y == 1) return x % mod ;\\n    ll t = exp(x , y/2) % mod;\\n    if(y & 1) {\\n        return ((x%mod) * (((t % mod) * (t%mod))%mod))%mod;\\n    }\\n    else return ((t % mod) * (t % mod))%mod;\\n}\\n\\nll findhash(ll i , ll j)\\n{\\n    if(i == 0){\\n        ll foo = has[j] % mod ;\\n        return foo ;\\n    }\\n    else {\\n        ll res = has[j] - has[i-1] ;\\n        res%= mod ;\\n        res*=mmi[i];\\n        res%=mod;\\n        return res;\\n    }\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        string s = \"\" ; \\n        s = text; \\n        ll n = s.length() ;\\n    has[0] = s[0] - \\'a\\' + 1;\\n    ll power = p;\\n    for(ll i = 1 ; i < n ; ++i){\\n        ll foo = s[i] - \\'a\\' + 1;\\n        foo = foo * power;\\n        foo = foo % mod;\\n        power = power * p;\\n        power = power % mod ;\\n        has[i] = has[i-1] + foo ;\\n    }\\n    for(int i = 0 ; i < n ; ++i){\\n        ll a = exp(p,i) % mod ;\\n        ll foo = exp(a , mod - 2) % mod ;\\n        mmi[i] = foo ;\\n    }\\n    ll count = 0 ;\\n    unordered_map<ll,ll> occured;\\n    occured.clear();\\n    for(ll i = 0 ; i < n ; ++i){\\n        for(ll j = 0 ; j < i ; ++j){\\n            ll diff = i - j + 1;\\n            if(diff % 2 == 0 ) {\\n                ll from1 = j , to1 = j + (diff / 2) - 1;\\n                ll from2 = j + (diff/2) , to2 = i ;\\n                ll hash1 = findhash(from1 , to1) ;\\n                ll hash2 = findhash(from2 , to2) ;\\n                if(hash1 == hash2 and !occured[hash1]){\\n                    occured[hash1] = 1;\\n                    ++count;\\n                }\\n            }\\n        }\\n    }\\n    return count ; \\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 752641,
                "title": "my-rolling-hash-solution-in-c",
                "content": "```\\nusing ll=long long int;\\nconst ll mod=1000000009;\\nclass Solution {\\npublic:\\n    ll sum(ll a,ll b)\\n    {\\n        return ((a%mod)+(b%mod))%mod;\\n    }\\n    ll mul(ll a,ll b)\\n    {\\n        return (((a%mod)*(b%mod))%mod);\\n    }\\n    ll sub(ll a,ll b)\\n    {\\n        return (((a%mod)-(b%mod))+mod)%mod;\\n    }\\ninline ll power(ll n,ll x){ll p=1;while(x!=0){if(x%2==0){n=mul(n,n);x=x/2;}p=mul(p,n);x--;}return p;}\\n    ll checkhash(int st,int en)\\n    {\\n        ll a1=sub(hash[en],hash[st-1]);\\n        a1=mul(a1,inv[st-1]);\\n        a1=a1%mod;\\n        return a1;\\n    }\\n    ll p=31;\\n    ll hash[2005];\\n    int po[2005];\\n    int inv[2005];\\n    int distinctEchoSubstrings(string text) {\\n        ll k=1;\\n        po[0]=1;\\n        inv[0]=power(po[0],mod-2);\\n        for(int i=1;i<=2001;i++)\\n        {\\n            k=mul(k,p);\\n            po[i]=k;\\n            inv[i]=power(po[i],mod-2);\\n        } \\n        hash[0]=0;\\n        ll z=1;\\n        int n=text.length();\\n    for(int i=1;i<=n;i++)\\n    {\\n        hash[i]=sum(hash[i-1],mul((text[i-1]-\\'a\\')+1,z));\\n        z=mul(z,p);\\n    }\\n        int ans=0;\\n        unordered_map<ll,ll>mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j+=2)\\n            {\\n                ll h1=checkhash(i+1,(j+i)/2+1);\\n                ll h2=checkhash((j+i)/2+2,j+1);\\n                if(h1==h2 && mp[h1]==0)\\n                {\\n                    ans++;\\n                    mp[h1]=1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nusing ll=long long int;\\nconst ll mod=1000000009;\\nclass Solution {\\npublic:\\n    ll sum(ll a,ll b)\\n    {\\n        return ((a%mod)+(b%mod))%mod;\\n    }\\n    ll mul(ll a,ll b)\\n    {\\n        return (((a%mod)*(b%mod))%mod);\\n    }\\n    ll sub(ll a,ll b)\\n    {\\n        return (((a%mod)-(b%mod))+mod)%mod;\\n    }\\ninline ll power(ll n,ll x){ll p=1;while(x!=0){if(x%2==0){n=mul(n,n);x=x/2;}p=mul(p,n);x--;}return p;}\\n    ll checkhash(int st,int en)\\n    {\\n        ll a1=sub(hash[en],hash[st-1]);\\n        a1=mul(a1,inv[st-1]);\\n        a1=a1%mod;\\n        return a1;\\n    }\\n    ll p=31;\\n    ll hash[2005];\\n    int po[2005];\\n    int inv[2005];\\n    int distinctEchoSubstrings(string text) {\\n        ll k=1;\\n        po[0]=1;\\n        inv[0]=power(po[0],mod-2);\\n        for(int i=1;i<=2001;i++)\\n        {\\n            k=mul(k,p);\\n            po[i]=k;\\n            inv[i]=power(po[i],mod-2);\\n        } \\n        hash[0]=0;\\n        ll z=1;\\n        int n=text.length();\\n    for(int i=1;i<=n;i++)\\n    {\\n        hash[i]=sum(hash[i-1],mul((text[i-1]-\\'a\\')+1,z));\\n        z=mul(z,p);\\n    }\\n        int ans=0;\\n        unordered_map<ll,ll>mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j+=2)\\n            {\\n                ll h1=checkhash(i+1,(j+i)/2+1);\\n                ll h2=checkhash((j+i)/2+2,j+1);\\n                if(h1==h2 && mp[h1]==0)\\n                {\\n                    ans++;\\n                    mp[h1]=1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 688691,
                "title": "python3-rolling-hash",
                "content": "How to calculate hash with rare probability of collision -\\nThere are multiple ways to do so, but I have used simplest one ->\\n\\nFor string ab ->\\nWe have \\na=> 0 * 128 + ord(\"a\") => 0 * 128 + 97 => 97\\nab => ans of a * 128 + ord(\"b\") => 97 * 128 + 98 => 12514\\nAs this number can become very large we can use a large prime to take modulo, I have taken 10^9 + 7. \\nThe reason I have chose 128 as multiplier is for the fact that the total ascii values can be 128. But we can choose other numbers as well.\\nThere are chances that these hashes can collide, but the chances of that are rare and doesn\\'t occur in the problem.\\n```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        mod = 1_000_000_007\\n        # Dict for storing hashes for all substrings\\n        hashed = {}\\n        for i in range(len(text)):\\n            sm = 0\\n            for j in range(i, len(text)):\\n                sm = (sm*128 + ord(text[j]))%mod\\n                hashed[(i, j)] = sm\\n        \\n        ans = 0\\n        st = {}\\n        for i in range(len(text)):\\n            for j in range(i+1, len(text), 2):\\n                # For each even length substring check if hash of first half\\n                # matches the hash of second half\\n                # Also check if the full string already exists as stored map\\n                if hashed[(i, i-1+(j + 1 - i)//2)] == hashed[(i+(j + 1 - i)//2, j)]:\\n                    if hashed[(i, j)] not in st:\\n                        ans += 1\\n                        st[hashed[(i,j)]] = 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        mod = 1_000_000_007\\n        # Dict for storing hashes for all substrings\\n        hashed = {}\\n        for i in range(len(text)):\\n            sm = 0\\n            for j in range(i, len(text)):\\n                sm = (sm*128 + ord(text[j]))%mod\\n                hashed[(i, j)] = sm\\n        \\n        ans = 0\\n        st = {}\\n        for i in range(len(text)):\\n            for j in range(i+1, len(text), 2):\\n                # For each even length substring check if hash of first half\\n                # matches the hash of second half\\n                # Also check if the full string already exists as stored map\\n                if hashed[(i, i-1+(j + 1 - i)//2)] == hashed[(i+(j + 1 - i)//2, j)]:\\n                    if hashed[(i, j)] not in st:\\n                        ans += 1\\n                        st[hashed[(i,j)]] = 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 541627,
                "title": "c-beginner-friendly-rolling-hash",
                "content": "```\\n#define mod (long)(1e9+7)\\n\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        int n = text.size();\\n        long hash[n][n];\\n        \\n        unordered_map<long,int>mp;\\n        for(int i=0;i<n;i++){\\n            long pow = 117;\\n            hash[i][i] = pow*(text[i]-\\'a\\' + 1);\\n            for(int j=i+1;j<n;j++){\\n                pow = pow*117;\\n                pow %= mod;\\n                \\n                long ch = text[j]-\\'a\\'+1;\\n                \\n                hash[i][j] = hash[i][j-1] + pow*ch;\\n                hash[i][j] %= mod;\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++){\\n                int len = j-i+1;\\n                \\n                if(j+len >=n)\\n                    continue;\\n                \\n                if(hash[i][j] == hash[j+1][j+len]){\\n                    if(mp[hash[i][j]] == 0)\\n                    ans++;\\n                    \\n                    mp[hash[i][j]] = 1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        int n = text.size();\\n        long hash[n][n];\\n        \\n        unordered_map<long,int>mp;\\n        for(int i=0;i<n;i++){\\n            long pow = 117;\\n            hash[i][i] = pow*(text[i]-\\'a\\' + 1);\\n            for(int j=i+1;j<n;j++){\\n                pow = pow*117;\\n                pow %= mod;\\n                \\n                long ch = text[j]-\\'a\\'+1;\\n                \\n                hash[i][j] = hash[i][j-1] + pow*ch;\\n                hash[i][j] %= mod;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 538841,
                "title": "c-rolling-hash-solution",
                "content": "```\\n    int distinctEchoSubstrings(string txt) {\\n        long mod = 1e10 + 7, d = 26, base = 1;\\n        \\n        auto getCode = [](char c) {\\n            return c-\\'a\\'+1;\\n        };\\n        \\n        auto getHash = [&](string & s, int l, int h) {\\n            long res = 0;\\n            for(int i = l; i <= h; i++) res = (res*d + getCode(s[i]))%mod;\\n            return res;\\n        };\\n        \\n        auto updateHash = [&](long h, char pre, char cur) {\\n            return ((h*d-getCode(pre)*base)%mod + mod + getCode(cur))%mod;\\n        };\\n        \\n        \\n        unordered_set<int> res;\\n        for(int l = 1; l + l <= txt.length(); l++) {\\n            base *= 26, base %= mod;\\n            \\n            int idx = 0;\\n            long h1 = getHash(txt, idx, idx + l-1);\\n            long h2 = getHash(txt, idx + l, idx + l+ l-1);\\n            if(h1 == h2 && !res.count(h1)) res.insert(h1);\\n            \\n            while(idx + l + l < txt.length()) {\\n                h1 = updateHash(h1, txt[idx], txt[idx+l]);\\n                h2 = updateHash(h2, txt[idx+l], txt[idx+l+l]);\\n                if(h1 == h2 && !res.count(h1)) res.insert(h1);\\n                idx++;\\n            }\\n        }\\n        return res.size();\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    int distinctEchoSubstrings(string txt) {\\n        long mod = 1e10 + 7, d = 26, base = 1;\\n        \\n        auto getCode = [](char c) {\\n            return c-\\'a\\'+1;\\n        };\\n        \\n        auto getHash = [&](string & s, int l, int h) {\\n            long res = 0;\\n            for(int i = l; i <= h; i++) res = (res*d + getCode(s[i]))%mod;\\n            return res;\\n        };\\n        \\n        auto updateHash = [&](long h, char pre, char cur) {\\n            return ((h*d-getCode(pre)*base)%mod + mod + getCode(cur))%mod;\\n        };\\n        \\n        \\n        unordered_set<int> res;\\n        for(int l = 1; l + l <= txt.length(); l++) {\\n            base *= 26, base %= mod;\\n            \\n            int idx = 0;\\n            long h1 = getHash(txt, idx, idx + l-1);\\n            long h2 = getHash(txt, idx + l, idx + l+ l-1);\\n            if(h1 == h2 && !res.count(h1)) res.insert(h1);\\n            \\n            while(idx + l + l < txt.length()) {\\n                h1 = updateHash(h1, txt[idx], txt[idx+l]);\\n                h2 = updateHash(h2, txt[idx+l], txt[idx+l+l]);\\n                if(h1 == h2 && !res.count(h1)) res.insert(h1);\\n                idx++;\\n            }\\n        }\\n        return res.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 483328,
                "title": "python-one-line-code",
                "content": "```\\nimport re\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        return len(set(re.findall(r\\'(?=([a-z]+)\\\\1)\\', text)))\\n```",
                "solutionTags": [],
                "code": "```\\nimport re\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        return len(set(re.findall(r\\'(?=([a-z]+)\\\\1)\\', text)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 478435,
                "title": "o-n-2-slide-window-java-solution",
                "content": "```\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        int len = text.length(), result = 0;\\n        char[] s = text.toCharArray();\\n        HashSet<String> set = new HashSet<>();\\n        \\n        // Echo String echo = A + A\\n        for (int w = 1; w <= len / 2; w++) {    // w is A\\'s length\\n            int start1 = 0, start2 = w, end1 = 0, end2 = w;\\n            StringBuilder sb = new StringBuilder(); // store current A\\n            while (end2 < len) {\\n                sb.append(s[end2]);\\n                if (s[end2] == s[end1]) {\\n                    if (end2 - start2 > w - 1) {    // move start point\\n                        start1++;\\n                        start2++;\\n                        sb.deleteCharAt(0);\\n                    }\\n                    if (end2 - start2 == w - 1 && set.add(sb.toString())) {\\n                        result++;\\n                    }\\n                } else {\\n                    start1 = end1 + 1;\\n                    start2 = end2 + 1;\\n                    sb = new StringBuilder();\\n                }\\n                \\n                end1++;\\n                end2++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        int len = text.length(), result = 0;\\n        char[] s = text.toCharArray();\\n        HashSet<String> set = new HashSet<>();\\n        \\n        // Echo String echo = A + A\\n        for (int w = 1; w <= len / 2; w++) {    // w is A\\'s length\\n            int start1 = 0, start2 = w, end1 = 0, end2 = w;\\n            StringBuilder sb = new StringBuilder(); // store current A\\n            while (end2 < len) {\\n                sb.append(s[end2]);\\n                if (s[end2] == s[end1]) {\\n                    if (end2 - start2 > w - 1) {    // move start point\\n                        start1++;\\n                        start2++;\\n                        sb.deleteCharAt(0);\\n                    }\\n                    if (end2 - start2 == w - 1 && set.add(sb.toString())) {\\n                        result++;\\n                    }\\n                } else {\\n                    start1 = end1 + 1;\\n                    start2 = end2 + 1;\\n                    sb = new StringBuilder();\\n                }\\n                \\n                end1++;\\n                end2++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477935,
                "title": "python-hash-1068ms",
                "content": "```python\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        res = set()\\n        ix = {}\\n        for i, c in enumerate(text):\\n            if c in ix:\\n                for j in ix[c][::-1]:\\n                    if i + i - j > len(text): break # Early stopping \\n                    if text[j:i] == text[i:i+i-j]:\\n                        res.add(text[j:i+i-j])\\n                ix[c].append(i)\\n            else:\\n                ix[c] = [i]\\n        return len(res) \\n```\\nThis is the best method I can think of, but it is still O(n^3). Any idea on improving this method is welcome. \\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        res = set()\\n        ix = {}\\n        for i, c in enumerate(text):\\n            if c in ix:\\n                for j in ix[c][::-1]:\\n                    if i + i - j > len(text): break # Early stopping \\n                    if text[j:i] == text[i:i+i-j]:\\n                        res.add(text[j:i+i-j])\\n                ix[c].append(i)\\n            else:\\n                ix[c] = [i]\\n        return len(res) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 477559,
                "title": "why-n-3-solution-tle-in-c-but-accepted-by-other-languages",
                "content": "It is not fair as a contest question.\\n\\n```\\npublic class Solution {\\n    public int DistinctEchoSubstrings(string text) {\\n        HashSet<string> set = new HashSet<string>();\\n        int n = text.Length;\\n        for (int i = 0; i < n; i++) {\\n            for (int len = 2; i + len <= n; len += 2) {\\n                int mid = i + len / 2;\\n                string subStr1 = text.Substring(i, mid-i);\\n                string subStr2 = text.Substring(mid, i + len - mid);\\n                if (subStr1.Equals(subStr2)) \\n                    set.Add(subStr1);\\n            }\\n        }\\n        return set.Count;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int DistinctEchoSubstrings(string text) {\\n        HashSet<string> set = new HashSet<string>();\\n        int n = text.Length;\\n        for (int i = 0; i < n; i++) {\\n            for (int len = 2; i + len <= n; len += 2) {\\n                int mid = i + len / 2;\\n                string subStr1 = text.Substring(i, mid-i);\\n                string subStr2 = text.Substring(mid, i + len - mid);\\n                if (subStr1.Equals(subStr2)) \\n                    set.Add(subStr1);\\n            }\\n        }\\n        return set.Count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477486,
                "title": "24ms-kmp-based-solution-c-with-pruning",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_set<string> sstr;\\n    int kmp(string& t,int l)\\n    {\\n        vector<int> f(t.length()-l,0);\\n        int len = f.size();\\n        auto s = &t[l];\\n        int pos = 0;\\n        for(int i = 1; i<len; i++)\\n        {\\n            while(pos>0&&s[i]!=s[pos]) pos = f[pos-1];\\n            if(s[i]==s[pos])        pos++;\\n            f[i] = pos;\\n            if(pos&&((i+1)%(i+1-pos)==0)){\\n                if(((i+1)/(i+1-pos))%2==0)  sstr.insert(t.substr(l,(i+1)/2));\\n            }\\n        }\\n        return (f[len-1]&&(len%(len-f[len-1])==0))?(len-f[len-1]):INT_MAX;\\n    }\\n    \\n    int distinctEchoSubstrings(string text) {\\n        int l = text.length()-1;\\n        for(int i = 0; i<=l; i++)   l = min(l,kmp(text,i));\\n        return sstr.size();\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    unordered_set<string> sstr;\\n    int kmp(string& t,int l)\\n    {\\n        vector<int> f(t.length()-l,0);\\n        int len = f.size();\\n        auto s = &t[l];\\n        int pos = 0;\\n        for(int i = 1; i<len; i++)\\n        {\\n            while(pos>0&&s[i]!=s[pos]) pos = f[pos-1];\\n            if(s[i]==s[pos])        pos++;\\n            f[i] = pos;\\n            if(pos&&((i+1)%(i+1-pos)==0)){\\n                if(((i+1)/(i+1-pos))%2==0)  sstr.insert(t.substr(l,(i+1)/2));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 477252,
                "title": "concise-rolling-hash-dp-c",
                "content": "First of all, I didn\\'t like the hardship it took me to make the soultion overcome the time limitation despite having roughly same time complexity.\\n\\n**Intuition:**\\n* Compute rolling hash of each substring. \\n* Then compare the hash of adjacent strings\\n\\t* If hashes match then compare character by character.\\n\\n**Implementation details:**\\n* Used a 2D table to store rolling hash where `Hash[i][l]` stores the rolling hash of substring starting at `i` with length `l`\\n* Compute `Hash[i][l]` from `Hash[i][l-1]` by adding current character\\n\\n**Code:**\\n```\\nint distinctEchoSubstrings(string text) {\\n\\tint N = text.size();\\n\\tint Mod = 1000000007;\\n\\tunordered_set<string> distinct;\\n\\n\\t/* Hash[i][l] = rolling hash of substring starting at i with length l */\\n\\tvector<vector<int>> Hash(N, vector<int>(N+1, 0));\\n\\n\\tfor(int l = 1; l <= N ; ++l) {\\n\\t\\tfor(int i = 0 ; i + l <= N ; ++i) {\\n\\t\\t\\t/* Build Hash[i][l] on Hash[i][l-1] and current character. */\\n\\t\\t\\tHash[i][l] = (Hash[i][l-1] + text[i + l - 1]) % Mod;\\n\\n\\t\\t\\t/* Now check if previous adjacent substring of same length matches */\\n\\t\\t\\tif(i >= l && Hash[i-l][l] == Hash[i][l]) { //Hash matches\\n\\t\\t\\t\\tstring sub = text.substr(i, l);\\n\\n\\t\\t\\t\\t/* Now check if not found and actual character by character match */\\n\\t\\t\\t\\tif(distinct.find(sub) == distinct.end() && sub == text.substr(i - l, l)) {\\n\\t\\t\\t\\t\\tdistinct.emplace(sub);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn distinct.size();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint distinctEchoSubstrings(string text) {\\n\\tint N = text.size();\\n\\tint Mod = 1000000007;\\n\\tunordered_set<string> distinct;\\n\\n\\t/* Hash[i][l] = rolling hash of substring starting at i with length l */\\n\\tvector<vector<int>> Hash(N, vector<int>(N+1, 0));\\n\\n\\tfor(int l = 1; l <= N ; ++l) {\\n\\t\\tfor(int i = 0 ; i + l <= N ; ++i) {\\n\\t\\t\\t/* Build Hash[i][l] on Hash[i][l-1] and current character. */\\n\\t\\t\\tHash[i][l] = (Hash[i][l-1] + text[i + l - 1]) % Mod;\\n\\n\\t\\t\\t/* Now check if previous adjacent substring of same length matches */\\n\\t\\t\\tif(i >= l && Hash[i-l][l] == Hash[i][l]) { //Hash matches\\n\\t\\t\\t\\tstring sub = text.substr(i, l);\\n\\n\\t\\t\\t\\t/* Now check if not found and actual character by character match */\\n\\t\\t\\t\\tif(distinct.find(sub) == distinct.end() && sub == text.substr(i - l, l)) {\\n\\t\\t\\t\\t\\tdistinct.emplace(sub);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn distinct.size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 477137,
                "title": "another-java-solution",
                "content": "```\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        char[] word = text.toCharArray();\\n        Set<String> result = new HashSet<>();\\n        \\n        for (int L = 0; L < word.length - 1; L++) {\\n            for (int R = L + 1; R < word.length; R++) {\\n                if (isConCat(L, R, word)) {\\n                    String candidate = text.substring(L, R + 1);\\n                    result.add(candidate);\\n                }    \\n            }\\n        }\\n        return result.size();\\n    }\\n    \\n    private boolean isConCat(int l, int r, char[] word) {\\n        if ((r - l) % 2 == 0) return false;\\n        \\n        int mid = l + (r - l) / 2 + 1;\\n        \\n        while (mid <= r) {\\n            if (word[l] != word[mid]) {\\n                return false;\\n            }\\n            mid++;\\n            l++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        char[] word = text.toCharArray();\\n        Set<String> result = new HashSet<>();\\n        \\n        for (int L = 0; L < word.length - 1; L++) {\\n            for (int R = L + 1; R < word.length; R++) {\\n                if (isConCat(L, R, word)) {\\n                    String candidate = text.substring(L, R + 1);\\n                    result.add(candidate);\\n                }    \\n            }\\n        }\\n        return result.size();\\n    }\\n    \\n    private boolean isConCat(int l, int r, char[] word) {\\n        if ((r - l) % 2 == 0) return false;\\n        \\n        int mid = l + (r - l) / 2 + 1;\\n        \\n        while (mid <= r) {\\n            if (word[l] != word[mid]) {\\n                return false;\\n            }\\n            mid++;\\n            l++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477117,
                "title": "java-rolling-hash-and-tire-solutions-trie-get-tle",
                "content": "Rolling hash got passed. Worst case would be O(n ^ 3) because we need to compare two strings to prevent collision even if they have the same hashcode.\\n```\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        int n = text.length(); \\n        long mod = 1000000007;\\n        long[] hash = new long[n + 1];\\n        long[] pow = new long[n + 1];\\n        pow[0] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            hash[i] = (hash[i - 1] * 26 + text.charAt(i - 1) - \\'a\\') % mod;\\n            pow[i] = (pow[i - 1] * 26) % mod;\\n        }\\n        \\n        int res = 0;\\n        for (int j = 2; j <= n; j += 2) {\\n            Set<String> set = new HashSet<>();\\n            for (int i = 0; i + j <= n; i ++) {\\n                //[i, i + j/2 - 1], [i + j/2, i + j - 1]\\n                int a = i, b = i + j / 2 - 1, c = i + j / 2, d = i + j - 1;\\n                long hash1 = (hash[b + 1] + mod - hash[a] * pow[b - a + 1] % mod) % mod;\\n                long hash2 = (hash[d + 1] + mod - hash[c] * pow[d - c + 1] % mod) % mod;\\n                if (hash1 == hash2 && text.substring(a, b + 1).equals(text.substring(c, d + 1))) {\\n                    set.add(text.substring(a, b + 1));\\n                } \\n            }\\n            res += set.size();\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n\\nTrie solution. Worst case O(n ^ 2). Don\\'t know why it gets TLE.\\n```\\nclass Trie {\\n    boolean counted;\\n    Set<Integer> end;\\n    Trie[] child;\\n    public Trie() {\\n        counted = false;\\n        end = new HashSet<>();\\n        child = new Trie[26];\\n    }\\n}\\n\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        char[] arr = text.toCharArray();\\n        int n = text.length(), res = 0;\\n        Trie root = new Trie();\\n        for (int i = 0; i < n; i++) {\\n            Trie p = root;\\n            for (int j = i; j < n && (j - i + 1) <= n / 2; j++) {\\n                if (p.child[arr[j] - \\'a\\'] == null) p.child[arr[j] - \\'a\\'] = new Trie();\\n                p = p.child[arr[j] - \\'a\\'];\\n                if (!p.counted && p.end.contains(i - 1)) {\\n                    res++;\\n                    p.counted = true;\\n                }\\n                p.end.add(j);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        int n = text.length(); \\n        long mod = 1000000007;\\n        long[] hash = new long[n + 1];\\n        long[] pow = new long[n + 1];\\n        pow[0] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            hash[i] = (hash[i - 1] * 26 + text.charAt(i - 1) - \\'a\\') % mod;\\n            pow[i] = (pow[i - 1] * 26) % mod;\\n        }\\n        \\n        int res = 0;\\n        for (int j = 2; j <= n; j += 2) {\\n            Set<String> set = new HashSet<>();\\n            for (int i = 0; i + j <= n; i ++) {\\n                //[i, i + j/2 - 1], [i + j/2, i + j - 1]\\n                int a = i, b = i + j / 2 - 1, c = i + j / 2, d = i + j - 1;\\n                long hash1 = (hash[b + 1] + mod - hash[a] * pow[b - a + 1] % mod) % mod;\\n                long hash2 = (hash[d + 1] + mod - hash[c] * pow[d - c + 1] % mod) % mod;\\n                if (hash1 == hash2 && text.substring(a, b + 1).equals(text.substring(c, d + 1))) {\\n                    set.add(text.substring(a, b + 1));\\n                } \\n            }\\n            res += set.size();\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Trie {\\n    boolean counted;\\n    Set<Integer> end;\\n    Trie[] child;\\n    public Trie() {\\n        counted = false;\\n        end = new HashSet<>();\\n        child = new Trie[26];\\n    }\\n}\\n\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        char[] arr = text.toCharArray();\\n        int n = text.length(), res = 0;\\n        Trie root = new Trie();\\n        for (int i = 0; i < n; i++) {\\n            Trie p = root;\\n            for (int j = i; j < n && (j - i + 1) <= n / 2; j++) {\\n                if (p.child[arr[j] - \\'a\\'] == null) p.child[arr[j] - \\'a\\'] = new Trie();\\n                p = p.child[arr[j] - \\'a\\'];\\n                if (!p.counted && p.end.contains(i - 1)) {\\n                    res++;\\n                    p.counted = true;\\n                }\\n                p.end.add(j);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477100,
                "title": "python-rolling-hash",
                "content": "```python\\ndef distinctEchoSubstrings(text: str) -> int:\\n\\tn = len(text)\\n\\tk, q = 26, 2**26 - 1   # rolling hash parameters\\n\\ttab = [0] * n\\n\\tout = 0\\n\\tfor m in range(1, n // 2 + 1):\\n\\t\\tfor i in range(n - m + 1):\\n\\t\\t\\ttab[i] = (tab[i] * k + ord(text[i + m - 1]) - ord(\\'a\\')) % q\\n\\t\\tseen = set()\\n\\t\\tfor i in range(n - m + 1 - m):\\n\\t\\t\\tif tab[i] == tab[i + m] and text[i:i + m] == text[i + m:i + m * 2]:\\n\\t\\t\\t\\tif text[i:i + m] not in seen:\\n\\t\\t\\t\\t\\tseen.add(text[i:i + m])\\n\\t\\t\\t\\t\\tout += 1\\n\\treturn out\\n```",
                "solutionTags": [],
                "code": "```python\\ndef distinctEchoSubstrings(text: str) -> int:\\n\\tn = len(text)\\n\\tk, q = 26, 2**26 - 1   # rolling hash parameters\\n\\ttab = [0] * n\\n\\tout = 0\\n\\tfor m in range(1, n // 2 + 1):\\n\\t\\tfor i in range(n - m + 1):\\n\\t\\t\\ttab[i] = (tab[i] * k + ord(text[i + m - 1]) - ord(\\'a\\')) % q\\n\\t\\tseen = set()\\n\\t\\tfor i in range(n - m + 1 - m):\\n\\t\\t\\tif tab[i] == tab[i + m] and text[i:i + m] == text[i + m:i + m * 2]:\\n\\t\\t\\t\\tif text[i:i + m] not in seen:\\n\\t\\t\\t\\t\\tseen.add(text[i:i + m])\\n\\t\\t\\t\\t\\tout += 1\\n\\treturn out\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 477039,
                "title": "c-sliding-window-set",
                "content": "```\\nint distinctEchoSubstrings(string text) {\\n      set<string> ans;\\n      int l=0,prev=0;\\n      while (l<text.size()-1) {\\n        int start=l+1;\\n        while(start-l<=(text.size()-start)) {\\n          while(start<text.size() and text[start]!=text[l]) {\\n              start++;\\n          }\\n          if (start<text.size()) {\\n            int len=start-l;\\n            string s1=text.substr(l,len),s2=text.substr(start,len);\\n            if (s1==s2) ans.insert(s1);\\n            start++;\\n          }\\n       }\\n       l++;\\n      }\\n      return ans.size();\\n   }\\n   ```",
                "solutionTags": [],
                "code": "```\\nint distinctEchoSubstrings(string text) {\\n      set<string> ans;\\n      int l=0,prev=0;\\n      while (l<text.size()-1) {\\n        int start=l+1;\\n        while(start-l<=(text.size()-start)) {\\n          while(start<text.size() and text[start]!=text[l]) {\\n              start++;\\n          }\\n          if (start<text.size()) {\\n            int len=start-l;\\n            string s1=text.substr(l,len),s2=text.substr(start,len);\\n            if (s1==s2) ans.insert(s1);\\n            start++;\\n          }\\n       }\\n       l++;\\n      }\\n      return ans.size();\\n   }\\n   ```",
                "codeTag": "Unknown"
            },
            {
                "id": 4086725,
                "title": "dart",
                "content": "# Code\\n```\\nimport \\'dart:collection\\';\\n\\nclass Solution {\\n  int distinctEchoSubstrings(String text) {\\n    final int N = text.length;\\n    final memo = List.generate(N, (_) => List.filled(N, 0));\\n    for (int j = N - 1; j >= 0; j--)\\n      for (int i = j - 1; i >= 0; i--)\\n        if (text[i] == text[j])\\n          memo[i][j] = j + 1 == N ? 1 : 1 + memo[i + 1][j + 1];\\n    final db = HashSet<String>();\\n    \\n    for (int i = 0; i < text.length; i++) {\\n      for (int j = i + 1; j < text.length; j++) {\\n        if (memo[i][j] >= j - i)\\n          db.add(text.substring(i, j));\\n      }\\n    }\\n    return db.length;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nimport \\'dart:collection\\';\\n\\nclass Solution {\\n  int distinctEchoSubstrings(String text) {\\n    final int N = text.length;\\n    final memo = List.generate(N, (_) => List.filled(N, 0));\\n    for (int j = N - 1; j >= 0; j--)\\n      for (int i = j - 1; i >= 0; i--)\\n        if (text[i] == text[j])\\n          memo[i][j] = j + 1 == N ? 1 : 1 + memo[i + 1][j + 1];\\n    final db = HashSet<String>();\\n    \\n    for (int i = 0; i < text.length; i++) {\\n      for (int j = i + 1; j < text.length; j++) {\\n        if (memo[i][j] >= j - i)\\n          db.add(text.substring(i, j));\\n      }\\n    }\\n    return db.length;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960267,
                "title": "simple-python-code-1231ms",
                "content": "# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\nbeats ~ 70%\\n\\n- Space complexity:\\n$$O(n)$$\\nbeats ~ 31%\\n\\n# Code\\n```\\nimport math\\nclass Solution:\\n    def distinctEchoSubstrings(self, text) :\\n        n = len(text)\\n        m = 0\\n        max_n = math.floor(n/2)\\n        substrs = set()\\n        for i in range(1, max_n+1) :\\n            for j in range(n-i-m) :\\n                substr = text[j:j+2*i]\\n                if substr[0:i] == substr[i:] :\\n                    substrs.add(substr)\\n            m += 1\\n        return len(substrs)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def distinctEchoSubstrings(self, text) :\\n        n = len(text)\\n        m = 0\\n        max_n = math.floor(n/2)\\n        substrs = set()\\n        for i in range(1, max_n+1) :\\n            for j in range(n-i-m) :\\n                substr = text[j:j+2*i]\\n                if substr[0:i] == substr[i:] :\\n                    substrs.add(substr)\\n            m += 1\\n        return len(substrs)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956320,
                "title": "python3-rolling-hash-o-n-2-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        text_arr = [ord(val)-97 for val in text]\\n        hash_map = {}\\n        pow_arr = [1]\\n        for i in range(1,len(text)+1):\\n            pow_arr.append(pow_arr[i-1]*26)\\n            \\n\\n        for substr_len in range(1,len(text_arr)//2 + 1):\\n            cur_hash = 0\\n            for k in range(0,substr_len):\\n                cur_hash = cur_hash*26+text_arr[k]\\n            hash_map[(0,substr_len)] = cur_hash\\n            for start_ind in range(1,len(text_arr)-substr_len+1):\\n                cur_hash -= text_arr[start_ind-1]*pow_arr[substr_len-1]\\n                cur_hash = cur_hash*26 + text_arr[start_ind+substr_len-1]\\n                hash_map[(start_ind, start_ind+substr_len)] = cur_hash\\n\\n\\n        substr_set = set()\\n        for pair in hash_map:\\n                first_pair = pair\\n                second_pair = (pair[1],pair[1]+(first_pair[1]-first_pair[0]))\\n                if first_pair in hash_map and second_pair in hash_map and hash_map[first_pair] == hash_map[second_pair]:\\n                    substr_set.add((first_pair[1]-first_pair[0], hash_map[first_pair]))\\n                    \\n        return len(substr_set)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        text_arr = [ord(val)-97 for val in text]\\n        hash_map = {}\\n        pow_arr = [1]\\n        for i in range(1,len(text)+1):\\n            pow_arr.append(pow_arr[i-1]*26)\\n            \\n\\n        for substr_len in range(1,len(text_arr)//2 + 1):\\n            cur_hash = 0\\n            for k in range(0,substr_len):\\n                cur_hash = cur_hash*26+text_arr[k]\\n            hash_map[(0,substr_len)] = cur_hash\\n            for start_ind in range(1,len(text_arr)-substr_len+1):\\n                cur_hash -= text_arr[start_ind-1]*pow_arr[substr_len-1]\\n                cur_hash = cur_hash*26 + text_arr[start_ind+substr_len-1]\\n                hash_map[(start_ind, start_ind+substr_len)] = cur_hash\\n\\n\\n        substr_set = set()\\n        for pair in hash_map:\\n                first_pair = pair\\n                second_pair = (pair[1],pair[1]+(first_pair[1]-first_pair[0]))\\n                if first_pair in hash_map and second_pair in hash_map and hash_map[first_pair] == hash_map[second_pair]:\\n                    substr_set.add((first_pair[1]-first_pair[0], hash_map[first_pair]))\\n                    \\n        return len(substr_set)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915472,
                "title": "my-attempt-towards-an-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhenever there exists a substring that meets the condition, the leading char in the second half must have been seen previously.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs we traverse the text char by char, recall where the same char exists before, and check if the suffix starting from those two positions matches.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nBest scenario: Not much duplicates (abcdefghij) -> O(n)\\nWorst scenario: Too many duplicates (aaaaaaaaaa) -> O(n**2/2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        seenCharAt = defaultdict(list)\\n        res = set()\\n        for i, char in enumerate(text):\\n            if char in seenCharAt:\\n                for prevPos in seenCharAt[char]:\\n                    suffixLen = i - prevPos\\n                    if text[prevPos:i] == text[i:i+suffixLen]:\\n                        res.add(text[prevPos:i+suffixLen])\\n            seenCharAt[char].append(i)\\n        return len(res)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        seenCharAt = defaultdict(list)\\n        res = set()\\n        for i, char in enumerate(text):\\n            if char in seenCharAt:\\n                for prevPos in seenCharAt[char]:\\n                    suffixLen = i - prevPos\\n                    if text[prevPos:i] == text[i:i+suffixLen]:\\n                        res.add(text[prevPos:i+suffixLen])\\n            seenCharAt[char].append(i)\\n        return len(res)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766168,
                "title": "python-beats-100-in-memory-and-runtime-string-hashing-with-pointer-crawlers",
                "content": "# Intuition\\nIn order to cut down runtime, we must decrease the number of comparisons needed to find new echos. I realized that for an echo made  with 2 substring of length l, at indexes [i; i + 2l], we can easily determine that the substring at [i + 1; i + 21 + 1] is an echo if arr[i + l + 1] = arr[i + 2l + 1].\\n\\nFor example: \\n\"appleapplea\"\\nOnce we find that \"appleapple\" is an echo, we can know that \"ppleapplea\" is an echo by just comparing the a at index 5 and at index 10.\\n\\n# Approach\\nUsing this approach, we just have to build a program that finds the first echo with substring length l, and then checks consecutive ones. This can be done be checking if index i and i + l are the same up until we\\'ve have l characters in a row that are the same. \\n\\n# Complexity\\n- Time complexity: O(n ^ 2)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def distinctEchoSubstrings(self, text):\\n\\n        //count of echos\\n        ret = 0\\n\\n        //dictionary keeping track of distinct substrings so we don\\'t count any echoes twice\\n        distinct = defaultdict(int)\\n\\n        //iterating through possible lengths of substrings\\n        for i in range (1, len(text) / 2 + 1):\\n            //number of characters in row that have echos a distance i away\\n            count = 0\\n            \\n            //every possible index containing an echo with substring length i\\n            for j in range(0, len(text) - i):\\n                if text[j] == text[i + j]:\\n                    if count == i - 1:\\n                        if distinct[text[j:j + i]] == 0:\\n                            ret += 1\\n                            distinct[text[j:j + i]] = 1\\n                    else:\\n                        count += 1\\n                else:\\n                    count = 0\\n        \\n        return ret\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def distinctEchoSubstrings(self, text):\\n\\n        //count of echos\\n        ret = 0\\n\\n        //dictionary keeping track of distinct substrings so we don\\'t count any echoes twice\\n        distinct = defaultdict(int)\\n\\n        //iterating through possible lengths of substrings\\n        for i in range (1, len(text) / 2 + 1):\\n            //number of characters in row that have echos a distance i away\\n            count = 0\\n            \\n            //every possible index containing an echo with substring length i\\n            for j in range(0, len(text) - i):\\n                if text[j] == text[i + j]:\\n                    if count == i - 1:\\n                        if distinct[text[j:j + i]] == 0:\\n                            ret += 1\\n                            distinct[text[j:j + i]] = 1\\n                    else:\\n                        count += 1\\n                else:\\n                    count = 0\\n        \\n        return ret\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3604220,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        unordered_set<string> result;\\n        int l = text.length() - 1;\\n        for (int i = 0; i < l; ++i)  {\\n            const auto& substr_len = KMP(text, i, &result);\\n            if (substr_len != numeric_limits<int>::max()) {\\n                l = min(l, i + substr_len);\\n            }\\n        }\\n        return result.size();\\n    }\\nprivate:\\n    int KMP(const string& text, int l, unordered_set<string> *result) {\\n        vector<int> prefix(text.length() - l, -1);\\n        int j = -1;\\n        for (int i = 1; i < prefix.size(); ++i) {\\n            while (j > -1 && text[l + j + 1] != text[l + i]) {\\n                j = prefix[j];\\n            }\\n            if (text[l + j + 1] == text[l + i]) {\\n                ++j;\\n            }\\n            prefix[i] = j;\\n            if ((j + 1) && (i + 1) % ((i + 1) - (j + 1)) == 0 &&\\n                (i + 1) / ((i + 1) - (j + 1)) % 2 == 0) {\\n                result->emplace(text.substr(l, i + 1));\\n            }\\n        }\\n        return (prefix.back() + 1 && (prefix.size() % (prefix.size() - (prefix.back() + 1)) == 0))\\n               ? (prefix.size() - (prefix.back() + 1))\\n               : numeric_limits<int>::max();\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        d = {}\\n        visited = set()\\n        ans = 0\\n        if all([t == text[0] for t in text]):\\n            return len(text) //2\\n        for (i, s) in enumerate(text):\\n            if s not in d:\\n                d[s] = [i]\\n            else:\\n                for k in d[s]:\\n                    if text[k:i] == text[i:(2 * i - k)]:\\n                        visited.add(text[k:i])\\n                        break\\n                d[s].append(i)\\n        return len(visited)\\n```\\n\\n```Java []\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        Set<Long> st = new HashSet<>();\\n        RollingHash rh = new RollingHash(text);\\n        for(int i = 0; i < text.length(); i++){\\n            for(int j = i; j < text.length(); j++){\\n                if( (j-i+1) % 2 == 0){\\n                    int mid = (i+1)+(j+1-(i+1))/2;\\n                    if(rh.get(i+1, mid) == rh.get(mid+1, j+1)){\\n                        st.add(rh.get(i+1, j+1));\\n                    }\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n}\\nclass RollingHash{\\n    int n;\\n    int base = 31;\\n    long[] p;\\n    long[] h;\\n    \\n    public RollingHash(String text){\\n        n = text.length();\\n        p = new long[n+2];\\n        h = new long[n+2];\\n        \\n        p[0] = 1;\\n        \\n        for(int i = 1; i <= n; i++){\\n            p[i] = p[i-1]*base;\\n            h[i] = h[i-1]*base + text.charAt(i-1);\\n        }\\n    }\\n    public long get(int l, int r){\\n        return h[r]-h[l-1]*p[r-l+1];\\n    }   \\n} \\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        unordered_set<string> result;\\n        int l = text.length() - 1;\\n        for (int i = 0; i < l; ++i)  {\\n            const auto& substr_len = KMP(text, i, &result);\\n            if (substr_len != numeric_limits<int>::max()) {\\n                l = min(l, i + substr_len);\\n            }\\n        }\\n        return result.size();\\n    }\\nprivate:\\n    int KMP(const string& text, int l, unordered_set<string> *result) {\\n        vector<int> prefix(text.length() - l, -1);\\n        int j = -1;\\n        for (int i = 1; i < prefix.size(); ++i) {\\n            while (j > -1 && text[l + j + 1] != text[l + i]) {\\n                j = prefix[j];\\n            }\\n            if (text[l + j + 1] == text[l + i]) {\\n                ++j;\\n            }\\n            prefix[i] = j;\\n            if ((j + 1) && (i + 1) % ((i + 1) - (j + 1)) == 0 &&\\n                (i + 1) / ((i + 1) - (j + 1)) % 2 == 0) {\\n                result->emplace(text.substr(l, i + 1));\\n            }\\n        }\\n        return (prefix.back() + 1 && (prefix.size() % (prefix.size() - (prefix.back() + 1)) == 0))\\n               ? (prefix.size() - (prefix.back() + 1))\\n               : numeric_limits<int>::max();\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        d = {}\\n        visited = set()\\n        ans = 0\\n        if all([t == text[0] for t in text]):\\n            return len(text) //2\\n        for (i, s) in enumerate(text):\\n            if s not in d:\\n                d[s] = [i]\\n            else:\\n                for k in d[s]:\\n                    if text[k:i] == text[i:(2 * i - k)]:\\n                        visited.add(text[k:i])\\n                        break\\n                d[s].append(i)\\n        return len(visited)\\n```\n```Java []\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        Set<Long> st = new HashSet<>();\\n        RollingHash rh = new RollingHash(text);\\n        for(int i = 0; i < text.length(); i++){\\n            for(int j = i; j < text.length(); j++){\\n                if( (j-i+1) % 2 == 0){\\n                    int mid = (i+1)+(j+1-(i+1))/2;\\n                    if(rh.get(i+1, mid) == rh.get(mid+1, j+1)){\\n                        st.add(rh.get(i+1, j+1));\\n                    }\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n}\\nclass RollingHash{\\n    int n;\\n    int base = 31;\\n    long[] p;\\n    long[] h;\\n    \\n    public RollingHash(String text){\\n        n = text.length();\\n        p = new long[n+2];\\n        h = new long[n+2];\\n        \\n        p[0] = 1;\\n        \\n        for(int i = 1; i <= n; i++){\\n            p[i] = p[i-1]*base;\\n            h[i] = h[i-1]*base + text.charAt(i-1);\\n        }\\n    }\\n    public long get(int l, int r){\\n        return h[r]-h[l-1]*p[r-l+1];\\n    }   \\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3560215,
                "title": "fast-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        n = len(text)\\n\\t\\t\\n        def helper(size):\\n            base = 1 << 5\\n            M = 10 ** 9 + 7\\n            a = pow(base, size, M)\\n            t = 0\\n            vis = defaultdict(set)\\n            vis_pattern = set()\\n            ans = 0\\n            for i in range(n):\\n                t = (base * t + ord(text[i]) - ord(\\'a\\')) % M\\n                if i >= size:\\n                    t -= a * (ord(text[i - size]) - ord(\\'a\\'))\\n                    t %= M\\n                    if t not in vis_pattern and (i - size * 2 + 1) in vis[t]:\\n                        ans += 1\\n                        vis_pattern.add(t)\\n                if i >= size - 1:\\n                    vis[t].add(i - size + 1)\\n            return ans\\n\\n        return sum(helper(size) for size in range(1, n//2+1))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        n = len(text)\\n\\t\\t\\n        def helper(size):\\n            base = 1 << 5\\n            M = 10 ** 9 + 7\\n            a = pow(base, size, M)\\n            t = 0\\n            vis = defaultdict(set)\\n            vis_pattern = set()\\n            ans = 0\\n            for i in range(n):\\n                t = (base * t + ord(text[i]) - ord(\\'a\\')) % M\\n                if i >= size:\\n                    t -= a * (ord(text[i - size]) - ord(\\'a\\'))\\n                    t %= M\\n                    if t not in vis_pattern and (i - size * 2 + 1) in vis[t]:\\n                        ans += 1\\n                        vis_pattern.add(t)\\n                if i >= size - 1:\\n                    vis[t].add(i - size + 1)\\n            return ans\\n\\n        return sum(helper(size) for size in range(1, n//2+1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532296,
                "title": "python-o-n-2-easy-to-understand",
                "content": "# Approach\\necho substring is a + a. so for each text[i] for i from 0 -> len(text) -1 and for j from i -> len(text). get prefix = text[i: j + 1], suffix = text[j + 1: j + 1 + len(prefix)]. if prefix == suffix: ans.add(prefix)\\n\\nthen return len(ans)\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        ans = set()\\n\\n        for i in range(len(text)):\\n            for j in range(i, len(text)):\\n                prefix = text[i : j + 1]\\n                suffix = text[j + 1: j + 1 + len(prefix)]\\n\\n                if prefix == suffix: \\n                    ans.add(prefix)\\n\\n        # print(ans) \\n        return len(ans)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        ans = set()\\n\\n        for i in range(len(text)):\\n            for j in range(i, len(text)):\\n                prefix = text[i : j + 1]\\n                suffix = text[j + 1: j + 1 + len(prefix)]\\n\\n                if prefix == suffix: \\n                    ans.add(prefix)\\n\\n        # print(ans) \\n        return len(ans)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3501060,
                "title": "golang-slightly-faster-using-bool",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc distinctEchoSubstrings(text string) int {\\n   ans := make(map[string]bool)\\n\\tfor i := range text {\\n\\t\\tfor j := i + 1; j-i <= len(text)-j; j++ {\\n\\t\\t\\tif t:=text[i:j]; t == text[j:2*j-i] {\\n\\t\\t\\t\\tans[t] = true\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn len(ans) \\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc distinctEchoSubstrings(text string) int {\\n   ans := make(map[string]bool)\\n\\tfor i := range text {\\n\\t\\tfor j := i + 1; j-i <= len(text)-j; j++ {\\n\\t\\t\\tif t:=text[i:j]; t == text[j:2*j-i] {\\n\\t\\t\\t\\tans[t] = true\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn len(ans) \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3473161,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(string &str,int start1,int end1,int start2,int end2)\\n    {\\n        for (int i=start1,j=start2;i<=end1,j<=end2;i++,j++)\\n        {\\n            if (str[i]!=str[j]) return false;\\n        }\\n        return true;\\n    }\\n    int distinctEchoSubstrings(string text) {\\n        int n=text.size();\\n        set<string>st;\\n        for (int i=0;i<n-1;i++)\\n        {\\n            for (int l=1;i+2*l<=n;l++)\\n            {\\n                if (check(text,i,i+l-1,i+l,i+2*l-1)) \\n                {\\n                    st.insert(text.substr(i,2*l));\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(string &str,int start1,int end1,int start2,int end2)\\n    {\\n        for (int i=start1,j=start2;i<=end1,j<=end2;i++,j++)\\n        {\\n            if (str[i]!=str[j]) return false;\\n        }\\n        return true;\\n    }\\n    int distinctEchoSubstrings(string text) {\\n        int n=text.size();\\n        set<string>st;\\n        for (int i=0;i<n-1;i++)\\n        {\\n            for (int l=1;i+2*l<=n;l++)\\n            {\\n                if (check(text,i,i+l-1,i+l,i+2*l-1)) \\n                {\\n                    st.insert(text.substr(i,2*l));\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442136,
                "title": "go-easy-solution-o-n-2",
                "content": "# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc distinctEchoSubstrings(text string) int {\\n\\techo := make(map[string]struct{})\\n\\tfor i := range text {\\n\\t\\tfor j := i + 1; j-i <= len(text)-j; j++ {\\n\\t\\t\\tif t := text[i:j]; t == text[j:2*j-i] {\\n\\t\\t\\t\\techo[t] = struct{}{}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn len(echo)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc distinctEchoSubstrings(text string) int {\\n\\techo := make(map[string]struct{})\\n\\tfor i := range text {\\n\\t\\tfor j := i + 1; j-i <= len(text)-j; j++ {\\n\\t\\t\\tif t := text[i:j]; t == text[j:2*j-i] {\\n\\t\\t\\t\\techo[t] = struct{}{}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn len(echo)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3339776,
                "title": "distinct-echo-substrings-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private long[] h;\\n    private long[] p;\\n\\n    public int distinctEchoSubstrings(String text) {\\n        int n = text.length();\\n        int base = 131;\\n        h = new long[n + 10];\\n        p = new long[n + 10];\\n        p[0] = 1;\\n        for (int i = 0; i < n; ++i) {\\n            int t = text.charAt(i) - \\'a\\' + 1;\\n            h[i + 1] = h[i] * base + t;\\n            p[i + 1] = p[i] * base;\\n        }\\n        Set<Long> vis = new HashSet<>();\\n        for (int i = 0; i < n - 1; ++i) {\\n            for (int j = i + 1; j < n; j += 2) {\\n                int k = (i + j) >> 1;\\n                long a = get(i + 1, k + 1);\\n                long b = get(k + 2, j + 1);\\n                if (a == b) {\\n                    vis.add(a);\\n                }\\n            }\\n        }\\n        return vis.size();\\n    }\\n\\n    private long get(int i, int j) {\\n        return h[j] - h[i - 1] * p[j - i + 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Rolling Hash"
                ],
                "code": "```\\nclass Solution {\\n    private long[] h;\\n    private long[] p;\\n\\n    public int distinctEchoSubstrings(String text) {\\n        int n = text.length();\\n        int base = 131;\\n        h = new long[n + 10];\\n        p = new long[n + 10];\\n        p[0] = 1;\\n        for (int i = 0; i < n; ++i) {\\n            int t = text.charAt(i) - \\'a\\' + 1;\\n            h[i + 1] = h[i] * base + t;\\n            p[i + 1] = p[i] * base;\\n        }\\n        Set<Long> vis = new HashSet<>();\\n        for (int i = 0; i < n - 1; ++i) {\\n            for (int j = i + 1; j < n; j += 2) {\\n                int k = (i + j) >> 1;\\n                long a = get(i + 1, k + 1);\\n                long b = get(k + 2, j + 1);\\n                if (a == b) {\\n                    vis.add(a);\\n                }\\n            }\\n        }\\n        return vis.size();\\n    }\\n\\n    private long get(int i, int j) {\\n        return h[j] - h[i - 1] * p[j - i + 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225395,
                "title": "rust-solution",
                "content": "Just a rust implementation of Stefan\\'s approach\\n# Code\\n```\\nimpl Solution {\\n    pub fn distinct_echo_substrings(text: String) -> i32 {\\n        fn sliding_window(text: String) -> i32 {\\n            use std::collections::*;\\n            let mut set = HashSet::new();\\n            let text = text.chars().collect::<Vec<_>>();\\n            for window_size in 1..=text.len() / 2 {\\n                let mut same_count = 0;\\n                for i in 0..window_size {\\n                    if text[i] == text[i + window_size] {\\n                        same_count += 1i32;\\n                    }\\n                }\\n                for i in 0..=text.len() - window_size * 2 {\\n                    if same_count == window_size as i32 {\\n                        set.insert(&text[i..i + window_size]);\\n                    }\\n                    if i == text.len() - window_size * 2 {\\n                        break;\\n                    }\\n                    same_count += (text[i + window_size] == text[i + window_size * 2]) as i32\\n                        - (text[i] == text[i + window_size]) as i32;\\n                }\\n            }\\n            set.len() as i32\\n        }\\n\\n        sliding_window(text)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn distinct_echo_substrings(text: String) -> i32 {\\n        fn sliding_window(text: String) -> i32 {\\n            use std::collections::*;\\n            let mut set = HashSet::new();\\n            let text = text.chars().collect::<Vec<_>>();\\n            for window_size in 1..=text.len() / 2 {\\n                let mut same_count = 0;\\n                for i in 0..window_size {\\n                    if text[i] == text[i + window_size] {\\n                        same_count += 1i32;\\n                    }\\n                }\\n                for i in 0..=text.len() - window_size * 2 {\\n                    if same_count == window_size as i32 {\\n                        set.insert(&text[i..i + window_size]);\\n                    }\\n                    if i == text.len() - window_size * 2 {\\n                        break;\\n                    }\\n                    same_count += (text[i + window_size] == text[i + window_size * 2]) as i32\\n                        - (text[i] == text[i + window_size]) as i32;\\n                }\\n            }\\n            set.len() as i32\\n        }\\n\\n        sliding_window(text)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3188623,
                "title": "chal-bhai",
                "content": "class Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) \\n    {\\n        set<string> st;\\n        int n=text.size();\\n        \\n        for(int len=1;len<=n/2;len++)\\n        {\\n            int count=0;\\n            \\n            for(int l=0,r=len;r<n;l++,r++)\\n            {\\n                if(text[l]==text[r])\\n                    count++;\\n                else\\n                    count=0;\\n                \\n                if(count==len)\\n                {\\n                     st.insert(text.substr(l,len));\\n                     count--;\\n                }\\n            }\\n        }\\n            \\n        return st.size();\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) \\n    {\\n        set<string> st;\\n        int n=text.size();\\n        \\n        for(int len=1;len<=n/2;len++)\\n        {\\n            int count=0;\\n            \\n            for(int l=0,r=len;r<n;l++,r++)\\n            {\\n                if(text[l]==text[r])\\n                    count++;\\n                else\\n                    count=0;\\n                \\n                if(count==len)\\n                {\\n                     st.insert(text.substr(l,len));\\n                     count--;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3116927,
                "title": "c-solution-hashset",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int DistinctEchoSubstrings(string text) {\\n        if(text.Length == 1){\\n            return 0;\\n        }\\n\\n        HashSet<string> echos = new();\\n        int lastIndex = text.Length - 1;\\n\\n        for(int i=0; i<lastIndex; i++){\\n            int mid = (text.Length-i)/2;\\n\\n            for(int len=1; len<=mid; len++){\\n                int j = i+len;\\n\\n                if(text.Substring(i, len).Equals(text.Substring(j, len))){\\n                    echos.Add(text.Substring(i, (len*2)));\\n                }\\n            }\\n        }\\n\\n        return echos.Count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\npublic class Solution {\\n    public int DistinctEchoSubstrings(string text) {\\n        if(text.Length == 1){\\n            return 0;\\n        }\\n\\n        HashSet<string> echos = new();\\n        int lastIndex = text.Length - 1;\\n\\n        for(int i=0; i<lastIndex; i++){\\n            int mid = (text.Length-i)/2;\\n\\n            for(int len=1; len<=mid; len++){\\n                int j = i+len;\\n\\n                if(text.Substring(i, len).Equals(text.Substring(j, len))){\\n                    echos.Add(text.Substring(i, (len*2)));\\n                }\\n            }\\n        }\\n\\n        return echos.Count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3114158,
                "title": "brute-force-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic static int distinctEchoSubstrings(String text) {\\n    \\n    Set<String> s = new HashSet<>();\\n    \\n    for (int i = 0; i < text.length(); i++)\\n        \\n    for (int j = i + 1; j < text.length(); j++)\\n        \\n    if (text.charAt(i) == text.charAt(j) && j + j - i <= text.length())\\n        \\n    if (text.substring(i, j).equals(text.substring(j, j + j - i)))\\n        \\n    s.add(text.substring(i, j) + text.substring(j, j + j - i));\\n    \\n    return s.size();\\n    \\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic static int distinctEchoSubstrings(String text) {\\n    \\n    Set<String> s = new HashSet<>();\\n    \\n    for (int i = 0; i < text.length(); i++)\\n        \\n    for (int j = i + 1; j < text.length(); j++)\\n        \\n    if (text.charAt(i) == text.charAt(j) && j + j - i <= text.length())\\n        \\n    if (text.substring(i, j).equals(text.substring(j, j + j - i)))\\n        \\n    s.add(text.substring(i, j) + text.substring(j, j + j - i));\\n    \\n    return s.size();\\n    \\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113780,
                "title": "python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        count=0\\n        dic=dict()\\n        for i in range(len(text)):\\n            a=i\\n            b=a+1\\n            for j in range(len(text[i:])):\\n                if text[a:b]==text[b:len(text[a:b])+b]:\\n                    if not text[a:b] in dic:\\n                        count+=1\\n                    dic[text[a:b]]=0\\n                b+=1\\n        \\n        return count \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        count=0\\n        dic=dict()\\n        for i in range(len(text)):\\n            a=i\\n            b=a+1\\n            for j in range(len(text[i:])):\\n                if text[a:b]==text[b:len(text[a:b])+b]:\\n                    if not text[a:b] in dic:\\n                        count+=1\\n                    dic[text[a:b]]=0\\n                b+=1\\n        \\n        return count \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096867,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn distinct_echo_substrings(text: String) -> i32 {\\n        fn check(s: &[u8]) -> bool {\\n            let mut j = s.len() / 2;\\n            for i in 0..(s.len() / 2) {\\n                if s[i] != s[j] {\\n                    return false;\\n                }\\n                j += 1;\\n            }\\n            true\\n        }\\n\\n        let mut s = std::collections::HashSet::new();\\n        let text = text.as_bytes();\\n        for i in 0..text.len() {\\n            let mut ans = vec![];\\n            for j in (i..text.len()).step_by(2) {\\n                ans.push(text[j]);\\n                if j + 1 < text.len() {\\n                    ans.push(text[j + 1]);\\n                } else {\\n                    break;\\n                }\\n                if check(&ans) {\\n                    s.insert(ans.clone());\\n                }\\n            }\\n        }\\n        s.len() as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn distinct_echo_substrings(text: String) -> i32 {\\n        fn check(s: &[u8]) -> bool {\\n            let mut j = s.len() / 2;\\n            for i in 0..(s.len() / 2) {\\n                if s[i] != s[j] {\\n                    return false;\\n                }\\n                j += 1;\\n            }\\n            true\\n        }\\n\\n        let mut s = std::collections::HashSet::new();\\n        let text = text.as_bytes();\\n        for i in 0..text.len() {\\n            let mut ans = vec![];\\n            for j in (i..text.len()).step_by(2) {\\n                ans.push(text[j]);\\n                if j + 1 < text.len() {\\n                    ans.push(text[j + 1]);\\n                } else {\\n                    break;\\n                }\\n                if check(&ans) {\\n                    s.insert(ans.clone());\\n                }\\n            }\\n        }\\n        s.len() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3095390,
                "title": "c-2-approach-improved-brute-rolling-hash-google-asked-well-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI tried classic rolling hash, but it gave TLE. So, I tried all possible substring, and check for the condition. But there is a cache !!\\nI tried only substring whose length is possible :\\n```\\nfor (int len = 1; i + 2 * len <= s.size(); len++){\\n    ...\\n}\\n```\\nFocus on ```i + 2 * len <= s.size();``` because if I consider ith index as starting of echo string then len can go upto only (n-i)/2, no more than that. So, it won\\'t give TLE and will help to reduce time. \\n\\n\\n# Approach 1 :\\n<!-- Describe your approach to solving the problem. -->\\nAssume ith index as start of substring and compare string for **all possible length** which can be made starting from ith index.\\nFor length len, compares s[i ... i+len-1] and s[i+len ... 1+2*len-1]. \\nAnd store possible substring in a set to avoid duplicates.\\n[ Note :- Use compare() in c++, to avoid creating a new substring each time.].\\n\\n\\n# Complexity \\n- Time complexity: $$O(N^3)$$ where N is size of string, as One extra $$O(N)$$ requirred to compare two substring. but it will be accepted. \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N^2)$$ where N is size of string, as in the worst case we have to store every substring.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll                 long long\\n\\nclass Solution {\\npublic:\\n\\n    // brute force // accepted\\n    int distinctEchoSubstrings(string& s) {\\n        unordered_set<string> st;\\n        for (int i = 0; i < s.size(); i++) {\\n            // assume ith index as start of string, so first substring s[i...i+len-1] and second is s[i+len...i+len+len-1]\\n            for (int len = 1; i + 2 * len <= s.size(); len++) {\\n                // compare both by compare()\\n                if (s.compare(i, len, s, i + len, len) == 0) st.insert(s.substr(i, len));\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```\\n\\n---\\n\\n\\n# Approach 2 :\\nHere approach is same as the previous one, but this time we compare hashes of two substring instead of comparing two substring.\\nAlso, store hashes of possible substring instead of substring, so that we can reduce our time. \\n\\n# Complexity \\n- Time complexity: $$O(N^2)$$ where N is size of string.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$ where N is size of string, we need space only to store hashes of substring.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll                 long long\\n\\nclass Solution {\\npublic:\\n\\n    // by hashing // accepted\\n    int distinctEchoSubstrings(string s) {\\n        ll n = s.size(), prm = 31, mod = 1000000007;\\n        // h[i] : store hash of s[0....i] // p[i] store prem^i\\n        vector<ll> h(n, 0), p(n, 0);\\n\\n        // preprocessing : calculate hash array and prime power\\n        h[0] = s[0] % mod;\\n        p[0] = 1;\\n        for (int i = 1; i < n; i++) {\\n            h[i] = (h[i - 1] * prm + s[i]) % mod;\\n            p[i] = (p[i - 1] * prm) % mod;\\n        }\\n\\n\\n        // cal hash of s[i...j]  // inclusive\\n        auto calHash = [&](int i, int j) {\\n            auto res = (h[j] - (i >= 1 ? h[i - 1] * p[j - i + 1] : 0)) % mod;\\n            return (res + mod) % mod;\\n        };\\n\\n\\n        // store hashes instead of string to reduce the time\\n        unordered_set<ll> st;\\n        for (int i = 0; i < n; i++) {\\n            // assume ith index as start of string, so first substring s[i...i+len-1] and second is s[i+len...i+len+len-1]\\n            for (int len = 1; i + 2 * len <= n; len++) {\\n                // compare both by hashing\\n                if (calHash(i, i + len - 1) == calHash(i + len, i + 2 * len - 1))\\n                    st.insert(calHash(i, i + len - 1));\\n            }\\n        }\\n        return st.size();\\n    }\\n\\n};\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sliding Window",
                    "Rolling Hash",
                    "Hash Function"
                ],
                "code": "```\\nfor (int len = 1; i + 2 * len <= s.size(); len++){\\n    ...\\n}\\n```\n```i + 2 * len <= s.size();```\n```\\n#define ll                 long long\\n\\nclass Solution {\\npublic:\\n\\n    // brute force // accepted\\n    int distinctEchoSubstrings(string& s) {\\n        unordered_set<string> st;\\n        for (int i = 0; i < s.size(); i++) {\\n            // assume ith index as start of string, so first substring s[i...i+len-1] and second is s[i+len...i+len+len-1]\\n            for (int len = 1; i + 2 * len <= s.size(); len++) {\\n                // compare both by compare()\\n                if (s.compare(i, len, s, i + len, len) == 0) st.insert(s.substr(i, len));\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094042,
                "title": "simple-c-easy-full-algorithm-explained",
                "content": "\\n\\n# Approach\\n1.We are taking a set for storing distinct substrings.\\n2.We are running a loop of len(1->n/2) i.e. max length for an echo substring can be n/2 and keep a count at 0.\\n3.We position the left pt on 0 and right pt on len and run the loop till right reaches n .\\n4.When same characters is found we increment the count and if different characters are found we make count = 0 i.e we have start again searching.\\n5.If the count reaches len we will store the certain substring into the set.\\n6.We will decrease the count to remove the first element occurence and start checking from 1st index for a new sequence.\\n7.finally we will return set size.\\n\\n# Complexity\\n- Time complexity:\\nO(n*3)\\n\\n- Space complexity:\\nO(n) - set\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        int n = text.size();\\n        unordered_set<string>st;\\n        for(int len=1;len<=n/2;len++){\\n            int count =0;\\n            for(int left=0,right=len;right<n;right++,left++){\\n                if(text[left]==text[right])count++;\\n                else count=0;\\n\\n                if(count==len){\\n                    string str = text.substr(left,right-left+1);\\n                    st.insert(str);\\n                    count--;\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        int n = text.size();\\n        unordered_set<string>st;\\n        for(int len=1;len<=n/2;len++){\\n            int count =0;\\n            for(int left=0,right=len;right<n;right++,left++){\\n                if(text[left]==text[right])count++;\\n                else count=0;\\n\\n                if(count==len){\\n                    string str = text.substr(left,right-left+1);\\n                    st.insert(str);\\n                    count--;\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018168,
                "title": "rolling-hash",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    long[] hash;\\n    long[] power;\\n    long mod = (int)1e9 + 7;\\n    long radix = 256;\\n    void _hashing(String s, int n) {\\n        hash = new long[n];\\n        power = new long[n];\\n        power[0] = 1;\\n        for(int i = 1; i < n; i++) {\\n            hash[i] = (hash[i - 1] * radix + s.charAt(i)) % mod;\\n            power[i] = (power[i - 1] * radix) % mod;\\n        }\\n    }\\n    long calculateHash(int l, int r) {\\n        long val = (hash[r] - hash[l] * power[r - l] % mod + mod ) % mod;\\n        return val;\\n    }\\n    public int distinctEchoSubstrings(String text) {\\n        int n = text.length();\\n        _hashing(text, n);\\n        Set<Long> set = new HashSet<>();\\n        for(int len = 1; len <= n / 2; len++) {\\n            int count = 0;\\n            for(int i = 0, j = len; j < n; i++, j++) {\\n                char ci = text.charAt(i);\\n                char cj = text.charAt(j);\\n                if(ci == cj)\\n                    count++;\\n                else count = 0;\\n                if(count == len){\\n                    long _hash = calculateHash(i, j);\\n                    set.add(_hash);\\n                    count--;\\n                }    \\n            }\\n        }\\n        return set.size();\\n    }\\n}\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Rolling Hash"
                ],
                "code": "```\\nclass Solution {\\n    long[] hash;\\n    long[] power;\\n    long mod = (int)1e9 + 7;\\n    long radix = 256;\\n    void _hashing(String s, int n) {\\n        hash = new long[n];\\n        power = new long[n];\\n        power[0] = 1;\\n        for(int i = 1; i < n; i++) {\\n            hash[i] = (hash[i - 1] * radix + s.charAt(i)) % mod;\\n            power[i] = (power[i - 1] * radix) % mod;\\n        }\\n    }\\n    long calculateHash(int l, int r) {\\n        long val = (hash[r] - hash[l] * power[r - l] % mod + mod ) % mod;\\n        return val;\\n    }\\n    public int distinctEchoSubstrings(String text) {\\n        int n = text.length();\\n        _hashing(text, n);\\n        Set<Long> set = new HashSet<>();\\n        for(int len = 1; len <= n / 2; len++) {\\n            int count = 0;\\n            for(int i = 0, j = len; j < n; i++, j++) {\\n                char ci = text.charAt(i);\\n                char cj = text.charAt(j);\\n                if(ci == cj)\\n                    count++;\\n                else count = 0;\\n                if(count == len){\\n                    long _hash = calculateHash(i, j);\\n                    set.add(_hash);\\n                    count--;\\n                }    \\n            }\\n        }\\n        return set.size();\\n    }\\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3009423,
                "title": "string-hashing-brute-force",
                "content": "```\\nclass Solution:\\n    def powers(self, n, p, ip, M):\\n        pw = 1\\n        invpw = 1\\n        ppow = []\\n        invppow = []\\n        for _ in range(n):\\n            ppow.append(pw)\\n            invppow.append(invpw)\\n            pw = (pw * p) % M\\n            invpw = (invpw * ip) % M\\n        return ppow, invppow\\n    \\n    def hashes(self, s, p, M):\\n        n = len(s)\\n        h = [0] * (n + 1)\\n        for i in range(n):\\n            h[i + 1] = (h[i] + self.ppow[i] * (ord(s[i]) - ord(\\'a\\'))) % M\\n        return h\\n    \\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        n = len(text)\\n        M = 10 ** 9 + 9\\n        p = 31\\n        self.ppow, self.invppow = self.powers(n + 1, p, pow(p, M - 2, M), M)\\n        subhash = lambda h, i, j: (self.invppow[i] * (h[j + 1] + M - h[i])) % M\\n        hashes = self.hashes(text, p, M)\\n        res = set()\\n        for i in range(n):\\n            for j in range(i, (i + n) // 2):\\n                if subhash(hashes, i, j) == subhash(hashes, j + 1, 2 * j - i + 1):\\n                    res.add(text[i:j+1])\\n        return len(res)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def powers(self, n, p, ip, M):\\n        pw = 1\\n        invpw = 1\\n        ppow = []\\n        invppow = []\\n        for _ in range(n):\\n            ppow.append(pw)\\n            invppow.append(invpw)\\n            pw = (pw * p) % M\\n            invpw = (invpw * ip) % M\\n        return ppow, invppow\\n    \\n    def hashes(self, s, p, M):\\n        n = len(s)\\n        h = [0] * (n + 1)\\n        for i in range(n):\\n            h[i + 1] = (h[i] + self.ppow[i] * (ord(s[i]) - ord(\\'a\\'))) % M\\n        return h\\n    \\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        n = len(text)\\n        M = 10 ** 9 + 9\\n        p = 31\\n        self.ppow, self.invppow = self.powers(n + 1, p, pow(p, M - 2, M), M)\\n        subhash = lambda h, i, j: (self.invppow[i] * (h[j + 1] + M - h[i])) % M\\n        hashes = self.hashes(text, p, M)\\n        res = set()\\n        for i in range(n):\\n            for j in range(i, (i + n) // 2):\\n                if subhash(hashes, i, j) == subhash(hashes, j + 1, 2 * j - i + 1):\\n                    res.add(text[i:j+1])\\n        return len(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949173,
                "title": "python-hashing-memo-solution-easy-to-understand-faster-than-60",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n```dp[start][end]``` contains the hashing value of substring ```text[start: end + 1]```\\n\\nIf ```text[start: start + substrLen]``` is equal to ```text[start + substrLen: start + substrLen * 2]```, we will have ```dp[start][start + substrLen-1] == dp[start + substrLen][start + substrLen * 2 - 1]```\\n\\nNow the things will be very simple. We just need to iterate in dp to find the differnet hash value with this condition.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python []\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        if len(set(text)) == 1:\\n            return len(text) // 2\\n        nums = [ord(char) - ord(\\'a\\') + 1 for char in text]\\n        hashMemo = [[0] * len(text) for _ in text]\\n        hashMod, ans = 10 ** 10 + 7, set()\\n        for start in range(len(nums)):\\n            hashMemo[start][start] = nums[start]\\n            for end in range(start + 1, len(nums)):\\n                hashMemo[start][end] = (hashMemo[start][end - 1] * 26 + nums[end]) % hashMod\\n        for start in range(len(nums)):\\n            for substrLen in range(1, (len(nums) - start) // 2 + 1):\\n                if hashMemo[start][start + substrLen - 1] == hashMemo[start + substrLen][start + substrLen * 2 - 1]:\\n                    ans.add(hashMemo[start][start + substrLen - 1])\\n        return len(ans)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Dynamic Programming",
                    "Hash Function"
                ],
                "code": "```dp[start][end]```\n```text[start: end + 1]```\n```text[start: start + substrLen]```\n```text[start + substrLen: start + substrLen * 2]```\n```dp[start][start + substrLen-1] == dp[start + substrLen][start + substrLen * 2 - 1]```\n```python []\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        if len(set(text)) == 1:\\n            return len(text) // 2\\n        nums = [ord(char) - ord(\\'a\\') + 1 for char in text]\\n        hashMemo = [[0] * len(text) for _ in text]\\n        hashMod, ans = 10 ** 10 + 7, set()\\n        for start in range(len(nums)):\\n            hashMemo[start][start] = nums[start]\\n            for end in range(start + 1, len(nums)):\\n                hashMemo[start][end] = (hashMemo[start][end - 1] * 26 + nums[end]) % hashMod\\n        for start in range(len(nums)):\\n            for substrLen in range(1, (len(nums) - start) // 2 + 1):\\n                if hashMemo[start][start + substrLen - 1] == hashMemo[start + substrLen][start + substrLen * 2 - 1]:\\n                    ans.add(hashMemo[start][start + substrLen - 1])\\n        return len(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2844529,
                "title": "solution-using-sliding-window-for-for-all-length-substrings",
                "content": "Hope this might be of some help :\\n\\nApproach 1: using HashSet and Sliding window using left right pointers.\\n   \\n         public int distinctEchoSubstrings(String text) \\n\\t\\t   {\\n\\t\\t   HashSet<String> set = new HashSet();\\n         int n = text.length();\\n         for(int len = 1; len<  n/2 +1; len++){\\n             int count=0;\\n             for(int l =0,r=len;r<n;l++,r++){\\n                 if(text.charAt(l)==text.charAt(r)){\\n                     count++;\\n                 }else{\\n                     count=0;\\n                 }\\n\\n                 if(count ==len){\\n                     String str = text.substring(l,r+1);\\n                     set.add(str);\\n                     count--; //Remove first character of found echo string to check next substings of length\\n                 }\\n             }\\n         }\\n         return set.size();\\n\\t\\t }\\n\\nApproach 2 : using HashMap\\n     \\n\\t \\n         public int distinctEchoSubstrings1(String text) \\n\\t\\t {\\n\\t\\t HashMap<Integer, String> distinctMap = new HashMap();\\n         int str_len = text.length();\\n         Set<String> answers = new HashSet();\\n         int counter = 0;\\n         for(int n = 1; n < 1+str_len/2; n++)\\n         {\\n             for(int i = 0; i < str_len-n+1; i++)\\n             {\\n                 String sub = text.substring(i, i+n);\\n                 if(distinctMap.containsKey(i) && distinctMap.get(i).equals(sub))\\n                 {\\n                     answers.add(sub);\\n                 }\\n                 distinctMap.put(i+n, sub);\\n             }\\n             distinctMap.clear();\\n         }\\n         return answers.size();\\n     }",
                "solutionTags": [
                    "Java",
                    "String",
                    "Sliding Window"
                ],
                "code": "Hope this might be of some help :\\n\\nApproach 1: using HashSet and Sliding window using left right pointers.\\n   \\n         public int distinctEchoSubstrings(String text) \\n\\t\\t   {\\n\\t\\t   HashSet<String> set = new HashSet();\\n         int n = text.length();\\n         for(int len = 1; len<  n/2 +1; len++){\\n             int count=0;\\n             for(int l =0,r=len;r<n;l++,r++){\\n                 if(text.charAt(l)==text.charAt(r)){\\n                     count++;\\n                 }else{\\n                     count=0;\\n                 }\\n\\n                 if(count ==len){\\n                     String str = text.substring(l,r+1);\\n                     set.add(str);\\n                     count--; //Remove first character of found echo string to check next substings of length\\n                 }\\n             }\\n         }\\n         return set.size();\\n\\t\\t }\\n\\nApproach 2 : using HashMap\\n     \\n\\t \\n         public int distinctEchoSubstrings1(String text) \\n\\t\\t {\\n\\t\\t HashMap<Integer, String> distinctMap = new HashMap();\\n         int str_len = text.length();\\n         Set<String> answers = new HashSet();\\n         int counter = 0;\\n         for(int n = 1; n < 1+str_len/2; n++)\\n         {\\n             for(int i = 0; i < str_len-n+1; i++)\\n             {\\n                 String sub = text.substring(i, i+n);\\n                 if(distinctMap.containsKey(i) && distinctMap.get(i).equals(sub))\\n                 {\\n                     answers.add(sub);\\n                 }\\n                 distinctMap.put(i+n, sub);\\n             }\\n             distinctMap.clear();\\n         }\\n         return answers.size();\\n     }",
                "codeTag": "Unknown"
            },
            {
                "id": 2776903,
                "title": "python-simple-and-intuitive-solution-dp-hash-time-o-n-2",
                "content": "```\\ndp[i][j] means the hashing value of substring text[i:j+1]\\nIf text[i:i+w] == text[i+w:i+w*2], we will have dp[i][i+w-1] == dp[i+w][i+w*2-1]\\nNow the things will be very simple.\\nWe just need to iterate in dp to find the differnet hash value with this condition.\\n```\\n\\n```\\ndef distinctEchoSubstrings(self, text: str) -> int:\\n\\tif len(set(text)) == 1:\\n\\t\\treturn len(text)//2\\n\\n\\tnums = [ord(c)-ord(\\'a\\')+1 for c in text]\\n\\tdp = [[0]*len(text) for _ in text]\\n\\tmod, ans = 10**10+7, set()\\n\\t\\n\\t# pre-caching the hash value with all possibilities\\n\\tfor i in range(len(nums)):\\n\\t\\tdp[i][i] = nums[i]\\n\\t\\tfor j in range(i+1, len(nums)):\\n\\t\\t\\tdp[i][j] = (dp[i][j-1]*26+nums[j])%mod\\n\\t\\n\\t# finding different hash value in specific conditions\\n\\tfor i in range(len(nums)):\\n\\t\\tfor w in range(1, (len(nums)-i)//2+1):\\n\\t\\t\\tif dp[i][i+w-1] == dp[i+w][i+w*2-1]:\\n\\t\\t\\t\\tans.add(dp[i][i+w-1])\\n\\treturn len(ans)\\n```",
                "solutionTags": [],
                "code": "```\\ndp[i][j] means the hashing value of substring text[i:j+1]\\nIf text[i:i+w] == text[i+w:i+w*2], we will have dp[i][i+w-1] == dp[i+w][i+w*2-1]\\nNow the things will be very simple.\\nWe just need to iterate in dp to find the differnet hash value with this condition.\\n```\n```\\ndef distinctEchoSubstrings(self, text: str) -> int:\\n\\tif len(set(text)) == 1:\\n\\t\\treturn len(text)//2\\n\\n\\tnums = [ord(c)-ord(\\'a\\')+1 for c in text]\\n\\tdp = [[0]*len(text) for _ in text]\\n\\tmod, ans = 10**10+7, set()\\n\\t\\n\\t# pre-caching the hash value with all possibilities\\n\\tfor i in range(len(nums)):\\n\\t\\tdp[i][i] = nums[i]\\n\\t\\tfor j in range(i+1, len(nums)):\\n\\t\\t\\tdp[i][j] = (dp[i][j-1]*26+nums[j])%mod\\n\\t\\n\\t# finding different hash value in specific conditions\\n\\tfor i in range(len(nums)):\\n\\t\\tfor w in range(1, (len(nums)-i)//2+1):\\n\\t\\t\\tif dp[i][i+w-1] == dp[i+w][i+w*2-1]:\\n\\t\\t\\t\\tans.add(dp[i][i+w-1])\\n\\treturn len(ans)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2633629,
                "title": "python-solution-hash-wisely",
                "content": "Initially I thought this problem is similar to [1044. Longest Duplicate Substring](https://leetcode.com/problems/longest-duplicate-substring/), but it is actually quite different.\\n\\nI felt annoyed because the Rabin-Karp algorithm, although correct, is just slow and even loses to the brute force string comparison solutions. In the end I used the known position of each starting character and just brute force test every possible pairs.\\n\\n```\\n# Rabin-Karp: TLE\\nclass Solution:\\n    # Use Rabin-Karp rolling hash to solve the problem\\n    # So the rolling hash function can convert a substring with any length into a hash value\\n    # Therefore, the art is to check all possible substring length (1 to n//2)\\n    # Use a hash table to store appeared hash value and index\\n    # If see a match, check if text[i:i+l] == text[i+l:i+2*l]\\n    # add length of hash set to result\\n    \\n    # Calculate rolling hash value according Rabin-Karp\\n    def rolling_hash(self, i, size, seed):\\n        h = seed\\n        if i == 0:\\n            for j in range(size):\\n                h *= self.base\\n                h += ord(self.string[i+j])-ord(\\'a\\')\\n                h %= self.MOD\\n        else:\\n            h -= (ord(self.string[i-1])-ord(\\'a\\'))*self.lookup[size-1]\\n            h *= self.base\\n            h += ord(self.string[i+size-1])-ord(\\'a\\')\\n            h %= self.MOD\\n        return h\\n    \\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        # Base chosen: must be larger than maximum of value of s, preferably prime; Mod: large enough to avoid overflow, should be prime\\n        self.base, self.MOD, n, self.string, result = 29, pow(2,31)-1, len(text), text, 0\\n        # Generate a lookup table for pow(self.base, 0:len(s)) % self.MOD\\n        self.lookup = []\\n        seed = 1\\n        for i in range(n):\\n            self.lookup.append(seed)\\n            seed *= self.base\\n            seed %= self.MOD\\n        first_hash_value = [0]\\n        \\n        for l in range(1,n//2+1,1):\\n            hash_table, result_set = {}, set()\\n            for j in range(n-l+1):\\n                if j > 0:\\n                    hash_value = self.rolling_hash(j, l, hash_value)\\n                else:\\n                    hash_value = first_hash_value[-1]\\n                    hash_value *= self.base\\n                    hash_value += ord(self.string[l-1])-ord(\\'a\\')\\n                    hash_value %= self.MOD\\n                    first_hash_value.append(hash_value)\\n                \\n                if hash_value not in hash_table:\\n                    hash_table[hash_value] = set()\\n                hash_table[hash_value].add(j)\\n                if j - l in hash_table[hash_value] and text[j-l:j] == text[j:j+l]:\\n                    result_set.add(text[j-l:j])\\n            result += len(result_set)\\n        return result\\n\\n# Smart hashing\\nclass Solution:\\n    # As Rabin-Karp is kind of brute-forceish and slow, I use another approach to handle the problem\\n    # For example like \"abcabcabc\", any echo substrings must have the same first letter at the starts of the repeats\\n    # So I first record the appearance of each letter.\\n    # Then if len(occur[letter]) > 1, I ask all pairwise occurences of letter if the two back-to-back strings starting at each position are the same\\n    \\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        occur, n = [[] for i in range(26)], len(text)\\n        for i, c in enumerate(text):\\n            occur[ord(c) - ord(\\'a\\')].append(i)\\n        \\n        result_set = set()\\n        for letter in range(26):\\n            l = len(occur[letter])\\n            if l <= 1:\\n                continue\\n            for i in range(l-1):\\n                for j in range(i+1,l):\\n                    start, end = occur[letter][i], occur[letter][j]\\n                    if 2*end - start > n:\\n                        break\\n                    if text[start:end] == text[end:2*end-start]:\\n                        result_set.add(text[start:end])\\n        return len(result_set)\\n```",
                "solutionTags": [],
                "code": "```\\n# Rabin-Karp: TLE\\nclass Solution:\\n    # Use Rabin-Karp rolling hash to solve the problem\\n    # So the rolling hash function can convert a substring with any length into a hash value\\n    # Therefore, the art is to check all possible substring length (1 to n//2)\\n    # Use a hash table to store appeared hash value and index\\n    # If see a match, check if text[i:i+l] == text[i+l:i+2*l]\\n    # add length of hash set to result\\n    \\n    # Calculate rolling hash value according Rabin-Karp\\n    def rolling_hash(self, i, size, seed):\\n        h = seed\\n        if i == 0:\\n            for j in range(size):\\n                h *= self.base\\n                h += ord(self.string[i+j])-ord(\\'a\\')\\n                h %= self.MOD\\n        else:\\n            h -= (ord(self.string[i-1])-ord(\\'a\\'))*self.lookup[size-1]\\n            h *= self.base\\n            h += ord(self.string[i+size-1])-ord(\\'a\\')\\n            h %= self.MOD\\n        return h\\n    \\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        # Base chosen: must be larger than maximum of value of s, preferably prime; Mod: large enough to avoid overflow, should be prime\\n        self.base, self.MOD, n, self.string, result = 29, pow(2,31)-1, len(text), text, 0\\n        # Generate a lookup table for pow(self.base, 0:len(s)) % self.MOD\\n        self.lookup = []\\n        seed = 1\\n        for i in range(n):\\n            self.lookup.append(seed)\\n            seed *= self.base\\n            seed %= self.MOD\\n        first_hash_value = [0]\\n        \\n        for l in range(1,n//2+1,1):\\n            hash_table, result_set = {}, set()\\n            for j in range(n-l+1):\\n                if j > 0:\\n                    hash_value = self.rolling_hash(j, l, hash_value)\\n                else:\\n                    hash_value = first_hash_value[-1]\\n                    hash_value *= self.base\\n                    hash_value += ord(self.string[l-1])-ord(\\'a\\')\\n                    hash_value %= self.MOD\\n                    first_hash_value.append(hash_value)\\n                \\n                if hash_value not in hash_table:\\n                    hash_table[hash_value] = set()\\n                hash_table[hash_value].add(j)\\n                if j - l in hash_table[hash_value] and text[j-l:j] == text[j:j+l]:\\n                    result_set.add(text[j-l:j])\\n            result += len(result_set)\\n        return result\\n\\n# Smart hashing\\nclass Solution:\\n    # As Rabin-Karp is kind of brute-forceish and slow, I use another approach to handle the problem\\n    # For example like \"abcabcabc\", any echo substrings must have the same first letter at the starts of the repeats\\n    # So I first record the appearance of each letter.\\n    # Then if len(occur[letter]) > 1, I ask all pairwise occurences of letter if the two back-to-back strings starting at each position are the same\\n    \\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        occur, n = [[] for i in range(26)], len(text)\\n        for i, c in enumerate(text):\\n            occur[ord(c) - ord(\\'a\\')].append(i)\\n        \\n        result_set = set()\\n        for letter in range(26):\\n            l = len(occur[letter])\\n            if l <= 1:\\n                continue\\n            for i in range(l-1):\\n                for j in range(i+1,l):\\n                    start, end = occur[letter][i], occur[letter][j]\\n                    if 2*end - start > n:\\n                        break\\n                    if text[start:end] == text[end:2*end-start]:\\n                        result_set.add(text[start:end])\\n        return len(result_set)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2614683,
                "title": "python-trie-clean-short",
                "content": "```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        tr={}\\n        n=len(text)\\n        ans=set()\\n        for i in range(n):\\n            cur=tr\\n            for j in range(i,n):\\n                ch=text[j]\\n                cur=cur.setdefault(ch,{})\\n                cur[j]=True\\n                if i-1 in cur:\\n                    ans.add(text[i:j+1])\\n        return len(ans)\\n",
                "solutionTags": [
                    "Trie"
                ],
                "code": "class Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        tr={}",
                "codeTag": "Java"
            },
            {
                "id": 2592489,
                "title": "dynamic-programming-rolling-hash-easy-to-understand",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        int n = text.size();\\n        ll dp[n][n];\\n        memset(dp, -1, sizeof(dp));\\n        for(int k = 0; k < n; k++){\\n            dp[k][0] = text[k] - \\'a\\' + 1;\\n        }\\n        ll p = 71, m = 1e9+7;\\n        ll pows[n+1];\\n        pows[0] = 1;\\n        for(int i = 1; i <= n; i++){\\n            pows[i] = (p * pows[i-1])%m;\\n        }\\n        for(int k = 1; k < n; k++){\\n            for(int i = 0; i + k < n; i++){\\n                dp[i][k] = (dp[i][k-1] + pows[k]*(dp[i+k][0]))%m;\\n            }\\n        }\\n        int count = 0;\\n        set<int> st;\\n        for(int i = 0; i < n; i++){\\n            for(int k = 0; k+i+1< n; k++){\\n                if ((dp[i][k] == dp[i+k+1][k]) && dp[i][k] >= 0){\\n                    st.insert(dp[i][k]);\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        int n = text.size();\\n        ll dp[n][n];\\n        memset(dp, -1, sizeof(dp));\\n        for(int k = 0; k < n; k++){\\n            dp[k][0] = text[k] - \\'a\\' + 1;\\n        }\\n        ll p = 71, m = 1e9+7;\\n        ll pows[n+1];\\n        pows[0] = 1;\\n        for(int i = 1; i <= n; i++){\\n            pows[i] = (p * pows[i-1])%m;\\n        }\\n        for(int k = 1; k < n; k++){\\n            for(int i = 0; i + k < n; i++){\\n                dp[i][k] = (dp[i][k-1] + pows[k]*(dp[i+k][0]))%m;\\n            }\\n        }\\n        int count = 0;\\n        set<int> st;\\n        for(int i = 0; i < n; i++){\\n            for(int k = 0; k+i+1< n; k++){\\n                if ((dp[i][k] == dp[i+k+1][k]) && dp[i][k] >= 0){\\n                    st.insert(dp[i][k]);\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569065,
                "title": "java-faster-than-97-hash-code-of-substrings",
                "content": "```\\nclass Solution {\\n    long hash[];\\n    long pow[];\\n    long r=256;\\n    long mod=(long)Math.pow(10,9)+7;\\n    public void process(String s,int n)\\n    {\\n        hash=new long[n];\\n        pow=new long[n];\\n        pow[0]=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            hash[i]=(hash[i-1]*r+s.charAt(i))%mod;\\n            pow[i]=(pow[i-1]*r)%mod;\\n        }\\n    }\\n    public long calc(int l,int r)\\n    {\\n        long hashValue=(hash[r]-hash[l]*pow[r-l]%mod+mod)%mod;\\n        return hashValue;\\n    }\\n    public int distinctEchoSubstrings(String text) {\\n        int n=text.length();\\n        process(text,n);\\n        HashSet<Long> hset=new HashSet<>();\\n        for(int len=1;len<=n/2;len++)\\n        {\\n            int c=0;\\n            for(int l=0,r=len;r<n;l++,r++)\\n            {\\n                if(text.charAt(l)==text.charAt(r))\\n                {\\n                   c++; \\n                }\\n                else\\n                {\\n                    c=0;\\n                }\\n                if(c==len)\\n                {\\n                    long hv=calc(l,r);\\n                    hset.add(hv);\\n                    c--;\\n                }\\n            }\\n        }\\n        return hset.size();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    long hash[];\\n    long pow[];\\n    long r=256;\\n    long mod=(long)Math.pow(10,9)+7;\\n    public void process(String s,int n)\\n    {\\n        hash=new long[n];\\n        pow=new long[n];\\n        pow[0]=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            hash[i]=(hash[i-1]*r+s.charAt(i))%mod;\\n            pow[i]=(pow[i-1]*r)%mod;\\n        }\\n    }\\n    public long calc(int l,int r)\\n    {\\n        long hashValue=(hash[r]-hash[l]*pow[r-l]%mod+mod)%mod;\\n        return hashValue;\\n    }\\n    public int distinctEchoSubstrings(String text) {\\n        int n=text.length();\\n        process(text,n);\\n        HashSet<Long> hset=new HashSet<>();\\n        for(int len=1;len<=n/2;len++)\\n        {\\n            int c=0;\\n            for(int l=0,r=len;r<n;l++,r++)\\n            {\\n                if(text.charAt(l)==text.charAt(r))\\n                {\\n                   c++; \\n                }\\n                else\\n                {\\n                    c=0;\\n                }\\n                if(c==len)\\n                {\\n                    long hv=calc(l,r);\\n                    hset.add(hv);\\n                    c--;\\n                }\\n            }\\n        }\\n        return hset.size();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467581,
                "title": "clean-java-sliding-window",
                "content": "```Java\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        int ans = 0, n = text.length()/2;\\n        for (int i = 1; i <= n; i++){ // i = length\\n            Set<String> seen = new HashSet<>();\\n            for (int j = 0, k = j+i, ok = 0; k < text.length(); j++, k++){ // j = start of 1st part, k = start of 2nd part.\\n                if (text.charAt(j) == text.charAt(k)){ // matched\\n                    ok++;\\n                }\\n                if (j >= i && text.charAt(j-i) == text.charAt(k-i)){ // was matched, but out of bound now, so delete 1\\n                    ok--;\\n                }\\n                if (j >= i-1 && ok == i && seen.add(text.substring(j-i+1,j+1))){ // if it echoes and we\\'ve not seen it, add 1 to ans\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```Java\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        int ans = 0, n = text.length()/2;\\n        for (int i = 1; i <= n; i++){ // i = length\\n            Set<String> seen = new HashSet<>();\\n            for (int j = 0, k = j+i, ok = 0; k < text.length(); j++, k++){ // j = start of 1st part, k = start of 2nd part.\\n                if (text.charAt(j) == text.charAt(k)){ // matched\\n                    ok++;\\n                }\\n                if (j >= i && text.charAt(j-i) == text.charAt(k-i)){ // was matched, but out of bound now, so delete 1\\n                    ok--;\\n                }\\n                if (j >= i-1 && ok == i && seen.add(text.substring(j-i+1,j+1))){ // if it echoes and we\\'ve not seen it, add 1 to ans\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2418959,
                "title": "python-just-brute-force",
                "content": "```\\n    def distinctEchoSubstrings(self, text):\\n        seen = set()\\n        for i in range(len(text)):\\n            for j in range(i+1, len(text), 2):\\n                s = text[i:(i+j)//2+1]\\n                if s not in seen and s == text[(i+j)//2+1:j+1]:\\n                    seen.add(s)\\n        return len(seen)\\n```",
                "solutionTags": [],
                "code": "```\\n    def distinctEchoSubstrings(self, text):\\n        seen = set()\\n        for i in range(len(text)):\\n            for j in range(i+1, len(text), 2):\\n                s = text[i:(i+j)//2+1]\\n                if s not in seen and s == text[(i+j)//2+1:j+1]:\\n                    seen.add(s)\\n        return len(seen)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2392957,
                "title": "rust-solution-using-rolling-hash",
                "content": "We can compare two strings O(1) using the rolling hash.\\nThe max string size is 2000, it\\'s enough small to memorize all substring hash.\\n\\n```\\nuse std::collections::*;\\nimpl Solution {\\n    pub fn distinct_echo_substrings(text: String) -> i32 {\\n        const MOD:usize = 2usize.pow(61)-1;  // big prime number\\n\\n        let n = text.len();\\n        let s = text.chars().collect::<Vec<char>>();\\n        let s = s.into_iter().map(|v| (v as u8 - \\'a\\' as u8) as usize).collect::<Vec<usize>>();\\n\\n        let value_pattern = 26; // a-z\\n        // memo[start][end]\\n        let mut memo = vec![vec![0;n];n];\\n        for i in 0..n {\\n            let mut hash = 0usize;\\n            for j in i..n {\\n                let c = s[j];\\n                hash = (hash * (value_pattern+1) + c+1) % MOD;\\n                memo[i][j] = hash;\\n            }\\n        }\\n\\n        let mut set = HashSet::new();\\n        for firat_start in 0..n {\\n            for first_end in firat_start..n {\\n                let len = first_end - firat_start + 1;\\n                let second_start = first_end+1;\\n                let second_end = first_end+len;\\n                if n <= second_end { break }\\n                let v1 = memo[firat_start][first_end];\\n                let v2 = memo[second_start][second_end];\\n                if v1 == v2 {\\n                    set.insert(v1);\\n                }\\n            }\\n        }\\n\\n        set.len() as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Rolling Hash"
                ],
                "code": "```\\nuse std::collections::*;\\nimpl Solution {\\n    pub fn distinct_echo_substrings(text: String) -> i32 {\\n        const MOD:usize = 2usize.pow(61)-1;  // big prime number\\n\\n        let n = text.len();\\n        let s = text.chars().collect::<Vec<char>>();\\n        let s = s.into_iter().map(|v| (v as u8 - \\'a\\' as u8) as usize).collect::<Vec<usize>>();\\n\\n        let value_pattern = 26; // a-z\\n        // memo[start][end]\\n        let mut memo = vec![vec![0;n];n];\\n        for i in 0..n {\\n            let mut hash = 0usize;\\n            for j in i..n {\\n                let c = s[j];\\n                hash = (hash * (value_pattern+1) + c+1) % MOD;\\n                memo[i][j] = hash;\\n            }\\n        }\\n\\n        let mut set = HashSet::new();\\n        for firat_start in 0..n {\\n            for first_end in firat_start..n {\\n                let len = first_end - firat_start + 1;\\n                let second_start = first_end+1;\\n                let second_end = first_end+len;\\n                if n <= second_end { break }\\n                let v1 = memo[firat_start][first_end];\\n                let v2 = memo[second_start][second_end];\\n                if v1 == v2 {\\n                    set.insert(v1);\\n                }\\n            }\\n        }\\n\\n        set.len() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2351050,
                "title": "easy-c-solution-two-pointer",
                "content": "Time complexity : O ( N ^ 3 )\\nSpace complexity : O ( N ) \\n```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        set<string> s ;\\n        int n = text.size() ;\\n        \\n        for(int len = 1 ; len <= n / 2 ; len++){\\n            int cnt = 0 ;\\n            for(int l = 0 , r = len ; r < n ; l++,r++){\\n                if ( text[l] == text[r] ){\\n                    cnt++;\\n                }\\n                else cnt = 0;\\n                \\n                if( cnt == len ){\\n                    string t = text.substr(l - len + 1, len);\\n                    s.insert(t);\\n                    cnt--;\\n                }\\n            }\\n        }\\n        \\n        return s.size();\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        set<string> s ;\\n        int n = text.size() ;\\n        \\n        for(int len = 1 ; len <= n / 2 ; len++){\\n            int cnt = 0 ;\\n            for(int l = 0 , r = len ; r < n ; l++,r++){\\n                if ( text[l] == text[r] ){\\n                    cnt++;\\n                }\\n                else cnt = 0;\\n                \\n                if( cnt == len ){\\n                    string t = text.substr(l - len + 1, len);\\n                    s.insert(t);\\n                    cnt--;\\n                }\\n            }\\n        }\\n        \\n        return s.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2316787,
                "title": "java-simple-working-solution-with-comments",
                "content": "```\\nimport java.util.Map.Entry;\\npublic class Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        HashSet<String> ans = new HashSet<>();\\n        int length = text.length();\\n\\n        HashMap<Character, ArrayList<Integer>> characterPositionMap = new HashMap<>(); // Map to store the position of each characters                                                                                       \\n\\n        for (int i = 0; i < length; i++) {\\n            characterPositionMap.computeIfAbsent(text.charAt(i), x -> new ArrayList<>()).add(i);\\n        }\\n\\n        for (Entry<Character, ArrayList<Integer>> entry : characterPositionMap.entrySet()) { // Iterate through each character in the map\\n            ArrayList<Integer> positions = entry.getValue(); // Get the positions of the character\\n            for (int i = 0; i < positions.size(); i++) { // Iterate through each position of the character\\n                int first = positions.get(i); // Get the first position of the character\\n                for (int j = i + 1; j < positions.size(); j++) { // Iterate through each position of the remaining character\\n                    int mid = positions.get(j);// Get the second position of the character\\n                    int last = mid + mid - first; // Get the last position of the character\\n                    String subString1 = text.substring(first, mid);// Get the first substring of the character\\n                    if (last <= length) {// Check if the last position is within the length of the string\\n                        String subString2 = text.substring(mid, last);// Get the second substring of the character\\n                        if (subString1.equals(subString2)) {// Check if the two substrings are equal\\n                            ans.add(subString1);// Add the substring to the set\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans.size();// Return the size of the set\\n\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.Map.Entry;\\npublic class Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        HashSet<String> ans = new HashSet<>();\\n        int length = text.length();\\n\\n        HashMap<Character, ArrayList<Integer>> characterPositionMap = new HashMap<>(); // Map to store the position of each characters                                                                                       \\n\\n        for (int i = 0; i < length; i++) {\\n            characterPositionMap.computeIfAbsent(text.charAt(i), x -> new ArrayList<>()).add(i);\\n        }\\n\\n        for (Entry<Character, ArrayList<Integer>> entry : characterPositionMap.entrySet()) { // Iterate through each character in the map\\n            ArrayList<Integer> positions = entry.getValue(); // Get the positions of the character\\n            for (int i = 0; i < positions.size(); i++) { // Iterate through each position of the character\\n                int first = positions.get(i); // Get the first position of the character\\n                for (int j = i + 1; j < positions.size(); j++) { // Iterate through each position of the remaining character\\n                    int mid = positions.get(j);// Get the second position of the character\\n                    int last = mid + mid - first; // Get the last position of the character\\n                    String subString1 = text.substring(first, mid);// Get the first substring of the character\\n                    if (last <= length) {// Check if the last position is within the length of the string\\n                        String subString2 = text.substring(mid, last);// Get the second substring of the character\\n                        if (subString1.equals(subString2)) {// Check if the two substrings are equal\\n                            ans.add(subString1);// Add the substring to the set\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans.size();// Return the size of the set\\n\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2304171,
                "title": "c-solution-based-on-sliding-window-and-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        \\n        int n = text.size();\\n        int max_sliding;\\n        if (n % 2 == 0){\\n            max_sliding = n;\\n        }\\n        else{\\n            max_sliding = n - 1;\\n        }\\n        char max_c = text[0], min_c = text[0];\\n        for (int i = 1; i < n; i++){\\n            max_c = max(max_c, text[i]);\\n            min_c = min(min_c, text[i]);\\n        }\\n        if (max_c == min_c){\\n            return max_sliding / 2;\\n        }\\n        \\n        unordered_set<string> records;\\n        for (int sliding = max_sliding; sliding >= 2; sliding = sliding - 2){\\n            int half_sliding = sliding / 2;\\n            for (int start = 0; start <= n - sliding; start++){\\n                int back = start + sliding - 1;\\n                int middle = start + half_sliding - 1;\\n                // [start, back], whether the substring is echo?\\n                bool is_echo = true;\\n                for (int i = 0; i < half_sliding; i++){\\n                    if (text[start + i] != text[middle + 1 + i]){\\n                        is_echo = false;\\n                        break;\\n                    }\\n                }\\n                if (is_echo){\\n                    string sub = text.substr(start, half_sliding);\\n                    if (records.count(sub) == 0){\\n                        records.insert(sub);       \\n                    }                    \\n                }\\n            }\\n        }\\n        return records.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        \\n        int n = text.size();\\n        int max_sliding;\\n        if (n % 2 == 0){\\n            max_sliding = n;\\n        }\\n        else{\\n            max_sliding = n - 1;\\n        }\\n        char max_c = text[0], min_c = text[0];\\n        for (int i = 1; i < n; i++){\\n            max_c = max(max_c, text[i]);\\n            min_c = min(min_c, text[i]);\\n        }\\n        if (max_c == min_c){\\n            return max_sliding / 2;\\n        }\\n        \\n        unordered_set<string> records;\\n        for (int sliding = max_sliding; sliding >= 2; sliding = sliding - 2){\\n            int half_sliding = sliding / 2;\\n            for (int start = 0; start <= n - sliding; start++){\\n                int back = start + sliding - 1;\\n                int middle = start + half_sliding - 1;\\n                // [start, back], whether the substring is echo?\\n                bool is_echo = true;\\n                for (int i = 0; i < half_sliding; i++){\\n                    if (text[start + i] != text[middle + 1 + i]){\\n                        is_echo = false;\\n                        break;\\n                    }\\n                }\\n                if (is_echo){\\n                    string sub = text.substr(start, half_sliding);\\n                    if (records.count(sub) == 0){\\n                        records.insert(sub);       \\n                    }                    \\n                }\\n            }\\n        }\\n        return records.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260249,
                "title": "python-simple-maths",
                "content": "\\n    def distinctEchoSubstrings(self, text):\\n        count, seen = 0, set()\\n        \\n        for k in range(1, len(text)//2 + 1):\\n            for i in range(len(text) - k):\\n                s1 = text[i:i+k]\\n                s2 = text[i+k:i+2*k]\\n                \\n                if s1 == s2 and s1 not in seen:\\n                    count += 1\\n                    seen.add(s1)\\n                    \\n            seen = set()\\n\\t\\t\\n        return count",
                "solutionTags": [],
                "code": "\\n    def distinctEchoSubstrings(self, text):\\n        count, seen = 0, set()\\n        \\n        for k in range(1, len(text)//2 + 1):\\n            for i in range(len(text) - k):\\n                s1 = text[i:i+k]\\n                s2 = text[i+k:i+2*k]\\n                \\n                if s1 == s2 and s1 not in seen:\\n                    count += 1\\n                    seen.add(s1)\\n                    \\n            seen = set()\\n\\t\\t\\n        return count",
                "codeTag": "Python3"
            },
            {
                "id": 2245656,
                "title": "roling-hash-prefix-sum-easy-to-understand",
                "content": "Check Echo string of Every length 1 2 3 ........... n\\nThen caluculate the hash value of every substring of length L. \\nS[0],S[1].....S[L].........S[2*L-1] ..............S[n-1]\\nif hash value of S[2L-1]==S[L] then we got the ECHO string and insert the hash value in set, then return the size of set.\\n*\\n**Then add all the length of Echo string and return it:**\\n\\n\\n\\t\\t\\t\\t\\t\\tclass Solution {\\n\\t\\t\\t\\t\\t\\tpublic:\\n\\t\\t\\t\\t\\t\\t\\tconst long long int p=1299827;\\n\\t\\t\\t\\t\\t\\t\\tconst long long int mod=1e11+7;\\n\\t\\t\\t\\t\\t\\t\\tint fn(int l,string &s){\\n\\t\\t\\t\\t\\t\\t\\t\\tlong long int crr_hash=0,pow=1,tmp;\\n\\t\\t\\t\\t\\t\\t\\t\\tint n=s.size();\\n\\t\\t\\t\\t\\t\\t\\t\\t set<long long int>ans;\\n\\t\\t\\t\\t\\t\\t\\t\\tvector<long long int> v(n);\\n\\t\\t\\t\\t\\t\\t\\t\\tfor(int i=0;i<(l);i++){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcrr_hash=(crr_hash*p)%mod;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcrr_hash+=(s[i]-\\'a\\'+1);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcrr_hash%=mod;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(i!=l-1) pow=(pow*p)%mod;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tv[i]=crr_hash;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tv[l-1]=crr_hash;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tfor(int i=l;i<n;i++){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcrr_hash+=mod;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcrr_hash-=((s[i-l]-\\'a\\'+1)*(pow))%mod;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcrr_hash+=mod; crr_hash%=mod;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcrr_hash=(crr_hash*p)%mod;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcrr_hash+=(s[i]-\\'a\\'+1);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcrr_hash%=mod;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tv[i]=crr_hash;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(i-2*l+1>=0){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tlong long int s1=0,s2=0;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ts1=v[i];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ts2=v[i-l];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(s1==s2) { ans.insert(s1);}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\treturn ans.size();\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tint distinctEchoSubstrings(string s) {\\n\\t\\t\\t\\t\\t\\t\\t\\tint n=s.size();\\n\\t\\t\\t\\t\\t\\t\\t\\tint ans=0;\\n\\t\\t\\t\\t\\t\\t\\t\\tfor(int i=1;i<=n/2;i++){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tint k=fn(i,s);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tans+=k;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// cout<<k<<\" \";\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t};",
                "solutionTags": [
                    "Rolling Hash"
                ],
                "code": "class Solution {\\n\\t\\t\\t\\t\\t\\tpublic:\\n\\t\\t\\t\\t\\t\\t\\tconst long long int p=1299827;\\n\\t\\t\\t\\t\\t\\t\\tconst long long int mod=1e11+7;\\n\\t\\t\\t\\t\\t\\t\\tint fn(int l,string &s){\\n\\t\\t\\t\\t\\t\\t\\t\\tlong long int crr_hash=0,pow=1,tmp;\\n\\t\\t\\t\\t\\t\\t\\t\\tint n=s.size();\\n\\t\\t\\t\\t\\t\\t\\t\\t set<long long int>ans;\\n\\t\\t\\t\\t\\t\\t\\t\\tvector<long long int> v(n);\\n\\t\\t\\t\\t\\t\\t\\t\\tfor(int i=0;i<(l);i++){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcrr_hash=(crr_hash*p)%mod;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcrr_hash+=(s[i]-\\'a\\'+1);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcrr_hash%=mod;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(i!=l-1) pow=(pow*p)%mod;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tv[i]=crr_hash;\\n\\t\\t\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2207514,
                "title": "rabin-karp-map-set-self-explanatory-easy-code-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        int n = text.size();\\n        unordered_set<string> st;\\n        int ans = 0;\\n        for (int i = 1; i < n; i++)\\n            if (text[i - 1] == text[i]) {\\n                string h;\\n                h.push_back(text[i - 1]);\\n                st.insert(h);\\n            }\\n        unordered_map<long long int, int> mp;\\n        for (int k = 2; 2 * k <= n; k++) {\\n            long long int temp1 = 0, temp2 = 0, t = 1, p = 31, mod = 1000000007;\\n            int i = 0, j = k - 1, r = 2 * k - 1;\\n            for (int y = 0; y < k; y++) {\\n                temp1 = temp1 + t * (text[y] - \\'a\\' + 1);\\n                temp2 = temp2 + t * (text[y + k] - \\'a\\' + 1);\\n                temp1 = temp1 % mod;\\n                temp2 = temp2 % mod;\\n                t = t * p;\\n                t = t % mod;\\n            }\\n            t /= p;\\n            while (r < n) {\\n                if (temp1 == temp2 && mp[temp1] == 0) {\\n                    mp[temp1]++;\\n                    // cout << text.substr(i, k) << endl;\\n                    string w1 = text.substr(i, k) , w2 = text.substr(i + k, k);\\n                    if (w1 == w2)\\n                        st.insert(w1);\\n                }\\n                // cout << \"temp1 = \" << temp1 << \" temp2 = \" << temp2 << \" s1 = \" << text.substr(i, k) << \" s2 = \" << text.substr(i + k, k) << endl;\\n                \\n                temp1 -= (text[i] - \\'a\\' + 1);\\n                temp2 -= (text[i + k] - \\'a\\' + 1);\\n                // cout << \"1 temp1 = \"<< temp1 << \" temp2 = \" << temp2 << endl;\\n                temp1 /= p;\\n                temp2 /= p;\\n                // cout << \"2 temp1 = \"<< temp1 << \" temp2 = \" << temp2 << endl;\\n                \\n                i++;\\n                j++;\\n                r++;\\n                \\n                if (r < n) {\\n                    temp1 += t * (text[j] - \\'a\\' + 1);\\n                    temp2 += t * (text[r] - \\'a\\' + 1);\\n                    // cout << \"3 - temp1add = \"<< t * (text[j] - \\'a\\' + 1) << \" temp2add = \" << t * (text[r] - \\'a\\' + 1) << endl;\\n                    temp1 %= mod;\\n                    temp2 %= mod;\\n                }\\n            }\\n        }\\n        // for (string g : st)\\n        //     cout << g << endl;\\n        return st.size();// + mp.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        int n = text.size();\\n        unordered_set<string> st;\\n        int ans = 0;\\n        for (int i = 1; i < n; i++)\\n            if (text[i - 1] == text[i]) {\\n                string h;\\n                h.push_back(text[i - 1]);\\n                st.insert(h);\\n            }\\n        unordered_map<long long int, int> mp;\\n        for (int k = 2; 2 * k <= n; k++) {\\n            long long int temp1 = 0, temp2 = 0, t = 1, p = 31, mod = 1000000007;\\n            int i = 0, j = k - 1, r = 2 * k - 1;\\n            for (int y = 0; y < k; y++) {\\n                temp1 = temp1 + t * (text[y] - \\'a\\' + 1);\\n                temp2 = temp2 + t * (text[y + k] - \\'a\\' + 1);\\n                temp1 = temp1 % mod;\\n                temp2 = temp2 % mod;\\n                t = t * p;\\n                t = t % mod;\\n            }\\n            t /= p;\\n            while (r < n) {\\n                if (temp1 == temp2 && mp[temp1] == 0) {\\n                    mp[temp1]++;\\n                    // cout << text.substr(i, k) << endl;\\n                    string w1 = text.substr(i, k) , w2 = text.substr(i + k, k);\\n                    if (w1 == w2)\\n                        st.insert(w1);\\n                }\\n                // cout << \"temp1 = \" << temp1 << \" temp2 = \" << temp2 << \" s1 = \" << text.substr(i, k) << \" s2 = \" << text.substr(i + k, k) << endl;\\n                \\n                temp1 -= (text[i] - \\'a\\' + 1);\\n                temp2 -= (text[i + k] - \\'a\\' + 1);\\n                // cout << \"1 temp1 = \"<< temp1 << \" temp2 = \" << temp2 << endl;\\n                temp1 /= p;\\n                temp2 /= p;\\n                // cout << \"2 temp1 = \"<< temp1 << \" temp2 = \" << temp2 << endl;\\n                \\n                i++;\\n                j++;\\n                r++;\\n                \\n                if (r < n) {\\n                    temp1 += t * (text[j] - \\'a\\' + 1);\\n                    temp2 += t * (text[r] - \\'a\\' + 1);\\n                    // cout << \"3 - temp1add = \"<< t * (text[j] - \\'a\\' + 1) << \" temp2add = \" << t * (text[r] - \\'a\\' + 1) << endl;\\n                    temp1 %= mod;\\n                    temp2 %= mod;\\n                }\\n            }\\n        }\\n        // for (string g : st)\\n        //     cout << g << endl;\\n        return st.size();// + mp.size();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2195128,
                "title": "cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        \\n        int p=31;\\n        int m=1e9+9;\\n        int len=text.size();\\n        \\n        vector<long long int> p_pow(len,1);\\n        for(int i=1;i<len;i++)\\n            p_pow[i]=(p_pow[i-1]*p)%m;\\n        \\n        vector<long long int> h(len+1,0);\\n        for(int i=0;i<len;i++)\\n            h[i+1]=(h[i]+(text[i]-\\'a\\'+1)*p_pow[i])%m;\\n        \\n       unordered_set<string>st;\\n        for(int i=0;i<len;i++)\\n        {\\n            string s;\\n            for(int j=i;j<len;j++)\\n            {\\n                s+=text[j];\\n                if(s.size()%2==0)\\n                {\\n                    int len1=s.size()/2;\\n                    long long int h1=(h[i+len1]+m-h[i])%m;\\n                    long long int h2=(h[j+1]+m-h[i+len1])%m;\\n                \\n                    if(h2== (h1*p_pow[len1])%m)\\n                        st.insert(s);\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        \\n        int p=31;\\n        int m=1e9+9;\\n        int len=text.size();\\n        \\n        vector<long long int> p_pow(len,1);\\n        for(int i=1;i<len;i++)\\n            p_pow[i]=(p_pow[i-1]*p)%m;\\n        \\n        vector<long long int> h(len+1,0);\\n        for(int i=0;i<len;i++)\\n            h[i+1]=(h[i]+(text[i]-\\'a\\'+1)*p_pow[i])%m;\\n        \\n       unordered_set<string>st;\\n        for(int i=0;i<len;i++)\\n        {\\n            string s;\\n            for(int j=i;j<len;j++)\\n            {\\n                s+=text[j];\\n                if(s.size()%2==0)\\n                {\\n                    int len1=s.size()/2;\\n                    long long int h1=(h[i+len1]+m-h[i])%m;\\n                    long long int h2=(h[j+1]+m-h[i+len1])%m;\\n                \\n                    if(h2== (h1*p_pow[len1])%m)\\n                        st.insert(s);\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2178921,
                "title": "string-hashing-solution",
                "content": "class Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        const int p=31;\\n        const long long m=1e9+9;\\n        int sz=text.size();\\n        const int SZ=2005;\\n        long long h[SZ];\\n        long long p_pow[SZ];\\n        p_pow[0]=1;\\n        for (int i=1;i<SZ;i++){\\n            p_pow[i]=(p_pow[i-1]*p)%m;\\n        }\\n        for (int i=0;i<sz;i++){\\n            if (i==0){\\n                h[i]=text[0]-\\'a\\'+1;\\n            }else{\\n                h[i]=h[i-1]+(text[i]-\\'a\\'+1)*p_pow[i];\\n                h[i]%=m;\\n            }\\n        }\\n        int res=0;\\n        for (int l=1;l<=sz/2;l++){\\n            set<long long> nums;\\n            for (int i=0;i+2*l-1<sz;i++){\\n                //i,i+l-1\\n                //i+l,i+l+l-1\\n                long long h1=(h[i+l-1]-(i>=1?h[i-1]:0)+m)%m;\\n                long long h2=(h[i+2*l-1]-h[i+l-1]+m)%m;\\n                if ((h1*p_pow[l])%m==h2){\\n                    nums.insert((h1*p_pow[sz-i])%m);\\n                }\\n            }\\n            res+=nums.size();\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        const int p=31;\\n        const long long m=1e9+9;\\n        int sz=text.size();\\n        const int SZ=2005;\\n        long long h[SZ];\\n        long long p_pow[SZ];\\n        p_pow[0]=1;\\n        for (int i=1;i<SZ;i++){\\n            p_pow[i]=(p_pow[i-1]*p)%m;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2133981,
                "title": "c-rolling-hash-solution",
                "content": "```\\nclass hash_substring\\n{\\n    typedef unsigned long long hash1;\\n    const hash1 BASE = 137;\\n    vector<hash1>h,hPow;\\n    int N;\\n    string S;\\n    public:\\n    hash_substring( string a )\\n    {\\n        S = a;\\n        N = S.length();\\n        h.resize(N+1);\\n        hPow.resize(N+1);\\n        \\n        hPow[0] = 1;\\n        for (int i = 1; i <= N; ++i)\\n            hPow[i] = hPow[i - 1] * BASE;\\n\\n        h[N] = 0;\\n        for (int i = N - 1; i >= 0; --i)\\n            h[i] = h[i + 1] * BASE + S[i];\\n    }\\n    \\n    hash1 getHash( int lo , int size )\\n    {\\n        return (h[lo] - h[(lo) + (size)] * hPow[size]);\\n    }\\n        \\n};\\n\\nbool check( hash_substring &h , int l , int r , int x , int y)\\n{\\n    return h.getHash(l,r-l+1) == h.getHash(x,y-x+1);\\n}\\n\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        hash_substring h(text);\\n        unordered_map<int,int>m;\\n        int ans=0;\\n        for(int i=0;i<text.length();i++)\\n        {\\n            for(int j=i+1;j<text.length();j++)\\n            {\\n                if((j-i+1)%2)\\n                    continue;\\n                int mid=(i+j)/2;\\n                if(check(h,i,mid,mid+1,j))\\n                {\\n                    int val=h.getHash(i,j-i+1);\\n                    if(!m[val])\\n                    {\\n                        m[val]++,ans++;\\n                        \\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Rolling Hash"
                ],
                "code": "```\\nclass hash_substring\\n{\\n    typedef unsigned long long hash1;\\n    const hash1 BASE = 137;\\n    vector<hash1>h,hPow;\\n    int N;\\n    string S;\\n    public:\\n    hash_substring( string a )\\n    {\\n        S = a;\\n        N = S.length();\\n        h.resize(N+1);\\n        hPow.resize(N+1);\\n        \\n        hPow[0] = 1;\\n        for (int i = 1; i <= N; ++i)\\n            hPow[i] = hPow[i - 1] * BASE;\\n\\n        h[N] = 0;\\n        for (int i = N - 1; i >= 0; --i)\\n            h[i] = h[i + 1] * BASE + S[i];\\n    }\\n    \\n    hash1 getHash( int lo , int size )\\n    {\\n        return (h[lo] - h[(lo) + (size)] * hPow[size]);\\n    }\\n        \\n};\\n\\nbool check( hash_substring &h , int l , int r , int x , int y)\\n{\\n    return h.getHash(l,r-l+1) == h.getHash(x,y-x+1);\\n}\\n\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        hash_substring h(text);\\n        unordered_map<int,int>m;\\n        int ans=0;\\n        for(int i=0;i<text.length();i++)\\n        {\\n            for(int j=i+1;j<text.length();j++)\\n            {\\n                if((j-i+1)%2)\\n                    continue;\\n                int mid=(i+j)/2;\\n                if(check(h,i,mid,mid+1,j))\\n                {\\n                    int val=h.getHash(i,j-i+1);\\n                    if(!m[val])\\n                    {\\n                        m[val]++,ans++;\\n                        \\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111617,
                "title": "clean-javascript-solution",
                "content": "```\\nfunction distinctEchoSubstrings(w, ans = new Set()) {\\n    for (let i = 0; i< w.length - 2; i++) {\\n        for (let size = 1; size <= (w.length - i) / 2; size++) {\\n            if (w.substr(i, size) === w.substr(i + size, size)) {\\n                ans.add(w.substr(i, size))\\n            }\\n        }\\n    }\\n    return ans.size\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction distinctEchoSubstrings(w, ans = new Set()) {\\n    for (let i = 0; i< w.length - 2; i++) {\\n        for (let size = 1; size <= (w.length - i) / 2; size++) {\\n            if (w.substr(i, size) === w.substr(i + size, size)) {\\n                ans.add(w.substr(i, size))\\n            }\\n        }\\n    }\\n    return ans.size\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2083432,
                "title": "simple-hashing-on-string-rabin-karp",
                "content": "```\\n#define ll long\\n\\nclass Solution {\\npublic:\\n    \\n    // 1-indexed string needed\\n    struct Hashs\\n    {\\n        vector<ll> hash;\\n        vector<ll> pows;\\n        ll P;\\n        ll mod;\\n\\n        Hashs() {}\\n\\n        Hashs(string &s,ll P,ll M) : P(P), mod(M)\\n        {\\n            ll n=s.size();\\n            pows.resize(n+1, 0);\\n            hash.resize(n+1, 0);\\n            pows[0] = 1;\\n            for(ll i=1;i<=n;i++)\\n            {\\n                pows[i]=(pows[i-1]*P)%mod;\\n                hash[i]=(hash[i-1]*P+(s[i-1]-\\'a\\'+1))%mod;\\n            }\\n        }\\n\\n        ll get_hash(ll l,ll r)  // [l,r]\\n        {\\n            return ( hash[r] - (hash[l-1]*pows[r-l+1])%mod + mod ) % mod;\\n        }\\n    };\\n\\n\\n\\n    int distinctEchoSubstrings(string s) \\n    {\\n        int n=s.length();\\n        Hashs hs(s,31,1e9+7);\\n        int ans=0;\\n        map<int,int> mp;\\n        for(int i=1;i<=n;i++)\\n            for(int j=i+1;j<=n;j+=2)\\n                if(hs.get_hash(i,i+(j-i)/2)==hs.get_hash(i+(j-i)/2+1,j) && !mp.count(hs.get_hash(i,i+(j-i)/2)))\\n                    ans++,mp[hs.get_hash(i,i+(j-i)/2)]++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define ll long\\n\\nclass Solution {\\npublic:\\n    \\n    // 1-indexed string needed\\n    struct Hashs\\n    {\\n        vector<ll> hash;\\n        vector<ll> pows;\\n        ll P;\\n        ll mod;\\n\\n        Hashs() {}\\n\\n        Hashs(string &s,ll P,ll M) : P(P), mod(M)\\n        {\\n            ll n=s.size();\\n            pows.resize(n+1, 0);\\n            hash.resize(n+1, 0);\\n            pows[0] = 1;\\n            for(ll i=1;i<=n;i++)\\n            {\\n                pows[i]=(pows[i-1]*P)%mod;\\n                hash[i]=(hash[i-1]*P+(s[i-1]-\\'a\\'+1))%mod;\\n            }\\n        }\\n\\n        ll get_hash(ll l,ll r)  // [l,r]\\n        {\\n            return ( hash[r] - (hash[l-1]*pows[r-l+1])%mod + mod ) % mod;\\n        }\\n    };\\n\\n\\n\\n    int distinctEchoSubstrings(string s) \\n    {\\n        int n=s.length();\\n        Hashs hs(s,31,1e9+7);\\n        int ans=0;\\n        map<int,int> mp;\\n        for(int i=1;i<=n;i++)\\n            for(int j=i+1;j<=n;j+=2)\\n                if(hs.get_hash(i,i+(j-i)/2)==hs.get_hash(i+(j-i)/2+1,j) && !mp.count(hs.get_hash(i,i+(j-i)/2)))\\n                    ans++,mp[hs.get_hash(i,i+(j-i)/2)]++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2067558,
                "title": "c-rolling-hash-explanation",
                "content": "```\\nconst int64_t p = 31;\\nconst int64_t MOD = 1e9+9;\\n    \\nclass Solution {\\npublic:\\n    \\n    int distinctEchoSubstrings(string text) {\\n        int n = (int)text.length();\\n        vector<int64_t> pow(n);\\n        vector<int64_t> hash(n);\\n        pow[0] = 1;\\n        for (int i = 1; i < n; i++) {\\n            pow[i] = (pow[i-1] * p) % MOD;\\n        }\\n        hash[0] = text[0];\\n        for (int i = 1; i < n; i++) {\\n            hash[i] = (hash[i-1] + text[i]*pow[i]) % MOD;\\n        }\\n        \\n        unordered_set<int64_t> seen;\\n        // For each length\\n        for (int len = 2; len <= n; len += 2) {\\n            for (int l = 0; l <= n-len; l++) {\\n                int r = l + len - 1;\\n                int a = l, b = a + len/2 - 1;       // First half\\n                int x = a + len/2, y = r;           // Second half\\n                \\n                int64_t part1Hash = (hash[b] - (a-1 >= 0 ? hash[a-1] : 0) + MOD) % MOD;\\n                part1Hash = (part1Hash * pow[n-1-a]) % MOD;\\n                \\n                int64_t part2Hash = (hash[y] - hash[x-1] + MOD) % MOD;\\n                part2Hash = (part2Hash * pow[n-1-x]) % MOD;\\n                \\n                if (part1Hash == part2Hash) \\n                    seen.insert(part1Hash);\\n            }\\n        }\\n        return (int)seen.size();\\n    }\\n};\\n\\n/**\\n\\nFact 1: We have to check all even length substrings 2, 4, 6, 8, 10, 12...\\nFact 2: For each length traverse the string using sliding window. \\nSo overall complexity is O(n^2). But....\\n\\nSuppose len = 6. \\nYou got l = 0, r = 5\\nString = abcabc\\n\\nNow question is how to check \"abcabc\" satisfy given conditon. It would take O(n) time if you manually check first half == second half.\\n\\nSo leverage rolling hash. At first find rolling hash of all prefix of text.\\n         \\n         L                   R\\n 0   1   2   3   4   5   6   7   8\\n a   b   c   a   b   c   a   b   c\\np^0 p^1 p^2 p^3 p^4 p^5 p^6 p^7 p^8\\n       |           |           |\\n       |           |           |\\nDivide by p^2 for first half\\nDivide by p^5 for second half\\n\\n        p^0 p^1 p^2 p^0 p^1 p^2\\n\\n\\n**/\\n```",
                "solutionTags": [
                    "Rolling Hash"
                ],
                "code": "```\\nconst int64_t p = 31;\\nconst int64_t MOD = 1e9+9;\\n    \\nclass Solution {\\npublic:\\n    \\n    int distinctEchoSubstrings(string text) {\\n        int n = (int)text.length();\\n        vector<int64_t> pow(n);\\n        vector<int64_t> hash(n);\\n        pow[0] = 1;\\n        for (int i = 1; i < n; i++) {\\n            pow[i] = (pow[i-1] * p) % MOD;\\n        }\\n        hash[0] = text[0];\\n        for (int i = 1; i < n; i++) {\\n            hash[i] = (hash[i-1] + text[i]*pow[i]) % MOD;\\n        }\\n        \\n        unordered_set<int64_t> seen;\\n        // For each length\\n        for (int len = 2; len <= n; len += 2) {\\n            for (int l = 0; l <= n-len; l++) {\\n                int r = l + len - 1;\\n                int a = l, b = a + len/2 - 1;       // First half\\n                int x = a + len/2, y = r;           // Second half\\n                \\n                int64_t part1Hash = (hash[b] - (a-1 >= 0 ? hash[a-1] : 0) + MOD) % MOD;\\n                part1Hash = (part1Hash * pow[n-1-a]) % MOD;\\n                \\n                int64_t part2Hash = (hash[y] - hash[x-1] + MOD) % MOD;\\n                part2Hash = (part2Hash * pow[n-1-x]) % MOD;\\n                \\n                if (part1Hash == part2Hash) \\n                    seen.insert(part1Hash);\\n            }\\n        }\\n        return (int)seen.size();\\n    }\\n};\\n\\n/**\\n\\nFact 1: We have to check all even length substrings 2, 4, 6, 8, 10, 12...\\nFact 2: For each length traverse the string using sliding window. \\nSo overall complexity is O(n^2). But....\\n\\nSuppose len = 6. \\nYou got l = 0, r = 5\\nString = abcabc\\n\\nNow question is how to check \"abcabc\" satisfy given conditon. It would take O(n) time if you manually check first half == second half.\\n\\nSo leverage rolling hash. At first find rolling hash of all prefix of text.\\n         \\n         L                   R\\n 0   1   2   3   4   5   6   7   8\\n a   b   c   a   b   c   a   b   c\\np^0 p^1 p^2 p^3 p^4 p^5 p^6 p^7 p^8\\n       |           |           |\\n       |           |           |\\nDivide by p^2 for first half\\nDivide by p^5 for second half\\n\\n        p^0 p^1 p^2 p^0 p^1 p^2\\n\\n\\n**/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1989341,
                "title": "fastest-js-solution",
                "content": "```\\n/**\\n * @param {string} text\\n * @return {number}\\n */\\nvar distinctEchoSubstrings = function(text) {\\n    const result = new Set();\\n    for (let i = 0; i< text.length - 2; i++) {\\n        \\n        for (let length = 1; length <= (text.length - i) / 2; length++) {\\n            if (text.substr(i, length) === text.substr(i+length, length)) {\\n                result.add(text.substr(i, length));\\n            }\\n        }\\n    }\\n    return result.size;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} text\\n * @return {number}\\n */\\nvar distinctEchoSubstrings = function(text) {\\n    const result = new Set();\\n    for (let i = 0; i< text.length - 2; i++) {\\n        \\n        for (let length = 1; length <= (text.length - i) / 2; length++) {\\n            if (text.substr(i, length) === text.substr(i+length, length)) {\\n                result.add(text.substr(i, length));\\n            }\\n        }\\n    }\\n    return result.size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1766331,
                "title": "c-brute-force-solution",
                "content": "```\\n\\tpublic int DistinctEchoSubstrings(string text) {\\n        var hashSet = new HashSet<string>();\\n        for (int n = 1; n <= text.Length/2; n++) {\\n            for (int i=0; i<=text.Length-2*n; i++) {\\n                if (AreEqualSubstrings(text, i, n+i, n)) // compare current and next substrings of length n\\n                    hashSet.Add(text.Substring(i, n));\\n            }\\n        }\\n        return hashSet.Count;\\n    }\\n    \\n    bool AreEqualSubstrings(string text, int start1, int start2, int length) {\\n        for (int i=0; i<length; i++) {\\n            if (text[start1+i] != text[start2+i])\\n                return false;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int DistinctEchoSubstrings(string text) {\\n        var hashSet = new HashSet<string>();\\n        for (int n = 1; n <= text.Length/2; n++) {\\n            for (int i=0; i<=text.Length-2*n; i++) {\\n                if (AreEqualSubstrings(text, i, n+i, n)) // compare current and next substrings of length n\\n                    hashSet.Add(text.Substring(i, n));\\n            }\\n        }\\n        return hashSet.Count;\\n    }\\n    \\n    bool AreEqualSubstrings(string text, int start1, int start2, int length) {\\n        for (int i=0; i<length; i++) {\\n            if (text[start1+i] != text[start2+i])\\n                return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1754656,
                "title": "python-brute-force",
                "content": "\\n```\\nclass Solution:\\n    def distinctEchoSubstrings(self, s: str) -> int:\\n        hash=set()\\n        n=len(s)\\n        for i in range(n):\\n            for j in range(i):\\n                \\n                if (i-j)&1==1:\\n                    \\n                    k=(i-j)//2\\n                    \\n                    if s[j:j+k+1]==s[j+k+1:i+1]:\\n                        hash.add(s[j:j+k+1]+s[j+k+1:i+1])\\n        return len(hash)\\n                    \\n                    \\n                    \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def distinctEchoSubstrings(self, s: str) -> int:\\n        hash=set()\\n        n=len(s)\\n        for i in range(n):\\n            for j in range(i):\\n                \\n                if (i-j)&1==1:\\n                    \\n                    k=(i-j)//2\\n                    \\n                    if s[j:j+k+1]==s[j+k+1:i+1]:\\n                        hash.add(s[j:j+k+1]+s[j+k+1:i+1])\\n        return len(hash)\\n                    \\n                    \\n                    \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739662,
                "title": "python-faster-than-99",
                "content": "```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        #indexes candidate to be the middle of substrings can only be chars that appear more than once\\n\\t\\tcandidate_indexes = set()\\n        \\n        #build hashmap keeping indexes of each chars\\n        hash_alph = {}\\n        for i, c in enumerate(text):\\n            if not c in hash_alph:\\n                hash_alph[c] = []\\n            else:\\n                candidate_indexes.add(i)\\n            hash_alph[c].append(i)\\n      \\n        #case input is all same letter\\n        if len(hash_alph.keys()) == 1 and len(text) > 1:\\n            return len(text) // 2\\n    \\n        return_set = set()\\n        for i in candidate_indexes:\\n            c = text[i]\\n\\t\\t\\t#sequence can only start at the same char in a position preceding\\n            for j in [x for x in hash_alph[c] if x < i]:\\n                length = i - j\\n                #too close from end\\n                if len(text) - i < length:\\n                    continue\\n                \\n                #verify if substring meets condition\\n                l = text[i-length:i] \\n                r = text[i:i+length]\\n                if l == r:\\n                    return_set.add(l+r)\\n                    \\n        return len(return_set)\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        #indexes candidate to be the middle of substrings can only be chars that appear more than once\\n\\t\\tcandidate_indexes = set()\\n        \\n        #build hashmap keeping indexes of each chars\\n        hash_alph = {}\\n        for i, c in enumerate(text):\\n            if not c in hash_alph:\\n                hash_alph[c] = []\\n            else:\\n                candidate_indexes.add(i)\\n            hash_alph[c].append(i)\\n      \\n        #case input is all same letter\\n        if len(hash_alph.keys()) == 1 and len(text) > 1:\\n            return len(text) // 2\\n    \\n        return_set = set()\\n        for i in candidate_indexes:\\n            c = text[i]\\n\\t\\t\\t#sequence can only start at the same char in a position preceding\\n            for j in [x for x in hash_alph[c] if x < i]:\\n                length = i - j\\n                #too close from end\\n                if len(text) - i < length:\\n                    continue\\n                \\n                #verify if substring meets condition\\n                l = text[i-length:i] \\n                r = text[i:i+length]\\n                if l == r:\\n                    return_set.add(l+r)\\n                    \\n        return len(return_set)\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1717835,
                "title": "java-dp",
                "content": "```\\nclass Solution {\\n    public int distinctEchoSubstrings(String s) {\\n        HashSet<String>set=new HashSet();\\n        int dp[][]=new int[s.length()+1][s.length()+1];\\n        for(int i=s.length()-1;i>=0;i--)\\n        {\\n            for(int j=i+1;j<s.length() && (j-i<=s.length()/2);j++)\\n            {\\n                if(s.charAt(i)==s.charAt(j))\\n                {\\n                    dp[i][j]=1+dp[i+1][j+1];\\n                    if(dp[i+1][j+1]>=j-i-1)\\n                        set.add(s.substring(i,j));\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int distinctEchoSubstrings(String s) {\\n        HashSet<String>set=new HashSet();\\n        int dp[][]=new int[s.length()+1][s.length()+1];\\n        for(int i=s.length()-1;i>=0;i--)\\n        {\\n            for(int j=i+1;j<s.length() && (j-i<=s.length()/2);j++)\\n            {\\n                if(s.charAt(i)==s.charAt(j))\\n                {\\n                    dp[i][j]=1+dp[i+1][j+1];\\n                    if(dp[i+1][j+1]>=j-i-1)\\n                        set.add(s.substring(i,j));\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1691605,
                "title": "javascript-brute-force-1332ms",
                "content": "```\\nconst distinctEchoSubstrings = (s) => {\\n    let n = s.length, res = new Set();\\n    for (let len = 1; len <= n >> 1; len++) {\\n        for (let i = 0; i + len <= n; i++) {\\n           let left = s.substr(i, len), right = s.substr(i + len, len);\\n           if (left == right) res.add(s.substr(i, 2 * len));\\n        }\\n    }\\n    return res.size;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst distinctEchoSubstrings = (s) => {\\n    let n = s.length, res = new Set();\\n    for (let len = 1; len <= n >> 1; len++) {\\n        for (let i = 0; i + len <= n; i++) {\\n           let left = s.substr(i, len), right = s.substr(i + len, len);\\n           if (left == right) res.add(s.substr(i, 2 * len));\\n        }\\n    }\\n    return res.size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1567532,
                "title": "java-solution-same-logic-doesn-t-work-in-c",
                "content": "```\\nclass Solution {\\n    \\n    public int distinctEchoSubstrings(String s) {\\n        \\n        int n = s.length();\\n        \\n        int ans = 0;\\n        \\n        HashSet<String> set = new HashSet<>();\\n        \\n        for(int g = 1 ; g < n ; g++){\\n            \\n            for(int i = 0 , j = g ; j < n ; i++, j++){\\n                \\n                if(g%2 == 1){\\n                    \\n                    String left = s.substring(i,i+(g/2)+1);\\n                    String right = s.substring(i+(g/2)+1,j+1);\\n                    \\n                    if(left.equals(right) && set.contains(left+right) == false){\\n                        ans++;\\n                        set.add(left + right);\\n                    }\\n                    \\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int distinctEchoSubstrings(String s) {\\n        \\n        int n = s.length();\\n        \\n        int ans = 0;\\n        \\n        HashSet<String> set = new HashSet<>();\\n        \\n        for(int g = 1 ; g < n ; g++){\\n            \\n            for(int i = 0 , j = g ; j < n ; i++, j++){\\n                \\n                if(g%2 == 1){\\n                    \\n                    String left = s.substring(i,i+(g/2)+1);\\n                    String right = s.substring(i+(g/2)+1,j+1);\\n                    \\n                    if(left.equals(right) && set.contains(left+right) == false){\\n                        ans++;\\n                        set.add(left + right);\\n                    }\\n                    \\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1558448,
                "title": "o-n-2-try-every-possible-duplicate-substring-recursively",
                "content": "```\\nvar distinctEchoSubstrings = function(text) {\\n    let count = 0;\\n    function solve(indices, length) {\\n        if (indices.length <= 1) {\\n            return;\\n        }\\n        const set = new Set(indices);\\n        for (let j = 0; j < indices.length - 1; j++) {\\n            if (set.has(indices[j] + length)) {\\n                count++\\n                break;\\n            }\\n        }\\n        const options = new Set(indices.map(i => text[i + length]));\\n        for (const c of options) {\\n            if (!c) continue;\\n            const next = indices.filter(i => text[i + length] === c);\\n            solve(next, length + 1)\\n        }\\n    }\\n    \\n    for (const c of \\'abcdefghijklmnopqrstuvwxyz\\') {\\n        const indices = text\\n            .split(\\'\\')\\n            .map((x, i) => x === c ? i : null)\\n            .filter(d => d !== null);\\n        solve(indices, 1)\\n    }\\n    \\n    return count;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar distinctEchoSubstrings = function(text) {\\n    let count = 0;\\n    function solve(indices, length) {\\n        if (indices.length <= 1) {\\n            return;\\n        }\\n        const set = new Set(indices);\\n        for (let j = 0; j < indices.length - 1; j++) {\\n            if (set.has(indices[j] + length)) {\\n                count++\\n                break;\\n            }\\n        }\\n        const options = new Set(indices.map(i => text[i + length]));\\n        for (const c of options) {\\n            if (!c) continue;\\n            const next = indices.filter(i => text[i + length] === c);\\n            solve(next, length + 1)\\n        }\\n    }\\n    \\n    for (const c of \\'abcdefghijklmnopqrstuvwxyz\\') {\\n        const indices = text\\n            .split(\\'\\')\\n            .map((x, i) => x === c ? i : null)\\n            .filter(d => d !== null);\\n        solve(indices, 1)\\n    }\\n    \\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1419989,
                "title": "python-better-than-100-simple-bruteforce",
                "content": "```\\nclass Solution(object):\\n    def distinctEchoSubstrings(self, text):\\n        n=len(text)\\n        ans=0\\n        s=set()\\n        for i in range(1,n):\\n            for j in range(i//2+1,i+1):\\n                l=i+1-j\\n                temp=text[j-l:j]\\n                if temp==text[j:i+1]:\\n                    s.add(temp)\\n        return len(s)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def distinctEchoSubstrings(self, text):\\n        n=len(text)\\n        ans=0\\n        s=set()\\n        for i in range(1,n):\\n            for j in range(i//2+1,i+1):\\n                l=i+1-j\\n                temp=text[j-l:j]\\n                if temp==text[j:i+1]:\\n                    s.add(temp)\\n        return len(s)\\n",
                "codeTag": "Java"
            },
            {
                "id": 1343699,
                "title": "why-does-my-code-not-work",
                "content": "Please exclude the modulo part. I have not included it yet. It fails on testcase : \"tiduxtiduxtiduxtiduxtiduxtiduxtiduxtidux\"\\nOutput : 15\\nExpected: 16\\n\\n```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        hasharray = []\\n        BASE = 7\\n        \\n        for i in range(len(text)):\\n            if i==0:\\n                hasharray.append(ord(text[i]))\\n            else:\\n                hasharray.append(ord(text[i])*(BASE**i)+hasharray[-1])\\n        \\n        \\n        echos = set()\\n        i = 0\\n        while i<len(text):\\n            length = 2\\n            while i+length <= len(text):\\n                mid = i + length//2\\n                hash1 = (hasharray[mid-1] - hasharray[i-1])/BASE**i if i>0 else hasharray[mid-1]\\n                hash2 = (hasharray[i+length-1] - hasharray[mid-1])/BASE**mid\\n                if hash1==hash2:\\n                    echos.add(text[i:i+length])\\n                length+=2\\n            i+=1\\n        return len(echos)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        hasharray = []\\n        BASE = 7\\n        \\n        for i in range(len(text)):\\n            if i==0:\\n                hasharray.append(ord(text[i]))\\n            else:\\n                hasharray.append(ord(text[i])*(BASE**i)+hasharray[-1])\\n        \\n        \\n        echos = set()\\n        i = 0\\n        while i<len(text):\\n            length = 2\\n            while i+length <= len(text):\\n                mid = i + length//2\\n                hash1 = (hasharray[mid-1] - hasharray[i-1])/BASE**i if i>0 else hasharray[mid-1]\\n                hash2 = (hasharray[i+length-1] - hasharray[mid-1])/BASE**mid\\n                if hash1==hash2:\\n                    echos.add(text[i:i+length])\\n                length+=2\\n            i+=1\\n        return len(echos)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1322425,
                "title": "amazed-to-see-brute-brute-force-solution-working-python",
                "content": "```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        sets = set()\\n        for i in range(len(text)-1):\\n            for j in range(i+1,len(text)):\\n                sub_str = text[i:j+1]\\n                if len(sub_str)%2==0:\\n                    l = len(sub_str)//2 \\n                    if sub_str[:l] == sub_str[l:]:\\n                        sets.add(sub_str)\\n        return len(sets)\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        sets = set()\\n        for i in range(len(text)-1):\\n            for j in range(i+1,len(text)):\\n                sub_str = text[i:j+1]\\n                if len(sub_str)%2==0:\\n                    l = len(sub_str)//2 \\n                    if sub_str[:l] == sub_str[l:]:\\n                        sets.add(sub_str)\\n        return len(sets)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1293621,
                "title": "java-easy-solution",
                "content": "class Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        Set<String> a=new HashSet<String>();\\n        for(int i=0;i<text.length();i++)\\n        {\\n            for(int j=i+1;j<text.length();j++)\\n            {\\n                if(text.charAt(i)==text.charAt(j))\\n                {\\n                    if(j+j-i<=text.length())\\n                    {\\n                    String s1=text.substring(i,j);\\n                    String s2=text.substring(j,j+j-i);\\n                    if(s1.equals(s2))\\n                    {\\n                        a.add(s1);\\n                    }\\n                    }\\n                }\\n            }\\n        }\\n        return a.size();\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        Set<String> a=new HashSet<String>();\\n        for(int i=0;i<text.length();i++)\\n        {\\n            for(int j=i+1;j<text.length();j++)\\n            {\\n                if(text.charAt(i)==text.charAt(j))\\n                {\\n                    if(j+j-i<=text.length())\\n                    {\\n                    String s1=text.substring(i,j);\\n                    String s2=text.substring(j,j+j-i);\\n                    if(s1.equals(s2))\\n                    {\\n                        a.add(s1);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1231850,
                "title": "c-250ms",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    ll q=1000000037;\\n    vector<ll>h;\\n    vector<ll>p;\\n    void build_hash(string &s)\\n    {\\n        ll n=s.size(),d=1000000007;\\n        h.resize(n+1);\\n        p.resize(n+1);\\n        p[0]=1,h[0]=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            h[i]=(h[i-1]*d+s[i-1])%q;\\n            p[i]=(p[i-1]*d)%q;\\n        }\\n    }\\n    ll hash(int i,int j)\\n    {\\n        ll res=(h[j+1]-h[i]*p[j-i+1])%q;\\n        if(res<0)\\n            res+=q;\\n        return res;\\n    }\\n    int distinctEchoSubstrings(string s) \\n    {\\n        unordered_set<int>res;\\n        build_hash(s);\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i;j<n;j++)\\n            {\\n                int len=j-i+1;\\n                if(j+len<n)\\n                {\\n                    if(hash(i,j)==hash(j+1,j+len))\\n                    {\\n                        res.insert(hash(i,j));\\n                    }\\n                }\\n            }\\n        }\\n        return res.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    ll q=1000000037;\\n    vector<ll>h;\\n    vector<ll>p;\\n    void build_hash(string &s)\\n    {\\n        ll n=s.size(),d=1000000007;\\n        h.resize(n+1);\\n        p.resize(n+1);\\n        p[0]=1,h[0]=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            h[i]=(h[i-1]*d+s[i-1])%q;\\n            p[i]=(p[i-1]*d)%q;\\n        }\\n    }\\n    ll hash(int i,int j)\\n    {\\n        ll res=(h[j+1]-h[i]*p[j-i+1])%q;\\n        if(res<0)\\n            res+=q;\\n        return res;\\n    }\\n    int distinctEchoSubstrings(string s) \\n    {\\n        unordered_set<int>res;\\n        build_hash(s);\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i;j<n;j++)\\n            {\\n                int len=j-i+1;\\n                if(j+len<n)\\n                {\\n                    if(hash(i,j)==hash(j+1,j+len))\\n                    {\\n                        res.insert(hash(i,j));\\n                    }\\n                }\\n            }\\n        }\\n        return res.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1221492,
                "title": "rust-brute-force-o-n-3-beats-100-100-nevertheless",
                "content": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn distinct_echo_substrings(text: String) -> i32 {\\n        let bytes = text.as_bytes();\\n        let n = bytes.len();\\n        let mut ans = HashSet::new();\\n        let mut cnt = 0;\\n        for l in 1..=n/2 {\\n            for start in l..=n-l {\\n                let seg = &bytes[start..start+l];\\n                if &bytes[start-l..start] == seg {\\n                    ans.insert(seg.clone());\\n                }\\n            }\\n            cnt += ans.len();\\n            ans.clear();\\n        }\\n        cnt as i32\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn distinct_echo_substrings(text: String) -> i32 {\\n        let bytes = text.as_bytes();\\n        let n = bytes.len();\\n        let mut ans = HashSet::new();\\n        let mut cnt = 0;\\n        for l in 1..=n/2 {\\n            for start in l..=n-l {\\n                let seg = &bytes[start..start+l];\\n                if &bytes[start-l..start] == seg {\\n                    ans.insert(seg.clone());\\n                }\\n            }\\n            cnt += ans.len();\\n            ans.clear();\\n        }\\n        cnt as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1067673,
                "title": "typescript-solution-100-speed-memory",
                "content": "```\\nconst distinctEchoSubstrings = (text: string): number => {\\n    const hashTable: { [key: string]: boolean } = {};\\n    // Iterate over all combinations of start (s1) and end (e1) positions.\\n    for (let s1=0; s1< text.length - 1; s1++) {\\n        for (let e1=s1+1; e1 < text.length; e1++) {\\n            const s2 = e1;\\n            const e2 = s2 + (e1 - s1);\\n            if (e2 > text.length) {\\n                // If e2 is out of bounds, move on to the next s1 position\\n                break;\\n            }\\n            // Check if the string from s1 to e1 (exclusive)\\n            // is equal to the string on the right of equal length (from s2 to e2).\\n            const stringToCheck = text.slice(s1, e1);\\n            if (stringToCheck === text.slice(s2, e2)) {\\n                // If the strings are equal,\\n                // then place string in hashTable.\\n                hashTable[stringToCheck] = true;\\n            }\\n        }\\n    }\\n    return Object.keys(hashTable).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nconst distinctEchoSubstrings = (text: string): number => {\\n    const hashTable: { [key: string]: boolean } = {};\\n    // Iterate over all combinations of start (s1) and end (e1) positions.\\n    for (let s1=0; s1< text.length - 1; s1++) {\\n        for (let e1=s1+1; e1 < text.length; e1++) {\\n            const s2 = e1;\\n            const e2 = s2 + (e1 - s1);\\n            if (e2 > text.length) {\\n                // If e2 is out of bounds, move on to the next s1 position\\n                break;\\n            }\\n            // Check if the string from s1 to e1 (exclusive)\\n            // is equal to the string on the right of equal length (from s2 to e2).\\n            const stringToCheck = text.slice(s1, e1);\\n            if (stringToCheck === text.slice(s2, e2)) {\\n                // If the strings are equal,\\n                // then place string in hashTable.\\n                hashTable[stringToCheck] = true;\\n            }\\n        }\\n    }\\n    return Object.keys(hashTable).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1047124,
                "title": "java-simple-brute-force-got-accepted-surprised-me",
                "content": "\\tpublic int distinctEchoSubstrings(String text) {\\n\\t\\t\\tif (text == null || text.length() == 0) return 0;\\n\\t\\t\\tSet<String> stringSet = new HashSet<>();\\n\\n\\t\\t\\tfor (int right = 1; right <= text.length(); ++right)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor (int left = 0; left < right; ++left)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (right - left <= 1) continue;\\n\\t\\t\\t\\t\\tString subStr = text.substring(left, right);\\n\\t\\t\\t\\t\\tif (isEchoString(subStr)) {\\n\\t\\t\\t\\t\\t\\tstringSet.add(subStr);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn stringSet.size();\\n\\t\\t}\\n\\n\\t\\tprivate boolean isEchoString(String subStr)\\n\\t\\t{\\n\\t\\t\\tif (subStr.length() % 2 != 0) return false;\\n\\n\\t\\t\\tif (subStr.substring(0, subStr.length()/2).equals(subStr.substring(subStr.length()/2, subStr.length())))\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\treturn false;\\n\\t\\t}",
                "solutionTags": [],
                "code": "\\tpublic int distinctEchoSubstrings(String text) {\\n\\t\\t\\tif (text == null || text.length() == 0) return 0;\\n\\t\\t\\tSet<String> stringSet = new HashSet<>();\\n\\n\\t\\t\\tfor (int right = 1; right <= text.length(); ++right)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor (int left = 0; left < right; ++left)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (right - left <= 1) continue;\\n\\t\\t\\t\\t\\tString subStr = text.substring(left, right);\\n\\t\\t\\t\\t\\tif (isEchoString(subStr)) {\\n\\t\\t\\t\\t\\t\\tstringSet.add(subStr);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn stringSet.size();\\n\\t\\t}\\n\\n\\t\\tprivate boolean isEchoString(String subStr)\\n\\t\\t{\\n\\t\\t\\tif (subStr.length() % 2 != 0) return false;\\n\\n\\t\\t\\tif (subStr.substring(0, subStr.length()/2).equals(subStr.substring(subStr.length()/2, subStr.length())))\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\treturn false;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 993806,
                "title": "rolling-hash-86",
                "content": "```\\n#define ll long long int\\nconst ll m = 1e9 + 9;\\nconst int p = 31;\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string s){\\n        int i, l = s.length();\\n        int mx = (l + 1);\\n        unordered_map<ll, bool> pre;\\n        ll pw[mx+1];\\n        pw[0] = 1;\\n        if(l==1)\\n            return 0;\\n        if(l==2){\\n            if(s[0]==s[1])\\n                return 1;\\n            return 0;\\n        }\\n        \\n        ll cnt = 0;\\n        for(i=1;i<=mx;i++)\\n            pw[i] = (pw[i-1]*31)%m;\\n        \\n        ll dp[l+1][l+1];\\n        memset(dp, -1, sizeof(dp));\\n        \\n        for(i=0;i<l;i++){\\n            ll h1 = 0;\\n            for(ll len = 1;len<=l;len++){\\n                if(i+len>l)\\n                    break;\\n                h1 = (h1 + ((s[i+len-1]-\\'a\\'+1)*pw[len-1])%m)%m;\\n                dp[i][len] = h1;\\n            }\\n        }\\n        \\n        for(i=0;i<l;i++){\\n            for(ll len =1;len<=l;len++){\\n                if(i+len>=l)\\n                    break;        \\n                if(dp[i][len]==dp[i+len][len]){\\n                    if(pre.find(dp[i][len])==pre.end()){\\n                        pre[dp[i][len]] = 1;\\n                        cnt++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Rolling Hash"
                ],
                "code": "```\\n#define ll long long int\\nconst ll m = 1e9 + 9;\\nconst int p = 31;\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string s){\\n        int i, l = s.length();\\n        int mx = (l + 1);\\n        unordered_map<ll, bool> pre;\\n        ll pw[mx+1];\\n        pw[0] = 1;\\n        if(l==1)\\n            return 0;\\n        if(l==2){\\n            if(s[0]==s[1])\\n                return 1;\\n            return 0;\\n        }\\n        \\n        ll cnt = 0;\\n        for(i=1;i<=mx;i++)\\n            pw[i] = (pw[i-1]*31)%m;\\n        \\n        ll dp[l+1][l+1];\\n        memset(dp, -1, sizeof(dp));\\n        \\n        for(i=0;i<l;i++){\\n            ll h1 = 0;\\n            for(ll len = 1;len<=l;len++){\\n                if(i+len>l)\\n                    break;\\n                h1 = (h1 + ((s[i+len-1]-\\'a\\'+1)*pw[len-1])%m)%m;\\n                dp[i][len] = h1;\\n            }\\n        }\\n        \\n        for(i=0;i<l;i++){\\n            for(ll len =1;len<=l;len++){\\n                if(i+len>=l)\\n                    break;        \\n                if(dp[i][len]==dp[i+len][len]){\\n                    if(pre.find(dp[i][len])==pre.end()){\\n                        pre[dp[i][len]] = 1;\\n                        cnt++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 956349,
                "title": "c-string-hashing",
                "content": "```\\npublic class Solution\\n{\\n  public int DistinctEchoSubstrings(string text)\\n  {\\n    const int A = 911382323;\\n    const int B = 972663749;\\n\\n    var h = new int[text.Length];\\n    var p = new int[text.Length];\\n\\n    h[0] = text[0] % B;\\n    p[0] = 1;\\n\\n    for (var i = 1; i < text.Length; i++)\\n    {\\n      h[i] = (Mod(h[i - 1], A, B) + text[i]) % B;\\n      p[i] = (Mod(p[i - 1], A, B)) % B;\\n    }\\n\\n    var set = new HashSet<int>();\\n\\n    for (var i = 0; i < text.Length; i++)\\n    {\\n      for (var j = i + 1; j < text.Length; j += 2)\\n      {\\n        var hash1 = Hash(h, p, i, (i + j) / 2, B);\\n        var hash2 = Hash(h, p, (i + j) / 2 + 1, j, B);\\n\\n        if (hash1 == hash2)\\n          set.Add(Hash(h, p, i, j, B));\\n      }\\n    }\\n\\n    return set.Count;\\n  }\\n\\n  private int Hash(int[] h, int[] p, int a, int b, int B)\\n  {\\n    if (a == 0)\\n      return h[b];\\n\\n    return ((h[b] + B) - Mod(h[a - 1], p[b - a + 1], B)) % B;\\n  }\\n\\n  private int Mod(int a, int b, int mod)\\n  {\\n    var res = 0;\\n    a %= mod;\\n\\n    while (b > 0)\\n    {\\n      if ((b & 1) > 0)\\n        res = (res + a) % mod;\\n\\n      a = (2 * a) % mod;\\n      b >>= 1;\\n    }\\n\\n    return res;\\n  }\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\npublic class Solution\\n{\\n  public int DistinctEchoSubstrings(string text)\\n  {\\n    const int A = 911382323;\\n    const int B = 972663749;\\n\\n    var h = new int[text.Length];\\n    var p = new int[text.Length];\\n\\n    h[0] = text[0] % B;\\n    p[0] = 1;\\n\\n    for (var i = 1; i < text.Length; i++)\\n    {\\n      h[i] = (Mod(h[i - 1], A, B) + text[i]) % B;\\n      p[i] = (Mod(p[i - 1], A, B)) % B;\\n    }\\n\\n    var set = new HashSet<int>();\\n\\n    for (var i = 0; i < text.Length; i++)\\n    {\\n      for (var j = i + 1; j < text.Length; j += 2)\\n      {\\n        var hash1 = Hash(h, p, i, (i + j) / 2, B);\\n        var hash2 = Hash(h, p, (i + j) / 2 + 1, j, B);\\n\\n        if (hash1 == hash2)\\n          set.Add(Hash(h, p, i, j, B));\\n      }\\n    }\\n\\n    return set.Count;\\n  }\\n\\n  private int Hash(int[] h, int[] p, int a, int b, int B)\\n  {\\n    if (a == 0)\\n      return h[b];\\n\\n    return ((h[b] + B) - Mod(h[a - 1], p[b - a + 1], B)) % B;\\n  }\\n\\n  private int Mod(int a, int b, int mod)\\n  {\\n    var res = 0;\\n    a %= mod;\\n\\n    while (b > 0)\\n    {\\n      if ((b & 1) > 0)\\n        res = (res + a) % mod;\\n\\n      a = (2 * a) % mod;\\n      b >>= 1;\\n    }\\n\\n    return res;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 939323,
                "title": "python3-short-brute-force-solution",
                "content": "```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        ret = set()\\n\\n        \\n        for i in range(len(text)):\\n            for j in range(i + 1, len(text), 2):\\n                middle = i + (j - i + 1) // 2\\n                candidate = text[i:middle]\\n                \\n                \\n                if (candidate == text[middle:j + 1]):\\n                    ret.add(candidate)\\n                    \\n        return len(ret)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        ret = set()\\n\\n        \\n        for i in range(len(text)):\\n            for j in range(i + 1, len(text), 2):\\n                middle = i + (j - i + 1) // 2\\n                candidate = text[i:middle]\\n                \\n                \\n                if (candidate == text[middle:j + 1]):\\n                    ret.add(candidate)\\n                    \\n        return len(ret)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 861153,
                "title": "distinct-echo-substring-simple-brute-force-solution",
                "content": "\\'\\'\\'\\'\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        \\n        \\n        subs=set()\\n        \\n        for i in range(len(text)):\\n            for j in range(i+1,len(text)):\\n                \\n                temp=text[i:j]\\n                \\n                #print(\"\\\\t\\\\t temp:\",temp,\"\\\\t\\\\t \",temp==text.startswith(temp,j))\\n                if text[i:j]==text[j:j+j-i] :#text.startswith(text[i:j],j):\\n                    subs.add(text[i:j])\\n                \\n        #print(subs)\\n        return len(subs)\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\'\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        \\n        \\n        subs=set()\\n        \\n        for i in range(len(text)):\\n            for j in range(i+1,len(text)):\\n                \\n                temp=text[i:j]\\n                \\n                #print(\"\\\\t\\\\t temp:\",temp,\"\\\\t\\\\t \",temp==text.startswith(temp,j))\\n                if text[i:j]==text[j:j+j-i] :#text.startswith(text[i:j],j):\\n                    subs.add(text[i:j])\\n                \\n        #print(subs)\\n        return len(subs)\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 847050,
                "title": "java-rolling-hash",
                "content": "```\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        int n = text.length();\\n        long mod = 1_000_000_009L;\\n        int[] a = new int[n];\\n        for(int i = 0; i < n; i++) a[i] = text.charAt(i) - \\'a\\';\\n        \\n        // modular exps of 26\\n        long[] exp = new long[n+1];\\n        exp[0] = 1;\\n        for(int i = 0; i < n; i++) exp[i+1] = (exp[i] % mod * 26) % mod;\\n        \\n        Set<String> res = new HashSet<>();\\n        for(int i = 1; i <= n/2; i++) {\\n            int p = 0, q = i;\\n            long h0 = 0, h1 = 0;\\n            while(p < i) {\\n                h0 = ((h0 % mod * 26) % mod + a[p]) % mod;\\n                h1 = ((h1 % mod * 26) % mod + a[q]) % mod;\\n                p++;\\n                q++;\\n            }\\n            \\n            while(q < n) {\\n                if(h0 == h1) {\\n                    res.add(text.substring(p, q));\\n                }\\n                h0 = ((h0 % mod * 26) % mod + a[p]) % mod;\\n                h1 = ((h1 % mod * 26) % mod + a[q]) % mod;\\n                h0 = (h0 % mod - (exp[i] * a[p - i]) % mod) % mod;\\n                h1 = (h1 % mod - (exp[i] * a[q - i]) % mod) % mod;\\n                p++;\\n                q++;\\n            }\\n\\n            if(h0 == h1) {\\n                res.add(text.substring(p, q));\\n            }\\n        }\\n        return res.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        int n = text.length();\\n        long mod = 1_000_000_009L;\\n        int[] a = new int[n];\\n        for(int i = 0; i < n; i++) a[i] = text.charAt(i) - \\'a\\';\\n        \\n        // modular exps of 26\\n        long[] exp = new long[n+1];\\n        exp[0] = 1;\\n        for(int i = 0; i < n; i++) exp[i+1] = (exp[i] % mod * 26) % mod;\\n        \\n        Set<String> res = new HashSet<>();\\n        for(int i = 1; i <= n/2; i++) {\\n            int p = 0, q = i;\\n            long h0 = 0, h1 = 0;\\n            while(p < i) {\\n                h0 = ((h0 % mod * 26) % mod + a[p]) % mod;\\n                h1 = ((h1 % mod * 26) % mod + a[q]) % mod;\\n                p++;\\n                q++;\\n            }\\n            \\n            while(q < n) {\\n                if(h0 == h1) {\\n                    res.add(text.substring(p, q));\\n                }\\n                h0 = ((h0 % mod * 26) % mod + a[p]) % mod;\\n                h1 = ((h1 % mod * 26) % mod + a[q]) % mod;\\n                h0 = (h0 % mod - (exp[i] * a[p - i]) % mod) % mod;\\n                h1 = (h1 % mod - (exp[i] * a[q - i]) % mod) % mod;\\n                p++;\\n                q++;\\n            }\\n\\n            if(h0 == h1) {\\n                res.add(text.substring(p, q));\\n            }\\n        }\\n        return res.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843570,
                "title": "rolling-hash-with-dp-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        int n=text.size();\\n        long long hash[n][n];\\n        int mod=1e9+7;\\n        unordered_map<long long,int> MP;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            long long pow=31;\\n            hash[i][i]=pow*(text[i]-\\'a\\'+1);\\n            for(int j=i+1;j<n;j++)\\n            {\\n                pow=(pow*31)%mod;\\n                hash[i][j]=(hash[i][j-1]%mod+pow*(text[j]-\\'a\\'+1)%mod)%mod;\\n            }\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i;j<n;j++)\\n            {\\n                int sz=j-i+1;\\n                if(j+sz>=n) continue;\\n                if(hash[i][j]==hash[j+1][j+sz])\\n                {\\n                    if(MP[hash[i][j]]==0) ans++;\\n                    MP[hash[i][j]]++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Rolling Hash"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        int n=text.size();\\n        long long hash[n][n];\\n        int mod=1e9+7;\\n        unordered_map<long long,int> MP;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            long long pow=31;\\n            hash[i][i]=pow*(text[i]-\\'a\\'+1);\\n            for(int j=i+1;j<n;j++)\\n            {\\n                pow=(pow*31)%mod;\\n                hash[i][j]=(hash[i][j-1]%mod+pow*(text[j]-\\'a\\'+1)%mod)%mod;\\n            }\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i;j<n;j++)\\n            {\\n                int sz=j-i+1;\\n                if(j+sz>=n) continue;\\n                if(hash[i][j]==hash[j+1][j+sz])\\n                {\\n                    if(MP[hash[i][j]]==0) ans++;\\n                    MP[hash[i][j]]++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823967,
                "title": "python-3-utilize-dictionary",
                "content": "```\\n def distinctEchoSubstrings(self, text: str) -> int:\\n        l = len(text)\\n        dic = {}\\n        if l == 0:\\n            return 0\\n        for start in range(l-1):    \\n            for end in range(l, start, -1):  \\n                diff = end - start\\n                if (diff %2) == 0 and text[start:diff//2 + start] == text[diff//2 + start:end]:\\n                    dic[text[start:end]] = 1              \\n        return len(list(dic.keys()))",
                "solutionTags": [],
                "code": "```\\n def distinctEchoSubstrings(self, text: str) -> int:\\n        l = len(text)\\n        dic = {}\\n        if l == 0:\\n            return 0\\n        for start in range(l-1):    \\n            for end in range(l, start, -1):  \\n                diff = end - start\\n                if (diff %2) == 0 and text[start:diff//2 + start] == text[diff//2 + start:end]:\\n                    dic[text[start:end]] = 1              \\n        return len(list(dic.keys()))",
                "codeTag": "Python3"
            },
            {
                "id": 798864,
                "title": "ruby-beats-100",
                "content": "* Record every char\\'s indexes.\\n* Use **sum[i]** the record the sum from **index 0** to **index i** in ord.\\n* For every **index i** of every char, find the **index j** in the rest:\\n\\t* compare the sum[i..j] with sum[j..l]\\n\\t* compare the text[i..j] with sum[j..l]\\n\\t* mark the text[i..j]\\n\\n```\\nA_ORD = \\'a\\'.ord\\n\\ndef distinct_echo_substrings(text)\\n  hash, sum = {}, [0]\\n  text.chars.each_with_index do |char, i|\\n    hash[char] ||= []\\n    hash[char] << i\\n    sum[i+1] = sum[i] + (char.ord - A_ORD + 1)\\n  end\\n\\n  mark = {}\\n  hash.each do |char, indexes|\\n    (0..indexes.size-2).each do |i|\\n      (i+1..indexes.size-1).each do |j|\\n        l = indexes[j] - indexes[i]\\n        sum1 = sum[indexes[j]] - sum[indexes[i]]\\n        next if indexes[i]+l > text.size\\n        sum2 = sum[indexes[i]+l] - sum[indexes[i]]\\n        next if sum1 != sum2\\n        s1 = text[indexes[i], l]\\n        next if mark[s1]\\n        s2 = text[indexes[j], l]\\n        mark[s1] = true if s1 == s2\\n      end\\n    end\\n  end\\n  mark.size\\nend\\n```\\n",
                "solutionTags": [],
                "code": "```\\nA_ORD = \\'a\\'.ord\\n\\ndef distinct_echo_substrings(text)\\n  hash, sum = {}, [0]\\n  text.chars.each_with_index do |char, i|\\n    hash[char] ||= []\\n    hash[char] << i\\n    sum[i+1] = sum[i] + (char.ord - A_ORD + 1)\\n  end\\n\\n  mark = {}\\n  hash.each do |char, indexes|\\n    (0..indexes.size-2).each do |i|\\n      (i+1..indexes.size-1).each do |j|\\n        l = indexes[j] - indexes[i]\\n        sum1 = sum[indexes[j]] - sum[indexes[i]]\\n        next if indexes[i]+l > text.size\\n        sum2 = sum[indexes[i]+l] - sum[indexes[i]]\\n        next if sum1 != sum2\\n        s1 = text[indexes[i], l]\\n        next if mark[s1]\\n        s2 = text[indexes[j], l]\\n        mark[s1] = true if s1 == s2\\n      end\\n    end\\n  end\\n  mark.size\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 786428,
                "title": "python3-illustrated-one-line-solution",
                "content": "![image](https://assets.leetcode.com/users/images/352db6f8-f5e1-453b-b247-0039670e2462_1597175114.4900339.png)\\n\\n![image](https://assets.leetcode.com/users/images/c1f070f5-1cf7-4652-84b9-7b796d5cdf77_1597175124.2101493.png)\\n\\n\\n```\\n    def distinctEchoSubstrings(self, text: str) -> int:  # pylint: disable=invalid-name\\n\\n        variants = [text[x:y] for x, y in itertools.combinations(range(len(text) + 1), r=2) if y - x > 1 and (y - x) % 2 == 0 and (size := (y - x) // 2) > 0 and text[x:x + size] == text[x + size:y]]\\n        return len(set(variants))\\n```",
                "solutionTags": [],
                "code": "```\\n    def distinctEchoSubstrings(self, text: str) -> int:  # pylint: disable=invalid-name\\n\\n        variants = [text[x:y] for x, y in itertools.combinations(range(len(text) + 1), r=2) if y - x > 1 and (y - x) % 2 == 0 and (size := (y - x) // 2) > 0 and text[x:x + size] == text[x + size:y]]\\n        return len(set(variants))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 726795,
                "title": "python-accepted-simple-brute-force",
                "content": "Simple brute works. Given substring size of 1 to (n/2) , \\n- find all substrings, compare\\n- Add to set if left == right\\n- Return length\\n```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        st = set()\\n        for s in range(1, 1 + len(text) // 2):\\n            for start in range(len(text)):\\n                l = text[start:start+s]\\n                r = text[start+s:start+s+s]\\n                if l == r and (l+r) not in st and len(l) != 0:\\n                    st.add(l+r)\\n        return len(st)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        st = set()\\n        for s in range(1, 1 + len(text) // 2):\\n            for start in range(len(text)):\\n                l = text[start:start+s]\\n                r = text[start+s:start+s+s]\\n                if l == r and (l+r) not in st and len(l) != 0:\\n                    st.add(l+r)\\n        return len(st)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 644173,
                "title": "python-accepted-solution-iterating-on-indexes-having-same-character",
                "content": "```\\nclass Solution(object):\\n    def distinctEchoSubstrings(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: int\\n        \"\"\"\\n        if not text: return 0\\n        \\n        prefixSum = [0]\\n        \\n        for char in text:\\n            prefixSum.append(prefixSum[-1] + ord(char))\\n        \\n        from collections import defaultdict\\n        indexes = defaultdict(list)\\n        \\n        for i in range(len(text)):\\n            indexes[text[i]].append(i)\\n        \\n        seen = set()\\n        for char in sorted(indexes.keys()):\\n            for i in range(len(indexes[char]) - 1):\\n                for j in range(i+1, len(indexes[char])):\\n                    ind1 = indexes[char][i]\\n                    ind2 = indexes[char][j]\\n                    length = ind2 - ind1\\n                    if ind2 + length > len(text):\\n                        break\\n                    if (prefixSum[ind2] - prefixSum[ind1]) == (prefixSum[ind2+length] - prefixSum[ind2]):\\n                        if text[ind1: ind2] == text[ind2:ind2+length]:\\n                            seen.add(text[ind1:ind2+length])\\n        return len(seen)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def distinctEchoSubstrings(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: int\\n        \"\"\"\\n        if not text: return 0\\n        \\n        prefixSum = [0]\\n        \\n        for char in text:\\n            prefixSum.append(prefixSum[-1] + ord(char))\\n        \\n        from collections import defaultdict\\n        indexes = defaultdict(list)\\n        \\n        for i in range(len(text)):\\n            indexes[text[i]].append(i)\\n        \\n        seen = set()\\n        for char in sorted(indexes.keys()):\\n            for i in range(len(indexes[char]) - 1):\\n                for j in range(i+1, len(indexes[char])):\\n                    ind1 = indexes[char][i]\\n                    ind2 = indexes[char][j]\\n                    length = ind2 - ind1\\n                    if ind2 + length > len(text):\\n                        break\\n                    if (prefixSum[ind2] - prefixSum[ind1]) == (prefixSum[ind2+length] - prefixSum[ind2]):\\n                        if text[ind1: ind2] == text[ind2:ind2+length]:\\n                            seen.add(text[ind1:ind2+length])\\n        return len(seen)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 627432,
                "title": "easy-python-solution-with-comments-incl-time-space-complexity-analysis",
                "content": "```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        count = 0\\n\\t\\t# prevents overcounting\\n        seen = set()\\n\\t\\t# try every possible repeating substring length; e.g.\\n\\t\\t# substring \\'abcabcabc\\' has a repeating substring length of 3\\n\\t\\t# note: the maximum length of such a substring is len(text) // 2\\n        for k in range(1, len(text) // 2 + 1):\\n\\t\\t\\t# search every possible starting position in `text` for \\n\\t\\t\\t# our repeating substring\\n            for i in range(len(text) - k):\\n\\t\\t\\t\\t# we *only* need to know that the substring repeats at\\n\\t\\t\\t\\t# *least* twice in order to count it, so we check for two\\n\\t\\t\\t\\t# repetitions\\n                s1 = text[i:i+k]\\n                s2 = text[i+k:i+2*k]\\n                if s1 == s2 and s1 not in seen:\\n                    count += 1\\n\\t\\t\\t\\t\\t# in the case where a substring repeats more than twice,\\n\\t\\t\\t\\t\\t# we must ensure we don\\'t overcount\\n                    seen.add(s1)\\n\\t\\t\\t# reset `seen` every time we start searching for subsets of a different size\\n\\t\\t\\tseen = set()\\n        return count\\n```\\n\\n**Time-complexity**\\nLet *n* be the length of our input text. The number of times the inner loop is executed is: (n - 1) + (n - 2) + (n - 3) + ... + (n - n/2) ... further, the comparison of `s1` and `s2` costs `k`. The total \"steps\" taken by the algorithm is thus: (n - 1) + 2*(n - 2) + 3*(n - 3) + ... + n/2(n - n/2) = sum_{i}^{n/2} (i\\\\*n - i^2) which, when you apply the various rules of summations, you get O(n^3). Note that this algorithm could be made O(n^2) (expected) if instead of doing a direct string comparison, we first hash `s1` and `s2`.\\n\\n**Space-complexity**\\nWe empty `seen` every time we start searching for a substring of a different length. Worst case, in terms of space complexity, is when `text` looks something like this: \"aabbccddeeff\" in which case seen, at the end of iteration where n == 1 will look like this: {\"aa\", \"bb\", \"cc\", \"dd\", \"ee\", \"ff\"}. That is, space complexity is O(n).",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        count = 0\\n\\t\\t# prevents overcounting\\n        seen = set()\\n\\t\\t# try every possible repeating substring length; e.g.\\n\\t\\t# substring \\'abcabcabc\\' has a repeating substring length of 3\\n\\t\\t# note: the maximum length of such a substring is len(text) // 2\\n        for k in range(1, len(text) // 2 + 1):\\n\\t\\t\\t# search every possible starting position in `text` for \\n\\t\\t\\t# our repeating substring\\n            for i in range(len(text) - k):\\n\\t\\t\\t\\t# we *only* need to know that the substring repeats at\\n\\t\\t\\t\\t# *least* twice in order to count it, so we check for two\\n\\t\\t\\t\\t# repetitions\\n                s1 = text[i:i+k]\\n                s2 = text[i+k:i+2*k]\\n                if s1 == s2 and s1 not in seen:\\n                    count += 1\\n\\t\\t\\t\\t\\t# in the case where a substring repeats more than twice,\\n\\t\\t\\t\\t\\t# we must ensure we don\\'t overcount\\n                    seen.add(s1)\\n\\t\\t\\t# reset `seen` every time we start searching for subsets of a different size\\n\\t\\t\\tseen = set()\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 585104,
                "title": "c-solution-24ms-clear-explanation",
                "content": "### Solution:\\n\\nIntuitively, solution is to compare every substrings and check whether a substring is a concatenation of a original string: `abcabc` from `abc` .\\n\\n1. Traverse every slots between characters of the string.\\n2. From the current slot, keep checking the left string and the right string with the equal length.\\n3. If the left string equals to the right string, put the string to an `unoredered_set` for removing the duplicates.\\n\\nNoted, consider to use `string_view` instead of `string` to reduce the complexity of creating new substrings.\\n\\n    class Solution {\\n    public:\\n        int distinctEchoSubstrings(string text) {\\n            int len = text.size();\\n            unordered_set<string_view> count;\\n            const char *p = text.c_str();\\n            for (int i = 1; i < len - 1; ++i) {\\n                int diff = min(i, len - i);\\n                int start = i - diff;\\n                for (int j = start; j < i; ++j) {\\n                    const string_view left(p + j, i - j);\\n                    const string_view right(p + i, i - j);\\n                    // auto left = text.substr(j, i - j);\\n                    // auto right = text.substr(i, i - j);\\n                    // cout << left << \", \" << right << endl;\\n                    if (left == right) {\\n                        count.insert(left);\\n                    }\\n                }\\n            }\\n            \\n            return count.size();\\n        }\\n    };\\n\\nThe solution results in `672 ms` for time and `7.1 mb` for space.\\n\\nFirst optimization is to reduce the number of created `string_view` substrings. To accomplish this, just simply check one-by-one character between the left substring and the right substring of the current slot.\\n\\n                ...\\n                for (int j = start; j < i; ++j) {\\n                    int l = j;\\n                    int r = i;\\n                    int c = 0;\\n                    while (l < i) {\\n                        if (p[l++] == p[r++]) {\\n                            ++c;\\n                        } else {\\n                            break;\\n                        }\\n                    }\\n    \\n                    if (c == i - j) {\\n                        count.insert(string_view(p + j, c)); // (*)\\n                    }\\n                }\\n                ...\\n\\nThis optimization is good, but we can do better. Further optimization is at asterisk `(*)` line. Here we just insert a new string into the `unordered_set` and use the set\\'s characteristic to remove the duplicates. However, there are still duplicated works. For example, given string:\\n\\n    string s = \"aaaaaa\";\\n\\nThere will be several times that we will compare multiple substrings with the same value as `aa` followed by many times processing the substrings `a`. So, we can early terminate here and the full final solution is below.\\n\\n    class Solution {\\n    public:\\n        int distinctEchoSubstrings(string text) {\\n            int len = text.size();\\n            unordered_set<string_view> count;\\n            const char *p = text.c_str();\\n            for (int i = 0; i < len; ++i) {\\n                int diff = min(i, len - i);\\n                int start = i - diff;\\n                for (int j = start; j < i; ++j) {\\n                    int l = j;\\n                    int r = i;\\n                    int c = 0;\\n                    while (l < i) {\\n                        if (p[l++] == p[r++]) {\\n                            ++c;\\n                        } else {\\n                            break;\\n                        }\\n                    }\\n                    \\n                    if (c == i - j) {\\n                        auto s = string_view(p + j, c);\\n                        if (count.count(s) == 0) {\\n                            count.insert(s);\\n                        } else {\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            return count.size();\\n        }\\n    };\\n\\nNew result: `24 ms` and `7.3 mb` . Done !!!",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int distinctEchoSubstrings(string text) {\\n            int len = text.size();\\n            unordered_set<string_view> count;\\n            const char *p = text.c_str();\\n            for (int i = 1; i < len - 1; ++i) {\\n                int diff = min(i, len - i);\\n                int start = i - diff;\\n                for (int j = start; j < i; ++j) {\\n                    const string_view left(p + j, i - j);\\n                    const string_view right(p + i, i - j);\\n                    // auto left = text.substr(j, i - j);\\n                    // auto right = text.substr(i, i - j);\\n                    // cout << left << \", \" << right << endl;\\n                    if (left == right) {\\n                        count.insert(left);\\n                    }",
                "codeTag": "C++"
            },
            {
                "id": 563429,
                "title": "rust-hash-solution",
                "content": "```\\nuse std::collections::HashSet;\\nuse std::ops::RangeInclusive;\\n\\nconst PRIME: u128 = 29;\\n\\n#[derive(Debug)]\\nstruct RabinKarp {\\n    arr: Vec<u128>,\\n}\\n\\nimpl RabinKarp {\\n    fn new(data: &str) -> Self {\\n        let arr = data\\n            .chars()\\n            .enumerate()\\n            .scan(0, |acc, (ind, chr)| {\\n                let cur = (chr as u128) - (\\'a\\' as u128) + 1;\\n                *acc = *acc + cur * PRIME.pow(ind as u32);\\n                Some(*acc)\\n            })\\n            .collect();\\n\\n        RabinKarp { arr }\\n    }\\n\\n    fn get_hash(&self, range: RangeInclusive<usize>) -> u128 {\\n        let hash = if *range.start() > 0 {\\n            self.arr[*range.end()] - self.arr[*range.start() - 1]\\n        } else {\\n            self.arr[*range.end()]\\n        };\\n\\n        hash * PRIME.pow((self.arr.len() - *range.start()) as u32)\\n    }\\n\\n    fn is_same(&self, first: RangeInclusive<usize>, second: RangeInclusive<usize>) -> bool {\\n        self.get_hash(first) == self.get_hash(second)\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn distinct_echo_substrings(text: String) -> i32 {\\n        let hash = RabinKarp::new(&text);\\n        let mut answer = 0;\\n\\n        for len in (2..=text.len()).step_by(2) {\\n            let mut substrings: HashSet<u128> = HashSet::new();\\n            for i in (len - 1)..text.len() {\\n                let mid = (i + i - len) / 2;\\n                let left = (i - len + 1)..=mid;\\n                let right = mid + 1..=i;\\n                if hash.is_same(left, right) {\\n                    let slice = (i - len + 1)..=i;\\n                    substrings.insert(hash.get_hash(slice));\\n                }\\n            }\\n            answer += substrings.len() as i32;\\n        }\\n\\n        answer\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::HashSet;\\nuse std::ops::RangeInclusive;\\n\\nconst PRIME: u128 = 29;\\n\\n#[derive(Debug)]\\nstruct RabinKarp {\\n    arr: Vec<u128>,\\n}\\n\\nimpl RabinKarp {\\n    fn new(data: &str) -> Self {\\n        let arr = data\\n            .chars()\\n            .enumerate()\\n            .scan(0, |acc, (ind, chr)| {\\n                let cur = (chr as u128) - (\\'a\\' as u128) + 1;\\n                *acc = *acc + cur * PRIME.pow(ind as u32);\\n                Some(*acc)\\n            })\\n            .collect();\\n\\n        RabinKarp { arr }\\n    }\\n\\n    fn get_hash(&self, range: RangeInclusive<usize>) -> u128 {\\n        let hash = if *range.start() > 0 {\\n            self.arr[*range.end()] - self.arr[*range.start() - 1]\\n        } else {\\n            self.arr[*range.end()]\\n        };\\n\\n        hash * PRIME.pow((self.arr.len() - *range.start()) as u32)\\n    }\\n\\n    fn is_same(&self, first: RangeInclusive<usize>, second: RangeInclusive<usize>) -> bool {\\n        self.get_hash(first) == self.get_hash(second)\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn distinct_echo_substrings(text: String) -> i32 {\\n        let hash = RabinKarp::new(&text);\\n        let mut answer = 0;\\n\\n        for len in (2..=text.len()).step_by(2) {\\n            let mut substrings: HashSet<u128> = HashSet::new();\\n            for i in (len - 1)..text.len() {\\n                let mid = (i + i - len) / 2;\\n                let left = (i - len + 1)..=mid;\\n                let right = mid + 1..=i;\\n                if hash.is_same(left, right) {\\n                    let slice = (i - len + 1)..=i;\\n                    substrings.insert(hash.get_hash(slice));\\n                }\\n            }\\n            answer += substrings.len() as i32;\\n        }\\n\\n        answer\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 561453,
                "title": "faster-than-100-rust-solutions-116ms-o-n-2-hashing-solution",
                "content": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn distinct_echo_substrings(text: String) -> i32 {\\n        const P1 : i32 = 127;\\n        const M1 : i32 = 75798632;\\n        const P2 : i32 = 1007;\\n        const M2 : i32 = 665729789;\\n        \\n        let data = text.as_bytes();\\n        let N = data.len();\\n        let mut hash = vec![vec![(0, 0); N]; N];\\n        \\n        for i in 0..N {\\n            hash[i][i] = (data[i] as i32, data[i] as i32);\\n            for j in (i+1)..N {\\n                hash[i][j] = (\\n                    (hash[i][j-1].0 * P1 + data[j] as i32) % M1,\\n                    (hash[i][j-1].0 * P2 + data[j] as i32) % M2\\n                );\\n            }\\n        }\\n        \\n        let mut ans = 0;\\n        \\n        for len in 1..=(N/2) {\\n            let mut exists = HashSet::new();\\n            for i in 0..=(N-len*2) {\\n                if hash[i][i+len-1] == hash[i+len][i+len*2-1] {\\n                    exists.insert(hash[i][i+len-1]);\\n                }\\n            }\\n            ans += exists.len() as i32;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn distinct_echo_substrings(text: String) -> i32 {\\n        const P1 : i32 = 127;\\n        const M1 : i32 = 75798632;\\n        const P2 : i32 = 1007;\\n        const M2 : i32 = 665729789;\\n        \\n        let data = text.as_bytes();\\n        let N = data.len();\\n        let mut hash = vec![vec![(0, 0); N]; N];\\n        \\n        for i in 0..N {\\n            hash[i][i] = (data[i] as i32, data[i] as i32);\\n            for j in (i+1)..N {\\n                hash[i][j] = (\\n                    (hash[i][j-1].0 * P1 + data[j] as i32) % M1,\\n                    (hash[i][j-1].0 * P2 + data[j] as i32) % M2\\n                );\\n            }\\n        }\\n        \\n        let mut ans = 0;\\n        \\n        for len in 1..=(N/2) {\\n            let mut exists = HashSet::new();\\n            for i in 0..=(N-len*2) {\\n                if hash[i][i+len-1] == hash[i+len][i+len*2-1] {\\n                    exists.insert(hash[i][i+len-1]);\\n                }\\n            }\\n            ans += exists.len() as i32;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 557415,
                "title": "accepted-c-hashing-solution",
                "content": "```\\npublic class Solution\\n    {\\n        public int DistinctEchoSubstrings(string str)\\n        {\\n            checked\\n            {\\n                int n = str.Length;\\n                int @base = 27;\\n                long modulus = (long)Math.Pow(2, 31);\\n\\n                long[] aL = new long[n + 1];\\n                long al = 1;\\n                long h = 0;\\n                long[] hLeftToRight = new long[n];\\n\\n                for (int i = 0; i < n; ++i)\\n                {\\n                    var num = (long)(str[i] - \\'a\\' + 1);\\n                    al = (al * @base) % modulus;\\n                    aL[i + 1] = al;\\n\\n                    h = (h * @base + num) % modulus;\\n                    hLeftToRight[i] = h;\\n                }\\n\\n                ISet<long> res = new HashSet<long>();\\n\\n                for (int start = 0; start < str.Length - 1; start++)\\n                {\\n                    for (int end = start + 1; end < str.Length; end+=2)\\n                    {\\n                        int length = end - start + 1;\\n                        int halfLength = length / 2;\\n                        int leftEnd = start + halfLength - 1;\\n\\n                        long leftSubstr = hLeftToRight[leftEnd];\\n                        int excludeIdx = start - 1;\\n\\n                        if (excludeIdx >= 0)\\n                        {\\n                            long longExclude = hLeftToRight[excludeIdx] * aL[halfLength] % modulus;\\n\\n                            leftSubstr -= longExclude;\\n                            leftSubstr += modulus;\\n                            leftSubstr %= modulus;\\n                        }\\n\\n\\n                        long rightSubstr = hLeftToRight[end];\\n                        excludeIdx = leftEnd;\\n\\n                        if (excludeIdx >= 0)\\n                        {\\n                            long longExclude = hLeftToRight[excludeIdx] * aL[halfLength] % modulus;\\n\\n                            rightSubstr -= longExclude;\\n                            rightSubstr += modulus;\\n                            rightSubstr %= modulus;\\n                        }\\n\\n                        if (leftSubstr == rightSubstr)\\n                        {\\n                            res.Add(leftSubstr);\\n                        }\\n                    }\\n                }\\n\\n                return res.Count;\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n    {\\n        public int DistinctEchoSubstrings(string str)\\n        {\\n            checked\\n            {\\n                int n = str.Length;\\n                int @base = 27;\\n                long modulus = (long)Math.Pow(2, 31);\\n\\n                long[] aL = new long[n + 1];\\n                long al = 1;\\n                long h = 0;\\n                long[] hLeftToRight = new long[n];\\n\\n                for (int i = 0; i < n; ++i)\\n                {\\n                    var num = (long)(str[i] - \\'a\\' + 1);\\n                    al = (al * @base) % modulus;\\n                    aL[i + 1] = al;\\n\\n                    h = (h * @base + num) % modulus;\\n                    hLeftToRight[i] = h;\\n                }\\n\\n                ISet<long> res = new HashSet<long>();\\n\\n                for (int start = 0; start < str.Length - 1; start++)\\n                {\\n                    for (int end = start + 1; end < str.Length; end+=2)\\n                    {\\n                        int length = end - start + 1;\\n                        int halfLength = length / 2;\\n                        int leftEnd = start + halfLength - 1;\\n\\n                        long leftSubstr = hLeftToRight[leftEnd];\\n                        int excludeIdx = start - 1;\\n\\n                        if (excludeIdx >= 0)\\n                        {\\n                            long longExclude = hLeftToRight[excludeIdx] * aL[halfLength] % modulus;\\n\\n                            leftSubstr -= longExclude;\\n                            leftSubstr += modulus;\\n                            leftSubstr %= modulus;\\n                        }\\n\\n\\n                        long rightSubstr = hLeftToRight[end];\\n                        excludeIdx = leftEnd;\\n\\n                        if (excludeIdx >= 0)\\n                        {\\n                            long longExclude = hLeftToRight[excludeIdx] * aL[halfLength] % modulus;\\n\\n                            rightSubstr -= longExclude;\\n                            rightSubstr += modulus;\\n                            rightSubstr %= modulus;\\n                        }\\n\\n                        if (leftSubstr == rightSubstr)\\n                        {\\n                            res.Add(leftSubstr);\\n                        }\\n                    }\\n                }\\n\\n                return res.Count;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 554241,
                "title": "c-record-the-previous-position",
                "content": "~~~\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        vector<int> alp(26,-1);\\n        vector<int> hmap(text.size(), -1);\\n        for(int i=0; i<text.size(); i++){\\n            hmap[i] = alp[text[i]-\\'a\\'];   //Record the Previous Position\\n            alp[text[i]-\\'a\\'] = i;\\n        }\\n        unordered_set<string> hset;\\n        vector<int> consec(26,0);\\n        \\n        int res = 0;\\n        for(int i=0; i<text.size(); i++){\\n            if(hmap[i]==-1) continue;\\n            int cur = i;\\n            while(cur>=0 && text.at(cur)==text.at(i))\\n                cur--;      //record the longest single-letter-repeated substring\\n            consec[text.at(i)-\\'a\\'] = max(consec[text.at(i)-\\'a\\'], i-cur);\\n            cur++;\\n            int ind = hmap[cur];\\n            while(ind!=-1){\\n                if(ind+1< i-ind)    break;\\n                int dis = i - ind;\\n                string s1 = text.substr(ind-(dis-1), dis);\\n                string s2 = text.substr(ind+1, dis);\\n                if(s1==s2 && !hset.count(s1)){\\n                    hset.insert(s1);\\n                    res++;\\n                }\\n                ind = hmap[ind];\\n            }\\n        }\\n        \\n        for(int ele:consec) // deal with the single-letter-repeated cases\\n            res += ele/2;\\n        return res;\\n    }\\n};\\n~~~",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        vector<int> alp(26,-1);\\n        vector<int> hmap(text.size(), -1);\\n        for(int i=0; i<text.size(); i++){\\n            hmap[i] = alp[text[i]-\\'a\\'];   //Record the Previous Position\\n            alp[text[i]-\\'a\\'] = i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 550823,
                "title": "testcase-doubt",
                "content": "One of the test case is failing but cannot understand why\\n\"aaaaaaaaaa\"\\nOutput is showing 5, can anyone explain how?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 539575,
                "title": "trie-solution-o-n-2-but-fails-one-test-case",
                "content": "Idea is to put all suffix of `text` to a trie, the dfs on the trie. For each node on the trie, the path from root to that node represents a unique substring. Just need to store the ending positions of these substrings, then we can check if a substring appears twice in a row.\\n\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        # n^2 Trie. Fails one test case.\\n        trie = {\\'pos\\': set()}\\n        n = len(text)\\n        def add_trie(text, s):\\n            p = trie\\n            for i in range(s, n):\\n                c = text[i]\\n                if c not in p:\\n                    p[c] = {\\'pos\\': set()}\\n                p = p[c]\\n                p[\\'pos\\'].add(i)\\n                \\n        def dfs(node, l):\\n            for p in node[\\'pos\\']:\\n                if p + l in node[\\'pos\\']:\\n                    self.res += 1\\n                    break\\n            for c in node:\\n                if c != \\'pos\\' and len(node[c][\\'pos\\']) >= 2:\\n                    dfs(node[c], l+1)\\n            \\n        \\n        for i in range(n):\\n            add_trie(text, i)\\n        self.res = 0\\n        dfs(trie, 0)\\n        return self.res\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        # n^2 Trie. Fails one test case.\\n        trie = {\\'pos\\': set()}\\n        n = len(text)\\n        def add_trie(text, s):\\n            p = trie\\n            for i in range(s, n):\\n                c = text[i]\\n                if c not in p:\\n                    p[c] = {\\'pos\\': set()}\\n                p = p[c]\\n                p[\\'pos\\'].add(i)\\n                \\n        def dfs(node, l):\\n            for p in node[\\'pos\\']:\\n                if p + l in node[\\'pos\\']:\\n                    self.res += 1\\n                    break\\n            for c in node:\\n                if c != \\'pos\\' and len(node[c][\\'pos\\']) >= 2:\\n                    dfs(node[c], l+1)\\n            \\n        \\n        for i in range(n):\\n            add_trie(text, i)\\n        self.res = 0\\n        dfs(trie, 0)\\n        return self.res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 523343,
                "title": "simple-java-solution-easy-to-understand",
                "content": "Use a hashmap to record the positions of each character and find same string with same first character.\\n```\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        HashMap<Character, List<Integer>> map = new HashMap<>();\\n        char[] chars = text.toCharArray();\\n        for (int i = 0; i < chars.length; i++) {\\n            if (!map.containsKey(chars[i])) {\\n                map.put(chars[i], new LinkedList<Integer>());\\n            }\\n            map.get(chars[i]).add(i);\\n        }// O(n)\\n        HashSet<String> set = new HashSet<>();\\n        for (char c: map.keySet()) {\\n            List<Integer> list = map.get(c);\\n            if (list.size() <= 1)\\n                continue;\\n            StringBuilder sb = new StringBuilder();\\n            for (int i: list) {\\n                for (int j: list) {\\n                    int tmpLen = j - i;\\n                    if (i >= j || j + tmpLen > text.length())\\n                        continue;\\n                    if (text.substring(i, j).equals(text.substring(j, j +tmpLen))) {\\n                        set.add(text.substring(i, j)); \\n                    }\\n                }\\n            }\\n        }// O(n2)\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        HashMap<Character, List<Integer>> map = new HashMap<>();\\n        char[] chars = text.toCharArray();\\n        for (int i = 0; i < chars.length; i++) {\\n            if (!map.containsKey(chars[i])) {\\n                map.put(chars[i], new LinkedList<Integer>());\\n            }\\n            map.get(chars[i]).add(i);\\n        }// O(n)\\n        HashSet<String> set = new HashSet<>();\\n        for (char c: map.keySet()) {\\n            List<Integer> list = map.get(c);\\n            if (list.size() <= 1)\\n                continue;\\n            StringBuilder sb = new StringBuilder();\\n            for (int i: list) {\\n                for (int j: list) {\\n                    int tmpLen = j - i;\\n                    if (i >= j || j + tmpLen > text.length())\\n                        continue;\\n                    if (text.substring(i, j).equals(text.substring(j, j +tmpLen))) {\\n                        set.add(text.substring(i, j)); \\n                    }\\n                }\\n            }\\n        }// O(n2)\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 510415,
                "title": "o-n-2-solution-using-trie-without-rolling-hash",
                "content": "The idea is simple. We look for valid substrings of length **1,2...N** .\\n\\nOur final answer will reside in variable **ans**.\\nNow for say some length say **l**,\\nWe maintain a **Trie T** which will hold valid substrings to avoid duplicates.\\nWe compare characters starting at \\n**i = 0, j = i + l**\\nand as long as they are equal, we increment a count **c** and also add it to a buffer **buf**.\\nIf the **c** goes all the way till **l**, then we have a valid substring and add **buf** to **T** (only if it\\'s not already there) and increment the **ans** variable. \\nWhen we slide the window, we keep the amount of match we had in previous window (*both buf and c are kept as it is, just that we remove one character from buf and decrement c by 1 to account for the outgoing character from the window*).\\nThis way we can simply solve in one iteration per length l.\\n\\n***TC = O(n^2)\\nSC = O(n^2)*\\n\\n```\\nclass Solution {\\n    \\n\\t// CODE FOR TRIE\\n    public static class Trie { \\n      \\n    // Alphabet size (# of symbols) \\n    static final int ALPHABET_SIZE = 26; \\n      \\n    // trie node \\n    public static class TrieNode \\n    { \\n        TrieNode[] children = new TrieNode[ALPHABET_SIZE]; \\n       \\n        // isEndOfWord is true if the node represents \\n        // end of a word \\n        boolean isEndOfWord; \\n          \\n        TrieNode(){ \\n            isEndOfWord = false; \\n            for (int i = 0; i < ALPHABET_SIZE; i++) \\n                children[i] = null; \\n        } \\n    }; \\n       \\n    static TrieNode root;  \\n      \\n    // If not present, inserts key into trie \\n    // If the key is prefix of trie node,  \\n    // just marks leaf node \\n    static void insert(String key) \\n    { \\n        int level; \\n        int length = key.length(); \\n        int index; \\n       \\n        TrieNode pCrawl = root; \\n       \\n        for (level = 0; level < length; level++) \\n        { \\n            index = key.charAt(level) - \\'a\\'; \\n            if (pCrawl.children[index] == null) \\n                pCrawl.children[index] = new TrieNode(); \\n       \\n            pCrawl = pCrawl.children[index]; \\n        } \\n       \\n        // mark last node as leaf \\n        pCrawl.isEndOfWord = true; \\n    } \\n       \\n    // Returns true if key presents in trie, else false \\n    static boolean search(String key) \\n    { \\n        int level; \\n        int length = key.length(); \\n        int index; \\n        TrieNode pCrawl = root; \\n       \\n        for (level = 0; level < length; level++) \\n        { \\n            index = key.charAt(level) - \\'a\\'; \\n       \\n            if (pCrawl.children[index] == null) \\n                return false; \\n       \\n            pCrawl = pCrawl.children[index]; \\n        } \\n       \\n        return (pCrawl != null && pCrawl.isEndOfWord); \\n    } \\n} \\n    \\n\\t\\n\\t// ACTUAL SOLUTION\\n    public int distinctEchoSubstrings(String text) {\\n        int ans = 0;\\n        int N = text.length();\\n        for(int l=1;l<=N;l++) {\\n            // System.out.println(\"l: \" + l);\\n            \\n            int i = 0;\\n            int c = 0;\\n            StringBuilder buf = new StringBuilder();\\n            Trie.root = new Trie.TrieNode();\\n            while(i < N) {\\n                int start = i;\\n                int j = i + l;\\n                // System.out.println(\"i: \" + i + \", j: \" + j);\\n                \\n                if(j < N) {\\n                    while(j < N && c < l && text.charAt(j) == text.charAt(i)) {\\n                        buf.append(text.charAt(i));\\n                        i++;\\n                        j++;\\n                        c++;\\n                    }\\n                    \\n                    // System.out.println(\"c: \" + c);\\n                    if(c == l) {\\n                        String str = buf.toString();\\n                        if(!Trie.search(str)) {\\n                            Trie.insert(str);\\n                            ans++;\\n                        }\\n                    }\\n                    if(c == 0) {\\n                        i++;\\n                    }\\n                    else {\\n                        buf = buf.deleteCharAt(0);\\n                        c--;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n\\t// CODE FOR TRIE\\n    public static class Trie { \\n      \\n    // Alphabet size (# of symbols) \\n    static final int ALPHABET_SIZE = 26; \\n      \\n    // trie node \\n    public static class TrieNode \\n    { \\n        TrieNode[] children = new TrieNode[ALPHABET_SIZE]; \\n       \\n        // isEndOfWord is true if the node represents \\n        // end of a word \\n        boolean isEndOfWord; \\n          \\n        TrieNode(){ \\n            isEndOfWord = false; \\n            for (int i = 0; i < ALPHABET_SIZE; i++) \\n                children[i] = null; \\n        } \\n    }; \\n       \\n    static TrieNode root;  \\n      \\n    // If not present, inserts key into trie \\n    // If the key is prefix of trie node,  \\n    // just marks leaf node \\n    static void insert(String key) \\n    { \\n        int level; \\n        int length = key.length(); \\n        int index; \\n       \\n        TrieNode pCrawl = root; \\n       \\n        for (level = 0; level < length; level++) \\n        { \\n            index = key.charAt(level) - \\'a\\'; \\n            if (pCrawl.children[index] == null) \\n                pCrawl.children[index] = new TrieNode(); \\n       \\n            pCrawl = pCrawl.children[index]; \\n        } \\n       \\n        // mark last node as leaf \\n        pCrawl.isEndOfWord = true; \\n    } \\n       \\n    // Returns true if key presents in trie, else false \\n    static boolean search(String key) \\n    { \\n        int level; \\n        int length = key.length(); \\n        int index; \\n        TrieNode pCrawl = root; \\n       \\n        for (level = 0; level < length; level++) \\n        { \\n            index = key.charAt(level) - \\'a\\'; \\n       \\n            if (pCrawl.children[index] == null) \\n                return false; \\n       \\n            pCrawl = pCrawl.children[index]; \\n        } \\n       \\n        return (pCrawl != null && pCrawl.isEndOfWord); \\n    } \\n} \\n    \\n\\t\\n\\t// ACTUAL SOLUTION\\n    public int distinctEchoSubstrings(String text) {\\n        int ans = 0;\\n        int N = text.length();\\n        for(int l=1;l<=N;l++) {\\n            // System.out.println(\"l: \" + l);\\n            \\n            int i = 0;\\n            int c = 0;\\n            StringBuilder buf = new StringBuilder();\\n            Trie.root = new Trie.TrieNode();\\n            while(i < N) {\\n                int start = i;\\n                int j = i + l;\\n                // System.out.println(\"i: \" + i + \", j: \" + j);\\n                \\n                if(j < N) {\\n                    while(j < N && c < l && text.charAt(j) == text.charAt(i)) {\\n                        buf.append(text.charAt(i));\\n                        i++;\\n                        j++;\\n                        c++;\\n                    }\\n                    \\n                    // System.out.println(\"c: \" + c);\\n                    if(c == l) {\\n                        String str = buf.toString();\\n                        if(!Trie.search(str)) {\\n                            Trie.insert(str);\\n                            ans++;\\n                        }\\n                    }\\n                    if(c == 0) {\\n                        i++;\\n                    }\\n                    else {\\n                        buf = buf.deleteCharAt(0);\\n                        c--;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 492546,
                "title": "scala-rolling-hash",
                "content": "i: denotes the hash and power values for the strings that ends at i-indexed char\\n\\n```Scala\\n  def distinctEchoSubstrings(text: String): Int = {\\n    \\n    val len = text.length\\n    val hash, power = Array.ofDim[Long](len)\\n    val base = 29L\\n    val mod = 1000000007L\\n    hash(0) = text.charAt(0)\\n    power(0) = base\\n\\n    for (i <- 1 until len) {\\n      hash(i) = ((hash(i - 1) * base) + text.charAt(i)) % mod\\n      power(i) = (base * power(i - 1)) % mod\\n    }\\n\\n    def h(start: Int, end: Int): Long = (hash(end) - (if (start - 1 >= 0) hash(start - 1) else 0) * power(end - start) % mod + mod) % mod\\n\\n\\n    import scala.collection.mutable.Set\\n    val counter = Set[Long]()\\n    for (d <- 1 to len - 1 by 2) {\\n      for (i <- 0 to len - 2 if (i + d < len)) {\\n        val mid = i + d / 2\\n        val h1 = h(i, mid)\\n        val h2 = h(mid + 1, i + d)\\n        if (h1 == h2) counter add h1\\n      }\\n    }\\n    counter.size\\n  }\\n```",
                "solutionTags": [],
                "code": "```Scala\\n  def distinctEchoSubstrings(text: String): Int = {\\n    \\n    val len = text.length\\n    val hash, power = Array.ofDim[Long](len)\\n    val base = 29L\\n    val mod = 1000000007L\\n    hash(0) = text.charAt(0)\\n    power(0) = base\\n\\n    for (i <- 1 until len) {\\n      hash(i) = ((hash(i - 1) * base) + text.charAt(i)) % mod\\n      power(i) = (base * power(i - 1)) % mod\\n    }\\n\\n    def h(start: Int, end: Int): Long = (hash(end) - (if (start - 1 >= 0) hash(start - 1) else 0) * power(end - start) % mod + mod) % mod\\n\\n\\n    import scala.collection.mutable.Set\\n    val counter = Set[Long]()\\n    for (d <- 1 to len - 1 by 2) {\\n      for (i <- 0 to len - 2 if (i + d < len)) {\\n        val mid = i + d / 2\\n        val h1 = h(i, mid)\\n        val h2 = h(mid + 1, i + d)\\n        if (h1 == h2) counter add h1\\n      }\\n    }\\n    counter.size\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 490113,
                "title": "c-o-n-2-rabin-karp-fingerprint-substring-search-from-algs4-not-faster-but-more-readable",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        // return func1(text);\\n        return func2(text.c_str(), text.length());\\n    }\\n\\n    // 1. Basic string compare solution, use hash-set do cache\\n    // Time: O(n^3) time, Space: O(n^2)\\n    int func1(string& text) {\\n        int N = text.length();\\n        unordered_set<string> set;\\n\\n        for (int len = 1; len <= N/2; len++) {\\n            for (int i = 0; i+2*len-1 < N; i++) {\\n                string s = text.substr(i, len);\\n                if (set.count(s) > 0) {\\n                    continue;\\n                }\\n                bool same = true;\\n                for (int j = 0; j < len; j++) {\\n                    if (text[i+j] != text[i+j+len]) {\\n                        same = false;\\n                        break;\\n                    }\\n                }\\n                if (same) {\\n                    set.emplace(s);\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n\\n    /*\\n     * 2. Rabin-Karp substring search, Time: O(n^2), Space: O(1)\\n     * According to \"Algorithms, 4th Edition => 5.3 Substring Search => Rabin-Karp fingerprint search\"\\n     * Onile implement: https://algs4.cs.princeton.edu/53substring/  => RabinKarp.java\\n     *\\n     * My notes:\\n     * #1 Use `const char*` instead `string&` for text to pass into the functions.\\n     * #2 Should use string type `unordered_set<string> set` not `long type` to avoid collision.\\n     * #3 Base on #2, should do `RK_Recheck` when hash value is equal for sure.\\n     * #4 Do #2 and #3 will make the code too slow to pass.\\n     * #5 There are a lot of thing can be done to speed up my implement, for readable, I just leave it this way.\\n     */\\n    const int R = 26;        // There are only low letter in string\\n    const long Q = 1e13 + 7; // Random chose some big prime\\n\\n    int func2(const char* text, int N) {\\n        long RM = 1;\\n        // unordered_set<string> set;\\n        unordered_set<long> set;\\n\\n        for (int len = 1; len <= N/2; len++) {\\n            // M == len, use \\'M\\' to keep same to algs4\\'s implement\\n            int M = len;\\n            // long RM = RK_RM(M, R, Q);\\n            if (M > 1) {\\n                RM = RM * R % Q;\\n            }\\n            long curr_hash1 = 0;\\n            long curr_hash2 = 0;\\n            \\n            for (int i = 0; i+2*len-1 < N; i++) {\\n                if (i == 0) {\\n                    curr_hash1 = RK_Hash(text, i, M, R, Q);\\n                    curr_hash2 = RK_Hash(text, i+M, M, R, Q);\\n                } else {\\n                    curr_hash1 = RK_Shift(text, i-1, M, R, Q, RM, curr_hash1);\\n                    curr_hash2 = RK_Shift(text, i-1+M, M, R, Q, RM, curr_hash2);\\n                }\\n                if (curr_hash1 == curr_hash2 && RK_Recheck(text, i, i+M)) {\\n                    // set.emplace(text.substr(i, M));\\n                    set.emplace(curr_hash1);\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n\\n    long RK_RM(int M, int R, long Q) {\\n        long RM = 1;\\n        for (int i = 1; i <= M-1; i++) {\\n            RM = (R * RM) % Q;\\n        }\\n        return RM;\\n    }\\n    long RK_Hash(const char* text, int i, int M, int R, long Q) {\\n        long h = 0;\\n        for (int j = 0; j < M; j++) {\\n            h = (R * h + text[i+j]) % Q;\\n        }\\n        return h;\\n    }\\n    long RK_Shift(const char* text, int i, int M, int R, long Q, long RM, long last_hash) {\\n        last_hash = (last_hash + Q - RM * text[i] % Q) % Q;\\n        last_hash = (last_hash * R + text[i+M]) % Q;\\n        return last_hash;\\n    }\\n    // Honest, we should always do Recheck, but will make \"a.....a\" case Time-Limit-Exceeded\\n    bool RK_Recheck(const char* text, int i, int j) {\\n        return true;\\n        for (int len = 0; len < j - i; len++) {\\n            if (text[i+len] != text[j+len]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        // return func1(text);\\n        return func2(text.c_str(), text.length());\\n    }\\n\\n    // 1. Basic string compare solution, use hash-set do cache\\n    // Time: O(n^3) time, Space: O(n^2)\\n    int func1(string& text) {\\n        int N = text.length();\\n        unordered_set<string> set;\\n\\n        for (int len = 1; len <= N/2; len++) {\\n            for (int i = 0; i+2*len-1 < N; i++) {\\n                string s = text.substr(i, len);\\n                if (set.count(s) > 0) {\\n                    continue;\\n                }\\n                bool same = true;\\n                for (int j = 0; j < len; j++) {\\n                    if (text[i+j] != text[i+j+len]) {\\n                        same = false;\\n                        break;\\n                    }\\n                }\\n                if (same) {\\n                    set.emplace(s);\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n\\n    /*\\n     * 2. Rabin-Karp substring search, Time: O(n^2), Space: O(1)\\n     * According to \"Algorithms, 4th Edition => 5.3 Substring Search => Rabin-Karp fingerprint search\"\\n     * Onile implement: https://algs4.cs.princeton.edu/53substring/  => RabinKarp.java\\n     *\\n     * My notes:\\n     * #1 Use `const char*` instead `string&` for text to pass into the functions.\\n     * #2 Should use string type `unordered_set<string> set` not `long type` to avoid collision.\\n     * #3 Base on #2, should do `RK_Recheck` when hash value is equal for sure.\\n     * #4 Do #2 and #3 will make the code too slow to pass.\\n     * #5 There are a lot of thing can be done to speed up my implement, for readable, I just leave it this way.\\n     */\\n    const int R = 26;        // There are only low letter in string\\n    const long Q = 1e13 + 7; // Random chose some big prime\\n\\n    int func2(const char* text, int N) {\\n        long RM = 1;\\n        // unordered_set<string> set;\\n        unordered_set<long> set;\\n\\n        for (int len = 1; len <= N/2; len++) {\\n            // M == len, use \\'M\\' to keep same to algs4\\'s implement\\n            int M = len;\\n            // long RM = RK_RM(M, R, Q);\\n            if (M > 1) {\\n                RM = RM * R % Q;\\n            }\\n            long curr_hash1 = 0;\\n            long curr_hash2 = 0;\\n            \\n            for (int i = 0; i+2*len-1 < N; i++) {\\n                if (i == 0) {\\n                    curr_hash1 = RK_Hash(text, i, M, R, Q);\\n                    curr_hash2 = RK_Hash(text, i+M, M, R, Q);\\n                } else {\\n                    curr_hash1 = RK_Shift(text, i-1, M, R, Q, RM, curr_hash1);\\n                    curr_hash2 = RK_Shift(text, i-1+M, M, R, Q, RM, curr_hash2);\\n                }\\n                if (curr_hash1 == curr_hash2 && RK_Recheck(text, i, i+M)) {\\n                    // set.emplace(text.substr(i, M));\\n                    set.emplace(curr_hash1);\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n\\n    long RK_RM(int M, int R, long Q) {\\n        long RM = 1;\\n        for (int i = 1; i <= M-1; i++) {\\n            RM = (R * RM) % Q;\\n        }\\n        return RM;\\n    }\\n    long RK_Hash(const char* text, int i, int M, int R, long Q) {\\n        long h = 0;\\n        for (int j = 0; j < M; j++) {\\n            h = (R * h + text[i+j]) % Q;\\n        }\\n        return h;\\n    }\\n    long RK_Shift(const char* text, int i, int M, int R, long Q, long RM, long last_hash) {\\n        last_hash = (last_hash + Q - RM * text[i] % Q) % Q;\\n        last_hash = (last_hash * R + text[i+M]) % Q;\\n        return last_hash;\\n    }\\n    // Honest, we should always do Recheck, but will make \"a.....a\" case Time-Limit-Exceeded\\n    bool RK_Recheck(const char* text, int i, int j) {\\n        return true;\\n        for (int len = 0; len < j - i; len++) {\\n            if (text[i+len] != text[j+len]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 487989,
                "title": "c-suffix-trie-got-tle-help",
                "content": "Hi,\\nI thought about using suffix trie for this problem, but it gets TLE for the final test cases (37/38 passed).\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.....aaaaaaaaa\"\\n\\nThe idea is very similar to this \\nhttps://leetcode.com/problems/distinct-echo-substrings/discuss/477896/No-rolling-hashTrie-with-optimization-and-explanation\\nThe code is also quite similar.\\n\\n\\nThe complexity for this is obviously O(n^2), I just don\\'t know how to improve that.\\n\\n\\n\\n```\\npublic class Solution {\\n    public int DistinctEchoSubstrings(string text) {\\n        var trie = new Trie();\\n        for(var i=0; i<text.Length; i++){\\n            trie.Add(text, i);\\n        }\\n        return trie.total;\\n    }\\n}\\n\\nclass Node{\\n    public Node[] children = new Node[26];\\n    public HashSet<int> starts = new HashSet<int>();\\n    public bool counted;\\n}\\n\\nclass Trie{\\n    Node root = new Node();\\n    public int total;\\n    public void Add(string s, int start){\\n        var curr = root;\\n        for(var i=start; i<s.Length&& (i-start+1<=s.Length-i || i-start+1<=start); i++){\\n            var j = s[i]-\\'a\\';\\n            if(curr.children[j]==null){\\n                curr.children[j] = new Node();\\n            }\\n            curr = curr.children[j];\\n            \\n            if(curr.counted)\\n                continue;\\n            \\n            if(curr.starts.Contains(start-(i-start+1))){\\n                curr.counted = true;\\n                total++;\\n            }\\n            curr.starts.Add(start);\\n        }\\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int DistinctEchoSubstrings(string text) {\\n        var trie = new Trie();\\n        for(var i=0; i<text.Length; i++){\\n            trie.Add(text, i);\\n        }\\n        return trie.total;\\n    }\\n}\\n\\nclass Node{\\n    public Node[] children = new Node[26];\\n    public HashSet<int> starts = new HashSet<int>();\\n    public bool counted;\\n}\\n\\nclass Trie{\\n    Node root = new Node();\\n    public int total;\\n    public void Add(string s, int start){\\n        var curr = root;\\n        for(var i=start; i<s.Length&& (i-start+1<=s.Length-i || i-start+1<=start); i++){\\n            var j = s[i]-\\'a\\';\\n            if(curr.children[j]==null){\\n                curr.children[j] = new Node();\\n            }\\n            curr = curr.children[j];\\n            \\n            if(curr.counted)\\n                continue;\\n            \\n            if(curr.starts.Contains(start-(i-start+1))){\\n                curr.counted = true;\\n                total++;\\n            }\\n            curr.starts.Add(start);\\n        }\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 482765,
                "title": "python-rolling-checksum-and-xor",
                "content": "/!\\\\ There is some probality this doesn\\'t work.\\n\\nThe idea is to calculate the rolling checksum _H_ from the begining til the end element in the string _H &leftarrow; h<sub>0</sub> &bigoplus; ... &bigoplus; h<sub>i</sub>_ ; the function &bigoplus; is chosen so that it is commutative and _h &bigoplus; h = 0_. At any point if the checksum comes back to a previous value it means there is some repeative representation in the string.\\n\\nFor example: With string `text=\\'ABAB\\'`, we have\\n`h_0 = 0`\\n`h_1 = hash(\\'A\\')`\\n`h_2 = hash(\\'A\\')`&bigoplus;`hash(\\'B\\')`\\n`h_3 = hash(\\'A\\')`&bigoplus;`hash(\\'B\\')`&bigoplus;`hash(\\'A\\') = hash(\\'B\\')`\\n`h_4 = hash(\\'A\\')`&bigoplus;`hash(\\'B\\')`&bigoplus;`hash(\\'A\\')` &bigoplus;`hash(\\'B\\') = 0 = h_0`\\n\\nOf course this applies to other ways of repeative as well: `ABCCBA`, `ABACBC`, but we can easily filter out these cases.\\n\\nWe can pick `XOR` to use as &bigoplus; but there is some probability just xor\\'ing the bits doesn\\'t work; increasing the length of the hash can reduce the likelihood.\\n\\n```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        def verify(st):\\n            i = len(st) // 2\\n            return and st[:i] == st[i:]\\n        \\n        hdict = dict([[0, [-1]]]) # dictionary of rolling hash values, hash_value -> locations of the value\\n        sdict = set() # set of found \\'echo\\' subsequences\\n        echo_count = 0\\n        hash_total = 0\\n        for i in range(len(text)):\\n            hash_total ^= hash(text[i])\\n            if hash_total in hdict:\\n\\t\\t\\t\\t# hash found before, there must be some repeatition between this and the previous locations of the hash\\n                for j in hdict[hash_total]:\\n                    esub = text[j + 1:i + 1]\\n                    if esub not in sdict and verify(esub):\\n                        sdict.add(esub)\\n                        echo_count += 1\\n                hdict[hash_total].append(i)\\n            else:\\n                hdict[hash_total] = [i]\\n        return echo_count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        def verify(st):\\n            i = len(st) // 2\\n            return and st[:i] == st[i:]\\n        \\n        hdict = dict([[0, [-1]]]) # dictionary of rolling hash values, hash_value -> locations of the value\\n        sdict = set() # set of found \\'echo\\' subsequences\\n        echo_count = 0\\n        hash_total = 0\\n        for i in range(len(text)):\\n            hash_total ^= hash(text[i])\\n            if hash_total in hdict:\\n\\t\\t\\t\\t# hash found before, there must be some repeatition between this and the previous locations of the hash\\n                for j in hdict[hash_total]:\\n                    esub = text[j + 1:i + 1]\\n                    if esub not in sdict and verify(esub):\\n                        sdict.add(esub)\\n                        echo_count += 1\\n                hdict[hash_total].append(i)\\n            else:\\n                hdict[hash_total] = [i]\\n        return echo_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 482206,
                "title": "java-solution-finish",
                "content": "public static int distinctEchoSubstrings(String text) {\\n        final Set<String> found = new HashSet<>();\\n        final char[] chars = text.toCharArray();\\n        for (int i = 0; i < chars.length; i++) {\\n            for (int j = i + 1; j < text.length(); j++) {\\n                if (chars[i] == chars[j]) {\\n                    if (j + j - i <= text.length()) {\\n                        final String first = text.substring(i, j);\\n                        final String second = text.substring(j, j + j - i);\\n                        if (first.equals(second)) {\\n                            found.add(first + second);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return found.size();\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "public static int distinctEchoSubstrings(String text) {\\n        final Set<String> found = new HashSet<>();\\n        final char[] chars = text.toCharArray();\\n        for (int i = 0; i < chars.length; i++) {\\n            for (int j = i + 1; j < text.length(); j++) {\\n                if (chars[i] == chars[j]) {\\n                    if (j + j - i <= text.length()) {\\n                        final String first = text.substring(i, j);\\n                        final String second = text.substring(j, j + j - i);\\n                        if (first.equals(second)) {\\n                            found.add(first + second);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return found.size();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 482080,
                "title": "python3-brute-force-will-work-c-brute-force-will-not",
                "content": "I submitted a C++ brute force solution and it fails on the biggest test case taking about 900ms. Then with python3 I applied the same logic and it passed with around 1000ms. Didn\\'t realize that is how leetcode works.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 481811,
                "title": "javascript-nothing-fancy",
                "content": "```javascript\\n/**\\n * @param {string} text\\n * @return {number}\\n */\\nvar distinctEchoSubstrings = function(text) {\\n    const store = new Set();\\n    for (let i = 0; i < text.length; i++) {\\n        for (let j = i + 1; j < text.length; j++) {\\n            const left = text.substring(i,j);\\n\\t\\t\\tconst right = text.substring(j, j + j - i);\\n            if (left === right) store.add(left);\\n        }\\n    }\\n    return store.size;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {string} text\\n * @return {number}\\n */\\nvar distinctEchoSubstrings = function(text) {\\n    const store = new Set();\\n    for (let i = 0; i < text.length; i++) {\\n        for (let j = i + 1; j < text.length; j++) {\\n            const left = text.substring(i,j);\\n\\t\\t\\tconst right = text.substring(j, j + j - i);\\n            if (left === right) store.add(left);\\n        }\\n    }\\n    return store.size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 479109,
                "title": "solution-with-sliding-window",
                "content": "Solution with Sliding WIndow technique:\\n\\nIdea: keep the \"last\" as the value of smallest index such that text[last:i] == text[last+len:i+len]\\n\\n```\\nlast is the left pointer;\\ni    is the right pointer;\\n```\\n```\\n    int distinctEchoSubstrings(string text) {\\n        unordered_set<string> s;\\n        for(int len=1;len<=text.size()/2;len++) {\\n            int last = 0;\\n            for(int i=0;i+len<text.size();i++) {\\n                if(text[i]!=text[i+len]) {\\n                    last = i+1;\\n                } else {\\n                    if(i-last+1>=len) {\\n                        // now, we have a substring text.substr(i-len+1, len) == text.substr(i+1, len)\\n                        s.insert(text.substr(i-len+1, len));\\n                    }\\n                }\\n            }\\n        }\\n        return s.size();\\n    }\\n```\\nTime: O(n^2)\\nfaster than 61.30% of C++ online submissions",
                "solutionTags": [],
                "code": "```\\nlast is the left pointer;\\ni    is the right pointer;\\n```\n```\\n    int distinctEchoSubstrings(string text) {\\n        unordered_set<string> s;\\n        for(int len=1;len<=text.size()/2;len++) {\\n            int last = 0;\\n            for(int i=0;i+len<text.size();i++) {\\n                if(text[i]!=text[i+len]) {\\n                    last = i+1;\\n                } else {\\n                    if(i-last+1>=len) {\\n                        // now, we have a substring text.substr(i-len+1, len) == text.substr(i+1, len)\\n                        s.insert(text.substr(i-len+1, len));\\n                    }\\n                }\\n            }\\n        }\\n        return s.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 478960,
                "title": "c-hash-solution-just-o-n-2",
                "content": "In other solution, they use string_view to reduce time.but i think just storage hashvalue is better good.\\n\\nfor example\\n```cpp\\nclass Hash{\\ntypedef long long ll;\\nprivate:\\n  vector<ll> table1,table2;\\n  vector<ll> store1,store2;\\n  const ll Mod1 = 1e9+7,Mod2 = 998244353;\\n  const ll B1 = 131,B2 = 13131;\\npublic:\\n  Hash(const string &str){\\n    table1.resize(str.size());\\n    table2.resize(str.size());\\n    store1.resize(str.size());\\n    store2.resize(str.size());\\n    for(int i=0;i<str.size();++i){\\n      if(i == 0){\\n        table1[i] = table2[i] = str[i];\\n        store1[i] = store2[i] = 1;\\n      }else{\\n        table1[i] = (table1[i-1]*B1 + str[i])%Mod1;\\n        store1[i] = (store1[i-1]*B1)%Mod1;\\n        \\n        table2[i] = (table2[i-1]*B2 + str[i])%Mod2;\\n        store2[i] = (store2[i-1]*B2)%Mod2;\\n      }\\n    }\\n  }\\n  ll getHashValue1(int l,int r){\\n    if(l == 0){\\n      return table1[r];\\n    }else{\\n      ll value1 = (table1[r]-table1[l-1]*store1[r-l+1])%Mod1;\\n      value1 = (value1+Mod1)%Mod1;\\n      return value1;\\n    }\\n  }\\n  ll getHashValue2(int l,int r){\\n    if(l == 0){\\n      return table2[r];\\n    }else{\\n      ll value2 = (table2[r]-table2[l-1]*store2[r-l+1])%Mod2;\\n      value2 = (value2+Mod2)%Mod2;\\n      return value2;\\n    }\\n  }\\n};\\n\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    int distinctEchoSubstrings(string text) {\\n        Hash h(text);\\n        unordered_set<ll> st;\\n        const char* p = text.c_str();\\n        for(int i=0;i<text.size();++i){\\n            for(int j=1;i+2*j<=text.size();++j){\\n                ll h1 = h.getHashValue1(i,i+j-1);\\n                ll h2 = h.getHashValue1(i+j,i+2*j-1);\\n                if(h1 == h2){\\n                    st.insert(h1);\\n                }\\n            }\\n        }\\n        return (int)st.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Hash{\\ntypedef long long ll;\\nprivate:\\n  vector<ll> table1,table2;\\n  vector<ll> store1,store2;\\n  const ll Mod1 = 1e9+7,Mod2 = 998244353;\\n  const ll B1 = 131,B2 = 13131;\\npublic:\\n  Hash(const string &str){\\n    table1.resize(str.size());\\n    table2.resize(str.size());\\n    store1.resize(str.size());\\n    store2.resize(str.size());\\n    for(int i=0;i<str.size();++i){\\n      if(i == 0){\\n        table1[i] = table2[i] = str[i];\\n        store1[i] = store2[i] = 1;\\n      }else{\\n        table1[i] = (table1[i-1]*B1 + str[i])%Mod1;\\n        store1[i] = (store1[i-1]*B1)%Mod1;\\n        \\n        table2[i] = (table2[i-1]*B2 + str[i])%Mod2;\\n        store2[i] = (store2[i-1]*B2)%Mod2;\\n      }\\n    }\\n  }\\n  ll getHashValue1(int l,int r){\\n    if(l == 0){\\n      return table1[r];\\n    }else{\\n      ll value1 = (table1[r]-table1[l-1]*store1[r-l+1])%Mod1;\\n      value1 = (value1+Mod1)%Mod1;\\n      return value1;\\n    }\\n  }\\n  ll getHashValue2(int l,int r){\\n    if(l == 0){\\n      return table2[r];\\n    }else{\\n      ll value2 = (table2[r]-table2[l-1]*store2[r-l+1])%Mod2;\\n      value2 = (value2+Mod2)%Mod2;\\n      return value2;\\n    }\\n  }\\n};\\n\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    int distinctEchoSubstrings(string text) {\\n        Hash h(text);\\n        unordered_set<ll> st;\\n        const char* p = text.c_str();\\n        for(int i=0;i<text.size();++i){\\n            for(int j=1;i+2*j<=text.size();++j){\\n                ll h1 = h.getHashValue1(i,i+j-1);\\n                ll h2 = h.getHashValue1(i+j,i+2*j-1);\\n                if(h1 == h2){\\n                    st.insert(h1);\\n                }\\n            }\\n        }\\n        return (int)st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 478829,
                "title": "java-solution-460ms",
                "content": "```\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        if(text.length()==0) return 0;\\n\\t\\t\\n        int[] ht = new int[text.length()]; \\t\\t// a good hash table maybe better\\n        ht[0] = text.charAt(0);\\n        for(int i=1; i<text.length(); i++) ht[i]=ht[i-1]+text.charAt(i);\\n        \\n        Set<String> set = new HashSet<>();\\n        \\n        for(int i=0; i<text.length()-1; i++){\\n            for(int len=1; len<text.length(); len++){\\n                int j = i+len;\\n                if(j+len>text.length()) break;\\n \\n                int a = (i==0?ht[j-1]:ht[j-1]-ht[i-1]);\\n                int b = ht[j+len-1]-ht[j-1];\\n\\n                if(a==b){ \\t// if a<>b, not impossible match\\n                    String s1 = text.substring(i, j);\\n                    String s2 = text.substring(j, j+len);\\n                    if(s1.equals(s2)) set.add(s1);\\n                }\\n            }\\n        }\\n        \\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        if(text.length()==0) return 0;\\n\\t\\t\\n        int[] ht = new int[text.length()]; \\t\\t// a good hash table maybe better\\n        ht[0] = text.charAt(0);\\n        for(int i=1; i<text.length(); i++) ht[i]=ht[i-1]+text.charAt(i);\\n        \\n        Set<String> set = new HashSet<>();\\n        \\n        for(int i=0; i<text.length()-1; i++){\\n            for(int len=1; len<text.length(); len++){\\n                int j = i+len;\\n                if(j+len>text.length()) break;\\n \\n                int a = (i==0?ht[j-1]:ht[j-1]-ht[i-1]);\\n                int b = ht[j+len-1]-ht[j-1];\\n\\n                if(a==b){ \\t// if a<>b, not impossible match\\n                    String s1 = text.substring(i, j);\\n                    String s2 = text.substring(j, j+len);\\n                    if(s1.equals(s2)) set.add(s1);\\n                }\\n            }\\n        }\\n        \\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 478086,
                "title": "easy-to-understand-hashing",
                "content": "```\\n#define hell 1000000007\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll power(ll x,ll y)\\n    {\\n        ll res=1;\\n        while(y>0)\\n        {\\n            if(y&1)\\n            res=res*x%hell;\\n            y=y>>1;\\n            x=x*x%hell;\\n        }\\n        return res;\\n    }\\n    int distinctEchoSubstrings(string s) {\\n        ll n=s.size();\\n        ll h[n+1]={0},p[n+1];\\n        p[0]=1;\\n        for(ll i=1;i<=n;i++)p[i]=p[i-1]*53%hell;\\n        for(ll i=0;i<n;i++){\\n            h[i+1]=(h[i]+(s[i]-\\'a\\'+1)*p[i+1]%hell)%hell;\\n        }\\n        set<ll> ss;\\n        for(ll i=0;i<n;i++){\\n            for(ll j=i+1;j<n;j++){\\n                if((j-i+1)%2==0){\\n                    ll l=i,r=(i+j-1)/2;\\n                    ll L=(i+j+1)/2,R=j;\\n                    ll x=((h[r+1]-h[l]+hell)%hell*power(power(53,l),hell-2))%hell;\\n                    ll y=((h[R+1]-h[L]+hell)%hell*power(power(53,L),hell-2))%hell;\\n                    if(x==y)ss.insert(x);\\n                }\\n            }\\n        }\\n        return ss.size();\\n    }\\n};\\n   ```",
                "solutionTags": [],
                "code": "```\\n#define hell 1000000007\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll power(ll x,ll y)\\n    {\\n        ll res=1;\\n        while(y>0)\\n        {\\n            if(y&1)\\n            res=res*x%hell;\\n            y=y>>1;\\n            x=x*x%hell;\\n        }\\n        return res;\\n    }\\n    int distinctEchoSubstrings(string s) {\\n        ll n=s.size();\\n        ll h[n+1]={0},p[n+1];\\n        p[0]=1;\\n        for(ll i=1;i<=n;i++)p[i]=p[i-1]*53%hell;\\n        for(ll i=0;i<n;i++){\\n            h[i+1]=(h[i]+(s[i]-\\'a\\'+1)*p[i+1]%hell)%hell;\\n        }\\n        set<ll> ss;\\n        for(ll i=0;i<n;i++){\\n            for(ll j=i+1;j<n;j++){\\n                if((j-i+1)%2==0){\\n                    ll l=i,r=(i+j-1)/2;\\n                    ll L=(i+j+1)/2,R=j;\\n                    ll x=((h[r+1]-h[l]+hell)%hell*power(power(53,l),hell-2))%hell;\\n                    ll y=((h[R+1]-h[L]+hell)%hell*power(power(53,L),hell-2))%hell;\\n                    if(x==y)ss.insert(x);\\n                }\\n            }\\n        }\\n        return ss.size();\\n    }\\n};\\n   ```",
                "codeTag": "Java"
            },
            {
                "id": 478078,
                "title": "is-o-n-3-better-than-o-n-2",
                "content": "I have two solutions . Solution A looks like O(N^3) and  Solution B looks like O(N^2).\\nBoth have been accepted.\\nThe interesting thing is  Solution A use 179ms to pass all cases while  Solution B use 358ms.\\nSolution A: https://leetcode.com/submissions/detail/293466213/\\nSolution B: https://leetcode.com/submissions/detail/293472536/\\n\\n```\\n//Solution A\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) { \\n        Set<String>set= new HashSet<String>(); \\n        distinctEchoSubstrings(text, set);\\n        return set.size();\\n    }\\n    public void distinctEchoSubstrings(String text, Set<String>set) { \\n        //System.out.println(text);\\n        if(text.length()<=1) return ;\\n        char[]chars = text.toCharArray(); \\n        List[] pos = pos(chars);\\n        //Arrays.sort(pos, (a,b)->{\\n        //    if(a.size()==b.size()) return 0;\\n        //    if(a.size()==0) return 1;\\n        //    if(b.size()==0) return -1;\\n        //    if(a.size()>b.size()) return 1;\\n        //    return -1;\\n        //});\\n        for(int j=0;j<26;j++) {\\n            if(pos[j].size()==0) {\\n                continue;\\n            }\\n            //System.out.println(j+\": \" +pos[j].size());\\n            if(pos[j].size()==1) {\\n                int t = (Integer)(pos[j].get(0));\\n                //System.out.println(new String(chars, 0, t)+\" \"+new String(chars, t + 1, chars.length - t - 1));\\n                distinctEchoSubstrings(new String(chars, 0, t), set);\\n                distinctEchoSubstrings(new String(chars, t + 1, chars.length - t - 1), set);\\n                return;\\n            }\\n            if(pos[j].size()==2) {\\n                int t1 = (Integer)(pos[j].get(0));\\n                int t2 = (Integer)(pos[j].get(1));\\n                //System.out.println(Arrays.toString(pos));\\n                if(t2 - t1==1) set.add(new String(chars,t1 , 1));\\n                if(t2-t1>chars.length/2) {\\n                    if(t1>1)distinctEchoSubstrings(new String(chars, 0, t1), set);\\n                    if(t2 - t1>1)distinctEchoSubstrings(new String(chars, t1+1, t2 - t1 - 1), set);\\n                    if(chars.length - t2>1)distinctEchoSubstrings(new String(chars, t2 + 1, chars.length - t2 - 1), set);\\n                    return;\\n                }  \\n            } else if(pos[j].size()==chars.length) {\\n                for(int i=chars.length/2;i>0;i--) {\\n                    set.add(new String(chars,0 , i));\\n                }\\n                return ;\\n            }\\n        }\\n        \\n        //System.out.println(Arrays.toString(pos));\\n        //pos = pos(chars);\\n\\n        for(int i=0;i<chars.length;i++) {\\n            char c = chars[i];\\n            pos[c-\\'a\\'].remove(0); // remove first, that should be i\\n            if(pos[c-\\'a\\'].size()==0) continue;\\n            Iterator<Integer> it = pos[c-\\'a\\'].iterator(); \\n            for(;it.hasNext(); ) {\\n                Integer next = it.next();\\n                if(next + next - i > chars.length) {\\n                    break;\\n                }  \\n                if(check(chars, i, next)) { \\n                    set.add(new String(chars, i, next - i));\\n                }\\n            }\\n        } \\n    }\\n    List[] pos(char[]chars) {\\n        List[] pos = new List[26];\\n        for(int i = 0 ; i < 26; i++) {\\n            pos[i] = new ArrayList<Integer>();\\n        }\\n        for(int i = 0 ; i < chars.length; i++) {\\n            pos[chars[i] - \\'a\\'].add(i);\\n        }\\n        return pos;\\n    }\\n    boolean check(char[]c, int first, int next) {\\n        int len = next - first;\\n        if(len == 1) return true;\\n        int mid = (next + first) / 2;\\n        return c[mid]==c[mid+len]&&check(c, first+1, mid, len) && check(c, mid+1, next, len);\\n    }\\n    boolean check(char[]c, int first, int next, int len) {\\n        int len2 = next - first;\\n        if(len2 <= 0) return true;\\n        int mid = (next + first) / 2;\\n        return c[mid]==c[mid+len]&&check(c, first, mid, len) && check(c, mid+1, next, len);\\n    }\\n}\\n```\\n```\\n//Solution B\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) { \\n        char[] t=text.toCharArray();\\n        int[] dif= dif(t); \\n        //System.out.println(Arrays.toString(dif));\\n        \\n        Set<String>set= new HashSet<String>(); \\n        for(int i=dif.length;--i>=0;) {\\n            if(dif[i]==0)\\n                set.add(new String(t, i, 1));\\n        }\\n        int[] bp= dif.clone();\\n        for(int j=1;j<t.length/2;j++) {\\n            int zero = 0;\\n            for(int i=dif.length-j;--i>=0;) {\\n                bp[i] += dif[i+j];\\n                if(bp[i]==0){\\n                    zero++;\\n                    if(zero>j)\\n                        set.add(new String(t, i, j+1));\\n                } else {\\n                    zero = 0;\\n                }\\n            }            \\n        }\\n        //distinctEchoSubstrings(text, set);\\n        return set.size();\\n    }\\n    int[] dif(char[] text) { \\n        int[] t = new int[text.length-1];\\n        for(int i=text.length-1;--i>=0;){\\n            t[i] = text[i+1]-text[i];\\n        }\\n        return t;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n//Solution A\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) { \\n        Set<String>set= new HashSet<String>(); \\n        distinctEchoSubstrings(text, set);\\n        return set.size();\\n    }\\n    public void distinctEchoSubstrings(String text, Set<String>set) { \\n        //System.out.println(text);\\n        if(text.length()<=1) return ;\\n        char[]chars = text.toCharArray(); \\n        List[] pos = pos(chars);\\n        //Arrays.sort(pos, (a,b)->{\\n        //    if(a.size()==b.size()) return 0;\\n        //    if(a.size()==0) return 1;\\n        //    if(b.size()==0) return -1;\\n        //    if(a.size()>b.size()) return 1;\\n        //    return -1;\\n        //});\\n        for(int j=0;j<26;j++) {\\n            if(pos[j].size()==0) {\\n                continue;\\n            }\\n            //System.out.println(j+\": \" +pos[j].size());\\n            if(pos[j].size()==1) {\\n                int t = (Integer)(pos[j].get(0));\\n                //System.out.println(new String(chars, 0, t)+\" \"+new String(chars, t + 1, chars.length - t - 1));\\n                distinctEchoSubstrings(new String(chars, 0, t), set);\\n                distinctEchoSubstrings(new String(chars, t + 1, chars.length - t - 1), set);\\n                return;\\n            }\\n            if(pos[j].size()==2) {\\n                int t1 = (Integer)(pos[j].get(0));\\n                int t2 = (Integer)(pos[j].get(1));\\n                //System.out.println(Arrays.toString(pos));\\n                if(t2 - t1==1) set.add(new String(chars,t1 , 1));\\n                if(t2-t1>chars.length/2) {\\n                    if(t1>1)distinctEchoSubstrings(new String(chars, 0, t1), set);\\n                    if(t2 - t1>1)distinctEchoSubstrings(new String(chars, t1+1, t2 - t1 - 1), set);\\n                    if(chars.length - t2>1)distinctEchoSubstrings(new String(chars, t2 + 1, chars.length - t2 - 1), set);\\n                    return;\\n                }  \\n            } else if(pos[j].size()==chars.length) {\\n                for(int i=chars.length/2;i>0;i--) {\\n                    set.add(new String(chars,0 , i));\\n                }\\n                return ;\\n            }\\n        }\\n        \\n        //System.out.println(Arrays.toString(pos));\\n        //pos = pos(chars);\\n\\n        for(int i=0;i<chars.length;i++) {\\n            char c = chars[i];\\n            pos[c-\\'a\\'].remove(0); // remove first, that should be i\\n            if(pos[c-\\'a\\'].size()==0) continue;\\n            Iterator<Integer> it = pos[c-\\'a\\'].iterator(); \\n            for(;it.hasNext(); ) {\\n                Integer next = it.next();\\n                if(next + next - i > chars.length) {\\n                    break;\\n                }  \\n                if(check(chars, i, next)) { \\n                    set.add(new String(chars, i, next - i));\\n                }\\n            }\\n        } \\n    }\\n    List[] pos(char[]chars) {\\n        List[] pos = new List[26];\\n        for(int i = 0 ; i < 26; i++) {\\n            pos[i] = new ArrayList<Integer>();\\n        }\\n        for(int i = 0 ; i < chars.length; i++) {\\n            pos[chars[i] - \\'a\\'].add(i);\\n        }\\n        return pos;\\n    }\\n    boolean check(char[]c, int first, int next) {\\n        int len = next - first;\\n        if(len == 1) return true;\\n        int mid = (next + first) / 2;\\n        return c[mid]==c[mid+len]&&check(c, first+1, mid, len) && check(c, mid+1, next, len);\\n    }\\n    boolean check(char[]c, int first, int next, int len) {\\n        int len2 = next - first;\\n        if(len2 <= 0) return true;\\n        int mid = (next + first) / 2;\\n        return c[mid]==c[mid+len]&&check(c, first, mid, len) && check(c, mid+1, next, len);\\n    }\\n}\\n```\n```\\n//Solution B\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) { \\n        char[] t=text.toCharArray();\\n        int[] dif= dif(t); \\n        //System.out.println(Arrays.toString(dif));\\n        \\n        Set<String>set= new HashSet<String>(); \\n        for(int i=dif.length;--i>=0;) {\\n            if(dif[i]==0)\\n                set.add(new String(t, i, 1));\\n        }\\n        int[] bp= dif.clone();\\n        for(int j=1;j<t.length/2;j++) {\\n            int zero = 0;\\n            for(int i=dif.length-j;--i>=0;) {\\n                bp[i] += dif[i+j];\\n                if(bp[i]==0){\\n                    zero++;\\n                    if(zero>j)\\n                        set.add(new String(t, i, j+1));\\n                } else {\\n                    zero = 0;\\n                }\\n            }            \\n        }\\n        //distinctEchoSubstrings(text, set);\\n        return set.size();\\n    }\\n    int[] dif(char[] text) { \\n        int[] t = new int[text.length-1];\\n        for(int i=text.length-1;--i>=0;){\\n            t[i] = text[i+1]-text[i];\\n        }\\n        return t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564834,
                "content": [
                    {
                        "username": "infmount",
                        "content": "Spent 30 minutes trying to decipher the 2 examples, still don\\'t understand. In the first example, why is \"abc\" not a echo substring? The explanation in the description didn\\'t really explain anything like why \"abcabc\" is an echo substring of \"abcabcabc\"."
                    },
                    {
                        "username": "NaoJoeMiao",
                        "content": "Most accepted answers are rolling hash. Can we solve without?"
                    },
                    {
                        "username": "Leoooooo",
                        "content": "The reason is simple, the number of unique substring could exceed the MOD value. Then the hash will casue collisions and it is not easy to handle the collisions.\\nFor example:\\nLet\\'s say substring A and B have the same hash remainder.\\nHow to handle the case like AABB ?\\nAA should be counted\\nAB should not\\nBB shoud be counted as a different one from AA but BB has the same hash as AA. \\n\\nAnd if we write extra logic to handle the collisions, the time complexity may not be n^2 anymore.\\n"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Brutal force is accepted, so it is not hard."
                    },
                    {
                        "username": "user9733OY",
                        "content": "I have wrong answer at test number 25. Input: text =\"leeleetleeleeleclec\"\\n\\nOutput: 4\\n\\nExpected: 5 \\n\\nWhat is the 5th string I am missing??\\n\\nMaybe I am blind, but I can find only 4, as the code does:\\n\"ee\", \"leelee\", \"eeleel\", \"leclec\""
                    },
                    {
                        "username": "Saiteja6",
                        "content": "\"eleele\""
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Andrei](/user9733OY) \\n\\nThe one you are missing is eleele. Check near the second instance of leelee"
                    }
                ]
            },
            {
                "id": 1569735,
                "content": [
                    {
                        "username": "infmount",
                        "content": "Spent 30 minutes trying to decipher the 2 examples, still don\\'t understand. In the first example, why is \"abc\" not a echo substring? The explanation in the description didn\\'t really explain anything like why \"abcabc\" is an echo substring of \"abcabcabc\"."
                    },
                    {
                        "username": "NaoJoeMiao",
                        "content": "Most accepted answers are rolling hash. Can we solve without?"
                    },
                    {
                        "username": "Leoooooo",
                        "content": "The reason is simple, the number of unique substring could exceed the MOD value. Then the hash will casue collisions and it is not easy to handle the collisions.\\nFor example:\\nLet\\'s say substring A and B have the same hash remainder.\\nHow to handle the case like AABB ?\\nAA should be counted\\nAB should not\\nBB shoud be counted as a different one from AA but BB has the same hash as AA. \\n\\nAnd if we write extra logic to handle the collisions, the time complexity may not be n^2 anymore.\\n"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Brutal force is accepted, so it is not hard."
                    },
                    {
                        "username": "user9733OY",
                        "content": "I have wrong answer at test number 25. Input: text =\"leeleetleeleeleclec\"\\n\\nOutput: 4\\n\\nExpected: 5 \\n\\nWhat is the 5th string I am missing??\\n\\nMaybe I am blind, but I can find only 4, as the code does:\\n\"ee\", \"leelee\", \"eeleel\", \"leclec\""
                    },
                    {
                        "username": "Saiteja6",
                        "content": "\"eleele\""
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Andrei](/user9733OY) \\n\\nThe one you are missing is eleele. Check near the second instance of leelee"
                    }
                ]
            },
            {
                "id": 1569736,
                "content": [
                    {
                        "username": "infmount",
                        "content": "Spent 30 minutes trying to decipher the 2 examples, still don\\'t understand. In the first example, why is \"abc\" not a echo substring? The explanation in the description didn\\'t really explain anything like why \"abcabc\" is an echo substring of \"abcabcabc\"."
                    },
                    {
                        "username": "NaoJoeMiao",
                        "content": "Most accepted answers are rolling hash. Can we solve without?"
                    },
                    {
                        "username": "Leoooooo",
                        "content": "The reason is simple, the number of unique substring could exceed the MOD value. Then the hash will casue collisions and it is not easy to handle the collisions.\\nFor example:\\nLet\\'s say substring A and B have the same hash remainder.\\nHow to handle the case like AABB ?\\nAA should be counted\\nAB should not\\nBB shoud be counted as a different one from AA but BB has the same hash as AA. \\n\\nAnd if we write extra logic to handle the collisions, the time complexity may not be n^2 anymore.\\n"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Brutal force is accepted, so it is not hard."
                    },
                    {
                        "username": "user9733OY",
                        "content": "I have wrong answer at test number 25. Input: text =\"leeleetleeleeleclec\"\\n\\nOutput: 4\\n\\nExpected: 5 \\n\\nWhat is the 5th string I am missing??\\n\\nMaybe I am blind, but I can find only 4, as the code does:\\n\"ee\", \"leelee\", \"eeleel\", \"leclec\""
                    },
                    {
                        "username": "Saiteja6",
                        "content": "\"eleele\""
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Andrei](/user9733OY) \\n\\nThe one you are missing is eleele. Check near the second instance of leelee"
                    }
                ]
            },
            {
                "id": 1966194,
                "content": [
                    {
                        "username": "infmount",
                        "content": "Spent 30 minutes trying to decipher the 2 examples, still don\\'t understand. In the first example, why is \"abc\" not a echo substring? The explanation in the description didn\\'t really explain anything like why \"abcabc\" is an echo substring of \"abcabcabc\"."
                    },
                    {
                        "username": "NaoJoeMiao",
                        "content": "Most accepted answers are rolling hash. Can we solve without?"
                    },
                    {
                        "username": "Leoooooo",
                        "content": "The reason is simple, the number of unique substring could exceed the MOD value. Then the hash will casue collisions and it is not easy to handle the collisions.\\nFor example:\\nLet\\'s say substring A and B have the same hash remainder.\\nHow to handle the case like AABB ?\\nAA should be counted\\nAB should not\\nBB shoud be counted as a different one from AA but BB has the same hash as AA. \\n\\nAnd if we write extra logic to handle the collisions, the time complexity may not be n^2 anymore.\\n"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Brutal force is accepted, so it is not hard."
                    },
                    {
                        "username": "user9733OY",
                        "content": "I have wrong answer at test number 25. Input: text =\"leeleetleeleeleclec\"\\n\\nOutput: 4\\n\\nExpected: 5 \\n\\nWhat is the 5th string I am missing??\\n\\nMaybe I am blind, but I can find only 4, as the code does:\\n\"ee\", \"leelee\", \"eeleel\", \"leclec\""
                    },
                    {
                        "username": "Saiteja6",
                        "content": "\"eleele\""
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Andrei](/user9733OY) \\n\\nThe one you are missing is eleele. Check near the second instance of leelee"
                    }
                ]
            },
            {
                "id": 1821015,
                "content": [
                    {
                        "username": "infmount",
                        "content": "Spent 30 minutes trying to decipher the 2 examples, still don\\'t understand. In the first example, why is \"abc\" not a echo substring? The explanation in the description didn\\'t really explain anything like why \"abcabc\" is an echo substring of \"abcabcabc\"."
                    },
                    {
                        "username": "NaoJoeMiao",
                        "content": "Most accepted answers are rolling hash. Can we solve without?"
                    },
                    {
                        "username": "Leoooooo",
                        "content": "The reason is simple, the number of unique substring could exceed the MOD value. Then the hash will casue collisions and it is not easy to handle the collisions.\\nFor example:\\nLet\\'s say substring A and B have the same hash remainder.\\nHow to handle the case like AABB ?\\nAA should be counted\\nAB should not\\nBB shoud be counted as a different one from AA but BB has the same hash as AA. \\n\\nAnd if we write extra logic to handle the collisions, the time complexity may not be n^2 anymore.\\n"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Brutal force is accepted, so it is not hard."
                    },
                    {
                        "username": "user9733OY",
                        "content": "I have wrong answer at test number 25. Input: text =\"leeleetleeleeleclec\"\\n\\nOutput: 4\\n\\nExpected: 5 \\n\\nWhat is the 5th string I am missing??\\n\\nMaybe I am blind, but I can find only 4, as the code does:\\n\"ee\", \"leelee\", \"eeleel\", \"leclec\""
                    },
                    {
                        "username": "Saiteja6",
                        "content": "\"eleele\""
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Andrei](/user9733OY) \\n\\nThe one you are missing is eleele. Check near the second instance of leelee"
                    }
                ]
            }
        ]
    },
    {
        "title": "Convert Integer to the Sum of Two No-Zero Integers",
        "question_content": "<p><strong>No-Zero integer</strong> is a positive integer that <strong>does not contain any <code>0</code></strong> in its decimal representation.</p>\n\n<p>Given an integer <code>n</code>, return <em>a list of two integers</em> <code>[a, b]</code> <em>where</em>:</p>\n\n<ul>\n\t<li><code>a</code> and <code>b</code> are <strong>No-Zero integers</strong>.</li>\n\t<li><code>a + b = n</code></li>\n</ul>\n\n<p>The test cases are generated so that there is at least one valid solution. If there are many valid solutions, you can return any of them.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> [1,1]\n<strong>Explanation:</strong> Let a = 1 and b = 1.\nBoth a and b are no-zero integers, and a + b = 2 = n.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 11\n<strong>Output:</strong> [2,9]\n<strong>Explanation:</strong> Let a = 2 and b = 9.\nBoth a and b are no-zero integers, and a + b = 9 = n.\nNote that there are other valid answers as [8, 3] that can be accepted.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 478216,
                "title": "java-intuitive-non-brute-force",
                "content": "build two non zero numbers that sums `n` , starting from the least significant digit.\\ntrick is to treat `0` and `1` as `10` and `11`\\n\\n```java\\n    public int[] getNoZeroIntegers(int n) {\\n        \\n        int a=0, b=0, step=1;\\n        \\n        while (n>0) {\\n            int d = n % 10; // digit\\n            n /= 10;\\n            \\n            if ((d == 0 || d == 1) && n>0) { // n>0 evades the case when 1 is the most significant digit\\n                a += step*(1+d);\\n                b += step*9;\\n                n--; // handle carry\\n            } else {\\n                a += step*1;\\n                b += step*(d-1);\\n            }\\n            step *= 10;\\n        }\\n        \\n        return new int[]{a,b};\\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int[] getNoZeroIntegers(int n) {\\n        \\n        int a=0, b=0, step=1;\\n        \\n        while (n>0) {\\n            int d = n % 10; // digit\\n            n /= 10;\\n            \\n            if ((d == 0 || d == 1) && n>0) { // n>0 evades the case when 1 is the most significant digit\\n                a += step*(1+d);\\n                b += step*9;\\n                n--; // handle carry\\n            } else {\\n                a += step*1;\\n                b += step*(d-1);\\n            }\\n            step *= 10;\\n        }\\n        \\n        return new int[]{a,b};\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 477717,
                "title": "python",
                "content": "Generator expression:\\n```\\ndef getNoZeroIntegers(self, n):\\n    return next([a, n-a] for a in range(n) if \\'0\\' not in f\\'{a}{n-a}\\')\\n```\\nWhile-loop:\\n```\\ndef getNoZeroIntegers(self, n):\\n    a = 1\\n    while \\'0\\' in f\\'{a}{n-a}\\':\\n        a += 1\\n    return [a, n-a]\\n```\\nFor-loop:\\n```\\ndef getNoZeroIntegers(self, n):\\n    for a in range(n):\\n        if \\'0\\' not in f\\'{a}{n-a}\\':\\n            return [a, n-a]\\n```",
                "solutionTags": [],
                "code": "```\\ndef getNoZeroIntegers(self, n):\\n    return next([a, n-a] for a in range(n) if \\'0\\' not in f\\'{a}{n-a}\\')\\n```\n```\\ndef getNoZeroIntegers(self, n):\\n    a = 1\\n    while \\'0\\' in f\\'{a}{n-a}\\':\\n        a += 1\\n    return [a, n-a]\\n```\n```\\ndef getNoZeroIntegers(self, n):\\n    for a in range(n):\\n        if \\'0\\' not in f\\'{a}{n-a}\\':\\n            return [a, n-a]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 478189,
                "title": "java-simple-solution-beats-100",
                "content": "```\\npublic int[] getNoZeroIntegers(int n) {\\n        for (int i = 1; i < n; i++) {\\n            if (nonZero(i) && nonZero(n - i)) {\\n                return new int[]{i, n - i};\\n            }\\n        }\\n        return new int[]{-1, -1};\\n    }\\n    \\n    private boolean nonZero(int n) {\\n        while (n > 0) {\\n            if (n % 10 == 0) return false;\\n            n /= 10;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] getNoZeroIntegers(int n) {\\n        for (int i = 1; i < n; i++) {\\n            if (nonZero(i) && nonZero(n - i)) {\\n                return new int[]{i, n - i};\\n            }\\n        }\\n        return new int[]{-1, -1};\\n    }\\n    \\n    private boolean nonZero(int n) {\\n        while (n > 0) {\\n            if (n % 10 == 0) return false;\\n            n /= 10;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 477693,
                "title": "java-c-simple-solution-clean-code",
                "content": "**Java**\\n```java\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        for (int a = 1; a < n; a++) {\\n            int b = n - a;\\n            if (!String.valueOf(a).contains(\"0\") && !String.valueOf(b).contains(\"0\"))\\n                return new int[]{a, b};\\n        }\\n        return new int[]{}; // unreachable because at least one valid solution\\n    }\\n}\\n```\\n\\n**C++**\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> getNoZeroIntegers(int n) {\\n        for (int a = 1; a < n; ++a) {\\n            int b = n - a;\\n            if (to_string(a).find(\\'0\\') == string::npos && to_string(b).find(\\'0\\') == string::npos)\\n                return {a, b};\\n        }\\n        return {}; // unreachable because at least one valid solution\\n    }\\n};\\n```\\n\\n**Complexity:**\\n- Time: O(n * log10(n)), `n <= 10^4`\\n- Space: O(1)",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        for (int a = 1; a < n; a++) {\\n            int b = n - a;\\n            if (!String.valueOf(a).contains(\"0\") && !String.valueOf(b).contains(\"0\"))\\n                return new int[]{a, b};\\n        }\\n        return new int[]{}; // unreachable because at least one valid solution\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<int> getNoZeroIntegers(int n) {\\n        for (int a = 1; a < n; ++a) {\\n            int b = n - a;\\n            if (to_string(a).find(\\'0\\') == string::npos && to_string(b).find(\\'0\\') == string::npos)\\n                return {a, b};\\n        }\\n        return {}; // unreachable because at least one valid solution\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765383,
                "title": "faster-100",
                "content": "```\\nclass Solution:\\n    def getNoZeroIntegers(self, n):\\n        a = 1\\n        while \\'0\\' in f\\'{a}{n-a}\\':\\n            a += 1\\n        return [a, n-a]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getNoZeroIntegers(self, n):\\n        a = 1\\n        while \\'0\\' in f\\'{a}{n-a}\\':\\n            a += 1\\n        return [a, n-a]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 973783,
                "title": "java-o-1-beats-100-no-solution-can-be-faster-than-this-one",
                "content": "Tell me a solution faster than this one.\\n\\n```\\n\\npublic int[] getNoZeroIntegers(int n) {\\n        int pos = 1;\\n        int m = 0, num = n;\\n        \\n        while(n > 1){\\n            int d = (n % 10);\\n            if(d == 1){\\n                m += 2 * pos;\\n                n -= 2;\\n            }else{\\n                m += pos;\\n                n -= 1;\\n            }\\n            \\n            pos *= 10;\\n            n /= 10;\\n        }\\n        \\n        return new int[]{num - m, m};\\n    }",
                "solutionTags": [],
                "code": "Tell me a solution faster than this one.\\n\\n```\\n\\npublic int[] getNoZeroIntegers(int n) {\\n        int pos = 1;\\n        int m = 0, num = n;\\n        \\n        while(n > 1){\\n            int d = (n % 10);\\n            if(d == 1){\\n                m += 2 * pos;\\n                n -= 2;\\n            }else{\\n                m += pos;\\n                n -= 1;\\n            }\\n            \\n            pos *= 10;\\n            n /= 10;\\n        }\\n        \\n        return new int[]{num - m, m};\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 504931,
                "title": "java-my-easy-solution-faster-than-100",
                "content": "```\\npublic int[] getNoZeroIntegers(int n) {\\n\\tint A = 1, B = n-1;\\n\\twhile(containsZero(B) || containsZero(A)) {\\n\\t\\tB--;\\n\\t\\tA++;\\n\\t}\\n\\treturn new int[] {A, B};\\n}\\n\\npublic boolean containsZero(int num) {\\n\\twhile(num!=0) {\\n\\t\\tint t = num%10;\\n\\t\\tif(t == 0) return true;\\n\\t\\tnum /= 10;\\n\\t}\\n\\treturn false;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] getNoZeroIntegers(int n) {\\n\\tint A = 1, B = n-1;\\n\\twhile(containsZero(B) || containsZero(A)) {\\n\\t\\tB--;\\n\\t\\tA++;\\n\\t}\\n\\treturn new int[] {A, B};\\n}\\n\\npublic boolean containsZero(int num) {\\n\\twhile(num!=0) {\\n\\t\\tint t = num%10;\\n\\t\\tif(t == 0) return true;\\n\\t\\tnum /= 10;\\n\\t}\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 478361,
                "title": "python3-c-simple-brute-force",
                "content": "##### Python\\n\\nSolution 1: Naive Solution \\n```\\nclass Solution:\\n    def check_zeros(self,n):\\n        while(n>0):\\n            lsb=n%10\\n            if lsb==0:\\n                return False\\n            n=int(n/10)\\n        return True\\n    def getNoZeroIntegers(self, n):\\n        a=1\\n        while(True):\\n            b=n-a\\n            if self.check_zeros(a) and self.check_zeros(b):\\n                return [a,b]\\n            a=a+1\\n```\\n\\nSolution 2: Use string to check for 0\\n```\\nclass Solution:\\n    def check_zeros(self,n):\\n        if \\'0\\' in str(n):\\n            return False\\n        else:\\n            return True\\n\\n    def getNoZeroIntegers(self, n):\\n        a=1\\n        while(True):\\n            b=n-a\\n            if self.check_zeros(a) and self.check_zeros(b):\\n                return [a,b]\\n            a=a+1\\n```\\n\\nSolution 3 (credit : @StefanPochmann)\\n\\n```\\nclass Solution:\\n    def getNoZeroIntegers(self, n):\\n        a=1\\n        while(\\'0\\' in f\\'{a}{n-a}\\'):\\n            a=a+1\\n        return [a,n-a]\\n\\t\\t\\n#f strings- https://realpython.com/python-f-strings/\\n```\\n\\n#### C++\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> getNoZeroIntegers(int n) {\\n      int a=1;\\n      int b;\\n      while(1){\\n        b=n-a;\\n        if (to_string(a).find(\\'0\\')==string::npos && to_string(b).find(\\'0\\')==string::npos){\\n          return {a,b};\\n        }\\n        ++a;\\n      }\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def check_zeros(self,n):\\n        while(n>0):\\n            lsb=n%10\\n            if lsb==0:\\n                return False\\n            n=int(n/10)\\n        return True\\n    def getNoZeroIntegers(self, n):\\n        a=1\\n        while(True):\\n            b=n-a\\n            if self.check_zeros(a) and self.check_zeros(b):\\n                return [a,b]\\n            a=a+1\\n```\n```\\nclass Solution:\\n    def check_zeros(self,n):\\n        if \\'0\\' in str(n):\\n            return False\\n        else:\\n            return True\\n\\n    def getNoZeroIntegers(self, n):\\n        a=1\\n        while(True):\\n            b=n-a\\n            if self.check_zeros(a) and self.check_zeros(b):\\n                return [a,b]\\n            a=a+1\\n```\n```\\nclass Solution:\\n    def getNoZeroIntegers(self, n):\\n        a=1\\n        while(\\'0\\' in f\\'{a}{n-a}\\'):\\n            a=a+1\\n        return [a,n-a]\\n\\t\\t\\n#f strings- https://realpython.com/python-f-strings/\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> getNoZeroIntegers(int n) {\\n      int a=1;\\n      int b;\\n      while(1){\\n        b=n-a;\\n        if (to_string(a).find(\\'0\\')==string::npos && to_string(b).find(\\'0\\')==string::npos){\\n          return {a,b};\\n        }\\n        ++a;\\n      }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 773315,
                "title": "c-simple-solution-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    bool no_zero(int n) {\\n        while (n>0)\\n        {\\n            if (n % 10 == 0)\\n                return false;\\n            n /= 10;\\n        }\\n        return true;\\n    }\\n    \\n    \\n    vector<int> getNoZeroIntegers(int n) {\\n        vector<int> res;\\n        int i=1;\\n        while (i<n)\\n        {\\n            if ((no_zero(i)) && (no_zero(n-i)))\\n            {\\n                res.push_back(i);\\n                res.push_back(n-i);\\n                return res;\\n            }  \\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool no_zero(int n) {\\n        while (n>0)\\n        {\\n            if (n % 10 == 0)\\n                return false;\\n            n /= 10;\\n        }\\n        return true;\\n    }\\n    \\n    \\n    vector<int> getNoZeroIntegers(int n) {\\n        vector<int> res;\\n        int i=1;\\n        while (i<n)\\n        {\\n            if ((no_zero(i)) && (no_zero(n-i)))\\n            {\\n                res.push_back(i);\\n                res.push_back(n-i);\\n                return res;\\n            }  \\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 630227,
                "title": "java-0ms-100-space-and-time",
                "content": "```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        n--;\\n        int m=1;\\n        int ans[]={m,n};\\n        \\n        while(contains(ans[0])==true || contains(ans[1])==true){\\n            ans[0]++;\\n            ans[1]--;\\n        }\\n        \\n        return ans;\\n    }\\n    public boolean contains(int n){\\n        boolean flag=false;\\n        while(n!=0){\\n            if(n%10==0)\\n                return true;\\n            n=n/10;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        n--;\\n        int m=1;\\n        int ans[]={m,n};\\n        \\n        while(contains(ans[0])==true || contains(ans[1])==true){\\n            ans[0]++;\\n            ans[1]--;\\n        }\\n        \\n        return ans;\\n    }\\n    public boolean contains(int n){\\n        boolean flag=false;\\n        while(n!=0){\\n            if(n%10==0)\\n                return true;\\n            n=n/10;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640113,
                "title": "easy-beginner-friendly-100-faster-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool isok(string a) {\\n        for(char ch : a) {\\n            if(ch == \\'0\\') return false;\\n        }\\n        return true;\\n    }\\n    \\n    vector<int> getNoZeroIntegers(int n) {\\n        int i = 1, j = n-1;\\n        while(i <= j) {\\n                if(i + j == n) {\\n                    string test1 = to_string(i);\\n                    string test2 = to_string(j);\\n                    if(isok(test1) and isok(test2)) return {i, j};\\n                }\\n            i++;\\n            j--;\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isok(string a) {\\n        for(char ch : a) {\\n            if(ch == \\'0\\') return false;\\n        }\\n        return true;\\n    }\\n    \\n    vector<int> getNoZeroIntegers(int n) {\\n        int i = 1, j = n-1;\\n        while(i <= j) {\\n                if(i + j == n) {\\n                    string test1 = to_string(i);\\n                    string test2 = to_string(j);\\n                    if(isok(test1) and isok(test2)) return {i, j};\\n                }\\n            i++;\\n            j--;\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1263756,
                "title": "c-100-fast",
                "content": "```class Solution {\\npublic:\\n    bool isNon(int n){\\n        while(n){\\n            if(n%10==0) return false;\\n            n/=10;\\n        }\\n        return true;\\n    }\\n    vector<int> getNoZeroIntegers(int n) {\\n        vector<int> v;\\n        for(int i=1;i<=n/2;i++){\\n            if(isNon(i)&&isNon(n-i)){\\n                v={i,n-i};\\n                return v;\\n            }\\n        }\\n        return v;\\n    }\\n};```",
                "solutionTags": [],
                "code": "```class Solution {\\npublic:\\n    bool isNon(int n){\\n        while(n){\\n            if(n%10==0) return false;\\n            n/=10;\\n        }\\n        return true;\\n    }\\n    vector<int> getNoZeroIntegers(int n) {\\n        vector<int> v;\\n        for(int i=1;i<=n/2;i++){\\n            if(isNon(i)&&isNon(n-i)){\\n                v={i,n-i};\\n                return v;\\n            }\\n        }\\n        return v;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 991418,
                "title": "easy-clear-solution-0ms-100-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getNoZeroIntegers(int n) {\\n        int a=1,b=n-1,aa,bb;\\n        while(true){\\n            aa=a;bb=b;\\n            while(aa>0){\\n                if(aa%10==0){\\n                    a++;\\n                    b--;\\n                    break;\\n                }\\n                aa/=10;\\n            }  \\n            while(bb>0){\\n                if(bb%10==0){\\n                    a++;\\n                    b--;\\n                    break;\\n                }\\n                bb/=10;\\n            }\\n            if(aa==0 && bb==0)break;\\n            \\n        }\\n        return {a,b};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getNoZeroIntegers(int n) {\\n        int a=1,b=n-1,aa,bb;\\n        while(true){\\n            aa=a;bb=b;\\n            while(aa>0){\\n                if(aa%10==0){\\n                    a++;\\n                    b--;\\n                    break;\\n                }\\n                aa/=10;\\n            }  \\n            while(bb>0){\\n                if(bb%10==0){\\n                    a++;\\n                    b--;\\n                    break;\\n                }\\n                bb/=10;\\n            }\\n            if(aa==0 && bb==0)break;\\n            \\n        }\\n        return {a,b};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 688984,
                "title": "java-0ms-solution-with-explanation",
                "content": "Concept : We can iterate through <b> i = 1 to i = n </b> and check if A (n) and B (n - i) numbers contains zero or not.\\n\\nNow there can be many methods to check if number contains zero or not.\\n\\n<pre>\\nMethod 1: String.valueOf(i).contains(\"0\") && String.valueOf(n-i).contains(\"0\")\\nMethod 2: Integer.toString(i).contains(\"0\") && Integer.toString(n-i).contains(\"0\")\\nMethod 3: Use while loop and every time take mod of 10 and check if reminder is zero or not.\\n</pre>\\n\\nIf you use method 1 then time complexity will be higher (in this case 48ms) because in-built function will take time to convert int to string and then check if zero is in the string or not.\\n\\nFor method 2, time complexity will also higher than zero because it is also using in-built function.\\n\\nBut if we use method 3 then for large numbers it will be less time consuming because we divide number by 10 each time. So this will use less time.\\n<b>Time complexity for this will be 0ms.</b>\\n\\nSo it will be helpful if you don\\'t use the in-built function in some case.\\n\\n<br>\\nSolution :\\n\\n```\\nclass Solution {\\n    \\n    public boolean containZero(int n) {\\n        while(n > 0) {\\n            int rem = n % 10;\\n            if(rem == 0)\\n                return true;\\n            n = n/10;\\n        }\\n        return false;\\n    }\\n    \\n    public int[] getNoZeroIntegers(int n) {\\n                \\n        for(int i=1; i<n; i++) {\\n            if(!containZero(i) && !containZero(n-i)) {\\n                return new int[]{ n - i, i};\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public boolean containZero(int n) {\\n        while(n > 0) {\\n            int rem = n % 10;\\n            if(rem == 0)\\n                return true;\\n            n = n/10;\\n        }\\n        return false;\\n    }\\n    \\n    public int[] getNoZeroIntegers(int n) {\\n                \\n        for(int i=1; i<n; i++) {\\n            if(!containZero(i) && !containZero(n-i)) {\\n                return new int[]{ n - i, i};\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 483735,
                "title": "python-not-brute-force-o-log-n",
                "content": "```\\n         a, b = 0, 0\\n        \\n        rest = n % 10\\n        power = 1\\n        \\n        while n > 1:\\n            n = n // 10 \\n            if rest > 1:\\n                a += 1*power\\n                b += (rest - 1)*power\\n            else:\\n                a += (rest+1)*power\\n                b += 9*power\\n                n -= 1\\n            rest = n % 10 \\n            power *= 10\\n                        \\n        if n == 1:\\n            a += power\\n        \\n        return [a, b]\\n```",
                "solutionTags": [],
                "code": "```\\n         a, b = 0, 0\\n        \\n        rest = n % 10\\n        power = 1\\n        \\n        while n > 1:\\n            n = n // 10 \\n            if rest > 1:\\n                a += 1*power\\n                b += (rest - 1)*power\\n            else:\\n                a += (rest+1)*power\\n                b += 9*power\\n                n -= 1\\n            rest = n % 10 \\n            power *= 10\\n                        \\n        if n == 1:\\n            a += power\\n        \\n        return [a, b]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 477691,
                "title": "simple-java-o-n-use-recursion-0-ms-beat-100-on-space-and-time",
                "content": "```\\n    public int[] getNoZeroIntegers(int n) {\\n        int[] res = new int[2];\\n        if (n < 2) return new int[]{0, n};\\n        if (n/10 == 0) return new int[]{1, n - 1};\\n        int rem = n % 10;\\n        if (rem < 2){\\n            res = getNoZeroIntegers(n/10 - 1);\\n            res[0] = res[0] * 10 + 2;\\n            res[1] = res[1] * 10 + 10 + rem - 2;\\n        } else {\\n            res = getNoZeroIntegers(n/10);\\n            res[0] = res[0] * 10 + 1;\\n            res[1] = res[1] * 10 + rem -1;\\n        }\\n        return res;\\n    }\\n```\\n\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Convert Integer to the Sum of Two No-Zero Integers.\\nMemory Usage: 34.8 MB, less than 100.00% of Java online submissions for Convert Integer to the Sum of Two No-Zero Integers.",
                "solutionTags": [],
                "code": "```\\n    public int[] getNoZeroIntegers(int n) {\\n        int[] res = new int[2];\\n        if (n < 2) return new int[]{0, n};\\n        if (n/10 == 0) return new int[]{1, n - 1};\\n        int rem = n % 10;\\n        if (rem < 2){\\n            res = getNoZeroIntegers(n/10 - 1);\\n            res[0] = res[0] * 10 + 2;\\n            res[1] = res[1] * 10 + 10 + rem - 2;\\n        } else {\\n            res = getNoZeroIntegers(n/10);\\n            res[0] = res[0] * 10 + 1;\\n            res[1] = res[1] * 10 + rem -1;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2279001,
                "title": "short-javascript-solution",
                "content": "Found this solution helpful? Consider showing support by upvoting this post.\\nHave a question? Kindly leave a comment below.\\nThank you and happy hacking!\\n```\\nvar getNoZeroIntegers = function (n) {\\n    let initCheck = n - 1 //Initial check\\n\\t\\n    if (!initCheck.toString().includes(\\'0\\')) {\\n        return [n - 1, 1]\\n    } else {\\n        let result = [n, 0];\\n\\n        while (result[1] !== n) {\\n            result[0]--\\n            result[1]++\\n            if (!result[1].toString().includes(\\'0\\') && !result[0].toString().includes(\\'0\\')) {\\n                return result\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getNoZeroIntegers = function (n) {\\n    let initCheck = n - 1 //Initial check\\n\\t\\n    if (!initCheck.toString().includes(\\'0\\')) {\\n        return [n - 1, 1]\\n    } else {\\n        let result = [n, 0];\\n\\n        while (result[1] !== n) {\\n            result[0]--\\n            result[1]++\\n            if (!result[1].toString().includes(\\'0\\') && !result[0].toString().includes(\\'0\\')) {\\n                return result\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2150054,
                "title": "simple-zero-check-loop-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int has0(int x)\\n{\\n    while (x){\\n        if (x % 10 == 0)\\n          return 1;\\n        x /= 10;\\n    } \\n    return 0;\\n}\\n    vector<int> getNoZeroIntegers(int n) {\\n        for(int i=1;i<=n;i++){\\n            if(has0(i)==false && has0(n-i)==false){\\n                return {i,n-i};\\n            }\\n        }\\n        return {1,1};\\n    }\\n};\\n```\\n**Please upvote if you like the solution**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int has0(int x)\\n{\\n    while (x){\\n        if (x % 10 == 0)\\n          return 1;\\n        x /= 10;\\n    } \\n    return 0;\\n}\\n    vector<int> getNoZeroIntegers(int n) {\\n        for(int i=1;i<=n;i++){\\n            if(has0(i)==false && has0(n-i)==false){\\n                return {i,n-i};\\n            }\\n        }\\n        return {1,1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477675,
                "title": "java-two-pointers",
                "content": "```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        int[] res = new int[2];\\n        int l = 1;\\n        int r = n - 1;\\n        while (l <= r) {\\n           if (check(l) && check(r)) {\\n               break;\\n           }\\n            l++;\\n            r--;\\n        }\\n        res[0] = l;\\n        res[1] = r;\\n        return res;\\n    }\\n    boolean check(int n) {\\n        while (n != 0) {\\n            if (n % 10 == 0) {\\n                return false;\\n            }\\n            n /= 10;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        int[] res = new int[2];\\n        int l = 1;\\n        int r = n - 1;\\n        while (l <= r) {\\n           if (check(l) && check(r)) {\\n               break;\\n           }\\n            l++;\\n            r--;\\n        }\\n        res[0] = l;\\n        res[1] = r;\\n        return res;\\n    }\\n    boolean check(int n) {\\n        while (n != 0) {\\n            if (n % 10 == 0) {\\n                return false;\\n            }\\n            n /= 10;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454244,
                "title": "100-beats-java-solution",
                "content": "PLEASE UPVOTE\\n```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        int arr[]=new int[2];\\n        boolean t=true;\\n        for(int i=1;i<=n;i++){\\n            int k=i;\\n            while(k!=0){\\n                int rem=k%10;\\n                if(rem==0){\\n                   t=false;\\n                }\\n                k/=10;\\n            }\\n            if(t){\\n                int m=n-i;\\n                while(m!=0){\\n                    int rem=m%10;\\n                    if(rem==0){\\n                        t=false;\\n                    }\\n                    m/=10;\\n                }\\n              if(t){\\n               arr[0]=i;\\n               arr[1]=n-i;\\n               break;\\n              }\\n            }\\n            t=true;\\n        }\\n    return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        int arr[]=new int[2];\\n        boolean t=true;\\n        for(int i=1;i<=n;i++){\\n            int k=i;\\n            while(k!=0){\\n                int rem=k%10;\\n                if(rem==0){\\n                   t=false;\\n                }\\n                k/=10;\\n            }\\n            if(t){\\n                int m=n-i;\\n                while(m!=0){\\n                    int rem=m%10;\\n                    if(rem==0){\\n                        t=false;\\n                    }\\n                    m/=10;\\n                }\\n              if(t){\\n               arr[0]=i;\\n               arr[1]=n-i;\\n               break;\\n              }\\n            }\\n            t=true;\\n        }\\n    return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351179,
                "title": "simple-python-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def nz(self, num):\\n        return not str(num).count(\\'0\\')\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        for i in range(1, n):\\n            if self.nz(i) and self.nz(n-i):\\n                return [i, n-i]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nz(self, num):\\n        return not str(num).count(\\'0\\')\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        for i in range(1, n):\\n            if self.nz(i) and self.nz(n-i):\\n                return [i, n-i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997642,
                "title": "c-4-lines-o-1-space",
                "content": "```c++\\nclass Solution {\\npublic:\\n    vector<int> getNoZeroIntegers(int n) {\\n        auto hasZero = [](int num) {\\n            auto s = to_string(num);\\n            for (auto c: s) if (c == \\'0\\') return true;\\n            return false;\\n        };\\n        for (int i = 1; i < n; i++)  if (!hasZero(n - i) && !hasZero(i)) return {i, other};\\n        throw \"Error\";\\n    }\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    vector<int> getNoZeroIntegers(int n) {\\n        auto hasZero = [](int num) {\\n            auto s = to_string(num);\\n            for (auto c: s) if (c == \\'0\\') return true;\\n            return false;\\n        };\\n        for (int i = 1; i < n; i++)  if (!hasZero(n - i) && !hasZero(i)) return {i, other};\\n        throw \"Error\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812823,
                "title": "python-easy-solution-faster-than-98-86",
                "content": "```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        def check(num):\\n            while num>0:\\n                if num%10==0:\\n                    return False\\n                num//=10\\n            return True\\n        for i in range(1,n):\\n            t=n-i\\n            if check(t) and check(i):\\n                return [i,t]\\n```\\n\\n**Upvote if you like the solution or ask if there is any query**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        def check(num):\\n            while num>0:\\n                if num%10==0:\\n                    return False\\n                num//=10\\n            return True\\n        for i in range(1,n):\\n            t=n-i\\n            if check(t) and check(i):\\n                return [i,t]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739323,
                "title": "js-simple-readable-fast-60-ms-low-memory-41-6-mb",
                "content": "```\\nvar getNoZeroIntegers = function(n) {\\n    let int1 = n - 1;\\n    let int2 = 1;\\n    \\n    const hasZero = int => int.toString().includes(\\'0\\');\\n    \\n    while (hasZero(int1) || hasZero(int2)) {\\n        int1 = int1 - 1;\\n        int2 = int2 + 1;\\n    }\\n    \\n    return [int1, int2];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getNoZeroIntegers = function(n) {\\n    let int1 = n - 1;\\n    let int2 = 1;\\n    \\n    const hasZero = int => int.toString().includes(\\'0\\');\\n    \\n    while (hasZero(int1) || hasZero(int2)) {\\n        int1 = int1 - 1;\\n        int2 = int2 + 1;\\n    }\\n    \\n    return [int1, int2];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2559633,
                "title": "java-very-simple-solution-easy-to-understand",
                "content": "\\tclass Solution {\\n\\t\\tpublic int[] getNoZeroIntegers(int n) {\\n\\t\\t\\tfor(int i=1; i<n; i++) {\\n\\t\\t\\t\\tint j = n-i;\\n\\n\\t\\t\\t\\tif(isNoZero(i) && isNoZero(j)) {\\n\\t\\t\\t\\t\\treturn new int[]{i, j};\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn new int[]{}; \\n\\t\\t}\\n\\n\\t\\tboolean isNoZero(int n) {\\n\\t\\t\\tString num = n+\"\";\\n\\n\\t\\t\\tfor(char ch : num.toCharArray()) {\\n\\t\\t\\t\\tif(ch == \\'0\\') return false;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int[] getNoZeroIntegers(int n) {\\n\\t\\t\\tfor(int i=1; i<n; i++) {\\n\\t\\t\\t\\tint j = n-i;\\n\\n\\t\\t\\t\\tif(isNoZero(i) && isNoZero(j)) {\\n\\t\\t\\t\\t\\treturn new int[]{i, j}",
                "codeTag": "Java"
            },
            {
                "id": 2481181,
                "title": "c-100-faster-easy-to-understand",
                "content": "1. Target: find the two numbers {i, n-i} that do not contain zero and their sum equals to n\\n2. Method:\\n\\t* find {i,n-i} pair whose sum equals to n, e.g. 6=1+5\\n\\t* check both i\\'s and n-i\\'s number of zero. They must be zero respectively\\n\\t* range of i is from 1 to n/2(include). Reason is that we can avoid calculating duplicated range. e.g we have checked whether {1,5} contains zero repectively, so we don\\'t need to check {5,1}\\n\\n```\\nclass Solution {\\npublic:\\n    int containZero(int n){\\n        int count = 0;\\n        while(n > 0){\\n            if(n % 10 == 0) count++;\\n            n /= 10;\\n        }\\n        return count;\\n    }\\n    \\n    vector<int> getNoZeroIntegers(int n) {\\n        for(int i = 1; i <= n/2; i++){\\n            if((containZero(i) == 0) && (containZero(n-i) == 0)) return {i, n-i};\\n        }\\n        return {};\\n    }\\n};\\n```\\nPlease upvote it if you love this answer, thank you!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int containZero(int n){\\n        int count = 0;\\n        while(n > 0){\\n            if(n % 10 == 0) count++;\\n            n /= 10;\\n        }\\n        return count;\\n    }\\n    \\n    vector<int> getNoZeroIntegers(int n) {\\n        for(int i = 1; i <= n/2; i++){\\n            if((containZero(i) == 0) && (containZero(n-i) == 0)) return {i, n-i};\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1293167,
                "title": "concise-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        for (int i = 1; i < n; i++) {\\n            if (hasNo0(i) && hasNo0(n-i)) {\\n                return new int[] {i, n - i};\\n            }\\n        }\\n        return null;\\n    }\\n    private boolean hasNo0(int n) {\\n        return String.valueOf(n).indexOf(\\'0\\') == -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        for (int i = 1; i < n; i++) {\\n            if (hasNo0(i) && hasNo0(n-i)) {\\n                return new int[] {i, n - i};\\n            }\\n        }\\n        return null;\\n    }\\n    private boolean hasNo0(int n) {\\n        return String.valueOf(n).indexOf(\\'0\\') == -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1219360,
                "title": "python-fast-easy-soln",
                "content": "```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        left = 0\\n        right = n\\n        ans = []\\n        while True:\\n            if str(left).count(\"0\")==0 and str(right).count(\"0\")==0:\\n                ans.append(left)\\n                ans.append(right)\\n                break\\n            left+=1\\n            right-=1\\n        return ans\\n                \\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        left = 0\\n        right = n\\n        ans = []\\n        while True:\\n            if str(left).count(\"0\")==0 and str(right).count(\"0\")==0:\\n                ans.append(left)\\n                ans.append(right)\\n                break\\n            left+=1\\n            right-=1\\n        return ans\\n                \\n",
                "codeTag": "Java"
            },
            {
                "id": 1142492,
                "title": "java-100-extremely-easy-solution",
                "content": "```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        int[] result = new int[2];\\n        int left = 1;\\n        int right = n-1;\\n        while(left <= right){\\n            if(check(left) && check(right)){\\n                result[0] = left;\\n                result[1] = right;\\n                break;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return result;\\n    }\\n    \\n    private boolean check(int val){\\n        while(val != 0){\\n            int temp = val % 10;\\n            if(temp == 0)\\n                return false;\\n            val/=10;\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        int[] result = new int[2];\\n        int left = 1;\\n        int right = n-1;\\n        while(left <= right){\\n            if(check(left) && check(right)){\\n                result[0] = left;\\n                result[1] = right;\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1006429,
                "title": "python-3-solution-analysis-digit-by-digit",
                "content": "```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        #\\n        A,B,i = 0,0,0\\n        \\n        if n < 10: return n-1,1\\n        \\n        while n >= 10:\\n            digit = n%10\\n            n = n//10\\n            if digit <= 1:\\n                A += (digit+1)*10**i\\n                B += 9*10**i\\n                n = n-1\\n            else:\\n                B += (digit-1)*10**i\\n                A += 1*10**i\\n            i += 1\\n        \\n        B += n*10**i\\n        \\n        return A,B\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        #\\n        A,B,i = 0,0,0\\n        \\n        if n < 10: return n-1,1\\n        \\n        while n >= 10:\\n            digit = n%10\\n            n = n//10\\n            if digit <= 1:\\n                A += (digit+1)*10**i\\n                B += 9*10**i\\n                n = n-1\\n            else:\\n                B += (digit-1)*10**i\\n                A += 1*10**i\\n            i += 1\\n        \\n        B += n*10**i\\n        \\n        return A,B\\n```",
                "codeTag": "Java"
            },
            {
                "id": 822584,
                "title": "python-o-log-n-faster-than-96",
                "content": "Approach:\\n1. Find the largest number A consisting of all 9\\'s, with A<=n.  Think of this as your cushion to pull from if any digits in B need to get bumped up.\\n2. Start with B = n-A\\n3. For each digit in B, if it is 0, add 1 to that position (and correspondingly decrement A).\\n\\nAlso, note that the runtime result for this problem can probably be misleading.  The constraints for this problem include an extremely low upper bound (n <= 10^4), where a brute force solution of iterating over all pairs and checking for a \\'0\\' (typically O(n log(n)) ) can perform well.\\n\\n```\\nimport math\\n\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        if n < 10:\\n            return [1,n-1]\\n        \\n        digits = math.floor(math.log10(n))+1\\n        a = 10**(digits-1) - 1\\n        b = n - a\\n        b_rem = b\\n        \\n        for ind in range(digits-1):\\n            d = b_rem%10\\n            if d == 0:\\n                a -= 10**ind\\n                b += 10**ind\\n            b_rem = (b_rem-d)//10\\n                \\n        return [a,b]\\n\\t\\t\\n",
                "solutionTags": [],
                "code": "Approach:\\n1. Find the largest number A consisting of all 9\\'s, with A<=n.  Think of this as your cushion to pull from if any digits in B need to get bumped up.\\n2. Start with B = n-A\\n3. For each digit in B, if it is 0, add 1 to that position (and correspondingly decrement A).\\n\\nAlso, note that the runtime result for this problem can probably be misleading.  The constraints for this problem include an extremely low upper bound (n <= 10^4), where a brute force solution of iterating over all pairs and checking for a \\'0\\' (typically O(n log(n)) ) can perform well.\\n\\n```\\nimport math\\n\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        if n < 10:\\n            return [1,n-1]\\n        \\n        digits = math.floor(math.log10(n))+1\\n        a = 10**(digits-1) - 1\\n        b = n - a\\n        b_rem = b\\n        \\n        for ind in range(digits-1):\\n            d = b_rem%10\\n            if d == 0:\\n                a -= 10**ind\\n                b += 10**ind\\n            b_rem = (b_rem-d)//10\\n                \\n        return [a,b]\\n\\t\\t\\n",
                "codeTag": "Java"
            },
            {
                "id": 773707,
                "title": "easy-java-solution-beats-100",
                "content": "```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        \\n        int num1 = 1;\\n        int num2 = n - num1;\\n\\n        while(num1 <= n/2)\\n        {      \\n            if(noZero(num1) && noZero(num2))\\n            {\\n                return new int[] {num1, num2};\\n            }\\n            else\\n            {   \\n                num1++;\\n                num2 = n - num1;\\n            }\\n        }\\n        \\n        return new int[] {0, 0};\\n    }\\n    \\n    private boolean noZero(int num)\\n    {\\n        while(num>0)\\n        {\\n            if(num%10==0)\\n                return false;\\n            num = num/10;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        \\n        int num1 = 1;\\n        int num2 = n - num1;\\n\\n        while(num1 <= n/2)\\n        {      \\n            if(noZero(num1) && noZero(num2))\\n            {\\n                return new int[] {num1, num2};\\n            }\\n            else\\n            {   \\n                num1++;\\n                num2 = n - num1;\\n            }\\n        }\\n        \\n        return new int[] {0, 0};\\n    }\\n    \\n    private boolean noZero(int num)\\n    {\\n        while(num>0)\\n        {\\n            if(num%10==0)\\n                return false;\\n            num = num/10;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 548987,
                "title": "c-0ms-easy-without-using-string",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(int n)\\n    {\\n        while(n)\\n        {\\n            if(n%10==0) return true;\\n            \\n            n = n/10;\\n        }\\n        \\n        return false;\\n    }\\n    vector<int> getNoZeroIntegers(int n) {\\n        vector<int> ans;\\n        int i = n;\\n        while(i--)\\n        {\\n            int x = i;\\n            int y = (n-i);\\n            if(!check(x) and !check(y))\\n            {\\n                ans.push_back(x);\\n                ans.push_back(y);\\n                return ans;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int n)\\n    {\\n        while(n)\\n        {\\n            if(n%10==0) return true;\\n            \\n            n = n/10;\\n        }\\n        \\n        return false;\\n    }\\n    vector<int> getNoZeroIntegers(int n) {\\n        vector<int> ans;\\n        int i = n;\\n        while(i--)\\n        {\\n            int x = i;\\n            int y = (n-i);\\n            if(!check(x) and !check(y))\\n            {\\n                ans.push_back(x);\\n                ans.push_back(y);\\n                return ans;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504814,
                "title": "javascript-easy-to-understand",
                "content": "```\\nvar getNoZeroIntegers = function(n) {\\n    for(let i = 0; i < n; i++) {\\n        if(!i.toString().includes(\\'0\\') && !(n - i).toString().includes(\\'0\\')) {\\n            return [i, n - i];\\n        }\\n    }\\n    return [];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getNoZeroIntegers = function(n) {\\n    for(let i = 0; i < n; i++) {\\n        if(!i.toString().includes(\\'0\\') && !(n - i).toString().includes(\\'0\\')) {\\n            return [i, n - i];\\n        }\\n    }\\n    return [];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 482665,
                "title": "java-o-log-n-solution-process-each-digit-in-n-from-right-to-left",
                "content": "Consider each digit from right to left, if the digit is >1, then just split that digit to 1 and (digit -1). If the digit is <= 1, there are two cases, if the digit is from the highest bit, then just split it to 1 and 0, since 0 in the highest bit not count, otherwise, bring 10 from the higher bit, and split it to 5 and (10 + digit) - 5.\\n```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        int a = 0, b = 0;\\n        int divisor = 1;\\n        while (n > 0) {\\n\\t\\t\\t// Current digit\\n            int rem = n % 10;\\n\\t\\t\\t// If digit is < 2 and there are higher bit available, bollow 10 from the higher bit, and split the digit to 5 and (digit + 10 - 5)\\n            if (rem < 2 & n > 2) {\\n\\t\\t\\t\\t// The higher bit will decrease by 1 for borrowing to lower digit.\\n                n = n / 10 - 1;\\n                a += 5 * divisor;\\n                b += (rem + 10 - 5) * divisor; \\n            } else {\\n\\t\\t\\t\\t//Otherwise, just split the digit to 1 and digit - 1\\n                n = n / 10;\\n                a += divisor;\\n                b += (rem - 1) * divisor; \\n            }\\n            divisor *= 10;\\n        }\\n        return new int[] {a, b};\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        int a = 0, b = 0;\\n        int divisor = 1;\\n        while (n > 0) {\\n\\t\\t\\t// Current digit\\n            int rem = n % 10;\\n\\t\\t\\t// If digit is < 2 and there are higher bit available, bollow 10 from the higher bit, and split the digit to 5 and (digit + 10 - 5)\\n            if (rem < 2 & n > 2) {\\n\\t\\t\\t\\t// The higher bit will decrease by 1 for borrowing to lower digit.\\n                n = n / 10 - 1;\\n                a += 5 * divisor;\\n                b += (rem + 10 - 5) * divisor; \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 479117,
                "title": "javascript-easy-to-understand-brute-force-non-brute-force",
                "content": "### SOLUTION 1\\n\\nBrute force solution. We traversal all possible numbers and check whether it includes 0.\\n\\n```js\\nconst memo = new Uint8Array(10000);\\nconst helper = x => {\\n  if (memo[x] !== 0) return memo[x] === 1;\\n  while (x > 0) {\\n    if (x % 10 === 0) { memo[x] = 2; return false; }\\n    x = x / 10 << 0;\\n  }\\n  memo[x] = 1;\\n  return true;\\n};\\nconst getNoZeroIntegers = n => {\\n  let m = 0;\\n  while (n--) {\\n    if (helper(++m) && helper(n)) return [m, n];\\n  }\\n};\\n```\\n\\n### SOLUTION 2\\n\\nNon brute force solution. We initial the values `x` and `y` as 1 and `n - 1`.\\n\\nIf `y` or `x` contains 0, then we gonna change it. Here I choose to minus value from `y` and add it to `x`. For example, if the 0 is in the tens, then we minus 10 from `y` and add 10 to `x`.\\n\\nWe keep looping until neither `x` and `y` contains 0.\\n\\n```js\\nconst helper = x => {\\n  let digit = 0;\\n  while (x > 0) {\\n    if (x % 10 === 0) break;\\n    x = x / 10 << 0;\\n    ++digit;\\n  }\\n  return digit;\\n};\\nconst getNoZeroIntegers = n => {\\n  let x = 1, y = n - 1;\\n  while (true) {\\n    let num = 10 ** helper(y);\\n    if (num < y) {\\n      y -= num;\\n      x += num;\\n      continue;\\n    }\\n    num = 10 ** helper(x);\\n    if (num > x) break;\\n    y -= num;\\n    x += num;\\n  }\\n  return [x, y];\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst memo = new Uint8Array(10000);\\nconst helper = x => {\\n  if (memo[x] !== 0) return memo[x] === 1;\\n  while (x > 0) {\\n    if (x % 10 === 0) { memo[x] = 2; return false; }\\n    x = x / 10 << 0;\\n  }\\n  memo[x] = 1;\\n  return true;\\n};\\nconst getNoZeroIntegers = n => {\\n  let m = 0;\\n  while (n--) {\\n    if (helper(++m) && helper(n)) return [m, n];\\n  }\\n};\\n```\n```js\\nconst helper = x => {\\n  let digit = 0;\\n  while (x > 0) {\\n    if (x % 10 === 0) break;\\n    x = x / 10 << 0;\\n    ++digit;\\n  }\\n  return digit;\\n};\\nconst getNoZeroIntegers = n => {\\n  let x = 1, y = n - 1;\\n  while (true) {\\n    let num = 10 ** helper(y);\\n    if (num < y) {\\n      y -= num;\\n      x += num;\\n      continue;\\n    }\\n    num = 10 ** helper(x);\\n    if (num > x) break;\\n    y -= num;\\n    x += num;\\n  }\\n  return [x, y];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 477812,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public int[] GetNoZeroIntegers(int n) \\n    {\\n        for(int i = 1; i < n; i++)\\n            if(!i.ToString().Contains(\\'0\\') && !(n - i).ToString().Contains(\\'0\\'))\\n                return new int[]{i, n - i};\\n        return new int[2];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int[] GetNoZeroIntegers(int n) \\n    {\\n        for(int i = 1; i < n; i++)\\n            if(!i.ToString().Contains(\\'0\\') && !(n - i).ToString().Contains(\\'0\\'))\\n                return new int[]{i, n - i};\\n        return new int[2];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926808,
                "title": "best-java-solution-with-0ms-runtime",
                "content": "\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        int[] res = new int[2];\\n        \\n        for (int i = 1; i < n; i++) {\\n            int c = n - i;\\n            if (check(c) && check(i)) {\\n                res[0] = i;\\n                res[1] = c;\\n                return res;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n\\n    public boolean check(int m) {\\n        while (m > 0) {\\n            int digit = m % 10;\\n            if (digit == 0) {\\n                return false;\\n            }\\n            m /= 10;\\n        }\\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        int[] res = new int[2];\\n        \\n        for (int i = 1; i < n; i++) {\\n            int c = n - i;\\n            if (check(c) && check(i)) {\\n                res[0] = i;\\n                res[1] = c;\\n                return res;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n\\n    public boolean check(int m) {\\n        while (m > 0) {\\n            int digit = m % 10;\\n            if (digit == 0) {\\n                return false;\\n            }\\n            m /= 10;\\n        }\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447533,
                "title": "simple-python-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        pow_ = a = b = 0\\n\\n        while n > 0:\\n            n, m = divmod(n, 10)\\n            if m < 2 and n > 0:\\n                m += 10\\n                n -= 1\\n            \\n            a += min(9, m - 1) * 10 ** pow_\\n            b += max(m - 9, 1) * 10 ** pow_\\n            pow_ += 1\\n\\n        return a, b\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        pow_ = a = b = 0\\n\\n        while n > 0:\\n            n, m = divmod(n, 10)\\n            if m < 2 and n > 0:\\n                m += 10\\n                n -= 1\\n            \\n            a += min(9, m - 1) * 10 ** pow_\\n            b += max(m - 9, 1) * 10 ** pow_\\n            pow_ += 1\\n\\n        return a, b\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3331918,
                "title": "c-easy-solution-and-0ms",
                "content": "# Complexity\\n- Time:\\n0 ms\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getNoZeroIntegers(int n) {\\n        vector<int> res;\\n        for(int i=1;i<n;i++){\\n            string a = to_string(i), b=to_string(n-i);\\n            if(a.find(\\'0\\') != std::string::npos || b.find(\\'0\\') != std::string::npos){\\n                continue;\\n            }\\n            res.push_back(i);res.push_back(n-i);\\n            break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getNoZeroIntegers(int n) {\\n        vector<int> res;\\n        for(int i=1;i<n;i++){\\n            string a = to_string(i), b=to_string(n-i);\\n            if(a.find(\\'0\\') != std::string::npos || b.find(\\'0\\') != std::string::npos){\\n                continue;\\n            }\\n            res.push_back(i);res.push_back(n-i);\\n            break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3319262,
                "title": "go",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc getNoZeroIntegers(n int) []int {\\n\\tfor A := 1; A < n; A++ {\\n\\t\\tB := n - A\\n\\t\\tif !strings.Contains(strconv.Itoa(A)+strconv.Itoa(B), \"0\") {\\n\\t\\t\\treturn []int{A, B}\\n\\t\\t}\\n\\t}\\n    return []int{}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc getNoZeroIntegers(n int) []int {\\n\\tfor A := 1; A < n; A++ {\\n\\t\\tB := n - A\\n\\t\\tif !strings.Contains(strconv.Itoa(A)+strconv.Itoa(B), \"0\") {\\n\\t\\t\\treturn []int{A, B}\\n\\t\\t}\\n\\t}\\n    return []int{}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3313610,
                "title": "91-52-25ms-python3-one-liner-and-detailed-version",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        for i in range(n-1, -1, -1):\\n            if \\'0\\' not in str(i) and \\'0\\' not in str(n - i):\\n                return [i, n-i ]\\n\\n        #Oneliner\\n\\n        return next([i, n-i] for i in range(n-1, -1, -1) if \\'0\\' not in str(i) and \\'0\\' not in str(n-i))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        for i in range(n-1, -1, -1):\\n            if \\'0\\' not in str(i) and \\'0\\' not in str(n - i):\\n                return [i, n-i ]\\n\\n        #Oneliner\\n\\n        return next([i, n-i] for i in range(n-1, -1, -1) if \\'0\\' not in str(i) and \\'0\\' not in str(n-i))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3215035,
                "title": "convert-integer-to-the-sum-of-two-no-zero-integers-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*m)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n// // First Approach\\n\\n\\n\\n// class Solution {\\n// public:\\n//     vector<int> getNoZeroIntegers(int n) {\\n//         vector<int> arr;\\n//         string s1, s2;\\n//         int i, j, k, flag=0;\\n//         for(i=1 ; i<n ; i++)\\n//         {\\n//             flag=0;\\n//             j = i;\\n\\n//             // Check if 1st number contains any zero\\n//             while(j>0)\\n//             {\\n//                 k = j%10;\\n//                 j = j/10;\\n//                 if(k==0)\\n//                 {\\n//                     flag=1;\\n//                     break;\\n//                 }\\n//             }\\n\\n//             // if first number does not contain any zero\\n//             if(flag==0)\\n//             {\\n//                 // then check if second number contains any zero\\n//                 j = n-i;\\n//                 while(j>0)\\n//                 {\\n//                     k = j%10;\\n//                     j = j/10;\\n//                     if(k==0)\\n//                     {\\n//                         flag=1;\\n//                         break;\\n//                     }\\n//                 }\\n//             }\\n\\n//             // if second number also does not conatin any zero, then push both values to vector\\n//             if(flag==0)\\n//             {\\n//                 arr.push_back(i);\\n//                 arr.push_back(n-i);\\n//                 break;\\n//             }\\n//         }\\n//         return arr;\\n//     }\\n// };\\n\\n\\n\\n// Second Approach\\n\\nclass Solution {\\npublic:\\n    vector<int> getNoZeroIntegers(int n) {\\n        vector<int> arr;\\n        string s1, s2;\\n        int i, j, k, flag=0;\\n        for(i=1 ; i<n ; i++)\\n        {\\n            flag = 0;\\n            s1 = to_string(i);\\n            s2 = to_string(n-i);\\n            for(j=0 ; j<s1.length() ; j++)\\n            {\\n                if(s1[j]==\\'0\\')\\n                {\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n            if(flag==0)\\n            {\\n                for(j=0 ; j<s2.length() ; j++)\\n                {\\n                    if(s2[j]==\\'0\\')\\n                    {\\n                        flag=1;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(flag==0)\\n            {\\n                arr.push_back(i);\\n                arr.push_back(n-i);\\n                break;\\n            }\\n        }\\n        return arr;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// // First Approach\\n\\n\\n\\n// class Solution {\\n// public:\\n//     vector<int> getNoZeroIntegers(int n) {\\n//         vector<int> arr;\\n//         string s1, s2;\\n//         int i, j, k, flag=0;\\n//         for(i=1 ; i<n ; i++)\\n//         {\\n//             flag=0;\\n//             j = i;\\n\\n//             // Check if 1st number contains any zero\\n//             while(j>0)\\n//             {\\n//                 k = j%10;\\n//                 j = j/10;\\n//                 if(k==0)\\n//                 {\\n//                     flag=1;\\n//                     break;\\n//                 }\\n//             }\\n\\n//             // if first number does not contain any zero\\n//             if(flag==0)\\n//             {\\n//                 // then check if second number contains any zero\\n//                 j = n-i;\\n//                 while(j>0)\\n//                 {\\n//                     k = j%10;\\n//                     j = j/10;\\n//                     if(k==0)\\n//                     {\\n//                         flag=1;\\n//                         break;\\n//                     }\\n//                 }\\n//             }\\n\\n//             // if second number also does not conatin any zero, then push both values to vector\\n//             if(flag==0)\\n//             {\\n//                 arr.push_back(i);\\n//                 arr.push_back(n-i);\\n//                 break;\\n//             }\\n//         }\\n//         return arr;\\n//     }\\n// };\\n\\n\\n\\n// Second Approach\\n\\nclass Solution {\\npublic:\\n    vector<int> getNoZeroIntegers(int n) {\\n        vector<int> arr;\\n        string s1, s2;\\n        int i, j, k, flag=0;\\n        for(i=1 ; i<n ; i++)\\n        {\\n            flag = 0;\\n            s1 = to_string(i);\\n            s2 = to_string(n-i);\\n            for(j=0 ; j<s1.length() ; j++)\\n            {\\n                if(s1[j]==\\'0\\')\\n                {\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n            if(flag==0)\\n            {\\n                for(j=0 ; j<s2.length() ; j++)\\n                {\\n                    if(s2[j]==\\'0\\')\\n                    {\\n                        flag=1;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(flag==0)\\n            {\\n                arr.push_back(i);\\n                arr.push_back(n-i);\\n                break;\\n            }\\n        }\\n        return arr;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2951353,
                "title": "c-88-simple-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int[] GetNoZeroIntegers(int n) {\\n        int a = 1, b = n-1;\\n        while(a < b){\\n            if((a.ToString().IndexOf(\"0\") < 0) && b.ToString().IndexOf(\"0\") < 0){\\n                return new int[2]{a, b};\\n            }\\n            a++;\\n            b--;\\n        }\\n        return new int[2]{a, b};\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] GetNoZeroIntegers(int n) {\\n        int a = 1, b = n-1;\\n        while(a < b){\\n            if((a.ToString().IndexOf(\"0\") < 0) && b.ToString().IndexOf(\"0\") < 0){\\n                return new int[2]{a, b};\\n            }\\n            a++;\\n            b--;\\n        }\\n        return new int[2]{a, b};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775977,
                "title": "c-easy-100-faster-than-all",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int containZero(int n){\\n        int count = 0;\\n        while(n > 0){\\n            if(n % 10 == 0) count++;\\n            n /= 10;\\n        }\\n        return count;\\n    }\\n    \\n    vector<int> getNoZeroIntegers(int n) {\\n        for(int i = 1; i <= n/2; i++){\\n            if((containZero(i) == 0) && (containZero(n-i) == 0)) return {i, n-i};\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int containZero(int n){\\n        int count = 0;\\n        while(n > 0){\\n            if(n % 10 == 0) count++;\\n            n /= 10;\\n        }\\n        return count;\\n    }\\n    \\n    vector<int> getNoZeroIntegers(int n) {\\n        for(int i = 1; i <= n/2; i++){\\n            if((containZero(i) == 0) && (containZero(n-i) == 0)) return {i, n-i};\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756835,
                "title": "easy-to-understand-beats-100-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n bool nozero(int n){\\n     while(n!=0){\\n         if(n%10==0)\\n         return false;\\n         n=n/10;\\n     }\\n     return true;\\n }\\n    vector<int> getNoZeroIntegers(int n) {\\n        vector<int> ans;\\n        for(int i=1;i<n;i++){\\n            if(nozero(i) && nozero(n-i))\\n            {\\n                ans.push_back(i);\\n                ans.push_back(n-i);\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n bool nozero(int n){\\n     while(n!=0){\\n         if(n%10==0)\\n         return false;\\n         n=n/10;\\n     }\\n     return true;\\n }\\n    vector<int> getNoZeroIntegers(int n) {\\n        vector<int> ans;\\n        for(int i=1;i<n;i++){\\n            if(nozero(i) && nozero(n-i))\\n            {\\n                ans.push_back(i);\\n                ans.push_back(n-i);\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2516052,
                "title": "java-solution-easy-and-faster",
                "content": "Comment for any doubt :)\\n```\\nclass Solution {\\n    // I used this function to check whether n1 and n2 are No-Zero integer or not. \\n    public boolean isContainzero(int num1, int num2 ){\\n        if(num1 == 0 || num2==0)\\n            return true;\\n        while(num1 > 0) {\\n            if(num1 % 10 == 0)\\n                return true;\\n            num1 /= 10;\\n        }\\n         while(num2 > 0) {\\n            if(num2 % 10 == 0)\\n                return true;\\n            num2 /= 10;\\n        }\\n        return false;\\n        \\n}\\n    public int[] getNoZeroIntegers(int n) {\\n        int[] ans = new int[2];\\n        int n1;\\n        int n2;\\n        for(int i=1;i<=n;i++){\\n            n1=i;\\n            n2=n-i;\\n            boolean return_ = isContainzero(n1,n2);\\n            if(return_==true){\\n                isContainzero(n1,n2);\\n            }else{\\n                ans[0]=n1;\\n                ans[1]=n2;\\n                break;\\n            }\\n                   \\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // I used this function to check whether n1 and n2 are No-Zero integer or not. \\n    public boolean isContainzero(int num1, int num2 ){\\n        if(num1 == 0 || num2==0)\\n            return true;\\n        while(num1 > 0) {\\n            if(num1 % 10 == 0)\\n                return true;\\n            num1 /= 10;\\n        }\\n         while(num2 > 0) {\\n            if(num2 % 10 == 0)\\n                return true;\\n            num2 /= 10;\\n        }\\n        return false;\\n        \\n}\\n    public int[] getNoZeroIntegers(int n) {\\n        int[] ans = new int[2];\\n        int n1;\\n        int n2;\\n        for(int i=1;i<=n;i++){\\n            n1=i;\\n            n2=n-i;\\n            boolean return_ = isContainzero(n1,n2);\\n            if(return_==true){\\n                isContainzero(n1,n2);\\n            }else{\\n                ans[0]=n1;\\n                ans[1]=n2;\\n                break;\\n            }\\n                   \\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2474437,
                "title": "easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool zeroContains(int n)\\n    {\\n        if(n%10==0)\\n            return true;\\n        while(n)\\n        {\\n            if(n%10==0)\\n                return true;\\n            n/=10;\\n        }\\n        \\n        return false;\\n    }\\n    vector<int> getNoZeroIntegers(int n) {\\n        vector<int>ans;\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                if(i+j>n)\\n                    break;\\n                if(!zeroContains(i) && !zeroContains(j) && i+j==n)\\n                {\\n                    ans.push_back(i);\\n                    ans.push_back(j);\\n                    return ans;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool zeroContains(int n)\\n    {\\n        if(n%10==0)\\n            return true;\\n        while(n)\\n        {\\n            if(n%10==0)\\n                return true;\\n            n/=10;\\n        }\\n        \\n        return false;\\n    }\\n    vector<int> getNoZeroIntegers(int n) {\\n        vector<int>ans;\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                if(i+j>n)\\n                    break;\\n                if(!zeroContains(i) && !zeroContains(j) && i+j==n)\\n                {\\n                    ans.push_back(i);\\n                    ans.push_back(j);\\n                    return ans;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2425353,
                "title": "easy-approach-c-100-faster",
                "content": "```\\nvector<int> getNoZeroIntegers(int n) {\\n        \\n        for(int i=1; i<=n; ++i){\\n            if(valid(i) && valid(n-i)) return {i,n-i}; //VALID() CHECKS IF I ANS I-N CONTAINS ANY 0 OR NOT\\n        }\\n        return {};   \\n    }\\n    \\n    bool valid(int n){\\n        while(n>0){\\n            if(n%10==0) return false;\\n            n/=10;\\n        }\\n        return true;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> getNoZeroIntegers(int n) {\\n        \\n        for(int i=1; i<=n; ++i){\\n            if(valid(i) && valid(n-i)) return {i,n-i}; //VALID() CHECKS IF I ANS I-N CONTAINS ANY 0 OR NOT\\n        }\\n        return {};   \\n    }\\n    \\n    bool valid(int n){\\n        while(n>0){\\n            if(n%10==0) return false;\\n            n/=10;\\n        }\\n        return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2206904,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        int B;\\n        for (int A = 1; A < n; ++A) {\\n            B = n - A;\\n            if (!(A + \"\").contains(\"0\") && !(B + \"\").contains(\"0\"))\\n            return new int[] {A, B};\\n    }\\n        return new int[]{};\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        int B;\\n        for (int A = 1; A < n; ++A) {\\n            B = n - A;\\n            if (!(A + \"\").contains(\"0\") && !(B + \"\").contains(\"0\"))\\n            return new int[] {A, B};\\n    }\\n        return new int[]{};\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957667,
                "title": "java-o-n-num-of-digits-beats-100",
                "content": "```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        int a=0, b=0, carry = 0 ;\\n        int base = 1;\\n        \\n        while (n > 0){\\n            int v = n % 10 + carry;\\n            if (v <2 && n >= 10){\\n                carry = -1; // borrow 1 from higher digit\\n                v += 10;\\n            } else {\\n                carry = 0;\\n            }\\n            a += base * (v / 2);\\n            b += base * (v / 2 + v % 2);\\n            base *= 10;\\n            n /= 10;\\n        }\\n        return new int[]{a, b};\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        int a=0, b=0, carry = 0 ;\\n        int base = 1;\\n        \\n        while (n > 0){\\n            int v = n % 10 + carry;\\n            if (v <2 && n >= 10){\\n                carry = -1; // borrow 1 from higher digit\\n                v += 10;\\n            } else {\\n                carry = 0;\\n            }\\n            a += base * (v / 2);\\n            b += base * (v / 2 + v % 2);\\n            base *= 10;\\n            n /= 10;\\n        }\\n        return new int[]{a, b};\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1872007,
                "title": "c-simple-c-solution",
                "content": "```\\nclass Solution {\\n    int zero(int n){\\n        int c=0;\\n        while(n>0){\\n            if(n%10 ==0) c++;\\n            n /= 10;\\n        }\\n        return c;\\n    }\\npublic:\\n    vector<int> getNoZeroIntegers(int n) {\\n        for(int i=1; i<=10000; ++i){\\n            if(zero(i)==0 && zero(n-i)==0){\\n                return {i,n-i};\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    int zero(int n){\\n        int c=0;\\n        while(n>0){\\n            if(n%10 ==0) c++;\\n            n /= 10;\\n        }\\n        return c;\\n    }\\npublic:\\n    vector<int> getNoZeroIntegers(int n) {\\n        for(int i=1; i<=10000; ++i){\\n            if(zero(i)==0 && zero(n-i)==0){\\n                return {i,n-i};\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1536281,
                "title": "simple-c-solution-beats-100",
                "content": "**My simple c++ solution, beats 100%**\\n```\\nclass Solution {\\npublic:\\n    vector<int> getNoZeroIntegers(int n) {\\n        for(int i = 1; i<n; i++){\\n            if(noZero(i) && noZero(n-i)){\\n                return {i, n-i};\\n            }\\n        }\\n        return {};\\n    }\\n    bool noZero(int n){\\n        while(n > 0){\\n            if(n % 10 == 0) return false;\\n            n = n/10;\\n        }\\n        return true;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getNoZeroIntegers(int n) {\\n        for(int i = 1; i<n; i++){\\n            if(noZero(i) && noZero(n-i)){\\n                return {i, n-i};\\n            }\\n        }\\n        return {};\\n    }\\n    bool noZero(int n){\\n        while(n > 0){\\n            if(n % 10 == 0) return false;\\n            n = n/10;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1410860,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public int[] getNoZeroIntegers(int n) {\\n        int i=1,j=n-1;\\n        int a[]=new int[2];\\n        while(i<=j)\\n        {\\n            if((check(String.valueOf(i)))&&(check(String.valueOf(j))))\\n            {\\n                a[0]=i;\\n                a[1]=j;\\n                break;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return a;\\n    }\\n    static boolean check(String n)\\n    {\\n        return n.contains(\"0\") ? false : true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int[] getNoZeroIntegers(int n) {\\n        int i=1,j=n-1;\\n        int a[]=new int[2];\\n        while(i<=j)\\n        {\\n            if((check(String.valueOf(i)))&&(check(String.valueOf(j))))\\n            {\\n                a[0]=i;\\n                a[1]=j;\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1383384,
                "title": "rust-simple-brute-force-math",
                "content": "```\\nimpl Solution {\\n    pub fn get_no_zero_integers(n: i32) -> Vec<i32> {\\n        let test_zero_in = |mut x: i32| -> bool {\\n            while x > 0 {\\n                match x % 10 {\\n                    0 => return true,\\n                    _ => x /= 10,\\n                };\\n            }\\n            false\\n        };\\n\\n        let mut a = 1;\\n        while test_zero_in(a) || test_zero_in(n - a) {\\n            a += 1;\\n        }\\n        vec![a, n - a]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Math"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn get_no_zero_integers(n: i32) -> Vec<i32> {\\n        let test_zero_in = |mut x: i32| -> bool {\\n            while x > 0 {\\n                match x % 10 {\\n                    0 => return true,\\n                    _ => x /= 10,\\n                };\\n            }\\n            false\\n        };\\n\\n        let mut a = 1;\\n        while test_zero_in(a) || test_zero_in(n - a) {\\n            a += 1;\\n        }\\n        vec![a, n - a]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1328089,
                "title": "c-easy-solution",
                "content": "```class Solution {\\npublic:\\n    vector<int> getNoZeroIntegers(int n) {\\n        \\n        int a,b,x1,x2;\\n        string s1,s2;\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            a=i;\\n            b=n-i;\\n            s1=to_string(a);\\n            s2=to_string(b);\\n            x1=count(s1.begin(),s1.end(),\\'0\\');\\n            x2=count(s2.begin(),s2.end(),\\'0\\');\\n            if(x1==0 && x2==0)\\n                return {a,b};\\n                \\n        }\\n        return {0};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```class Solution {\\npublic:\\n    vector<int> getNoZeroIntegers(int n) {\\n        \\n        int a,b,x1,x2;\\n        string s1,s2;\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            a=i;\\n            b=n-i;\\n            s1=to_string(a);\\n            s2=to_string(b);\\n            x1=count(s1.begin(),s1.end(),\\'0\\');\\n            x2=count(s2.begin(),s2.end(),\\'0\\');\\n            if(x1==0 && x2==0)\\n                return {a,b};\\n                \\n        }\\n        return {0};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1321687,
                "title": "simple-c-approach-using-two-pointer",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isZero(int n){\\n        while(n>0){\\n            int a = n%10;\\n            if(a==0) return true;\\n            n=n/10;\\n        }\\n        return false;\\n    }\\n    \\n    vector<int> getNoZeroIntegers(int n) {\\n        if(n<10) return {1,n-1};\\n        int i=1, j = n-1;\\n        while(j>i){\\n            if(isZero(j)||isZero(i)){ \\n                j--;i++;\\n            }\\n            else return {i,j};\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isZero(int n){\\n        while(n>0){\\n            int a = n%10;\\n            if(a==0) return true;\\n            n=n/10;\\n        }\\n        return false;\\n    }\\n    \\n    vector<int> getNoZeroIntegers(int n) {\\n        if(n<10) return {1,n-1};\\n        int i=1, j = n-1;\\n        while(j>i){\\n            if(isZero(j)||isZero(i)){ \\n                j--;i++;\\n            }\\n            else return {i,j};\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309141,
                "title": "javascript-simple-solution-92",
                "content": "```\\n/**\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar getNoZeroIntegers = function(n) {\\n    \\n    let firstVal = n;\\n    \\n    let secondVal = 0;\\n    \\n    function hasZero(val) {\\n        return (val + \\'\\').split(\\'\\').includes(\\'0\\')\\n    }\\n    \\n    while(hasZero(firstVal) || hasZero(secondVal)) {\\n        --firstVal;\\n        ++secondVal;\\n    }\\n    \\n    return [firstVal, secondVal];\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar getNoZeroIntegers = function(n) {\\n    \\n    let firstVal = n;\\n    \\n    let secondVal = 0;\\n    \\n    function hasZero(val) {\\n        return (val + \\'\\').split(\\'\\').includes(\\'0\\')\\n    }\\n    \\n    while(hasZero(firstVal) || hasZero(secondVal)) {\\n        --firstVal;\\n        ++secondVal;\\n    }\\n    \\n    return [firstVal, secondVal];\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1295509,
                "title": "convert-integer-to-the-sum-of-two-no-zero-integers-easy-solution",
                "content": "Howdy....\\n.\\n\\n\\n    public int[] getNoZeroIntegers(int n) {\\n        int a = n;\\n        int b = 0;\\n        while(hasNext(a) || hasNext(b)){\\n            a--;\\n            b++;\\n        }\\n        int[] arr = {a,b};\\n        return arr;\\n    }\\n    \\n    public static boolean hasNext(int n){\\n        if(n==0) return true;\\n        \\n        while(n>0){\\n            int digit = n%10;\\n            if(digit==0) return true;\\n            \\n            n/=10;\\n        }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "Howdy....\\n.\\n\\n\\n    public int[] getNoZeroIntegers(int n) {\\n        int a = n;\\n        int b = 0;\\n        while(hasNext(a) || hasNext(b)){\\n            a--;\\n            b++;\\n        }\\n        int[] arr = {a,b};\\n        return arr;\\n    }\\n    \\n    public static boolean hasNext(int n){\\n        if(n==0) return true;\\n        \\n        while(n>0){\\n            int digit = n%10;\\n            if(digit==0) return true;\\n            \\n            n/=10;\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1269041,
                "title": "4-line-solution-c-using-stl-100-fast",
                "content": "**Faster than 100.00% of C++ online submissions for Convert Integer to the Sum of Two No-Zero Integers.**\\n```\\nvector<int> getNoZeroIntegers(int n) \\n    {  \\n        for(int i=1;i<n;i++)\\n        { \\n            string s1=to_string(i);\\n            string s2=to_string(n-i);\\n            if(count(s1.begin(),s1.end(),\\'0\\')==0 && count(s2.begin(),s2.end(),\\'0\\')==0)\\n            {\\n                return {i,n-i};\\n            }\\n        }\\n        return {0,0};\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> getNoZeroIntegers(int n) \\n    {  \\n        for(int i=1;i<n;i++)\\n        { \\n            string s1=to_string(i);\\n            string s2=to_string(n-i);\\n            if(count(s1.begin(),s1.end(),\\'0\\')==0 && count(s2.begin(),s2.end(),\\'0\\')==0)\\n            {\\n                return {i,n-i};\\n            }\\n        }\\n        return {0,0};\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1242220,
                "title": "100-faster-easy-c-solution",
                "content": "```\\n bool isNozero(int a){\\n        while(a>0){\\n            int rem=a%10;\\n            if(rem==0){\\n                return 0;\\n            }\\n            a/=10;\\n        }\\n        return 1;\\n    }\\n    \\n    vector<int> getNoZeroIntegers(int n) {\\n        vector<int> ot;\\n        for(int i=1;i<=n;i++){\\n            int a = i;\\n            int b = n-i;\\n            \\n            if(isNozero(a) and isNozero(b)){\\n                ot.push_back(a);\\n                ot.push_back(b);\\n                break;\\n            }\\n        }\\n        return ot;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n bool isNozero(int a){\\n        while(a>0){\\n            int rem=a%10;\\n            if(rem==0){\\n                return 0;\\n            }\\n            a/=10;\\n        }\\n        return 1;\\n    }\\n    \\n    vector<int> getNoZeroIntegers(int n) {\\n        vector<int> ot;\\n        for(int i=1;i<=n;i++){\\n            int a = i;\\n            int b = n-i;\\n            \\n            if(isNozero(a) and isNozero(b)){\\n                ot.push_back(a);\\n                ot.push_back(b);\\n                break;\\n            }\\n        }\\n        return ot;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1201285,
                "title": "simple-solution-in-java-100-faster",
                "content": "```\\nclass Solution {\\n    boolean hasZero(int num){\\n        while(num>0){\\n            if(num%10==0)\\n                return true;\\n            num/=10;\\n        }\\n        return false;\\n    }\\n    public int[] getNoZeroIntegers(int n) {\\n        int i=1;\\n        \\n        while(i<=n){\\n            if(hasZero(i) || hasZero(n-i))\\n               i++;\\n            else\\n                return new int[]{i,n-i}; \\n        }\\n        return new int[]{-1,-1}; \\n    }\\n}\\n```\\nPlease **upvote**, if you like the solution:)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    boolean hasZero(int num){\\n        while(num>0){\\n            if(num%10==0)\\n                return true;\\n            num/=10;\\n        }\\n        return false;\\n    }\\n    public int[] getNoZeroIntegers(int n) {\\n        int i=1;\\n        \\n        while(i<=n){\\n            if(hasZero(i) || hasZero(n-i))\\n               i++;\\n            else\\n                return new int[]{i,n-i}; \\n        }\\n        return new int[]{-1,-1}; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1193272,
                "title": "rust-beats-100-100",
                "content": "```\\nimpl Solution {\\n    pub fn get_no_zero_integers(n: i32) -> Vec<i32> {\\n        let x = (1..=n / 2).find(|&x| ok(x) && ok(n - x)).unwrap();\\n        vec![x, n - x]\\n    }\\n}\\n\\nfn ok(n: i32) -> bool {\\n    n % 10 != 0\\n        && (n < 10 || (n / 10) % 10 != 0)\\n        && (n < 100 || (n / 100) % 10 != 0)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn get_no_zero_integers(n: i32) -> Vec<i32> {\\n        let x = (1..=n / 2).find(|&x| ok(x) && ok(n - x)).unwrap();\\n        vec![x, n - x]\\n    }\\n}\\n\\nfn ok(n: i32) -> bool {\\n    n % 10 != 0\\n        && (n < 10 || (n / 10) % 10 != 0)\\n        && (n < 100 || (n / 100) % 10 != 0)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1121942,
                "title": "easiest-java-solution-better-than-100",
                "content": "```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        int[] ans = new int[2];\\n        for(int i=1;i<=n;i++)\\n        {\\n            boolean flag = true;\\n            int temp= n-i;\\n            while(temp>0)\\n            {\\n                if(temp%10==0)\\n                {flag= false;\\n                 break;\\n                }\\n                temp=temp/10;\\n            }\\n            int temp1=i;\\n             while(temp1>0)\\n            {\\n                if(temp1%10==0)\\n                {flag= false;\\n                 break;\\n                }\\n                temp1=temp1/10;\\n            }\\n            if(flag==true)\\n            {\\n                ans[0]=i;\\n                ans[1]=n-i;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        int[] ans = new int[2];\\n        for(int i=1;i<=n;i++)\\n        {\\n            boolean flag = true;\\n            int temp= n-i;\\n            while(temp>0)\\n            {\\n                if(temp%10==0)\\n                {flag= false;\\n                 break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1115791,
                "title": "python3-simple-solution-beats-100-user",
                "content": "![image](https://assets.leetcode.com/users/images/69191e72-825c-4be0-a820-4fe83befd131_1616086553.0415015.png)\\n\\n```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        for i in range(1,n):\\n            if \\'0\\' not in str(i) and \\'0\\' not in str(n-i):\\n                return [i,n-i]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        for i in range(1,n):\\n            if \\'0\\' not in str(i) and \\'0\\' not in str(n-i):\\n                return [i,n-i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1068790,
                "title": "java-faster-than-100-for-each-digit-try-to-take-one-if-you-cannot-take-2",
                "content": "```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        var a = n;       \\n        var multiplier = 1;\\n        var take = 1;\\n        var tmp = a;\\n        while (tmp > 0) {\\n            tmp = tmp - 1;\\n            if (tmp % 10 != 0) {\\n                a -= multiplier * take;\\n                tmp /= 10;\\n                multiplier *= 10;\\n                take = 1;\\n            } else {\\n                take++;\\n            }\\n        }\\n        return new int[] {n - a, a};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        var a = n;       \\n        var multiplier = 1;\\n        var take = 1;\\n        var tmp = a;\\n        while (tmp > 0) {\\n            tmp = tmp - 1;\\n            if (tmp % 10 != 0) {\\n                a -= multiplier * take;\\n                tmp /= 10;\\n                multiplier *= 10;\\n                take = 1;\\n            } else {\\n                take++;\\n            }\\n        }\\n        return new int[] {n - a, a};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1054168,
                "title": "python-easy-and-fast-solution",
                "content": "```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        if n<10:\\n            return [n-1,1]\\n        x=len(str(n))\\n        m=int(\"9\"*(x-1))\\n        n=n-m\\n        x=str(n)\\n        c=0\\n        for i in range(len(x)-1,0,-1):\\n            if x[i]==\"0\":\\n                n+=10**c\\n                m-=10**c\\n            c+=1\\n        return [m,n]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        if n<10:\\n            return [n-1,1]\\n        x=len(str(n))\\n        m=int(\"9\"*(x-1))\\n        n=n-m\\n        x=str(n)\\n        c=0\\n        for i in range(len(x)-1,0,-1):\\n            if x[i]==\"0\":\\n                n+=10**c\\n                m-=10**c\\n            c+=1\\n        return [m,n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1052276,
                "title": "golang-solution-faster-than-100",
                "content": "```\\nfunc getNoZeroIntegers(n int) []int {\\n\\tfor i := 1; i < n; i++ {\\n\\t\\tcontainsZero := false\\n\\t\\ta := i\\n\\t\\tb := n - i\\n\\t\\tfor a > 0 { // the first number has no zeros\\n\\t\\t\\tif a%10 == 0 {\\n\\t\\t\\t\\tcontainsZero = true\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t\\ta /= 10\\n\\t\\t}\\n\\t\\tif !containsZero {\\n\\t\\t\\tfor b > 0 { // second number has no zeros\\n\\t\\t\\t\\tif b%10 == 0 {\\n\\t\\t\\t\\t\\tcontainsZero = true\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tb /= 10\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif !containsZero { // if none of the numbers have zeros then return \\n\\t\\t\\treturn []int{i, n - i}\\n\\t\\t}\\n\\t}\\n\\treturn []int{}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc getNoZeroIntegers(n int) []int {\\n\\tfor i := 1; i < n; i++ {\\n\\t\\tcontainsZero := false\\n\\t\\ta := i\\n\\t\\tb := n - i\\n\\t\\tfor a > 0 { // the first number has no zeros\\n\\t\\t\\tif a%10 == 0 {\\n\\t\\t\\t\\tcontainsZero = true\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t\\ta /= 10\\n\\t\\t}\\n\\t\\tif !containsZero {\\n\\t\\t\\tfor b > 0 { // second number has no zeros\\n\\t\\t\\t\\tif b%10 == 0 {\\n\\t\\t\\t\\t\\tcontainsZero = true\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tb /= 10\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif !containsZero { // if none of the numbers have zeros then return \\n\\t\\t\\treturn []int{i, n - i}\\n\\t\\t}\\n\\t}\\n\\treturn []int{}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1014807,
                "title": "faster-than-95-09-of-python3-online-submissions",
                "content": "```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        i,j = n,0\\n        i1,j1 = str(i),str(j)\\n        while \\'0\\' in i1 or \\'0\\' in j1:\\n            i -= 1\\n            j += 1\\n            i1,j1 = str(i),str(j)\\n        return [j,i]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        i,j = n,0\\n        i1,j1 = str(i),str(j)\\n        while \\'0\\' in i1 or \\'0\\' in j1:\\n            i -= 1\\n            j += 1\\n            i1,j1 = str(i),str(j)\\n        return [j,i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 915654,
                "title": "python3-100-faster-100-less-memory-16ms-14-1mb",
                "content": "```\\nclass Solution:\\n    def getNoZeroIntegers(self, n):\\n        for x in range(1, n):\\n            for c in str(x):\\n                if c == \\'0\\':\\n                    break\\n            else:\\n                for y in str(tmp := n - x):\\n                    if y ==\\'0\\':\\n                        break\\n                else:\\n                    return x, tmp\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getNoZeroIntegers(self, n):\\n        for x in range(1, n):\\n            for c in str(x):\\n                if c == \\'0\\':\\n                    break\\n            else:\\n                for y in str(tmp := n - x):\\n                    if y ==\\'0\\':\\n                        break\\n                else:\\n                    return x, tmp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 910783,
                "title": "c-clean-ft-100",
                "content": "```\\nbool checkNoZero(int n) {\\n        if (n == 0) return true;\\n        return (n % 10 != 0) && checkNoZero(n/10);\\n    }\\n    vector<int> getNoZeroIntegers(int n) {\\n        int a = 1, b = n-1;\\n        while(!checkNoZero(a) || !checkNoZero(b)) a++, b--;\\n        return {a,b};\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nbool checkNoZero(int n) {\\n        if (n == 0) return true;\\n        return (n % 10 != 0) && checkNoZero(n/10);\\n    }\\n    vector<int> getNoZeroIntegers(int n) {\\n        int a = 1, b = n-1;\\n        while(!checkNoZero(a) || !checkNoZero(b)) a++, b--;\\n        return {a,b};\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 909564,
                "title": "java-100",
                "content": "```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        int i=1;\\n        int j=n-1; \\n        while(i%10==0 || j%10==0 || (i/10!=0 && (i/10)%10==0) || (j/10!=0 && (j/10)%10==0)\\n             || (i/100!=0 && (i/100)%10==0) || (j/100!=0 && (j/100)%10==0)\\n             || (i/1000!=0 && (i/1000)%10==0) || (j/1000!=0 && (j/1000)%10==0)){\\n            i++;\\n            j--;\\n        }\\n        return new int[]{i,j};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        int i=1;\\n        int j=n-1; \\n        while(i%10==0 || j%10==0 || (i/10!=0 && (i/10)%10==0) || (j/10!=0 && (j/10)%10==0)\\n             || (i/100!=0 && (i/100)%10==0) || (j/100!=0 && (j/100)%10==0)\\n             || (i/1000!=0 && (i/1000)%10==0) || (j/1000!=0 && (j/1000)%10==0)){\\n            i++;\\n            j--;\\n        }\\n        return new int[]{i,j};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 903059,
                "title": "my-java-solution",
                "content": "```\\n// this can be simply done by iterating from 1 to n, take the ith and n-i value. Check if both the values are having zero, if not take these 2 numbers as the valid answer and save it, otherwise continue with the other one\\n\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        if (n == 2)\\n            return new int [] {1, 1};\\n        int [] result = new int [2];\\n        for (int i=1; i<=n; i++) {  //O(n)\\n            int firstNumber = i;\\n            int secondNumber = n - i;\\n            if (isNoZero(firstNumber) && isNoZero(secondNumber)) { //O(i/10 * (n-i)/10)\\n                result[0] = firstNumber;\\n                result[1] = secondNumber;\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n    public boolean isNoZero(int n) {\\n        while (n > 0) { \\n            int rem = n % 10;\\n            if (rem == 0)\\n                return false;\\n            n = n / 10;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\n// this can be simply done by iterating from 1 to n, take the ith and n-i value. Check if both the values are having zero, if not take these 2 numbers as the valid answer and save it, otherwise continue with the other one\\n\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        if (n == 2)\\n            return new int [] {1, 1};\\n        int [] result = new int [2];\\n        for (int i=1; i<=n; i++) {  //O(n)\\n            int firstNumber = i;\\n            int secondNumber = n - i;\\n            if (isNoZero(firstNumber) && isNoZero(secondNumber)) { //O(i/10 * (n-i)/10)\\n                result[0] = firstNumber;\\n                result[1] = secondNumber;\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n    public boolean isNoZero(int n) {\\n        while (n > 0) { \\n            int rem = n % 10;\\n            if (rem == 0)\\n                return false;\\n            n = n / 10;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 896463,
                "title": "python-easy-intuitive",
                "content": "```\\nclass Solution(object):\\n    def getNoZeroIntegers(self, num):\\n        for k in range(num -1, 0, -1):\\n            if \\'0\\' in str(k) or \\'0\\' in str(num - k):\\n                continue\\n                \\n            return [k, num - k]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def getNoZeroIntegers(self, num):\\n        for k in range(num -1, 0, -1):\\n            if \\'0\\' in str(k) or \\'0\\' in str(num - k):\\n                continue\\n                \\n            return [k, num - k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 894876,
                "title": "c-o-log-n-solution-using-only-integers",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getNoZeroIntegers(int n) {\\n        if(n<10) {\\n            return {1, n-1};\\n        }\\n        int result=0;\\n        int place_value = 1;\\n        int m = n;\\n        while(m/place_value >= 10) {\\n            if((m/place_value)%10 == 1) {\\n                result += place_value *2;\\n            } else {\\n                result += place_value * 1;\\n            }\\n            m = n - result;\\n            place_value *= 10;\\n        }\\n        return {result, n-result};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getNoZeroIntegers(int n) {\\n        if(n<10) {\\n            return {1, n-1};\\n        }\\n        int result=0;\\n        int place_value = 1;\\n        int m = n;\\n        while(m/place_value >= 10) {\\n            if((m/place_value)%10 == 1) {\\n                result += place_value *2;\\n            } else {\\n                result += place_value * 1;\\n            }\\n            m = n - result;\\n            place_value *= 10;\\n        }\\n        return {result, n-result};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 861780,
                "title": "easy-log-n-solution",
                "content": "```\\nbool isValid(int n){\\n        if(n==0)\\n            return false;\\n        while(n>0){\\n            int r = n%10;\\n            if(r==0)\\n                return false;\\n            n = n/10;\\n        }\\n        return true;\\n    }\\n    vector<int> getNoZeroIntegers(int n) {\\n       int low = 1;\\n        int high = n;\\n        int low2 = 1;\\n        int high2 = n;\\n        while(low <high){\\n            int m =low + (high-low)/2;\\n            if(isValid(low) && isValid(n-low))\\n                return {low,n-low};\\n            if(isValid(m) && isValid(n-m))\\n                return {m,n-m};\\n            low = m+1;            \\n        }\\n        while(low2 <high2){\\n            int m =low2 + (high2-low2)/2;\\n            if(isValid(high2)&&isValid(n-high2))\\n                return {high2,n-high2};\\n            if(isValid(m) && isValid(n-m))\\n                return {m,n-m};\\n            high2 = m-1;            \\n        }\\n        \\n       return{};\\n    }\\n\\t```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool isValid(int n){\\n        if(n==0)\\n            return false;\\n        while(n>0){\\n            int r = n%10;\\n            if(r==0)\\n                return false;\\n            n = n/10;\\n        }\\n        return true;\\n    }\\n    vector<int> getNoZeroIntegers(int n) {\\n       int low = 1;\\n        int high = n;\\n        int low2 = 1;\\n        int high2 = n;\\n        while(low <high){\\n            int m =low + (high-low)/2;\\n            if(isValid(low) && isValid(n-low))\\n                return {low,n-low};\\n            if(isValid(m) && isValid(n-m))\\n                return {m,n-m};\\n            low = m+1;            \\n        }\\n        while(low2 <high2){\\n            int m =low2 + (high2-low2)/2;\\n            if(isValid(high2)&&isValid(n-high2))\\n                return {high2,n-high2};\\n            if(isValid(m) && isValid(n-m))\\n                return {m,n-m};\\n            high2 = m-1;            \\n        }\\n        \\n       return{};\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 849258,
                "title": "100-speed-90-memory-c-solution",
                "content": "First, we have two numbers starting at both extremities of [1 to n - 1].\\nThen, we make them go closer to the center until they both no longer contain a zero-digit.\\n\\nWe can make a helper function that returns true if a number contains a zero-digit.\\n```\\n\\tbool containZero(int n) {\\n        for (int d{ 1 }; d <= n; d *= 10)\\n            if (!((n / d) % 10))\\n                return true;\\n        return false;\\n    }\\n```\\nThis helper function checks each digit if it\\'s a zero and returns true at the first sight of a zero-digit.\\n\\nWe can then make our algorithm.\\n```\\n\\tvector<int> getNoZeroIntegers(int n) {\\n        int first{ 1 };\\n        int second{ n - 1 };\\n        \\n        while (containZero(second) || containZero(first)) {\\n            --second;\\n            ++first;\\n        }\\n        \\n        return {first, second};\\n    }\\n```\\nHere, we have two numbers, starting at the extremities of [1 to n - 1].\\nWe then use our helper function and a loop to continue make them go closer to the center until neither of them contain a zero-digit.\\n\\nWe then return an anonymous vector made up of the non-zero containing digits that add up to [n].",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\tbool containZero(int n) {\\n        for (int d{ 1 }; d <= n; d *= 10)\\n            if (!((n / d) % 10))\\n                return true;\\n        return false;\\n    }\\n```\n```\\n\\tvector<int> getNoZeroIntegers(int n) {\\n        int first{ 1 };\\n        int second{ n - 1 };\\n        \\n        while (containZero(second) || containZero(first)) {\\n            --second;\\n            ++first;\\n        }\\n        \\n        return {first, second};\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 827207,
                "title": "c-o-number-of-digits-faster-than-100-solution-using-a-rule-of-construction",
                "content": "```\\nclass Solution {\\npublic:\\n    inline int findSingleCut(int n) {\\n      if (n == 1) {\\n        return 2;\\n      } else { // including 0\\n        return 1;\\n      }\\n    }\\n    \\n    vector<int> getNoZeroIntegers(int n) {\\n      int multiplier = 1;\\n      int firstNumber = findSingleCut(n % 10);\\n      int nextNum = n - firstNumber;\\n      nextNum /= 10;\\n\\n      while (nextNum / 10) {\\n        multiplier *= 10;\\n        int nextDig = findSingleCut(nextNum % 10);\\n        firstNumber += multiplier * nextDig;\\n        nextNum -= nextDig;\\n        nextNum /= 10;\\n      }\\n\\n      return {firstNumber, n - firstNumber};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    inline int findSingleCut(int n) {\\n      if (n == 1) {\\n        return 2;\\n      } else { // including 0\\n        return 1;\\n      }\\n    }\\n    \\n    vector<int> getNoZeroIntegers(int n) {\\n      int multiplier = 1;\\n      int firstNumber = findSingleCut(n % 10);\\n      int nextNum = n - firstNumber;\\n      nextNum /= 10;\\n\\n      while (nextNum / 10) {\\n        multiplier *= 10;\\n        int nextDig = findSingleCut(nextNum % 10);\\n        firstNumber += multiplier * nextDig;\\n        nextNum -= nextDig;\\n        nextNum /= 10;\\n      }\\n\\n      return {firstNumber, n - firstNumber};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825559,
                "title": "c-o-log-n-solution-without-traversing-upto-n",
                "content": "**O(n) solution or O(nlogn) solutions can be a naive approach to this solution as n<10^4. But here is a O(log n) solution which is quite easy to understand.**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> getNoZeroIntegers(int n) {\\n        vector<int> digits;\\n        int n_copy=n,n1,n2;\\n        while(n!=0){\\n            digits.push_back(n%10);\\n            n=n/10;\\n        } // O(log n) , saving digits separately\\n        \\n        n1=pow(10,digits.size()-1);\\n        n1*=digits[digits.size()-1]-1;\\n        for(int i=1;i<digits.size();i++){\\n            n1+=9*pow(10,i-1);\\n        } // O(log n) ,  n=1111 => n1=999 ; if n=5012 => n1=4999\\n        n2=n_copy-n1; \\n        digits.clear();\\n        while(n2!=0){\\n            if(n2%10==0){\\n                n1-=pow(10,digits.size());\\n            }\\n            digits.push_back(n2%10);\\n            n2=n2/10;\\n        } // O(log n2) , checking for 0 in n2; if found put 1 to that place and subtract 1 from n1\\n          //            ie, if n1=4999 n2=105 => n1=4989 n2=115\\n        n2=n_copy-n1;\\n        digits.clear();\\n        return {n1,n2};\\n\\n    }\\n};\\n```\\n\\nPS-: Please do comment your doubts or optimisations :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getNoZeroIntegers(int n) {\\n        vector<int> digits;\\n        int n_copy=n,n1,n2;\\n        while(n!=0){\\n            digits.push_back(n%10);\\n            n=n/10;\\n        } // O(log n) , saving digits separately\\n        \\n        n1=pow(10,digits.size()-1);\\n        n1*=digits[digits.size()-1]-1;\\n        for(int i=1;i<digits.size();i++){\\n            n1+=9*pow(10,i-1);\\n        } // O(log n) ,  n=1111 => n1=999 ; if n=5012 => n1=4999\\n        n2=n_copy-n1; \\n        digits.clear();\\n        while(n2!=0){\\n            if(n2%10==0){\\n                n1-=pow(10,digits.size());\\n            }\\n            digits.push_back(n2%10);\\n            n2=n2/10;\\n        } // O(log n2) , checking for 0 in n2; if found put 1 to that place and subtract 1 from n1\\n          //            ie, if n1=4999 n2=105 => n1=4989 n2=115\\n        n2=n_copy-n1;\\n        digits.clear();\\n        return {n1,n2};\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823536,
                "title": "ruby-solution-get-answer-pair-from-iteration-over-range-and-checking-for-zero-precence",
                "content": "##### Leetcode: 1317. Convert Integer to the Sum of Two No-Zero Integers. \\n\\nIterate over range from 1 till n-1 inclusively, on each iteration check two variables acquired from i and n-i for comprising zeros in decimal representation. If both of them have no zeros return these values in array as an answer.  \\n\\nRuby code:\\n```Ruby\\n# Leetcode: 1317. Convert Integer to the Sum of Two No-Zero Integers.\\n# https://leetcode.com/problems/convert-integer-to-the-sum-of-two-no-zero-integers\\n# Runtime: 64 ms, faster than 28.57% of Ruby online submissions for Convert Integer to the Sum of Two No-Zero Integers.\\n# Memory Usage: 9.7 MB, less than 28.57% of Ruby online submissions for Convert Integer to the Sum of Two No-Zero Integers.\\n# @param {Integer} n\\n# @return {Integer[]}\\ndef get_no_zero_integers(n)\\n    \\n    (1...n).each do |i|\\n        a,b = i,n-i\\n        return [a,b] if no_zero(a) && no_zero(b)\\n    end\\n    raise \"Cannot find solution.\"\\nend\\ndef no_zero(x)\\n    x.digits.find_index(0).nil?\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```Ruby\\n# Leetcode: 1317. Convert Integer to the Sum of Two No-Zero Integers.\\n# https://leetcode.com/problems/convert-integer-to-the-sum-of-two-no-zero-integers\\n# Runtime: 64 ms, faster than 28.57% of Ruby online submissions for Convert Integer to the Sum of Two No-Zero Integers.\\n# Memory Usage: 9.7 MB, less than 28.57% of Ruby online submissions for Convert Integer to the Sum of Two No-Zero Integers.\\n# @param {Integer} n\\n# @return {Integer[]}\\ndef get_no_zero_integers(n)\\n    \\n    (1...n).each do |i|\\n        a,b = i,n-i\\n        return [a,b] if no_zero(a) && no_zero(b)\\n    end\\n    raise \"Cannot find solution.\"\\nend\\ndef no_zero(x)\\n    x.digits.find_index(0).nil?\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 787455,
                "title": "simple-java-solution-100-time-and-93-space-optimised",
                "content": "class Solution {\\n\\n    public int[] getNoZeroIntegers(int n) {\\n        int x=1;\\n        int y=n-1;\\n        boolean f=false;\\n        int[] a =new int[2];\\n        for(;x<=y;x++,y--)\\n        {\\n        \\n            f=true;\\n            for(int i=x;i>0;i=i/10)\\n            {\\n                if(i%10==0){\\n                    f=false;\\n                    break;}\\n            }\\n            if(f==true)\\n            {\\n            for(int i=y;i>0;i=i/10)\\n            {\\n                if(i%10==0){\\n                    f=false;\\n                    break;}\\n            }\\n            }\\n            if(f==true){\\n        a[0]=x;\\n        a[1]=y;\\n            break;} \\n            \\n        }\\n        return a;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int[] getNoZeroIntegers(int n) {\\n        int x=1;\\n        int y=n-1;\\n        boolean f=false;\\n        int[] a =new int[2];\\n        for(;x<=y;x++,y--)\\n        {\\n        \\n            f=true;\\n            for(int i=x;i>0;i=i/10)\\n            {\\n                if(i%10==0){\\n                    f=false;\\n                    break;}",
                "codeTag": "Java"
            },
            {
                "id": 776675,
                "title": "python-3-3-liner",
                "content": "```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]: \\n        for num in range(1, n):\\n            if \\'0\\' not in \\'\\'.join([str(num), str(n - num)]):\\n                return [num, n - num]\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]: \\n        for num in range(1, n):\\n            if \\'0\\' not in \\'\\'.join([str(num), str(n - num)]):\\n                return [num, n - num]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 741519,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        a = 1\\n        b = n - a\\n        while \\'0\\' in str(a) or \\'0\\' in str(b):\\n            a += 1\\n            b -= 1\\n\\n        return [a, b]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        a = 1\\n        b = n - a\\n        while \\'0\\' in str(a) or \\'0\\' in str(b):\\n            a += 1\\n            b -= 1\\n\\n        return [a, b]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 734172,
                "title": "c-100-time-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool notZero(int num){\\n        while(num){\\n            if(num%10 == 0) return false;\\n            num /= 10;\\n        }\\n        return true;\\n    }\\n    \\n    vector<int> getNoZeroIntegers(int n) {\\n        vector<int> ans;\\n        int i = 1, j = n-1;\\n        while(i <= j){\\n            if(notZero(i) and notZero(j)){\\n                ans.push_back(i);\\n                ans.push_back(j);\\n                //  return ans;\\n                break;\\n            }\\n            i += 1;\\n            j -= 1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool notZero(int num){\\n        while(num){\\n            if(num%10 == 0) return false;\\n            num /= 10;\\n        }\\n        return true;\\n    }\\n    \\n    vector<int> getNoZeroIntegers(int n) {\\n        vector<int> ans;\\n        int i = 1, j = n-1;\\n        while(i <= j){\\n            if(notZero(i) and notZero(j)){\\n                ans.push_back(i);\\n                ans.push_back(j);\\n                //  return ans;\\n                break;\\n            }\\n            i += 1;\\n            j -= 1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 675717,
                "title": "easy-solution-in-c-0ms-beats-100-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    bool nozero(int n){\\n        while(n>0){\\n            if(n%10==0)return 0;\\n            n/=10;\\n        }\\n        return 1;\\n    }\\n    vector<int> getNoZeroIntegers(int n) {\\n        vector<int> ans;\\n        for(int i=1,j=n-1;i<n,j>0;i++,j--){\\n            if(nozero(i) && nozero(j)){\\n                ans.push_back(i);\\n                ans.push_back(j);\\n                return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool nozero(int n){\\n        while(n>0){\\n            if(n%10==0)return 0;\\n            n/=10;\\n        }\\n        return 1;\\n    }\\n    vector<int> getNoZeroIntegers(int n) {\\n        vector<int> ans;\\n        for(int i=1,j=n-1;i<n,j>0;i++,j--){\\n            if(nozero(i) && nozero(j)){\\n                ans.push_back(i);\\n                ans.push_back(j);\\n                return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 620233,
                "title": "java-greedy-o-1-solution",
                "content": "* For each digit **d** in **n**, if it\\'s less than 1, plus 10\\n* Divide it to 1 and (d-1)\\n\\n```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        int a, b, cnt;\\n        a = b = cnt = 0;\\n        while (n > 0) {\\n            int l = n%10;\\n            n /= 10;\\n            if (l < 2 && n > 0) {\\n                l += 10;\\n                n--;\\n            }\\n            int f1 = 1;\\n            if (l == 11) {\\n                f1 = 2;\\n            }\\n            a += Math.pow(10, cnt) * f1;\\n            b += Math.pow(10, cnt) * (l-f1);\\n            cnt++;\\n        }\\n        return new int[] {a, b};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        int a, b, cnt;\\n        a = b = cnt = 0;\\n        while (n > 0) {\\n            int l = n%10;\\n            n /= 10;\\n            if (l < 2 && n > 0) {\\n                l += 10;\\n                n--;\\n            }\\n            int f1 = 1;\\n            if (l == 11) {\\n                f1 = 2;\\n            }\\n            a += Math.pow(10, cnt) * f1;\\n            b += Math.pow(10, cnt) * (l-f1);\\n            cnt++;\\n        }\\n        return new int[] {a, b};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 583374,
                "title": "python-o-n",
                "content": "Problem very similar to \"Two Sums\".\\n\\nThe brute force approach is:\\n```\\ndef getNoZeroIntegers(self, n: int) -> List[int]:\\n\\t### Brute force\\n\\tfor i in range(1, n):\\n\\t\\tfor j in range(i, n):\\n\\t\\t\\tif i + j == n and \"0\" not in str(i) and \"0\" not in str(j):\\n\\t\\t\\t\\treturn [i,j]\\n\\t\\t\\t\\t\\t\\n```\\n\\nNot very efficient as the cost scales quadratic with `n`. \\n\\nBetter approach:\\n```\\ndef getNoZeroIntegers(self, n: int) -> List[int]:\\n\\tfor i in range(1, n):\\n\\t\\tif \"0\" not in str(i) and \"0\" not in str(n-i):\\n\\t\\t\\treturn [i,n-i]\\n                \\n```\\n\\nTime complexity: `O(n)`.  Beats 90% speed, 100% memory.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\ndef getNoZeroIntegers(self, n: int) -> List[int]:\\n\\t### Brute force\\n\\tfor i in range(1, n):\\n\\t\\tfor j in range(i, n):\\n\\t\\t\\tif i + j == n and \"0\" not in str(i) and \"0\" not in str(j):\\n\\t\\t\\t\\treturn [i,j]\\n\\t\\t\\t\\t\\t\\n```\n```\\ndef getNoZeroIntegers(self, n: int) -> List[int]:\\n\\tfor i in range(1, n):\\n\\t\\tif \"0\" not in str(i) and \"0\" not in str(n-i):\\n\\t\\t\\treturn [i,n-i]\\n                \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 573286,
                "title": "go-golang-0ms-solution",
                "content": ">Runtime: 0 ms, faster than 100.00% of Go online submissions for Convert Integer to the Sum of Two No-Zero Integers.\\nMemory Usage: 2 MB, less than 100.00% of Go online submissions for Convert Integer to the Sum of Two No-Zero Integers.\\n\\n```go\\nfunc getNoZeroIntegers(n int) []int {\\n    a, b := 1, n - 1\\n    for {\\n        if notContainZero(a) && notContainZero(b) { return []int{a, b} }\\n        a++\\n        b--\\n    }\\n    return nil\\n}\\n\\nfunc notContainZero(n int) bool {\\n    for n > 10 {\\n        if n % 10 == 0 { return false }\\n        n = n / 10\\n    }\\n    return n != 10\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc getNoZeroIntegers(n int) []int {\\n    a, b := 1, n - 1\\n    for {\\n        if notContainZero(a) && notContainZero(b) { return []int{a, b} }\\n        a++\\n        b--\\n    }\\n    return nil\\n}\\n\\nfunc notContainZero(n int) bool {\\n    for n > 10 {\\n        if n % 10 == 0 { return false }\\n        n = n / 10\\n    }\\n    return n != 10\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 562257,
                "title": "python-3-easy-one-liner",
                "content": "```python\\nclass Solution:\\n  def getNoZeroIntegers(self, n: int) -> List[int]:\\n    return next([i, n-i] for i in range(1, n) if \\'0\\' not in str(i) and not \\'0\\' in str(n-i))\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n  def getNoZeroIntegers(self, n: int) -> List[int]:\\n    return next([i, n-i] for i in range(1, n) if \\'0\\' not in str(i) and not \\'0\\' in str(n-i))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 560449,
                "title": "python-inspired-by-binary-search-same-speed-as-the-other-methods",
                "content": "This method is inspired by binary search. Its the same speed as the one liners here just a bit more explicitly written.\\n\\n```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        l,r = 1, n-1\\n        \\n        while l < r:\\n            \\n            if str(l).count(\"0\") ==0 and str(r).count(\"0\") == 0 and l+r == n:\\n                return [l,r]\\n            \\n            elif l+r > n:\\n                \\n                r -= 1\\n                while str(r).count(\"0\") > 0 :\\n                    r-= 1\\n                    \\n            else:\\n                l += 1\\n                while str(l).count(\"0\") > 0:\\n                    l += 1\\n                    \\n        return [l,r]\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        l,r = 1, n-1\\n        \\n        while l < r:\\n            \\n            if str(l).count(\"0\") ==0 and str(r).count(\"0\") == 0 and l+r == n:\\n                return [l,r]\\n            \\n            elif l+r > n:\\n                \\n                r -= 1\\n                while str(r).count(\"0\") > 0 :\\n                    r-= 1\\n                    \\n            else:\\n                l += 1\\n                while str(l).count(\"0\") > 0:\\n                    l += 1\\n                    \\n        return [l,r]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 535510,
                "title": "c-descriptive-log10-n-solution-0ms-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getNoZeroIntegers(int n) {\\n        vector<int> results = {0, 0};\\n        int iteration = 0;\\n        bool carry = false;\\n        \\n        auto addNumbersToResult = [&](int lhs, int rhs) {\\n            results[0] += lhs * pow(10, iteration);\\n            results[1] += rhs * pow(10, iteration);\\n        };\\n        \\n        while (n > 0) {\\n            if (carry) {\\n                n -= 1;\\n                carry = false;\\n                continue;\\n            }\\n            \\n            /// Special terminal case\\n            if (n == 1) {\\n                addNumbersToResult(1, 0);\\n                return results;\\n            }\\n            \\n            int lastDigit = n % 10;\\n            \\n            if (lastDigit == 0) {\\n                carry = true;\\n                addNumbersToResult(1, 9);\\n            } else if (lastDigit == 1) {\\n                carry = true;\\n                addNumbersToResult(2, 9);\\n            } else {\\n                addNumbersToResult(1, lastDigit - 1);\\n            }\\n            \\n            n /= 10;\\n            iteration += 1;\\n        }\\n        \\n        return results;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getNoZeroIntegers(int n) {\\n        vector<int> results = {0, 0};\\n        int iteration = 0;\\n        bool carry = false;\\n        \\n        auto addNumbersToResult = [&](int lhs, int rhs) {\\n            results[0] += lhs * pow(10, iteration);\\n            results[1] += rhs * pow(10, iteration);\\n        };\\n        \\n        while (n > 0) {\\n            if (carry) {\\n                n -= 1;\\n                carry = false;\\n                continue;\\n            }\\n            \\n            /// Special terminal case\\n            if (n == 1) {\\n                addNumbersToResult(1, 0);\\n                return results;\\n            }\\n            \\n            int lastDigit = n % 10;\\n            \\n            if (lastDigit == 0) {\\n                carry = true;\\n                addNumbersToResult(1, 9);\\n            } else if (lastDigit == 1) {\\n                carry = true;\\n                addNumbersToResult(2, 9);\\n            } else {\\n                addNumbersToResult(1, lastDigit - 1);\\n            }\\n            \\n            n /= 10;\\n            iteration += 1;\\n        }\\n        \\n        return results;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 526937,
                "title": "c-runtime-and-memory-efficient-100",
                "content": "```\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Convert Integer to the Sum of Two No-Zero Integers.\\nMemory Usage: 7.4 MB, less than 100.00% of C++ online submissions for Convert Integer to the Sum of Two No-Zero Integers.\\n\\nclass Solution {\\npublic:\\n    vector<int> getNoZeroIntegers(int n) {\\n        int num = n;\\n        while(num == n || hasZero(num) || (hasZero(numMinus(n, num)))){\\n            num = rand() % n + 1;\\n        }\\n        \\n        int num2 = (num > n) ? num - n : n - num;\\n        \\n        if(num2 > num) return {num, num2};\\n        else return {num2, num};\\n    }\\n    \\n    int numMinus(int n, int num){\\n        return (n > num) ? n - num : num - n;\\n    }\\n    \\n    bool hasZero(int x){\\n        while(x){\\n           if(x % 10 == 0) return true;\\n            x /= 10;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Convert Integer to the Sum of Two No-Zero Integers.\\nMemory Usage: 7.4 MB, less than 100.00% of C++ online submissions for Convert Integer to the Sum of Two No-Zero Integers.\\n\\nclass Solution {\\npublic:\\n    vector<int> getNoZeroIntegers(int n) {\\n        int num = n;\\n        while(num == n || hasZero(num) || (hasZero(numMinus(n, num)))){\\n            num = rand() % n + 1;\\n        }\\n        \\n        int num2 = (num > n) ? num - n : n - num;\\n        \\n        if(num2 > num) return {num, num2};\\n        else return {num2, num};\\n    }\\n    \\n    int numMinus(int n, int num){\\n        return (n > num) ? n - num : num - n;\\n    }\\n    \\n    bool hasZero(int x){\\n        while(x){\\n           if(x % 10 == 0) return true;\\n            x /= 10;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 520961,
                "title": "c-0-ms-o-logn-solution",
                "content": "Basically, we iterate through each digit in `n`. If `n` contains  a digit `d` greater than 1, we assign to our \"other\" number `d-1`. Otherwise, we borrow from next, so if `d = 1` we would set `2` to our number in that digit index, and then borrow a `1` from the next digit. \\n\\nWe can borrow without worries since we can always borrow from the last digit (it can\\'t be a `0`, and if it is a `1`, turning it into a `0` doesn\\'t violate no-zero). So we proceed to do this for every digit, and since we iterate over digits the run-time is `O(logN)`.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> getNoZeroIntegers(int n) {\\n        if(n < 10) return {1, n-1};\\n        string s = to_string(n);\\n        int a = 0, f = 1;\\n        for(int i = s.size()-1; i >= 1; --i) {\\n            if(s[i] <= \\'1\\') {\\n                if(i == 1 && s[i-1] == \\'0\\') break; // If most significant digit is used up (at 0), we are done, this digit in \\'a\\' can be a 0.\\n                a += f*((int)(s[i]-\\'0\\'+1));\\n                int j = i-1;\\n                while(s[j] == \\'0\\') s[j--] = \\'9\\'; // Borrow from left\\n                --s[j]; // always valid\\n            }\\n            else a += (int)(s[i]-\\'0\\'-1)*f;\\n            f *= 10;\\n        }\\n        return {a, n-a};\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getNoZeroIntegers(int n) {\\n        if(n < 10) return {1, n-1};\\n        string s = to_string(n);\\n        int a = 0, f = 1;\\n        for(int i = s.size()-1; i >= 1; --i) {\\n            if(s[i] <= \\'1\\') {\\n                if(i == 1 && s[i-1] == \\'0\\') break; // If most significant digit is used up (at 0), we are done, this digit in \\'a\\' can be a 0.\\n                a += f*((int)(s[i]-\\'0\\'+1));\\n                int j = i-1;\\n                while(s[j] == \\'0\\') s[j--] = \\'9\\'; // Borrow from left\\n                --s[j]; // always valid\\n            }\\n            else a += (int)(s[i]-\\'0\\'-1)*f;\\n            f *= 10;\\n        }\\n        return {a, n-a};\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 494549,
                "title": "java-log-n",
                "content": "Process all digits from right to left.\\nSplit 1 to 2 and 9, else n to 1 and n - 1\\n```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        int mask = 1;\\n        int carry = 0;\\n        int x = 0;\\n        int y = 0;\\n        while (n >= 10) {\\n            int val = n % 10;\\n            if (val == 1) {\\n                x += 2 * mask;\\n                y += 9 * mask;\\n                carry = 1;\\n            } else if (val == 0) {\\n                x += mask;\\n                y += 9 * mask;\\n                carry = 1;\\n            } else {\\n                x += mask;\\n                y += (val - 1) * mask;\\n                carry = 0;\\n            }\\n            mask *= 10;\\n            n = n / 10 - carry;\\n        }\\n        if (n != 0) {\\n            x += mask;\\n            y += (n - 1) * mask;\\n        }\\n        return new int[]{x, y};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        int mask = 1;\\n        int carry = 0;\\n        int x = 0;\\n        int y = 0;\\n        while (n >= 10) {\\n            int val = n % 10;\\n            if (val == 1) {\\n                x += 2 * mask;\\n                y += 9 * mask;\\n                carry = 1;\\n            } else if (val == 0) {\\n                x += mask;\\n                y += 9 * mask;\\n                carry = 1;\\n            } else {\\n                x += mask;\\n                y += (val - 1) * mask;\\n                carry = 0;\\n            }\\n            mask *= 10;\\n            n = n / 10 - carry;\\n        }\\n        if (n != 0) {\\n            x += mask;\\n            y += (n - 1) * mask;\\n        }\\n        return new int[]{x, y};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 492138,
                "title": "kotlin-based-solution-100-runtime-100-memory",
                "content": "A relatively simple solution in kotlin is as follows:\\n\\n```kotlin\\nclass Solution {\\n    fun getNoZeroIntegers(n: Int): IntArray {\\n        for (i in 1 until n) {\\n            if (!isNonZero(i)) continue\\n            \\n            if (isNonZero(n - i)) {\\n                return intArrayOf(i, n - i)\\n            }\\n        }\\n\\n        throw IllegalArgumentException(\"Precondition failed -- all numbers assumed to fit property\")\\n    }\\n    \\n    fun isNonZero(n: Int): Boolean {\\n        var n = n\\n        while (n > 0) {\\n            if (n % 10 == 0) {\\n                return false\\n            }\\n            \\n            n = n / 10\\n        }\\n        \\n        return true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```kotlin\\nclass Solution {\\n    fun getNoZeroIntegers(n: Int): IntArray {\\n        for (i in 1 until n) {\\n            if (!isNonZero(i)) continue\\n            \\n            if (isNonZero(n - i)) {\\n                return intArrayOf(i, n - i)\\n            }\\n        }\\n\\n        throw IllegalArgumentException(\"Precondition failed -- all numbers assumed to fit property\")\\n    }\\n    \\n    fun isNonZero(n: Int): Boolean {\\n        var n = n\\n        while (n > 0) {\\n            if (n % 10 == 0) {\\n                return false\\n            }\\n            \\n            n = n / 10\\n        }\\n        \\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 485620,
                "title": "python",
                "content": "a = 1\\n        b = n -1\\n        for i in range(n):\\n            if \\'0\\' not in list(str(a + i)) and \\'0\\' not in list(str(b-i)):\\n                return [a+i,b-i]",
                "solutionTags": [],
                "code": "a = 1\\n        b = n -1\\n        for i in range(n):\\n            if \\'0\\' not in list(str(a + i)) and \\'0\\' not in list(str(b-i)):\\n                return [a+i,b-i]",
                "codeTag": "Unknown"
            },
            {
                "id": 482657,
                "title": "java-faster-than-100-00-memory-less-than-100-00",
                "content": "```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        int x = 1;\\n        int y = n - 1;\\n        while (x <= y) {\\n            if (isZeroFree(x) && isZeroFree(y)) {\\n                return new int[]{x, y};\\n            }\\n            x++;\\n            y--;            \\n        }\\n        return new int[]{-1, -1};\\n    }\\n    \\n    private static boolean isZeroFree(int n) {\\n        while (n > 0) {\\n            if (n % 10 == 0) {\\n                return false;\\n            }\\n            n /= 10;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        int x = 1;\\n        int y = n - 1;\\n        while (x <= y) {\\n            if (isZeroFree(x) && isZeroFree(y)) {\\n                return new int[]{x, y};\\n            }\\n            x++;\\n            y--;            \\n        }\\n        return new int[]{-1, -1};\\n    }\\n    \\n    private static boolean isZeroFree(int n) {\\n        while (n > 0) {\\n            if (n % 10 == 0) {\\n                return false;\\n            }\\n            n /= 10;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 481908,
                "title": "c-backtracking-with-constant-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    bool backtracking(vector<int>& digits, vector<int>& res, int idx, int carry) {\\n        if (idx >= digits.size() - 1) {\\n            if (!res.empty()) return true;\\n        }\\n        \\n        for (int i = 1; i <= 9; i++) {\\n            int d = digits[idx] + carry;\\n            if (d == i) continue;\\n            if (d < i) {\\n                d += 10;\\n                carry = -1;\\n            } else {\\n                carry = 0;\\n            }\\n            if (d == i) continue;\\n\\n            res.push_back(i);\\n            bool found = backtracking(digits, res, idx + 1, carry);\\n            if (found) return found;\\n            res.pop_back();\\n        }\\n        return false;\\n    }\\n    \\n    vector<int> getNoZeroIntegers(int n) {\\n        vector<int> digits;\\n        int cpy = n;\\n        while (n) {\\n            digits.push_back(n%10);\\n            n/=10;\\n        }\\n        vector<int> res;\\n        backtracking(digits, res, 0, 0);\\n        int v1 = 0, k = 1;\\n        for (const auto& d: res) {\\n            v1 = d * k + v1;\\n            k *= 10;\\n        }\\n        return {v1, cpy - v1};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool backtracking(vector<int>& digits, vector<int>& res, int idx, int carry) {\\n        if (idx >= digits.size() - 1) {\\n            if (!res.empty()) return true;\\n        }\\n        \\n        for (int i = 1; i <= 9; i++) {\\n            int d = digits[idx] + carry;\\n            if (d == i) continue;\\n            if (d < i) {\\n                d += 10;\\n                carry = -1;\\n            } else {\\n                carry = 0;\\n            }\\n            if (d == i) continue;\\n\\n            res.push_back(i);\\n            bool found = backtracking(digits, res, idx + 1, carry);\\n            if (found) return found;\\n            res.pop_back();\\n        }\\n        return false;\\n    }\\n    \\n    vector<int> getNoZeroIntegers(int n) {\\n        vector<int> digits;\\n        int cpy = n;\\n        while (n) {\\n            digits.push_back(n%10);\\n            n/=10;\\n        }\\n        vector<int> res;\\n        backtracking(digits, res, 0, 0);\\n        int v1 = 0, k = 1;\\n        for (const auto& d: res) {\\n            v1 = d * k + v1;\\n            k *= 10;\\n        }\\n        return {v1, cpy - v1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 480317,
                "title": "python-o-logn",
                "content": "```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        order = len(str(n)) if len(str(n))>1 else 2 \\n        a,b = n,0\\n        for i in range(1,order):\\n            digit_position = 10**(i-1)\\n            curr_digit = (a%10**i)//digit_position\\n            if curr_digit == 1:\\n                subtract = 2\\n            else:\\n                subtract = 1\\n            a -= subtract*digit_position\\n            b += subtract*digit_position\\n        return a,b",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        order = len(str(n)) if len(str(n))>1 else 2 \\n        a,b = n,0\\n        for i in range(1,order):\\n            digit_position = 10**(i-1)\\n            curr_digit = (a%10**i)//digit_position\\n            if curr_digit == 1:\\n                subtract = 2\\n            else:\\n                subtract = 1\\n            a -= subtract*digit_position\\n            b += subtract*digit_position\\n        return a,b",
                "codeTag": "Java"
            },
            {
                "id": 478998,
                "title": "just-do-it-digit-by-digit",
                "content": "```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        int a = 0;\\n        int b = n;\\n        int m = 1;\\n        while(b > 1) {\\n            int d = (b % 10 == 1) ? 2 : 1;\\n            a += d * m;\\n            b -= d;\\n            b /= 10;\\n            m *= 10;\\n        }\\n        \\n        return new int[]{a, n - a};\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        int a = 0;\\n        int b = n;\\n        int m = 1;\\n        while(b > 1) {\\n            int d = (b % 10 == 1) ? 2 : 1;\\n            a += d * m;\\n            b -= d;\\n            b /= 10;\\n            m *= 10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 478816,
                "title": "python-3-faster-than-100-less-than-100",
                "content": "\\tclass Solution:\\n\\t\\tdef getNoZeroIntegers(self, n: int) -> List[int]:\\n\\t\\t\\tif len(str(n)) == 1:\\n\\t\\t\\t\\treturn [1, n - 1]\\n\\t\\t\\tnum = \"\"\\n\\t\\t\\tfor i in str(n)[1:]:\\n\\t\\t\\t\\tif i == \"0\":\\n\\t\\t\\t\\t\\tnum += \"1\"\\n\\t\\t\\t\\telif i == \"1\":\\n\\t\\t\\t\\t\\tnum += \"2\"\\n\\t\\t\\t\\telif i == \"2\":\\n\\t\\t\\t\\t\\tnum += \"3\"\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tnum += \"1\"\\n\\t\\t\\treturn [int(num), n - int(num)]",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef getNoZeroIntegers(self, n: int) -> List[int]:\\n\\t\\t\\tif len(str(n)) == 1:\\n\\t\\t\\t\\treturn [1, n - 1]\\n\\t\\t\\tnum = \"\"\\n\\t\\t\\tfor i in str(n)[1:]:\\n\\t\\t\\t\\tif i == \"0\":\\n\\t\\t\\t\\t\\tnum += \"1\"\\n\\t\\t\\t\\telif i == \"1\":\\n\\t\\t\\t\\t\\tnum += \"2\"\\n\\t\\t\\t\\telif i == \"2\":\\n\\t\\t\\t\\t\\tnum += \"3\"\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tnum += \"1\"\\n\\t\\t\\treturn [int(num), n - int(num)]",
                "codeTag": "Java"
            },
            {
                "id": 478748,
                "title": "c-o-len-split-digit",
                "content": "Get a digit, if it\\'s greater than 1, we simply split it for `A` and `B`.\\n`D` -> `A`, `B` (e.g., `A = D/2`, `B = D-D/2`)\\n2 -> 1, 1\\n3 -> 1, 2\\n4 -> 2, 2\\n5 -> 2, 3\\n6 -> 3, 3\\n7 -> 3, 4\\n8 -> 4, 4\\n9 -> 4, 5\\nIf `D` is less than 2, borrow a carry and add 10.\\n0 -> 10 -> 5, 5\\n1 -> 11 -> 5, 6\\nPile digits together and we are sure there is no zero in `A` and `B`\\nA corner case is `d = 1` and there is not enough carry to borrow.\\nIn this case, 1 -> 0, 1. This corner case is for most left digit, hence the 0 doesn\\'t matter.\\n(You can also do any other type of split)\\n```\\nclass Solution {\\npublic:\\n    vector<int> getNoZeroIntegers(int n) {\\n        string A, B;\\n        while(n) {\\n            int d = n % 10;\\n            n /= 10;\\n            if (d < 2 && n > 0) {\\n                --n;\\n                d += 10;\\n            }\\n            A = to_string(d/2) + A;\\n            B = to_string(d-d/2) + B;\\n        }\\n        return {stoi(A),stoi(B)};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getNoZeroIntegers(int n) {\\n        string A, B;\\n        while(n) {\\n            int d = n % 10;\\n            n /= 10;\\n            if (d < 2 && n > 0) {\\n                --n;\\n                d += 10;\\n            }\\n            A = to_string(d/2) + A;\\n            B = to_string(d-d/2) + B;\\n        }\\n        return {stoi(A),stoi(B)};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 478572,
                "title": "simple-java-solution",
                "content": "``` java\\n    public int[] getNoZeroIntegers(int n) {\\n        int[] res = {-1, -1};\\n        for (int i = 1; i < n; i++) {\\n            int j = n - i;\\n            if (!String.valueOf(i).contains(\"0\") && !String.valueOf(j).contains(\"0\")) {\\n                res[0] = i;\\n                res[1] = j;\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "``` java\\n    public int[] getNoZeroIntegers(int n) {\\n        int[] res = {-1, -1};\\n        for (int i = 1; i < n; i++) {\\n            int j = n - i;\\n            if (!String.valueOf(i).contains(\"0\") && !String.valueOf(j).contains(\"0\")) {\\n                res[0] = i;\\n                res[1] = j;\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 478472,
                "title": "c-simple-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getNoZeroIntegers(int n) {\\n        for (int i = 1; i < n; i++) {\\n            if (to_string(i).find(\\'0\\') == string::npos \\n                && to_string(n-i).find(\\'0\\') == string::npos)\\n                return {i, n-i};\\n        }\\n        return {}; // this will not get hit\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getNoZeroIntegers(int n) {\\n        for (int i = 1; i < n; i++) {\\n            if (to_string(i).find(\\'0\\') == string::npos \\n                && to_string(n-i).find(\\'0\\') == string::npos)\\n                return {i, n-i};\\n        }\\n        return {}; // this will not get hit\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 478163,
                "title": "python-one-liner-using-next",
                "content": "```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        return next([i, n - i] for i in range (1, n) if \\'0\\' not in str(i) and \\'0\\' not in str(n - i))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        return next([i, n - i] for i in range (1, n) if \\'0\\' not in str(i) and \\'0\\' not in str(n - i))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477811,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool hasZeros(int x)\\n    {\\n        while(x%10!=0)\\n        {\\n            if(x<10){\\n                return false;\\n            }\\n            x/=10;\\n            \\n        }\\n        return true;\\n    }\\n    \\n    vector<int> getNoZeroIntegers(int n) {\\n        vector<int> ans;\\n        int x=1,y=n-1;\\n        \\n        while( hasZeros(x)|| hasZeros(y) )\\n        {\\n            x++;\\n            y--;\\n        }\\n        ans.push_back(x);\\n        ans.push_back(y);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool hasZeros(int x)\\n    {\\n        while(x%10!=0)\\n        {\\n            if(x<10){\\n                return false;\\n            }\\n            x/=10;\\n            \\n        }\\n        return true;\\n    }\\n    \\n    vector<int> getNoZeroIntegers(int n) {\\n        vector<int> ans;\\n        int x=1,y=n-1;\\n        \\n        while( hasZeros(x)|| hasZeros(y) )\\n        {\\n            x++;\\n            y--;\\n        }\\n        ans.push_back(x);\\n        ans.push_back(y);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477748,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        int left,right;\\n        if(n%2==0){\\n            left = n/2;\\n            right = n/2;\\n        }else{\\n            left = 1;\\n            right = n-1;\\n        }\\n        while(true){\\n            if(check(left)&&check(right))return new int[]{left,right};\\n            else {\\n                left = left+1;\\n                right -=1;\\n            }\\n        }\\n    }\\n    public boolean check(int n){\\n        while(n!=0){\\n            if(n%10==0)return false;\\n            n = n/10;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        int left,right;\\n        if(n%2==0){\\n            left = n/2;\\n            right = n/2;\\n        }else{\\n            left = 1;\\n            right = n-1;\\n        }\\n        while(true){\\n            if(check(left)&&check(right))return new int[]{left,right};\\n            else {\\n                left = left+1;\\n                right -=1;\\n            }\\n        }\\n    }\\n    public boolean check(int n){\\n        while(n!=0){\\n            if(n%10==0)return false;\\n            n = n/10;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477743,
                "title": "short-java",
                "content": "```\\npublic int[] getNoZeroIntegers(int n) {\\n    int a = 1;\\n    while ((n-a + \"\" + a).contains(\"0\"))\\n        a++;\\n    return new int[]{a, n-a};\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] getNoZeroIntegers(int n) {\\n    int a = 1;\\n    while ((n-a + \"\" + a).contains(\"0\"))\\n        a++;\\n    return new int[]{a, n-a};\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 477733,
                "title": "python-one-liner",
                "content": "Here is a simple One-Liner:\\n```python\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        return next([a, n - a] for a in range(n) if \\'0\\' not in str(a) + str(n - a))\\n```\\nAnd this is its original longer version:\\n```python\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        for a in range(n):\\n            b = n - a\\n            if \\'0\\' not in str(a) and \\'0\\' not in str(b):\\n                return [a, b]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        return next([a, n - a] for a in range(n) if \\'0\\' not in str(a) + str(n - a))\\n```\n```python\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        for a in range(n):\\n            b = n - a\\n            if \\'0\\' not in str(a) and \\'0\\' not in str(b):\\n                return [a, b]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477732,
                "title": "python-3-brute-force-two-lines-beats-100-24-ms",
                "content": "```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        for i in range(1,n):\\n            if \\'0\\' not in str(i) + str(n-i): return [i,n-i]\\n\\t\\t\\t\\n\\n- Junaid Mansuri\\n- Chicago, IL",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        for i in range(1,n):\\n            if \\'0\\' not in str(i) + str(n-i): return [i,n-i]\\n\\t\\t\\t\\n\\n- Junaid Mansuri\\n- Chicago, IL",
                "codeTag": "Java"
            },
            {
                "id": 477710,
                "title": "brute-force",
                "content": "```CPP\\nvector<int> getNoZeroIntegers(int n) {\\n    for (auto i = 1; i < n; ++i) {\\n        auto j = n - i;\\n        if (to_string(i).find(\\'0\\') == string::npos \\n            && to_string(j).find(\\'0\\') == string::npos)\\n            return {i, j};\\n    }\\n    return {};\\n}\\n```",
                "solutionTags": [],
                "code": "```CPP\\nvector<int> getNoZeroIntegers(int n) {\\n    for (auto i = 1; i < n; ++i) {\\n        auto j = n - i;\\n        if (to_string(i).find(\\'0\\') == string::npos \\n            && to_string(j).find(\\'0\\') == string::npos)\\n            return {i, j};\\n    }\\n    return {};\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 477689,
                "title": "python-o-n",
                "content": "```python\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        for i in range(1, n):\\n            if str(i).count(\\'0\\') == 0 and str(n-i).count(\\'0\\') == 0:\\n                return [i, n-i]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        for i in range(1, n):\\n            if str(i).count(\\'0\\') == 0 and str(n-i).count(\\'0\\') == 0:\\n                return [i, n-i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477671,
                "title": "java-solution",
                "content": "```\\n\\t  public int[] getNoZeroIntegers(int n) {\\n        if (n == 2) {\\n            return new int[]{1,1};\\n        }\\n        int c1 = 1, c2 = n - c1;\\n        \\n        while (c1 < n) {\\n            if (isNoZero(c1) && isNoZero(c2)) {\\n                return new int[]{c1, c2};\\n            } else {\\n                c1 += 1;\\n                c2 = n - c1;\\n            }\\n        }\\n        return new int[]{c1, c2};\\n    }\\n    \\n    public boolean isNoZero(int num) {\\n        int x = num;\\n        while (x != 0) {\\n            if (x % 10 == 0) {\\n                return false;\\n            }\\n            x /= 10;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\t  public int[] getNoZeroIntegers(int n) {\\n        if (n == 2) {\\n            return new int[]{1,1};\\n        }\\n        int c1 = 1, c2 = n - c1;\\n        \\n        while (c1 < n) {\\n            if (isNoZero(c1) && isNoZero(c2)) {\\n                return new int[]{c1, c2};\\n            } else {\\n                c1 += 1;\\n                c2 = n - c1;\\n            }\\n        }\\n        return new int[]{c1, c2};\\n    }\\n    \\n    public boolean isNoZero(int num) {\\n        int x = num;\\n        while (x != 0) {\\n            if (x % 10 == 0) {\\n                return false;\\n            }\\n            x /= 10;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4089676,
                "title": "the-simplest-solution-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getNoZeroIntegers(int n) {\\n        for (int i = 1; i < n; i++)\\n            if (to_string(i).find(\\'0\\') == string::npos && to_string(n - i).find(\\'0\\') == string::npos)\\n                return vector<int>{ i, n - i };\\n        \\n        return vector<int>{};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getNoZeroIntegers(int n) {\\n        for (int i = 1; i < n; i++)\\n            if (to_string(i).find(\\'0\\') == string::npos && to_string(n - i).find(\\'0\\') == string::npos)\\n                return vector<int>{ i, n - i };\\n        \\n        return vector<int>{};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081909,
                "title": "python-simple",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        a = n\\n        b = int()\\n        for i in range(n):\\n            a -=1\\n            b +=1\\n            if \"0\" in str(a) or \"0\" in str(b):\\n                continue\\n            else:\\n                return [a,b]            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        a = n\\n        b = int()\\n        for i in range(n):\\n            a -=1\\n            b +=1\\n            if \"0\" in str(a) or \"0\" in str(b):\\n                continue\\n            else:\\n                return [a,b]            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4076966,
                "title": "easy-0-ms-soln",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        int a=0;\\n        int b=0;\\n        for(int i=1;i<n;i++){\\n            a=i;\\n            b=n-i;\\n            if(check(a) && check(b)){\\n                return new int[] {a,b};\\n            }\\n        }\\n        return new int[] {-1,-1};\\n    }\\n    public boolean check(int n){\\n        int temp=n;\\n        int ld=0;\\n        while(temp>0){\\n           ld = temp%10;\\n           if(ld==0){\\n               return false;\\n           }\\n           temp/=10;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        int a=0;\\n        int b=0;\\n        for(int i=1;i<n;i++){\\n            a=i;\\n            b=n-i;\\n            if(check(a) && check(b)){\\n                return new int[] {a,b};\\n            }\\n        }\\n        return new int[] {-1,-1};\\n    }\\n    public boolean check(int n){\\n        int temp=n;\\n        int ld=0;\\n        while(temp>0){\\n           ld = temp%10;\\n           if(ld==0){\\n               return false;\\n           }\\n           temp/=10;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066351,
                "title": "runtime-beats-88-80-of-users-with-python3",
                "content": "# Approach\\n1) Divide the input number by 2 and put that number in \"a\" \\n2) Take a and subtract from input number and put the result in \"b\"\\n3) Check if \"a\" or \"b\" contains 0\\n4) do it again till we get \"a\" and \"b\" without 0\\n\\nRuntime\\nDetails\\n33ms\\nBeats 88.80%of users with Python3\\n\\nMemory\\nDetails\\n16.07MB\\nBeats 98.67%of users with Python3\\n\\n# Code\\n```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        a = n//2\\n        b = n - a\\n        if \"0\" in str(a) or \"0\" in str(b):\\n            while \"0\" in str(a) or \"0\" in str(b):\\n                a = a//2\\n                b = n-a\\n\\n        return [a,b]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        a = n//2\\n        b = n - a\\n        if \"0\" in str(a) or \"0\" in str(b):\\n            while \"0\" in str(a) or \"0\" in str(b):\\n                a = a//2\\n                b = n-a\\n\\n        return [a,b]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4057474,
                "title": "easy-simple-code-clean-100-better",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector <int> getNoZeroIntegers(int n) {\\nvector<int> ans;\\nfor(int i=1;i<n;i++){\\n    string a=to_string(i),b=to_string(n-i);\\n    if(a.find(\\'0\\')!=string::npos||b.find(\\'0\\')!=string::npos) continue;\\n    ans.push_back(i);\\n    ans.push_back(n-i);\\n    break;\\n}\\nreturn ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector <int> getNoZeroIntegers(int n) {\\nvector<int> ans;\\nfor(int i=1;i<n;i++){\\n    string a=to_string(i),b=to_string(n-i);\\n    if(a.find(\\'0\\')!=string::npos||b.find(\\'0\\')!=string::npos) continue;\\n    ans.push_back(i);\\n    ans.push_back(n-i);\\n    break;\\n}\\nreturn ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4053305,
                "title": "python3-beat-99-99-time-o-n-space-o-1",
                "content": "# Intuition\\nBrute force all sum combinations\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n\\n        def check_num(num):\\n            s = str(num)\\n            for c in s:\\n                if c == \"0\":\\n                    return False\\n            return True\\n\\n        i = 0\\n        while i <= n//2:\\n\\n            if check_num(i) and check_num(n-i):\\n                return [i, n-i] \\n\\n            i += 1\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n\\n        def check_num(num):\\n            s = str(num)\\n            for c in s:\\n                if c == \"0\":\\n                    return False\\n            return True\\n\\n        i = 0\\n        while i <= n//2:\\n\\n            if check_num(i) and check_num(n-i):\\n                return [i, n-i] \\n\\n            i += 1\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046033,
                "title": "super-easy-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        x = 0\\n        while \\'0\\' in str(x) or \\'0\\' in str(n-x):\\n            x = random.randrange(1,n)\\n        return [x, n-x]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        x = 0\\n        while \\'0\\' in str(x) or \\'0\\' in str(n-x):\\n            x = random.randrange(1,n)\\n        return [x, n-x]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038929,
                "title": "python-simple-solution-math-string-loop",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python\\nclass Solution:\\n  def getNoZeroIntegers(self, n: int) -> List[int]:\\n    x = 1\\n    m = n - 1\\n    while \\'0\\' in str(m) + str(x):\\n      x += 1\\n      m -= 1\\n    return [x, m]\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "String"
                ],
                "code": "```python\\nclass Solution:\\n  def getNoZeroIntegers(self, n: int) -> List[int]:\\n    x = 1\\n    m = n - 1\\n    while \\'0\\' in str(m) + str(x):\\n      x += 1\\n      m -= 1\\n    return [x, m]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038016,
                "title": "discuss",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(h)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        for (int A = 1; A < n; ++A) {\\n        int B = n - A;\\n        if (!String.valueOf(A).contains(\"0\") && !String.valueOf(B).contains(\"0\"))\\n            return new int[] {A, B};\\n        }\\n\\n        throw new IllegalArgumentException();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        for (int A = 1; A < n; ++A) {\\n        int B = n - A;\\n        if (!String.valueOf(A).contains(\"0\") && !String.valueOf(B).contains(\"0\"))\\n            return new int[] {A, B};\\n        }\\n\\n        throw new IllegalArgumentException();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027115,
                "title": "no-zero-integer-using-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar getNoZeroIntegers = function(n) {\\n    for(let i=1;i<n;i++){\\n        let a=i,b=n-i;\\n        if (!String(i).includes(\\'0\\') && !String(n - i).includes(\\'0\\')) {\\n        return [a,b];\\n    }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar getNoZeroIntegers = function(n) {\\n    for(let i=1;i<n;i++){\\n        let a=i,b=n-i;\\n        if (!String(i).includes(\\'0\\') && !String(n - i).includes(\\'0\\')) {\\n        return [a,b];\\n    }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4024873,
                "title": "easy-java-solution-optimize-one",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private boolean check(int num){\\n        if(num==0) return false;\\n        while(num!=0){\\n            if(num%10 == 0){\\n                return false;\\n            }\\n            num/=10;\\n        }\\n        return true;\\n    }\\n\\n    public int[] getNoZeroIntegers(int n) {\\n        \\n        for(int i=0; i<n; i++){\\n            int right = n-i;\\n            if(check(i) && check(right)) return new int[]{i, right};\\n        }\\n\\n        return new int[]{0,0}; // Redundent \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    private boolean check(int num){\\n        if(num==0) return false;\\n        while(num!=0){\\n            if(num%10 == 0){\\n                return false;\\n            }\\n            num/=10;\\n        }\\n        return true;\\n    }\\n\\n    public int[] getNoZeroIntegers(int n) {\\n        \\n        for(int i=0; i<n; i++){\\n            int right = n-i;\\n            if(check(i) && check(right)) return new int[]{i, right};\\n        }\\n\\n        return new int[]{0,0}; // Redundent \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022499,
                "title": "java-and-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Java\\n```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        Random rand = new Random();\\n        String num1 = \"0\";\\n        String num2 = \"0\";\\n        int x = 0;\\n        while(num1.contains(\"0\") || num2.contains(\"0\")){ \\n            x = rand.nextInt(1, n);\\n            num1 = String.valueOf(x);\\n            num2 = String.valueOf(n-x);\\n        }\\n        return new int[]{x, n-x};\\n    }\\n}\\n```\\n\\n# Java 2nd Approach\\n```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        for(int i = 1; i < n; i++){\\n            if(!(String.valueOf(i).contains(\"0\")) && !(String.valueOf(n-i).contains(\"0\"))){ \\n          return new int[]{i, n-i};\\n          }\\n        }\\n        return new int[2];\\n    }\\n}\\n```\\n\\n# Python\\n```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        for i in range(n):\\n\\t        if \"0\" not in str(i) and \"0\" not in str(n - i):\\n\\t\\t        return [i, n - i]\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        Random rand = new Random();\\n        String num1 = \"0\";\\n        String num2 = \"0\";\\n        int x = 0;\\n        while(num1.contains(\"0\") || num2.contains(\"0\")){ \\n            x = rand.nextInt(1, n);\\n            num1 = String.valueOf(x);\\n            num2 = String.valueOf(n-x);\\n        }\\n        return new int[]{x, n-x};\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        for(int i = 1; i < n; i++){\\n            if(!(String.valueOf(i).contains(\"0\")) && !(String.valueOf(n-i).contains(\"0\"))){ \\n          return new int[]{i, n-i};\\n          }\\n        }\\n        return new int[2];\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        for i in range(n):\\n\\t        if \"0\" not in str(i) and \"0\" not in str(n - i):\\n\\t\\t        return [i, n - i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021607,
                "title": "easy-and-understandable-solution-for-beginners",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    func getNoZeroIntegers(_ n: Int) -> [Int] {\\n        var answer:[Int] = []\\n        var firstNumber = 1\\n        var secondNumber = n - firstNumber\\n\\n        var firstNumberString = Array(String(firstNumber))\\n        var secondNumberString = Array(String(secondNumber))\\n\\n        while (firstNumberString.contains(\"0\") != true && secondNumberString.contains(\"0\") != true) == false {\\n            firstNumber += 1\\n            secondNumber = n - firstNumber\\n            firstNumberString = Array(String(firstNumber))\\n            secondNumberString = Array(String(secondNumber))\\n        }\\n\\n        return [firstNumber, secondNumber]\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func getNoZeroIntegers(_ n: Int) -> [Int] {\\n        var answer:[Int] = []\\n        var firstNumber = 1\\n        var secondNumber = n - firstNumber\\n\\n        var firstNumberString = Array(String(firstNumber))\\n        var secondNumberString = Array(String(secondNumber))\\n\\n        while (firstNumberString.contains(\"0\") != true && secondNumberString.contains(\"0\") != true) == false {\\n            firstNumber += 1\\n            secondNumber = n - firstNumber\\n            firstNumberString = Array(String(firstNumber))\\n            secondNumberString = Array(String(secondNumber))\\n        }\\n\\n        return [firstNumber, secondNumber]\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020361,
                "title": "easy-c-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public int[] GetNoZeroIntegers(int n)\\n    {\\n        for (var i = 1; i < n; i++)\\n        {\\n            if (hasNoZero(i) && hasNoZero(n - i))\\n            {\\n                return new[] {i, n - i};\\n            }\\n        }\\n\\n        return Array.Empty<int>();\\n    }\\n\\n    private static bool hasNoZero(int n)\\n    {\\n        while (n > 0)\\n        {\\n            if (n % 10 == 0)\\n            {\\n                return false;\\n            }\\n\\n            n /= 10;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int[] GetNoZeroIntegers(int n)\\n    {\\n        for (var i = 1; i < n; i++)\\n        {\\n            if (hasNoZero(i) && hasNoZero(n - i))\\n            {\\n                return new[] {i, n - i};\\n            }\\n        }\\n\\n        return Array.Empty<int>();\\n    }\\n\\n    private static bool hasNoZero(int n)\\n    {\\n        while (n > 0)\\n        {\\n            if (n % 10 == 0)\\n            {\\n                return false;\\n            }\\n\\n            n /= 10;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020108,
                "title": "the-fastest-in-dart",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\n List<int> getNoZeroIntegers(int n) {\\n  for (int i = 1; i < n; i++) {\\n    int a = i;\\n    int b = n - i;\\n\\n    if (!a.toString().contains(\\'0\\') && !b.toString().contains(\\'0\\')) {\\n      return [a, b];\\n    }\\n  }\\n  // This return statement is only reached if no valid solution is found,\\n  // but your problem statement guarantees there is always a valid solution.\\n  return [];\\n}\\n\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n List<int> getNoZeroIntegers(int n) {\\n  for (int i = 1; i < n; i++) {\\n    int a = i;\\n    int b = n - i;\\n\\n    if (!a.toString().contains(\\'0\\') && !b.toString().contains(\\'0\\')) {\\n      return [a, b];\\n    }\\n  }\\n  // This return statement is only reached if no valid solution is found,\\n  // but your problem statement guarantees there is always a valid solution.\\n  return [];\\n}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4000695,
                "title": "golang-boilerplate",
                "content": "```\\nfunc Index[S ~[]E, E comparable](s S, v E) int {\\n\\tfor i := range s {\\n\\t\\tif v == s[i] {\\n\\t\\t\\treturn i\\n\\t\\t}\\n\\t}\\n\\treturn -1\\n}\\n\\nfunc Contains[S ~[]E, E comparable](s S, v E) bool {\\n\\treturn Index(s, v) >= 0\\n}\\n\\nfunc splitInt(n int) []int {\\n  slc := make([]int, 0)\\n  for n > 0 {\\n    slc = append(slc, n % 10)\\n    n = n / 10\\n  }\\n  return slc\\n}\\n\\nfunc getNoZeroIntegers(n int) []int {\\n  counter := 1 \\n  for ;; {\\n    if Contains(splitInt(n-counter), 0) || Contains(splitInt(counter), 0) {\\n      counter++\\n    } else {\\n      break\\n    }\\n  }\\n  return []int{n-counter, counter}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc Index[S ~[]E, E comparable](s S, v E) int {\\n\\tfor i := range s {\\n\\t\\tif v == s[i] {\\n\\t\\t\\treturn i\\n\\t\\t}\\n\\t}\\n\\treturn -1\\n}\\n\\nfunc Contains[S ~[]E, E comparable](s S, v E) bool {\\n\\treturn Index(s, v) >= 0\\n}\\n\\nfunc splitInt(n int) []int {\\n  slc := make([]int, 0)\\n  for n > 0 {\\n    slc = append(slc, n % 10)\\n    n = n / 10\\n  }\\n  return slc\\n}\\n\\nfunc getNoZeroIntegers(n int) []int {\\n  counter := 1 \\n  for ;; {\\n    if Contains(splitInt(n-counter), 0) || Contains(splitInt(counter), 0) {\\n      counter++\\n    } else {\\n      break\\n    }\\n  }\\n  return []int{n-counter, counter}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4000478,
                "title": "java-fastest-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        int[] ans = new int[2];\\n\\n        for(int i = 1; i <= n/2; i++){\\n            if(isValid(i) && isValid(n-i)){\\n               ans[0] = i;\\n               ans[1]= n-i;\\n               break;\\n            }\\n        }\\n\\n        return ans;\\n    }   \\n\\n    private boolean isValid(int n){\\n        while(n > 0){\\n            if(n % 10 == 0) return false;\\n            n /= 10;\\n        }\\n        return true;\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        int[] ans = new int[2];\\n\\n        for(int i = 1; i <= n/2; i++){\\n            if(isValid(i) && isValid(n-i)){\\n               ans[0] = i;\\n               ans[1]= n-i;\\n               break;\\n            }\\n        }\\n\\n        return ans;\\n    }   \\n\\n    private boolean isValid(int n){\\n        while(n > 0){\\n            if(n % 10 == 0) return false;\\n            n /= 10;\\n        }\\n        return true;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988056,
                "title": "python3-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        \\n        \\n        \\n        \\n        def valid(a):\\n            return \\'0\\' not in str(a) \\n        \\n        curr=1\\n        while  valid(curr)==False or valid(n-curr)==False:\\n            curr+=1\\n        \\n        return [curr,n-curr]\\n\\n    \\n            \\n            \\n                    \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        \\n        \\n        \\n        \\n        def valid(a):\\n            return \\'0\\' not in str(a) \\n        \\n        curr=1\\n        while  valid(curr)==False or valid(n-curr)==False:\\n            curr+=1\\n        \\n        return [curr,n-curr]\\n\\n    \\n            \\n            \\n                    \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985614,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        int arr[]=new int [2];\\n       int i=1;\\n       int j=n-1;\\n       while(i<=j)\\n       {              \\n        if(containsZero(i) && containsZero(j))  //if both i&j do not contain 0\\n              {\\n                  arr[0]=i;\\n                  arr[1]=j;\\n                  break;\\n              }\\n              i++;\\n              j--;\\n          }\\n          return arr;\\n      }\\n\\n      private  boolean containsZero(int num)    //check if number contains 0\\n      {\\n                    \\n                        if(num < 0)\\n                        num = -num;\\n\\n                    while(num > 0) {\\n                        if(num % 10 == 0)\\n                            return false;\\n                        num /= 10;\\n                    }\\n                    return true;\\n                \\n      \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        int arr[]=new int [2];\\n       int i=1;\\n       int j=n-1;\\n       while(i<=j)\\n       {              \\n        if(containsZero(i) && containsZero(j))  //if both i&j do not contain 0\\n              {\\n                  arr[0]=i;\\n                  arr[1]=j;\\n                  break;\\n              }\\n              i++;\\n              j--;\\n          }\\n          return arr;\\n      }\\n\\n      private  boolean containsZero(int num)    //check if number contains 0\\n      {\\n                    \\n                        if(num < 0)\\n                        num = -num;\\n\\n                    while(num > 0) {\\n                        if(num % 10 == 0)\\n                            return false;\\n                        num /= 10;\\n                    }\\n                    return true;\\n                \\n      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983862,
                "title": "simple-java-solution-1ms",
                "content": "```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        int[] result = new int[2];\\n        for (int i = 1; i <= n; i++) {\\n            int j = n - i;\\n            if (!(\"\" + i).contains(\"0\") && !(\"\" + j).contains(\"0\")) {\\n                result[0] = i;\\n                result[1] = j;\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        int[] result = new int[2];\\n        for (int i = 1; i <= n; i++) {\\n            int j = n - i;\\n            if (!(\"\" + i).contains(\"0\") && !(\"\" + j).contains(\"0\")) {\\n                result[0] = i;\\n                result[1] = j;\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977410,
                "title": "python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        for i in range(1, n+1):\\n            if (i > 0 and \"0\" not in str(i)) and (\"0\" not in str(n-i)):\\n                return [i, n-i]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        for i in range(1, n+1):\\n            if (i > 0 and \"0\" not in str(i)) and (\"0\" not in str(n-i)):\\n                return [i, n-i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962754,
                "title": "100-beats-runtime-and-memory-kotlin-beginner-friendly",
                "content": "# Code\\n![\\u0421\\u043D\\u0438\\u043C\\u043E\\u043A \\u044D\\u043A\\u0440\\u0430\\u043D\\u0430 2023-08-26 150140.png](https://assets.leetcode.com/users/images/0aa36f9e-2e41-41ba-85c7-92b41395e734_1693051440.8475406.png)\\n```\\nclass Solution {\\n\\n    fun getNoZeroIntegers(n: Int): IntArray {\\n        for (idxNum in 1 .. n) {\\n            if (!isHasAZero(idxNum) && !isHasAZero(n - idxNum)) {\\n                return intArrayOf(idxNum, n - idxNum)\\n            }\\n        }\\n        return intArrayOf()\\n    }\\n\\n    fun isHasAZero(number: Int): Boolean {\\n        var temp = number\\n        while (temp != 0) {\\n            if (temp % 10 == 0)\\n                return true\\n            temp /= 10\\n        }\\n        return false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n\\n    fun getNoZeroIntegers(n: Int): IntArray {\\n        for (idxNum in 1 .. n) {\\n            if (!isHasAZero(idxNum) && !isHasAZero(n - idxNum)) {\\n                return intArrayOf(idxNum, n - idxNum)\\n            }\\n        }\\n        return intArrayOf()\\n    }\\n\\n    fun isHasAZero(number: Int): Boolean {\\n        var temp = number\\n        while (temp != 0) {\\n            if (temp % 10 == 0)\\n                return true\\n            temp /= 10\\n        }\\n        return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926185,
                "title": "python-fast-and-easy-10ms-95-12mb-100",
                "content": "# Intuition\\nDecompose n = k + (n-k) and check if both are no-Zeros, increment k until solution is valid.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def getNoZeroIntegers(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if not \\'0\\' in str(n-1):\\n            return [n-1,1]\\n        else:\\n            k=1\\n            while \\'0\\' in str(n-k) or \\'0\\' in str(k):\\n                k+=1\\n            return [n-k,k]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def getNoZeroIntegers(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if not \\'0\\' in str(n-1):\\n            return [n-1,1]\\n        else:\\n            k=1\\n            while \\'0\\' in str(n-k) or \\'0\\' in str(k):\\n                k+=1\\n            return [n-k,k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886081,
                "title": "c-easy-100-faster-than-all",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(int n) {\\n        int c=0;\\n        while(n) {\\n            if(n%10 == 0) ++c;\\n            n/=10;\\n        }\\n        if(c != 0) return 1;\\n        return 0;\\n    }\\n    \\n    vector<int> getNoZeroIntegers(int n) {\\n      \\n        for(int i=1; i<=n; ++i) if((n-i)!=0) if(solve(i) == 0 and solve(n-i) == 0) return {i, n-i};\\n        return {0, 0};\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(int n) {\\n        int c=0;\\n        while(n) {\\n            if(n%10 == 0) ++c;\\n            n/=10;\\n        }\\n        if(c != 0) return 1;\\n        return 0;\\n    }\\n    \\n    vector<int> getNoZeroIntegers(int n) {\\n      \\n        for(int i=1; i<=n; ++i) if((n-i)!=0) if(solve(i) == 0 and solve(n-i) == 0) return {i, n-i};\\n        return {0, 0};\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866572,
                "title": "beats-100-no-conversions-to-string",
                "content": "![Untitled.png](https://assets.leetcode.com/users/images/eb43d997-ac53-460e-bd54-fea35651180e_1691229933.7420204.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        def no_zero(x):\\n            while x:\\n                if x % 10 == 0:\\n                    return False\\n                x //= 10\\n            return True\\n\\n        for a in range(1, n // 2 + 1):\\n            if no_zero(a) and no_zero(n - a):\\n                return [a, n - a]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        def no_zero(x):\\n            while x:\\n                if x % 10 == 0:\\n                    return False\\n                x //= 10\\n            return True\\n\\n        for a in range(1, n // 2 + 1):\\n            if no_zero(a) and no_zero(n - a):\\n                return [a, n - a]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866366,
                "title": "java-iteration",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n\\n        int num1 = 1;\\n        int num2 = 0;\\n\\n        while(num1 < n){\\n\\n            num2 = n - num1;\\n\\n            if(!checker(num2)){\\n\\n                break;\\n\\n            }else{\\n                \\n                num1++;\\n\\n                while(checker(num1)){\\n                    num1++;\\n                }\\n\\n            }\\n\\n        }\\n        \\n\\n        return new int[]{ num1 , num2 };\\n\\n    }\\n\\n    private boolean checker(int num){\\n\\n        while(num > 0){\\n\\n            if(num % 10 == 0){\\n                return true;\\n            }\\n\\n            num /= 10;\\n\\n        }\\n\\n        return false;\\n\\n    }\\n\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n\\n        int num1 = 1;\\n        int num2 = 0;\\n\\n        while(num1 < n){\\n\\n            num2 = n - num1;\\n\\n            if(!checker(num2)){\\n\\n                break;\\n\\n            }else{\\n                \\n                num1++;\\n\\n                while(checker(num1)){\\n                    num1++;\\n                }\\n\\n            }\\n\\n        }\\n        \\n\\n        return new int[]{ num1 , num2 };\\n\\n    }\\n\\n    private boolean checker(int num){\\n\\n        while(num > 0){\\n\\n            if(num % 10 == 0){\\n                return true;\\n            }\\n\\n            num /= 10;\\n\\n        }\\n\\n        return false;\\n\\n    }\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853852,
                "title": "python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        for i in range(n):\\n            slist = []\\n            for j in str(i):\\n                slist.append(j)\\n            for k in str(n-i):\\n                slist.append(k)\\n            if \"0\" not in slist:\\n                return [i, n-i]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        for i in range(n):\\n            slist = []\\n            for j in str(i):\\n                slist.append(j)\\n            for k in str(n-i):\\n                slist.append(k)\\n            if \"0\" not in slist:\\n                return [i, n-i]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853286,
                "title": "simplest-solution-runtime-99-20-memory-92-17",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n\\n        k, a = 10, 1\\n        while n//k > 0:\\n            a += k//10\\n            b = n-a\\n            if b%k == b%(k//10): # check \"0\" in k-digit of \"b\"\\n                a += k//10   \\n            k *= 10\\n        return a, n-a\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n\\n        k, a = 10, 1\\n        while n//k > 0:\\n            a += k//10\\n            b = n-a\\n            if b%k == b%(k//10): # check \"0\" in k-digit of \"b\"\\n                a += k//10   \\n            k *= 10\\n        return a, n-a\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3851747,
                "title": "beats-100-00-of-users-with-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getNoZeroIntegers(int n) {\\n        vector<int> out(2);\\n        for (int i = 1; i < n; i++)\\n        {\\n            int flag1 = 0, flag2 = 0;\\n            int k1 = i, k2 = n - i;\\n            while (k1 >= 1)\\n            {\\n                int rem1 = k1 % 10;\\n                if (rem1 == 0)\\n                {\\n                    flag1 = 1;\\n                    break;\\n                }\\n                k1 = k1/10;\\n            }\\n            while (k2 >= 1)\\n            {\\n                int rem2 = k2 % 10;\\n                if (rem2 == 0)\\n                {\\n                    flag2 = 1;\\n                    break;\\n                }\\n                k2 = k2/10;\\n            }\\n\\n            if (flag1 == 0 && flag2 == 0)\\n            {\\n                out[0] = i;\\n                out[1] = n - i;\\n                break;\\n            }\\n        }\\n        return out;       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getNoZeroIntegers(int n) {\\n        vector<int> out(2);\\n        for (int i = 1; i < n; i++)\\n        {\\n            int flag1 = 0, flag2 = 0;\\n            int k1 = i, k2 = n - i;\\n            while (k1 >= 1)\\n            {\\n                int rem1 = k1 % 10;\\n                if (rem1 == 0)\\n                {\\n                    flag1 = 1;\\n                    break;\\n                }\\n                k1 = k1/10;\\n            }\\n            while (k2 >= 1)\\n            {\\n                int rem2 = k2 % 10;\\n                if (rem2 == 0)\\n                {\\n                    flag2 = 1;\\n                    break;\\n                }\\n                k2 = k2/10;\\n            }\\n\\n            if (flag1 == 0 && flag2 == 0)\\n            {\\n                out[0] = i;\\n                out[1] = n - i;\\n                break;\\n            }\\n        }\\n        return out;       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789164,
                "title": "java-simplest-fastest-memory-efficient-100-fast-easy-to-understand-with-details",
                "content": "# Approach\\nfirst cut the int in half and in while loop check for zero in both the pieces, if any one piece has zero in it then minus 1 from it and add it in other half. At one point you\\'ll get non-zero int pieces which sums up to the `int n`\\n\\n`speed : 100%`\\n`space : 90%;`\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        int[] ans = new int[2];\\n        ans[0] = n/2;\\n        if((n&1)==0) ans[1] = n/2;\\n        else ans[1] = n/2+1;\\n\\n        while (zeroPresent(ans[0]) || zeroPresent(ans[1])) {\\n            ans[0]--;\\n            ans[1]++;\\n        }\\n\\n        return ans;\\n    }\\n    private boolean zeroPresent(int val) {\\n        while(val > 9){\\n            if(val%10==0) {\\n                return true;\\n            }\\n            val/=10;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        int[] ans = new int[2];\\n        ans[0] = n/2;\\n        if((n&1)==0) ans[1] = n/2;\\n        else ans[1] = n/2+1;\\n\\n        while (zeroPresent(ans[0]) || zeroPresent(ans[1])) {\\n            ans[0]--;\\n            ans[1]++;\\n        }\\n\\n        return ans;\\n    }\\n    private boolean zeroPresent(int val) {\\n        while(val > 9){\\n            if(val%10==0) {\\n                return true;\\n            }\\n            val/=10;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788527,
                "title": "1-ms-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n     int i;\\n     for(i=1;i<=n;i++)\\n     if(i%10!=0 && String.valueOf(i).contains(\"0\")==false && String.valueOf(n-i).contains(\"0\")==false && i+(n-i)==n)\\n     break;\\n     return new int[]{i,n-i};   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n     int i;\\n     for(i=1;i<=n;i++)\\n     if(i%10!=0 && String.valueOf(i).contains(\"0\")==false && String.valueOf(n-i).contains(\"0\")==false && i+(n-i)==n)\\n     break;\\n     return new int[]{i,n-i};   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3787987,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool chk(int x){\\n        while(x){\\n            if(x%10==0){\\n                return true;\\n            }\\n            x/=10;\\n        }\\n        return false;\\n    }\\n    vector<int> getNoZeroIntegers(int n) {\\n        for(int i=1; i<=n; i++){\\n            if(!chk(i) && !chk(n-i)){\\n                return {i,n-i};\\n            }\\n        }\\n        return {1,1};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool chk(int x){\\n        while(x){\\n            if(x%10==0){\\n                return true;\\n            }\\n            x/=10;\\n        }\\n        return false;\\n    }\\n    vector<int> getNoZeroIntegers(int n) {\\n        for(int i=1; i<=n; i++){\\n            if(!chk(i) && !chk(n-i)){\\n                return {i,n-i};\\n            }\\n        }\\n        return {1,1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744975,
                "title": "very-light-approach",
                "content": "# Complexity\\n- Time complexity:\\n-       O(n)\\n- Space complexity:\\n-       O(1)\\n# Code\\n```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n\\n        for i in range(1, n//2 + 1):\\n            num1, num2 = i, n-i\\n\\n            if num1 + num2 == n and \\'0\\' not in str(num1) and \\'0\\' not in str(num2):\\n                return [num1, num2]\\n        \\n        return 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n\\n        for i in range(1, n//2 + 1):\\n            num1, num2 = i, n-i\\n\\n            if num1 + num2 == n and \\'0\\' not in str(num1) and \\'0\\' not in str(num2):\\n                return [num1, num2]\\n        \\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740984,
                "title": "convert-integer-to-the-sum-of-two-no-zero-integers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\nTo find a pair of No-Zero integers that sum up to the given integer n, we can iterate through all possible values from 1 to n-1. For each value i, we check if both i and n - i are No-Zero integers. If we find such a pair, we return it as the result. Since the problem guarantees at least one valid solution, we can return any valid pair we find.\\n\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.  Iterate through the numbers from 1 to n-1.\\n2. For each number i:\\n3. Check if both i and n - i are No-Zero integers.\\n4.  To check if a number is a No-Zero integer, we can convert it to a string and look for the presence of the character \\'0\\'.\\n5.  If both conditions are satisfied, return the pair [i, n - i] as the result.\\n6.  If no valid pair is found, return an appropriate error or default result (not applicable in this case, as the problem guarantees a valid solution).\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n     for i in range(1, n):\\n        if \\'0\\' not in str(i) and \\'0\\' not in str(n - i):\\n            return [i, n - i]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n     for i in range(1, n):\\n        if \\'0\\' not in str(i) and \\'0\\' not in str(n - i):\\n            return [i, n - i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740544,
                "title": "beats-97-very-easy-python-self-explanatory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        for i in range(1, int(n/2) + 1):\\n            if str(i).count(\"0\") == 0 and str(n-i).count(\"0\") == 0:\\n                return [i, n-i]\\n        return []\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        for i in range(1, int(n/2) + 1):\\n            if str(i).count(\"0\") == 0 and str(n-i).count(\"0\") == 0:\\n                return [i, n-i]\\n        return []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727159,
                "title": "beats-96-more-effective-solution-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        for j in range(n):\\n            n1=j\\n            n2=n-j\\n            if \"0\" not in str(n1) and \"0\" not in str(n2):\\n                return [n1,n2]\\n\\n\\n\\n\\'\\'\\' # less per beat less effective\\n        lst=[]\\n        for j in range(0,n):\\n            n1=j\\n            n2=n-j\\n            if \"0\" in str(n1) or \"0\" in str(n2):\\n                continue\\n            else:\\n                lst.extend([n1,n2])\\n                break\\n        return(lst)\\n\\'\\'\\'\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        for j in range(n):\\n            n1=j\\n            n2=n-j\\n            if \"0\" not in str(n1) and \"0\" not in str(n2):\\n                return [n1,n2]\\n\\n\\n\\n\\'\\'\\' # less per beat less effective\\n        lst=[]\\n        for j in range(0,n):\\n            n1=j\\n            n2=n-j\\n            if \"0\" in str(n1) or \"0\" in str(n2):\\n                continue\\n            else:\\n                lst.extend([n1,n2])\\n                break\\n        return(lst)\\n\\'\\'\\'\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3715266,
                "title": "simple-solution",
                "content": "\\n\\n# Code\\n```\\n\\nvar getNoZeroIntegers = function (n) {\\n  let result = [n, 0];\\n    while(result[1]<n){\\n      if (\\n        !result[0].toString().includes(\"0\") &&\\n        !result[1].toString().includes(\"0\")\\n      ) {\\n        return result;\\n      }\\n      result[0]--;\\n      result[1]++;\\n    }\\n    }\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar getNoZeroIntegers = function (n) {\\n  let result = [n, 0];\\n    while(result[1]<n){\\n      if (\\n        !result[0].toString().includes(\"0\") &&\\n        !result[1].toString().includes(\"0\")\\n      ) {\\n        return result;\\n      }\\n      result[0]--;\\n      result[1]++;\\n    }\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1799454,
                "content": [
                    {
                        "username": "im_rish97",
                        "content": "The wordings of problem not good to catch the problem in one iteration.\\nIt basically means that the number can\\'t have digit 0 in it.\\nFor example: for 1010: 1,1009 is one of the cases but since 1009 has two 0\\'s in it, so not a possible pair."
                    },
                    {
                        "username": "linuscodes56",
                        "content": "[@venkysuvarna8](/venkysuvarna8) headaches are limitless in  software dev career \\uD83D\\uDE43"
                    },
                    {
                        "username": "venkysuvarna8",
                        "content": "Thanks dude, saved me a headache :)"
                    },
                    {
                        "username": "28gevu",
                        "content": "Feels more like a medium."
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "noo"
                    },
                    {
                        "username": "tjstinso",
                        "content": "If the time constraints were more meaningful and input domain were much larger maybe, but for now it\\'s fairly simple arithmetic."
                    },
                    {
                        "username": "d3vSDK",
                        "content": "[@hosua](/hosua) Yeap, really easy with strings. But that\\'s not the best way to solve it."
                    },
                    {
                        "username": "hosua",
                        "content": "Pretty easy if you use strings, but that\\'s most likely not the solution this question\\'s looking for"
                    },
                    {
                        "username": "ramee",
                        "content": "Rewrite the question, in question you are talking about decimal part and answer should be an integer. So integers never contain decimal part. I think im_rish97 is correct, question might state in that way"
                    },
                    {
                        "username": "iambhumik",
                        "content": "when they say decimal, they mean base 10."
                    },
                    {
                        "username": "niteshky01",
                        "content": "why n=11\\n5,6,not valid"
                    },
                    {
                        "username": "user2049D",
                        "content": "It is."
                    },
                    {
                        "username": "Paridhi77",
                        "content": "what\\'s wrong with my solution?\\ntest case says that if n=11 you need to get 9,2 and 5,4 is wrong. idk why\\nclass Solution {\\npublic:\\n    vector<int> getNoZeroIntegers(int n) {\\n        vector<int>ans;\\n        if(n%2==0){\\n            ans.push_back(n/2);\\n            ans.push_back(n/2);\\n        }\\n        else{\\n            ans.push_back(n/2);\\n            ans.push_back(n/2-1);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "niteshky01",
                        "content": "whats the sum of 5,4=9,where n=11"
                    },
                    {
                        "username": "andrewseva",
                        "content": "Use bruteforce and check if both numbers do not contain zero"
                    }
                ]
            },
            {
                "id": 1570506,
                "content": [
                    {
                        "username": "im_rish97",
                        "content": "The wordings of problem not good to catch the problem in one iteration.\\nIt basically means that the number can\\'t have digit 0 in it.\\nFor example: for 1010: 1,1009 is one of the cases but since 1009 has two 0\\'s in it, so not a possible pair."
                    },
                    {
                        "username": "linuscodes56",
                        "content": "[@venkysuvarna8](/venkysuvarna8) headaches are limitless in  software dev career \\uD83D\\uDE43"
                    },
                    {
                        "username": "venkysuvarna8",
                        "content": "Thanks dude, saved me a headache :)"
                    },
                    {
                        "username": "28gevu",
                        "content": "Feels more like a medium."
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "noo"
                    },
                    {
                        "username": "tjstinso",
                        "content": "If the time constraints were more meaningful and input domain were much larger maybe, but for now it\\'s fairly simple arithmetic."
                    },
                    {
                        "username": "d3vSDK",
                        "content": "[@hosua](/hosua) Yeap, really easy with strings. But that\\'s not the best way to solve it."
                    },
                    {
                        "username": "hosua",
                        "content": "Pretty easy if you use strings, but that\\'s most likely not the solution this question\\'s looking for"
                    },
                    {
                        "username": "ramee",
                        "content": "Rewrite the question, in question you are talking about decimal part and answer should be an integer. So integers never contain decimal part. I think im_rish97 is correct, question might state in that way"
                    },
                    {
                        "username": "iambhumik",
                        "content": "when they say decimal, they mean base 10."
                    },
                    {
                        "username": "niteshky01",
                        "content": "why n=11\\n5,6,not valid"
                    },
                    {
                        "username": "user2049D",
                        "content": "It is."
                    },
                    {
                        "username": "Paridhi77",
                        "content": "what\\'s wrong with my solution?\\ntest case says that if n=11 you need to get 9,2 and 5,4 is wrong. idk why\\nclass Solution {\\npublic:\\n    vector<int> getNoZeroIntegers(int n) {\\n        vector<int>ans;\\n        if(n%2==0){\\n            ans.push_back(n/2);\\n            ans.push_back(n/2);\\n        }\\n        else{\\n            ans.push_back(n/2);\\n            ans.push_back(n/2-1);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "niteshky01",
                        "content": "whats the sum of 5,4=9,where n=11"
                    },
                    {
                        "username": "andrewseva",
                        "content": "Use bruteforce and check if both numbers do not contain zero"
                    }
                ]
            },
            {
                "id": 1890578,
                "content": [
                    {
                        "username": "im_rish97",
                        "content": "The wordings of problem not good to catch the problem in one iteration.\\nIt basically means that the number can\\'t have digit 0 in it.\\nFor example: for 1010: 1,1009 is one of the cases but since 1009 has two 0\\'s in it, so not a possible pair."
                    },
                    {
                        "username": "linuscodes56",
                        "content": "[@venkysuvarna8](/venkysuvarna8) headaches are limitless in  software dev career \\uD83D\\uDE43"
                    },
                    {
                        "username": "venkysuvarna8",
                        "content": "Thanks dude, saved me a headache :)"
                    },
                    {
                        "username": "28gevu",
                        "content": "Feels more like a medium."
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "noo"
                    },
                    {
                        "username": "tjstinso",
                        "content": "If the time constraints were more meaningful and input domain were much larger maybe, but for now it\\'s fairly simple arithmetic."
                    },
                    {
                        "username": "d3vSDK",
                        "content": "[@hosua](/hosua) Yeap, really easy with strings. But that\\'s not the best way to solve it."
                    },
                    {
                        "username": "hosua",
                        "content": "Pretty easy if you use strings, but that\\'s most likely not the solution this question\\'s looking for"
                    },
                    {
                        "username": "ramee",
                        "content": "Rewrite the question, in question you are talking about decimal part and answer should be an integer. So integers never contain decimal part. I think im_rish97 is correct, question might state in that way"
                    },
                    {
                        "username": "iambhumik",
                        "content": "when they say decimal, they mean base 10."
                    },
                    {
                        "username": "niteshky01",
                        "content": "why n=11\\n5,6,not valid"
                    },
                    {
                        "username": "user2049D",
                        "content": "It is."
                    },
                    {
                        "username": "Paridhi77",
                        "content": "what\\'s wrong with my solution?\\ntest case says that if n=11 you need to get 9,2 and 5,4 is wrong. idk why\\nclass Solution {\\npublic:\\n    vector<int> getNoZeroIntegers(int n) {\\n        vector<int>ans;\\n        if(n%2==0){\\n            ans.push_back(n/2);\\n            ans.push_back(n/2);\\n        }\\n        else{\\n            ans.push_back(n/2);\\n            ans.push_back(n/2-1);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "niteshky01",
                        "content": "whats the sum of 5,4=9,where n=11"
                    },
                    {
                        "username": "andrewseva",
                        "content": "Use bruteforce and check if both numbers do not contain zero"
                    }
                ]
            },
            {
                "id": 1946574,
                "content": [
                    {
                        "username": "im_rish97",
                        "content": "The wordings of problem not good to catch the problem in one iteration.\\nIt basically means that the number can\\'t have digit 0 in it.\\nFor example: for 1010: 1,1009 is one of the cases but since 1009 has two 0\\'s in it, so not a possible pair."
                    },
                    {
                        "username": "linuscodes56",
                        "content": "[@venkysuvarna8](/venkysuvarna8) headaches are limitless in  software dev career \\uD83D\\uDE43"
                    },
                    {
                        "username": "venkysuvarna8",
                        "content": "Thanks dude, saved me a headache :)"
                    },
                    {
                        "username": "28gevu",
                        "content": "Feels more like a medium."
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "noo"
                    },
                    {
                        "username": "tjstinso",
                        "content": "If the time constraints were more meaningful and input domain were much larger maybe, but for now it\\'s fairly simple arithmetic."
                    },
                    {
                        "username": "d3vSDK",
                        "content": "[@hosua](/hosua) Yeap, really easy with strings. But that\\'s not the best way to solve it."
                    },
                    {
                        "username": "hosua",
                        "content": "Pretty easy if you use strings, but that\\'s most likely not the solution this question\\'s looking for"
                    },
                    {
                        "username": "ramee",
                        "content": "Rewrite the question, in question you are talking about decimal part and answer should be an integer. So integers never contain decimal part. I think im_rish97 is correct, question might state in that way"
                    },
                    {
                        "username": "iambhumik",
                        "content": "when they say decimal, they mean base 10."
                    },
                    {
                        "username": "niteshky01",
                        "content": "why n=11\\n5,6,not valid"
                    },
                    {
                        "username": "user2049D",
                        "content": "It is."
                    },
                    {
                        "username": "Paridhi77",
                        "content": "what\\'s wrong with my solution?\\ntest case says that if n=11 you need to get 9,2 and 5,4 is wrong. idk why\\nclass Solution {\\npublic:\\n    vector<int> getNoZeroIntegers(int n) {\\n        vector<int>ans;\\n        if(n%2==0){\\n            ans.push_back(n/2);\\n            ans.push_back(n/2);\\n        }\\n        else{\\n            ans.push_back(n/2);\\n            ans.push_back(n/2-1);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "niteshky01",
                        "content": "whats the sum of 5,4=9,where n=11"
                    },
                    {
                        "username": "andrewseva",
                        "content": "Use bruteforce and check if both numbers do not contain zero"
                    }
                ]
            },
            {
                "id": 1930094,
                "content": [
                    {
                        "username": "im_rish97",
                        "content": "The wordings of problem not good to catch the problem in one iteration.\\nIt basically means that the number can\\'t have digit 0 in it.\\nFor example: for 1010: 1,1009 is one of the cases but since 1009 has two 0\\'s in it, so not a possible pair."
                    },
                    {
                        "username": "linuscodes56",
                        "content": "[@venkysuvarna8](/venkysuvarna8) headaches are limitless in  software dev career \\uD83D\\uDE43"
                    },
                    {
                        "username": "venkysuvarna8",
                        "content": "Thanks dude, saved me a headache :)"
                    },
                    {
                        "username": "28gevu",
                        "content": "Feels more like a medium."
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "noo"
                    },
                    {
                        "username": "tjstinso",
                        "content": "If the time constraints were more meaningful and input domain were much larger maybe, but for now it\\'s fairly simple arithmetic."
                    },
                    {
                        "username": "d3vSDK",
                        "content": "[@hosua](/hosua) Yeap, really easy with strings. But that\\'s not the best way to solve it."
                    },
                    {
                        "username": "hosua",
                        "content": "Pretty easy if you use strings, but that\\'s most likely not the solution this question\\'s looking for"
                    },
                    {
                        "username": "ramee",
                        "content": "Rewrite the question, in question you are talking about decimal part and answer should be an integer. So integers never contain decimal part. I think im_rish97 is correct, question might state in that way"
                    },
                    {
                        "username": "iambhumik",
                        "content": "when they say decimal, they mean base 10."
                    },
                    {
                        "username": "niteshky01",
                        "content": "why n=11\\n5,6,not valid"
                    },
                    {
                        "username": "user2049D",
                        "content": "It is."
                    },
                    {
                        "username": "Paridhi77",
                        "content": "what\\'s wrong with my solution?\\ntest case says that if n=11 you need to get 9,2 and 5,4 is wrong. idk why\\nclass Solution {\\npublic:\\n    vector<int> getNoZeroIntegers(int n) {\\n        vector<int>ans;\\n        if(n%2==0){\\n            ans.push_back(n/2);\\n            ans.push_back(n/2);\\n        }\\n        else{\\n            ans.push_back(n/2);\\n            ans.push_back(n/2-1);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "niteshky01",
                        "content": "whats the sum of 5,4=9,where n=11"
                    },
                    {
                        "username": "andrewseva",
                        "content": "Use bruteforce and check if both numbers do not contain zero"
                    }
                ]
            },
            {
                "id": 1895910,
                "content": [
                    {
                        "username": "im_rish97",
                        "content": "The wordings of problem not good to catch the problem in one iteration.\\nIt basically means that the number can\\'t have digit 0 in it.\\nFor example: for 1010: 1,1009 is one of the cases but since 1009 has two 0\\'s in it, so not a possible pair."
                    },
                    {
                        "username": "linuscodes56",
                        "content": "[@venkysuvarna8](/venkysuvarna8) headaches are limitless in  software dev career \\uD83D\\uDE43"
                    },
                    {
                        "username": "venkysuvarna8",
                        "content": "Thanks dude, saved me a headache :)"
                    },
                    {
                        "username": "28gevu",
                        "content": "Feels more like a medium."
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "noo"
                    },
                    {
                        "username": "tjstinso",
                        "content": "If the time constraints were more meaningful and input domain were much larger maybe, but for now it\\'s fairly simple arithmetic."
                    },
                    {
                        "username": "d3vSDK",
                        "content": "[@hosua](/hosua) Yeap, really easy with strings. But that\\'s not the best way to solve it."
                    },
                    {
                        "username": "hosua",
                        "content": "Pretty easy if you use strings, but that\\'s most likely not the solution this question\\'s looking for"
                    },
                    {
                        "username": "ramee",
                        "content": "Rewrite the question, in question you are talking about decimal part and answer should be an integer. So integers never contain decimal part. I think im_rish97 is correct, question might state in that way"
                    },
                    {
                        "username": "iambhumik",
                        "content": "when they say decimal, they mean base 10."
                    },
                    {
                        "username": "niteshky01",
                        "content": "why n=11\\n5,6,not valid"
                    },
                    {
                        "username": "user2049D",
                        "content": "It is."
                    },
                    {
                        "username": "Paridhi77",
                        "content": "what\\'s wrong with my solution?\\ntest case says that if n=11 you need to get 9,2 and 5,4 is wrong. idk why\\nclass Solution {\\npublic:\\n    vector<int> getNoZeroIntegers(int n) {\\n        vector<int>ans;\\n        if(n%2==0){\\n            ans.push_back(n/2);\\n            ans.push_back(n/2);\\n        }\\n        else{\\n            ans.push_back(n/2);\\n            ans.push_back(n/2-1);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "niteshky01",
                        "content": "whats the sum of 5,4=9,where n=11"
                    },
                    {
                        "username": "andrewseva",
                        "content": "Use bruteforce and check if both numbers do not contain zero"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Flips to Make a OR b Equal to c",
        "question_content": "<p>Given 3 positives numbers <code>a</code>, <code>b</code> and <code>c</code>. Return the minimum flips required in some bits of <code>a</code> and <code>b</code> to make (&nbsp;<code>a</code> OR <code>b</code> == <code>c</code>&nbsp;). (bitwise OR operation).<br />\r\nFlip operation&nbsp;consists of change&nbsp;<strong>any</strong>&nbsp;single bit 1 to 0 or change the bit 0 to 1&nbsp;in their binary representation.</p>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong class=\"example\">Example 1:</strong></p>\r\n\r\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/01/06/sample_3_1676.png\" style=\"width: 260px; height: 87px;\" /></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> a = 2, b = 6, c = 5\r\n<strong>Output:</strong> 3\r\n<strong>Explanation: </strong>After flips a = 1 , b = 4 , c = 5 such that (<code>a</code> OR <code>b</code> == <code>c</code>)</pre>\r\n\r\n<p><strong class=\"example\">Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> a = 4, b = 2, c = 7\r\n<strong>Output:</strong> 1\r\n</pre>\r\n\r\n<p><strong class=\"example\">Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> a = 1, b = 2, c = 3\r\n<strong>Output:</strong> 0\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Constraints:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= a &lt;= 10^9</code></li>\r\n\t<li><code>1 &lt;= b&nbsp;&lt;= 10^9</code></li>\r\n\t<li><code>1 &lt;= c&nbsp;&lt;= 10^9</code></li>\r\n</ul>",
        "solutions": [
            {
                "id": 479998,
                "title": "c-bitwise-xor-solution-1-line",
                "content": "**Step 1**: `a | b` is what we have while `c` is what we want. An XOR operation finds all different bits, i.e. `(a | b) ^ c` sets the bits where flip(s) is needed. Then we count the set bits.\\n**Step 2**: There is only one case when two flips are needed: a bit is `0` in `c` but is `1` in both `a` and `b`. An AND operation finds all common `1` bits, i.e. `a & b & ((a | b) ^ c)` sets the common `1` bits in `a`, `b` and the must-flip bits found in Step 1.\\n```\\nint minFlips(int a, int b, int c) {\\n    return popcount((a | b) ^ c) + popcount(a & b & ((a | b) ^ c));\\n}\\n```\\nor simplify with an assignment:\\n```\\nint minFlips(int a, int b, int c) {\\n    return popcount(c ^= a | b) + popcount(a & b & c);\\n}\\n```\\nNote: The `popcount` function is a C++ 20 standard builtin function that counts set bits. LeetCode uses g++ compiler with the C++17 standard so we can use `__builtin_popcount` instead. For other compilers please use `bitset<32>().count()`.",
                "solutionTags": [],
                "code": "```\\nint minFlips(int a, int b, int c) {\\n    return popcount((a | b) ^ c) + popcount(a & b & ((a | b) ^ c));\\n}\\n```\n```\\nint minFlips(int a, int b, int c) {\\n    return popcount(c ^= a | b) + popcount(a & b & c);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 477690,
                "title": "java-python-3-bit-manipulation-w-explanation-and-analysis",
                "content": "**Method 1:**\\n\\n**Credit to @codedayday:** for contribution to remove redundant part of the code.\\n\\n----\\n\\n**Q & A**\\nQ1: What is the `mask`? is it `00...01` at the beginning, and move bit `1` to the left when `i` is increasing?\\nA1: Exactly. `mask` changes as the following during iteration:\\n\\t\\n\\t00...01 -> 00...010 -> 00...0100 -> 00...01000 -> ...\\n\\nQ2: Is the `31` here because in C++ int is 32-bit long and there\\'s a sign bit?\\nA2: Because the question said that `a,b,c` are positive numbers. -- **Credit to @KHVic**\\n\\n----\\n\\n1. if `(a | b) ^ c` is `0`, `a | b` and `c` are equal, otherwise not equal and we need to check them bit by bit;\\n2. For `ith` bit of `(a | b) ^ c`, use `1 << i` as mask to do `&` operation to check if the bit is `0`; if not, `ith` bits of `a | b` and `c` are not same and we need at least `1` flip; there are 3 cases:\\n\\ti) the `ith` bit of `a | b`  less than that of `c`; then `ith` bit of `a | b` must be `0`, we only need to flip the `ith` bit of either `a` or `b`;\\n\\tii) the `ith` bit of `a | b`  bigger than that of `c`; then `ith` bit of `a | b` must be `1`, but if only one of `a` or `b`\\'s `ith` bit is `1`, we only need to flip one of them;\\n\\tiii) Other case, we need to flip both set bit of `a` and `b`, hence need `2` flips.\\n\\tIn short, **if `ith` bits of `a | b` and `c` are not same, then only if  `ith` bits of `a` and `b` are both `1` and  that of `c` is `0`, we need `2` flips; otherwise only `1` flip needed.**\\n```java\\n    public int minFlips(int a, int b, int c) {\\n        int ans = 0, ab = a | b, equal = ab ^ c;\\n        for (int i = 0; i < 31; ++i) {\\n            int mask = 1 << i;\\n            if ((equal & mask) > 0)  // ith bits of a | b and c are not same, need at least 1 flip.\\n             // ans += (ab & mask) < (c & mask) || (a & mask) != (b & mask) ? 1 : 2;\\n                ans += (a & mask) == (b & mask) && (c & mask) == 0 ? 2 : 1; // ith bits of a and b are both 1 and that of c is 0?\\n        }\\n        return ans;\\n    }\\n```\\n```python\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        ab, equal, ans = a | b, (a | b) ^ c, 0\\n        for i in range(31):\\n            mask = 1 << i\\n            if equal & mask > 0:\\n              # ans += 1 if (ab & mask) < (c & mask) or (a & mask) != (b & mask) else 2\\n                ans += 2 if (a & mask) == (b & mask) and (c & mask) == 0 else 1\\n        return ans\\n```\\n\\n----\\n\\n**Method 2:**\\n\\nThe following idea and simple codes are from **@mzchen**:\\n\\n**Step 1**: `a | b` is what we have while `c` is what we want. An XOR operation finds all different bits, i.e. `(a | b) ^ c` sets the bits where flip(s) is needed. Then we count the set bits.\\n**Step 2**: There is only one case when two flips are needed: a bit is `0` in `c` but is `1` in both `a` and `b`. An AND operation finds all common `1` bits, i.e. `a & b & ((a | b) ^ c)` sets the common `1` bits in `a`, `b` and the must-flip bits found in Step 1.\\n\\n```java\\n    public int minFlips(int a, int b, int c) {\\n        return Integer.bitCount(c ^= (a | b)) + Integer.bitCount(a & b & c);\\n    }\\n```\\n```python\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        return (c := (a | b) ^ c).bit_count() + (a & b & c).bit_count()\\n```\\n**Analysis:**\\nTime: O(L), space: O(1), where L is the number of bits in an integer.",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```java\\n    public int minFlips(int a, int b, int c) {\\n        int ans = 0, ab = a | b, equal = ab ^ c;\\n        for (int i = 0; i < 31; ++i) {\\n            int mask = 1 << i;\\n            if ((equal & mask) > 0)  // ith bits of a | b and c are not same, need at least 1 flip.\\n             // ans += (ab & mask) < (c & mask) || (a & mask) != (b & mask) ? 1 : 2;\\n                ans += (a & mask) == (b & mask) && (c & mask) == 0 ? 2 : 1; // ith bits of a and b are both 1 and that of c is 0?\\n        }\\n        return ans;\\n    }\\n```\n```python\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        ab, equal, ans = a | b, (a | b) ^ c, 0\\n        for i in range(31):\\n            mask = 1 << i\\n            if equal & mask > 0:\\n              # ans += 1 if (ab & mask) < (c & mask) or (a & mask) != (b & mask) else 2\\n                ans += 2 if (a & mask) == (b & mask) and (c & mask) == 0 else 1\\n        return ans\\n```\n```java\\n    public int minFlips(int a, int b, int c) {\\n        return Integer.bitCount(c ^= (a | b)) + Integer.bitCount(a & b & c);\\n    }\\n```\n```python\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        return (c := (a | b) ^ c).bit_count() + (a & b & c).bit_count()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3606668,
                "title": "python-java-c-simple-solution-easy-to-understand",
                "content": "# !! BIG ANNOUNCEMENT !!\\nI am currently Giving away my premium content well-structured assignments and study materials to clear interviews at top companies related to computer science and data science to my current Subscribers. This is only for the first 10,000 Subscribers. **DON\\'T FORGET** to Subscribe.\\n\\n# Search \\uD83D\\uDC49 `Tech Wired Leetcode` to Subscribe\\n\\n# Video Solution\\n\\n# Search \\uD83D\\uDC49 `Minimum Flips to Make a OR b Equal to c By Tech Wired` \\n\\n# or\\n\\n# Click the Link in my Profile\\n\\nHappy Learning, Cheers Guys \\uD83D\\uDE0A\\n\\n```Python []\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        flips = 0\\n        while a > 0 or b > 0 or c > 0:\\n            bit_a = a & 1\\n            bit_b = b & 1\\n            bit_c = c & 1\\n\\n            if bit_c == 0:\\n                flips += (bit_a + bit_b)  \\n            else:\\n                if bit_a == 0 and bit_b == 0:\\n                    flips += 1  \\n\\n            a >>= 1\\n            b >>= 1\\n            c >>= 1\\n\\n        return flips\\n\\n```\\n```Java []\\nclass Solution {\\n    public int minFlips(int a, int b, int c) {\\n        int flips = 0;\\n        while (a > 0 || b > 0 || c > 0) {\\n            int bitA = a & 1;\\n            int bitB = b & 1;\\n            int bitC = c & 1;\\n\\n            if (bitC == 0) {\\n                flips += (bitA + bitB); \\n            } else {\\n                if (bitA == 0 && bitB == 0) {\\n                    flips += 1; \\n                }\\n            }\\n\\n            a >>= 1;\\n            b >>= 1;\\n            c >>= 1;\\n        }\\n\\n        return flips;\\n    }\\n}\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int flips = 0;\\n        while (a > 0 || b > 0 || c > 0) {\\n            int bitA = a & 1;\\n            int bitB = b & 1;\\n            int bitC = c & 1;\\n\\n            if (bitC == 0) {\\n                flips += (bitA + bitB); \\n            } else {\\n                if (bitA == 0 && bitB == 0) {\\n                    flips += 1; \\n                }\\n            }\\n\\n            a >>= 1;\\n            b >>= 1;\\n            c >>= 1;\\n        }\\n\\n        return flips;\\n    }\\n};\\n\\n```\\n# An Upvote will be encouraging \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```Python []\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        flips = 0\\n        while a > 0 or b > 0 or c > 0:\\n            bit_a = a & 1\\n            bit_b = b & 1\\n            bit_c = c & 1\\n\\n            if bit_c == 0:\\n                flips += (bit_a + bit_b)  \\n            else:\\n                if bit_a == 0 and bit_b == 0:\\n                    flips += 1  \\n\\n            a >>= 1\\n            b >>= 1\\n            c >>= 1\\n\\n        return flips\\n\\n```\n```Java []\\nclass Solution {\\n    public int minFlips(int a, int b, int c) {\\n        int flips = 0;\\n        while (a > 0 || b > 0 || c > 0) {\\n            int bitA = a & 1;\\n            int bitB = b & 1;\\n            int bitC = c & 1;\\n\\n            if (bitC == 0) {\\n                flips += (bitA + bitB); \\n            } else {\\n                if (bitA == 0 && bitB == 0) {\\n                    flips += 1; \\n                }\\n            }\\n\\n            a >>= 1;\\n            b >>= 1;\\n            c >>= 1;\\n        }\\n\\n        return flips;\\n    }\\n}\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int flips = 0;\\n        while (a > 0 || b > 0 || c > 0) {\\n            int bitA = a & 1;\\n            int bitB = b & 1;\\n            int bitC = c & 1;\\n\\n            if (bitC == 0) {\\n                flips += (bitA + bitB); \\n            } else {\\n                if (bitA == 0 && bitB == 0) {\\n                    flips += 1; \\n                }\\n            }\\n\\n            a >>= 1;\\n            b >>= 1;\\n            c >>= 1;\\n        }\\n\\n        return flips;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606667,
                "title": "c-java-python-solution-beats-100-0ms-run-time",
                "content": "- Linkedin Profile (https://linkedin.com/in/ayush-kumar-a276a124a)\\n//-------------> \\uD83D\\uDC7B Pls Upvote if it is helpful for You \\uD83D\\uDC7B <-----------------//\\n\\n# Complexity\\n- Space complexity: ---> O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# C++ Code\\n```class Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int ans=0;\\n        while(a||b||c){\\n            int x1=a&1;\\n            int x2=b&1;\\n            int x3=c&1;\\n            if((x1|x2)!=x3){\\n                if(x1&x2)   ans+=2;\\n                else ans+=1;\\n            }\\n            a=a>>1;\\n            b=b>>1;\\n            c=c>>1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Python Code\\n```class Solution:\\n    def minFlips(self, a, b, c):\\n        ans = 0\\n        while a or b or c:\\n            x1 = a & 1\\n            x2 = b & 1\\n            x3 = c & 1\\n            if (x1 | x2) != x3:\\n                if x1 & x2:\\n                    ans += 2\\n                else:\\n                    ans += 1\\n            a = a >> 1\\n            b = b >> 1\\n            c = c >> 1\\n        return ans\\n\\n```\\n# Java Code \\n```\\nclass Solution {\\n    public int minFlips(int a, int b, int c) {\\n        int ans = 0;\\n        while (a != 0 || b != 0 || c != 0) {\\n            int x1 = a & 1;\\n            int x2 = b & 1;\\n            int x3 = c & 1;\\n            if ((x1 | x2) != x3) {\\n                if ((x1 & x2) == 1)\\n                    ans += 2;\\n                else\\n                    ans += 1;\\n            }\\n            a = a >> 1;\\n            b = b >> 1;\\n            c = c >> 1;\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n\\uD83D\\uDC7B IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION\\uD83D\\uDC7B*\\n\\n![image.png](https://assets.leetcode.com/users/images/808ce812-ef58-4889-9d68-6c3a66620ff1_1686095947.3712385.png)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```class Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int ans=0;\\n        while(a||b||c){\\n            int x1=a&1;\\n            int x2=b&1;\\n            int x3=c&1;\\n            if((x1|x2)!=x3){\\n                if(x1&x2)   ans+=2;\\n                else ans+=1;\\n            }\\n            a=a>>1;\\n            b=b>>1;\\n            c=c>>1;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```class Solution:\\n    def minFlips(self, a, b, c):\\n        ans = 0\\n        while a or b or c:\\n            x1 = a & 1\\n            x2 = b & 1\\n            x3 = c & 1\\n            if (x1 | x2) != x3:\\n                if x1 & x2:\\n                    ans += 2\\n                else:\\n                    ans += 1\\n            a = a >> 1\\n            b = b >> 1\\n            c = c >> 1\\n        return ans\\n\\n```\n```\\nclass Solution {\\n    public int minFlips(int a, int b, int c) {\\n        int ans = 0;\\n        while (a != 0 || b != 0 || c != 0) {\\n            int x1 = a & 1;\\n            int x2 = b & 1;\\n            int x3 = c & 1;\\n            if ((x1 | x2) != x3) {\\n                if ((x1 & x2) == 1)\\n                    ans += 2;\\n                else\\n                    ans += 1;\\n            }\\n            a = a >> 1;\\n            b = b >> 1;\\n            c = c >> 1;\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607404,
                "title": "c-easy-bit",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int ans=0;\\n        for(long i=0;i<=30;i++){\\n            long d1=a&1;\\n            long d2=b&1;\\n            long d3=c&1;\\n            if(d3==0) {\\n                ans += d1+d2;\\n            }\\n            else {\\n                if(d1==0 && d2==0)ans++;\\n            }\\n            a/=2;\\n            b/=2;\\n            c/=2;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/e6b75a65-a511-4672-bc71-2a29908cc1b5_1686114003.6189425.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int ans=0;\\n        for(long i=0;i<=30;i++){\\n            long d1=a&1;\\n            long d2=b&1;\\n            long d3=c&1;\\n            if(d3==0) {\\n                ans += d1+d2;\\n            }\\n            else {\\n                if(d1==0 && d2==0)ans++;\\n            }\\n            a/=2;\\n            b/=2;\\n            c/=2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477662,
                "title": "java-o-1-time-o-1-space",
                "content": "```\\nclass Solution {\\n    public int minFlips(int a, int b, int c) {\\n        int count = 0;\\n        for(int i = 1; i <= 32; i++) {\\n            int b1 = 0, b2 = 0, b3 = 0;\\n            if(((a >> (i - 1)) & 1) >= 1) b1 = 1; // check the ith bit of a\\n            if(((b >> (i - 1)) & 1) >= 1) b2 = 1; // check the ith bit of b\\n            if(((c >> (i - 1)) & 1) >= 1) b3 = 1; // check the ith bit of c\\n            if(b3 == 0 && (b1 == 1 || b2 == 1)) count += b1 + b2; // if the ith bit of c is 0 and any of the ith bits of a or b is 1\\n            else if(b3 == 1 && b1 == 0 && b2 == 0) count++; // if the ith bit of c is 1, check the ith bits of a and b\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minFlips(int a, int b, int c) {\\n        int count = 0;\\n        for(int i = 1; i <= 32; i++) {\\n            int b1 = 0, b2 = 0, b3 = 0;\\n            if(((a >> (i - 1)) & 1) >= 1) b1 = 1; // check the ith bit of a\\n            if(((b >> (i - 1)) & 1) >= 1) b2 = 1; // check the ith bit of b\\n            if(((c >> (i - 1)) & 1) >= 1) b3 = 1; // check the ith bit of c\\n            if(b3 == 0 && (b1 == 1 || b2 == 1)) count += b1 + b2; // if the ith bit of c is 0 and any of the ith bits of a or b is 1\\n            else if(b3 == 1 && b1 == 0 && b2 == 0) count++; // if the ith bit of c is 1, check the ith bits of a and b\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 478571,
                "title": "c-python-simple-bit-manipulation",
                "content": "#### Python\\n```\\n\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        count=0\\n        while(a or b or c):\\n            bit_a,bit_b,bit_c=a&1,b&1,c&1\\n            if (bit_a|bit_b)!=bit_c:\\n                if bit_a==1 and bit_b==1:\\n                    count=count+2\\n                else:\\n                    count=count+1\\n            a=a>>1\\n            b=b>>1\\n            c=c>>1\\n        return count\\n```\\n\\n### C++\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n      int mask=1;\\n      int count=0;\\n      int bit_a,bit_b,bit_c;\\n      while (a||b||c){\\n        bit_a=a&1;\\n        bit_b=b&1;\\n        bit_c=c&1;\\n        if ((bit_a|bit_b)!=bit_c){\\n          if (bit_a & bit_b){\\n            count=count+2;\\n          }\\n          else{\\n            ++count;\\n          }\\n        }\\n        a=a>>1;\\n        b=b>>1;\\n        c=c>>1;\\n      }\\n      return count;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        count=0\\n        while(a or b or c):\\n            bit_a,bit_b,bit_c=a&1,b&1,c&1\\n            if (bit_a|bit_b)!=bit_c:\\n                if bit_a==1 and bit_b==1:\\n                    count=count+2\\n                else:\\n                    count=count+1\\n            a=a>>1\\n            b=b>>1\\n            c=c>>1\\n        return count\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n      int mask=1;\\n      int count=0;\\n      int bit_a,bit_b,bit_c;\\n      while (a||b||c){\\n        bit_a=a&1;\\n        bit_b=b&1;\\n        bit_c=c&1;\\n        if ((bit_a|bit_b)!=bit_c){\\n          if (bit_a & bit_b){\\n            count=count+2;\\n          }\\n          else{\\n            ++count;\\n          }\\n        }\\n        a=a>>1;\\n        b=b>>1;\\n        c=c>>1;\\n      }\\n      return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 488292,
                "title": "the-most-simple-solution-if-you-know-a-few-bitman-tricks",
                "content": "I saw a lot of posts for this question and realized mine was easier to understand and was simple.\\nIntuition:\\n1.  Check every bit of **a and b** and compare it with **c** \\n    Example 1:\\n   ``\\n   0010->a(2)\\n   0110->b(6)\\n   0101->c(5) ``\\n   \\n\\t   Compare **0,0** and **1**(LSBs of the 3 numbers)\\n   **We see that atleast one of the bits of a and b(0 and 0) must be flipped to 1 for the result to be c,so we increment the count value by one**.\\n   \\n   2.   We get the LSB of a number by performing **AND** operation of that number with one.\\n\\t Eg:   3->0011\\n\\t **3 AND 1**  -> 0011 & 0001 which is equal to **1** which means LSB is **one** , similarly result will be zero if LSB is zero.\\n\\t 3. How do we go to the next bit? \\n\\t Use unsigned right shift operator(**>>>**),this operator shifts the bits one to the right.\\n\\n```\\nclass Solution {\\n    public int minFlips(int a, int b, int c) {\\n        if((a|b)==c)\\n            return 0;\\n        \\n        int flips=0;\\n        \\n \\xA0 \\xA0 \\xA0 \\xA0while(c!=0 || a!=0 || b!=0 ) //compare bits of the numbers as long as atleast one of them is nonzero\\n \\xA0 \\xA0 \\xA0 \\xA0{\\n            if((c&1)==1)\\n            {\\n                if((a&1)==0 && (b&1)==0) //if both are zero while c is 1,one flip is needed\\n                    flips+=1;\\n                \\n            }\\n            \\n            else if((c&1)==0)\\n            {\\n                if((a&1)==1 && (b&1)==1) //if both are one while c is zero,we need to change both the bits to zero to get the result .So,this requires 2 flips.\\n                    flips+=2;\\n                \\n                else if((a&1)==1 || (b&1)==1) //if one of the bits is one while c is zero,we need to flip it once.\\n                    flips+=1;\\n                \\n            }\\n            a>>>=1; //moving through the bits\\n            b>>>=1;\\n            c>>>=1;\\n        }\\n       return flips;\\n    }\\n    \\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minFlips(int a, int b, int c) {\\n        if((a|b)==c)\\n            return 0;\\n        \\n        int flips=0;\\n        \\n \\xA0 \\xA0 \\xA0 \\xA0while(c!=0 || a!=0 || b!=0 ) //compare bits of the numbers as long as atleast one of them is nonzero\\n \\xA0 \\xA0 \\xA0 \\xA0{\\n            if((c&1)==1)\\n            {\\n                if((a&1)==0 && (b&1)==0) //if both are zero while c is 1,one flip is needed\\n                    flips+=1;\\n                \\n            }\\n            \\n            else if((c&1)==0)\\n            {\\n                if((a&1)==1 && (b&1)==1) //if both are one while c is zero,we need to change both the bits to zero to get the result .So,this requires 2 flips.\\n                    flips+=2;\\n                \\n                else if((a&1)==1 || (b&1)==1) //if one of the bits is one while c is zero,we need to flip it once.\\n                    flips+=1;\\n                \\n            }\\n            a>>>=1; //moving through the bits\\n            b>>>=1;\\n            c>>>=1;\\n        }\\n       return flips;\\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607332,
                "title": "easy-c-solution-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(32) ~O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(128) ~ O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void decToBinary(int n,int binaryNum[])\\n{\\n    int i = 0;\\n    while (n > 0) {\\n        binaryNum[i] = n % 2;\\n        n = n / 2;\\n        i++;\\n    }\\n}\\n\\n    int minFlips(int a, int b, int c) {\\n        int x[32]={0};\\n        int y[32]={0};\\n        int z[32]={0};\\n        decToBinary(a,x);\\n        decToBinary(b,y);\\n        decToBinary(c,z);\\n\\n        int i,j,k,s=0,m=0;\\n        for(i=0;i<32;i++){\\n            int a_or_b=x[i]|y[i];\\n            if(a_or_b !=z[i]){\\n                if(a_or_b==1 and z[i]==0){\\n                    if(x[i]==1 and y[i]==1)\\n                    s+=2;\\n                    else\\n                    s++;\\n                }\\n                else{\\n                    s++;\\n                }\\n            }\\n        }\\n\\n\\n        return s;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void decToBinary(int n,int binaryNum[])\\n{\\n    int i = 0;\\n    while (n > 0) {\\n        binaryNum[i] = n % 2;\\n        n = n / 2;\\n        i++;\\n    }\\n}\\n\\n    int minFlips(int a, int b, int c) {\\n        int x[32]={0};\\n        int y[32]={0};\\n        int z[32]={0};\\n        decToBinary(a,x);\\n        decToBinary(b,y);\\n        decToBinary(c,z);\\n\\n        int i,j,k,s=0,m=0;\\n        for(i=0;i<32;i++){\\n            int a_or_b=x[i]|y[i];\\n            if(a_or_b !=z[i]){\\n                if(a_or_b==1 and z[i]==0){\\n                    if(x[i]==1 and y[i]==1)\\n                    s+=2;\\n                    else\\n                    s++;\\n                }\\n                else{\\n                    s++;\\n                }\\n            }\\n        }\\n\\n\\n        return s;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606850,
                "title": "clear-and-intuitive-explanation-of-bit-manipulation-python",
                "content": "# Intuition\\nConsider the i\\'th bit of `c`. There are two cases:\\n\\na) The `i`\\'th bit is equal to 0\\nThis means the `i`\\'th bit in `a` and `b` must both be 0. We need to flip any of the 1-bits to 0.\\n\\nb) The `i`\\'th bit is equal to 1\\nThis means either the `i`\\'th bit in `a` or the `i`\\'th bit in `b` must be 1. If neither are 1, we must flip at least one bit.\\n\\n# Approach\\nIterate through each bit from 0 to 30 (as the problem states `a,b,c <= 10^9` and `10^9 < 2^30`) in numbers a, b and c. We then inspect the bit in c and consider each of the two cases listed above.\\n\\n# Complexity\\n- Time complexity: O(1). Although we are iterating from 0 to 30, the number of iterations is constant (31 in this case), so the time complexity is O(1).\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        flips = 0\\n        for i in range(31):\\n            # i\\'th bit of c is 1\\n            if (c >> i) & 1:\\n                flips += ((a >> i) & 1) == 0 and ((b >> i) & 1) == 0\\n            # i\\'th bit of c is 0\\n            else:\\n                flips += (a >> i) & 1\\n                flips += (b >> i) & 1\\n        return flips\\n```\\n\\n# Get Faster Interview Prep Results with Top Algos\\nWe all know how time-consuming it is to prepare for interviews and how frustratingly difficult it is to improve. We made **Top Algos** - a tool recommends the perfect algorithm problem based on your current skill level to help you improve the fastest in the shortest amount of time. Top Algos is your personalized coach that learns your skill level and finds the best problem you need to solve to improve.\\n\\nThe beta version of the product is available for **free** right now! You can sign up at https://topalgos.xyz/.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        flips = 0\\n        for i in range(31):\\n            # i\\'th bit of c is 1\\n            if (c >> i) & 1:\\n                flips += ((a >> i) & 1) == 0 and ((b >> i) & 1) == 0\\n            # i\\'th bit of c is 0\\n            else:\\n                flips += (a >> i) & 1\\n                flips += (b >> i) & 1\\n        return flips\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606683,
                "title": "rust-one-line-expression",
                "content": "If a bit is 0 in c, and that same bit is 1 in exactly 1 of a or b, then it takes 1 move to flip that bit. We can identify all of these bits with (a ^ b) & !c.\\n\\nIf a bit is 0 in c, and that same bit is 1 in both a and b, then it takes 2 moves to flip the bit in both a and b to be 0. We can identify these bits with (a & b) & !c.\\n\\nIf a bit is 1 in c, and that same bit is 0 in both a and b, then it takes 1 move to flip the bit in either a or b such that that bit is 1 in the OR-ed output. We can idenfity these bits with !(a | b) & c.\\n\\n\\nThis would give us the expression:\\n\\n```        \\n((a ^ b) & !c).count_ones()\\n+ ((a & b) & !c).count_ones() * 2\\n+ (!(a | b) & c).count_ones()\\n```\\n\\nHowever, we can simplify further. Note that `(a^b)` and `(a & b)` have no bits in common. This means that, as long as we\\'re just counting zeros, we can merge these into `(a|b)`, letting us change to:\\n\\n```\\n((a | b) & !c).count_ones()\\n+ ((a & b) & !c).count_ones()\\n+ (!(a | b) & c).count_ones()\\n```\\n\\nBut then we also have both `((a | b) & !c)` and `(!(a | b) & c)`. Thes can be merged as well, into `((a | b) ^ c)`.\\n\\nSo our final answer is one line: `((a | b) ^ c).count_ones() + ((a & b) & !c).count_ones()`.\\n\\n# Complexity\\n- Time complexity: O(1), we perform finitely many bitwise operations.\\n\\n- Space complexity: O(1), no operations needed\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn min_flips(a: i32, b: i32, c: i32) -> i32 {  \\n        (((a | b) ^ c).count_ones()\\n        + ((a & b) & !c).count_ones()) as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```        \\n((a ^ b) & !c).count_ones()\\n+ ((a & b) & !c).count_ones() * 2\\n+ (!(a | b) & c).count_ones()\\n```\n```\\n((a | b) & !c).count_ones()\\n+ ((a & b) & !c).count_ones()\\n+ (!(a | b) & c).count_ones()\\n```\n```\\nimpl Solution {\\n    pub fn min_flips(a: i32, b: i32, c: i32) -> i32 {  \\n        (((a | b) ^ c).count_ones()\\n        + ((a & b) & !c).count_ones()) as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 746026,
                "title": "c-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int ai,bi,ci;\\n        int res=0;\\n        while(a>0 || b>0 || c>0){\\n            ai=a%2;bi=b%2;ci=c%2;\\n            if(ci==1 && ai+bi==0)\\n                res++;\\n            else if(ci==0)\\n                res+=ai+bi;\\n            a/=2;b/=2;c/=2;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int ai,bi,ci;\\n        int res=0;\\n        while(a>0 || b>0 || c>0){\\n            ai=a%2;bi=b%2;ci=c%2;\\n            if(ci==1 && ai+bi==0)\\n                res++;\\n            else if(ci==0)\\n                res+=ai+bi;\\n            a/=2;b/=2;c/=2;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 478364,
                "title": "java-solution-with-explanation-o-1-time-o-1-space-beats-100-time-space",
                "content": "```\\nclass Solution {\\n\\tpublic int minFlips(int a, int b, int c) {\\n\\t\\tint res = 0;\\n        while(a != 0 || b != 0 || c!= 0){\\n            int bitA = a & 1, bitB = b & 1, bitC = c & 1;\\n            if (bitC == 0) res += (bitA + bitB);\\n\\t\\t\\telse if ((bitA | bitB) == 0) res++;\\n            \\n            a >>= 1; b >>= 1; c >>= 1;\\n        }\\n\\t\\treturn res;\\n\\t}\\n}\\n\\n/*\\n * If bitC == 0 => bitA OR bitB == 0 => bitA must be zero and bitB must be zero\\n * c = 0: count a, b != 0\\n * \\n * If bitC == 1 => bitA OR bitB == 1 => bitA must be zero or bitB must be zero\\n * => if (bitA ^ bitB) != 0 => need to flip one of them c = 1: count a | b = 0\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\tpublic int minFlips(int a, int b, int c) {\\n\\t\\tint res = 0;\\n        while(a != 0 || b != 0 || c!= 0){\\n            int bitA = a & 1, bitB = b & 1, bitC = c & 1;\\n            if (bitC == 0) res += (bitA + bitB);\\n\\t\\t\\telse if ((bitA | bitB) == 0) res++;\\n            \\n            a >>= 1; b >>= 1; c >>= 1;\\n        }\\n\\t\\treturn res;\\n\\t}\\n}\\n\\n/*\\n * If bitC == 0 => bitA OR bitB == 0 => bitA must be zero and bitB must be zero\\n * c = 0: count a, b != 0\\n * \\n * If bitC == 1 => bitA OR bitB == 1 => bitA must be zero or bitB must be zero\\n * => if (bitA ^ bitB) != 0 => need to flip one of them c = 1: count a | b = 0\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 3609096,
                "title": "c-faster-than-100-with-explanatory-comments",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n       int ans=0;\\n       while( a || b || c)  //it process untill all digits become zero\\n       {\\n           //extracting all LSBs of a , b and c\\n           //we can extract LSB by performing \\'&\\' operation to 1\\n\\n            int x1 = a & 1;\\n            int x2 = b & 1;\\n            int x3 = c & 1;\\n            \\n            if( (x1 | x2) != x3)  //if this true then we have to flip the digits according to question\\n            {\\n               if(x1&x2) ans += 2;   //if both are 1 then we have to flip 2 times\\n               else      ans += 1;   //else only 1 times\\n            }\\n\\n            //shift to right by 1 position to perform operation in next digits \\n            a = a>>1;       \\n            b = b>>1;\\n            c = c>>1; \\n       } \\n       return ans;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(log(max(a, b, c)))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n       int ans=0;\\n       while( a || b || c)  //it process untill all digits become zero\\n       {\\n           //extracting all LSBs of a , b and c\\n           //we can extract LSB by performing \\'&\\' operation to 1\\n\\n            int x1 = a & 1;\\n            int x2 = b & 1;\\n            int x3 = c & 1;\\n            \\n            if( (x1 | x2) != x3)  //if this true then we have to flip the digits according to question\\n            {\\n               if(x1&x2) ans += 2;   //if both are 1 then we have to flip 2 times\\n               else      ans += 1;   //else only 1 times\\n            }\\n\\n            //shift to right by 1 position to perform operation in next digits \\n            a = a>>1;       \\n            b = b>>1;\\n            c = c>>1; \\n       } \\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607966,
                "title": "python-3-9-lines-divmod-t-m-96-96",
                "content": "```\\n    class Solution:\\n        def minFlips(self, a: int, b: int, c: int) -> int:\\n        \\n            ans = 0\\n\\n            while not a == b == c == 0:\\n                a, A = divmod(a,2)\\n                b, B = divmod(b,2)\\n                c, C = divmod(c,2)\\n\\n                if   A == B == 1 and C == 0 : ans+= 2\\n                elif A == B == 0 and C == 1 : ans+= 1\\n                elif A != B      and C == 0 : ans+= 1\\n                \\n            return ans\\n```\\n[https://leetcode.com/problems/minimum-flips-to-make-a-or-b-equal-to-c/submissions/692614360/](http://)\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1), in which *N* ~`max(a,b,c)\\n`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    class Solution:\\n        def minFlips(self, a: int, b: int, c: int) -> int:\\n        \\n            ans = 0\\n\\n            while not a == b == c == 0:\\n                a, A = divmod(a,2)\\n                b, B = divmod(b,2)\\n                c, C = divmod(c,2)\\n\\n                if   A == B == 1 and C == 0 : ans+= 2\\n                elif A == B == 0 and C == 1 : ans+= 1\\n                elif A != B      and C == 0 : ans+= 1\\n                \\n            return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606684,
                "title": "explained-simple-and-clear-python3-code",
                "content": "# Intuition\\nThe problem requires finding the minimum number of bit flips in the binary representations of two numbers, \\'a\\' and \\'b\\', such that their bitwise OR is equal to another number \\'c\\'. To solve this problem, we can iterate through the binary representations of \\'a\\', \\'b\\', and \\'c\\' simultaneously and check each bit. If the corresponding bit in \\'c\\' is set to 1, we need to ensure that at least one of the bits in \\'a\\' or \\'b\\' is also set to 1. If the bit in \\'c\\' is 0, we need to ensure that both bits in \\'a\\' and \\'b\\' are set to 0.\\n\\n\\n# Approach\\n1.\\tConvert \\'a\\', \\'b\\', and \\'c\\' to their binary representations using the \\'format\\' function.\\n2.\\tDetermine the maximum length among the binary representations of \\'a\\', \\'b\\', and \\'c\\'.\\n3.\\tPad the shorter binary representations with leading zeros to ensure all three have the same length.\\n4.\\tInitialize a variable \\'res\\' to keep track of the minimum number of flips required.\\n5.\\tIterate through each bit position from left to right.\\n\\u2022\\tIf the bit in \\'c\\' is 1 and both bits in \\'a\\' and \\'b\\' are 0, increment \\'res\\' by 1.\\n\\u2022\\tIf the bit in \\'c\\' is 0 and either bit in \\'a\\' or \\'b\\' is 1, increment \\'res\\' by 1 for each set bit.\\n6.\\tReturn the final value of \\'res\\', which represents the minimum number of flips required to achieve (a OR b == c).\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this approach is O(log(max(a, b, c))), as we need to iterate through the binary representations of \\'a\\', \\'b\\', and \\'c\\'.\\n\\n\\n- Space complexity:\\nThe space complexity is O(log(max(a, b, c))), as we need to store the binary representations of \\'a\\', \\'b\\', and \\'c\\' in separate variables.\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        abin=format(a,\\'b\\')\\n        bbin=format(b,\\'b\\')\\n        cbin=format(c,\\'b\\')\\n        x = max(max(len(abin),len(bbin)),len(cbin))\\n        for i in range(x-len(abin)):\\n            abin=\"0\"+abin\\n        for i in range(x-len(bbin)):\\n            bbin=\"0\"+bbin\\n        for i in range(x-len(cbin)):\\n            cbin=\"0\"+cbin\\n        res=0\\n        for i in range(x):\\n            if cbin[i]==\\'1\\':\\n                if abin[i]==\\'0\\' and bbin[i]==\\'0\\':\\n                    res+=1\\n            else:\\n                if abin[i]==\\'1\\' :\\n                    res+=1\\n                if bbin[i]==\\'1\\' :\\n                    res+=1\\n        return res\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        abin=format(a,\\'b\\')\\n        bbin=format(b,\\'b\\')\\n        cbin=format(c,\\'b\\')\\n        x = max(max(len(abin),len(bbin)),len(cbin))\\n        for i in range(x-len(abin)):\\n            abin=\"0\"+abin\\n        for i in range(x-len(bbin)):\\n            bbin=\"0\"+bbin\\n        for i in range(x-len(cbin)):\\n            cbin=\"0\"+cbin\\n        res=0\\n        for i in range(x):\\n            if cbin[i]==\\'1\\':\\n                if abin[i]==\\'0\\' and bbin[i]==\\'0\\':\\n                    res+=1\\n            else:\\n                if abin[i]==\\'1\\' :\\n                    res+=1\\n                if bbin[i]==\\'1\\' :\\n                    res+=1\\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608469,
                "title": "simple-beginner-friendly-c-solution-with-intuition-and-explanation-easy-to-understand",
                "content": "# Intuition\\nIn this problem, we need to find the minimum number of bit flips required to convert the result of \\'a OR b\\' to \\'c\\'. We can use bit manipulation to solve this problem.\\n\\n# Approach\\n- Inside the loop, we extract the least significant bit of a, b, and c using the bitwise AND operation with 1 (bitA = a & 1, bitB = b & 1, bitC = c & 1).\\n- We then check if the bitwise OR of bitA and bitB is not equal to bitC. If this condition is true, it means a bit flip is required to make a | b equal to c.\\n- Depending on the values of bitA, bitB, and bitC, the function increments the result variable accordingly. If both bitA and bitB are 1, it means two bit flips are required, so result is incremented by 2. Otherwise, only one bit flip is required, so result is incremented by 1.\\n- After processing the least significant bit, we right-shift a, b, and c by 1 bit to move to the next least significant bit.\\n\\n\\n\\n# Complexity\\n- Time complexity:O(log(max(a, b, c)))\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nUPVOTE. Glad to help.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int result=0;\\n        while(a or b or c){\\n            int bitA=a & 1;\\n            int bitB=b & 1;\\n            int bitC=c & 1;\\n            if((bitA | bitB )!= bitC){\\n                if(bitA & bitB) result+=2;\\n                else result++;\\n            }\\n            a>>=1;\\n            b>>=1;\\n            c>>=1;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int result=0;\\n        while(a or b or c){\\n            int bitA=a & 1;\\n            int bitB=b & 1;\\n            int bitC=c & 1;\\n            if((bitA | bitB )!= bitC){\\n                if(bitA & bitB) result+=2;\\n                else result++;\\n            }\\n            a>>=1;\\n            b>>=1;\\n            c>>=1;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606796,
                "title": "100-beats-most-optimized-c",
                "content": "if(c&1 == 1) than \\n    :- check (a&)&&(b&1)==0 tha there is need for change c&1\\nelse c&1 == 0 than\\n    :- increment ans By a&1 + b&1\\ndivide a,b,c by 2 untill all are not 0.\\n\\n# Complexity\\n- Time complexity:\\nO(32)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int minFlips(int a, int b, int c)\\n    {\\n        int d = 0;\\n        while (a || b || c)\\n        {\\n            if (c & 1)\\n            {\\n                if ((a & 1) == 0 && (b & 1) == 0)\\n                {\\n                    d++;\\n                }\\n            }\\n            else\\n            {\\n                if (a & 1)\\n                    d++;\\n                if (b & 1)\\n                    d++;\\n            }\\n        a >>= 1, b >>= 1, c >>= 1;\\n        }\\n    return d;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int minFlips(int a, int b, int c)\\n    {\\n        int d = 0;\\n        while (a || b || c)\\n        {\\n            if (c & 1)\\n            {\\n                if ((a & 1) == 0 && (b & 1) == 0)\\n                {\\n                    d++;\\n                }\\n            }\\n            else\\n            {\\n                if (a & 1)\\n                    d++;\\n                if (b & 1)\\n                    d++;\\n            }\\n        a >>= 1, b >>= 1, c >>= 1;\\n        }\\n    return d;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477683,
                "title": "java-bit",
                "content": "```\\nclass Solution {\\n    public int minFlips(int a, int b, int c) {\\n        int res = 0;\\n        while (a != 0 || b != 0 || c != 0) {\\n            int t = a & 1;\\n            int m = b & 1;\\n            int n = c & 1;\\n            if ((t | m) != n) {\\n                if (n == 0) {\\n                    if (t == 1) {\\n                        res++;\\n                    }\\n                    if (m == 1) {\\n                        res++;\\n                    }\\n                } else {\\n                    res++;\\n                }\\n            }\\n            a = a >> 1;\\n            b = b >> 1;\\n            c = c >> 1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minFlips(int a, int b, int c) {\\n        int res = 0;\\n        while (a != 0 || b != 0 || c != 0) {\\n            int t = a & 1;\\n            int m = b & 1;\\n            int n = c & 1;\\n            if ((t | m) != n) {\\n                if (n == 0) {\\n                    if (t == 1) {\\n                        res++;\\n                    }\\n                    if (m == 1) {\\n                        res++;\\n                    }\\n                } else {\\n                    res++;\\n                }\\n            }\\n            a = a >> 1;\\n            b = b >> 1;\\n            c = c >> 1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 489623,
                "title": "python-simple-solution-python-memory-usage-less-than-100",
                "content": "```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:   \\n        count = 0\\n        while a or b or c:\\n            if (a & 1) | (b & 1) != (c & 1):\\n                if (c & 1): count += 1\\n                else: count += (a & 1) + (b & 1)\\n            a, b, c = a >> 1, b >> 1, c >> 1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:   \\n        count = 0\\n        while a or b or c:\\n            if (a & 1) | (b & 1) != (c & 1):\\n                if (c & 1): count += 1\\n                else: count += (a & 1) + (b & 1)\\n            a, b, c = a >> 1, b >> 1, c >> 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607777,
                "title": "easy-python3-solution-includes-explanation-and-comments-bit-manipulation-beats-over-90",
                "content": "# Approach\\nFor each bit in c, do:\\n- If bit is 0, then make sure the corresponding bits in a and b are also 0. If bit is 1 in either or both of a and b, increase flip count by 1 or 2 respectively.\\n- If bit is 1, then either of a or b should have the corresponding bit as 1. If neither have, then increase flip count by 1.\\n\\n# Complexity\\n- Time complexity: O(No. of bits)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        n = ceil(log2(max(a,b,c)))+1\\n        flip = 0\\n        for i in range(n):\\n            mask = 1<<i\\n            if c&mask:      #at a position, if c has a 1, then either b or a should have a 1, else flip one bit.\\n                if not (a&mask | b&mask):\\n                    flip+=1\\n            else:           #if c has 0, then both need to be 0. If not, then flip those bits.\\n                if a&mask:\\n                    flip+=1\\n                if b&mask:\\n                    flip+=1\\n        return flip\\n```\\n# If this was helpful, might as well drop a like :D",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        n = ceil(log2(max(a,b,c)))+1\\n        flip = 0\\n        for i in range(n):\\n            mask = 1<<i\\n            if c&mask:      #at a position, if c has a 1, then either b or a should have a 1, else flip one bit.\\n                if not (a&mask | b&mask):\\n                    flip+=1\\n            else:           #if c has 0, then both need to be 0. If not, then flip those bits.\\n                if a&mask:\\n                    flip+=1\\n                if b&mask:\\n                    flip+=1\\n        return flip\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606977,
                "title": "optimized-solution-daily-leetcode-challenge",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int flips = 0; // Counter to track the number of flips required\\n        for (int i = 0; i < 32; i++) {\\n            // Extract the i-th bit of a, b, and c\\n            int bitA = (a >> i) & 1;\\n            int bitB = (b >> i) & 1;\\n            int bitC = (c >> i) & 1;\\n            \\n            // Check if the i-th bit of (a OR b) is equal to the i-th bit of c\\n            if ((bitA | bitB) != bitC) {\\n                if (bitC == 1) {\\n                    flips++; // Flip required to make the i-th bit of (a OR b) equal to 1\\n                } else {\\n                    flips += (bitA == 1) + (bitB == 1); // Flips required to make both bits of a and b equal to 0\\n                }\\n            }\\n        }\\n        return flips;\\n    }\\n};\\n```\\n\\n**PLEASE UPVOTE :)**",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int flips = 0; // Counter to track the number of flips required\\n        for (int i = 0; i < 32; i++) {\\n            // Extract the i-th bit of a, b, and c\\n            int bitA = (a >> i) & 1;\\n            int bitB = (b >> i) & 1;\\n            int bitC = (c >> i) & 1;\\n            \\n            // Check if the i-th bit of (a OR b) is equal to the i-th bit of c\\n            if ((bitA | bitB) != bitC) {\\n                if (bitC == 1) {\\n                    flips++; // Flip required to make the i-th bit of (a OR b) equal to 1\\n                } else {\\n                    flips += (bitA == 1) + (bitB == 1); // Flips required to make both bits of a and b equal to 0\\n                }\\n            }\\n        }\\n        return flips;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606670,
                "title": "java-bit-manipulation-10-lines",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$ where `n` is the number of bits\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int minFlips(int a, int b, int c) {\\n    var cnt = 0;\\n\\n    while (a>0 || b>0 || c>0) {\\n      if ((c & 1) == 0) {\\n        if ((a & 1) == 1) cnt++;\\n        if ((b & 1) == 1) cnt++;\\n      } else if ((a & 1) == 0 && (b & 1) == 0) cnt++;\\n\\n      a >>= 1;\\n      b >>= 1;\\n      c >>= 1;\\n    }\\n    return cnt;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n  public int minFlips(int a, int b, int c) {\\n    var cnt = 0;\\n\\n    while (a>0 || b>0 || c>0) {\\n      if ((c & 1) == 0) {\\n        if ((a & 1) == 1) cnt++;\\n        if ((b & 1) == 1) cnt++;\\n      } else if ((a & 1) == 0 && (b & 1) == 0) cnt++;\\n\\n      a >>= 1;\\n      b >>= 1;\\n      c >>= 1;\\n    }\\n    return cnt;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 822979,
                "title": "c-simple-explained-solution-0-ms-faster-than-100",
                "content": "**Like it? please upvote...**\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int count = 0;\\n        while (a | b != c)\\n        {\\n            // get left bits of each number\\n            int aa = a & 0x1;\\n            int bb = b & 0x1;\\n            int cc = c & 0x1;\\n            if (cc == 0) // if left bit of c is zero - both a and b have to be zero\\n            {\\n                if (aa == 1) {count++; a--;}\\n                if (bb == 1) {count++; b--;}\\n            }\\n            else // if left bit of c is one, either a or b have to be one\\n                if ((aa == 0) && (bb == 0)) {count++; a += 1;}\\n            a = a>>1;\\n            b = b>>1;\\n            c = c>>1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int count = 0;\\n        while (a | b != c)\\n        {\\n            // get left bits of each number\\n            int aa = a & 0x1;\\n            int bb = b & 0x1;\\n            int cc = c & 0x1;\\n            if (cc == 0) // if left bit of c is zero - both a and b have to be zero\\n            {\\n                if (aa == 1) {count++; a--;}\\n                if (bb == 1) {count++; b--;}\\n            }\\n            else // if left bit of c is one, either a or b have to be one\\n                if ((aa == 0) && (bb == 0)) {count++; a += 1;}\\n            a = a>>1;\\n            b = b>>1;\\n            c = c>>1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 479153,
                "title": "javascript-easy-to-understand-bit-manipulation",
                "content": "The main process is traversal each bit of `a | b` and `c` to sum the cost.\\n\\nIf the bit of `a | b` equals to the same bit of `c`, then we don\\'t need to flip it.\\nIf they are not same, we could find the logic of solving from this table easily:\\n\\na | b | c | cost\\n- | - | - | -\\n0 | 0 | 1 | 1\\n1 | 0 | 0 | 1\\n0 | 1 | 0 | 1\\n1 | 1 | 0 | 2\\n\\nSo, here\\'s the code:\\n\\n```js\\nconst minFlips = (a, b, c) => {\\n  let ret = 0;\\n  while (a > 0 || b > 0 || c > 0) {\\n    if (((a & 1) | (b & 1)) !== (c & 1)) {\\n      ret += (a & 1) === 1 && (b & 1) === 1 ? 2 : 1;\\n    }\\n    a >>>= 1;\\n    b >>>= 1;\\n    c >>>= 1;\\n  }\\n  return ret;\\n};\\n```\\n\\nSince the `a`, `b` and `c` are all int, we could set the traversal times and calculate with a mask. The code could be like this:\\n\\n```js\\nconst minFlips = (a, b, c) => {\\n  let ret = 0;\\n  let mask = 1;\\n  for (let i = 1; i < 32; ++i) {\\n    if (((a & mask) | (b & mask)) !== (c & mask)) {\\n      ret += (a & mask) === mask && (b & mask) === mask ? 2 : 1;\\n    }\\n    mask <<= 1;\\n  }\\n  return ret;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst minFlips = (a, b, c) => {\\n  let ret = 0;\\n  while (a > 0 || b > 0 || c > 0) {\\n    if (((a & 1) | (b & 1)) !== (c & 1)) {\\n      ret += (a & 1) === 1 && (b & 1) === 1 ? 2 : 1;\\n    }\\n    a >>>= 1;\\n    b >>>= 1;\\n    c >>>= 1;\\n  }\\n  return ret;\\n};\\n```\n```js\\nconst minFlips = (a, b, c) => {\\n  let ret = 0;\\n  let mask = 1;\\n  for (let i = 1; i < 32; ++i) {\\n    if (((a & mask) | (b & mask)) !== (c & mask)) {\\n      ret += (a & mask) === mask && (b & mask) === mask ? 2 : 1;\\n    }\\n    mask <<= 1;\\n  }\\n  return ret;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3608079,
                "title": "python-elegant-short-one-line-math",
                "content": "# Complexity\\n- Time complexity: $$O(\\\\log_2 {n})$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        return ((a | b) ^ c).bit_count() + (a & b & ((a | b) ^ c)).bit_count()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        return ((a | b) ^ c).bit_count() + (a & b & ((a | b) ^ c)).bit_count()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607913,
                "title": "c-bit-manipulation-mostly-beginner-friendly-tc-o-1-0ms",
                "content": "# Intuition\\n\\nPre-Requisites: **Binary Representation** && **Bit Operations**\\n\\nTo understand the intuition for this problem you need to know the about the binary representations of integers and Bit operations that can be performed on them.\\nWe need to compare the OR of individual bits `a` and `b` with the corresponding bits of `c`. \\nFor the $$i^{th}$$ bit,\\nif $$c_i==0$$ then $$a_i$$ and $$b_i$$ should both be zero, if not, we have to flip the bits that are `1`(set).\\nif $$c_i==1$$ then either $$a_i$$ or $$b_i$$ should be `1`(set), if both are `0`(unset), we have to flip only one of the two bits.\\n\\n# Approach\\n1. Find the LSB of `a`, `b`, and `c`. (least significant bit). (using $$num \\\\space & \\\\space 1$$).\\n2. If LSBc is 1, and neither LSBa or LSBb are 1, then increment number of flips by 1.\\n3. If LSBc is 0, then add LSBa and LSBb value to number of flips. (We do this because if LSBa is 1, then we need to flip that, and same for LSBb. So if both are 1, then we need to flip both and we add `1+1` to number of flips)\\n4. Right shift `a`, `b`, and `c` by `1` bit, so that we can perform the same checks for the next bits.\\n5. Repeat steps 1 to 4, while either of `a`, `b`, or `c` are greater than `0`.\\n\\n# Code\\n```cpp []\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int res{0};\\n        while(a || b || c) {\\n            if ((c&1) == 1)\\n                res += ((a&1)==0)&&((b&1)==0);\\n            else\\n                res += (a&1) + (b&1);\\n            a>>=1; b>>=1; c>>=1;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity: $$O(32) \\\\approx O(1)$$\\nSince the number is 32-bit, and in worst case we check all bits, the time it\\'ll take is $$O(32)$$, which is basically constant.\\n\\n- Space complexity: $$O(1)$$\\nNot using any kind of extra space anywhere.\\n\\n> ### Note\\n> - Upvote if you liked my solution\\n> - Drop a comment if you have any doubt",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```cpp []\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int res{0};\\n        while(a || b || c) {\\n            if ((c&1) == 1)\\n                res += ((a&1)==0)&&((b&1)==0);\\n            else\\n                res += (a&1) + (b&1);\\n            a>>=1; b>>=1; c>>=1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606950,
                "title": "c-0-ms-100-beat-solution-with-explanation-no-xor-inbuilt-used",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst what I did was convert the numbers into binary string form using the function binary.\\nAfter that I checked bit by bit from the last of the binary string numbers to check if a flip is needed or not.\\n## **Flips are needed on this basis :**\\n1. if z\\'s bit is 0, then flip is needed for the bits in x and y if they are 1\\n2. if z\\'s bit is 1, the only 1 flip is needed if both x and y bits are 0\\n3. if z length is over, then treat it as z bit = 0 and goto step 1\\n4. if x and y length over, and z length is remaining, then for each z\\'s bit = 1 encountered, 1 flip is needed\\n\\nUsing this minimum flips required are calculated.\\n\\n# Complexity\\n- Time complexity: O(log(max(a,b,c)))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string binary(int num){\\n        int temp = 1;\\n        while(temp<=num){\\n            temp*=2;\\n        }\\n        temp/=2;\\n        string ans = \"\";\\n        while(temp>=1){\\n            if(temp<=num){\\n                num -= temp;\\n                ans += \"1\";\\n            }\\n            else{\\n                ans += \"0\";\\n            }\\n            temp/=2;\\n        }\\n        return ans;\\n    }\\n\\n    int minFlips(int a, int b, int c) {\\n        string x = binary(a);\\n        string y = binary(b);\\n        string z = binary(c);\\n        //cout << x << \" \" << y << \" \" << z;\\n\\n        int ans=0;\\n        int u=x.length()-1,v=y.length()-1,w=z.length()-1;\\n        while(u>=0 && v>=0){\\n            if(w<0){\\n                if(x[u]==\\'1\\') ans++;\\n                if(y[v]==\\'1\\') ans++;\\n                u--; v--; continue;\\n            }\\n            else if(z[w]==\\'1\\'){\\n                if(x[u]==\\'0\\' && y[v]==\\'0\\') ans++;\\n            }\\n            else if(z[w]==\\'0\\'){\\n                if(x[u]==\\'1\\') ans++;\\n                if(y[v]==\\'1\\') ans++;\\n            }\\n            u--;\\n            v--;\\n            w--;\\n        }\\n        while(u>=0){\\n            if(w<0){\\n                if(x[u]==\\'1\\') ans++;\\n                u--; continue;\\n            }\\n            else if(z[w]==\\'1\\' && x[u]==\\'0\\') ans++;\\n            else if(z[w]==\\'0\\' && x[u]==\\'1\\') ans++;\\n            u--;\\n            w--;\\n        }\\n        while(v>=0){\\n            if(w<0){\\n                if(y[v]==\\'1\\') ans++;\\n                v--; continue;\\n            }\\n            else if(z[w]==\\'1\\' && y[v]==\\'0\\') ans++;\\n            else if(z[w]==\\'0\\' && y[v]==\\'1\\') ans++;\\n            v--;\\n            w--;\\n        }\\n        while(w>=0){\\n            if(z[w]==\\'1\\') ans++;\\n            w--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string binary(int num){\\n        int temp = 1;\\n        while(temp<=num){\\n            temp*=2;\\n        }\\n        temp/=2;\\n        string ans = \"\";\\n        while(temp>=1){\\n            if(temp<=num){\\n                num -= temp;\\n                ans += \"1\";\\n            }\\n            else{\\n                ans += \"0\";\\n            }\\n            temp/=2;\\n        }\\n        return ans;\\n    }\\n\\n    int minFlips(int a, int b, int c) {\\n        string x = binary(a);\\n        string y = binary(b);\\n        string z = binary(c);\\n        //cout << x << \" \" << y << \" \" << z;\\n\\n        int ans=0;\\n        int u=x.length()-1,v=y.length()-1,w=z.length()-1;\\n        while(u>=0 && v>=0){\\n            if(w<0){\\n                if(x[u]==\\'1\\') ans++;\\n                if(y[v]==\\'1\\') ans++;\\n                u--; v--; continue;\\n            }\\n            else if(z[w]==\\'1\\'){\\n                if(x[u]==\\'0\\' && y[v]==\\'0\\') ans++;\\n            }\\n            else if(z[w]==\\'0\\'){\\n                if(x[u]==\\'1\\') ans++;\\n                if(y[v]==\\'1\\') ans++;\\n            }\\n            u--;\\n            v--;\\n            w--;\\n        }\\n        while(u>=0){\\n            if(w<0){\\n                if(x[u]==\\'1\\') ans++;\\n                u--; continue;\\n            }\\n            else if(z[w]==\\'1\\' && x[u]==\\'0\\') ans++;\\n            else if(z[w]==\\'0\\' && x[u]==\\'1\\') ans++;\\n            u--;\\n            w--;\\n        }\\n        while(v>=0){\\n            if(w<0){\\n                if(y[v]==\\'1\\') ans++;\\n                v--; continue;\\n            }\\n            else if(z[w]==\\'1\\' && y[v]==\\'0\\') ans++;\\n            else if(z[w]==\\'0\\' && y[v]==\\'1\\') ans++;\\n            v--;\\n            w--;\\n        }\\n        while(w>=0){\\n            if(z[w]==\\'1\\') ans++;\\n            w--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3606940,
                "title": "odd-even-py",
                "content": "# Code\\n```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        ans=0\\n        while a or b or c:\\n            x,y,z=a%2,b%2,c%2\\n            print(x,y,z)\\n            if z==0:ans+=(x+y)\\n            elif x==0 and y==0:ans+=1\\n            a,b,c=a//2,b//2,c//2\\n        return ans\\n```\\n\\n![](https://media.makeameme.org/created/please-upvote-and.jpg)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        ans=0\\n        while a or b or c:\\n            x,y,z=a%2,b%2,c%2\\n            print(x,y,z)\\n            if z==0:ans+=(x+y)\\n            elif x==0 and y==0:ans+=1\\n            a,b,c=a//2,b//2,c//2\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606819,
                "title": "intuition-solution-with-neat-and-clean-code-c",
                "content": "# Intuition\\n-  If the corresponding bit in the result c is 0, both a and b should have a 0 at that index.\\n-  If the corresponding bit in the result c is 1, at least one of a and b should have a 1 at that index.\\n\\nTo fulfill this condition, the bits can be flipped accordingly.\\n\\nTo calculate the result, the following approach can be taken:\\n- \\n - If the bit in c is 0, the result is increased by the sum of bits in a and b at that index (i.e., ans += (ai + bi)).\\n - If the bit in c is 1, the result is increased by the expression (ai != 1 && bi != 1) (if both ai and bi are not equal to 1, the value will be 1; otherwise, it will be 0).\\n# Complexity\\n- Time complexity:\\n$$O(log(max(a,b,c)))$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int ans = 0;\\n        while(a||b||c){\\n            int aa = a%2;\\n            int bb= b%2;\\n            int cc = c%2;\\n            if(cc==1){\\n                ans += (aa!=1&&bb!=1);\\n            }else{\\n                ans += ((aa==1)+(bb==1));\\n            }\\n            a/=2;\\n            b/=2;\\n            c/=2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int ans = 0;\\n        while(a||b||c){\\n            int aa = a%2;\\n            int bb= b%2;\\n            int cc = c%2;\\n            if(cc==1){\\n                ans += (aa!=1&&bb!=1);\\n            }else{\\n                ans += ((aa==1)+(bb==1));\\n            }\\n            a/=2;\\n            b/=2;\\n            c/=2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606768,
                "title": "check-least-significant-bit-python-js-solution",
                "content": "Hello **Tenno Leetcoders**, \\n\\nFor this problem, given 3 positives numbers `a`, `b` and `c`. Return the minimum flips required in some bits of `a` and `b` to make `( a OR b == c )`. (bitwise OR operation).\\n\\nFlip operation consists of change any single bit 1 to 0 or change the bit 0 to 1 in their binary representation.\\n\\n### Explanation \\n\\nWe want to find the minimum required flips needed to make `( a OR b == c )`. To do that, we can use bitwise operations. \\n\\nCreate a variable to keep track of minimum number of flips required.\\n\\nWe want to iterate through the bits of `a`, `b` and `c` simultaneously and check for the `least significant bit` using bitwise `AND` operation with `1`. The number `1` in binary is represented as `00000001`, and performing the `& 1` operation will extracts the rightmost bit of each number, resulting in `1` if bit is set to `1` and `0` if bit is unset `0`\\n\\nUsing the least significant bit, we will perform a few checks:\\n\\n1)  If a & 1 or b & 1 is not equal to c & 1, this means either bit a or bit b is 1 (at least one bit is 1) but c is 0. Thus, we need to perform flips to make `a or b == c`\\n\\n    - If bit c is equal to 1, this means the current bit in c is 1, and the OR operation will result in 1. So increment tracker variable by 1 to represent the need to flip `a` and `b` to match `c`\\n    \\n    - If bit c is equal to 0, this means that the current bit in c is 0, and the OR operation will result in 0. If at least one of bit a or bit b is 1, we need to flip the corresponding bit to 0, so increment the tracker variable by the number of bits needed to be flipped, which is ` (bit_a == 1) + (bit_b == 1)`\\n    \\n2) To move onto the next bit after processing the current bit, we right-shift `a`, `b` and `c` by 1 to discard the rightmost bit and shit all other bits towards the right\\n\\n3) Loop will continue until a, b and c becomes `0`. Thus, we will return the minimum flips needed \\n\\n\\n# Code\\n\\n**Python**\\n```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        min_flip = 0\\n\\n        while a or b or c:\\n            bit_a = a & 1\\n            bit_b = b & 1\\n            bit_c = c & 1\\n\\n            if (bit_a or bit_b) != bit_c:\\n                if bit_c == 1: \\n                    min_flip += 1\\n                else:\\n                    min_flip += (bit_a == 1) + (bit_b == 1)\\n               \\n            a >>= 1\\n            b >>= 1\\n            c >>= 1\\n\\n        return min_flip\\n```\\n\\n**JavaScript**\\n```\\n/**\\n * @param {number} a\\n * @param {number} b\\n * @param {number} c\\n * @return {number}\\n */\\nvar minFlips = function(a, b, c) {\\n    let minFlip = 0\\n\\n    while(a || b || c){\\n        const bitA = a & 1\\n        const bitB = b & 1\\n        const bitC = c & 1\\n        if ((bitA || bitB) !== bitC){\\n            bitC === 1 ? minFlip += 1 : minFlip += (bitA === 1) + (bitB === 1)\\n        }\\n        a >>= 1\\n        b >>= 1\\n        c >>= 1\\n    }\\n    return minFlip\\n};\\n```\\n### Time Complexity: `O(log(max(a,b,c)))`\\n### Space Complexity: `O(1)`\\n\\n \\n***Warframe\\'s Darvo wants you to upvote this post  \\uD83D\\uDE4F\\uD83C\\uDFFB \\u2764\\uFE0F\\u200D\\uD83D\\uDD25***\\n![image](https://assets.leetcode.com/users/images/814f5668-c966-46d7-ba42-e5435c4c1761_1675302761.3081913.gif)",
                "solutionTags": [
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        min_flip = 0\\n\\n        while a or b or c:\\n            bit_a = a & 1\\n            bit_b = b & 1\\n            bit_c = c & 1\\n\\n            if (bit_a or bit_b) != bit_c:\\n                if bit_c == 1: \\n                    min_flip += 1\\n                else:\\n                    min_flip += (bit_a == 1) + (bit_b == 1)\\n               \\n            a >>= 1\\n            b >>= 1\\n            c >>= 1\\n\\n        return min_flip\\n```\n```\\n/**\\n * @param {number} a\\n * @param {number} b\\n * @param {number} c\\n * @return {number}\\n */\\nvar minFlips = function(a, b, c) {\\n    let minFlip = 0\\n\\n    while(a || b || c){\\n        const bitA = a & 1\\n        const bitB = b & 1\\n        const bitC = c & 1\\n        if ((bitA || bitB) !== bitC){\\n            bitC === 1 ? minFlip += 1 : minFlip += (bitA === 1) + (bitB === 1)\\n        }\\n        a >>= 1\\n        b >>= 1\\n        c >>= 1\\n    }\\n    return minFlip\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 810613,
                "title": "beats-100-cpp-solution-with-comments",
                "content": "```\\n// Runtime: 0 ms, faster than 100.00% of C++ online submissions for Minimum Flips to Make a OR b Equal to c.\\n// Memory Usage: 6 MB, less than 51.42% of C++ online submissions for Minimum Flips to Make a OR b Equal to c.\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int count = 0;\\n        while(a != 0 || b != 0 || c){\\n            //check the last bit\\n            int aBit = a & 1;\\n            int bBit = b & 1;\\n            int cBit = c & 1;\\n            if(cBit == 1 && bBit == 0 && aBit == 0){\\n                count ++; //if both zero then to make a || b = 1  atleast one 1 is needed\\n            }else if (cBit == 0){\\n                if(aBit == 1 && bBit == 1) count += 2;//if both 1 then both should be zero to make a || b = 0\\n                if(aBit + bBit == 1) count++;//if one is zero flip the other one\\n            }//shift to check for next digit\\n            a >>= 1;\\n            b >>= 1;\\n            c >>= 1;\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int count = 0;\\n        while(a != 0 || b != 0 || c){\\n            //check the last bit\\n            int aBit = a & 1;\\n            int bBit = b & 1;\\n            int cBit = c & 1;\\n            if(cBit == 1 && bBit == 0 && aBit == 0){\\n                count ++; //if both zero then to make a || b = 1  atleast one 1 is needed\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3609608,
                "title": "c-kernighan-s-algorithm-super-fast",
                "content": "# Intuition\\nKernighan\\u2019s Algorithm is a quick way to count how many bits are on in a given number. The explanation of this algorithm is in the comments of the BitCount function. \\n\\nSome simple bitwise operations on our inputs will give us numbers whose bits we can count to give us our answer. Doing it this way will require use to loop over two numbers, however we will save numerous if checks and bitshifts, and so it should be faster than the brute force methods.\\n\\n# Approach\\nFirst implement Kernighan\\'s Algorithm to count bits.\\n\\nIn order to find bits where a flip of some kind is needed we can simply XOR c with the target (a or b). An XOR is on only if the bit is on in one number but not the other. All of the bits that are on after the XOR will require at least one flip. \\n\\nNow we just need to find the bits that are on in our XOR result and BOTH a AND b. These are the bits that need double counted.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\npublic class Solution {\\n    public int MinFlips(int a, int b, int c) {\\n        int flips = 0;\\n        int or = a | b;\\n        //xor\\'ing will tell us places where \\n        //  1) c is on but neither a or b is\\n        //  2) c is off but a or b or both is on\\n        int xor = c ^ or;\\n        //at least one bit needs flipped for each bit that is on\\n        flips = this.BitCount(xor);\\n        //now we just need to count once more\\n        //the places where both a and b need flipped\\n        int dblcount = xor & a & b;\\n        flips += this.BitCount(dblcount);\\n\\n        return flips;\\n    }\\n\\n    public int BitCount(int x) {\\n        /*\\n        Brian Kernighan\\u2019s Algorithm\\n        ---------------------------\\n        Relies on the following observation about what happens \\n        when you subtract 1 from a number in binary.\\n        E.g.\\n        52: 0011 0100\\n        51: 0011 0011\\n\\n        Notice we could describe subtracting 1 in the \\n        following way:\\n        Find the first bit from the right that is set (==1).\\n        That bit and all the bits to its right will flip.\\n        Any set bits to the left stay.\\n\\n        Now, if we AND those two numbers (x AND x-1) together \\n        we are left with\\n        0011 0000\\n\\n        So we went from 3 set bits to 2. \\n        If we repeat this procedure and count how many times we \\n        do it before we reach zero, we will have our answer.\\n        */\\n        int count = 0;\\n        while (x > 0){\\n            count++;\\n            x &= (x - 1);\\n        }\\n        return count;\\n    }\\n}\\n```\\nWould greatly appreciate an upvote if you found this useful or interesting.",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinFlips(int a, int b, int c) {\\n        int flips = 0;\\n        int or = a | b;\\n        //xor\\'ing will tell us places where \\n        //  1) c is on but neither a or b is\\n        //  2) c is off but a or b or both is on\\n        int xor = c ^ or;\\n        //at least one bit needs flipped for each bit that is on\\n        flips = this.BitCount(xor);\\n        //now we just need to count once more\\n        //the places where both a and b need flipped\\n        int dblcount = xor & a & b;\\n        flips += this.BitCount(dblcount);\\n\\n        return flips;\\n    }\\n\\n    public int BitCount(int x) {\\n        /*\\n        Brian Kernighan\\u2019s Algorithm\\n        ---------------------------\\n        Relies on the following observation about what happens \\n        when you subtract 1 from a number in binary.\\n        E.g.\\n        52: 0011 0100\\n        51: 0011 0011\\n\\n        Notice we could describe subtracting 1 in the \\n        following way:\\n        Find the first bit from the right that is set (==1).\\n        That bit and all the bits to its right will flip.\\n        Any set bits to the left stay.\\n\\n        Now, if we AND those two numbers (x AND x-1) together \\n        we are left with\\n        0011 0000\\n\\n        So we went from 3 set bits to 2. \\n        If we repeat this procedure and count how many times we \\n        do it before we reach zero, we will have our answer.\\n        */\\n        int count = 0;\\n        while (x > 0){\\n            count++;\\n            x &= (x - 1);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609042,
                "title": "java",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minFlips(int a, int b, int c) {\\n        String res = String.format(\"%32s\",Integer.toBinaryString(c)).replaceAll(\" \",\"0\");\\n        String x = String.format(\"%32s\",Integer.toBinaryString(a)).replaceAll(\" \",\"0\");\\n        String y = String.format(\"%32s\",Integer.toBinaryString(b)).replaceAll(\" \",\"0\");\\n\\n        char [] resA = res.toCharArray();\\n        char [] xA = x.toCharArray();\\n        char [] yA = y.toCharArray();\\n        \\n        int count = 0;\\n\\n        for(int i=0; i<32; i++){\\n            int p = resA[i] - \\'0\\';\\n            int q = xA[i] - \\'0\\';\\n            int r = yA[i] - \\'0\\';\\n            \\n            if(p==1 && (q|r)!=1) count++;\\n            else if(p==0 && (q|r)!=0){\\n                if(q==1 && r==1) count+=2;\\n                else count+=1;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minFlips(int a, int b, int c) {\\n        String res = String.format(\"%32s\",Integer.toBinaryString(c)).replaceAll(\" \",\"0\");\\n        String x = String.format(\"%32s\",Integer.toBinaryString(a)).replaceAll(\" \",\"0\");\\n        String y = String.format(\"%32s\",Integer.toBinaryString(b)).replaceAll(\" \",\"0\");\\n\\n        char [] resA = res.toCharArray();\\n        char [] xA = x.toCharArray();\\n        char [] yA = y.toCharArray();\\n        \\n        int count = 0;\\n\\n        for(int i=0; i<32; i++){\\n            int p = resA[i] - \\'0\\';\\n            int q = xA[i] - \\'0\\';\\n            int r = yA[i] - \\'0\\';\\n            \\n            if(p==1 && (q|r)!=1) count++;\\n            else if(p==0 && (q|r)!=0){\\n                if(q==1 && r==1) count+=2;\\n                else count+=1;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608795,
                "title": "beats-100-o-n-bit-manipulation-and-shifting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nJust bit shifting.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minFlips(int a, int b, int c) {\\n        int tmp = a|b;\\n        if(tmp == c){\\n            return 0;\\n        }\\n        int mask = 1;\\n        int ans = 0;\\n        for(int i=0; i<32; i++) {\\n            int aBit = ((1 << i) & a) >> i;\\n            int bBit = ((1 << i) & b) >> i;\\n            int cBit = ((1 << i) & c) >> i;\\n            tmp = aBit | bBit;\\n            if(tmp == cBit){\\n                continue;\\n            }\\n            if(cBit == 0) {\\n                ans+=aBit;\\n                ans+=bBit;\\n            }\\n            else {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minFlips(int a, int b, int c) {\\n        int tmp = a|b;\\n        if(tmp == c){\\n            return 0;\\n        }\\n        int mask = 1;\\n        int ans = 0;\\n        for(int i=0; i<32; i++) {\\n            int aBit = ((1 << i) & a) >> i;\\n            int bBit = ((1 << i) & b) >> i;\\n            int cBit = ((1 << i) & c) >> i;\\n            tmp = aBit | bBit;\\n            if(tmp == cBit){\\n                continue;\\n            }\\n            if(cBit == 0) {\\n                ans+=aBit;\\n                ans+=bBit;\\n            }\\n            else {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608282,
                "title": "golang-beats-100-easy-to-understand-simple-code",
                "content": "# Approach\\nCompare these three numbers bit-by-bit. \\n- `ai OR bi == ci` - this case means no flips are needed for $$ith$$ bits.\\n- `ai OR bi != ci` - this case means that there must be at least one flip operation. But actually, there is a possiblity that we need to perform two flips, when `ci` is 0 and both `ai` and `bi` are 1.\\n\\n# Code\\n```\\nfunc minFlips(a int, b int, c int) int {\\n\\tans := 0\\n\\tfor a > 0 || b > 0 || c > 0 {\\n\\t\\tai, bi, ci := a%2, b%2, c%2\\n\\t\\ta, b, c = a/2, b/2, c/2\\n\\t\\tif ai|bi != ci {\\n\\t\\t\\tans++\\n\\t\\t\\tif ci == 0 && ai == 1 && bi == 1 {\\n\\t\\t\\t\\tans++\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t}\\n\\treturn ans\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minFlips(a int, b int, c int) int {\\n\\tans := 0\\n\\tfor a > 0 || b > 0 || c > 0 {\\n\\t\\tai, bi, ci := a%2, b%2, c%2\\n\\t\\ta, b, c = a/2, b/2, c/2\\n\\t\\tif ai|bi != ci {\\n\\t\\t\\tans++\\n\\t\\t\\tif ci == 0 && ai == 1 && bi == 1 {\\n\\t\\t\\t\\tans++\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t}\\n\\treturn ans\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3608204,
                "title": "c-simple-bit-manipulation-approach",
                "content": "# Approach\\n- Iterate over each bit of the numbers starting from the least significant bit.\\n- Let\\'s denote the least significant bits of a, b, and c as aa, bb, and cc, respectively.\\n- Check if the bitwise OR of aa and bb is equal to cc. If they are equal, no bit flip is required to satisfy the condition (a OR b = c).\\n- If the bitwise OR is not equal to cc, it means that at least one bit needs to be flipped to match the condition.\\n- If the condition is not satisfied and cc is 1, then it means both aa and bb are 0. So, either aa or bb must be flipped to obtain 1. So, we increment the count by 1.\\n- If the condition is not satisfied and cc is 0, then it means both aa and bb are 1. So, both aa and bb must be flipped to obtain 0. So, we increment the count by 2.\\n\\n# Dry Run\\nLet\\'s take a small example with `a = 5`, `b = 3`, and `c = 6`. \\n\\n1. Initialization:\\n   - Iterating through the bits from right to left: \\n     - `a = 101` (binary representation of 5)\\n     - `b = 011` (binary representation of 3)\\n     - `c = 110` (binary representation of 6)\\n\\n2. Loop / Bit Processing:\\n   - Bit 0:\\n     - `aa = 1`, `bb = 1`, `cc = 0`\\n     - Since `aa | bb != cc`, we enter the if condition.\\n     - `cc` is 0, and both `aa` and `bb` are 1. So, we increment `count` by 2.\\n   - Bit 1:\\n     - `aa = 0`, `bb = 1`, `cc = 1`\\n     - Since `aa | bb == cc`, no bit flip is required.\\n   - Bit 2:\\n     - `aa = 1`, `bb = 0`, `cc = 1`\\n     - Since `aa | bb == cc`, no bit flip is required.\\n\\n3. Final Result:\\n   - `count = 2` (minimum number of bit flips required)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c)\\n    {\\n        int count = 0;\\n\\n        while(a || b || c)\\n        {\\n            int aa = a&1;\\n            int bb = b&1;\\n            int cc = c&1;\\n\\n            if((aa | bb) != cc)\\n            {\\n                if(cc == 1)\\n                    count += 1;\\n                else\\n                {\\n                    count += (aa == 1) ? (1) : (0);\\n                    count += (bb == 1) ? (1) : (0);\\n                }\\n            }\\n\\n            a /= 2;\\n            b /= 2;\\n            c /= 2;\\n        }\\n\\n        return count;\\n    }\\n};\\n```\\n\\n> **NOTE:** \\nThe addition of parentheses in the expression `(aa | bb) != cc` is necessary to control the order of evaluation. Without parentheses, the `!=` operator has higher precedence than the `|` operator, leading to incorrect evaluation of the expression. By using parentheses, we ensure that the bitwise OR operation (`|`) is performed first, followed by the comparison with `cc`. This ensures that the desired logic of the code is maintained and the correct comparison is made between the bitwise OR result and `cc`.\\n\\n# Complexity\\n- Time complexity: $ O(log(max(a, b, c))) $\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c)\\n    {\\n        int count = 0;\\n\\n        while(a || b || c)\\n        {\\n            int aa = a&1;\\n            int bb = b&1;\\n            int cc = c&1;\\n\\n            if((aa | bb) != cc)\\n            {\\n                if(cc == 1)\\n                    count += 1;\\n                else\\n                {\\n                    count += (aa == 1) ? (1) : (0);\\n                    count += (bb == 1) ? (1) : (0);\\n                }\\n            }\\n\\n            a /= 2;\\n            b /= 2;\\n            c /= 2;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607698,
                "title": "o-1-time-and-space-easy-solution-in-c",
                "content": "# Intuition\\n- Checking each bit of a, b, and c from the most significant bit (MSB) to the least significant bit (LSB).\\n- If the corresponding bit in c is 1, we need to ensure that either a or b has a corresponding bit as 1. If not, a flip operation is required.\\n- If the corresponding bit in c is 0, we need to ensure that both a and b have the corresponding bit as 0. If not, a flip operation is required.\\n\\n# Approach\\n- Convert **a**, **b**, and **c** into binary representations using **bitset<32>**.\\n- Initialize a **count** variable to keep track of the number of flips required.\\n- Iterate over each bit from the MSB to the LSB (from index 31 to 0):\\n- If **c1[i]** is 1:\\n  - If both **a1[i]** and **b1[i]** are 0, increment **count** since a flip is required.\\n- If **c1[i]** is 0:\\n  - If either **a1[i]** or **b1[i]** is 1, increment **count** since a flip is required.\\n  - If both **a1[i]** and **b1[i]** are 1, increment **count** by 2 since two flips are required.\\n- Return the final **count** as the minimum number of flips required.\\n\\n# Complexity\\n- Time complexity: **O(1)**\\n\\nThe code performs a constant number of operations regardless of the input size.\\nIt involves a single loop iterating over 32 bits, which is a fixed number.\\n\\n - Space complexity: **O(1)**\\n\\nThe code uses a constant amount of extra space to store the bitsets and the count variable.\\nThe space used does not depend on the input size.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int minFlips(int a, int b, int c) {\\n       bitset<32> a1(a);\\n       a1.to_string();\\n\\n       bitset<32> b1(b);\\n       b1.to_string();\\n\\n       bitset<32> c1(c);\\n       c1.to_string();\\n\\n       int count = 0;\\n\\n       for(int i = 31; i>=0; i--){\\n           if(c1[i]==1){\\n               if(a1[i]==0 && b1[i]==0){\\n                   count++;\\n               }\\n           }\\n           else{\\n               if((a1[i]==0 && b1[i]==1) || (a1[i]==1 && b1[i]==0)){\\n                   count++;\\n               }\\n               if(a1[i]==1 && b1[i]==1){\\n                   count += 2;\\n               }\\n           }\\n       }\\n       return count; \\n    }\\n};\\n```\\nUPVOTE :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int minFlips(int a, int b, int c) {\\n       bitset<32> a1(a);\\n       a1.to_string();\\n\\n       bitset<32> b1(b);\\n       b1.to_string();\\n\\n       bitset<32> c1(c);\\n       c1.to_string();\\n\\n       int count = 0;\\n\\n       for(int i = 31; i>=0; i--){\\n           if(c1[i]==1){\\n               if(a1[i]==0 && b1[i]==0){\\n                   count++;\\n               }\\n           }\\n           else{\\n               if((a1[i]==0 && b1[i]==1) || (a1[i]==1 && b1[i]==0)){\\n                   count++;\\n               }\\n               if(a1[i]==1 && b1[i]==1){\\n                   count += 2;\\n               }\\n           }\\n       }\\n       return count; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606984,
                "title": "python3-one-line-solution",
                "content": "\\n```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        return (c:=(a|b)^c).bit_count()+(a&b&c).bit_count()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        return (c:=(a|b)^c).bit_count()+(a&b&c).bit_count()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606942,
                "title": "simple-and-easy-to-understand-c-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n   int minFlips(int a, int b, int c) {\\n\\n        int cnt = 0;\\n        int a1, b1, c1;\\n        \\n        while (a || b || c) {\\n            a1 = a%2;\\n            b1 = b%2;\\n            c1 = c%2;\\n            \\n            if (c1 == 0) cnt += (a1 + b1);\\n            else {\\n                if (a1 + b1 == 0) ++cnt;\\n            }\\n        \\n            a /= 2;\\n            b /= 2;\\n            c /= 2;\\n        }\\n        return cnt;\\n   }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int minFlips(int a, int b, int c) {\\n\\n        int cnt = 0;\\n        int a1, b1, c1;\\n        \\n        while (a || b || c) {\\n            a1 = a%2;\\n            b1 = b%2;\\n            c1 = c%2;\\n            \\n            if (c1 == 0) cnt += (a1 + b1);\\n            else {\\n                if (a1 + b1 == 0) ++cnt;\\n            }\\n        \\n            a /= 2;\\n            b /= 2;\\n            c /= 2;\\n        }\\n        return cnt;\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606698,
                "title": "one-liner-explained",
                "content": "Xor operation **^** is an \"inequality testing\" operator, i.e. if we want to test whether **x $\\\\neq $ y** (bitwise speaking), we use **x ^ y** which yields 1 for non-equal and 0 for equal.\\nSo, here we test values **a | b** vs **c**\\n**(a | b) ^ c** gives almost what we need, except for the nasty case of **a = 1, b = 1, c = 0** when it takes not one but two flips to change the outcome of **a | b**. So we just add 1 to the result for that case, that\\'s where **a & b & ~c** comes from.\\nThe resulting formula provides the desired answer for any triple of corresponding bits from a, b, and c. And to get the result for the whole number, use the property with self-explanatory name `nonzeroBitCount` (or its equivalent in your language of choice).\\n\\n```\\nfunc minFlips(_ a: Int, _ b: Int, _ c: Int) -> Int {\\n    ((a | b) ^ c).nonzeroBitCount + (a & b & ~c).nonzeroBitCount\\n}\\n```\\n![1.JPG](https://assets.leetcode.com/users/images/55291529-cc37-4f00-915f-de3cfee6f4cb_1686098366.8057234.jpeg)\\n![2.JPG](https://assets.leetcode.com/users/images/3154e848-ac97-416b-a655-9cc34ae88df0_1686098399.302026.jpeg)\\n",
                "solutionTags": [
                    "Swift",
                    "Bit Manipulation"
                ],
                "code": "```\\nfunc minFlips(_ a: Int, _ b: Int, _ c: Int) -> Int {\\n    ((a | b) ^ c).nonzeroBitCount + (a & b & ~c).nonzeroBitCount\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2435400,
                "title": "c-o-1-clean-code",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int itr = 31, count = 0;\\n        while (itr--) {\\n            auto isCone = (c >> itr) & 1;\\n            auto isAone = (a >> itr) & 1;\\n            auto isBone = (b >> itr) & 1;\\n            if (isCone && !isAone && !isBone) count++;\\n            else if (!isCone) {\\n                if (isAone) count++;\\n                if (isBone) count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int itr = 31, count = 0;\\n        while (itr--) {\\n            auto isCone = (c >> itr) & 1;\\n            auto isAone = (a >> itr) & 1;\\n            auto isBone = (b >> itr) & 1;\\n            if (isCone && !isAone && !isBone) count++;\\n            else if (!isCone) {\\n                if (isAone) count++;\\n                if (isBone) count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1811870,
                "title": "c-o-1-solution-explained-solution-using-or",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int res = 0;\\n        for( int i=0; i<32; i++ ) {     // Looping through 32 bits in a int...\\n            bool _bita = a&(1<<i);\\n            bool _bitb = b&(1<<i);\\n            bool _bitc = c&(1<<i);\\n            \\n            bool aORb = _bita|_bitb;\\n            if( (aORb) != _bitc ) {\\n                // basically we get 4 cases\\n                // (0,0) , (0,1) , (1,0) , (1,1)\\n                // but these cases depend on _bitc..\\n                // soo , we first check _bitc\\n                \\n                if( _bitc == 1 ) {    //_bitc == 1 --> cases = (0,0)\\n                    res++;\\n                } else {              //_bitc == 0 --> cases = (0,0) , (0,1) , (1,0)\\n                    if( (_bita == 1 && _bitb == 0) || (_bita == 0 && _bitb == 1) ) {\\n                        res++;        // for cases = (1,0) , (0,1)\\n                    } else {\\n                        res += 2;     // for cases = (0,0)\\n                    }\\n                }   //all cases are handled...\\n                \\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\nIf you like ,  UpVote it...",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int res = 0;\\n        for( int i=0; i<32; i++ ) {     // Looping through 32 bits in a int...\\n            bool _bita = a&(1<<i);\\n            bool _bitb = b&(1<<i);\\n            bool _bitc = c&(1<<i);\\n            \\n            bool aORb = _bita|_bitb;\\n            if( (aORb) != _bitc ) {\\n                // basically we get 4 cases\\n                // (0,0) , (0,1) , (1,0) , (1,1)\\n                // but these cases depend on _bitc..\\n                // soo , we first check _bitc\\n                \\n                if( _bitc == 1 ) {    //_bitc == 1 --> cases = (0,0)\\n                    res++;\\n                } else {              //_bitc == 0 --> cases = (0,0) , (0,1) , (1,0)\\n                    if( (_bita == 1 && _bitb == 0) || (_bita == 0 && _bitb == 1) ) {\\n                        res++;        // for cases = (1,0) , (0,1)\\n                    } else {\\n                        res += 2;     // for cases = (0,0)\\n                    }\\n                }   //all cases are handled...\\n                \\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1738443,
                "title": "0-ms-efficient-0-32-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = 0 ; \\n    int minFlips(int a, int b, int c) {\\n        \\n        for(int i = 0 ; i <= 31; i++)\\n        {\\n            long long int mask = (1 << i) ; \\n            \\n            int a_bit = (a & mask)?1:0;\\n            int b_bit = (b & mask)?1:0;\\n            int c_bit = (c & mask)?1:0;\\n          //  cout<<a_bit<<\" \"<<b_bit<<\" \"<<c_bit<<endl;\\n            if((a_bit | b_bit) == c_bit)ans+=0;\\n            if((a_bit | b_bit) != c_bit)\\n            {\\n                if((a_bit == c_bit) || (b_bit == c_bit)){\\n                    ans++ ; continue;}\\n                if(a_bit == 1 &&  b_bit == 1 && c_bit == 0 )\\n                {ans+=2 ; continue;}\\n                else{ \\n                   // cout<<i<<\" \";\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int ans = 0 ; \\n    int minFlips(int a, int b, int c) {\\n        \\n        for(int i = 0 ; i <= 31; i++)\\n        {\\n            long long int mask = (1 << i) ; \\n            \\n            int a_bit = (a & mask)?1:0;\\n            int b_bit = (b & mask)?1:0;\\n            int c_bit = (c & mask)?1:0;\\n          //  cout<<a_bit<<\" \"<<b_bit<<\" \"<<c_bit<<endl;\\n            if((a_bit | b_bit) == c_bit)ans+=0;\\n            if((a_bit | b_bit) != c_bit)\\n            {\\n                if((a_bit == c_bit) || (b_bit == c_bit)){\\n                    ans++ ; continue;}",
                "codeTag": "C++"
            },
            {
                "id": 1179942,
                "title": "java-simple-solution-bit-manipulation",
                "content": "```\\n\\nclass Solution {\\n    public int minFlips(int a, int b, int c) {\\n        int xor = (a|b)^c;\\n        int res = 0;\\n        while(xor!=0){\\n            int mask = xor & -xor;\\n            if((mask & c) > 0){\\n                res++;\\n            }else{\\n                if((mask & a) > 0)\\n                    res++;\\n                if((mask & b) > 0)\\n                    res++;\\n            }\\n            xor ^= mask;\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int minFlips(int a, int b, int c) {\\n        int xor = (a|b)^c;\\n        int res = 0;\\n        while(xor!=0){\\n            int mask = xor & -xor;\\n            if((mask & c) > 0){\\n                res++;\\n            }else{\\n                if((mask & a) > 0)\\n                    res++;\\n                if((mask & b) > 0)\\n                    res++;\\n            }\\n            xor ^= mask;\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 641275,
                "title": "c-o-1-space-time-w-o-skipping-intermediate-steps-and-w-explanation",
                "content": "```\\npublic class Solution {\\n    public int MinFlips(int a, int b, int c) {\\n        var diff = (a | b) ^ c; // what bits are different from expected\\n        var ones_a = a & diff; // from the bits that were different which are 1s in a, they must all be flipped to 0\\n        var ones_b = b & diff; // from the bits that were different which are 1s in b, they must all be flipped to 0\\n        var zeros = ~(a | b) & diff // from the bits that were different which zeros in both a and b, they must be flipped in either a or b;\\n\\n        return count(ones_a) + count(ones_b) + count(zeros); // lets count all the bits needing flipping\\n        \\n        const int b1 = 0b0101_0101_0101_0101_0101_0101_0101_0101;\\n        const int b2 = 0b0011_0011_0011_0011_0011_0011_0011_0011;\\n        const int b4 = 0b0000_1111_0000_1111_0000_1111_0000_1111;\\n        const int b8 = 0b0000_0000_1111_1111_0000_0000_1111_1111;\\n        const int bl = 0b0000_0000_0000_0000_1111_1111_1111_1111;\\n\\n        // counts the number of 1s in n\\n        int count(int n) {\\n            // don\\'t give up just yet, this is easier magic trick than it seems! \\n            // imagine your intiger bits are a stack of 32 playing cards, each either red or black\\n            // imagine simultaneously sliding out every other card in the deck to your left starting from the top of the deck while maintaining all the spaces\\n            // now shift the new stack of cards on your left one space down so the cards in each deck are parallel\\n            // assuming red represents 0\\'s and black 1\\'s you notice if you add up each parallel pair of cards you will have the number of black cards at each level\\n            // now imagine the process of adding each pair of cards together squeezes each pair into 1 new card labeled with a number corresponding to the sum you just found\\n            // now squeeze the new deck of 16 cards down so there are no more spaces, and repeat the process once more\\n            // you now have 8 cards each constructed from merging 4 cards and each labeled with a number representing the total number of black cards out of the 4\\n            // repeat this again, now you have 4 cards,\\n            // repeat this again, now you have 2 cards,\\n            // repeat this again, now you have 1 card, you notice the number on the card reads how many black cards you had in the original deck\\n            // the magic trick is done, the audience roars in a standing ovation, pen and teller stare at you baffled \\n            n = (n & b1) + (n >> 1 & b1); \\n            n = (n & b2) + (n >> 2 & b2);\\n            n = (n & b4) + (n >> 4 & b4);\\n            n = (n & b8) + (n >> 8 & b8);\\n            return (n & bl) + (n >> 16);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MinFlips(int a, int b, int c) {\\n        var diff = (a | b) ^ c; // what bits are different from expected\\n        var ones_a = a & diff; // from the bits that were different which are 1s in a, they must all be flipped to 0\\n        var ones_b = b & diff; // from the bits that were different which are 1s in b, they must all be flipped to 0\\n        var zeros = ~(a | b) & diff // from the bits that were different which zeros in both a and b, they must be flipped in either a or b;\\n\\n        return count(ones_a) + count(ones_b) + count(zeros); // lets count all the bits needing flipping\\n        \\n        const int b1 = 0b0101_0101_0101_0101_0101_0101_0101_0101;\\n        const int b2 = 0b0011_0011_0011_0011_0011_0011_0011_0011;\\n        const int b4 = 0b0000_1111_0000_1111_0000_1111_0000_1111;\\n        const int b8 = 0b0000_0000_1111_1111_0000_0000_1111_1111;\\n        const int bl = 0b0000_0000_0000_0000_1111_1111_1111_1111;\\n\\n        // counts the number of 1s in n\\n        int count(int n) {\\n            // don\\'t give up just yet, this is easier magic trick than it seems! \\n            // imagine your intiger bits are a stack of 32 playing cards, each either red or black\\n            // imagine simultaneously sliding out every other card in the deck to your left starting from the top of the deck while maintaining all the spaces\\n            // now shift the new stack of cards on your left one space down so the cards in each deck are parallel\\n            // assuming red represents 0\\'s and black 1\\'s you notice if you add up each parallel pair of cards you will have the number of black cards at each level\\n            // now imagine the process of adding each pair of cards together squeezes each pair into 1 new card labeled with a number corresponding to the sum you just found\\n            // now squeeze the new deck of 16 cards down so there are no more spaces, and repeat the process once more\\n            // you now have 8 cards each constructed from merging 4 cards and each labeled with a number representing the total number of black cards out of the 4\\n            // repeat this again, now you have 4 cards,\\n            // repeat this again, now you have 2 cards,\\n            // repeat this again, now you have 1 card, you notice the number on the card reads how many black cards you had in the original deck\\n            // the magic trick is done, the audience roars in a standing ovation, pen and teller stare at you baffled \\n            n = (n & b1) + (n >> 1 & b1); \\n            n = (n & b2) + (n >> 2 & b2);\\n            n = (n & b4) + (n >> 4 & b4);\\n            n = (n & b8) + (n >> 8 & b8);\\n            return (n & bl) + (n >> 16);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477700,
                "title": "python-solution",
                "content": "```\\ndef minFlips(self, a: int, b: int, c: int) -> int:\\n        mark = 1\\n        count = 0\\n        \\n        while mark <= c or mark <= a or mark <= b:\\n            if mark & c == 0:\\n                if mark & a != 0:\\n                    count += 1\\n                if mark & b != 0:\\n                    count += 1\\n            else:\\n                if mark & a == 0 and mark & b == 0:\\n                    count += 1\\n            mark = mark << 1\\n           \\n            \\n        return count      \\n",
                "solutionTags": [],
                "code": "```\\ndef minFlips(self, a: int, b: int, c: int) -> int:\\n        mark = 1\\n        count = 0\\n        \\n        while mark <= c or mark <= a or mark <= b:\\n            if mark & c == 0:\\n                if mark & a != 0:\\n                    count += 1\\n                if mark & b != 0:\\n                    count += 1\\n            else:\\n                if mark & a == 0 and mark & b == 0:\\n                    count += 1\\n            mark = mark << 1\\n           \\n            \\n        return count      \\n",
                "codeTag": "Python3"
            },
            {
                "id": 4036777,
                "title": "minimum-flips-to-make-a-or-b-equal-to-c-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int flips = 0;\\n        while (a > 0 || b > 0 || c > 0) {\\n            int bitA = a & 1;\\n            int bitB = b & 1;\\n            int bitC = c & 1;\\n\\n            if (bitC == 0) {\\n                flips += (bitA + bitB); \\n            } else {\\n                if (bitA == 0 && bitB == 0) {\\n                    flips += 1; \\n                }\\n            }\\n\\n            a >>= 1;\\n            b >>= 1;\\n            c >>= 1;\\n        }\\n\\n        return flips;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int flips = 0;\\n        while (a > 0 || b > 0 || c > 0) {\\n            int bitA = a & 1;\\n            int bitB = b & 1;\\n            int bitC = c & 1;\\n\\n            if (bitC == 0) {\\n                flips += (bitA + bitB); \\n            } else {\\n                if (bitA == 0 && bitB == 0) {\\n                    flips += 1; \\n                }\\n            }\\n\\n            a >>= 1;\\n            b >>= 1;\\n            c >>= 1;\\n        }\\n\\n        return flips;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610635,
                "title": "python-shortest-1-liner-bit-manipulation-functional-programming",
                "content": "# Approach\\n1. Given that `c` is the goal. And `c\\' = a | b` is where we are at, we need to flip bits in `a` or `b` to make `c\\' == c`.\\n\\n2. Every mismatched bit between `c` and `c\\'` is an indication that we need atleast one flip. Count number of such flips by taking `xor`, i.e `(c ^ c).bit_count()\\'`\\n\\n3. But in a special case where a bit in `a, b, c` is `1, 1, 0` respectively, we need 2 flips. And step 2 only counts one such flip. To compensate that count of bits with the above pattern, i.e `(a & b & ~c).bit_count()`.\\n\\n4. Add both counts and return.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\nwhere, `n is the number of bits in max(a, b, c)`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        return ((a | b) ^ c).bit_count() + (a & b & ~c).bit_count()\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```python\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        return ((a | b) ^ c).bit_count() + (a & b & ~c).bit_count()\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610617,
                "title": "c-bit-manipulation-approach-explained-code",
                "content": "# Approach- \\n1) If the c\\'s bit is 0 and \\n case-1: a\\'s and b\\'s bit are 1 then need 2 flips\\n case-2: one of them is 1 then need only 1 flip\\n\\n2) If the c\\'s bit is 1 then \\n case-1: if on a and b both are 0 then need 1 flip \\n\\n\\n# Full explanation-\\n[https://youtu.be/hIiBHXN8HXE]()\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int ans = 0;\\n\\n        while(a || b || c){\\n            int bitA = a&1;\\n            int bitB = b&1;\\n            int bitC = c&1;\\n\\n            if(bitC == 0){\\n                if(bitA==1 && bitB==1) ans+=2;\\n                else if(bitA || bitB) ans+= 1;\\n            }\\n\\n            else if(bitC ==1 && bitA==0 && bitB==0){\\n                ans+= 1;\\n            }\\n\\n            a>>= 1;\\n            b>>= 1;\\n            c>>= 1;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\nPlease do upvote if you like the solution:)",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int ans = 0;\\n\\n        while(a || b || c){\\n            int bitA = a&1;\\n            int bitB = b&1;\\n            int bitC = c&1;\\n\\n            if(bitC == 0){\\n                if(bitA==1 && bitB==1) ans+=2;\\n                else if(bitA || bitB) ans+= 1;\\n            }\\n\\n            else if(bitC ==1 && bitA==0 && bitB==0){\\n                ans+= 1;\\n            }\\n\\n            a>>= 1;\\n            b>>= 1;\\n            c>>= 1;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610565,
                "title": "clean-code-bit-manipulation-solution-with-comments",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    //function to check if n has setbit i.e. 1 at position pos\\n    bool getBit(int n, int pos){ \\n        return (n & 1<<pos); \\n    }\\n    int minFlips(int a, int b, int c) {\\n        int ans=0;\\n        for(int i =0; i<32; i++){\\n            if((getBit(a, i) | getBit(b,i))!=getBit(c, i)){\\n                if(getBit(c, i)==1) ans+=1; //since the OR of bits in a and b is 0, so fliping any bit will make the OR = 1\\n                else{\\n                    //bit in c is zero\\n                    if(getBit(a, i) & getBit(b,i)) ans+=2; // if both bits are 1 we need to flip both to make the OR zero so incrementing ans by 2\\n                    else ans++; //if one of the bit is one, flip that one\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n![687474703a2f2f692e696d6775722e636f6d2f425972773275612e676966.gif](https://assets.leetcode.com/users/images/33785b4f-7e9b-490e-a26c-f2be12212cbc_1686166271.2359772.gif)\\nUpvote if helpful :p",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //function to check if n has setbit i.e. 1 at position pos\\n    bool getBit(int n, int pos){ \\n        return (n & 1<<pos); \\n    }\\n    int minFlips(int a, int b, int c) {\\n        int ans=0;\\n        for(int i =0; i<32; i++){\\n            if((getBit(a, i) | getBit(b,i))!=getBit(c, i)){\\n                if(getBit(c, i)==1) ans+=1; //since the OR of bits in a and b is 0, so fliping any bit will make the OR = 1\\n                else{\\n                    //bit in c is zero\\n                    if(getBit(a, i) & getBit(b,i)) ans+=2; // if both bits are 1 we need to flip both to make the OR zero so incrementing ans by 2\\n                    else ans++; //if one of the bit is one, flip that one\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610329,
                "title": "c-code-bit-manipulation-simple-comparison",
                "content": "# Intuition\\ncompare a|b with c bit by bit\\n\\n# Approach\\n1- calculate a|b\\n2- check the bits of a|b is different from c\\n\\n    2.1- if a|b==1 for that bit then\\n\\n        2.1.1- if bits of a and b are 1 then increment by 2\\n        2.1.2- else increment by 1\\n    2.1-else increment by 1\\n\\n# Complexity\\n- Time complexity: $$O(32)$$ \\n\\n- Space complexity: $$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int newc=a|b;\\n        int ans=0;\\n        \\n        for(int i=0;i<32;i++){\\n            if((c&(1<<i)) != (newc &(1<<i))){\\n                if((newc&(1<<i))>0){\\n                    if((a&(1<<i))==(b&(1<<i))) \\n                    ans+=2;\\n                    else ans+=1;\\n                    }\\n                else ans+=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int newc=a|b;\\n        int ans=0;\\n        \\n        for(int i=0;i<32;i++){\\n            if((c&(1<<i)) != (newc &(1<<i))){\\n                if((newc&(1<<i))>0){\\n                    if((a&(1<<i))==(b&(1<<i))) \\n                    ans+=2;\\n                    else ans+=1;\\n                    }\\n                else ans+=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610193,
                "title": "simple-java-solution-runtime-beats-100-and-memory-beats-80",
                "content": "\\n# Approach\\nJava Solution using bit shift operation\\n# Complexity\\n- Time complexity: O(log(max(a,b,c)))\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minFlips(int a, int b, int c) {\\n        int count = 0;\\n        while(a>0 || b>0 || c>0) {\\n            if((c&1)!=((a|b)&1)) {\\n                if((c&1)==1) {\\n                    count++;\\n                } else {\\n                    count = count + (a&1) + (b&1);\\n                }\\n            }\\n            a=a>>1;\\n            b=b>>1;\\n            c=c>>1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minFlips(int a, int b, int c) {\\n        int count = 0;\\n        while(a>0 || b>0 || c>0) {\\n            if((c&1)!=((a|b)&1)) {\\n                if((c&1)==1) {\\n                    count++;\\n                } else {\\n                    count = count + (a&1) + (b&1);\\n                }\\n            }\\n            a=a>>1;\\n            b=b>>1;\\n            c=c>>1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610014,
                "title": "easy-c-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int flips = 0;\\n        while (a > 0 || b > 0 || c > 0) {\\n            int bitA = a & 1;\\n            int bitB = b & 1;\\n            int bitC = c & 1;\\n\\n            if (bitC == 0) {\\n                flips += (bitA + bitB); \\n            } else {\\n                if (bitA == 0 && bitB == 0) {\\n                    flips += 1; \\n                }\\n            }\\n\\n            a >>= 1;\\n            b >>= 1;\\n            c >>= 1;\\n        }\\n\\n        return flips;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int flips = 0;\\n        while (a > 0 || b > 0 || c > 0) {\\n            int bitA = a & 1;\\n            int bitB = b & 1;\\n            int bitC = c & 1;\\n\\n            if (bitC == 0) {\\n                flips += (bitA + bitB); \\n            } else {\\n                if (bitA == 0 && bitB == 0) {\\n                    flips += 1; \\n                }\\n            }\\n\\n            a >>= 1;\\n            b >>= 1;\\n            c >>= 1;\\n        }\\n\\n        return flips;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610007,
                "title": "bit-manipulation-easy-c-solution-beats-100-upvote",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing Bit Manipulation. We first check whether the lsb of c is set or not.If it is set we know that 3 combinations can set it (01,10,11) and (00) can make it false so to verify this we check if both a and b lsb is 0 if it is then counter must be incremented.To do this we perform bit AND. The next condition is when c lsb is 0 so this condition is false in these condition (00,01,10) we check for this condition if both a and b are 1 then we need to set them both to 0 so counter must be increment by 2 in this case.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(log(max(a,b,c)))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int cnt=0;\\n        while(c>0 || a>0 || b>0)\\n        {\\n            if(c&1)\\n            {\\n                if(!(a&1) && !(b&1))\\n                {\\n                    cnt++;\\n                }\\n            }\\n            else\\n            {\\n                if(a&1 && b&1)\\n                {\\n                    cnt+=2;\\n                }\\n                else if((a&1 && !(b&1))||(!(a&1) && b&1))\\n                {\\n                    cnt++;\\n                }\\n            }\\n            c>>=1;a>>=1;b>>=1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int cnt=0;\\n        while(c>0 || a>0 || b>0)\\n        {\\n            if(c&1)\\n            {\\n                if(!(a&1) && !(b&1))\\n                {\\n                    cnt++;\\n                }\\n            }\\n            else\\n            {\\n                if(a&1 && b&1)\\n                {\\n                    cnt+=2;\\n                }\\n                else if((a&1 && !(b&1))||(!(a&1) && b&1))\\n                {\\n                    cnt++;\\n                }\\n            }\\n            c>>=1;a>>=1;b>>=1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609762,
                "title": "beats-100-easiest-approach-well-explained",
                "content": "Please upvote if you find my code helpful..!\\nThankYou++\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n    int flips = 0;\\n    while(a!=0 || b!=0 || c!=0){\\n        if((c&1)==1){//right most bit is 1\\n        if((a&1)==0 && (b&1)==0) flips++;\\n        }\\n        else{//right most bit is 0\\n        if((a&1)==1) flips++;\\n        if((b&1)==1) flips++;\\n        }\\n        a>>=1;\\n        b>>=1;\\n        c>>=1;\\n    }\\n    return flips;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n    int flips = 0;\\n    while(a!=0 || b!=0 || c!=0){\\n        if((c&1)==1){//right most bit is 1\\n        if((a&1)==0 && (b&1)==0) flips++;\\n        }\\n        else{//right most bit is 0\\n        if((a&1)==1) flips++;\\n        if((b&1)==1) flips++;\\n        }\\n        a>>=1;\\n        b>>=1;\\n        c>>=1;\\n    }\\n    return flips;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609614,
                "title": "simple-c-solution-runtime-that-beats-100-bit-manipulation-time-and-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/1d5864b0-8e6c-49d2-a028-777bb7ec7b6b_1686147324.2414613.png)\\nThe given problem is to find the minimum number of bit flips required to make the bitwise OR of a and b equal to c. We can iterate over each bit position from the least significant bit to the most significant bit and check the conditions to determine if a bit flip is required at that position.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.Initialize a variable flips to keep track of the number of flips required.\\n2.Iterate from i = 0 to i <= max(max(a, b), c).\\n3.At each iteration:\\n(a)Create a bit mask bit with the i-th bit set to 1 (1 << i).\\n(b)Extract the i-th bit from a, b, and c using bitwise AND with the mask and check if the bit is 1 or 0.\\n(c)Check the conditions:\\n(i)If a_bit and b_bit are both 0 and c_bit is 1, it means a flip is required to set the i-th bit in c. Increment flips by 1.\\n(ii)If a_bit and b_bit are both 1 and c_bit is 0, it means both bits need to be flipped to 0. Increment flips by 2.\\n(iii)If a_bit and b_bit are different (either 0 and 1 or 1 and 0) and c_bit is 0, it means one of the bits needs to be flipped to 1. Increment flips by 1.\\n4.Return the final value of flips, which represents the minimum number of flips required.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log(max(a,b,c))):The time complexity of this approach is O(log(max(a, b, c))) since we iterate over the bits of the largest number among a, b, and c.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1):The space complexity is O(1) since we only use a constant amount of extra space to store variables flips, bit, a_bit, b_bit, and c_bit.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n  int flips = 0;\\n    //int mask = 1;\\n\\n     for(int i = 0; (1 << i) <= max(max(a, b), c); i++)\\n     {\\n            int bit = 1 << i;\\n            int a_bit = a & bit ? 1 : 0;\\n            int b_bit = b & bit ? 1 : 0;\\n            int c_bit = c & bit ? 1 : 0;\\n            if(!(a_bit | b_bit) && c_bit)\\n            {\\n                flips++;\\n            }\\n            else if((a_bit & b_bit) && !c_bit)\\n            {\\n                flips+=2;\\n            }else if((a_bit ^ b_bit) && !c_bit)\\n            {\\n                flips++;\\n            }\\n        }\\n        \\n        return flips;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n  int flips = 0;\\n    //int mask = 1;\\n\\n     for(int i = 0; (1 << i) <= max(max(a, b), c); i++)\\n     {\\n            int bit = 1 << i;\\n            int a_bit = a & bit ? 1 : 0;\\n            int b_bit = b & bit ? 1 : 0;\\n            int c_bit = c & bit ? 1 : 0;\\n            if(!(a_bit | b_bit) && c_bit)\\n            {\\n                flips++;\\n            }\\n            else if((a_bit & b_bit) && !c_bit)\\n            {\\n                flips+=2;\\n            }else if((a_bit ^ b_bit) && !c_bit)\\n            {\\n                flips++;\\n            }\\n        }\\n        \\n        return flips;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609575,
                "title": "c-using-simple-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->The intuition behind this program is to compare the binary representation of \\'a\\' and \\'b\\' with the binary representation of \\'c\\' bit by bit. By performing a bitwise OR operation between \\'a\\' and \\'b\\', we can obtain a value that represents the combination of all the corresponding bits in \\'a\\' and \\'b\\'. Then, by comparing this value with the corresponding bits in \\'c\\', we can identify the positions where a bit flip is required.\\n\\nThe program first converts \\'a\\', \\'b\\', and \\'c\\' to their binary representations using the helper function \"decToBinary\". This allows us to store the individual bits of each integer in separate arrays.\\n\\nNext, the program iterates over each bit position (from 0 to 31) in the arrays \\'x\\', \\'y\\', and \\'z\\'. For each position, it calculates the bitwise OR of the corresponding bits in \\'x\\' and \\'y\\' and stores the result in the variable \\'a_or_b\\'. This represents the combined value of \\'a\\' and \\'b\\' at that bit position.\\n\\nThe program then compares \\'a_or_b\\' with the corresponding bit in \\'z\\'. If they are not equal, it means a bit flip is required to match the desired result in \\'z\\'. The program handles two cases:\\n\\nIf \\'a_or_b\\' is 1 and \\'z\\' is 0, it means both \\'a\\' and \\'b\\' need to be flipped to 0. In this case, the program checks if both \\'x\\' and \\'y\\' are already 1. If they are, it requires two flips (\\'s += 2\\'). Otherwise, only one flip is needed (\\'s++\\').\\n\\nIf \\'z\\' is not as expected (either 0 or 1), it requires a single flip (\\'s++\\').\\n\\nFinally, the program returns the value of \\'s\\', which represents the minimum number of flips needed to convert \\'a\\' and \\'b\\' to \\'c\\' based on the described rules.\\n\\nIn summary, the program compares the binary representations of \\'a\\' and \\'b\\' with \\'c\\' bit by bit, identifying the positions where bit flips are required and calculating the minimum number of flips needed to transform \\'a\\' and \\'b\\' into \\'c\\'.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->The approach used in this program involves converting the given integers \\'a\\', \\'b\\', and \\'c\\' into their binary representations. By comparing the bits at each position, the program identifies the positions where a bit flip is required to transform \\'a\\' and \\'b\\' into \\'c\\'.\\n\\nThe program starts by initializing three arrays, \\'x\\', \\'y\\', and \\'z\\', each of size 32, with zeros. These arrays will be used to store the binary representation of \\'a\\', \\'b\\', and \\'c\\', respectively.\\n\\nTo convert an integer to its binary representation, the program uses the helper function \"decToBinary\". This function uses a while loop to perform repeated division by 2 and stores the remainder (0 or 1) in the \\'binaryNum\\' array. The loop continues until the integer becomes zero. As a result, the \\'binaryNum\\' array will contain the binary representation of the integer in reverse order.\\n\\nAfter converting \\'a\\', \\'b\\', and \\'c\\' to their binary representations using the \"decToBinary\" function, the program proceeds to iterate over each bit position (from 0 to 31) in the arrays \\'x\\', \\'y\\', and \\'z\\'.\\n\\nFor each position, the program calculates the bitwise OR of the corresponding bits in \\'x\\' and \\'y\\' and stores the result in the variable \\'a_or_b\\'. This represents the combined value of \\'a\\' and \\'b\\' at that bit position.\\n\\nThe program then compares \\'a_or_b\\' with the corresponding bit in \\'z\\'. If they are not equal, it means a bit flip is required to match the desired result in \\'z\\'. The program handles two cases:\\n\\nIf \\'a_or_b\\' is 1 and \\'z\\' is 0, it means both \\'a\\' and \\'b\\' need to be flipped to 0. In this case, the program checks if both \\'x\\' and \\'y\\' are already 1. If they are, it requires two flips (\\'s += 2\\'). Otherwise, only one flip is needed (\\'s++\\').\\n\\nIf \\'z\\' is not as expected (either 0 or 1), it requires a single flip (\\'s++\\').\\n\\nFinally, the program returns the value of \\'s\\', which represents the minimum number of flips needed to convert \\'a\\' and \\'b\\' to \\'c\\' based on the described rules.\\n\\nIn summary, the approach involves converting the integers to their binary representations, comparing the bits at each position, and calculating the minimum number of flips required to transform \\'a\\' and \\'b\\' into \\'c\\'.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->0(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->0(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void decToBinary(int n,int binaryNum[])\\n    {\\n    int i = 0;\\n    while (n > 0)\\n    {\\n        binaryNum[i] = n % 2;\\n        n = n / 2;\\n        i++;\\n    }\\n}\\n    int minFlips(int a, int b, int c)\\n     {\\n        int x[32]={0};\\n        int y[32]={0};\\n        int z[32]={0};\\n        decToBinary(a,x);\\n        decToBinary(b,y);\\n        decToBinary(c,z);\\n        int i,j,k,s=0,m=0;\\n        for(i=0;i<32;i++)\\n        {\\n            int a_or_b=x[i]|y[i];\\n            if(a_or_b !=z[i])\\n            {\\n                if(a_or_b==1 and z[i]==0)\\n                {\\n                    if(x[i]==1 and y[i]==1)\\n                    s+=2;\\n                    else\\n                    s++;\\n                }\\n                else\\n                {\\n                    s++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n\\n//Must Upvote",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    void decToBinary(int n,int binaryNum[])\\n    {\\n    int i = 0;\\n    while (n > 0)\\n    {\\n        binaryNum[i] = n % 2;\\n        n = n / 2;\\n        i++;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3609196,
                "title": "c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        string x=\"\",y=\"\",z=\"\";\\n        while(a){\\n            if(a%2==1)x+=\\'1\\';\\n            else x+=\\'0\\';\\n            a/=2;\\n        }\\n\\n         while(b){\\n            if(b%2==1)y+=\\'1\\';\\n            else y+=\\'0\\';\\n            b/=2;\\n        }\\n\\n          while(c){\\n            if(c%2==1)z+=\\'1\\';\\n            else z+=\\'0\\';\\n            c/=2;\\n        }\\n       int mx=max({x.size(),y.size(),z.size()});\\n        for(int i=0;i<mx;i++){\\n            if(x.size()<mx){\\n                x+=\\'0\\';\\n            }\\n            if(y.size()<mx){\\n                y+=\\'0\\';\\n            }\\n            if(z.size()<mx){\\n                z+=\\'0\\';\\n            }\\n        }\\n        reverse(x.begin(),x.end());\\n        reverse(y.begin(),y.end());\\n        reverse(z.begin(),z.end());\\n        int cnt=0;\\n        for(int i=0;i<mx;i++){\\n            if(x[i]==\\'0\\'&&y[i]==\\'0\\'&&z[i]==\\'1\\')cnt++;\\n            if(z[i]==\\'0\\'){\\n                if(x[i]==\\'1\\')cnt++;\\n                if(y[i]==\\'1\\')cnt++;\\n            }\\n        }\\n\\n        return cnt;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        string x=\"\",y=\"\",z=\"\";\\n        while(a){\\n            if(a%2==1)x+=\\'1\\';\\n            else x+=\\'0\\';\\n            a/=2;\\n        }\\n\\n         while(b){\\n            if(b%2==1)y+=\\'1\\';\\n            else y+=\\'0\\';\\n            b/=2;\\n        }\\n\\n          while(c){\\n            if(c%2==1)z+=\\'1\\';\\n            else z+=\\'0\\';\\n            c/=2;\\n        }\\n       int mx=max({x.size(),y.size(),z.size()});\\n        for(int i=0;i<mx;i++){\\n            if(x.size()<mx){\\n                x+=\\'0\\';\\n            }\\n            if(y.size()<mx){\\n                y+=\\'0\\';\\n            }\\n            if(z.size()<mx){\\n                z+=\\'0\\';\\n            }\\n        }\\n        reverse(x.begin(),x.end());\\n        reverse(y.begin(),y.end());\\n        reverse(z.begin(),z.end());\\n        int cnt=0;\\n        for(int i=0;i<mx;i++){\\n            if(x[i]==\\'0\\'&&y[i]==\\'0\\'&&z[i]==\\'1\\')cnt++;\\n            if(z[i]==\\'0\\'){\\n                if(x[i]==\\'1\\')cnt++;\\n                if(y[i]==\\'1\\')cnt++;\\n            }\\n        }\\n\\n        return cnt;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609001,
                "title": "easy-0ms-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(log(Math.max(a,b,c)))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minFlips(int a, int b, int c) {\\n        int ans = 0;\\n\\n        \\n        int z = Math.max(c,Math.max(a,b));\\n\\n        while(z>0){\\n            boolean aHasOne = (a & 1) == 1;\\n            boolean bHasOne = (b & 1) == 1;\\n            boolean cHasOne = (c & 1) == 1;\\n            if(aHasOne && bHasOne){\\n                if(!cHasOne)\\n                    ans += 2;\\n            }\\n            else if((aHasOne && !bHasOne) || (!aHasOne && bHasOne)){\\n                if(!cHasOne){\\n                    ans+=1;\\n                }\\n            }\\n            else{\\n                if(cHasOne)\\n                    ans+=1;\\n            }\\n            a = a>>1;\\n            b = b>>1;\\n            c = c>>1;\\n            z = z>>1;\\n        }\\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minFlips(int a, int b, int c) {\\n        int ans = 0;\\n\\n        \\n        int z = Math.max(c,Math.max(a,b));\\n\\n        while(z>0){\\n            boolean aHasOne = (a & 1) == 1;\\n            boolean bHasOne = (b & 1) == 1;\\n            boolean cHasOne = (c & 1) == 1;\\n            if(aHasOne && bHasOne){\\n                if(!cHasOne)\\n                    ans += 2;\\n            }\\n            else if((aHasOne && !bHasOne) || (!aHasOne && bHasOne)){\\n                if(!cHasOne){\\n                    ans+=1;\\n                }\\n            }\\n            else{\\n                if(cHasOne)\\n                    ans+=1;\\n            }\\n            a = a>>1;\\n            b = b>>1;\\n            c = c>>1;\\n            z = z>>1;\\n        }\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608987,
                "title": "solution",
                "content": "\\n# Complexity\\n- Time complexity: O(log_2(max(a,b,c)))\\n\\n- Space complexity:O(log_2(max(a,b,c)))\\n\\n# Code\\n```\\n/**\\n * @param {number} a\\n * @param {number} b\\n * @param {number} c\\n * @return {number}\\n */\\nfunction dec2bin(dec){\\n   return dec.toString(2);\\n}\\nvar minFlips = function(a, b, c) {\\n    let flip =0;\\n    a=dec2bin(a).toString(2).split(\\'\\')\\n    b=dec2bin(b).toString(2).split(\\'\\')\\n    c=dec2bin(c).toString(2).split(\\'\\')\\n\\n    let maxbit = Math.max(a.length, b.length, c.length)\\n\\n    while(maxbit)\\n    {\\n        maxbit--;\\n        const charA = a.length ? a.pop() : \\'0\\';\\n        const charB = b.length ? b.pop() : \\'0\\';\\n        const charC = c.length ? c.pop() : \\'0\\';\\n\\n        if(charC ===\\'0\\'){\\n            if(charA ===\\'1\\') flip++;\\n            if(charB=== \\'1\\') flip++;\\n        }\\n        else {\\n            if(charA === \\'0\\' && charB ===\\'0\\') flip++\\n        }\\n    }\\n    return flip\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} a\\n * @param {number} b\\n * @param {number} c\\n * @return {number}\\n */\\nfunction dec2bin(dec){\\n   return dec.toString(2);\\n}\\nvar minFlips = function(a, b, c) {\\n    let flip =0;\\n    a=dec2bin(a).toString(2).split(\\'\\')\\n    b=dec2bin(b).toString(2).split(\\'\\')\\n    c=dec2bin(c).toString(2).split(\\'\\')\\n\\n    let maxbit = Math.max(a.length, b.length, c.length)\\n\\n    while(maxbit)\\n    {\\n        maxbit--;\\n        const charA = a.length ? a.pop() : \\'0\\';\\n        const charB = b.length ? b.pop() : \\'0\\';\\n        const charC = c.length ? c.pop() : \\'0\\';\\n\\n        if(charC ===\\'0\\'){\\n            if(charA ===\\'1\\') flip++;\\n            if(charB=== \\'1\\') flip++;\\n        }\\n        else {\\n            if(charA === \\'0\\' && charB ===\\'0\\') flip++\\n        }\\n    }\\n    return flip\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3608591,
                "title": "java-solution-for-minimum-flips-to-make-a-or-b-equal-to-c-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the above solution is to compare the bits of a, b, and c to determine the number of flips required to make (a OR b) == c.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize a variable flips to keep track of the total number of flips required.\\n1. Iterate through the bits of a, b, and c by performing a bitwise AND operation with 1 (a & 1, b & 1, c & 1).\\n1. Compare the rightmost bits of a and b with the rightmost bit of c. If (bitA | bitB) != bitC, it means flipping is required.\\n1. If bitC is 0, it implies that the corresponding bit of c is 0. In this case, both bitA and bitB should be flipped to 1, so increment flips by (bitA + bitB).\\n1. If bitC is 1, it implies that the corresponding bit of c is 1. In this case, at least one of bitA or bitB should be flipped to 1, so increment flips by 1.\\n1. Right shift a, b, and c by 1 bit to move to the next bit.\\n1. Repeat steps 2-6 until all bits have been processed.\\n1. Return the final value of flips.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is O(log(max(a, b, c))) since we iterate through the bits of a, b, and c using the right shift operation.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(1) since we use a constant amount of space to store the variables flips, bitA, bitB, and bitC.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minFlips(int a, int b, int c) {\\n        int flips = 0;\\n        int bitA, bitB, bitC;\\n\\n        while (a > 0 || b > 0 || c > 0) \\n        {\\n            bitA = a & 1;  // Get the rightmost bit of a\\n            bitB = b & 1;  // Get the rightmost bit of b\\n            bitC = c & 1;  // Get the rightmost bit of c\\n\\n            if ((bitA | bitB) != bitC) \\n            {\\n                if (bitC == 0) \\n                {\\n                    flips += (bitA + bitB);  // Flip both bits of a and b\\n                } \\n                else \\n                {\\n                    flips += 1;  // Flip any one bit of a or b\\n                }\\n            }\\n\\n            a >>= 1;  // Shift right to get the next bit of a\\n            b >>= 1;  // Shift right to get the next bit of b\\n            c >>= 1;  // Shift right to get the next bit of c\\n        }\\n        return flips;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minFlips(int a, int b, int c) {\\n        int flips = 0;\\n        int bitA, bitB, bitC;\\n\\n        while (a > 0 || b > 0 || c > 0) \\n        {\\n            bitA = a & 1;  // Get the rightmost bit of a\\n            bitB = b & 1;  // Get the rightmost bit of b\\n            bitC = c & 1;  // Get the rightmost bit of c\\n\\n            if ((bitA | bitB) != bitC) \\n            {\\n                if (bitC == 0) \\n                {\\n                    flips += (bitA + bitB);  // Flip both bits of a and b\\n                } \\n                else \\n                {\\n                    flips += 1;  // Flip any one bit of a or b\\n                }\\n            }\\n\\n            a >>= 1;  // Shift right to get the next bit of a\\n            b >>= 1;  // Shift right to get the next bit of b\\n            c >>= 1;  // Shift right to get the next bit of c\\n        }\\n        return flips;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608093,
                "title": "easy-solution-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int res=0;\\n        while(a>0 || b>0 ||c>0){\\n            int bit_a= a&1;\\n            int bit_b= b&1;\\n            int bit_c= c&1;\\n            \\n            if((bit_a | bit_b)!=bit_c){\\n                if(bit_c==1)res++;\\n                else res+=bit_a+bit_b;\\n            }\\n            \\n            a>>=1;\\n            b>>=1;\\n            c>>=1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int res=0;\\n        while(a>0 || b>0 ||c>0){\\n            int bit_a= a&1;\\n            int bit_b= b&1;\\n            int bit_c= c&1;\\n            \\n            if((bit_a | bit_b)!=bit_c){\\n                if(bit_c==1)res++;\\n                else res+=bit_a+bit_b;\\n            }\\n            \\n            a>>=1;\\n            b>>=1;\\n            c>>=1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607757,
                "title": "easy-to-understand-simple-and-efficient-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int flips = 0;\\n        \\n        // Iterate through the bits of a, b, and c\\n        while (a > 0 || b > 0 || c > 0) {\\n            int bit_a = a & 1;  // Get the least significant bit of a\\n            int bit_b = b & 1;  // Get the least significant bit of b\\n            int bit_c = c & 1;  // Get the least significant bit of c\\n\\n            // Check if the least significant bit of c is 0\\n            if (bit_c == 0) {\\n                // If c is 0, both a and b should have their corresponding bits as 0\\n                // Add the sum of bit_a and bit_b to flips to account for the necessary flips\\n                flips += (bit_a + bit_b);\\n            } else {\\n                // If c is 1, at least one of a and b should have its corresponding bit as 1\\n                if (bit_a == 0 && bit_b == 0) {\\n                    // If both bit_a and bit_b are 0, increment flips by 1 to indicate the need for a flip\\n                    flips += 1;\\n                }\\n            }\\n\\n            // Shift bits to the right\\n            a >>= 1;\\n            b >>= 1;\\n            c >>= 1;\\n        }\\n\\n        return flips;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int flips = 0;\\n        \\n        // Iterate through the bits of a, b, and c\\n        while (a > 0 || b > 0 || c > 0) {\\n            int bit_a = a & 1;  // Get the least significant bit of a\\n            int bit_b = b & 1;  // Get the least significant bit of b\\n            int bit_c = c & 1;  // Get the least significant bit of c\\n\\n            // Check if the least significant bit of c is 0\\n            if (bit_c == 0) {\\n                // If c is 0, both a and b should have their corresponding bits as 0\\n                // Add the sum of bit_a and bit_b to flips to account for the necessary flips\\n                flips += (bit_a + bit_b);\\n            } else {\\n                // If c is 1, at least one of a and b should have its corresponding bit as 1\\n                if (bit_a == 0 && bit_b == 0) {\\n                    // If both bit_a and bit_b are 0, increment flips by 1 to indicate the need for a flip\\n                    flips += 1;\\n                }\\n            }\\n\\n            // Shift bits to the right\\n            a >>= 1;\\n            b >>= 1;\\n            c >>= 1;\\n        }\\n\\n        return flips;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607738,
                "title": "beats-100-time-o-1-space-o-1-easy-solution-pen-paper-explaination",
                "content": "# Intuition\\n\\nThe given code is an implementation of a function named minFlips that calculates the minimum number of flips required to convert two integers a and b to an integer c. The approach used in this code is to convert the decimal representations of a, b, and c into binary representations and compare the corresponding bits. By comparing the bits, the code determines whether a flip is required or not.\\n\\n# Approach & Explaination of code\\n<!-- Describe your approach to solving the problem. -->\\n- The binary function is defined to convert a decimal number to its binary representation. It takes a number num and a reference to a vector arr where the binary representation of num will be stored.\\n- Inside the binary function, a loop iterates from 31 to 0, representing the 32 bits of an integer.\\n- In each iteration, the i-th bit of num is extracted using the right shift operator (>>) and bitwise AND operator (&) with 1. The result is stored in the i-th index of arr.\\n- The minFlips function takes three integers a, b, and c as input.\\n- Three vectors hasha, hashb, and hashc are defined to store the binary representations of a, b, and c respectively.\\n- The binary function is called three times to convert a, b, and c to binary and store them in the respective vectors.\\n- A variable count is initialized to 0, which will store the minimum number of flips required.\\n- A loop iterates from 0 to 31, representing the 32 bits of the integers.\\n- Inside the loop, if the i-th bit of hashc is 0, it means that the corresponding bits in a and b should be flipped to match the i-th bit of c. So, count is incremented by the sum of the i-th bits of hasha and hashb.\\n- If the i-th bit of hashc is 1, it means that the corresponding bits in a and b should remain unchanged to match the i-th bit of c. So, if the sum of the i-th bits of hasha and hashb is 0, it indicates that a flip is required, and count is incremented by 1.\\n- After the loop completes, the final value of count represents the minimum number of flips required.\\n\\n   The count variable is returned as the output of the minFlips function.\\n\\n\\n![photo_2023-06-07_11-42-28.jpg](https://assets.leetcode.com/users/images/0e63e691-9b6e-44aa-a74a-df1e4c999dd8_1686118416.868102.jpeg)\\n\\n# Time complexity:\\n\\n- The time complexity of this code is O(1) because the loop iterates 32 times, which is a constant value irrespective of the input. The binary conversion process takes constant time as well.\\n\\n\\n\\n\\n# Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- The space complexity of this code is O(1) because the space required to store the binary representations of the numbers is fixed. The vectors hasha, hashb, and hashc each have a size of 32, which is a constant value.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    //utility function to convert a decimal number to binary\\n    void binary(int num,vector<int>&arr)\\n    {\\n    for (int i = 31; i >= 0; --i)\\n    {\\n        arr[i]=((num >> i) & 1);\\n    }\\n    }\\n\\n    int minFlips(int a, int b, int c) {\\n    vector<int>hasha(32);\\n    vector<int>hashb(32);\\n    vector<int>hashc(32);\\n  \\n    binary(a,hasha);\\n    binary(b,hashb);\\n    binary(c,hashc);\\n\\n    int count=0;\\n\\n    for(int i=0;i<=31;i++)\\n    {\\n        if(hashc[i]==0)\\n        {\\n             count+=(hasha[i]+hashb[i]);\\n        }\\n        else\\n        {\\n             if((hasha[i]+hashb[i])==0)\\n             {\\n                 count++;\\n             }\\n        }\\n    }\\n\\n    return count;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    //utility function to convert a decimal number to binary\\n    void binary(int num,vector<int>&arr)\\n    {\\n    for (int i = 31; i >= 0; --i)\\n    {\\n        arr[i]=((num >> i) & 1);\\n    }\\n    }\\n\\n    int minFlips(int a, int b, int c) {\\n    vector<int>hasha(32);\\n    vector<int>hashb(32);\\n    vector<int>hashc(32);\\n  \\n    binary(a,hasha);\\n    binary(b,hashb);\\n    binary(c,hashc);\\n\\n    int count=0;\\n\\n    for(int i=0;i<=31;i++)\\n    {\\n        if(hashc[i]==0)\\n        {\\n             count+=(hasha[i]+hashb[i]);\\n        }\\n        else\\n        {\\n             if((hasha[i]+hashb[i])==0)\\n             {\\n                 count++;\\n             }\\n        }\\n    }\\n\\n    return count;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607722,
                "title": "minimum-flips-to-make-a-or-b-equal-c-easiest-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:```O(max(N1,N2,N3))```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:```O(N1)+O(N2)+O(N2)```\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate: \\nstring NumToBits(int val){\\n    string str=\"\";\\n    while(val>0){\\n        if(val%2==0) str+=\\'0\\';\\n        else str+=\\'1\\';\\n        val/=2;\\n    }\\n    return str;\\n}\\npublic:\\n    int minFlips(int a, int b, int c) {\\n       string str1=NumToBits(a);\\n       string str2=NumToBits(b);\\n       string str3=NumToBits(c);\\n       int maxSize = max(str1.size(),max(str2.size(),str3.size()));\\n       int cnt = 0;\\n       int start  = 0;\\n\\n       while(start < maxSize){\\n           char ch1,ch2,ch3;\\n           if(start < str1.size()) ch1=str1[start];\\n           else ch1 =\\'0\\';\\n           if(start < str2.size()) ch2=str2[start];\\n           else ch2 =\\'0\\';\\n           if(start < str3.size()) ch3=str3[start];\\n           else ch3 =\\'0\\';\\n\\n           if(ch3==\\'0\\'){\\n              if(ch1==\\'1\\') cnt++;\\n              if(ch2==\\'1\\') cnt++;\\n           }\\n           else if(ch1==\\'0\\' && ch2==\\'0\\') cnt++; \\n           start++;\\n       }\\n       return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```O(max(N1,N2,N3))```\n```O(N1)+O(N2)+O(N2)```\n```\\nclass Solution {\\nprivate: \\nstring NumToBits(int val){\\n    string str=\"\";\\n    while(val>0){\\n        if(val%2==0) str+=\\'0\\';\\n        else str+=\\'1\\';\\n        val/=2;\\n    }\\n    return str;\\n}\\npublic:\\n    int minFlips(int a, int b, int c) {\\n       string str1=NumToBits(a);\\n       string str2=NumToBits(b);\\n       string str3=NumToBits(c);\\n       int maxSize = max(str1.size(),max(str2.size(),str3.size()));\\n       int cnt = 0;\\n       int start  = 0;\\n\\n       while(start < maxSize){\\n           char ch1,ch2,ch3;\\n           if(start < str1.size()) ch1=str1[start];\\n           else ch1 =\\'0\\';\\n           if(start < str2.size()) ch2=str2[start];\\n           else ch2 =\\'0\\';\\n           if(start < str3.size()) ch3=str3[start];\\n           else ch3 =\\'0\\';\\n\\n           if(ch3==\\'0\\'){\\n              if(ch1==\\'1\\') cnt++;\\n              if(ch2==\\'1\\') cnt++;\\n           }\\n           else if(ch1==\\'0\\' && ch2==\\'0\\') cnt++; \\n           start++;\\n       }\\n       return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607616,
                "title": "0ms-solution-bit-manipulation",
                "content": "# Intuition\\nCheck the bits of $a$ and $b$ are equal to $c$ through $OR(a|b)$ Operation i.e., check if the $a | b = c$.\\n\\n# Approach\\nIf the bit in $c$ is **set**.\\nThen check if either of the bits in $a$ and $b$ are set, since **atleast** one bit of $a$ is set or $b$ is set then we can make $a|b = c$.\\n\\nIf the bit in $c$ is **not set**.\\nThen check if **none** of the bits in $a$ and $b$ are set, since if a bit is set in either of $a$ or $b$ are set the $OR$ operation will make them set making them not equal to $c$.\\n\\n\\n# Complexity\\n- Time complexity: $$O(log(max(a, b, c)))$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int cnt = 0;\\n        while(c || (a | b))\\n        {\\n            bool cBit = (c&1);\\n            bool aBit = (a&1);\\n            bool bBit = (b&1);\\n            if(cBit)\\n            {\\n                if(aBit || bBit)\\n                {\\n                    // Do Nothing\\n                }\\n                else\\n                {\\n                    cnt++;\\n                }\\n            }\\n            else\\n            {\\n                if(aBit)\\n                {\\n                    cnt++;\\n                }\\n                if(bBit)\\n                {\\n                    cnt++;\\n                }\\n            }\\n            a >>= 1;\\n            b >>= 1;\\n            c >>= 1;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n# Similar Question:\\nhttps://leetcode.com/problems/minimum-bit-flips-to-convert-number/description/\\n**My Solution:** https://leetcode.com/problems/minimum-bit-flips-to-convert-number/solutions/3608176/0ms-solution-bit-manipulation/",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int cnt = 0;\\n        while(c || (a | b))\\n        {\\n            bool cBit = (c&1);\\n            bool aBit = (a&1);\\n            bool bBit = (b&1);\\n            if(cBit)\\n            {\\n                if(aBit || bBit)\\n                {\\n                    // Do Nothing\\n                }\\n                else\\n                {\\n                    cnt++;\\n                }\\n            }\\n            else\\n            {\\n                if(aBit)\\n                {\\n                    cnt++;\\n                }\\n                if(bBit)\\n                {\\n                    cnt++;\\n                }\\n            }\\n            a >>= 1;\\n            b >>= 1;\\n            c >>= 1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607550,
                "title": "check-for-every-bit-and-take-action-accordingly-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        \\n        int flip=0;\\n        for(int i=0;i<=31;i++)\\n        {\\n            int bita=(a>>i)&1; \\n            int bitb=(b>>i)&1;\\n            int bitc=(c>>i)&1;\\n            \\n            int orOfab=(bita | bitb);\\n            if(bitc ==orOfab ) continue;\\n            if(bitc==1 && orOfab==0) flip++;\\n            else if(bitc==0 && bita==1 && bitb==1) flip+=2;\\n            else  if(bitc==0 && orOfab==1) flip++;\\n          \\n        }\\n        return flip;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        \\n        int flip=0;\\n        for(int i=0;i<=31;i++)\\n        {\\n            int bita=(a>>i)&1; \\n            int bitb=(b>>i)&1;\\n            int bitc=(c>>i)&1;\\n            \\n            int orOfab=(bita | bitb);\\n            if(bitc ==orOfab ) continue;\\n            if(bitc==1 && orOfab==0) flip++;\\n            else if(bitc==0 && bita==1 && bitb==1) flip+=2;\\n            else  if(bitc==0 && orOfab==1) flip++;\\n          \\n        }\\n        return flip;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607422,
                "title": "simple-c-o-32-t-o-1-s-bit-runtime-100ms-memory-93-33",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBy seeing the test cases we can thought of bitwise operations.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDo what the question demanding.Use simple approach to  get the ith bit of c and update the answer by seeing ith bit of a and b respectively.Below is the c++ code for better understanding.\\nIf you understand the problem. Then plz upvote me.\\n\\n\\n# Complexity\\n- Time complexity:O(32)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int ans=0;\\n        \\n        for(int i=0;i<32;i++){\\n            int mask=0;\\n            if(((1<<i)&c)>0) mask=1;\\n        \\n            if(mask==0){\\n                if((a&(1<<i))!=0 && (b&(1<<i))!=0) ans+=2;\\n                else if((a&(1<<i))!=0 || (b&(1<<i))!=0) ans+=1;\\n            }\\n            else if(mask==1){\\n                if((a&(1<<i))==0 && (b&(1<<i))==0) ans+=1;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int ans=0;\\n        \\n        for(int i=0;i<32;i++){\\n            int mask=0;\\n            if(((1<<i)&c)>0) mask=1;\\n        \\n            if(mask==0){\\n                if((a&(1<<i))!=0 && (b&(1<<i))!=0) ans+=2;\\n                else if((a&(1<<i))!=0 || (b&(1<<i))!=0) ans+=1;\\n            }\\n            else if(mask==1){\\n                if((a&(1<<i))==0 && (b&(1<<i))==0) ans+=1;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606965,
                "title": "easy-python-solution-in-o-n-time-bit-manipulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        ba=bin(a)[2:]\\n        bb=bin(b)[2:]\\n        bc=bin(c)[2:]\\n        n=max(len(ba),len(bb),len(bc))\\n        ba=\"0\"*(n-len(ba))+ba\\n        bb=\"0\"*(n-len(bb))+bb\\n        bc=\"0\"*(n-len(bc))+bc\\n        ct=0\\n        for i in range(n):\\n            if bc[i]==\"0\":\\n                if ba[i]==\"1\":\\n                    ct+=1\\n                if bb[i]==\"1\":\\n                    ct+=1\\n            else:\\n                if ba[i]==\"1\"or bb[i]==\"1\":\\n                    continue\\n                else:\\n                    ct+=1\\n        return ct\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        ba=bin(a)[2:]\\n        bb=bin(b)[2:]\\n        bc=bin(c)[2:]\\n        n=max(len(ba),len(bb),len(bc))\\n        ba=\"0\"*(n-len(ba))+ba\\n        bb=\"0\"*(n-len(bb))+bb\\n        bc=\"0\"*(n-len(bc))+bc\\n        ct=0\\n        for i in range(n):\\n            if bc[i]==\"0\":\\n                if ba[i]==\"1\":\\n                    ct+=1\\n                if bb[i]==\"1\":\\n                    ct+=1\\n            else:\\n                if ba[i]==\"1\"or bb[i]==\"1\":\\n                    continue\\n                else:\\n                    ct+=1\\n        return ct\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606886,
                "title": "c-using-bitset-easy-implementation",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        bitset<32> A(a);\\n        bitset<32> B(b);\\n        bitset<32> C(c);\\n\\n        string x=A.to_string();\\n        string y=B.to_string();\\n        string z=C.to_string();\\n        \\n        int res=0;\\n        for(int i=31;i>=0;i--){\\n            int a=x[i]-\\'0\\';\\n            int b=y[i]-\\'0\\';\\n            int c=z[i]-\\'0\\';\\n            if((a or b)!=c){\\n                if(c==0 and a==1 and b==1){\\n                    res+=2;\\n                }\\n                else{\\n                    res+=1;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        bitset<32> A(a);\\n        bitset<32> B(b);\\n        bitset<32> C(c);\\n\\n        string x=A.to_string();\\n        string y=B.to_string();\\n        string z=C.to_string();\\n        \\n        int res=0;\\n        for(int i=31;i>=0;i--){\\n            int a=x[i]-\\'0\\';\\n            int b=y[i]-\\'0\\';\\n            int c=z[i]-\\'0\\';\\n            if((a or b)!=c){\\n                if(c==0 and a==1 and b==1){\\n                    res+=2;\\n                }\\n                else{\\n                    res+=1;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606789,
                "title": "c-1-line-solution",
                "content": "![image](https://assets.leetcode.com/users/images/3588d2ae-8ad0-484c-adcc-05a68940b5d2_1686101052.0535266.png)\\n \\n \\n return (__builtin_popcount(c^=a|b)+__builtin_popcount(a&b&c));\\n\\n",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/3588d2ae-8ad0-484c-adcc-05a68940b5d2_1686101052.0535266.png)\\n \\n \\n return (__builtin_popcount(c^=a|b)+__builtin_popcount(a&b&c));\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3606673,
                "title": "w-explanation-python-c-solutions-using-bitset-bin",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBit Manipulation uses bitset/bin for C++/Python.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code with explanation Beats 100% w 0 ms\\n```\\nclass Solution {\\npublic:\\n// Function to calculate the minimum number of flips \\n//required to make \\'a\\' and \\'b\\' equal to \\'c\\'\\n    int minFlips(int a, int b, int c) { \\n// Calculate the bits that need to be flipped \\n// in order to make \\'a\\' or \\'b\\' equal to \\'c\\'\\n        int xx = (a | b) ^ c;\\n\\n        // Convert the integer \\'xx\\' to a bitset of size 32\\n        bitset<32> x(xx);\\n\\n        // Calculate the bits that are 1 \\n        // in both \\'a\\', \\'b\\', and \\'xx\\' (common bits)\\n        bitset<32> y(a & b & xx);\\n\\n        // Return the sum of the number of bits \\n        //that need to be flipped in \\'x\\' and \\'y\\'\\n        return x.count() + y.count();\\n    }\\n};\\n\\n```\\n# Python Code\\n```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        xx=(a|b)^c\\n        yy=a&b&xx\\n        return bin(xx).count(\\'1\\')+bin(yy).count(\\'1\\')\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n// Function to calculate the minimum number of flips \\n//required to make \\'a\\' and \\'b\\' equal to \\'c\\'\\n    int minFlips(int a, int b, int c) { \\n// Calculate the bits that need to be flipped \\n// in order to make \\'a\\' or \\'b\\' equal to \\'c\\'\\n        int xx = (a | b) ^ c;\\n\\n        // Convert the integer \\'xx\\' to a bitset of size 32\\n        bitset<32> x(xx);\\n\\n        // Calculate the bits that are 1 \\n        // in both \\'a\\', \\'b\\', and \\'xx\\' (common bits)\\n        bitset<32> y(a & b & xx);\\n\\n        // Return the sum of the number of bits \\n        //that need to be flipped in \\'x\\' and \\'y\\'\\n        return x.count() + y.count();\\n    }\\n};\\n\\n```\n```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        xx=(a|b)^c\\n        yy=a&b&xx\\n        return bin(xx).count(\\'1\\')+bin(yy).count(\\'1\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467525,
                "title": "python-simple-clean-solution-using-bit-manipulation",
                "content": "# Code\\n\\n```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        if a | b == c: return 0\\n        c = (\\'0\\' * 32 + bin(c)[2:])[-32:]\\n        a = (\\'0\\' * 32 + bin(a)[2:])[-32:]\\n        b = (\\'0\\' * 32 + bin(b)[2:])[-32:]\\n        \\n        \\n        cnt = 0\\n        for i in range(len(c)):\\n            if c[i] == \\'1\\':\\n                if not (a[i] == c[i] or b[i] == c[i]):\\n                    cnt += 1\\n            else:\\n                if a[i] != c[i]:\\n                    cnt += 1\\n                if b[i] != c[i]:\\n                    cnt += 1\\n        return cnt\\n```\\n\\n## Bit Manipulation\\n```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        return bin((a | b) ^ c).count(\\'1\\') + bin(a & b & ((a | b) ^ c)).count(\\'1\\')\\n```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        if a | b == c: return 0\\n        c = (\\'0\\' * 32 + bin(c)[2:])[-32:]\\n        a = (\\'0\\' * 32 + bin(a)[2:])[-32:]\\n        b = (\\'0\\' * 32 + bin(b)[2:])[-32:]\\n        \\n        \\n        cnt = 0\\n        for i in range(len(c)):\\n            if c[i] == \\'1\\':\\n                if not (a[i] == c[i] or b[i] == c[i]):\\n                    cnt += 1\\n            else:\\n                if a[i] != c[i]:\\n                    cnt += 1\\n                if b[i] != c[i]:\\n                    cnt += 1\\n        return cnt\\n```\n```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        return bin((a | b) ^ c).count(\\'1\\') + bin(a & b & ((a | b) ^ c)).count(\\'1\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284481,
                "title": "c-bitset",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        bitset<32> A(a);\\n        bitset<32> B(b);\\n        bitset<32> C(c);\\n\\n        string x=A.to_string();\\n        string y=B.to_string();\\n        string z=C.to_string();\\n\\n        int res=0;\\n        for(int i=31;i>=0;i--){\\n            int a=x[i]-\\'0\\';\\n            int b=y[i]-\\'0\\';\\n            int c=z[i]-\\'0\\';\\n            if((a or b)!=c){\\n                if(c==0 and a==1 and b==1){\\n                    res+=2;\\n                }\\n                else{\\n                    res+=1;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        bitset<32> A(a);\\n        bitset<32> B(b);\\n        bitset<32> C(c);\\n\\n        string x=A.to_string();\\n        string y=B.to_string();\\n        string z=C.to_string();\\n\\n        int res=0;\\n        for(int i=31;i>=0;i--){\\n            int a=x[i]-\\'0\\';\\n            int b=y[i]-\\'0\\';\\n            int c=z[i]-\\'0\\';\\n            if((a or b)!=c){\\n                if(c==0 and a==1 and b==1){\\n                    res+=2;\\n                }\\n                else{\\n                    res+=1;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096893,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn min_flips(a: i32, b: i32, c: i32) -> i32 {\\n        let mut a = a;\\n        let mut b = b;\\n        let mut c = c;\\n        let mut count = 0;\\n        while a > 0 || b > 0 || c > 0 {\\n            let a_bit = a & 1;\\n            let b_bit = b & 1;\\n            let c_bit = c & 1;\\n            if c_bit == 0 {\\n                count += a_bit + b_bit;\\n            } else if a_bit == 0 && b_bit == 0 {\\n                count += 1;\\n            }\\n            a >>= 1;\\n            b >>= 1;\\n            c >>= 1;\\n        }\\n        count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_flips(a: i32, b: i32, c: i32) -> i32 {\\n        let mut a = a;\\n        let mut b = b;\\n        let mut c = c;\\n        let mut count = 0;\\n        while a > 0 || b > 0 || c > 0 {\\n            let a_bit = a & 1;\\n            let b_bit = b & 1;\\n            let c_bit = c & 1;\\n            if c_bit == 0 {\\n                count += a_bit + b_bit;\\n            } else if a_bit == 0 && b_bit == 0 {\\n                count += 1;\\n            }\\n            a >>= 1;\\n            b >>= 1;\\n            c >>= 1;\\n        }\\n        count\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2921001,
                "title": "simply-written-in-c",
                "content": "# Complexity\\n- Time complexity:O(32)=O(1) constant time\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinFlips(int a, int b, int c) {\\n        \\n        int aorb=a|b;\\n        int flips=0;\\n\\n        for(int i=0;i<32;i++)\\n        {\\n            if((aorb>>i&1) != (c>>i&1))\\n            {\\n                if((c>>i&1)==0 && (a>>i &1)==1 && (b>>i&1)==1)\\n                    flips=flips+2;\\n                else\\n                  flips=flips+1;\\n            }\\n        }\\n        return flips;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinFlips(int a, int b, int c) {\\n        \\n        int aorb=a|b;\\n        int flips=0;\\n\\n        for(int i=0;i<32;i++)\\n        {\\n            if((aorb>>i&1) != (c>>i&1))\\n            {\\n                if((c>>i&1)==0 && (a>>i &1)==1 && (b>>i&1)==1)\\n                    flips=flips+2;\\n                else\\n                  flips=flips+1;\\n            }\\n        }\\n        return flips;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2596781,
                "title": "c-bit-manipulation-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFlips(int &a, int &b, int &c) {\\n        int x = 0;\\n        while(a || b || c){\\n            if(c&1){\\n                if(!(a&1) && !(b & 1)){\\n                    x++;\\n                }\\n            }else{\\n                if((a&1) && (b & 1)){\\n                    x+=2;\\n                }else if((a&1) || (b & 1))x += 1;\\n            }\\n            a >>=1;b >>= 1;c >>=1;\\n        }\\n        return x;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minFlips(int &a, int &b, int &c) {\\n        int x = 0;\\n        while(a || b || c){\\n            if(c&1){\\n                if(!(a&1) && !(b & 1)){\\n                    x++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2509241,
                "title": "c-checking-the-ith-bit-of-a-b-and-c-100-faster-tc-o-32",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int cnt=0;\\n        int n=32;\\n        for(int i=0;i<32;i++){\\n            int l=(a>>i)&1, j=(b>>i)&1, k=(c>>i)&1;\\n            //cout<<l<<\" \"<<j<<\" \"<<k<<endl;\\n            if(k==1){\\n                if(l==1 || j==1){}\\n                else{\\n                    cnt++;\\n                }\\n            }\\n            else{\\n                if(l==1 && j==1){\\n                    cnt+=2;\\n                }\\n                else if(l==1 || j==1){\\n                    cnt++;\\n                }\\n           }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int cnt=0;\\n        int n=32;\\n        for(int i=0;i<32;i++){\\n            int l=(a>>i)&1, j=(b>>i)&1, k=(c>>i)&1;\\n            //cout<<l<<\" \"<<j<<\" \"<<k<<endl;\\n            if(k==1){\\n                if(l==1 || j==1){}\\n                else{\\n                    cnt++;\\n                }\\n            }\\n            else{\\n                if(l==1 && j==1){\\n                    cnt+=2;\\n                }\\n                else if(l==1 || j==1){\\n                    cnt++;\\n                }\\n           }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1803783,
                "title": "python-solution",
                "content": "\\n```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        ans=0\\n        while(c | a | b):\\n            if(c&1):\\n                if((a&1)==0 and (b&1)==0):\\n                    ans+=1\\n            \\n            else:\\n                if(a&1 and b&1):\\n                    ans+=2;\\n                elif(a&1 or b&1):\\n                    ans+=1\\n            \\n            c>>=1\\n            b>>=1\\n            a>>=1\\n        \\n        return ans;\\n    \\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        ans=0\\n        while(c | a | b):\\n            if(c&1):\\n                if((a&1)==0 and (b&1)==0):\\n                    ans+=1\\n            \\n            else:\\n                if(a&1 and b&1):\\n                    ans+=2;\\n                elif(a&1 or b&1):\\n                    ans+=1\\n            \\n            c>>=1\\n            b>>=1\\n            a>>=1\\n        \\n        return ans;\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498105,
                "title": "java-easy-to-understand-0-ms-fastest-bruteforce-solution-bit-manipulation",
                "content": "```\\nclass Solution {\\n    public int minFlips(int a, int b, int c) {\\n        int count=0;\\n        \\n        while(a != 0 || b != 0 || c != 0)\\n        {\\n            int A = a&1;\\n            int B = b&1;\\n            int C = c&1;\\n            if(C == 1)\\n            {\\n                if(A == 0 && B == 0)\\n                    count++;\\n            }\\n            else if(C == 0)\\n            {\\n                if(A == 1 && B == 1)\\n                    count += 2;\\n                else if(A == 1 || B == 1)\\n                    count++;\\n            }\\n            a = a>>1;\\n            b = b>>1;\\n            c = c>>1;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minFlips(int a, int b, int c) {\\n        int count=0;\\n        \\n        while(a != 0 || b != 0 || c != 0)\\n        {\\n            int A = a&1;\\n            int B = b&1;\\n            int C = c&1;\\n            if(C == 1)\\n            {\\n                if(A == 0 && B == 0)\\n                    count++;\\n            }\\n            else if(C == 0)\\n            {\\n                if(A == 1 && B == 1)\\n                    count += 2;\\n                else if(A == 1 || B == 1)\\n                    count++;\\n            }\\n            a = a>>1;\\n            b = b>>1;\\n            c = c>>1;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346687,
                "title": "c-0ms-solution",
                "content": "class Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int flip = 0;\\n         int k = log2(max(a , max(b ,c)));\\n        for(int i = 0; i <= k; i++){\\n            if((c & (1 << i)) == 0){\\n                if((a & (1 << i)) && (b & (1 << i))) flip += 2;\\n                else if((a & (1 << i)) || (b & (1 << i))) flip += 1;\\n            }\\n            else{\\n                 if(((a & (1 << i)) == 0) && ((b & (1 << i)) == 0)) flip += 1;\\n            }\\n        }\\n        return flip;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int flip = 0;\\n         int k = log2(max(a , max(b ,c)));\\n        for(int i = 0; i <= k; i++){\\n            if((c & (1 << i)) == 0){\\n                if((a & (1 << i)) && (b & (1 << i))) flip += 2;\\n                else if((a & (1 << i)) || (b & (1 << i))) flip += 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1202317,
                "title": "runtime-4-ms-faster-than-100-00-of-c-online-submissions",
                "content": "class Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int ans=0;\\n        while(c>0 || (a>0 || b>0))\\n        {\\n            if(a&1 && b&1)\\n            {\\n                if((c&1)==0)\\n                {\\n                    ans+=2;\\n                cout<<\"A\";\\n                }\\n            }\\n            else if((a&1 || b&1 )!=(c&1))\\n            {\\n                cout<<(a&1 || b&1 )<<\"->\"<<(c&1)<<endl;\\n                ans++;\\n                cout<<\"B\";\\n            }\\n            a=a>>1;\\n            b=b>>1;\\n            c=c>>1;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int ans=0;\\n        while(c>0 || (a>0 || b>0))\\n        {\\n            if(a&1 && b&1)\\n            {\\n                if((c&1)==0)\\n                {\\n                    ans+=2;\\n                cout<<\"A\";\\n                }",
                "codeTag": "C++"
            },
            {
                "id": 499383,
                "title": "simple-java-beats-100-space-and-time-best-solution-yet",
                "content": "\\n    public int minFlips(int a, int b, int c) {\\n        int sum = 0;\\n         while (a>0 || b>0) {\\n             int last_bit_a = (a&1);\\n             int last_bit_b = (b&1);\\n             int last_bit_c = (c&1);\\n             if(last_bit_c > 0){\\n                  if ((last_bit_a == 0 && last_bit_b == 0)) {\\n                 sum+=1;\\n             }else if (last_bit_a > 0 && last_bit_b > 0 ) {\\n                      sum+=0;\\n                  } else {\\n                      sum+=0;\\n                  }\\n             \\n             }else {\\n                  if ((last_bit_a == 0 && last_bit_b == 0)) {\\n                 sum+=0;\\n             }else if (last_bit_a > 0 && last_bit_b > 0 ) {\\n                      sum+=2;\\n                  } else {\\n                      sum+=1;\\n                  }\\n             }\\n             c = c >> 1;\\n             a = a >> 1;\\n             b = b >> 1;\\n          }\\n        int x = Integer.bitCount(c);\\n        return sum+x;\\n    }\\n",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "\\n    public int minFlips(int a, int b, int c) {\\n        int sum = 0;\\n         while (a>0 || b>0) {\\n             int last_bit_a = (a&1);\\n             int last_bit_b = (b&1);\\n             int last_bit_c = (c&1);\\n             if(last_bit_c > 0){\\n                  if ((last_bit_a == 0 && last_bit_b == 0)) {\\n                 sum+=1;\\n             }else if (last_bit_a > 0 && last_bit_b > 0 ) {\\n                      sum+=0;\\n                  } else {\\n                      sum+=0;\\n                  }\\n             \\n             }else {\\n                  if ((last_bit_a == 0 && last_bit_b == 0)) {\\n                 sum+=0;\\n             }else if (last_bit_a > 0 && last_bit_b > 0 ) {\\n                      sum+=2;\\n                  } else {\\n                      sum+=1;\\n                  }\\n             }\\n             c = c >> 1;\\n             a = a >> 1;\\n             b = b >> 1;\\n          }\\n        int x = Integer.bitCount(c);\\n        return sum+x;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 483741,
                "title": "c-solution-converting-the-numbers-to-binary-then-traverse",
                "content": "```\\nclass Solution {\\n\\t// converting a number to its binary version\\n    string binarize(int a) {\\n        string ret = \"\";\\n        while(a > 0) {\\n            ret = string(1, a % 2 + \\'0\\') + ret;\\n            a /= 2;\\n        }\\n        return ret;\\n    }\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        string a_s = binarize(a);\\n        string b_s = binarize(b);\\n        string c_s = binarize(c);\\n        int max_len = max(max(a_s.length(), b_s.length()), c_s.length());\\n\\t\\t// appending \\'0\\'s in front of each number\\n        a_s = string(max_len - a_s.length(), \\'0\\') + a_s;\\n        b_s = string(max_len - b_s.length(), \\'0\\') + b_s;\\n        c_s = string(max_len - c_s.length(), \\'0\\') + c_s;\\n        int ret = 0;\\n\\t\\t// traverse the numbers\\n        for(int i = 0; i < max_len; i++) {\\n            if(c_s[i] == \\'0\\') {\\n                if(a_s[i] == \\'1\\') // flip i-th character of a\\n                    ret++;\\n                if(b_s[i] == \\'1\\') // flip i-th character of b\\n                    ret++;\\n            }\\n            if(c_s[i] == \\'1\\') {\\n                if(a_s[i] == \\'0\\' && b_s[i] == \\'0\\') // flip both i-th character of a and b at the same time\\n                    ret++;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\t// converting a number to its binary version\\n    string binarize(int a) {\\n        string ret = \"\";\\n        while(a > 0) {\\n            ret = string(1, a % 2 + \\'0\\') + ret;\\n            a /= 2;\\n        }\\n        return ret;\\n    }\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        string a_s = binarize(a);\\n        string b_s = binarize(b);\\n        string c_s = binarize(c);\\n        int max_len = max(max(a_s.length(), b_s.length()), c_s.length());\\n\\t\\t// appending \\'0\\'s in front of each number\\n        a_s = string(max_len - a_s.length(), \\'0\\') + a_s;\\n        b_s = string(max_len - b_s.length(), \\'0\\') + b_s;\\n        c_s = string(max_len - c_s.length(), \\'0\\') + c_s;\\n        int ret = 0;\\n\\t\\t// traverse the numbers\\n        for(int i = 0; i < max_len; i++) {\\n            if(c_s[i] == \\'0\\') {\\n                if(a_s[i] == \\'1\\') // flip i-th character of a\\n                    ret++;\\n                if(b_s[i] == \\'1\\') // flip i-th character of b\\n                    ret++;\\n            }\\n            if(c_s[i] == \\'1\\') {\\n                if(a_s[i] == \\'0\\' && b_s[i] == \\'0\\') // flip both i-th character of a and b at the same time\\n                    ret++;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 478481,
                "title": "c-single-line-actually-o-1-as-opposed-to-o-number-of-bits",
                "content": "OK... I\\'m spreading the code over three lines for readability. \\uD83D\\uDE09\\n\\n```C++\\nint minFlips(int a, int b, int c) {\\n  return bitset<30>(~(a|b) &  c).count() + // number of bits to flip to 1\\n         bitset<30>( a     & ~c).count() + // number of bits to flip to 0 in a\\n         bitset<30>( b     & ~c).count();  // number of bits to flip to 0 in b\\n}\\n```\\n\\nMost (if not all) solutions claiming **O(1)** runtime seem to still be iterating over all bits. I would argue that\\'s actually **O(number of bits)** or **O(log a|b|c)**. I realize that the maximum limit of `a`, `b` and `c` are given in the problem description. But by that reasoning, aren\\'t _all_ algorithms O(1)? LeetCode provides constraints for all its recent problems.\\n\\nBut something like [`bitset<30>(x)::count()`](https://en.cppreference.com/w/cpp/utility/bitset) can be optimized by the compiler. For example, GCC will optimize it to [`__builtin_popcount(x)`](https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html#index-_005f_005fbuiltin_005fpopcount), which uses a lookup table for each byte, or to a CPU specific instruction like [`POPCNT`](https://en.wikipedia.org/wiki/SSE4#POPCNT_and_LZCNT), which can do a whole integer at once. To enable that instruction for Intel processors, you can add the following line of code:\\n\\n```C++\\n#pragma GCC target (\"sse4.2\")\\n```\\n\\nThat actually works on LeetCode. Try running `bitset<32>(x)::count()` many times in a loop, both with and without the pragma.",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\nint minFlips(int a, int b, int c) {\\n  return bitset<30>(~(a|b) &  c).count() + // number of bits to flip to 1\\n         bitset<30>( a     & ~c).count() + // number of bits to flip to 0 in a\\n         bitset<30>( b     & ~c).count();  // number of bits to flip to 0 in b\\n}\\n```\n```C++\\n#pragma GCC target (\"sse4.2\")\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 477825,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public int MinFlips(int a, int b, int c) \\n    {\\n        int count = 0;\\n        while(a > 0 || b > 0 || c > 0)\\n        {\\n            if(c % 2 == 0)\\n                count += a % 2 + b % 2;\\n            else if(a % 2 + b % 2 == 0)\\n                count++;\\n            \\n            a /= 2;\\n            b /= 2;\\n            c /= 2;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int MinFlips(int a, int b, int c) \\n    {\\n        int count = 0;\\n        while(a > 0 || b > 0 || c > 0)\\n        {\\n            if(c % 2 == 0)\\n                count += a % 2 + b % 2;\\n            else if(a % 2 + b % 2 == 0)\\n                count++;\\n            \\n            a /= 2;\\n            b /= 2;\\n            c /= 2;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477759,
                "title": "python-3-five-lines-beats-100-20-ms",
                "content": "```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        a, b, c, t, D = bin(a)[2:], bin(b)[2:], bin(c)[2:], 0, {\\'010\\':1, \\'100\\':1, \\'001\\':1, \\'110\\':2}\\n        M = max(len(a),len(b),len(c))\\n        a, b, c = a.zfill(M), b.zfill(M), c.zfill(M)\\n        for i in range(M): t += D.get(a[i]+b[i]+c[i],0)\\n        return t\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        a, b, c, t, D = bin(a)[2:], bin(b)[2:], bin(c)[2:], 0, {\\'010\\':1, \\'100\\':1, \\'001\\':1, \\'110\\':2}",
                "codeTag": "Java"
            },
            {
                "id": 477666,
                "title": "python-solution-with-explanation-easy-to-understand",
                "content": "on each bit, while `a[i] | b[i] == c[i]`\\na| b| c\\n----|----|----\\n0|0|0\\n1|0|1\\n0|1|1\\n1|1|1\\nnothing would be changed.\\n\\nwhile `a[i] | b[i] != c[i]`\\na| b| c|flips number\\n----|----|----|----\\n0|0|1|1\\n1|0|0|1\\n0|1|0|1\\n1|1|0|2\\n\\n```python\\nclass Solution(object):\\n    def minFlips(self, a, b, c):\\n        \"\"\"\\n        :type a: int\\n        :type b: int\\n        :type c: int\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        while (a | b) != c:\\n            ai = a % 2\\n            bi = b % 2\\n            ci = c % 2\\n            \\n            if ai | bi != ci:\\n                res += ai + bi + ci\\n\\n            a /= 2\\n            b /= 2\\n            c /= 2\\n        \\n        return res\\n            \\n\\n                    \\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def minFlips(self, a, b, c):\\n        \"\"\"\\n        :type a: int\\n        :type b: int\\n        :type c: int\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        while (a | b) != c:\\n            ai = a % 2\\n            bi = b % 2\\n            ci = c % 2\\n            \\n            if ai | bi != ci:\\n                res += ai + bi + ci\\n\\n            a /= 2\\n            b /= 2\\n            c /= 2\\n        \\n        return res\\n            \\n\\n                    \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966561,
                "title": "neat-clean-optimal-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int flips = 0 ;\\n        while(a || b || c){\\n            int temp = ((b&1)+(a&1)); \\n            if(c&1){ \\n                if(temp == 0) flips++;\\n            }else{\\n                flips += temp ;\\n            }\\n            a = a>>1 ;\\n            b = b>>1 ;\\n            c = c>>1 ;\\n        }\\n        return flips ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int flips = 0 ;\\n        while(a || b || c){\\n            int temp = ((b&1)+(a&1)); \\n            if(c&1){ \\n                if(temp == 0) flips++;\\n            }else{\\n                flips += temp ;\\n            }\\n            a = a>>1 ;\\n            b = b>>1 ;\\n            c = c>>1 ;\\n        }\\n        return flips ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3620928,
                "title": "java-c-bit-manipulation-easy-100-best-soln-please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBit manipulation\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTraverse every bit from rigght to left and increase mx.\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minFlips(int a, int b, int c) {\\n        int mx=0;\\n\\n        while(true){\\n            mx+=c&1^( (a&1) | (b&1) );\\n            mx+=(a&1) & (b&1)  & ~(c&1) ;\\n            b=b>>1;\\n            a=a>>1;\\n            c=c>>1;\\n            if(c==0 &&a==0&&b==0){\\n                mx+=c^(a | b );\\n                mx+=a & b  & ~c ;\\n                break;\\n            }\\n        }     \\n        return mx;\\n    }\\n}\\n//1000\\n//0011\\n//0101\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minFlips(int a, int b, int c) {\\n        int mx=0;\\n\\n        while(true){\\n            mx+=c&1^( (a&1) | (b&1) );\\n            mx+=(a&1) & (b&1)  & ~(c&1) ;\\n            b=b>>1;\\n            a=a>>1;\\n            c=c>>1;\\n            if(c==0 &&a==0&&b==0){\\n                mx+=c^(a | b );\\n                mx+=a & b  & ~c ;\\n                break;\\n            }\\n        }     \\n        return mx;\\n    }\\n}\\n//1000\\n//0011\\n//0101\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3620601,
                "title": "c-brute-force-easy-sol",
                "content": "# Intuition\\nFinding Binary representation of number and compare the bits\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(100)\\n\\n- Space complexity:\\nO(100)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getBit(int n){\\n        vector<int> v(100,0);\\n        int i=0;\\n        while(n){\\n            v[i++]=n%2;\\n            n/=2;\\n        }\\n        reverse(v.begin(),v.end());\\n        return v;\\n    }\\n    int minFlips(int a, int b, int c) {\\n        vector<int> v1 = getBit(a);\\n        vector<int> v2 = getBit(b);\\n        vector<int> v3 = getBit(c);\\n        int cnt=0;\\n        \\n        int i=v1.size()-1,j=v2.size()-1,k=v3.size()-1;\\n        while(i>=0&&j>=0&&k>=0){\\n            if(v3[k]==1){\\n                if(v2[j]==0&&v1[i]==0){\\n                    cnt++;\\n                }\\n            }else{\\n                 if(v2[j]==1&&v1[i]==1){\\n                    cnt+=2;\\n                }\\n                 else if(v2[j]==1||v1[i]==1){\\n                    cnt++;\\n                }\\n            }\\n            i--;\\n            j--;\\n            k--;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getBit(int n){\\n        vector<int> v(100,0);\\n        int i=0;\\n        while(n){\\n            v[i++]=n%2;\\n            n/=2;\\n        }\\n        reverse(v.begin(),v.end());\\n        return v;\\n    }\\n    int minFlips(int a, int b, int c) {\\n        vector<int> v1 = getBit(a);\\n        vector<int> v2 = getBit(b);\\n        vector<int> v3 = getBit(c);\\n        int cnt=0;\\n        \\n        int i=v1.size()-1,j=v2.size()-1,k=v3.size()-1;\\n        while(i>=0&&j>=0&&k>=0){\\n            if(v3[k]==1){\\n                if(v2[j]==0&&v1[i]==0){\\n                    cnt++;\\n                }\\n            }else{\\n                 if(v2[j]==1&&v1[i]==1){\\n                    cnt+=2;\\n                }\\n                 else if(v2[j]==1||v1[i]==1){\\n                    cnt++;\\n                }\\n            }\\n            i--;\\n            j--;\\n            k--;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618584,
                "title": "c-neat-and-clean-code-no-need-to-think-too-much-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int flips = 0;\\n        while(a || b || c){\\n            if(c & 1){\\n                if(!(a&1) && !(b&1)){\\n                    flips++;\\n                }\\n            }\\n            else{\\n                if(a & 1) flips++;\\n                if(b & 1) flips++;\\n            }\\n            a = a>>1;\\n            b = b>>1;\\n            c = c>>1;\\n        }\\n        return flips;       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int flips = 0;\\n        while(a || b || c){\\n            if(c & 1){\\n                if(!(a&1) && !(b&1)){\\n                    flips++;\\n                }\\n            }\\n            else{\\n                if(a & 1) flips++;\\n                if(b & 1) flips++;\\n            }\\n            a = a>>1;\\n            b = b>>1;\\n            c = c>>1;\\n        }\\n        return flips;       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613011,
                "title": "javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar minFlips = function(a, b, c) {\\n    const resultA = a.toString(2);\\n    const resultB = b.toString(2);\\n    const resultC = c.toString(2);\\n    let Atoarray =resultA.split(\\'\\')\\n    let Btoarray = resultB.split(\\'\\')\\n    let Ctoarray = resultC.split(\\'\\')\\n    let len = [Atoarray.length,Btoarray.length,Ctoarray.length]\\n    let maxLen =Math.max(...len)\\n    console.log(maxLen)\\n    for (let j = 0; j < maxLen; j++) {\\n        if (Atoarray.length < maxLen) {\\n            Atoarray.unshift(\\'0\\')\\n        }\\n        if (Btoarray.length < maxLen) {\\n            Btoarray.unshift(\\'0\\')\\n        }\\n        if (Ctoarray.length < maxLen) {\\n            Ctoarray.unshift(\\'0\\')\\n        }\\n    }\\n    let count =0\\n    for(let j=0;j<Ctoarray.length;j++){\\n        if(Ctoarray[j]===\\'0\\'){\\n            if (Atoarray[j] === \\'0\\' && Btoarray[j] === \\'1\\' || Atoarray[j] === \\'1\\' && Btoarray[j] === \\'0\\') {\\n                count++\\n            } else if (Atoarray[j] === \\'1\\' && Btoarray[j] === \\'1\\'){\\n                count+=2\\n            }\\n        } else if (Ctoarray[j] === \\'1\\'){\\n                if (Atoarray[j] === \\'0\\' && Btoarray[j] === \\'0\\') {\\n                    count++\\n                }\\n        }\\n    }\\n    return count\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minFlips = function(a, b, c) {\\n    const resultA = a.toString(2);\\n    const resultB = b.toString(2);\\n    const resultC = c.toString(2);\\n    let Atoarray =resultA.split(\\'\\')\\n    let Btoarray = resultB.split(\\'\\')\\n    let Ctoarray = resultC.split(\\'\\')\\n    let len = [Atoarray.length,Btoarray.length,Ctoarray.length]\\n    let maxLen =Math.max(...len)\\n    console.log(maxLen)\\n    for (let j = 0; j < maxLen; j++) {\\n        if (Atoarray.length < maxLen) {\\n            Atoarray.unshift(\\'0\\')\\n        }\\n        if (Btoarray.length < maxLen) {\\n            Btoarray.unshift(\\'0\\')\\n        }\\n        if (Ctoarray.length < maxLen) {\\n            Ctoarray.unshift(\\'0\\')\\n        }\\n    }\\n    let count =0\\n    for(let j=0;j<Ctoarray.length;j++){\\n        if(Ctoarray[j]===\\'0\\'){\\n            if (Atoarray[j] === \\'0\\' && Btoarray[j] === \\'1\\' || Atoarray[j] === \\'1\\' && Btoarray[j] === \\'0\\') {\\n                count++\\n            } else if (Atoarray[j] === \\'1\\' && Btoarray[j] === \\'1\\'){\\n                count+=2\\n            }\\n        } else if (Ctoarray[j] === \\'1\\'){\\n                if (Atoarray[j] === \\'0\\' && Btoarray[j] === \\'0\\') {\\n                    count++\\n                }\\n        }\\n    }\\n    return count\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3610773,
                "title": "gnu-formatted-solution-gnu-me-harder",
                "content": "Please upvote I need good reputation for the new wold order :)\\n# Intuition\\n check place for c. if c is 0 then add the amount of 1s at the same place for a and b. if c is 1 add 1 if neither of the place of a or b is 1.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\nleft shift op.\\n(Don\\'t forget shifting in lisp is the `ash` function)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $\\\\Omega(1)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $\\\\Omega(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n  static int32_t\\n  minFlips (int32_t a, int32_t b, int32_t c)\\n  {\\n    int32_t runk = 0;\\n    int32_t pa, pb, pc;\\n    for (uint64_t i = 0; i < 31; i += 1)\\n      {\\n        pa = a & 1 << i, pb = b & 1 << i, pc = c & 1 << i;\\n        if (pc)\\n          {\\n            runk += !(pa || pb);\\n          }\\n        else\\n          {\\n            runk += !!pa + !!pb;\\n          }\\n      }\\n      return (runk);\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n  static int32_t\\n  minFlips (int32_t a, int32_t b, int32_t c)\\n  {\\n    int32_t runk = 0;\\n    int32_t pa, pb, pc;\\n    for (uint64_t i = 0; i < 31; i += 1)\\n      {\\n        pa = a & 1 << i, pb = b & 1 << i, pc = c & 1 << i;\\n        if (pc)\\n          {\\n            runk += !(pa || pb);\\n          }\\n        else\\n          {\\n            runk += !!pa + !!pb;\\n          }\\n      }\\n      return (runk);\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610699,
                "title": "python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        A=bin(a)[2:]\\n        B=bin(b)[2:]\\n        C=bin(c)[2:]\\n        count=0\\n        lenAlenB=max(len(A),len(B))\\n        lenC=max(lenAlenB,len(C))\\n        i=0\\n        A=int(bin(a)[2:])\\n        B=int(bin(b)[2:])\\n        C=int(bin(c)[2:])\\n        while i< lenC:\\n            digitA=A%10 \\n            digitB=B%10\\n            digitC=C%10 \\n            if int(digitA or digitB) != digitC:\\n                if digitC==1:\\n                    count=count+1\\n                else:\\n                    count=count+digitA + digitB \\n            i=i+1\\n            A=A//10\\n            B=B//10\\n            C=C//10\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        A=bin(a)[2:]\\n        B=bin(b)[2:]\\n        C=bin(c)[2:]\\n        count=0\\n        lenAlenB=max(len(A),len(B))\\n        lenC=max(lenAlenB,len(C))\\n        i=0\\n        A=int(bin(a)[2:])\\n        B=int(bin(b)[2:])\\n        C=int(bin(c)[2:])\\n        while i< lenC:\\n            digitA=A%10 \\n            digitB=B%10\\n            digitC=C%10 \\n            if int(digitA or digitB) != digitC:\\n                if digitC==1:\\n                    count=count+1\\n                else:\\n                    count=count+digitA + digitB \\n            i=i+1\\n            A=A//10\\n            B=B//10\\n            C=C//10\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610500,
                "title": "c-beginner-friendly-solution-beats-100-submissions",
                "content": "Take out the last digit of a, b & c and compare a OR b ==c for each digit.\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n\\n     int count=0;\\n        while(a || b || c){\\n            int l=a&1,r=b&1,s=c&1;\\n            if((l|r) !=s && l==1 && r==1 &&s==0){\\n                count+=2;\\n            }\\n            else if((l|r) !=s)\\n                count++;\\n            \\n            a=a>>1;\\n            b=b>>1;            \\n            c=c>>1;\\n            \\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n\\n     int count=0;\\n        while(a || b || c){\\n            int l=a&1,r=b&1,s=c&1;\\n            if((l|r) !=s && l==1 && r==1 &&s==0){\\n                count+=2;\\n            }\\n            else if((l|r) !=s)\\n                count++;\\n            \\n            a=a>>1;\\n            b=b>>1;            \\n            c=c>>1;\\n            \\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610397,
                "title": "1318-minimum-flips-to-make-a-or-b-equal-to-c-java",
                "content": "```\\nclass Solution {\\n    public int minFlips(int a, int b, int c) {\\n        int cnt=0;\\n        while(a>0||b>0||c>0)\\n        {\\n            int x=a&1;\\n            int y=b&1;\\n            int z=c&1;\\n            if(z==0)\\n            {\\n                cnt+=x+y;\\n            }\\n            else\\n            {\\n                if(x==0&&y==0)\\n                    cnt++;\\n                \\n            }\\n            a=a>>1;\\n            b=b>>1;\\n            c=c>>1;\\n\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minFlips(int a, int b, int c) {\\n        int cnt=0;\\n        while(a>0||b>0||c>0)\\n        {\\n            int x=a&1;\\n            int y=b&1;\\n            int z=c&1;\\n            if(z==0)\\n            {\\n                cnt+=x+y;\\n            }\\n            else\\n            {\\n                if(x==0&&y==0)\\n                    cnt++;\\n                \\n            }\\n            a=a>>1;\\n            b=b>>1;\\n            c=c>>1;\\n\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610354,
                "title": "python-simple-and-intuitive-bit-manipulation-1-line",
                "content": "# Intuition\\n![\\u5716\\u7247.png](https://assets.leetcode.com/users/images/d5a1795e-3a81-4104-877c-6d2905a6f2d0_1686158697.2263498.png)\\n\\nThere are only three scenarios that require flipping.\\n\\n- c == 1\\n    - if a == 0 and b == 0: flip a or b to 1\\n- c == 0\\n    - if a == 1: flip a to 0\\n    - if b == 1: flip b to 0\\n\\n\\n# Code\\n```\\n# c == 1 and a == 0 and b == 0\\n# means c and not(a) and not(b) \\n# The flip count is how many \"1\" in bin(c & ~a & ~b)\\nbin(c & ~a & ~b).count(\"1\")\\n\\n# c == 0 and a == 1\\n# means not(c) and a\\nbin(~c & a).count(\"1\")\\n\\n# c == 0 and b == 1\\n# means not(c) and b\\nbin(~c & b).count(\"1\")\\n```\\n```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        return bin(c & ~a & ~b).count(\"1\") + bin(~c & a).count(\"1\") + bin(~c & b).count(\"1\")\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# c == 1 and a == 0 and b == 0\\n# means c and not(a) and not(b) \\n# The flip count is how many \"1\" in bin(c & ~a & ~b)\\nbin(c & ~a & ~b).count(\"1\")\\n\\n# c == 0 and a == 1\\n# means not(c) and a\\nbin(~c & a).count(\"1\")\\n\\n# c == 0 and b == 1\\n# means not(c) and b\\nbin(~c & b).count(\"1\")\\n```\n```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        return bin(c & ~a & ~b).count(\"1\") + bin(~c & a).count(\"1\") + bin(~c & b).count(\"1\")\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610331,
                "title": "easy-js-solution",
                "content": "# Code\\n```\\nvar minFlips = function(a, b, c) {\\n    let o = 0;\\n    for(let i = 0; i < 32; i++) {\\n        let cbit = (c>>i) & 1;\\n        let abit = (a>>i) & 1, bbit = (b>>i) & 1;\\n        let v = abit || bbit;\\n        if (cbit === v) continue;\\n        o += cbit == 1 ? 1 : (abit + bbit);\\n    }\\n    return o;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minFlips = function(a, b, c) {\\n    let o = 0;\\n    for(let i = 0; i < 32; i++) {\\n        let cbit = (c>>i) & 1;\\n        let abit = (a>>i) & 1, bbit = (b>>i) & 1;\\n        let v = abit || bbit;\\n        if (cbit === v) continue;\\n        o += cbit == 1 ? 1 : (abit + bbit);\\n    }\\n    return o;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3610279,
                "title": "100-beat-c-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string binary(int c){\\n        string cstr = \"\";\\n        while(c > 0){\\n            if(c%2 == 0){\\n                cstr = \\'0\\' + cstr;\\n            }else{\\n                cstr = \\'1\\' + cstr;\\n            }\\n            c /= 2;\\n        }\\n        return cstr;\\n    }\\n    int minFlips(int a, int b, int c) {\\n        string cstr = binary(c);\\n        int csize = cstr.length();\\n\\n        string astr = binary(a);\\n        int asize = astr.length();\\n\\n        string bstr = binary(b);\\n        int bsize = bstr.length();\\n\\n        int maxi = max(csize , max(asize , bsize));\\n\\n        while(cstr.length() < maxi){\\n            cstr = \\'0\\' + cstr;\\n        }\\n        while(bstr.length() < maxi){\\n            bstr = \\'0\\' + bstr;\\n        }\\n        while(astr.length() < maxi){\\n            astr = \\'0\\' + astr;\\n        }\\n        int count = 0;\\n        for(int i=maxi-1; i>=0; i--){\\n            if((astr[i]-\\'0\\')==0 && (bstr[i]-\\'0\\')==0 && (cstr[i]-\\'0\\') == 1) count++;\\n            else if((astr[i]-\\'0\\')==1 && (bstr[i]-\\'0\\')==1 && (cstr[i]-\\'0\\') == 0) count += 2;\\n            else if((astr[i]-\\'0\\')==0 && (bstr[i]-\\'0\\')==1 && (cstr[i]-\\'0\\') == 0) count++;\\n            else if((astr[i]-\\'0\\')==1 && (bstr[i]-\\'0\\')==0 && (cstr[i]-\\'0\\') == 0) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string binary(int c){\\n        string cstr = \"\";\\n        while(c > 0){\\n            if(c%2 == 0){\\n                cstr = \\'0\\' + cstr;\\n            }else{\\n                cstr = \\'1\\' + cstr;\\n            }\\n            c /= 2;\\n        }\\n        return cstr;\\n    }\\n    int minFlips(int a, int b, int c) {\\n        string cstr = binary(c);\\n        int csize = cstr.length();\\n\\n        string astr = binary(a);\\n        int asize = astr.length();\\n\\n        string bstr = binary(b);\\n        int bsize = bstr.length();\\n\\n        int maxi = max(csize , max(asize , bsize));\\n\\n        while(cstr.length() < maxi){\\n            cstr = \\'0\\' + cstr;\\n        }\\n        while(bstr.length() < maxi){\\n            bstr = \\'0\\' + bstr;\\n        }\\n        while(astr.length() < maxi){\\n            astr = \\'0\\' + astr;\\n        }\\n        int count = 0;\\n        for(int i=maxi-1; i>=0; i--){\\n            if((astr[i]-\\'0\\')==0 && (bstr[i]-\\'0\\')==0 && (cstr[i]-\\'0\\') == 1) count++;\\n            else if((astr[i]-\\'0\\')==1 && (bstr[i]-\\'0\\')==1 && (cstr[i]-\\'0\\') == 0) count += 2;\\n            else if((astr[i]-\\'0\\')==0 && (bstr[i]-\\'0\\')==1 && (cstr[i]-\\'0\\') == 0) count++;\\n            else if((astr[i]-\\'0\\')==1 && (bstr[i]-\\'0\\')==0 && (cstr[i]-\\'0\\') == 0) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610226,
                "title": "bitwise-operation-only-with-just-one-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConsider all situations of bitwise operation and results, you will find that the problem can be solved easily\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\na b c    result\\n0 0 0 ->   0\\n0 0 1 ->   1\\n0 1 0 ->   1\\n0 1 1 ->   0\\n1 0 0 ->   1\\n1 0 1 ->   0\\n1 1 0 ->   2(but a XOR b XOR c = 0)\\n1 1 1 ->   0(but a XOR b XOR c = 1)\\n\\nthe first 6 cases can be counted using XOR\\nthe last 2 cases can be counted using a&b&(~c) and a&b&c respectively\\nfinally, using builtin function popcount to count the number of 1\\'s of integer in binary expression\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        return __builtin_popcount(a^b^c)+__builtin_popcount(a&b&(~c))*2-__builtin_popcount(a&b&c);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        return __builtin_popcount(a^b^c)+__builtin_popcount(a&b&(~c))*2-__builtin_popcount(a&b&c);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610115,
                "title": "simple-solution-beats-100-c-bitset",
                "content": "# Intuition\\nconsider (i)th bits of numbers\\nCompare if A[i]||B[i] == C[i] then omit , else\\n1) if C[i] == 0\\n   \\u2022\\t if  A[i] = B[i] = 1 \\n    then flip both bits \\n    \\u2022\\telse if \\n        ( A[i]==1 and B[i]==0 ) or ( A[i]==1 and B[i]==0 )\\n    flip 1 bit\\n2) else C[i] == 1\\n    \\u2022\\tif A[i] = B[i] = 1 \\n    flip 1 bit\\n    \\u2022\\telse if ( A[i] = B[i] = 0 )  ( A[i]==1 and B[i]==0 ) or ( A[i]==1 and B[i]==0 )\\n    flip 1 bit\\n\\n\\n# Approach\\nConvert the integers a, b, and c into bitsets (na, nb, and nc, respectively) of size 32 to represent their binary representations.\\nInitialize a counter (cnt) to keep track of the number of bit flips.\\nFind the maximum value among a, b, and c to determine the number of bits to iterate over. This is done by calculating the ceiling of the logarithm base 2 of the maximum value.\\nIterate through each bit position from 0 to maxn (inclusive).\\nif A[i]||B[i] == C[i] continue\\nif if C[i] == 0 and  A[i] = B[i] = 1 \\n \\u2022Flips = 2 ,  cnt+=2\\nelse in each case  \\n \\u2022Flips = 1 , cnt++\\n\\n# Complexity\\n- Time complexity : O(log2(max(a, b, c)))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe code calculates the maximum value in (a,b,c) to determine the number of bits to iterate over, and the number of iterations is proportional to the number of bits in the maximum value that is  ceil( log2 (max(a, b, c) ) )\\n\\n- Space complexity : O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the code is O(1) since the space used is constant. The bitsets are of fixed size (32 bits) and do not depend on the input size. The counter and other variables also use constant space.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) \\n    {\\n        bitset<32> nc(c);\\n        bitset<32> nb(b);\\n        bitset<32> na(a);\\n\\n        int cnt=0;\\n        int maxn = max(a,max(b,c));\\n        maxn = ceil(log2(maxn));\\n\\n        for(int i=0 ; i<=maxn ;i++)\\n        {\\n            if((na[i] || nb[i]) == nc[i]) \\n                continue;\\n            else if(nc[i]==0 && na[i] && nb[i]){\\n                cnt+=2;\\n            }   \\n            else{\\n                cnt++; \\n            }  \\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) \\n    {\\n        bitset<32> nc(c);\\n        bitset<32> nb(b);\\n        bitset<32> na(a);\\n\\n        int cnt=0;\\n        int maxn = max(a,max(b,c));\\n        maxn = ceil(log2(maxn));\\n\\n        for(int i=0 ; i<=maxn ;i++)\\n        {\\n            if((na[i] || nb[i]) == nc[i]) \\n                continue;\\n            else if(nc[i]==0 && na[i] && nb[i]){\\n                cnt+=2;\\n            }   \\n            else{\\n                cnt++; \\n            }  \\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609772,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThe code is a Python function implemented as a method of a class called Solution. This function takes three integer inputs a, b, and c and returns an integer which represents the minimum number of bit flips required to make a | b equal to c.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n- ab is a binary number obtained by performing the bitwise OR operation between a and b. This operation sets each bit in ab to 1 if that bit is set in either a or b.\\n\\n- equal is a binary number obtained by performing the bitwise XOR operation between ab and c. This operation sets each bit in equal to 1 if the corresponding bits in ab and c are different.\\n\\n- ans is a counter variable that keeps track of the minimum number of bit flips required.\\n\\nThe code then iterates over each bit position (0 to 30) and checks if the bit at that position needs to be flipped. If the bit needs to be flipped, depending on the values of a, b, and c, it increments ans by either 1 or 2.\\n\\nThe condition equal & mask > 0 checks if the bit at position i needs to be flipped. If this condition is true, then one of two things can happen:\\n\\n- If the bits in a, b, and c are such that flipping the bit at position i in both a and b makes a | b equal to c, then ans is incremented by 2. This is because we need to flip both bits in a and b to get from ab to c.\\n\\n- If the bits in a, b, and c are such that flipping the bit at position i in only one of a or b (or neither) makes a | b equal to c, then ans is incremented by 1. This is because we only need to flip one bit to get from ab to c.\\n\\n# Complexity\\n- Time complexity : $$O(log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        ab, equal, ans = a | b, (a | b) ^ c, 0\\n        for i in range(31):\\n            mask = 1 << i\\n            if equal & mask > 0:\\n                if (a & mask) == (b & mask) and (c & mask) == 0:\\n                    ans += 2 \\n                else:\\n                    ans += 1\\n        return ans\\n\\n```\\n\\n\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/a5125831-8710-4929-946c-38eebae827b3_1686150303.8650544.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        ab, equal, ans = a | b, (a | b) ^ c, 0\\n        for i in range(31):\\n            mask = 1 << i\\n            if equal & mask > 0:\\n                if (a & mask) == (b & mask) and (c & mask) == 0:\\n                    ans += 2 \\n                else:\\n                    ans += 1\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609751,
                "title": "c-beats-100-time-complexity-analysis-with-beginner-friendly-explanation",
                "content": "\\n# Intuition\\nGiven three positive integers `a`, `b`, and `c`, our objective is to determine the minimum number of bit flips required in `a` and `b` to ensure that their bitwise OR operation `(a OR b)` is equal to `c`. A flip operation involves changing any single bit 1 to 0 or changing a bit 0 to 1 in their binary representation.\\n\\n\\nTo solve this problem, we need to examine the binary representations of `a`, `b`, and `c`. Our goal is to count the minimum number of bit flips required to make `(a OR b)` equal to `c`.\\n\\n# Approach:\\n\\n1. Initialize a variable `flips` to keep track of the total number of bit flips required and set it to 0.\\n2. Iterate through the bits of `a`, `b`, and `c` simultaneously, starting from the least significant bit to the most significant bit.\\n3. Extract the least significant bits of `a`, `b`, and `c` using bitwise AND with 1. Let\\'s denote these bits as `bitA`, `bitB`, and `bitC`, respectively.\\n4. Compare `bitA` and `bitB` with `bitC` to determine if a bit flip is necessary. If `(bitA OR bitB) != bitC`, it implies that at least one of `bitA` or `bitB` needs to be flipped to match `bitC`.\\n5. If both `bitA` and `bitB` are 1 (i.e., `bitA AND bitB == 1`), we need to perform two bit flips to ensure that `(a OR b)` matches `c`. Increment `flips` by 2 in this case.\\n6. Otherwise, if either `bitA` or `bitB` is 1 (i.e., `bitA OR bitB == 1`), we only need to perform one bit flip to ensure that `(a OR b)` matches `c`. Increment `flips` by 1.\\n7. Right shift `a`, `b`, and `c` by 1 bit to move to the next significant bit position.\\n8. Repeat steps 3-7 until all bits of `a`, `b`, and `c` have been processed.\\n9. Return the final value of `flips`, which represents the minimum number of bit flips required to achieve `(a OR b) == c`.\\n\\n\\n\\n# Complexity\\n\\n- **Time complexity:**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the provided code is O(log(max(a, b, c))), where max(a, b, c) represents the maximum value among `a`, `b`, and `c`. \\n\\nThe while loop iterates until all the bits of `a`, `b`, and `c` have been processed. Since the maximum number of bits in an integer is logarithmic in its value, the loop will execute a maximum of log(max(a, b, c)) times.\\n\\nWithin each iteration, the code performs a constant number of operations, regardless of the input size. These operations include bitwise AND, bitwise OR, comparisons, and bit shifting, which all take constant time.\\n\\nTherefore, the overall time complexity is dominated by the number of iterations, resulting in a time complexity of O(log(max(a, b, c))).\\n\\nWe may initially assume that since the size of an `int` is 32 bits, the time complexity is O(32), which can be simplified to O(1). But the time complexity of O(1) would imply that the code runs in constant time regardless of the input size. However, in this case, the input size is determined by the number of bits in the integers `a`, `b`, and `c`, which is fixed at 32 bits.\\n\\nSince the while loop iterates 32 times, once for each bit position, the time complexity is not constant. It scales with the number of bits in the input, making it logarithmic in the input size.\\n\\nTherefore, the time complexity for the given code is **O(log(max(a, b, c)))**. \\n\\n- **Space complexity:**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**O(1)**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int flips = 0;  // Variable to count the total number of flips\\n        \\n        // Iterate until all bits of a, b, and c have been processed\\n        while (a || b || c) {\\n            int bitA = a & 1;  // Extract the least significant bit of a\\n            int bitB = b & 1;  // Extract the least significant bit of b\\n            int bitC = c & 1;  // Extract the least significant bit of c\\n            \\n            // Check if a flip is required to match the corresponding bit in c\\n            if ((bitA | bitB) != bitC) {\\n                if (bitA & bitB)\\n                    flips += 2;  // Two flips required if both bitA and bitB are 1\\n                else\\n                    flips += 1;  // One flip required if either bitA or bitB is 1\\n            }\\n            \\n            // Right shift a, b, and c to move to the next significant bit position\\n            a >>= 1;\\n            b >>= 1;\\n            c >>= 1;\\n        }\\n        \\n        return flips;  // Return the minimum number of flips\\n    }\\n};\\n```\\nAn upvote would be encouraging :)",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int flips = 0;  // Variable to count the total number of flips\\n        \\n        // Iterate until all bits of a, b, and c have been processed\\n        while (a || b || c) {\\n            int bitA = a & 1;  // Extract the least significant bit of a\\n            int bitB = b & 1;  // Extract the least significant bit of b\\n            int bitC = c & 1;  // Extract the least significant bit of c\\n            \\n            // Check if a flip is required to match the corresponding bit in c\\n            if ((bitA | bitB) != bitC) {\\n                if (bitA & bitB)\\n                    flips += 2;  // Two flips required if both bitA and bitB are 1\\n                else\\n                    flips += 1;  // One flip required if either bitA or bitB is 1\\n            }\\n            \\n            // Right shift a, b, and c to move to the next significant bit position\\n            a >>= 1;\\n            b >>= 1;\\n            c >>= 1;\\n        }\\n        \\n        return flips;  // Return the minimum number of flips\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609692,
                "title": "beats-100-easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nconvert the a,b,c into binary and store into array\\nand run the for loop 64 time and check thier is need to convert the bit or not ....if their is need then ...........increase the answer \\n\\ni have done ans=ans+2 ...for this condn(binaryc[i]==0----if(binarya[i]==1 && binaryb[i]==1)) means if both bit is 1 then i need to change both of bit\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nas numbers are in  10^9 order the binay will be in 64 bit formate \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nconstant\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(3x64)\\n# Code\\n```\\nclass Solution {\\npublic:\\n   vector<int> decToBinary(int n ){\\n    \\n   vector<int>binaryNum(64,0);\\n \\n   \\n    int i = 0;\\n    while (n > 0) {\\n \\n       \\n        binaryNum[i] = n % 2;\\n        n = n / 2;\\n        i++;\\n    }\\n    return binaryNum;\\n     }\\n    int minFlips(int a, int b, int c) {\\n        \\n        \\n    vector<int>binarya=decToBinary(a );\\n    vector<int> binaryb=decToBinary( b );\\n    vector<int> binaryc=decToBinary( c );\\n     int ans=0;\\n    for(int i=0;i<64;i++){\\n        cout<<binaryc[i];\\n    }\\n    \\n     \\n     for(int i=0;i<64;i++){\\n         if((binarya[i] | binaryb[i])==binaryc[i]){\\n             \\n             continue;\\n         }\\n         else if(binaryc[i]==0){\\n             if(binarya[i]==1 && binaryb[i]==1){\\n                 \\n                 ans=ans+2;\\n                //  continue;\\n             }\\n             else{\\n                 \\n                 ans++;\\n                 continue;\\n             }\\n         }\\n         else if(binaryc[i]==1) {\\n             \\n              if(binarya[i]==0 && binaryb[i]==0){\\n                  ans++;\\n              }\\n             \\n            //  continue;\\n         }\\n     }\\n     return ans;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   vector<int> decToBinary(int n ){\\n    \\n   vector<int>binaryNum(64,0);\\n \\n   \\n    int i = 0;\\n    while (n > 0) {\\n \\n       \\n        binaryNum[i] = n % 2;\\n        n = n / 2;\\n        i++;\\n    }\\n    return binaryNum;\\n     }\\n    int minFlips(int a, int b, int c) {\\n        \\n        \\n    vector<int>binarya=decToBinary(a );\\n    vector<int> binaryb=decToBinary( b );\\n    vector<int> binaryc=decToBinary( c );\\n     int ans=0;\\n    for(int i=0;i<64;i++){\\n        cout<<binaryc[i];\\n    }\\n    \\n     \\n     for(int i=0;i<64;i++){\\n         if((binarya[i] | binaryb[i])==binaryc[i]){\\n             \\n             continue;\\n         }\\n         else if(binaryc[i]==0){\\n             if(binarya[i]==1 && binaryb[i]==1){\\n                 \\n                 ans=ans+2;\\n                //  continue;\\n             }\\n             else{\\n                 \\n                 ans++;\\n                 continue;\\n             }\\n         }\\n         else if(binaryc[i]==1) {\\n             \\n              if(binarya[i]==0 && binaryb[i]==0){\\n                  ans++;\\n              }\\n             \\n            //  continue;\\n         }\\n     }\\n     return ans;\\n       \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3609691,
                "title": "2-simple-solutions-with-bit-manipulation-and-strings",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCheck if number `a` OR `b` needs flipping to be `c` bit by bit\\n## 1. Bitwise solution\\n\\n### Approach\\n<!-- Describe your approach to solving the problem. -->\\nHave a number with only one bit 1, and move the bit to see if flipping is required by checking its AND result with all the numbers\\n### Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### Code\\n```\\nfunction minFlips(a: number, b: number, c: number): number {\\n    const limit = Math.max(a, b, c);\\n    let check = 1;\\n    let result = 0;\\n    while(check <= limit){\\n        if(check & c){\\n            if(!(check & a) && !(check & b)){\\n                result++;\\n            }\\n        }else{\\n            if(check & a){\\n                result++;\\n            }\\n            if(check & b){\\n                result++;\\n            }\\n        }\\n        check *= 2;\\n    }\\n    return result;\\n};\\n```\\n## 2. toString solution\\n### Approach\\n<!-- Describe your approach to solving the problem. -->\\nTransform numbers to strings and check if flipping is required through iteration\\n\\n### Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### Code\\n```\\nfunction minFlips(a: number, b: number, c: number): number {\\n    const aStr = a.toString(2).split(\\'\\').reverse();\\n    const bStr = b.toString(2).split(\\'\\').reverse();\\n    const target = c.toString(2).split(\\'\\').reverse();\\n\\n    let result = 0;\\n    const maxLen = Math.max(aStr.length, bStr.length, target.length);\\n    for(let i = 0;i < maxLen; i++){\\n        if(!target[i] || target[i] === \\'0\\'){\\n            if(aStr[i] === \\'1\\'){\\n                result++;\\n            }\\n            if(bStr[i] === \\'1\\'){\\n                result++;\\n            }\\n        }else{\\n            if((!aStr[i] || aStr[i] === \\'0\\') && (!bStr[i] || bStr[i] === \\'0\\')){\\n                result++;\\n            }\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Bit Manipulation"
                ],
                "code": "```\\nfunction minFlips(a: number, b: number, c: number): number {\\n    const limit = Math.max(a, b, c);\\n    let check = 1;\\n    let result = 0;\\n    while(check <= limit){\\n        if(check & c){\\n            if(!(check & a) && !(check & b)){\\n                result++;\\n            }\\n        }else{\\n            if(check & a){\\n                result++;\\n            }\\n            if(check & b){\\n                result++;\\n            }\\n        }\\n        check *= 2;\\n    }\\n    return result;\\n};\\n```\n```\\nfunction minFlips(a: number, b: number, c: number): number {\\n    const aStr = a.toString(2).split(\\'\\').reverse();\\n    const bStr = b.toString(2).split(\\'\\').reverse();\\n    const target = c.toString(2).split(\\'\\').reverse();\\n\\n    let result = 0;\\n    const maxLen = Math.max(aStr.length, bStr.length, target.length);\\n    for(let i = 0;i < maxLen; i++){\\n        if(!target[i] || target[i] === \\'0\\'){\\n            if(aStr[i] === \\'1\\'){\\n                result++;\\n            }\\n            if(bStr[i] === \\'1\\'){\\n                result++;\\n            }\\n        }else{\\n            if((!aStr[i] || aStr[i] === \\'0\\') && (!bStr[i] || bStr[i] === \\'0\\')){\\n                result++;\\n            }\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3609642,
                "title": "easy-explanation-for-beginners-must-read",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n  - First we must be very clear with the concepts of bits manupulation and also understant left shift and right shift operations.\\n  - Try and write the code to print all the bits of a number(There is very easy approach which is used in this question as well).\\n  - When you know how do we print the bits then this problem becomes more easy and clearer.\\n  -  So, (0 | 0)=0,  (0 | 1)=1, (1 | 0) = 1 and (1 | 1) = 1. This is how TRUTH TABLE of OR looks like.\\n  - If we find OR of a and b then we can only get 0 when both have zero bits. Moreover we can get one in two cases.\\n      - Where a get 1 bit and b get 0.\\n      - Where a gets 0 bit and b get 1.\\n\\n    \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Now, we will iterate through the bits of a, b and c.(That\\'s what while loop is doing it is iterating untill all the number becomes zero)\\n- if OR of a and b for that specific bit is same as bit of c we change nothing.\\n- if there is difference then two cases are formed\\n    - if (a | b)==1 and c==0, then there can be max two flips and min 1. Because we will need to change both bits to 0 of they are 1.\\n    - if (a | b)==0 and c==1, then there will be only 1 flip required. Because out of a and b, if you change any of it to 1 it will give 1 as OR.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n     \\n   $$O(log n)$$ where n is the maximum number out of a, b and c.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$ O(1) $$\\n \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) \\n    {\\n        int minFlips=0;\\n\\n        while(a!=0 || b!=0 || c!=0)\\n        {\\n            int bit1= a & 1 ? 1 : 0;\\n            int bit2= b & 1 ? 1 : 0;\\n            int bit3= c & 1 ? 1 : 0;\\n\\n           \\n\\n            if(bit3 != (bit2 | bit1))\\n            {\\n                 if(bit3 == 1)\\n                 {\\n                    minFlips+=1;\\n                 }else{\\n                     minFlips+=(bit2+bit1);\\n                 }\\n            }\\n\\n            a>>=1;\\n            b>>=1;\\n            c>>=1;\\n        }\\n        \\n        return minFlips;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) \\n    {\\n        int minFlips=0;\\n\\n        while(a!=0 || b!=0 || c!=0)\\n        {\\n            int bit1= a & 1 ? 1 : 0;\\n            int bit2= b & 1 ? 1 : 0;\\n            int bit3= c & 1 ? 1 : 0;\\n\\n           \\n\\n            if(bit3 != (bit2 | bit1))\\n            {\\n                 if(bit3 == 1)\\n                 {\\n                    minFlips+=1;\\n                 }else{\\n                     minFlips+=(bit2+bit1);\\n                 }\\n            }\\n\\n            a>>=1;\\n            b>>=1;\\n            c>>=1;\\n        }\\n        \\n        return minFlips;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609579,
                "title": "simple-c-solution-using-bitmasks",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        \\n        int ans = 0;\\n        \\n        for(int i=0;i<32;i++){\\n            \\n            int bits = ((a>>i)&1) + ((b>>i)&1);\\n            int need = (c>>i)&1;\\n            \\n            if(need == 0){\\n                ans+=bits;\\n            }\\n            else{\\n                if(bits == 0){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Bitmask"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        \\n        int ans = 0;\\n        \\n        for(int i=0;i<32;i++){\\n            \\n            int bits = ((a>>i)&1) + ((b>>i)&1);\\n            int need = (c>>i)&1;\\n            \\n            if(need == 0){\\n                ans+=bits;\\n            }\\n            else{\\n                if(bits == 0){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609171,
                "title": "pure-bit-manipulation-solution-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) \\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        int ans = 0;\\n        \\n        while(a || b || c)\\n        {\\n            int a_bit = a&1;\\n            a >>= 1;\\n            int b_bit = b&1;\\n            b >>= 1;\\n            int c_bit = c&1;\\n            c >>= 1;\\n\\n            if((a_bit | b_bit) != c_bit)\\n            {\\n                if(a_bit == 1 && b_bit == 1)\\n                ans += 2;\\n                else\\n                ans += 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) \\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        int ans = 0;\\n        \\n        while(a || b || c)\\n        {\\n            int a_bit = a&1;\\n            a >>= 1;\\n            int b_bit = b&1;\\n            b >>= 1;\\n            int c_bit = c&1;\\n            c >>= 1;\\n\\n            if((a_bit | b_bit) != c_bit)\\n            {\\n                if(a_bit == 1 && b_bit == 1)\\n                ans += 2;\\n                else\\n                ans += 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608921,
                "title": "beats-100-solution-c-easy-approach-and-intuitive",
                "content": "# Intuition\\nIn the above question they are asking us to find XOR so it suggests to use binary notation and after knowing basic of AND and OR we can find the solution\\n\\n# Approach\\n1.  convert in binary \\n2. if element in c at ith index is \\'0\\' then at ith index of both a and b the element should be \\'0\\' \\n3. if element at ith index is \\'1\\' then either of the element should be \\'1\\'\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(30)\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    vector<int> int_bin(int a){\\n        int i = 31;\\n        vector<int> arr(i,0);\\n        i=0;\\n        while(a > 0){\\n            arr[i] = a%2;\\n            i++;\\n            a = a / 2;\\n        }\\n        reverse(arr.begin(), arr.end());\\n        return arr;\\n    }\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        vector<int> aa = int_bin(a);\\n        vector<int> bb = int_bin(b);\\n        vector<int> cc = int_bin(c);\\n        int ans = 0;\\n        for(int i=30; i >= 0; i--){\\n            if(cc[i] == 0){\\n                if(aa[i] == 0 && bb[i] == 0){\\n                    continue;\\n                }else if((aa[i] == 0 && bb[i] == 1) || (aa[i] == 1 && bb[i] == 0)){\\n                    ans++;\\n                    continue;\\n                }else{\\n                    ans = ans + 2;\\n                    continue;\\n                }\\n            }else{\\n                if(aa[i] == 0 && bb[i] == 0){\\n                    ans = ans + 1;\\n                    continue;\\n                }else{\\n                    continue;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int> int_bin(int a){\\n        int i = 31;\\n        vector<int> arr(i,0);\\n        i=0;\\n        while(a > 0){\\n            arr[i] = a%2;\\n            i++;\\n            a = a / 2;\\n        }\\n        reverse(arr.begin(), arr.end());\\n        return arr;\\n    }\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        vector<int> aa = int_bin(a);\\n        vector<int> bb = int_bin(b);\\n        vector<int> cc = int_bin(c);\\n        int ans = 0;\\n        for(int i=30; i >= 0; i--){\\n            if(cc[i] == 0){\\n                if(aa[i] == 0 && bb[i] == 0){\\n                    continue;\\n                }else if((aa[i] == 0 && bb[i] == 1) || (aa[i] == 1 && bb[i] == 0)){\\n                    ans++;\\n                    continue;\\n                }else{\\n                    ans = ans + 2;\\n                    continue;\\n                }\\n            }else{\\n                if(aa[i] == 0 && bb[i] == 0){\\n                    ans = ans + 1;\\n                    continue;\\n                }else{\\n                    continue;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608880,
                "title": "c-solutions-beats-100-based-on-the-basic-logical-approach",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBASIC LOGICAL APPROACH & EASY TO UNDERSTAND\\n\\n*In the problem we are given three numbers a,b,c. And we have to find  the minimum flips required in some bits of a and b to make ( a OR b == c ). (bitwise OR operation).\\nFlip operation consists of change any single bit 1 to 0 or change the bit 0 to 1 in their binary representation.\\n\\n# *Here is the basic steps:-*\\n1>In the first step we will find the OR as well as AND of a and b. Why we are doing this will come to know in the next step.\\ninput a = 2, b = 6, c = 5;\\n\\n         int bit1=a|b;    \\n         int bit2=a&b \\nFor exp:-   \\n0010 OR 0110=0110\\n0010 OR 0110=0010\\n\\n2> In the 2nd step we take XOR of bit1 and c so that we can find number of non similar bit. \\n0110^0101=0011\\n\\n        int bit3=bit1^c;\\n        int bit4=bit3&bit2;\\n\\n*HERE IS ONE THING THAT YOU NEED TO BE CARE ABOUT*\\nIn 0011 one is showing non similar bit now we have to think how can be it made similar.\\n \\nit can be made either flip bit in a or b or in both.So 1 bit of a&b will lead to flip in both so here number of flip will be 2. \\n\\n3> In 3rd step we simply count 1 bit in the bit3 and bit4 subtract count 1 bit of bit4 from bit3 and add 2*(count of 1 bit of bit4)\\n\\n\\nreturn (__builtin_popcount(bit3)- __builtin_popcount(bit4))\\n+2* __builtin_popcount(bit4);\\n\\n        \\n\\n\\n# FOR BETTER UNDERSTANDING LOOK INTO THE CODE:)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int bit1=a|b;\\n        int bit2=a&b;\\n        int bit3=bit1^c;\\n        int bit4=bit3&bit2;\\n        \\n         return (__builtin_popcount(bit3)- __builtin_popcount(bit4))+2* __builtin_popcount(bit4);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int bit1=a|b;\\n        int bit2=a&b;\\n        int bit3=bit1^c;\\n        int bit4=bit3&bit2;\\n        \\n         return (__builtin_popcount(bit3)- __builtin_popcount(bit4))+2* __builtin_popcount(bit4);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608853,
                "title": "c-easy-to-understand-beats-100-0-ms-daily-challenge",
                "content": "# Complexity\\n- Time complexity:\\nO(32)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int ans=0,n=32;\\n        while(n--){\\n            int x=(a&1)|(b&1),y=c&1;\\n            if(x!=y){\\n                if(a&1 && b&1) ans+=2;\\n                else ans++;\\n            }b\\n            a>>=1;b>>=1;c>>=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int ans=0,n=32;\\n        while(n--){\\n            int x=(a&1)|(b&1),y=c&1;\\n            if(x!=y){\\n                if(a&1 && b&1) ans+=2;\\n                else ans++;\\n            }b\\n            a>>=1;b>>=1;c>>=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608835,
                "title": "c-detailed-explanation-with-o-log-min-a-b-c-100-time-0ms-60-space-5-9mb",
                "content": "Odd that this problem is flagged as a medium when it only requires basic bit manipulation.\\n\\nWe need to think of our numbers in their binary representation, bit by bit, to figure out how to proceed, but then it becomes trivial; let\\'s consider for example this case:\\n\\n```cpp\\n00010010 // a: 18\\n00011011 // b: 27\\n00010100 // c: 20\\n```\\n\\nWe will then check each bit from least meaningful bit (ie: the rightmost), like this, knowing that when the current bit in `c` is `0`, we need to make sure both the others in the same position are `0`, while when it is `1`, at least one of the other two has to be `1`:\\n\\n\\n```cpp\\n00010010 // a: 0\\n00011011 // b: 1\\n       |\\n00010100 // c: 0\\n// we need to flip the bit in b to 0 to get 0 from an OR\\n       1 // count of flips\\n\\n00010010 // a: 1\\n00011011 // b: 1\\n      |\\n00010100 // c: 0\\n// we need to flip both bits in a and b to 0 to get 0 from an OR\\n       3 // count of flips\\n\\n00010010 // a: 0\\n00011011 // b: 0\\n     |\\n00010100 // c: 1\\n// we need to flip either bit in a and b to 1 to get 1 from an OR\\n       4 // count of flips\\n\\n00010010 // a: 0\\n00011011 // b: 1\\n    |\\n00010100 // c: 0\\n// we need to flip the bit in b to 0 to get 0 from an OR\\n       5 // count of flips\\n\\n00010010 // a: 1\\n00011011 // b: 1\\n   |\\n00010100 // c: 1\\n// nothing to flip\\n       5 // count of flips\\n\\n00010010 // a: 1\\n00011011 // b: 1\\n  |\\n00010100 // c: 1\\n// nothing to flip\\n       5 // count of flips\\n\\n00010010 // a: 1\\n00011011 // b: 1\\n |\\n00010100 // c: 1\\n// nothing to flip\\n       5 // count of flips\\n\\n00010010 // a: 1\\n00011011 // b: 1\\n|\\n00010100 // c: 1\\n// nothing to flip\\n       5 // count of flips\\n```\\n\\nAnd we can play smart and stop the loop when no more `1` are left to parse while going left.\\n\\nTo do so, we will start declaring a support variable, `res`, as our counter, initially set to be `0`; we will then loop `while` at least one of the three values `a`, `b` and `c` is `!= 0` and:\\n* if the least significant bit in `c` (ie: `c & 1`) is `1`, we will increase `res` by `1` if both the least significant bits in `a` and `b` are `0`:\\n* otherwise, if the least significant bit in `c` is `0`, we will increase `res` by `1` for each least significant bit in `a` and `b` being currently to `0`;\\n* shave off the bit we just parsed from `a`, `b` and `c` with a bitwise shift right by one position.\\n\\nOnce we are done, we can `return` `res`.\\n\\n# Complexity\\n- Time complexity: $$O(log(max(a, b, b)))$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        // support variables\\n        int res = 0;\\n        // parsing c bit by bit\\n        while (a || b || c) {\\n            // 1st case: least significant bit is 1\\n            if (c & 1) res += !(a & 1) && !(b & 1);\\n            // 2nd case: least significant bit is 0\\n            else res += (a & 1) + (b & 1);\\n            // shaving off the least significant digit from all values\\n            a >>= 1, b >>= 1, c >>= 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```cpp\\n00010010 // a: 18\\n00011011 // b: 27\\n00010100 // c: 20\\n```\n```cpp\\n00010010 // a: 0\\n00011011 // b: 1\\n       |\\n00010100 // c: 0\\n// we need to flip the bit in b to 0 to get 0 from an OR\\n       1 // count of flips\\n\\n00010010 // a: 1\\n00011011 // b: 1\\n      |\\n00010100 // c: 0\\n// we need to flip both bits in a and b to 0 to get 0 from an OR\\n       3 // count of flips\\n\\n00010010 // a: 0\\n00011011 // b: 0\\n     |\\n00010100 // c: 1\\n// we need to flip either bit in a and b to 1 to get 1 from an OR\\n       4 // count of flips\\n\\n00010010 // a: 0\\n00011011 // b: 1\\n    |\\n00010100 // c: 0\\n// we need to flip the bit in b to 0 to get 0 from an OR\\n       5 // count of flips\\n\\n00010010 // a: 1\\n00011011 // b: 1\\n   |\\n00010100 // c: 1\\n// nothing to flip\\n       5 // count of flips\\n\\n00010010 // a: 1\\n00011011 // b: 1\\n  |\\n00010100 // c: 1\\n// nothing to flip\\n       5 // count of flips\\n\\n00010010 // a: 1\\n00011011 // b: 1\\n |\\n00010100 // c: 1\\n// nothing to flip\\n       5 // count of flips\\n\\n00010010 // a: 1\\n00011011 // b: 1\\n|\\n00010100 // c: 1\\n// nothing to flip\\n       5 // count of flips\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        // support variables\\n        int res = 0;\\n        // parsing c bit by bit\\n        while (a || b || c) {\\n            // 1st case: least significant bit is 1\\n            if (c & 1) res += !(a & 1) && !(b & 1);\\n            // 2nd case: least significant bit is 0\\n            else res += (a & 1) + (b & 1);\\n            // shaving off the least significant digit from all values\\n            a >>= 1, b >>= 1, c >>= 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608726,
                "title": "c-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nperform simple `OR` operation on `a` and `b`.\\nThen compare with `c` and check there is need of flipping bits.\\n\\n# Complexity\\n- Time complexity:`O(1)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:`O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n\\n        int flips = 0;    \\n\\n        while(a || b || c){\\n            \\n            int bit1 = a & 1 , bit2 = b & 1 , bit3 = c & 1;\\n\\n            if((bit1 | bit2) != bit3){\\n               \\n                if(bit1 == 1 && bit2 == 1) flips += 2;\\n                else if(bit1 == 0 && bit2 == 0) flips += 1;\\n                else if(bit1 == 0 && bit2 == 1) flips += 1;\\n                else flips += 1;\\n\\n            }\\n\\n            a >>= 1;\\n            b >>= 1;\\n            c >>= 1;\\n\\n        }\\n\\n        return flips;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n\\n        int flips = 0;    \\n\\n        while(a || b || c){\\n            \\n            int bit1 = a & 1 , bit2 = b & 1 , bit3 = c & 1;\\n\\n            if((bit1 | bit2) != bit3){\\n               \\n                if(bit1 == 1 && bit2 == 1) flips += 2;\\n                else if(bit1 == 0 && bit2 == 0) flips += 1;\\n                else if(bit1 == 0 && bit2 == 1) flips += 1;\\n                else flips += 1;\\n\\n            }\\n\\n            a >>= 1;\\n            b >>= 1;\\n            c >>= 1;\\n\\n        }\\n\\n        return flips;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608711,
                "title": "c-solution-using-bit-manipulation",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        \\n        int res=0;\\n\\n        while(a>0 || b>0 || c>0){\\n\\n            int bitOfA=a&1;\\n            int bitOfB=b&1;\\n            int bitOfC=c&1;\\n\\n            if((bitOfA | bitOfB)!=bitOfC){\\n\\n                if(bitOfC==1){\\n                    res++;\\n                }\\n                else{\\n                    res+=(bitOfA+bitOfB);\\n                }\\n            }\\n\\n            a=a>>1;\\n            b=b>>1;\\n            c=c>>1;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        \\n        int res=0;\\n\\n        while(a>0 || b>0 || c>0){\\n\\n            int bitOfA=a&1;\\n            int bitOfB=b&1;\\n            int bitOfC=c&1;\\n\\n            if((bitOfA | bitOfB)!=bitOfC){\\n\\n                if(bitOfC==1){\\n                    res++;\\n                }\\n                else{\\n                    res+=(bitOfA+bitOfB);\\n                }\\n            }\\n\\n            a=a>>1;\\n            b=b>>1;\\n            c=c>>1;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608670,
                "title": "java-very-easy-and-intuitive-beats-100-one-line-solution-without-using-xor",
                "content": "# Approach\\n\\nWe know the property of OR:\\n\\n`If either of the input is 1, the result will be 1`\\n\\nThis means, in order to get `a | b = c`, \\n\\nIf the `i-th` bit of `c is 0`, both the `i-th` bits of `a` and `b` must be `0`.\\nIf the `i-th` bit of `c is 1`, at least one of the `i-th` bits of `a` or `b` must be `1`.\\n\\n1. To obtain the bits that are `set in a` but `not in c`, we can use `a & ~c`. We need to change these bits to `0`.\\n\\n2. Similarly, to obtain the bits that are `set in b` but `not in c`, we can use `b & ~c`. We also need to change these bits to `0`.\\n\\n3. To find the bits that are `set in c` but `not in a | b`, we can use `~(a | b) & c`. We have to change these bits to `1`.\\n\\nOn adding these, we will get our answer.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int minFlips(int a, int b, int c) {\\n        return Integer.bitCount(a & ~c) +  Integer.bitCount(~(a | b) & c) + Integer.bitCount(b & ~c);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minFlips(int a, int b, int c) {\\n        return Integer.bitCount(a & ~c) +  Integer.bitCount(~(a | b) & c) + Integer.bitCount(b & ~c);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608646,
                "title": "simple-observation-on-bit-manuplation",
                "content": "\\n# Approach\\n- Simple observation approch\\n- Think about finding \\'and\\' \\'or\\' and \\'xor\\' operation \\n- \\uD83D\\uDE01 Please Upvote\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n  O(1) \\uD83D\\uDD25\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n\\n        int k = a&b; // finding common set bits to check double flips\\n\\n        int l = a|b; // calculating expected \\'or\\' value\\n        int j = l^c; // finding uncommon bits\\n        int m = j&k; // calculating for extra set bits flips\\n\\nint cnt = 0 , red = 0;\\n        while(j){\\n            cnt += j&1;\\n            j = j>>1;\\n        }\\n        while(m){\\n            red += m&1;\\n            m = m>>1;\\n        }\\n\\n        return cnt+red;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n\\n        int k = a&b; // finding common set bits to check double flips\\n\\n        int l = a|b; // calculating expected \\'or\\' value\\n        int j = l^c; // finding uncommon bits\\n        int m = j&k; // calculating for extra set bits flips\\n\\nint cnt = 0 , red = 0;\\n        while(j){\\n            cnt += j&1;\\n            j = j>>1;\\n        }\\n        while(m){\\n            red += m&1;\\n            m = m>>1;\\n        }\\n\\n        return cnt+red;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608623,
                "title": "java-python-solution-comparing-the-each-bit-of-the-binary-number",
                "content": "# Approach\\nFirst converted all three numbers from decimal to binary and padded the elements which are less in length than binary number of max length among three, After converting checking the each bit of a , b with c based on that we will get the minimum number of changes.  \\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n```java []\\nclass Solution {\\n    public int minFlips(int a, int b, int c) {\\n        int res=0;\\n        int maxDecimal = Math.max(a, Math.max(b, c));\\n        String a1= Integer.toBinaryString(a);\\n        String b1= Integer.toBinaryString(b);\\n        String c1= Integer.toBinaryString(c);\\n        int maxBinaryLength = Integer.toBinaryString(maxDecimal).length();\\n        a1 = padWithLeadingZeros(a1, maxBinaryLength);\\n        b1 = padWithLeadingZeros(b1, maxBinaryLength);\\n        c1 = padWithLeadingZeros(c1, maxBinaryLength);\\n        for(int i=0;i<c1.toCharArray().length;i++){\\n            if(c1.toCharArray()[i]==\\'0\\'){\\n                if(a1.toCharArray()[i]!=\\'0\\')\\n                  res+=1;\\n                if(b1.toCharArray()[i]!=\\'0\\')\\n                res+=1;\\n            }\\n            else if(c1.toCharArray()[i]==\\'1\\'){\\n                if(a1.toCharArray()[i]==\\'0\\' && b1.toCharArray()[i]==\\'0\\')\\n                  res+=1;\\n            }\\n        }\\n        return res;\\n    }\\n     private static String padWithLeadingZeros(String binary, int length) {\\n        int paddingLength = length - binary.length();\\n        StringBuilder paddedBinary = new StringBuilder();\\n\\n        for (int i = 0; i < paddingLength; i++) {\\n            paddedBinary.append(\\'0\\');\\n        }\\n\\n        paddedBinary.append(binary);\\n        return paddedBinary.toString();\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        def padding(s,l):\\n            arr=[]\\n            for i in range(l-len(s)):\\n                arr.append(\\'0\\')\\n            arr.append(s)\\n            return \"\".join(arr)\\n        res=0\\n        maxi=max(a,b,c)\\n        a1=bin(a)[2:]\\n        b1=bin(b)[2:]\\n        c1=bin(c)[2:]\\n        maxlength= len(bin(maxi)[2:])\\n        a1=padding(a1,maxlength)\\n        b1=padding(b1,maxlength)\\n        c1=padding(c1,maxlength)\\n        for i in range(len(c1)):\\n            if(c1[i]==\\'0\\'):\\n                if(a1[i]!=\\'0\\'):\\n                    res+=1\\n                if(b1[i]!=\\'0\\'):\\n                    res+=1\\n            elif(c1[i]==\\'1\\'):\\n                if(a1[i]==\\'0\\' and b1[i]==\\'0\\'):\\n                    res+=1\\n        return res\\n```\\n<!-- Describe your approach to solving the problem. -->",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```java []\\nclass Solution {\\n    public int minFlips(int a, int b, int c) {\\n        int res=0;\\n        int maxDecimal = Math.max(a, Math.max(b, c));\\n        String a1= Integer.toBinaryString(a);\\n        String b1= Integer.toBinaryString(b);\\n        String c1= Integer.toBinaryString(c);\\n        int maxBinaryLength = Integer.toBinaryString(maxDecimal).length();\\n        a1 = padWithLeadingZeros(a1, maxBinaryLength);\\n        b1 = padWithLeadingZeros(b1, maxBinaryLength);\\n        c1 = padWithLeadingZeros(c1, maxBinaryLength);\\n        for(int i=0;i<c1.toCharArray().length;i++){\\n            if(c1.toCharArray()[i]==\\'0\\'){\\n                if(a1.toCharArray()[i]!=\\'0\\')\\n                  res+=1;\\n                if(b1.toCharArray()[i]!=\\'0\\')\\n                res+=1;\\n            }\\n            else if(c1.toCharArray()[i]==\\'1\\'){\\n                if(a1.toCharArray()[i]==\\'0\\' && b1.toCharArray()[i]==\\'0\\')\\n                  res+=1;\\n            }\\n        }\\n        return res;\\n    }\\n     private static String padWithLeadingZeros(String binary, int length) {\\n        int paddingLength = length - binary.length();\\n        StringBuilder paddedBinary = new StringBuilder();\\n\\n        for (int i = 0; i < paddingLength; i++) {\\n            paddedBinary.append(\\'0\\');\\n        }\\n\\n        paddedBinary.append(binary);\\n        return paddedBinary.toString();\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        def padding(s,l):\\n            arr=[]\\n            for i in range(l-len(s)):\\n                arr.append(\\'0\\')\\n            arr.append(s)\\n            return \"\".join(arr)\\n        res=0\\n        maxi=max(a,b,c)\\n        a1=bin(a)[2:]\\n        b1=bin(b)[2:]\\n        c1=bin(c)[2:]\\n        maxlength= len(bin(maxi)[2:])\\n        a1=padding(a1,maxlength)\\n        b1=padding(b1,maxlength)\\n        c1=padding(c1,maxlength)\\n        for i in range(len(c1)):\\n            if(c1[i]==\\'0\\'):\\n                if(a1[i]!=\\'0\\'):\\n                    res+=1\\n                if(b1[i]!=\\'0\\'):\\n                    res+=1\\n            elif(c1[i]==\\'1\\'):\\n                if(a1[i]==\\'0\\' and b1[i]==\\'0\\'):\\n                    res+=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608502,
                "title": "c-solution-well-commented-and-fairly-easy-to-understand",
                "content": "# Approach\\nIterate over each of the bits in a 32-bit integer and compare the values of the bits in that position for a, b, and c.\\n\\n# Complexity\\n- Time complexity: O(n) where n = 32.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: N/A\\n\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinFlips(int a, int b, int c) {\\n        var flips = 0;\\n\\n        // iterate over each bit in a 32-bit integer\\n        for(int i = 0; i < 32; i++) {\\n\\n            // Shift the mask each iteration and use\\n            // a bitwise AND (&) to isolate the bit\\n            // for each number.\\n            var mask = (1 << i);\\n            var aBit = a & mask;\\n            var bBit = b & mask;\\n            var cBit = c & mask;\\n\\n            if(cBit == 0)\\n            {\\n                // With c == 0, if a and b both have 1\\'s\\n                // for the current bit, then 2 flips \\n                // will need to made. \\n                if (aBit > 0 && bBit > 0)\\n                    flips += 2;\\n\\n                // Otherwise, if only one of them has \\n                // a 1 in the current bit position,\\n                // then one flip will need to be made.\\n                else if (aBit > 0 || bBit > 0)\\n                    flips++;\\n            }\\n            else\\n            {\\n                // If the cBit has a 1 in the current\\n                // position and both a and b are 0,\\n                // only one of them needs to be flipped.\\n                if (aBit == 0 && bBit == 0)\\n                    flips++;\\n            }\\n        }\\n        \\n        return flips;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinFlips(int a, int b, int c) {\\n        var flips = 0;\\n\\n        // iterate over each bit in a 32-bit integer\\n        for(int i = 0; i < 32; i++) {\\n\\n            // Shift the mask each iteration and use\\n            // a bitwise AND (&) to isolate the bit\\n            // for each number.\\n            var mask = (1 << i);\\n            var aBit = a & mask;\\n            var bBit = b & mask;\\n            var cBit = c & mask;\\n\\n            if(cBit == 0)\\n            {\\n                // With c == 0, if a and b both have 1\\'s\\n                // for the current bit, then 2 flips \\n                // will need to made. \\n                if (aBit > 0 && bBit > 0)\\n                    flips += 2;\\n\\n                // Otherwise, if only one of them has \\n                // a 1 in the current bit position,\\n                // then one flip will need to be made.\\n                else if (aBit > 0 || bBit > 0)\\n                    flips++;\\n            }\\n            else\\n            {\\n                // If the cBit has a 1 in the current\\n                // position and both a and b are 0,\\n                // only one of them needs to be flipped.\\n                if (aBit == 0 && bBit == 0)\\n                    flips++;\\n            }\\n        }\\n        \\n        return flips;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608405,
                "title": "c-solution-using-builtin-popcount",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        return __builtin_popcount((a | b)^c) + __builtin_popcount((a & b) &((a | b)^c));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        return __builtin_popcount((a | b)^c) + __builtin_popcount((a & b) &((a | b)^c));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608332,
                "title": "c-2-approaches-detailed-explanation-codestorywithmik",
                "content": "YouTube Link : [Minimum Flips to Make a OR b Equal to c](https://www.youtube.com/watch?v=Gx4-uOkopMA)\\nMy Github Treasure : [Minimum Flips to Make a OR b Equal to c ](https://github.com/MAZHARMIK/Interview_DS_Algo/blob/master/Bit_Magic/Minimum%20Flips%20to%20Make%20a%20OR%20b%20Equal%20to%20c.cpp)\\n\\n```\\n//Approach-1 (Visiting all bit one by one and compaing)\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int result = 0;\\n        \\n        while( a != 0 || b != 0 || c != 0) {\\n            \\n            if( (c & 1) == 1) {\\n                if((a & 1) == 0 && (b & 1) == 0) {\\n                    result++;\\n                }\\n            } else {\\n                result += (a & 1) + (b & 1);\\n            }\\n            \\n            a >>= 1;\\n            b >>= 1;\\n            c >>= 1;\\n            \\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n``\\n//Approach-2 (Using inbuild function)\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int result = (a | b) ^ c;\\n        return __builtin_popcount(result) + __builtin_popcount((a & b) & (result));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (Visiting all bit one by one and compaing)\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int result = 0;\\n        \\n        while( a != 0 || b != 0 || c != 0) {\\n            \\n            if( (c & 1) == 1) {\\n                if((a & 1) == 0 && (b & 1) == 0) {\\n                    result++;\\n                }\\n            } else {\\n                result += (a & 1) + (b & 1);\\n            }\\n            \\n            a >>= 1;\\n            b >>= 1;\\n            c >>= 1;\\n            \\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608308,
                "title": "java-solution-100-faster-constanttime-o-32-o-1-simple-easyapproach",
                "content": "# Complexity\\n- Time complexity:$$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minFlips(int a, int b, int c) {\\n        int flips = 0;\\n        int or = a|b;\\n\\n        for(int i=0;i<32;i++){\\n            if((or&(1<<i)) != (c&(1<<i))){\\n\\n                //System.out.println((or&(1<<i)) +\" \"+ (c&(1<<i)));\\n\\n                if((or&(1<<i)) == 0){\\n                    flips++;\\n                }\\n                else{\\n                    if((a&(1<<i)) != 0)\\n                        flips++;\\n                    if((b&(1<<i)) != 0)\\n                        flips++;\\n                }\\n            }\\n        }\\n        return flips;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minFlips(int a, int b, int c) {\\n        int flips = 0;\\n        int or = a|b;\\n\\n        for(int i=0;i<32;i++){\\n            if((or&(1<<i)) != (c&(1<<i))){\\n\\n                //System.out.println((or&(1<<i)) +\" \"+ (c&(1<<i)));\\n\\n                if((or&(1<<i)) == 0){\\n                    flips++;\\n                }\\n                else{\\n                    if((a&(1<<i)) != 0)\\n                        flips++;\\n                    if((b&(1<<i)) != 0)\\n                        flips++;\\n                }\\n            }\\n        }\\n        return flips;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608294,
                "title": "ruby-solution",
                "content": "# Code\\n```ruby []\\n# @param {Integer} a\\n# @param {Integer} b\\n# @param {Integer} c\\n# @return {Integer}\\ndef min_flips(a, b, c)\\n  a, b, c = set_numbers_as_reverse_binary(a, b, c)\\n  max_size = [a.size, b.size, c.size].max\\n  \\n  result = 0\\n  0.upto(max_size - 1) do |index|\\n    if c[index] == \"1\"\\n      result += 1 if (a[index] != \"1\") && (b[index] != \"1\")\\n    else\\n      result += 1 if a[index] == \"1\"\\n      result += 1 if b[index] == \"1\"\\n    end\\n  end\\n\\n  result\\nend\\n\\ndef set_numbers_as_reverse_binary(*nums)\\n  nums.map {|num| num.to_s(2).reverse}\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby []\\n# @param {Integer} a\\n# @param {Integer} b\\n# @param {Integer} c\\n# @return {Integer}\\ndef min_flips(a, b, c)\\n  a, b, c = set_numbers_as_reverse_binary(a, b, c)\\n  max_size = [a.size, b.size, c.size].max\\n  \\n  result = 0\\n  0.upto(max_size - 1) do |index|\\n    if c[index] == \"1\"\\n      result += 1 if (a[index] != \"1\") && (b[index] != \"1\")\\n    else\\n      result += 1 if a[index] == \"1\"\\n      result += 1 if b[index] == \"1\"\\n    end\\n  end\\n\\n  result\\nend\\n\\ndef set_numbers_as_reverse_binary(*nums)\\n  nums.map {|num| num.to_s(2).reverse}\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3608287,
                "title": "c-bit-manipulation-one-liner",
                "content": "# Intuition\\nIntuition is pretty simple: go through each bit of a | b and compare it with corresponding bit of c. Following cases are possible (considering ith_bit is a pseudo-function that returns i-th bit of a number):\\n- **ith_bit(a | b) == ith_bit(c)** - nothing to do. Continue to next position;\\n- **ith_bit(a | b) == 0 && ith_bit(c) == 1** - one flip (either in a or in b) is required\\n- **ith_bit(a | b) == 1 && ith_bit(c) == 0** - two cases are possible here:\\n    - **ith_bit(a & b) == 1** - that means that bits in both a and b are set and therefore should be flipped (2 operations);\\n    - **ith_bit(a & b) == 0** - means that only one bit is set, either in a or in b, and therefore 1 operation is required. \\n\\n# Approach\\nThe provided one-liner is pretty cumbersome, so here\\'s the explanation, fragment by fragment:\\n1) First, we iterate through 0 - 29 (inclusive), as max limit (10^9) fits in 30 bits;\\n2) At each iteration we check bits at corresponding position. 2 consecutive ternary operators are used: \\n    - **(((a | b) ^ c) & 1 << i) == 0** - check if i-th bit of a | b ==  i-th bit of c (using XOR operation). If so - no flips required at current position; add 0 to the result. Otherwise:\\n    - **(a & b & 1 << i) != 0** - check if i-th bit of a and i-th bit of b are both set. If so - both of them should be flipped; add 2 to the result. Otherwise:\\n    - In all other cases - only one flip is required; add 1 to the result.\\n\\n# Complexity\\n- Time complexity:\\nO(1) - constant number of iterations per any input.\\n\\n- Space complexity:\\nO(1) - constant extra space for storing of intermediate results (count of flips so far) is required.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinFlips(int a, int b, int c) {\\n        return Enumerable.Range(0, 30).Sum(i => (((a | b) ^ c) & 1 << i) == 0 ? 0 : (a & b & 1 << i) != 0 ? 2 : 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinFlips(int a, int b, int c) {\\n        return Enumerable.Range(0, 30).Sum(i => (((a | b) ^ c) & 1 << i) == 0 ? 0 : (a & b & 1 << i) != 0 ? 2 : 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608208,
                "title": "python-o-1-solution-beats-81-bitmask-solution-line-by-line-explanation",
                "content": "# Intuition\\nThere are few things we need to understand here \\n1. `AND` operation with `1`\\nInorder to mask bits and get the value of the least significant bit (right most) we `AND` it with `1`.\\nTake this number for example `58`, in binary `58 = 0000...00111010`. Inorder to get the value of the right most bit if we AND it with `1 = 0000...00000001`\\n    ```\\n      0000...00111010\\n    & 0000...00000001\\n      ---------------\\n      0000...00000000\\n    ```\\n    we get `0`\\n\\n    Let\\'s take another example `59`, in binary `59 = 0000...00111011`. Inorder to get the value of the right most bit if we AND it with `1 = 0000...00000001`\\n    ```\\n      0000...00111011\\n    & 0000...00000001\\n      ---------------\\n      0000...00000001\\n    ```\\n    we get `1`\\n\\n2. Bit Shift. \\nIn Python we use `>>` operator to drop the right most bit.\\nFor example: if we take `58` for example, in binary the value will be `0000...00111010`. \\nIf we shift this number to the right by 1 bit, the number becomes - `0000...00011101`\\nIf we shift it again it becomes - `0000...00001110`\\nAnd again it becomes - `0000...00000111`\\nWe can see how this might come in handy if we want to check the value of `i-th` bit.\\n\\n3. OR Operation (Since in the question are doing OR operation of `a` and `b`).\\nNow based on the example in the question\\n![image.png](https://assets.leetcode.com/users/images/5dcd4a7e-2dc5-471d-b27c-29b0dc12c65d_1686123895.6846492.png)\\n\\n    There\\'s few observations we can make\\n    if `c`\\'s `i-th` bit is `1` then either `a`\\'s or `b`\\'s `i-th` bit has to be `1`. If not we add `1` to our `count`.\\n    if `c`\\'s `i-th` bit is `0` then we need to check whether-\\n    1. `a`\\'s `i-th` bit == 1 and `b`\\'s `i-th` bit == `1`, in that case add `2` to our `count`\\n    2. `a`\\'s `i-th` bit == 1 or `b`\\'s `i-th` bit == `1` but NOT both. Then we add `1` to our `count`\\n    3. Otherwise if both are `0` then we add `0` to the count. \\n\\n    Remember inorder for an OR operator to be `0` both `a`\\'s `i-th` and `b`\\'s `i-th` bits have to be `0` otherwise we take turns flipping bits until both are `0`.\\n\\nHere\\'s a recap of our logic gates\\n![image.png](https://assets.leetcode.com/users/images/5a4e769d-07cc-4601-9ca4-4fff461d3215_1686123972.6182215.png)\\n\\n# Approach\\nIterate until all 3 numbers are `0`\\n```\\nwhile a > 0 or b > 0 or c > 0:\\n```\\n\\nFor each of the 3 numbers get the right most bit\\n```\\n    temp_a = a & 1\\n    temp_b = b & 1\\n    temp_c = c & 1\\n```\\n\\nIf `temp_c` or `c`\\'s right most bit it `0` then we need to flip `0,1,2` number of bits to `0` based on `temp_a`\\'s + `temp_b`\\'s value. (The sum if the two will tell us how many bits are `1`)\\n```\\n    if temp_c == 0:\\n        count += temp_a + temp_b\\n```\\nOtherwise if `temp_c` or `c`\\'s right most bit it `1`, then we need to check if either `temp_a == 1` or `temp_b == 1`, if not then we need to flip atleast `1` of the two bits to `1` so increment `count` by `1` otherwise we don\\'t need to increment `count`.\\n```\\n    else:\\n        count += 1 if temp_a + temp_b == 0 else 0\\n```\\n\\nSince we have evaluated the right most bit, we can choose to drop the bit by using right shift `>>` on all 3 numbers\\n```\\n    a = a >> 1\\n    b = b >> 1\\n    c = c >> 1\\n```\\n\\nFinally return the `count`\\n```\\nreturn count\\n```\\n# Complexity\\n- Time complexity:\\nO(1) Since integers are in the range of 32 bits, so we have fixed number of iterations.\\n\\n- Space complexity:\\nO(1) Since we are not saving any value.\\n\\n# Code\\n```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        count = 0\\n        while a > 0 or b > 0 or c > 0:\\n            temp_a = a & 1\\n            temp_b = b & 1\\n            temp_c = c & 1\\n            if temp_c == 0:\\n                count += temp_a + temp_b\\n            else:\\n                count += 1 if temp_a + temp_b == 0 else 0\\n            a = a >> 1\\n            b = b >> 1\\n            c = c >> 1\\n        return count\\n```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\n      0000...00111010\\n    & 0000...00000001\\n      ---------------\\n      0000...00000000\\n    ```\n```\\n      0000...00111011\\n    & 0000...00000001\\n      ---------------\\n      0000...00000001\\n    ```\n```\\nwhile a > 0 or b > 0 or c > 0:\\n```\n```\\n    temp_a = a & 1\\n    temp_b = b & 1\\n    temp_c = c & 1\\n```\n```\\n    if temp_c == 0:\\n        count += temp_a + temp_b\\n```\n```\\n    else:\\n        count += 1 if temp_a + temp_b == 0 else 0\\n```\n```\\n    a = a >> 1\\n    b = b >> 1\\n    c = c >> 1\\n```\n```\\nreturn count\\n```\n```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        count = 0\\n        while a > 0 or b > 0 or c > 0:\\n            temp_a = a & 1\\n            temp_b = b & 1\\n            temp_c = c & 1\\n            if temp_c == 0:\\n                count += temp_a + temp_b\\n            else:\\n                count += 1 if temp_a + temp_b == 0 else 0\\n            a = a >> 1\\n            b = b >> 1\\n            c = c >> 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608169,
                "title": "java-solution-with-detailed-explanation",
                "content": "# Intuition\\nWe should go through the each triplet of bits and check whether **OR** is correct or not and count the amount of bits to be flipped. \\n# Approach\\nWe are going from 0 to 31 bit of signed integer using the first bit mask making **&** operation with 1 to get the first bit of each number(**aBit, bBit, cBit**) and at the end of each step we perform **>>** operation to get the next bit. How can we count the flips? At each itteration we have just two possible options when we need to flip bits. 1) **aBit = 1, bBit = 1, cBit = 0**; 2) **aBit = 0, bBit = 0, cBit = 1**. In the first case we need to flip both bits, in the second case is enought to flip just one bit. If we look carefully on that we can see that we should just count the number of **1**\\'s among the bits if **aBit | bBit != cBit**\\n\\n# Complexity\\n- Time complexity:\\n**O(1)**\\n\\n- Space complexity:\\n**O(1)**\\n\\n# Code\\n```\\nclass Solution {\\n\\n  public int minFlips(int a, int b, int c) {\\n    int result = 0;\\n    for (int i = 0; i < 32; i++) {\\n      int aBit = a & 1;\\n      int bBit = b & 1;\\n      int cBit = c & 1;\\n\\n      if ((aBit | bBit) != cBit) {\\n        result += (aBit + bBit + cBit);\\n      }\\n\\n      a = a >> 1;\\n      b = b >> 1;\\n      c = c >> 1;\\n    }\\n\\n    return result;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n  public int minFlips(int a, int b, int c) {\\n    int result = 0;\\n    for (int i = 0; i < 32; i++) {\\n      int aBit = a & 1;\\n      int bBit = b & 1;\\n      int cBit = c & 1;\\n\\n      if ((aBit | bBit) != cBit) {\\n        result += (aBit + bBit + cBit);\\n      }\\n\\n      a = a >> 1;\\n      b = b >> 1;\\n      c = c >> 1;\\n    }\\n\\n    return result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608099,
                "title": "easy-c-code",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>dectobin(int n)\\n    {\\n        vector<int>binaryNum(32);\\n    int i = 0;\\n    while (n > 0) {\\n        binaryNum[i] = n % 2;\\n        n = n / 2;\\n        i++;\\n    }\\n    return binaryNum;\\n    }\\n    int minFlips(int a, int b, int c) {\\n        int k=a|b;\\n        vector<int>p=dectobin(k);\\n        vector<int>o=dectobin(c);\\n        int count=0;\\n        for (int i = 0; i < 32; i++) {\\n            if (o[i] == 1) {\\n                if (p[i] != 1)\\n                    count++;\\n            } else {\\n                if (p[i] == 1 && (a & (1 << i)) && (b & (1 << i)))\\n                    count += 2;\\n                else if (p[i] == 1 && ((a & (1 << i)) || (b & (1 << i))))\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>dectobin(int n)\\n    {\\n        vector<int>binaryNum(32);\\n    int i = 0;\\n    while (n > 0) {\\n        binaryNum[i] = n % 2;\\n        n = n / 2;\\n        i++;\\n    }\\n    return binaryNum;\\n    }\\n    int minFlips(int a, int b, int c) {\\n        int k=a|b;\\n        vector<int>p=dectobin(k);\\n        vector<int>o=dectobin(c);\\n        int count=0;\\n        for (int i = 0; i < 32; i++) {\\n            if (o[i] == 1) {\\n                if (p[i] != 1)\\n                    count++;\\n            } else {\\n                if (p[i] == 1 && (a & (1 << i)) && (b & (1 << i)))\\n                    count += 2;\\n                else if (p[i] == 1 && ((a & (1 << i)) || (b & (1 << i))))\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608084,
                "title": "easy-solution-cpp-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(32)\\n- we can say that O(1) because 32 is small number\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n#define ll long long\\n    int minFlips(int a, int b, int c) {\\n        int cnt=0;\\n        for(int i=0;i<32;i++){\\n            ll e = (1LL)<<i;\\n            if((c&e)==0){\\n                if((a&e)!=0  && (b&e)!=0){\\n                    cnt+=2;\\n                }else if((a&e)!=0||(b&e)!=0){\\n                    cnt++;\\n                }\\n            }else{\\n                if((a&e)==0  && (b&e)==0){\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n// 100 010 111\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n#define ll long long\\n    int minFlips(int a, int b, int c) {\\n        int cnt=0;\\n        for(int i=0;i<32;i++){\\n            ll e = (1LL)<<i;\\n            if((c&e)==0){\\n                if((a&e)!=0  && (b&e)!=0){\\n                    cnt+=2;\\n                }else if((a&e)!=0||(b&e)!=0){\\n                    cnt++;\\n                }\\n            }else{\\n                if((a&e)==0  && (b&e)==0){\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n// 100 010 111\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608071,
                "title": "minimum-flips-to-make-a-or-b-equal-to-c-c-beginner-friendly-explained",
                "content": "# Intuition\\n###### In OR operation we know that if any of bit is 1 then OR operation will give 1 as result. As we have to make a|b == c so we will traverse through all bits of  a,b and c using right shift and we will try to make a|b equal to c using the following steps: \\n- If the current bit or least significant of c is 0 then current bit of both a and b should be 0. So if any one of them don\\'t have zero we will flip them.\\n- If the current bit of c is 1 then atleast one of them should have the current bit as 1. If both have current bit as 0 then we will flip anyone of them.\\n- Then we will use the right shift operator which will right shift the least significant bit on a,b and c.\\n\\n###### At last we will count the number of flip and return the result. \\n\\n---\\n\\n\\n# Approach\\n1. We will create a variable result to count the number of flips.\\n2. We will run a loop to traverse a, b and c.\\n3. We will store the current bit of c in variable x.\\n4. We wiil now check if x == 0 then current bit of  both of them should be zero. If any of them is not zero we will increment the value of result.\\n5. If the value of x == 1 and both of them have 0 as current bit then we will increment result by one.\\n\\n###### At last we will return the result.\\n\\n---\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$ \\n\\n- Space complexity:\\n $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n          int result = 0;\\n          while(a != 0 || b != 0 || c != 0)\\n          {\\n              int x = c & 1;\\n\\n              if(x == 0 && (a&1) == 1) result++;\\n              if(x == 0 && (b&1) == 1) result++;\\n              if(x == 1 && (a&1) == 0 && (b&1) == 0)result++;\\n\\n              a>>=1;\\n              b>>=1;\\n              c>>=1;\\n          }\\n          return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n          int result = 0;\\n          while(a != 0 || b != 0 || c != 0)\\n          {\\n              int x = c & 1;\\n\\n              if(x == 0 && (a&1) == 1) result++;\\n              if(x == 0 && (b&1) == 1) result++;\\n              if(x == 1 && (a&1) == 0 && (b&1) == 0)result++;\\n\\n              a>>=1;\\n              b>>=1;\\n              c>>=1;\\n          }\\n          return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608070,
                "title": "c-solution-beats-100-upvote-if-helpful",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int ans;\\n        while(a>0 || b>0 || c>0){\\n            int bita =a&1;\\n            int bitb = b&1;\\n            int bitc = c&1;\\n            if((bita||bitb)!=bitc){\\n                if(bitc==1) ans++;\\n                else ans+=(bita + bitb);\\n            }\\n            a >>= 1;\\n            b >>=1;\\n            c >>=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int ans;\\n        while(a>0 || b>0 || c>0){\\n            int bita =a&1;\\n            int bitb = b&1;\\n            int bitc = c&1;\\n            if((bita||bitb)!=bitc){\\n                if(bitc==1) ans++;\\n                else ans+=(bita + bitb);\\n            }\\n            a >>= 1;\\n            b >>=1;\\n            c >>=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608020,
                "title": "69-iq-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn min_flips(a: i32, b: i32, c: i32) -> i32 {\\n        let mut changes = 0;\\n\\n        for i in 0..32 {\\n            if (c >> i) & 1 == 1 {\\n                changes += ((a >> i) & 1 == 0 && (b >> i) & 1 == 0) as i32;\\n            } else {\\n                changes += ((a >> i) & 1 == 1) as i32 + ((b >> i) & 1 == 1) as i32;\\n            }\\n        }\\n\\n        changes\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_flips(a: i32, b: i32, c: i32) -> i32 {\\n        let mut changes = 0;\\n\\n        for i in 0..32 {\\n            if (c >> i) & 1 == 1 {\\n                changes += ((a >> i) & 1 == 0 && (b >> i) & 1 == 0) as i32;\\n            } else {\\n                changes += ((a >> i) & 1 == 1) as i32 + ((b >> i) & 1 == 1) as i32;\\n            }\\n        }\\n\\n        changes\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3607921,
                "title": "beats-100-simple-solution-bit-manipulation-constant-time-constant-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTake Or of \"a\" and \"b\" and try to check how can you convert (a || b)==c . Count every bit that has to be flipped \\nTry to think of every case that you will encounter.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere will be 4 cases in the question \\n- For every ith bit\\n- Case 1:  \\n    a[i]==1 and b[i]==1 but c[i]==0 you have to flip 2 bit (a[i],b[i])\\n- Case 2: \\n    a[i]==0 and b[i]==0 c[i]==1 you have to flip any one bit (a[i],b[i])\\n\\n- Case 3: \\n    a[i]==0 and b[i]==1 c[i]==0 you have to flip one bit b[[i]\\n\\n- Case 4: \\n    a[i]==0 and b[i]==0 c[i]==1 you have to flip one bit a[i]\\n\\ncount for every cases for i=1 to 32\\nbecause in integer there are 32 bits \\n\\n# Complexity\\n- Time complexity: O(32)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Please Upvote \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkBit(int n,int ind){\\n        if(n & 1<<ind)  // if bit is 1 at that location \\n            return true;\\n        return false;\\n    }\\n    int minFlips(int a, int b, int c) {\\n        int ans=0;\\n        for(int i=0;i<32;i++){\\n            if(checkBit(a,i) && checkBit(b,i) && !checkBit(c,i))\\n                ans+=2; // case 1 \\n            else if(!checkBit(a,i) && checkBit(c,i) && !checkBit(b,i))\\n                ans++; // case 2 \\n            else if(!checkBit(a,i) && !checkBit(c,i) && checkBit(b,i))\\n                ans++; // case 3\\n            \\n            else if(checkBit(a,i) && !checkBit(c,i) && !checkBit(b,i))\\n                ans++; // case 4 \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkBit(int n,int ind){\\n        if(n & 1<<ind)  // if bit is 1 at that location \\n            return true;\\n        return false;\\n    }\\n    int minFlips(int a, int b, int c) {\\n        int ans=0;\\n        for(int i=0;i<32;i++){\\n            if(checkBit(a,i) && checkBit(b,i) && !checkBit(c,i))\\n                ans+=2; // case 1 \\n            else if(!checkBit(a,i) && checkBit(c,i) && !checkBit(b,i))\\n                ans++; // case 2 \\n            else if(!checkBit(a,i) && !checkBit(c,i) && checkBit(b,i))\\n                ans++; // case 3\\n            \\n            else if(checkBit(a,i) && !checkBit(c,i) && !checkBit(b,i))\\n                ans++; // case 4 \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607914,
                "title": "c-simple-bit-manipulation-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int flips = 0;\\n        int a_bit, b_bit, c_bit;\\n\\n        while (a > 0 || b > 0 || c > 0) {\\n            a_bit = a & 1;  // same as a % 2\\n            b_bit = b & 1;\\n            c_bit = c & 1;\\n\\n            a = a >> 1;\\n            b = b >> 1;\\n            c = c >> 1;\\n\\n            if (c_bit == 0) {\\n                if (a_bit == 1) flips++;\\n                if (b_bit == 1) flips++;\\n            } else if (c_bit == 1) {\\n                if (a_bit == 1 || b_bit == 1)\\n                    continue;\\n                else flips++;\\n            }\\n        } \\n    \\n        return flips;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int flips = 0;\\n        int a_bit, b_bit, c_bit;\\n\\n        while (a > 0 || b > 0 || c > 0) {\\n            a_bit = a & 1;  // same as a % 2\\n            b_bit = b & 1;\\n            c_bit = c & 1;\\n\\n            a = a >> 1;\\n            b = b >> 1;\\n            c = c >> 1;\\n\\n            if (c_bit == 0) {\\n                if (a_bit == 1) flips++;\\n                if (b_bit == 1) flips++;\\n            } else if (c_bit == 1) {\\n                if (a_bit == 1 || b_bit == 1)\\n                    continue;\\n                else flips++;\\n            }\\n        } \\n    \\n        return flips;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607899,
                "title": "my-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minFlips(int a, int b, int c) {\\n        if((a | b) == c){\\n            return 0;\\n        }\\n        int count = 0;\\n        while(c > 0){\\n            if((c & 1) == 1){\\n                if((a & 1) != 1 && (b & 1) != 1){\\n                    count++;\\n                }\\n            }else{\\n                if((a & 1) == 1){\\n                    count++;\\n                }\\n                if((b & 1) == 1){\\n                    count++;\\n                }\\n            }\\n            a >>= 1;\\n            b >>= 1;\\n            c >>= 1;\\n        }\\n        while(a > 0){\\n            if((a & 1) == 1){\\n                count++;\\n            }\\n            a >>= 1;\\n        }\\n        while(b > 0){\\n            if((b & 1) == 1){\\n                count++;\\n            }\\n            b >>= 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minFlips(int a, int b, int c) {\\n        if((a | b) == c){\\n            return 0;\\n        }\\n        int count = 0;\\n        while(c > 0){\\n            if((c & 1) == 1){\\n                if((a & 1) != 1 && (b & 1) != 1){\\n                    count++;\\n                }\\n            }else{\\n                if((a & 1) == 1){\\n                    count++;\\n                }\\n                if((b & 1) == 1){\\n                    count++;\\n                }\\n            }\\n            a >>= 1;\\n            b >>= 1;\\n            c >>= 1;\\n        }\\n        while(a > 0){\\n            if((a & 1) == 1){\\n                count++;\\n            }\\n            a >>= 1;\\n        }\\n        while(b > 0){\\n            if((b & 1) == 1){\\n                count++;\\n            }\\n            b >>= 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607863,
                "title": "easy-java-solution-100-fast",
                "content": "\\n\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minFlips(int a, int b, int c) {\\n        int ans=0;\\n        int i=0;\\n\\n        // check bit positon from 0 to 32\\n        while(i<32){\\n            if((a%2==c%2 || b%2==c%2) && c%2==1){\\n                //do nothing\\n            }\\n            else if(c%2==0){\\n                if(a%2==1)\\n                    ans++;\\n                if(b%2==1)\\n                    ans++;\\n            }\\n            else{\\n                ans++;\\n            }\\n            //shift right\\n            a=a>>1; \\n            b=b>>1;\\n            c=c>>1;\\n            i++;  \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minFlips(int a, int b, int c) {\\n        int ans=0;\\n        int i=0;\\n\\n        // check bit positon from 0 to 32\\n        while(i<32){\\n            if((a%2==c%2 || b%2==c%2) && c%2==1){\\n                //do nothing\\n            }\\n            else if(c%2==0){\\n                if(a%2==1)\\n                    ans++;\\n                if(b%2==1)\\n                    ans++;\\n            }\\n            else{\\n                ans++;\\n            }\\n            //shift right\\n            a=a>>1; \\n            b=b>>1;\\n            c=c>>1;\\n            i++;  \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607837,
                "title": "beats-100-cpp-sol",
                "content": "# **Pls Upvote if Helpful\\uD83D\\uDE07**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        if((a|b)==c)\\n            return 0;\\n        \\n        int flips=0;\\n        \\n        while(c!=0 || a!=0 || b!=0 ) //compare bits of the numbers as long as atleast one of them is nonzero\\n        {\\n            if((c&1)==1)\\n            {\\n                if((a&1)==0 && (b&1)==0) //if both are zero while c is 1,one flip is needed\\n                    flips+=1;\\n                \\n            }\\n            \\n            else if((c&1)==0)\\n            {\\n                if((a&1)==1 && (b&1)==1) //if both are one while c is zero,we need to change both the bits to zero to get the result .So,this requires 2 flips.\\n                    flips+=2;\\n                \\n                else if((a&1)==1 || (b&1)==1) //if one of the bits is one while c is zero,we need to flip it once.\\n                    flips+=1;\\n                \\n            }\\n            a >>=1;\\n            b >>=1;\\n            c >>=1;\\n        }\\n       return flips;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        if((a|b)==c)\\n            return 0;\\n        \\n        int flips=0;\\n        \\n        while(c!=0 || a!=0 || b!=0 ) //compare bits of the numbers as long as atleast one of them is nonzero\\n        {\\n            if((c&1)==1)\\n            {\\n                if((a&1)==0 && (b&1)==0) //if both are zero while c is 1,one flip is needed\\n                    flips+=1;\\n                \\n            }\\n            \\n            else if((c&1)==0)\\n            {\\n                if((a&1)==1 && (b&1)==1) //if both are one while c is zero,we need to change both the bits to zero to get the result .So,this requires 2 flips.\\n                    flips+=2;\\n                \\n                else if((a&1)==1 || (b&1)==1) //if one of the bits is one while c is zero,we need to flip it once.\\n                    flips+=1;\\n                \\n            }\\n            a >>=1;\\n            b >>=1;\\n            c >>=1;\\n        }\\n       return flips;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607735,
                "title": "simulation",
                "content": "```\\n class Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        \\n        int cnt = 0;\\n        while(a || b|| c)\\n        {\\n            bool aa = (a&1);\\n            bool bb = (b&1);\\n            bool cc = (c&1);\\n            \\n            if((aa|bb)!=cc)\\n            {\\n                if(aa && bb)\\n                    cnt+=2;\\n                else\\n                    cnt++;\\n                \\n            }\\n            \\n            a=a>>1;\\n            b=b>>1;\\n            c=c>>1;\\n        }\\n        \\n        return cnt;\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n class Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        \\n        int cnt = 0;\\n        while(a || b|| c)\\n        {\\n            bool aa = (a&1);\\n            bool bb = (b&1);\\n            bool cc = (c&1);\\n            \\n            if((aa|bb)!=cc)\\n            {\\n                if(aa && bb)\\n                    cnt+=2;\\n                else\\n                    cnt++;\\n                \\n            }\\n            \\n            a=a>>1;\\n            b=b>>1;\\n            c=c>>1;\\n        }\\n        \\n        return cnt;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607706,
                "title": "c-easy-solution-bit-extraction-t-c-o-1-s-c-o-1",
                "content": "# Intuition\\nChecking bits of C and comparign with A and B.\\nIf they do not satisfy the relation of OR than increase count value.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Extratct all bits\\n2. Now check whether ith bit of C is set or not.\\n    ***i.) If set :-***\\n        Check whether ith bit of A and B are set or not. If they both are set,we need to flip one to have OR value equal to 1.\\n\\n    ***ii)If not set: -***\\n        Check whether ith bit of A or B is set or not.\\n        If both have ith bit as set, increase counter twice, else if any one has ith bit as set, increase counter by 1;\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int cnt = 0;\\n        vector<int> A(32,0),B(32,0),C(32,0);\\n\\n        for(int i = 0 ; i < 32 ;i++){\\n            A[i]=a&(1<<i);\\n            B[i]=(b&(1<<i));\\n            C[i]=(c&(1<<i));\\n        }\\n\\n        for(int i = 0 ; i < 32 ; i++){\\n            if(C[i]==0){\\n                if(A[i]==0 && B[i]!=0)cnt++;\\n                else if(A[i]!=0 && B[i]==0)cnt++;\\n                else if(A[i]!=0 && B[i]!=0)cnt+=2;\\n            }else if(C[i]!=0){\\n                if(A[i]==0 && B[i]==0)cnt++;\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int cnt = 0;\\n        vector<int> A(32,0),B(32,0),C(32,0);\\n\\n        for(int i = 0 ; i < 32 ;i++){\\n            A[i]=a&(1<<i);\\n            B[i]=(b&(1<<i));\\n            C[i]=(c&(1<<i));\\n        }\\n\\n        for(int i = 0 ; i < 32 ; i++){\\n            if(C[i]==0){\\n                if(A[i]==0 && B[i]!=0)cnt++;\\n                else if(A[i]!=0 && B[i]==0)cnt++;\\n                else if(A[i]!=0 && B[i]!=0)cnt+=2;\\n            }else if(C[i]!=0){\\n                if(A[i]==0 && B[i]==0)cnt++;\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607666,
                "title": "detailed-explanation-easy-approach-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is obviously a bit manipulation question. However, if you are like me, bit-manipulation is eugh.\\nSo what approach can be taken for the problem?\\nI converted each number into an array of it\\'s binary representation!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst off, we made the fuction to convert the number into an array of it\\'s binary representation.\\nIn my case, the binary representation is flipped, but in this case it does not matter.... so I did not bother it flip it back.\\nSince ```Int``` numbers are garunteed to fit into 32 bits, our time complexity for this operation is $$O(32)$$~$$O(1)$$.\\n\\nNow for each number ```a``` ```b``` ```c```, convert it to it\\'s binary vector representation.\\n\\nNow for each of the bits, try to make the ```bit(A) OR bit(B) == bit(C)```.\\nThis can be done by simple if statements, which of you can be able to come up with if you are fammiliar with the OR operation\\n\\n![image1](https://i0.wp.com/blog.oureducation.in/wp-content/uploads/2013/05/2-Input-OR-Gate-Truth-Table.jpg?ssl=1)\\nUsing this Approach, the question undoubtedly goes from a medium to an easy difficulty.\\n\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    vector<int> decToBinary(int n)\\n    {\\n        vector<int> binaryNum(32, 0);\\n    \\n        int i = 0;\\n        while (n > 0) {\\n                binaryNum[i] = n % 2;\\n            n = n / 2;\\n            i++;\\n        }\\n        return binaryNum;\\n    }\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        vector<int> bin_a = decToBinary(a), bin_b = decToBinary(b), bin_c = decToBinary(c);\\n        int ans = 0;\\n        for(int i = 0; i< bin_c.size(); i++){\\n            if(bin_c[i] == 0){\\n                if(bin_a[i] == 1){\\n                    ans++;\\n                }\\n                if(bin_b[i] == 1){\\n                    ans++;\\n                }\\n            }\\n            else{\\n                if(bin_a[i] == 0 && bin_b[i] == 0){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```Int```\n```a```\n```b```\n```c```\n```bit(A) OR bit(B) == bit(C)```\n```\\nclass Solution {\\nprivate:\\n    vector<int> decToBinary(int n)\\n    {\\n        vector<int> binaryNum(32, 0);\\n    \\n        int i = 0;\\n        while (n > 0) {\\n                binaryNum[i] = n % 2;\\n            n = n / 2;\\n            i++;\\n        }\\n        return binaryNum;\\n    }\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        vector<int> bin_a = decToBinary(a), bin_b = decToBinary(b), bin_c = decToBinary(c);\\n        int ans = 0;\\n        for(int i = 0; i< bin_c.size(); i++){\\n            if(bin_c[i] == 0){\\n                if(bin_a[i] == 1){\\n                    ans++;\\n                }\\n                if(bin_b[i] == 1){\\n                    ans++;\\n                }\\n            }\\n            else{\\n                if(bin_a[i] == 0 && bin_b[i] == 0){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607663,
                "title": "100-beats-without-bit-manipulation-2-approaches",
                "content": "# Intuition\\nComparing the respective bits of a,b,c in binary form and then counting the no. of bits to be changed.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach 1\\nUsing Deque to convert a,b,c in binary form, then comparing the bits\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    deque<int> decimal_to_binary(int n ){\\n        deque<int>v;\\n  while(n!=0){\\n      v.push_front(n%2);\\n      n = n/2;\\n  }\\n   return v;\\n}\\n    int minFlips(int a, int b, int c) {\\n        deque<int>va,vb,vc;\\n        va = decimal_to_binary(a);\\n        vb = decimal_to_binary(b);\\n        vc = decimal_to_binary(c);\\n\\n       int maxi= max(va.size(),vb.size());\\n       int e= vc.size();\\n       int max_size = max(maxi,e);\\n      \\n        if(va.size() < max_size){\\n            int x= max_size - va.size();\\n           for(int i=0;i<x;i++){\\n               va.push_front(0);\\n           }\\n        }\\n         if(vb.size() < max_size){\\n             int x = max_size - vb.size();\\n           for(int i=0;i<x;i++){\\n               vb.push_front(0);\\n           }\\n        }\\n         if(vc.size() < max_size){\\n             int x = max_size - vc.size();\\n           for(int i=0;i<x;i++){\\n               vc.push_front(0);\\n           }\\n        }\\n        \\n        int count=0;\\n     for(int i=0;i<max_size;i++){\\n          if((vc[i]==1 && va[i]==0 && vb[i]==0) || vc[i]==0 && va[i]==1 && vb[i]==0 || vc[i]==0 && va[i]==0 && vb[i]==1){\\n              count++;\\n          }\\n          else if(vc[i]==0 && va[i]==1 && vb[i]==1){\\n              count+=2;\\n          }\\n         \\n     }\\n     return count;\\n       \\n    }\\n};\\n\\n```\\n# Approach 2\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int count = 0;\\n\\n        while(a > 0 || b > 0 || c > 0){\\n            int x = a % 2;\\n            int y = b % 2;\\n            int z = c % 2;\\n\\n            if((x | y) == 0){\\n                if(z == 1){\\n                    count++;\\n                }\\n            }\\n\\n            if((x | y) == 1){\\n                if((x & y) == 0){\\n                    // Check for z\\n                    if(z == 0){\\n                        count++;\\n                    }\\n                }else{\\n                    if(z == 0){\\n                        count += 2;\\n                    }\\n                }\\n            }\\n            a = a / 2;\\n            b = b / 2;\\n            c = c / 2;\\n        }\\n        return count;\\n    }\\n};\\n```\\nPlease Upvote \\uD83D\\uDC4D\\uD83D\\uDC4D\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    deque<int> decimal_to_binary(int n ){\\n        deque<int>v;\\n  while(n!=0){\\n      v.push_front(n%2);\\n      n = n/2;\\n  }\\n   return v;\\n}\\n    int minFlips(int a, int b, int c) {\\n        deque<int>va,vb,vc;\\n        va = decimal_to_binary(a);\\n        vb = decimal_to_binary(b);\\n        vc = decimal_to_binary(c);\\n\\n       int maxi= max(va.size(),vb.size());\\n       int e= vc.size();\\n       int max_size = max(maxi,e);\\n      \\n        if(va.size() < max_size){\\n            int x= max_size - va.size();\\n           for(int i=0;i<x;i++){\\n               va.push_front(0);\\n           }\\n        }\\n         if(vb.size() < max_size){\\n             int x = max_size - vb.size();\\n           for(int i=0;i<x;i++){\\n               vb.push_front(0);\\n           }\\n        }\\n         if(vc.size() < max_size){\\n             int x = max_size - vc.size();\\n           for(int i=0;i<x;i++){\\n               vc.push_front(0);\\n           }\\n        }\\n        \\n        int count=0;\\n     for(int i=0;i<max_size;i++){\\n          if((vc[i]==1 && va[i]==0 && vb[i]==0) || vc[i]==0 && va[i]==1 && vb[i]==0 || vc[i]==0 && va[i]==0 && vb[i]==1){\\n              count++;\\n          }\\n          else if(vc[i]==0 && va[i]==1 && vb[i]==1){\\n              count+=2;\\n          }\\n         \\n     }\\n     return count;\\n       \\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int count = 0;\\n\\n        while(a > 0 || b > 0 || c > 0){\\n            int x = a % 2;\\n            int y = b % 2;\\n            int z = c % 2;\\n\\n            if((x | y) == 0){\\n                if(z == 1){\\n                    count++;\\n                }\\n            }\\n\\n            if((x | y) == 1){\\n                if((x & y) == 0){\\n                    // Check for z\\n                    if(z == 0){\\n                        count++;\\n                    }\\n                }else{\\n                    if(z == 0){\\n                        count += 2;\\n                    }\\n                }\\n            }\\n            a = a / 2;\\n            b = b / 2;\\n            c = c / 2;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607559,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        if((a|b)==c)return 0;\\n        int count=0;\\n        while(c || a || b){\\n            if((c&1) == 1) count+=!((a&1) || (b&1));\\n            else if((c&1)==0) count+=(a&1)+(b&1);\\n            a>>=1;\\n            b>>=1;\\n            c>>=1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        if((a|b)==c)return 0;\\n        int count=0;\\n        while(c || a || b){\\n            if((c&1) == 1) count+=!((a&1) || (b&1));\\n            else if((c&1)==0) count+=(a&1)+(b&1);\\n            a>>=1;\\n            b>>=1;\\n            c>>=1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607546,
                "title": "beats-100-easy-solution-c-0-ms-most-optimized",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int res=0;\\n        for(int i=0;i<32;i++){\\n            bool x=false,y=false,z=false;\\n            \\n            if(a & (1<<i))\\n                x=true;\\n            if(b & (1<<i)) \\n                y=true;\\n            if(c & (1<<i))\\n                z=true;\\n            \\n            if(z==false){\\n                if(x==true and y==true)\\n                    res+=2;\\n                else if(x==true or y==true)\\n                    res++;\\n            }\\n            else{\\n                if(x==false and y==false) \\n                    res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n1. In this code I\\u2019m checking every i th bit and corresponding to it incrementing the result count.",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int res=0;\\n        for(int i=0;i<32;i++){\\n            bool x=false,y=false,z=false;\\n            \\n            if(a & (1<<i))\\n                x=true;\\n            if(b & (1<<i)) \\n                y=true;\\n            if(c & (1<<i))\\n                z=true;\\n            \\n            if(z==false){\\n                if(x==true and y==true)\\n                    res+=2;\\n                else if(x==true or y==true)\\n                    res++;\\n            }\\n            else{\\n                if(x==false and y==false) \\n                    res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607542,
                "title": "easy-to-understand-c-solution-beats-100",
                "content": "# Approach\\nWe will check the rightmost bits for each number and then shift right all the numbers once checked. Just an important point to keep in mind is that the condition for while loop should contain OR and not AND between different conditions.\\n\\nwhile(a!=0 **||** b!=0 **||** c!=0)\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\nwhere n is the number of bits in each number.\\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int flips=0;\\n        if((a|b)==c)\\n            return 0;\\n        while(a!=0 || b!=0 || c!=0)\\n        {\\n            int bitA=a&1;\\n            int bitB=b&1;\\n            int bitC=c&1;\\n            int temp=bitA|bitB;\\n            if(temp!=bitC)\\n            {\\n                if(bitC==0)\\n                {\\n                    if(bitA==1 && bitB==1)\\n                        flips+=2;\\n                    else\\n                        flips+=1;\\n                }\\n                else\\n                {\\n                    if(bitA==0 && bitB==0)\\n                        flips+=1;\\n                }\\n            }\\n            a>>=1;\\n            b>>=1;\\n            c>>=1;\\n        }\\n        return flips;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int flips=0;\\n        if((a|b)==c)\\n            return 0;\\n        while(a!=0 || b!=0 || c!=0)\\n        {\\n            int bitA=a&1;\\n            int bitB=b&1;\\n            int bitC=c&1;\\n            int temp=bitA|bitB;\\n            if(temp!=bitC)\\n            {\\n                if(bitC==0)\\n                {\\n                    if(bitA==1 && bitB==1)\\n                        flips+=2;\\n                    else\\n                        flips+=1;\\n                }\\n                else\\n                {\\n                    if(bitA==0 && bitB==0)\\n                        flips+=1;\\n                }\\n            }\\n            a>>=1;\\n            b>>=1;\\n            c>>=1;\\n        }\\n        return flips;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607515,
                "title": "4-lines-code-easy-to-understand-image-explaination",
                "content": "# Image Explantion\\n![bit.jpeg](https://assets.leetcode.com/users/images/cfc97661-9a07-4212-867d-013054e00c42_1686117097.9050121.jpeg)\\n\\n# Complexity\\n- Time complexity: ~log(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int ans=0;\\n        while(a || b || c){\\n            if((c&1)==0 && (a&1)+(b&1)==1 || (c&1)==1 && (a&1)+(b&1)==0 ) ++ans;\\n            if((c&1)==0 && (a&1)+(b&1)==2) ans+=2;\\n            a>>=1;b>>=1;c>>=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int ans=0;\\n        while(a || b || c){\\n            if((c&1)==0 && (a&1)+(b&1)==1 || (c&1)==1 && (a&1)+(b&1)==0 ) ++ans;\\n            if((c&1)==0 && (a&1)+(b&1)==2) ans+=2;\\n            a>>=1;b>>=1;c>>=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607478,
                "title": "c-checking-bit-by-bit-o-32",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int orr = a|b;\\n        int flip = 0;\\n        for(int i = 0;i<32;i++){\\n            if((1<<i)&c){ // bit is set in c\\n               if(!((1<<i)&a) && !((1<<i)&b)){\\n                   flip++;\\n               }\\n            }\\n            else{ // bit is unset in c\\n               if((1<<i)&a && (1<<i)&b){\\n                   flip+=2;\\n               }\\n               else if((1<<i)&a || (1<<i)&b){\\n                   flip++;\\n               }\\n            }\\n        }\\n        return flip;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int orr = a|b;\\n        int flip = 0;\\n        for(int i = 0;i<32;i++){\\n            if((1<<i)&c){ // bit is set in c\\n               if(!((1<<i)&a) && !((1<<i)&b)){\\n                   flip++;\\n               }\\n            }\\n            else{ // bit is unset in c\\n               if((1<<i)&a && (1<<i)&b){\\n                   flip+=2;\\n               }\\n               else if((1<<i)&a || (1<<i)&b){\\n                   flip++;\\n               }\\n            }\\n        }\\n        return flip;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607430,
                "title": "c-solution-bit-manipulation-beats-100-0ms",
                "content": "**Algorithm**\\n\\t1. Take curr= ( a| b ).\\n\\t2. Chekc if LSB of curr and c are equal, do nothing\\n\\t3. if not equal and  LSB of c is 1 then make LSB of a or b 1 ( one opertion needed)\\n\\t4. if not equal and  LSB of c is 0 then make LSB of a or b 0 ( make LSB of a \\'0\\' and make LSB of b \\'0\\' (whichever needed)).\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int curr=a|b;\\n        if(curr==c){\\n            return 0;\\n        }\\n        int operation=0;\\n        while(a or b or c){\\n            if((curr&1)==(c&1)){\\n                \\n            }else if(c&1){\\n                operation++;\\n            }else{\\n                operation+=(a&1);\\n                operation+=(b&1);\\n            }\\n            curr>>=1,c>>=1,a>>=1,b>>=1;\\n        }\\n        return operation;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        int curr=a|b;\\n        if(curr==c){\\n            return 0;\\n        }\\n        int operation=0;\\n        while(a or b or c){\\n            if((curr&1)==(c&1)){\\n                \\n            }else if(c&1){\\n                operation++;\\n            }else{\\n                operation+=(a&1);\\n                operation+=(b&1);\\n            }\\n            curr>>=1,c>>=1,a>>=1,b>>=1;\\n        }\\n        return operation;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607426,
                "title": "1318-minimum-flips-to-make-a-or-b-equal-to-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        if(a == 0 && b == 0 && c == 0) return 0;\\n        if((c&1) == 0) {\\n            if((a&1)&(b&1)) return minFlips(a>>1,b>>1,c>>1) + 2;\\n        }\\n        return (((a&1)|(b&1)) == (c&1)) ? minFlips(a>>1,b>>1,c>>1) : minFlips(a>>1,b>>1,c>>1)+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        if(a == 0 && b == 0 && c == 0) return 0;\\n        if((c&1) == 0) {\\n            if((a&1)&(b&1)) return minFlips(a>>1,b>>1,c>>1) + 2;\\n        }\\n        return (((a&1)|(b&1)) == (c&1)) ? minFlips(a>>1,b>>1,c>>1) : minFlips(a>>1,b>>1,c>>1)+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607340,
                "title": "easy-c-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncheck all the set and non set bit and  find the ans .\\n\\n# Complexity\\n- Time complexity:O(31)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(31)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        vector<int>v(32,0);\\n        vector<int>v1(32,0);\\n        for(int i =31;i>=0;i--){\\n            if(a & (1<<i)){\\n                v[i]++;\\n            }\\n            if(b & (1<<i)){\\n                v[i]++;\\n            }\\n            if(c&(1<<i)){\\n                v1[i]++;\\n            }\\n        }\\n\\n        int ans = 0;\\n        for(int i =31;i>=0;i--){\\n            if((v[i]==v1[i]) || (v[i]==2 && v1[i]==1)){\\n                continue;\\n            }else if((v[i]==0 && v1[i]==1)|| (v1[i]==0 && v[i]==1) ){\\n                   ans++;\\n            }else if(v[i]==2 && v1[i]==0){\\n                  ans+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(int a, int b, int c) {\\n        vector<int>v(32,0);\\n        vector<int>v1(32,0);\\n        for(int i =31;i>=0;i--){\\n            if(a & (1<<i)){\\n                v[i]++;\\n            }\\n            if(b & (1<<i)){\\n                v[i]++;\\n            }\\n            if(c&(1<<i)){\\n                v1[i]++;\\n            }\\n        }\\n\\n        int ans = 0;\\n        for(int i =31;i>=0;i--){\\n            if((v[i]==v1[i]) || (v[i]==2 && v1[i]==1)){\\n                continue;\\n            }else if((v[i]==0 && v1[i]==1)|| (v1[i]==0 && v[i]==1) ){\\n                   ans++;\\n            }else if(v[i]==2 && v1[i]==0){\\n                  ans+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607244,
                "title": "java-bits-easy-solution",
                "content": "```\\nclass Solution {\\n    public int minFlips(int a, int b, int c) {\\n        int ans = 0, i = 0;\\n        while( i < 65){\\n            int bita =( a & 1 ) | 0 , bitb =( b & 1) | 0, required =  (c & 1) | 0;\\n            // System.out.println(bita+\" \"+bitb+\" \"+required);\\n            if(required == 0){\\n                ans+=bita+bitb;\\n            }else{\\n                if(bita + bitb == 0)\\n                    ans++;\\n            }\\n            a = a>>1;\\n            b = b>>1;\\n            c = c>>1;\\n            i++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minFlips(int a, int b, int c) {\\n        int ans = 0, i = 0;\\n        while( i < 65){\\n            int bita =( a & 1 ) | 0 , bitb =( b & 1) | 0, required =  (c & 1) | 0;\\n            // System.out.println(bita+\" \"+bitb+\" \"+required);\\n            if(required == 0){\\n                ans+=bita+bitb;\\n            }else{\\n                if(bita + bitb == 0)\\n                    ans++;\\n            }\\n            a = a>>1;\\n            b = b>>1;\\n            c = c>>1;\\n            i++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1919558,
                "content": [
                    {
                        "username": "anurag-k",
                        "content": "Anyone think this should be easy?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "[@user5822gZ](/user5822gZ) true and yet even using naive string comparison, this is an easy question"
                    },
                    {
                        "username": "ginbankaikamishininoyari",
                        "content": "[@user5822gZ](/user5822gZ) are you talking about me i heard you from very far away through the leetcode servers \\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "yea and leetcode think stone game is Medium also"
                    },
                    {
                        "username": "user5822gZ",
                        "content": "Maybe they forgot to mention not to use bitset or something. It\\'s probably not so easy for a newbie who isn\\'t proficient with bit manipulation, but then again, what is easy for someone who isn\\'t proficient in some area."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "very easy\\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "\"i love bit manipulation\" ... said no one, ever "
                    },
                    {
                        "username": "madhavgoyal2k2",
                        "content": "I love bit manipulation \\u2764\\uFE0F"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Bit manipulation1>>1<<1"
                    },
                    {
                        "username": "rahul1995",
                        "content": "I love bit manipulation <3"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I love bit manipulation >_>"
                    },
                    {
                        "username": "dadick",
                        "content": "Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ STL bitset is good for implementation in this need."
                    },
                    {
                        "username": "natitati",
                        "content": "Approach:\\n\\n-Iterate over bits from right to left (think how)\\n-For every 2 bits in a and b, check if ORing them would be equal to the bit in c\\n-if the answer to the previous step is false:\\n Check if the bit in C is set - this means both a and b are unset, since if at least one of them was, ORing \\n them would produce the bit in c.\\n If the bit in c is not set, we need to unset bit in a and bit in b, depending on whether they are set.\\n-Don\\'t forget to increment the flips counter. Good luck!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Another genuine 5 minute problem."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) wait for it "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) All in due course."
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "You have only solved 10 out of 600+ hard questions, maybe try one of those."
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Is there a use case for bitwise manipulation in web development? Thanks for providing your valuable insights."
                    },
                    {
                        "username": "gastelum",
                        "content": "Search about Bloom Filter, it\\'s a nice topic"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "I didnt meet yet a use case but you should try it because it\\'s fun and the world is more than web dev.\\nI wish you luck on this one, you can do it \\uD83D\\uDCAA\\uD83C\\uDFFB"
                    },
                    {
                        "username": "user1440f",
                        "content": "It is useful to store permissions on the database for a particular module (ex. user) in your project."
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@tungbuivn](/tungbuivn) my fellow, you don\\'t need to understand that much to toggle a flag. "
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Because a bit is either 0 or 1, it is useful to hold configs.  "
                    },
                    {
                        "username": "tungbuivn",
                        "content": "example: your web need to call a function called \"sum of maxtrixs after query\", you can see the 1st solution writen by c++, it is bitwise manipulation, if your leader want to upgrade it, should you rewrite entire that function ?=))"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "there are many case, almost things called \"flag\" is bitwise,in .net it is every where, even if you are not interested in it, you will never meet \"advanced skill\" if you dont know bitwise manipulation, ofcouse, you just need to understand how it work, you dont need to make yourself to expert"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "Maybe i\\'m just a dumbass, but for the test case a = 00000010\\nand b = 00000110 so a|b = 00000110 now to convert this to c = 00000101, doesn\\'t this conversion just require two bit flips?"
                    },
                    {
                        "username": "_SID_",
                        "content": "a = 010\\nb = 110\\nc = 101\\n\\nfor left most bit no need any flips  -- 0 flips\\nfor middle bit you need to change 2 bits so that it gives 0  -- 2 flips\\nfor right most bit you need to change at least one bit to 1 -- 1 flip\\nTotal -- 3 flips"
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@chSatyaSavith](/chSatyaSavith) yes you are\\n"
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "yes , it just require 2 bit flips \n1 to conevrt 3rd bit of b top 0(backwards)\n2 to convert 1st bit of b top 1(backwards)\nthis question doestn't consider these type of cases\nso when we encounter x[i]==1 and y[i]==1 do operations as just like you do for other cases"
                    },
                    {
                        "username": "bbl19982",
                        "content": "you make conversion on a or b themselves not on the result of (a OR b)"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "nvm i get it, im dumb"
                    },
                    {
                        "username": "cursydd",
                        "content": "\\treturn bin((a|b)^c).count(\\'1\\')+bin(a&b&((a|b)^c)).count(\\'1\\')\\n\\n"
                    },
                    {
                        "username": "20951a1293",
                        "content": "Explaination would be appreciated :)"
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "how to be good at like this problems ? "
                    }
                ]
            },
            {
                "id": 1919403,
                "content": [
                    {
                        "username": "anurag-k",
                        "content": "Anyone think this should be easy?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "[@user5822gZ](/user5822gZ) true and yet even using naive string comparison, this is an easy question"
                    },
                    {
                        "username": "ginbankaikamishininoyari",
                        "content": "[@user5822gZ](/user5822gZ) are you talking about me i heard you from very far away through the leetcode servers \\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "yea and leetcode think stone game is Medium also"
                    },
                    {
                        "username": "user5822gZ",
                        "content": "Maybe they forgot to mention not to use bitset or something. It\\'s probably not so easy for a newbie who isn\\'t proficient with bit manipulation, but then again, what is easy for someone who isn\\'t proficient in some area."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "very easy\\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "\"i love bit manipulation\" ... said no one, ever "
                    },
                    {
                        "username": "madhavgoyal2k2",
                        "content": "I love bit manipulation \\u2764\\uFE0F"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Bit manipulation1>>1<<1"
                    },
                    {
                        "username": "rahul1995",
                        "content": "I love bit manipulation <3"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I love bit manipulation >_>"
                    },
                    {
                        "username": "dadick",
                        "content": "Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ STL bitset is good for implementation in this need."
                    },
                    {
                        "username": "natitati",
                        "content": "Approach:\\n\\n-Iterate over bits from right to left (think how)\\n-For every 2 bits in a and b, check if ORing them would be equal to the bit in c\\n-if the answer to the previous step is false:\\n Check if the bit in C is set - this means both a and b are unset, since if at least one of them was, ORing \\n them would produce the bit in c.\\n If the bit in c is not set, we need to unset bit in a and bit in b, depending on whether they are set.\\n-Don\\'t forget to increment the flips counter. Good luck!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Another genuine 5 minute problem."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) wait for it "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) All in due course."
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "You have only solved 10 out of 600+ hard questions, maybe try one of those."
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Is there a use case for bitwise manipulation in web development? Thanks for providing your valuable insights."
                    },
                    {
                        "username": "gastelum",
                        "content": "Search about Bloom Filter, it\\'s a nice topic"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "I didnt meet yet a use case but you should try it because it\\'s fun and the world is more than web dev.\\nI wish you luck on this one, you can do it \\uD83D\\uDCAA\\uD83C\\uDFFB"
                    },
                    {
                        "username": "user1440f",
                        "content": "It is useful to store permissions on the database for a particular module (ex. user) in your project."
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@tungbuivn](/tungbuivn) my fellow, you don\\'t need to understand that much to toggle a flag. "
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Because a bit is either 0 or 1, it is useful to hold configs.  "
                    },
                    {
                        "username": "tungbuivn",
                        "content": "example: your web need to call a function called \"sum of maxtrixs after query\", you can see the 1st solution writen by c++, it is bitwise manipulation, if your leader want to upgrade it, should you rewrite entire that function ?=))"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "there are many case, almost things called \"flag\" is bitwise,in .net it is every where, even if you are not interested in it, you will never meet \"advanced skill\" if you dont know bitwise manipulation, ofcouse, you just need to understand how it work, you dont need to make yourself to expert"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "Maybe i\\'m just a dumbass, but for the test case a = 00000010\\nand b = 00000110 so a|b = 00000110 now to convert this to c = 00000101, doesn\\'t this conversion just require two bit flips?"
                    },
                    {
                        "username": "_SID_",
                        "content": "a = 010\\nb = 110\\nc = 101\\n\\nfor left most bit no need any flips  -- 0 flips\\nfor middle bit you need to change 2 bits so that it gives 0  -- 2 flips\\nfor right most bit you need to change at least one bit to 1 -- 1 flip\\nTotal -- 3 flips"
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@chSatyaSavith](/chSatyaSavith) yes you are\\n"
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "yes , it just require 2 bit flips \n1 to conevrt 3rd bit of b top 0(backwards)\n2 to convert 1st bit of b top 1(backwards)\nthis question doestn't consider these type of cases\nso when we encounter x[i]==1 and y[i]==1 do operations as just like you do for other cases"
                    },
                    {
                        "username": "bbl19982",
                        "content": "you make conversion on a or b themselves not on the result of (a OR b)"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "nvm i get it, im dumb"
                    },
                    {
                        "username": "cursydd",
                        "content": "\\treturn bin((a|b)^c).count(\\'1\\')+bin(a&b&((a|b)^c)).count(\\'1\\')\\n\\n"
                    },
                    {
                        "username": "20951a1293",
                        "content": "Explaination would be appreciated :)"
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "how to be good at like this problems ? "
                    }
                ]
            },
            {
                "id": 1919454,
                "content": [
                    {
                        "username": "anurag-k",
                        "content": "Anyone think this should be easy?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "[@user5822gZ](/user5822gZ) true and yet even using naive string comparison, this is an easy question"
                    },
                    {
                        "username": "ginbankaikamishininoyari",
                        "content": "[@user5822gZ](/user5822gZ) are you talking about me i heard you from very far away through the leetcode servers \\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "yea and leetcode think stone game is Medium also"
                    },
                    {
                        "username": "user5822gZ",
                        "content": "Maybe they forgot to mention not to use bitset or something. It\\'s probably not so easy for a newbie who isn\\'t proficient with bit manipulation, but then again, what is easy for someone who isn\\'t proficient in some area."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "very easy\\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "\"i love bit manipulation\" ... said no one, ever "
                    },
                    {
                        "username": "madhavgoyal2k2",
                        "content": "I love bit manipulation \\u2764\\uFE0F"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Bit manipulation1>>1<<1"
                    },
                    {
                        "username": "rahul1995",
                        "content": "I love bit manipulation <3"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I love bit manipulation >_>"
                    },
                    {
                        "username": "dadick",
                        "content": "Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ STL bitset is good for implementation in this need."
                    },
                    {
                        "username": "natitati",
                        "content": "Approach:\\n\\n-Iterate over bits from right to left (think how)\\n-For every 2 bits in a and b, check if ORing them would be equal to the bit in c\\n-if the answer to the previous step is false:\\n Check if the bit in C is set - this means both a and b are unset, since if at least one of them was, ORing \\n them would produce the bit in c.\\n If the bit in c is not set, we need to unset bit in a and bit in b, depending on whether they are set.\\n-Don\\'t forget to increment the flips counter. Good luck!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Another genuine 5 minute problem."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) wait for it "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) All in due course."
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "You have only solved 10 out of 600+ hard questions, maybe try one of those."
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Is there a use case for bitwise manipulation in web development? Thanks for providing your valuable insights."
                    },
                    {
                        "username": "gastelum",
                        "content": "Search about Bloom Filter, it\\'s a nice topic"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "I didnt meet yet a use case but you should try it because it\\'s fun and the world is more than web dev.\\nI wish you luck on this one, you can do it \\uD83D\\uDCAA\\uD83C\\uDFFB"
                    },
                    {
                        "username": "user1440f",
                        "content": "It is useful to store permissions on the database for a particular module (ex. user) in your project."
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@tungbuivn](/tungbuivn) my fellow, you don\\'t need to understand that much to toggle a flag. "
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Because a bit is either 0 or 1, it is useful to hold configs.  "
                    },
                    {
                        "username": "tungbuivn",
                        "content": "example: your web need to call a function called \"sum of maxtrixs after query\", you can see the 1st solution writen by c++, it is bitwise manipulation, if your leader want to upgrade it, should you rewrite entire that function ?=))"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "there are many case, almost things called \"flag\" is bitwise,in .net it is every where, even if you are not interested in it, you will never meet \"advanced skill\" if you dont know bitwise manipulation, ofcouse, you just need to understand how it work, you dont need to make yourself to expert"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "Maybe i\\'m just a dumbass, but for the test case a = 00000010\\nand b = 00000110 so a|b = 00000110 now to convert this to c = 00000101, doesn\\'t this conversion just require two bit flips?"
                    },
                    {
                        "username": "_SID_",
                        "content": "a = 010\\nb = 110\\nc = 101\\n\\nfor left most bit no need any flips  -- 0 flips\\nfor middle bit you need to change 2 bits so that it gives 0  -- 2 flips\\nfor right most bit you need to change at least one bit to 1 -- 1 flip\\nTotal -- 3 flips"
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@chSatyaSavith](/chSatyaSavith) yes you are\\n"
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "yes , it just require 2 bit flips \n1 to conevrt 3rd bit of b top 0(backwards)\n2 to convert 1st bit of b top 1(backwards)\nthis question doestn't consider these type of cases\nso when we encounter x[i]==1 and y[i]==1 do operations as just like you do for other cases"
                    },
                    {
                        "username": "bbl19982",
                        "content": "you make conversion on a or b themselves not on the result of (a OR b)"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "nvm i get it, im dumb"
                    },
                    {
                        "username": "cursydd",
                        "content": "\\treturn bin((a|b)^c).count(\\'1\\')+bin(a&b&((a|b)^c)).count(\\'1\\')\\n\\n"
                    },
                    {
                        "username": "20951a1293",
                        "content": "Explaination would be appreciated :)"
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "how to be good at like this problems ? "
                    }
                ]
            },
            {
                "id": 1919398,
                "content": [
                    {
                        "username": "anurag-k",
                        "content": "Anyone think this should be easy?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "[@user5822gZ](/user5822gZ) true and yet even using naive string comparison, this is an easy question"
                    },
                    {
                        "username": "ginbankaikamishininoyari",
                        "content": "[@user5822gZ](/user5822gZ) are you talking about me i heard you from very far away through the leetcode servers \\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "yea and leetcode think stone game is Medium also"
                    },
                    {
                        "username": "user5822gZ",
                        "content": "Maybe they forgot to mention not to use bitset or something. It\\'s probably not so easy for a newbie who isn\\'t proficient with bit manipulation, but then again, what is easy for someone who isn\\'t proficient in some area."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "very easy\\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "\"i love bit manipulation\" ... said no one, ever "
                    },
                    {
                        "username": "madhavgoyal2k2",
                        "content": "I love bit manipulation \\u2764\\uFE0F"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Bit manipulation1>>1<<1"
                    },
                    {
                        "username": "rahul1995",
                        "content": "I love bit manipulation <3"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I love bit manipulation >_>"
                    },
                    {
                        "username": "dadick",
                        "content": "Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ STL bitset is good for implementation in this need."
                    },
                    {
                        "username": "natitati",
                        "content": "Approach:\\n\\n-Iterate over bits from right to left (think how)\\n-For every 2 bits in a and b, check if ORing them would be equal to the bit in c\\n-if the answer to the previous step is false:\\n Check if the bit in C is set - this means both a and b are unset, since if at least one of them was, ORing \\n them would produce the bit in c.\\n If the bit in c is not set, we need to unset bit in a and bit in b, depending on whether they are set.\\n-Don\\'t forget to increment the flips counter. Good luck!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Another genuine 5 minute problem."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) wait for it "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) All in due course."
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "You have only solved 10 out of 600+ hard questions, maybe try one of those."
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Is there a use case for bitwise manipulation in web development? Thanks for providing your valuable insights."
                    },
                    {
                        "username": "gastelum",
                        "content": "Search about Bloom Filter, it\\'s a nice topic"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "I didnt meet yet a use case but you should try it because it\\'s fun and the world is more than web dev.\\nI wish you luck on this one, you can do it \\uD83D\\uDCAA\\uD83C\\uDFFB"
                    },
                    {
                        "username": "user1440f",
                        "content": "It is useful to store permissions on the database for a particular module (ex. user) in your project."
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@tungbuivn](/tungbuivn) my fellow, you don\\'t need to understand that much to toggle a flag. "
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Because a bit is either 0 or 1, it is useful to hold configs.  "
                    },
                    {
                        "username": "tungbuivn",
                        "content": "example: your web need to call a function called \"sum of maxtrixs after query\", you can see the 1st solution writen by c++, it is bitwise manipulation, if your leader want to upgrade it, should you rewrite entire that function ?=))"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "there are many case, almost things called \"flag\" is bitwise,in .net it is every where, even if you are not interested in it, you will never meet \"advanced skill\" if you dont know bitwise manipulation, ofcouse, you just need to understand how it work, you dont need to make yourself to expert"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "Maybe i\\'m just a dumbass, but for the test case a = 00000010\\nand b = 00000110 so a|b = 00000110 now to convert this to c = 00000101, doesn\\'t this conversion just require two bit flips?"
                    },
                    {
                        "username": "_SID_",
                        "content": "a = 010\\nb = 110\\nc = 101\\n\\nfor left most bit no need any flips  -- 0 flips\\nfor middle bit you need to change 2 bits so that it gives 0  -- 2 flips\\nfor right most bit you need to change at least one bit to 1 -- 1 flip\\nTotal -- 3 flips"
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@chSatyaSavith](/chSatyaSavith) yes you are\\n"
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "yes , it just require 2 bit flips \n1 to conevrt 3rd bit of b top 0(backwards)\n2 to convert 1st bit of b top 1(backwards)\nthis question doestn't consider these type of cases\nso when we encounter x[i]==1 and y[i]==1 do operations as just like you do for other cases"
                    },
                    {
                        "username": "bbl19982",
                        "content": "you make conversion on a or b themselves not on the result of (a OR b)"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "nvm i get it, im dumb"
                    },
                    {
                        "username": "cursydd",
                        "content": "\\treturn bin((a|b)^c).count(\\'1\\')+bin(a&b&((a|b)^c)).count(\\'1\\')\\n\\n"
                    },
                    {
                        "username": "20951a1293",
                        "content": "Explaination would be appreciated :)"
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "how to be good at like this problems ? "
                    }
                ]
            },
            {
                "id": 1920015,
                "content": [
                    {
                        "username": "anurag-k",
                        "content": "Anyone think this should be easy?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "[@user5822gZ](/user5822gZ) true and yet even using naive string comparison, this is an easy question"
                    },
                    {
                        "username": "ginbankaikamishininoyari",
                        "content": "[@user5822gZ](/user5822gZ) are you talking about me i heard you from very far away through the leetcode servers \\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "yea and leetcode think stone game is Medium also"
                    },
                    {
                        "username": "user5822gZ",
                        "content": "Maybe they forgot to mention not to use bitset or something. It\\'s probably not so easy for a newbie who isn\\'t proficient with bit manipulation, but then again, what is easy for someone who isn\\'t proficient in some area."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "very easy\\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "\"i love bit manipulation\" ... said no one, ever "
                    },
                    {
                        "username": "madhavgoyal2k2",
                        "content": "I love bit manipulation \\u2764\\uFE0F"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Bit manipulation1>>1<<1"
                    },
                    {
                        "username": "rahul1995",
                        "content": "I love bit manipulation <3"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I love bit manipulation >_>"
                    },
                    {
                        "username": "dadick",
                        "content": "Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ STL bitset is good for implementation in this need."
                    },
                    {
                        "username": "natitati",
                        "content": "Approach:\\n\\n-Iterate over bits from right to left (think how)\\n-For every 2 bits in a and b, check if ORing them would be equal to the bit in c\\n-if the answer to the previous step is false:\\n Check if the bit in C is set - this means both a and b are unset, since if at least one of them was, ORing \\n them would produce the bit in c.\\n If the bit in c is not set, we need to unset bit in a and bit in b, depending on whether they are set.\\n-Don\\'t forget to increment the flips counter. Good luck!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Another genuine 5 minute problem."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) wait for it "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) All in due course."
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "You have only solved 10 out of 600+ hard questions, maybe try one of those."
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Is there a use case for bitwise manipulation in web development? Thanks for providing your valuable insights."
                    },
                    {
                        "username": "gastelum",
                        "content": "Search about Bloom Filter, it\\'s a nice topic"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "I didnt meet yet a use case but you should try it because it\\'s fun and the world is more than web dev.\\nI wish you luck on this one, you can do it \\uD83D\\uDCAA\\uD83C\\uDFFB"
                    },
                    {
                        "username": "user1440f",
                        "content": "It is useful to store permissions on the database for a particular module (ex. user) in your project."
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@tungbuivn](/tungbuivn) my fellow, you don\\'t need to understand that much to toggle a flag. "
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Because a bit is either 0 or 1, it is useful to hold configs.  "
                    },
                    {
                        "username": "tungbuivn",
                        "content": "example: your web need to call a function called \"sum of maxtrixs after query\", you can see the 1st solution writen by c++, it is bitwise manipulation, if your leader want to upgrade it, should you rewrite entire that function ?=))"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "there are many case, almost things called \"flag\" is bitwise,in .net it is every where, even if you are not interested in it, you will never meet \"advanced skill\" if you dont know bitwise manipulation, ofcouse, you just need to understand how it work, you dont need to make yourself to expert"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "Maybe i\\'m just a dumbass, but for the test case a = 00000010\\nand b = 00000110 so a|b = 00000110 now to convert this to c = 00000101, doesn\\'t this conversion just require two bit flips?"
                    },
                    {
                        "username": "_SID_",
                        "content": "a = 010\\nb = 110\\nc = 101\\n\\nfor left most bit no need any flips  -- 0 flips\\nfor middle bit you need to change 2 bits so that it gives 0  -- 2 flips\\nfor right most bit you need to change at least one bit to 1 -- 1 flip\\nTotal -- 3 flips"
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@chSatyaSavith](/chSatyaSavith) yes you are\\n"
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "yes , it just require 2 bit flips \n1 to conevrt 3rd bit of b top 0(backwards)\n2 to convert 1st bit of b top 1(backwards)\nthis question doestn't consider these type of cases\nso when we encounter x[i]==1 and y[i]==1 do operations as just like you do for other cases"
                    },
                    {
                        "username": "bbl19982",
                        "content": "you make conversion on a or b themselves not on the result of (a OR b)"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "nvm i get it, im dumb"
                    },
                    {
                        "username": "cursydd",
                        "content": "\\treturn bin((a|b)^c).count(\\'1\\')+bin(a&b&((a|b)^c)).count(\\'1\\')\\n\\n"
                    },
                    {
                        "username": "20951a1293",
                        "content": "Explaination would be appreciated :)"
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "how to be good at like this problems ? "
                    }
                ]
            },
            {
                "id": 1919506,
                "content": [
                    {
                        "username": "anurag-k",
                        "content": "Anyone think this should be easy?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "[@user5822gZ](/user5822gZ) true and yet even using naive string comparison, this is an easy question"
                    },
                    {
                        "username": "ginbankaikamishininoyari",
                        "content": "[@user5822gZ](/user5822gZ) are you talking about me i heard you from very far away through the leetcode servers \\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "yea and leetcode think stone game is Medium also"
                    },
                    {
                        "username": "user5822gZ",
                        "content": "Maybe they forgot to mention not to use bitset or something. It\\'s probably not so easy for a newbie who isn\\'t proficient with bit manipulation, but then again, what is easy for someone who isn\\'t proficient in some area."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "very easy\\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "\"i love bit manipulation\" ... said no one, ever "
                    },
                    {
                        "username": "madhavgoyal2k2",
                        "content": "I love bit manipulation \\u2764\\uFE0F"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Bit manipulation1>>1<<1"
                    },
                    {
                        "username": "rahul1995",
                        "content": "I love bit manipulation <3"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I love bit manipulation >_>"
                    },
                    {
                        "username": "dadick",
                        "content": "Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ STL bitset is good for implementation in this need."
                    },
                    {
                        "username": "natitati",
                        "content": "Approach:\\n\\n-Iterate over bits from right to left (think how)\\n-For every 2 bits in a and b, check if ORing them would be equal to the bit in c\\n-if the answer to the previous step is false:\\n Check if the bit in C is set - this means both a and b are unset, since if at least one of them was, ORing \\n them would produce the bit in c.\\n If the bit in c is not set, we need to unset bit in a and bit in b, depending on whether they are set.\\n-Don\\'t forget to increment the flips counter. Good luck!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Another genuine 5 minute problem."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) wait for it "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) All in due course."
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "You have only solved 10 out of 600+ hard questions, maybe try one of those."
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Is there a use case for bitwise manipulation in web development? Thanks for providing your valuable insights."
                    },
                    {
                        "username": "gastelum",
                        "content": "Search about Bloom Filter, it\\'s a nice topic"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "I didnt meet yet a use case but you should try it because it\\'s fun and the world is more than web dev.\\nI wish you luck on this one, you can do it \\uD83D\\uDCAA\\uD83C\\uDFFB"
                    },
                    {
                        "username": "user1440f",
                        "content": "It is useful to store permissions on the database for a particular module (ex. user) in your project."
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@tungbuivn](/tungbuivn) my fellow, you don\\'t need to understand that much to toggle a flag. "
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Because a bit is either 0 or 1, it is useful to hold configs.  "
                    },
                    {
                        "username": "tungbuivn",
                        "content": "example: your web need to call a function called \"sum of maxtrixs after query\", you can see the 1st solution writen by c++, it is bitwise manipulation, if your leader want to upgrade it, should you rewrite entire that function ?=))"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "there are many case, almost things called \"flag\" is bitwise,in .net it is every where, even if you are not interested in it, you will never meet \"advanced skill\" if you dont know bitwise manipulation, ofcouse, you just need to understand how it work, you dont need to make yourself to expert"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "Maybe i\\'m just a dumbass, but for the test case a = 00000010\\nand b = 00000110 so a|b = 00000110 now to convert this to c = 00000101, doesn\\'t this conversion just require two bit flips?"
                    },
                    {
                        "username": "_SID_",
                        "content": "a = 010\\nb = 110\\nc = 101\\n\\nfor left most bit no need any flips  -- 0 flips\\nfor middle bit you need to change 2 bits so that it gives 0  -- 2 flips\\nfor right most bit you need to change at least one bit to 1 -- 1 flip\\nTotal -- 3 flips"
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@chSatyaSavith](/chSatyaSavith) yes you are\\n"
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "yes , it just require 2 bit flips \n1 to conevrt 3rd bit of b top 0(backwards)\n2 to convert 1st bit of b top 1(backwards)\nthis question doestn't consider these type of cases\nso when we encounter x[i]==1 and y[i]==1 do operations as just like you do for other cases"
                    },
                    {
                        "username": "bbl19982",
                        "content": "you make conversion on a or b themselves not on the result of (a OR b)"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "nvm i get it, im dumb"
                    },
                    {
                        "username": "cursydd",
                        "content": "\\treturn bin((a|b)^c).count(\\'1\\')+bin(a&b&((a|b)^c)).count(\\'1\\')\\n\\n"
                    },
                    {
                        "username": "20951a1293",
                        "content": "Explaination would be appreciated :)"
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "how to be good at like this problems ? "
                    }
                ]
            },
            {
                "id": 1919436,
                "content": [
                    {
                        "username": "anurag-k",
                        "content": "Anyone think this should be easy?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "[@user5822gZ](/user5822gZ) true and yet even using naive string comparison, this is an easy question"
                    },
                    {
                        "username": "ginbankaikamishininoyari",
                        "content": "[@user5822gZ](/user5822gZ) are you talking about me i heard you from very far away through the leetcode servers \\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "yea and leetcode think stone game is Medium also"
                    },
                    {
                        "username": "user5822gZ",
                        "content": "Maybe they forgot to mention not to use bitset or something. It\\'s probably not so easy for a newbie who isn\\'t proficient with bit manipulation, but then again, what is easy for someone who isn\\'t proficient in some area."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "very easy\\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "\"i love bit manipulation\" ... said no one, ever "
                    },
                    {
                        "username": "madhavgoyal2k2",
                        "content": "I love bit manipulation \\u2764\\uFE0F"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Bit manipulation1>>1<<1"
                    },
                    {
                        "username": "rahul1995",
                        "content": "I love bit manipulation <3"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I love bit manipulation >_>"
                    },
                    {
                        "username": "dadick",
                        "content": "Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ STL bitset is good for implementation in this need."
                    },
                    {
                        "username": "natitati",
                        "content": "Approach:\\n\\n-Iterate over bits from right to left (think how)\\n-For every 2 bits in a and b, check if ORing them would be equal to the bit in c\\n-if the answer to the previous step is false:\\n Check if the bit in C is set - this means both a and b are unset, since if at least one of them was, ORing \\n them would produce the bit in c.\\n If the bit in c is not set, we need to unset bit in a and bit in b, depending on whether they are set.\\n-Don\\'t forget to increment the flips counter. Good luck!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Another genuine 5 minute problem."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) wait for it "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) All in due course."
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "You have only solved 10 out of 600+ hard questions, maybe try one of those."
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Is there a use case for bitwise manipulation in web development? Thanks for providing your valuable insights."
                    },
                    {
                        "username": "gastelum",
                        "content": "Search about Bloom Filter, it\\'s a nice topic"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "I didnt meet yet a use case but you should try it because it\\'s fun and the world is more than web dev.\\nI wish you luck on this one, you can do it \\uD83D\\uDCAA\\uD83C\\uDFFB"
                    },
                    {
                        "username": "user1440f",
                        "content": "It is useful to store permissions on the database for a particular module (ex. user) in your project."
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@tungbuivn](/tungbuivn) my fellow, you don\\'t need to understand that much to toggle a flag. "
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Because a bit is either 0 or 1, it is useful to hold configs.  "
                    },
                    {
                        "username": "tungbuivn",
                        "content": "example: your web need to call a function called \"sum of maxtrixs after query\", you can see the 1st solution writen by c++, it is bitwise manipulation, if your leader want to upgrade it, should you rewrite entire that function ?=))"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "there are many case, almost things called \"flag\" is bitwise,in .net it is every where, even if you are not interested in it, you will never meet \"advanced skill\" if you dont know bitwise manipulation, ofcouse, you just need to understand how it work, you dont need to make yourself to expert"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "Maybe i\\'m just a dumbass, but for the test case a = 00000010\\nand b = 00000110 so a|b = 00000110 now to convert this to c = 00000101, doesn\\'t this conversion just require two bit flips?"
                    },
                    {
                        "username": "_SID_",
                        "content": "a = 010\\nb = 110\\nc = 101\\n\\nfor left most bit no need any flips  -- 0 flips\\nfor middle bit you need to change 2 bits so that it gives 0  -- 2 flips\\nfor right most bit you need to change at least one bit to 1 -- 1 flip\\nTotal -- 3 flips"
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@chSatyaSavith](/chSatyaSavith) yes you are\\n"
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "yes , it just require 2 bit flips \n1 to conevrt 3rd bit of b top 0(backwards)\n2 to convert 1st bit of b top 1(backwards)\nthis question doestn't consider these type of cases\nso when we encounter x[i]==1 and y[i]==1 do operations as just like you do for other cases"
                    },
                    {
                        "username": "bbl19982",
                        "content": "you make conversion on a or b themselves not on the result of (a OR b)"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "nvm i get it, im dumb"
                    },
                    {
                        "username": "cursydd",
                        "content": "\\treturn bin((a|b)^c).count(\\'1\\')+bin(a&b&((a|b)^c)).count(\\'1\\')\\n\\n"
                    },
                    {
                        "username": "20951a1293",
                        "content": "Explaination would be appreciated :)"
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "how to be good at like this problems ? "
                    }
                ]
            },
            {
                "id": 1919442,
                "content": [
                    {
                        "username": "anurag-k",
                        "content": "Anyone think this should be easy?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "[@user5822gZ](/user5822gZ) true and yet even using naive string comparison, this is an easy question"
                    },
                    {
                        "username": "ginbankaikamishininoyari",
                        "content": "[@user5822gZ](/user5822gZ) are you talking about me i heard you from very far away through the leetcode servers \\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "yea and leetcode think stone game is Medium also"
                    },
                    {
                        "username": "user5822gZ",
                        "content": "Maybe they forgot to mention not to use bitset or something. It\\'s probably not so easy for a newbie who isn\\'t proficient with bit manipulation, but then again, what is easy for someone who isn\\'t proficient in some area."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "very easy\\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "\"i love bit manipulation\" ... said no one, ever "
                    },
                    {
                        "username": "madhavgoyal2k2",
                        "content": "I love bit manipulation \\u2764\\uFE0F"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Bit manipulation1>>1<<1"
                    },
                    {
                        "username": "rahul1995",
                        "content": "I love bit manipulation <3"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I love bit manipulation >_>"
                    },
                    {
                        "username": "dadick",
                        "content": "Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ STL bitset is good for implementation in this need."
                    },
                    {
                        "username": "natitati",
                        "content": "Approach:\\n\\n-Iterate over bits from right to left (think how)\\n-For every 2 bits in a and b, check if ORing them would be equal to the bit in c\\n-if the answer to the previous step is false:\\n Check if the bit in C is set - this means both a and b are unset, since if at least one of them was, ORing \\n them would produce the bit in c.\\n If the bit in c is not set, we need to unset bit in a and bit in b, depending on whether they are set.\\n-Don\\'t forget to increment the flips counter. Good luck!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Another genuine 5 minute problem."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) wait for it "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) All in due course."
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "You have only solved 10 out of 600+ hard questions, maybe try one of those."
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Is there a use case for bitwise manipulation in web development? Thanks for providing your valuable insights."
                    },
                    {
                        "username": "gastelum",
                        "content": "Search about Bloom Filter, it\\'s a nice topic"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "I didnt meet yet a use case but you should try it because it\\'s fun and the world is more than web dev.\\nI wish you luck on this one, you can do it \\uD83D\\uDCAA\\uD83C\\uDFFB"
                    },
                    {
                        "username": "user1440f",
                        "content": "It is useful to store permissions on the database for a particular module (ex. user) in your project."
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@tungbuivn](/tungbuivn) my fellow, you don\\'t need to understand that much to toggle a flag. "
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Because a bit is either 0 or 1, it is useful to hold configs.  "
                    },
                    {
                        "username": "tungbuivn",
                        "content": "example: your web need to call a function called \"sum of maxtrixs after query\", you can see the 1st solution writen by c++, it is bitwise manipulation, if your leader want to upgrade it, should you rewrite entire that function ?=))"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "there are many case, almost things called \"flag\" is bitwise,in .net it is every where, even if you are not interested in it, you will never meet \"advanced skill\" if you dont know bitwise manipulation, ofcouse, you just need to understand how it work, you dont need to make yourself to expert"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "Maybe i\\'m just a dumbass, but for the test case a = 00000010\\nand b = 00000110 so a|b = 00000110 now to convert this to c = 00000101, doesn\\'t this conversion just require two bit flips?"
                    },
                    {
                        "username": "_SID_",
                        "content": "a = 010\\nb = 110\\nc = 101\\n\\nfor left most bit no need any flips  -- 0 flips\\nfor middle bit you need to change 2 bits so that it gives 0  -- 2 flips\\nfor right most bit you need to change at least one bit to 1 -- 1 flip\\nTotal -- 3 flips"
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@chSatyaSavith](/chSatyaSavith) yes you are\\n"
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "yes , it just require 2 bit flips \n1 to conevrt 3rd bit of b top 0(backwards)\n2 to convert 1st bit of b top 1(backwards)\nthis question doestn't consider these type of cases\nso when we encounter x[i]==1 and y[i]==1 do operations as just like you do for other cases"
                    },
                    {
                        "username": "bbl19982",
                        "content": "you make conversion on a or b themselves not on the result of (a OR b)"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "nvm i get it, im dumb"
                    },
                    {
                        "username": "cursydd",
                        "content": "\\treturn bin((a|b)^c).count(\\'1\\')+bin(a&b&((a|b)^c)).count(\\'1\\')\\n\\n"
                    },
                    {
                        "username": "20951a1293",
                        "content": "Explaination would be appreciated :)"
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "how to be good at like this problems ? "
                    }
                ]
            },
            {
                "id": 1568305,
                "content": [
                    {
                        "username": "anurag-k",
                        "content": "Anyone think this should be easy?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "[@user5822gZ](/user5822gZ) true and yet even using naive string comparison, this is an easy question"
                    },
                    {
                        "username": "ginbankaikamishininoyari",
                        "content": "[@user5822gZ](/user5822gZ) are you talking about me i heard you from very far away through the leetcode servers \\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "yea and leetcode think stone game is Medium also"
                    },
                    {
                        "username": "user5822gZ",
                        "content": "Maybe they forgot to mention not to use bitset or something. It\\'s probably not so easy for a newbie who isn\\'t proficient with bit manipulation, but then again, what is easy for someone who isn\\'t proficient in some area."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "very easy\\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "\"i love bit manipulation\" ... said no one, ever "
                    },
                    {
                        "username": "madhavgoyal2k2",
                        "content": "I love bit manipulation \\u2764\\uFE0F"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Bit manipulation1>>1<<1"
                    },
                    {
                        "username": "rahul1995",
                        "content": "I love bit manipulation <3"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I love bit manipulation >_>"
                    },
                    {
                        "username": "dadick",
                        "content": "Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ STL bitset is good for implementation in this need."
                    },
                    {
                        "username": "natitati",
                        "content": "Approach:\\n\\n-Iterate over bits from right to left (think how)\\n-For every 2 bits in a and b, check if ORing them would be equal to the bit in c\\n-if the answer to the previous step is false:\\n Check if the bit in C is set - this means both a and b are unset, since if at least one of them was, ORing \\n them would produce the bit in c.\\n If the bit in c is not set, we need to unset bit in a and bit in b, depending on whether they are set.\\n-Don\\'t forget to increment the flips counter. Good luck!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Another genuine 5 minute problem."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) wait for it "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) All in due course."
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "You have only solved 10 out of 600+ hard questions, maybe try one of those."
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Is there a use case for bitwise manipulation in web development? Thanks for providing your valuable insights."
                    },
                    {
                        "username": "gastelum",
                        "content": "Search about Bloom Filter, it\\'s a nice topic"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "I didnt meet yet a use case but you should try it because it\\'s fun and the world is more than web dev.\\nI wish you luck on this one, you can do it \\uD83D\\uDCAA\\uD83C\\uDFFB"
                    },
                    {
                        "username": "user1440f",
                        "content": "It is useful to store permissions on the database for a particular module (ex. user) in your project."
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@tungbuivn](/tungbuivn) my fellow, you don\\'t need to understand that much to toggle a flag. "
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Because a bit is either 0 or 1, it is useful to hold configs.  "
                    },
                    {
                        "username": "tungbuivn",
                        "content": "example: your web need to call a function called \"sum of maxtrixs after query\", you can see the 1st solution writen by c++, it is bitwise manipulation, if your leader want to upgrade it, should you rewrite entire that function ?=))"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "there are many case, almost things called \"flag\" is bitwise,in .net it is every where, even if you are not interested in it, you will never meet \"advanced skill\" if you dont know bitwise manipulation, ofcouse, you just need to understand how it work, you dont need to make yourself to expert"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "Maybe i\\'m just a dumbass, but for the test case a = 00000010\\nand b = 00000110 so a|b = 00000110 now to convert this to c = 00000101, doesn\\'t this conversion just require two bit flips?"
                    },
                    {
                        "username": "_SID_",
                        "content": "a = 010\\nb = 110\\nc = 101\\n\\nfor left most bit no need any flips  -- 0 flips\\nfor middle bit you need to change 2 bits so that it gives 0  -- 2 flips\\nfor right most bit you need to change at least one bit to 1 -- 1 flip\\nTotal -- 3 flips"
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@chSatyaSavith](/chSatyaSavith) yes you are\\n"
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "yes , it just require 2 bit flips \n1 to conevrt 3rd bit of b top 0(backwards)\n2 to convert 1st bit of b top 1(backwards)\nthis question doestn't consider these type of cases\nso when we encounter x[i]==1 and y[i]==1 do operations as just like you do for other cases"
                    },
                    {
                        "username": "bbl19982",
                        "content": "you make conversion on a or b themselves not on the result of (a OR b)"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "nvm i get it, im dumb"
                    },
                    {
                        "username": "cursydd",
                        "content": "\\treturn bin((a|b)^c).count(\\'1\\')+bin(a&b&((a|b)^c)).count(\\'1\\')\\n\\n"
                    },
                    {
                        "username": "20951a1293",
                        "content": "Explaination would be appreciated :)"
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "how to be good at like this problems ? "
                    }
                ]
            },
            {
                "id": 1920347,
                "content": [
                    {
                        "username": "anurag-k",
                        "content": "Anyone think this should be easy?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "[@user5822gZ](/user5822gZ) true and yet even using naive string comparison, this is an easy question"
                    },
                    {
                        "username": "ginbankaikamishininoyari",
                        "content": "[@user5822gZ](/user5822gZ) are you talking about me i heard you from very far away through the leetcode servers \\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "yea and leetcode think stone game is Medium also"
                    },
                    {
                        "username": "user5822gZ",
                        "content": "Maybe they forgot to mention not to use bitset or something. It\\'s probably not so easy for a newbie who isn\\'t proficient with bit manipulation, but then again, what is easy for someone who isn\\'t proficient in some area."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "very easy\\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "\"i love bit manipulation\" ... said no one, ever "
                    },
                    {
                        "username": "madhavgoyal2k2",
                        "content": "I love bit manipulation \\u2764\\uFE0F"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Bit manipulation1>>1<<1"
                    },
                    {
                        "username": "rahul1995",
                        "content": "I love bit manipulation <3"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I love bit manipulation >_>"
                    },
                    {
                        "username": "dadick",
                        "content": "Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ STL bitset is good for implementation in this need."
                    },
                    {
                        "username": "natitati",
                        "content": "Approach:\\n\\n-Iterate over bits from right to left (think how)\\n-For every 2 bits in a and b, check if ORing them would be equal to the bit in c\\n-if the answer to the previous step is false:\\n Check if the bit in C is set - this means both a and b are unset, since if at least one of them was, ORing \\n them would produce the bit in c.\\n If the bit in c is not set, we need to unset bit in a and bit in b, depending on whether they are set.\\n-Don\\'t forget to increment the flips counter. Good luck!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Another genuine 5 minute problem."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) wait for it "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) All in due course."
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "You have only solved 10 out of 600+ hard questions, maybe try one of those."
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Is there a use case for bitwise manipulation in web development? Thanks for providing your valuable insights."
                    },
                    {
                        "username": "gastelum",
                        "content": "Search about Bloom Filter, it\\'s a nice topic"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "I didnt meet yet a use case but you should try it because it\\'s fun and the world is more than web dev.\\nI wish you luck on this one, you can do it \\uD83D\\uDCAA\\uD83C\\uDFFB"
                    },
                    {
                        "username": "user1440f",
                        "content": "It is useful to store permissions on the database for a particular module (ex. user) in your project."
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@tungbuivn](/tungbuivn) my fellow, you don\\'t need to understand that much to toggle a flag. "
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Because a bit is either 0 or 1, it is useful to hold configs.  "
                    },
                    {
                        "username": "tungbuivn",
                        "content": "example: your web need to call a function called \"sum of maxtrixs after query\", you can see the 1st solution writen by c++, it is bitwise manipulation, if your leader want to upgrade it, should you rewrite entire that function ?=))"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "there are many case, almost things called \"flag\" is bitwise,in .net it is every where, even if you are not interested in it, you will never meet \"advanced skill\" if you dont know bitwise manipulation, ofcouse, you just need to understand how it work, you dont need to make yourself to expert"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "Maybe i\\'m just a dumbass, but for the test case a = 00000010\\nand b = 00000110 so a|b = 00000110 now to convert this to c = 00000101, doesn\\'t this conversion just require two bit flips?"
                    },
                    {
                        "username": "_SID_",
                        "content": "a = 010\\nb = 110\\nc = 101\\n\\nfor left most bit no need any flips  -- 0 flips\\nfor middle bit you need to change 2 bits so that it gives 0  -- 2 flips\\nfor right most bit you need to change at least one bit to 1 -- 1 flip\\nTotal -- 3 flips"
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@chSatyaSavith](/chSatyaSavith) yes you are\\n"
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "yes , it just require 2 bit flips \n1 to conevrt 3rd bit of b top 0(backwards)\n2 to convert 1st bit of b top 1(backwards)\nthis question doestn't consider these type of cases\nso when we encounter x[i]==1 and y[i]==1 do operations as just like you do for other cases"
                    },
                    {
                        "username": "bbl19982",
                        "content": "you make conversion on a or b themselves not on the result of (a OR b)"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "nvm i get it, im dumb"
                    },
                    {
                        "username": "cursydd",
                        "content": "\\treturn bin((a|b)^c).count(\\'1\\')+bin(a&b&((a|b)^c)).count(\\'1\\')\\n\\n"
                    },
                    {
                        "username": "20951a1293",
                        "content": "Explaination would be appreciated :)"
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "how to be good at like this problems ? "
                    }
                ]
            },
            {
                "id": 1919558,
                "content": [
                    {
                        "username": "anurag-k",
                        "content": "Anyone think this should be easy?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "[@user5822gZ](/user5822gZ) true and yet even using naive string comparison, this is an easy question"
                    },
                    {
                        "username": "ginbankaikamishininoyari",
                        "content": "[@user5822gZ](/user5822gZ) are you talking about me i heard you from very far away through the leetcode servers \\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "yea and leetcode think stone game is Medium also"
                    },
                    {
                        "username": "user5822gZ",
                        "content": "Maybe they forgot to mention not to use bitset or something. It\\'s probably not so easy for a newbie who isn\\'t proficient with bit manipulation, but then again, what is easy for someone who isn\\'t proficient in some area."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "very easy\\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "\"i love bit manipulation\" ... said no one, ever "
                    },
                    {
                        "username": "madhavgoyal2k2",
                        "content": "I love bit manipulation \\u2764\\uFE0F"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Bit manipulation1>>1<<1"
                    },
                    {
                        "username": "rahul1995",
                        "content": "I love bit manipulation <3"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I love bit manipulation >_>"
                    },
                    {
                        "username": "dadick",
                        "content": "Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ STL bitset is good for implementation in this need."
                    },
                    {
                        "username": "natitati",
                        "content": "Approach:\\n\\n-Iterate over bits from right to left (think how)\\n-For every 2 bits in a and b, check if ORing them would be equal to the bit in c\\n-if the answer to the previous step is false:\\n Check if the bit in C is set - this means both a and b are unset, since if at least one of them was, ORing \\n them would produce the bit in c.\\n If the bit in c is not set, we need to unset bit in a and bit in b, depending on whether they are set.\\n-Don\\'t forget to increment the flips counter. Good luck!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Another genuine 5 minute problem."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) wait for it "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) All in due course."
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "You have only solved 10 out of 600+ hard questions, maybe try one of those."
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Is there a use case for bitwise manipulation in web development? Thanks for providing your valuable insights."
                    },
                    {
                        "username": "gastelum",
                        "content": "Search about Bloom Filter, it\\'s a nice topic"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "I didnt meet yet a use case but you should try it because it\\'s fun and the world is more than web dev.\\nI wish you luck on this one, you can do it \\uD83D\\uDCAA\\uD83C\\uDFFB"
                    },
                    {
                        "username": "user1440f",
                        "content": "It is useful to store permissions on the database for a particular module (ex. user) in your project."
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@tungbuivn](/tungbuivn) my fellow, you don\\'t need to understand that much to toggle a flag. "
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Because a bit is either 0 or 1, it is useful to hold configs.  "
                    },
                    {
                        "username": "tungbuivn",
                        "content": "example: your web need to call a function called \"sum of maxtrixs after query\", you can see the 1st solution writen by c++, it is bitwise manipulation, if your leader want to upgrade it, should you rewrite entire that function ?=))"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "there are many case, almost things called \"flag\" is bitwise,in .net it is every where, even if you are not interested in it, you will never meet \"advanced skill\" if you dont know bitwise manipulation, ofcouse, you just need to understand how it work, you dont need to make yourself to expert"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "Maybe i\\'m just a dumbass, but for the test case a = 00000010\\nand b = 00000110 so a|b = 00000110 now to convert this to c = 00000101, doesn\\'t this conversion just require two bit flips?"
                    },
                    {
                        "username": "_SID_",
                        "content": "a = 010\\nb = 110\\nc = 101\\n\\nfor left most bit no need any flips  -- 0 flips\\nfor middle bit you need to change 2 bits so that it gives 0  -- 2 flips\\nfor right most bit you need to change at least one bit to 1 -- 1 flip\\nTotal -- 3 flips"
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@chSatyaSavith](/chSatyaSavith) yes you are\\n"
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "yes , it just require 2 bit flips \n1 to conevrt 3rd bit of b top 0(backwards)\n2 to convert 1st bit of b top 1(backwards)\nthis question doestn't consider these type of cases\nso when we encounter x[i]==1 and y[i]==1 do operations as just like you do for other cases"
                    },
                    {
                        "username": "bbl19982",
                        "content": "you make conversion on a or b themselves not on the result of (a OR b)"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "nvm i get it, im dumb"
                    },
                    {
                        "username": "cursydd",
                        "content": "\\treturn bin((a|b)^c).count(\\'1\\')+bin(a&b&((a|b)^c)).count(\\'1\\')\\n\\n"
                    },
                    {
                        "username": "20951a1293",
                        "content": "Explaination would be appreciated :)"
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "how to be good at like this problems ? "
                    }
                ]
            },
            {
                "id": 1919403,
                "content": [
                    {
                        "username": "anurag-k",
                        "content": "Anyone think this should be easy?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "[@user5822gZ](/user5822gZ) true and yet even using naive string comparison, this is an easy question"
                    },
                    {
                        "username": "ginbankaikamishininoyari",
                        "content": "[@user5822gZ](/user5822gZ) are you talking about me i heard you from very far away through the leetcode servers \\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "yea and leetcode think stone game is Medium also"
                    },
                    {
                        "username": "user5822gZ",
                        "content": "Maybe they forgot to mention not to use bitset or something. It\\'s probably not so easy for a newbie who isn\\'t proficient with bit manipulation, but then again, what is easy for someone who isn\\'t proficient in some area."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "very easy\\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "\"i love bit manipulation\" ... said no one, ever "
                    },
                    {
                        "username": "madhavgoyal2k2",
                        "content": "I love bit manipulation \\u2764\\uFE0F"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Bit manipulation1>>1<<1"
                    },
                    {
                        "username": "rahul1995",
                        "content": "I love bit manipulation <3"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I love bit manipulation >_>"
                    },
                    {
                        "username": "dadick",
                        "content": "Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ STL bitset is good for implementation in this need."
                    },
                    {
                        "username": "natitati",
                        "content": "Approach:\\n\\n-Iterate over bits from right to left (think how)\\n-For every 2 bits in a and b, check if ORing them would be equal to the bit in c\\n-if the answer to the previous step is false:\\n Check if the bit in C is set - this means both a and b are unset, since if at least one of them was, ORing \\n them would produce the bit in c.\\n If the bit in c is not set, we need to unset bit in a and bit in b, depending on whether they are set.\\n-Don\\'t forget to increment the flips counter. Good luck!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Another genuine 5 minute problem."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) wait for it "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) All in due course."
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "You have only solved 10 out of 600+ hard questions, maybe try one of those."
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Is there a use case for bitwise manipulation in web development? Thanks for providing your valuable insights."
                    },
                    {
                        "username": "gastelum",
                        "content": "Search about Bloom Filter, it\\'s a nice topic"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "I didnt meet yet a use case but you should try it because it\\'s fun and the world is more than web dev.\\nI wish you luck on this one, you can do it \\uD83D\\uDCAA\\uD83C\\uDFFB"
                    },
                    {
                        "username": "user1440f",
                        "content": "It is useful to store permissions on the database for a particular module (ex. user) in your project."
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@tungbuivn](/tungbuivn) my fellow, you don\\'t need to understand that much to toggle a flag. "
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Because a bit is either 0 or 1, it is useful to hold configs.  "
                    },
                    {
                        "username": "tungbuivn",
                        "content": "example: your web need to call a function called \"sum of maxtrixs after query\", you can see the 1st solution writen by c++, it is bitwise manipulation, if your leader want to upgrade it, should you rewrite entire that function ?=))"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "there are many case, almost things called \"flag\" is bitwise,in .net it is every where, even if you are not interested in it, you will never meet \"advanced skill\" if you dont know bitwise manipulation, ofcouse, you just need to understand how it work, you dont need to make yourself to expert"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "Maybe i\\'m just a dumbass, but for the test case a = 00000010\\nand b = 00000110 so a|b = 00000110 now to convert this to c = 00000101, doesn\\'t this conversion just require two bit flips?"
                    },
                    {
                        "username": "_SID_",
                        "content": "a = 010\\nb = 110\\nc = 101\\n\\nfor left most bit no need any flips  -- 0 flips\\nfor middle bit you need to change 2 bits so that it gives 0  -- 2 flips\\nfor right most bit you need to change at least one bit to 1 -- 1 flip\\nTotal -- 3 flips"
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@chSatyaSavith](/chSatyaSavith) yes you are\\n"
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "yes , it just require 2 bit flips \n1 to conevrt 3rd bit of b top 0(backwards)\n2 to convert 1st bit of b top 1(backwards)\nthis question doestn't consider these type of cases\nso when we encounter x[i]==1 and y[i]==1 do operations as just like you do for other cases"
                    },
                    {
                        "username": "bbl19982",
                        "content": "you make conversion on a or b themselves not on the result of (a OR b)"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "nvm i get it, im dumb"
                    },
                    {
                        "username": "cursydd",
                        "content": "\\treturn bin((a|b)^c).count(\\'1\\')+bin(a&b&((a|b)^c)).count(\\'1\\')\\n\\n"
                    },
                    {
                        "username": "20951a1293",
                        "content": "Explaination would be appreciated :)"
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "how to be good at like this problems ? "
                    }
                ]
            },
            {
                "id": 1919454,
                "content": [
                    {
                        "username": "anurag-k",
                        "content": "Anyone think this should be easy?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "[@user5822gZ](/user5822gZ) true and yet even using naive string comparison, this is an easy question"
                    },
                    {
                        "username": "ginbankaikamishininoyari",
                        "content": "[@user5822gZ](/user5822gZ) are you talking about me i heard you from very far away through the leetcode servers \\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "yea and leetcode think stone game is Medium also"
                    },
                    {
                        "username": "user5822gZ",
                        "content": "Maybe they forgot to mention not to use bitset or something. It\\'s probably not so easy for a newbie who isn\\'t proficient with bit manipulation, but then again, what is easy for someone who isn\\'t proficient in some area."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "very easy\\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "\"i love bit manipulation\" ... said no one, ever "
                    },
                    {
                        "username": "madhavgoyal2k2",
                        "content": "I love bit manipulation \\u2764\\uFE0F"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Bit manipulation1>>1<<1"
                    },
                    {
                        "username": "rahul1995",
                        "content": "I love bit manipulation <3"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I love bit manipulation >_>"
                    },
                    {
                        "username": "dadick",
                        "content": "Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ STL bitset is good for implementation in this need."
                    },
                    {
                        "username": "natitati",
                        "content": "Approach:\\n\\n-Iterate over bits from right to left (think how)\\n-For every 2 bits in a and b, check if ORing them would be equal to the bit in c\\n-if the answer to the previous step is false:\\n Check if the bit in C is set - this means both a and b are unset, since if at least one of them was, ORing \\n them would produce the bit in c.\\n If the bit in c is not set, we need to unset bit in a and bit in b, depending on whether they are set.\\n-Don\\'t forget to increment the flips counter. Good luck!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Another genuine 5 minute problem."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) wait for it "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) All in due course."
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "You have only solved 10 out of 600+ hard questions, maybe try one of those."
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Is there a use case for bitwise manipulation in web development? Thanks for providing your valuable insights."
                    },
                    {
                        "username": "gastelum",
                        "content": "Search about Bloom Filter, it\\'s a nice topic"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "I didnt meet yet a use case but you should try it because it\\'s fun and the world is more than web dev.\\nI wish you luck on this one, you can do it \\uD83D\\uDCAA\\uD83C\\uDFFB"
                    },
                    {
                        "username": "user1440f",
                        "content": "It is useful to store permissions on the database for a particular module (ex. user) in your project."
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@tungbuivn](/tungbuivn) my fellow, you don\\'t need to understand that much to toggle a flag. "
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Because a bit is either 0 or 1, it is useful to hold configs.  "
                    },
                    {
                        "username": "tungbuivn",
                        "content": "example: your web need to call a function called \"sum of maxtrixs after query\", you can see the 1st solution writen by c++, it is bitwise manipulation, if your leader want to upgrade it, should you rewrite entire that function ?=))"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "there are many case, almost things called \"flag\" is bitwise,in .net it is every where, even if you are not interested in it, you will never meet \"advanced skill\" if you dont know bitwise manipulation, ofcouse, you just need to understand how it work, you dont need to make yourself to expert"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "Maybe i\\'m just a dumbass, but for the test case a = 00000010\\nand b = 00000110 so a|b = 00000110 now to convert this to c = 00000101, doesn\\'t this conversion just require two bit flips?"
                    },
                    {
                        "username": "_SID_",
                        "content": "a = 010\\nb = 110\\nc = 101\\n\\nfor left most bit no need any flips  -- 0 flips\\nfor middle bit you need to change 2 bits so that it gives 0  -- 2 flips\\nfor right most bit you need to change at least one bit to 1 -- 1 flip\\nTotal -- 3 flips"
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@chSatyaSavith](/chSatyaSavith) yes you are\\n"
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "yes , it just require 2 bit flips \n1 to conevrt 3rd bit of b top 0(backwards)\n2 to convert 1st bit of b top 1(backwards)\nthis question doestn't consider these type of cases\nso when we encounter x[i]==1 and y[i]==1 do operations as just like you do for other cases"
                    },
                    {
                        "username": "bbl19982",
                        "content": "you make conversion on a or b themselves not on the result of (a OR b)"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "nvm i get it, im dumb"
                    },
                    {
                        "username": "cursydd",
                        "content": "\\treturn bin((a|b)^c).count(\\'1\\')+bin(a&b&((a|b)^c)).count(\\'1\\')\\n\\n"
                    },
                    {
                        "username": "20951a1293",
                        "content": "Explaination would be appreciated :)"
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "how to be good at like this problems ? "
                    }
                ]
            },
            {
                "id": 1919398,
                "content": [
                    {
                        "username": "anurag-k",
                        "content": "Anyone think this should be easy?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "[@user5822gZ](/user5822gZ) true and yet even using naive string comparison, this is an easy question"
                    },
                    {
                        "username": "ginbankaikamishininoyari",
                        "content": "[@user5822gZ](/user5822gZ) are you talking about me i heard you from very far away through the leetcode servers \\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "yea and leetcode think stone game is Medium also"
                    },
                    {
                        "username": "user5822gZ",
                        "content": "Maybe they forgot to mention not to use bitset or something. It\\'s probably not so easy for a newbie who isn\\'t proficient with bit manipulation, but then again, what is easy for someone who isn\\'t proficient in some area."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "very easy\\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "\"i love bit manipulation\" ... said no one, ever "
                    },
                    {
                        "username": "madhavgoyal2k2",
                        "content": "I love bit manipulation \\u2764\\uFE0F"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Bit manipulation1>>1<<1"
                    },
                    {
                        "username": "rahul1995",
                        "content": "I love bit manipulation <3"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I love bit manipulation >_>"
                    },
                    {
                        "username": "dadick",
                        "content": "Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ STL bitset is good for implementation in this need."
                    },
                    {
                        "username": "natitati",
                        "content": "Approach:\\n\\n-Iterate over bits from right to left (think how)\\n-For every 2 bits in a and b, check if ORing them would be equal to the bit in c\\n-if the answer to the previous step is false:\\n Check if the bit in C is set - this means both a and b are unset, since if at least one of them was, ORing \\n them would produce the bit in c.\\n If the bit in c is not set, we need to unset bit in a and bit in b, depending on whether they are set.\\n-Don\\'t forget to increment the flips counter. Good luck!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Another genuine 5 minute problem."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) wait for it "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) All in due course."
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "You have only solved 10 out of 600+ hard questions, maybe try one of those."
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Is there a use case for bitwise manipulation in web development? Thanks for providing your valuable insights."
                    },
                    {
                        "username": "gastelum",
                        "content": "Search about Bloom Filter, it\\'s a nice topic"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "I didnt meet yet a use case but you should try it because it\\'s fun and the world is more than web dev.\\nI wish you luck on this one, you can do it \\uD83D\\uDCAA\\uD83C\\uDFFB"
                    },
                    {
                        "username": "user1440f",
                        "content": "It is useful to store permissions on the database for a particular module (ex. user) in your project."
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@tungbuivn](/tungbuivn) my fellow, you don\\'t need to understand that much to toggle a flag. "
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Because a bit is either 0 or 1, it is useful to hold configs.  "
                    },
                    {
                        "username": "tungbuivn",
                        "content": "example: your web need to call a function called \"sum of maxtrixs after query\", you can see the 1st solution writen by c++, it is bitwise manipulation, if your leader want to upgrade it, should you rewrite entire that function ?=))"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "there are many case, almost things called \"flag\" is bitwise,in .net it is every where, even if you are not interested in it, you will never meet \"advanced skill\" if you dont know bitwise manipulation, ofcouse, you just need to understand how it work, you dont need to make yourself to expert"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "Maybe i\\'m just a dumbass, but for the test case a = 00000010\\nand b = 00000110 so a|b = 00000110 now to convert this to c = 00000101, doesn\\'t this conversion just require two bit flips?"
                    },
                    {
                        "username": "_SID_",
                        "content": "a = 010\\nb = 110\\nc = 101\\n\\nfor left most bit no need any flips  -- 0 flips\\nfor middle bit you need to change 2 bits so that it gives 0  -- 2 flips\\nfor right most bit you need to change at least one bit to 1 -- 1 flip\\nTotal -- 3 flips"
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@chSatyaSavith](/chSatyaSavith) yes you are\\n"
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "yes , it just require 2 bit flips \n1 to conevrt 3rd bit of b top 0(backwards)\n2 to convert 1st bit of b top 1(backwards)\nthis question doestn't consider these type of cases\nso when we encounter x[i]==1 and y[i]==1 do operations as just like you do for other cases"
                    },
                    {
                        "username": "bbl19982",
                        "content": "you make conversion on a or b themselves not on the result of (a OR b)"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "nvm i get it, im dumb"
                    },
                    {
                        "username": "cursydd",
                        "content": "\\treturn bin((a|b)^c).count(\\'1\\')+bin(a&b&((a|b)^c)).count(\\'1\\')\\n\\n"
                    },
                    {
                        "username": "20951a1293",
                        "content": "Explaination would be appreciated :)"
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "how to be good at like this problems ? "
                    }
                ]
            },
            {
                "id": 1920015,
                "content": [
                    {
                        "username": "anurag-k",
                        "content": "Anyone think this should be easy?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "[@user5822gZ](/user5822gZ) true and yet even using naive string comparison, this is an easy question"
                    },
                    {
                        "username": "ginbankaikamishininoyari",
                        "content": "[@user5822gZ](/user5822gZ) are you talking about me i heard you from very far away through the leetcode servers \\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "yea and leetcode think stone game is Medium also"
                    },
                    {
                        "username": "user5822gZ",
                        "content": "Maybe they forgot to mention not to use bitset or something. It\\'s probably not so easy for a newbie who isn\\'t proficient with bit manipulation, but then again, what is easy for someone who isn\\'t proficient in some area."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "very easy\\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "\"i love bit manipulation\" ... said no one, ever "
                    },
                    {
                        "username": "madhavgoyal2k2",
                        "content": "I love bit manipulation \\u2764\\uFE0F"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Bit manipulation1>>1<<1"
                    },
                    {
                        "username": "rahul1995",
                        "content": "I love bit manipulation <3"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I love bit manipulation >_>"
                    },
                    {
                        "username": "dadick",
                        "content": "Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ STL bitset is good for implementation in this need."
                    },
                    {
                        "username": "natitati",
                        "content": "Approach:\\n\\n-Iterate over bits from right to left (think how)\\n-For every 2 bits in a and b, check if ORing them would be equal to the bit in c\\n-if the answer to the previous step is false:\\n Check if the bit in C is set - this means both a and b are unset, since if at least one of them was, ORing \\n them would produce the bit in c.\\n If the bit in c is not set, we need to unset bit in a and bit in b, depending on whether they are set.\\n-Don\\'t forget to increment the flips counter. Good luck!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Another genuine 5 minute problem."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) wait for it "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) All in due course."
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "You have only solved 10 out of 600+ hard questions, maybe try one of those."
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Is there a use case for bitwise manipulation in web development? Thanks for providing your valuable insights."
                    },
                    {
                        "username": "gastelum",
                        "content": "Search about Bloom Filter, it\\'s a nice topic"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "I didnt meet yet a use case but you should try it because it\\'s fun and the world is more than web dev.\\nI wish you luck on this one, you can do it \\uD83D\\uDCAA\\uD83C\\uDFFB"
                    },
                    {
                        "username": "user1440f",
                        "content": "It is useful to store permissions on the database for a particular module (ex. user) in your project."
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@tungbuivn](/tungbuivn) my fellow, you don\\'t need to understand that much to toggle a flag. "
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Because a bit is either 0 or 1, it is useful to hold configs.  "
                    },
                    {
                        "username": "tungbuivn",
                        "content": "example: your web need to call a function called \"sum of maxtrixs after query\", you can see the 1st solution writen by c++, it is bitwise manipulation, if your leader want to upgrade it, should you rewrite entire that function ?=))"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "there are many case, almost things called \"flag\" is bitwise,in .net it is every where, even if you are not interested in it, you will never meet \"advanced skill\" if you dont know bitwise manipulation, ofcouse, you just need to understand how it work, you dont need to make yourself to expert"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "Maybe i\\'m just a dumbass, but for the test case a = 00000010\\nand b = 00000110 so a|b = 00000110 now to convert this to c = 00000101, doesn\\'t this conversion just require two bit flips?"
                    },
                    {
                        "username": "_SID_",
                        "content": "a = 010\\nb = 110\\nc = 101\\n\\nfor left most bit no need any flips  -- 0 flips\\nfor middle bit you need to change 2 bits so that it gives 0  -- 2 flips\\nfor right most bit you need to change at least one bit to 1 -- 1 flip\\nTotal -- 3 flips"
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@chSatyaSavith](/chSatyaSavith) yes you are\\n"
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "yes , it just require 2 bit flips \n1 to conevrt 3rd bit of b top 0(backwards)\n2 to convert 1st bit of b top 1(backwards)\nthis question doestn't consider these type of cases\nso when we encounter x[i]==1 and y[i]==1 do operations as just like you do for other cases"
                    },
                    {
                        "username": "bbl19982",
                        "content": "you make conversion on a or b themselves not on the result of (a OR b)"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "nvm i get it, im dumb"
                    },
                    {
                        "username": "cursydd",
                        "content": "\\treturn bin((a|b)^c).count(\\'1\\')+bin(a&b&((a|b)^c)).count(\\'1\\')\\n\\n"
                    },
                    {
                        "username": "20951a1293",
                        "content": "Explaination would be appreciated :)"
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "how to be good at like this problems ? "
                    }
                ]
            },
            {
                "id": 1919506,
                "content": [
                    {
                        "username": "anurag-k",
                        "content": "Anyone think this should be easy?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "[@user5822gZ](/user5822gZ) true and yet even using naive string comparison, this is an easy question"
                    },
                    {
                        "username": "ginbankaikamishininoyari",
                        "content": "[@user5822gZ](/user5822gZ) are you talking about me i heard you from very far away through the leetcode servers \\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "yea and leetcode think stone game is Medium also"
                    },
                    {
                        "username": "user5822gZ",
                        "content": "Maybe they forgot to mention not to use bitset or something. It\\'s probably not so easy for a newbie who isn\\'t proficient with bit manipulation, but then again, what is easy for someone who isn\\'t proficient in some area."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "very easy\\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "\"i love bit manipulation\" ... said no one, ever "
                    },
                    {
                        "username": "madhavgoyal2k2",
                        "content": "I love bit manipulation \\u2764\\uFE0F"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Bit manipulation1>>1<<1"
                    },
                    {
                        "username": "rahul1995",
                        "content": "I love bit manipulation <3"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I love bit manipulation >_>"
                    },
                    {
                        "username": "dadick",
                        "content": "Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ STL bitset is good for implementation in this need."
                    },
                    {
                        "username": "natitati",
                        "content": "Approach:\\n\\n-Iterate over bits from right to left (think how)\\n-For every 2 bits in a and b, check if ORing them would be equal to the bit in c\\n-if the answer to the previous step is false:\\n Check if the bit in C is set - this means both a and b are unset, since if at least one of them was, ORing \\n them would produce the bit in c.\\n If the bit in c is not set, we need to unset bit in a and bit in b, depending on whether they are set.\\n-Don\\'t forget to increment the flips counter. Good luck!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Another genuine 5 minute problem."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) wait for it "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) All in due course."
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "You have only solved 10 out of 600+ hard questions, maybe try one of those."
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Is there a use case for bitwise manipulation in web development? Thanks for providing your valuable insights."
                    },
                    {
                        "username": "gastelum",
                        "content": "Search about Bloom Filter, it\\'s a nice topic"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "I didnt meet yet a use case but you should try it because it\\'s fun and the world is more than web dev.\\nI wish you luck on this one, you can do it \\uD83D\\uDCAA\\uD83C\\uDFFB"
                    },
                    {
                        "username": "user1440f",
                        "content": "It is useful to store permissions on the database for a particular module (ex. user) in your project."
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@tungbuivn](/tungbuivn) my fellow, you don\\'t need to understand that much to toggle a flag. "
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Because a bit is either 0 or 1, it is useful to hold configs.  "
                    },
                    {
                        "username": "tungbuivn",
                        "content": "example: your web need to call a function called \"sum of maxtrixs after query\", you can see the 1st solution writen by c++, it is bitwise manipulation, if your leader want to upgrade it, should you rewrite entire that function ?=))"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "there are many case, almost things called \"flag\" is bitwise,in .net it is every where, even if you are not interested in it, you will never meet \"advanced skill\" if you dont know bitwise manipulation, ofcouse, you just need to understand how it work, you dont need to make yourself to expert"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "Maybe i\\'m just a dumbass, but for the test case a = 00000010\\nand b = 00000110 so a|b = 00000110 now to convert this to c = 00000101, doesn\\'t this conversion just require two bit flips?"
                    },
                    {
                        "username": "_SID_",
                        "content": "a = 010\\nb = 110\\nc = 101\\n\\nfor left most bit no need any flips  -- 0 flips\\nfor middle bit you need to change 2 bits so that it gives 0  -- 2 flips\\nfor right most bit you need to change at least one bit to 1 -- 1 flip\\nTotal -- 3 flips"
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@chSatyaSavith](/chSatyaSavith) yes you are\\n"
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "yes , it just require 2 bit flips \n1 to conevrt 3rd bit of b top 0(backwards)\n2 to convert 1st bit of b top 1(backwards)\nthis question doestn't consider these type of cases\nso when we encounter x[i]==1 and y[i]==1 do operations as just like you do for other cases"
                    },
                    {
                        "username": "bbl19982",
                        "content": "you make conversion on a or b themselves not on the result of (a OR b)"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "nvm i get it, im dumb"
                    },
                    {
                        "username": "cursydd",
                        "content": "\\treturn bin((a|b)^c).count(\\'1\\')+bin(a&b&((a|b)^c)).count(\\'1\\')\\n\\n"
                    },
                    {
                        "username": "20951a1293",
                        "content": "Explaination would be appreciated :)"
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "how to be good at like this problems ? "
                    }
                ]
            },
            {
                "id": 1919436,
                "content": [
                    {
                        "username": "anurag-k",
                        "content": "Anyone think this should be easy?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "[@user5822gZ](/user5822gZ) true and yet even using naive string comparison, this is an easy question"
                    },
                    {
                        "username": "ginbankaikamishininoyari",
                        "content": "[@user5822gZ](/user5822gZ) are you talking about me i heard you from very far away through the leetcode servers \\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "yea and leetcode think stone game is Medium also"
                    },
                    {
                        "username": "user5822gZ",
                        "content": "Maybe they forgot to mention not to use bitset or something. It\\'s probably not so easy for a newbie who isn\\'t proficient with bit manipulation, but then again, what is easy for someone who isn\\'t proficient in some area."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "very easy\\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "\"i love bit manipulation\" ... said no one, ever "
                    },
                    {
                        "username": "madhavgoyal2k2",
                        "content": "I love bit manipulation \\u2764\\uFE0F"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Bit manipulation1>>1<<1"
                    },
                    {
                        "username": "rahul1995",
                        "content": "I love bit manipulation <3"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I love bit manipulation >_>"
                    },
                    {
                        "username": "dadick",
                        "content": "Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ STL bitset is good for implementation in this need."
                    },
                    {
                        "username": "natitati",
                        "content": "Approach:\\n\\n-Iterate over bits from right to left (think how)\\n-For every 2 bits in a and b, check if ORing them would be equal to the bit in c\\n-if the answer to the previous step is false:\\n Check if the bit in C is set - this means both a and b are unset, since if at least one of them was, ORing \\n them would produce the bit in c.\\n If the bit in c is not set, we need to unset bit in a and bit in b, depending on whether they are set.\\n-Don\\'t forget to increment the flips counter. Good luck!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Another genuine 5 minute problem."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) wait for it "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) All in due course."
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "You have only solved 10 out of 600+ hard questions, maybe try one of those."
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Is there a use case for bitwise manipulation in web development? Thanks for providing your valuable insights."
                    },
                    {
                        "username": "gastelum",
                        "content": "Search about Bloom Filter, it\\'s a nice topic"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "I didnt meet yet a use case but you should try it because it\\'s fun and the world is more than web dev.\\nI wish you luck on this one, you can do it \\uD83D\\uDCAA\\uD83C\\uDFFB"
                    },
                    {
                        "username": "user1440f",
                        "content": "It is useful to store permissions on the database for a particular module (ex. user) in your project."
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@tungbuivn](/tungbuivn) my fellow, you don\\'t need to understand that much to toggle a flag. "
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Because a bit is either 0 or 1, it is useful to hold configs.  "
                    },
                    {
                        "username": "tungbuivn",
                        "content": "example: your web need to call a function called \"sum of maxtrixs after query\", you can see the 1st solution writen by c++, it is bitwise manipulation, if your leader want to upgrade it, should you rewrite entire that function ?=))"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "there are many case, almost things called \"flag\" is bitwise,in .net it is every where, even if you are not interested in it, you will never meet \"advanced skill\" if you dont know bitwise manipulation, ofcouse, you just need to understand how it work, you dont need to make yourself to expert"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "Maybe i\\'m just a dumbass, but for the test case a = 00000010\\nand b = 00000110 so a|b = 00000110 now to convert this to c = 00000101, doesn\\'t this conversion just require two bit flips?"
                    },
                    {
                        "username": "_SID_",
                        "content": "a = 010\\nb = 110\\nc = 101\\n\\nfor left most bit no need any flips  -- 0 flips\\nfor middle bit you need to change 2 bits so that it gives 0  -- 2 flips\\nfor right most bit you need to change at least one bit to 1 -- 1 flip\\nTotal -- 3 flips"
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@chSatyaSavith](/chSatyaSavith) yes you are\\n"
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "yes , it just require 2 bit flips \n1 to conevrt 3rd bit of b top 0(backwards)\n2 to convert 1st bit of b top 1(backwards)\nthis question doestn't consider these type of cases\nso when we encounter x[i]==1 and y[i]==1 do operations as just like you do for other cases"
                    },
                    {
                        "username": "bbl19982",
                        "content": "you make conversion on a or b themselves not on the result of (a OR b)"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "nvm i get it, im dumb"
                    },
                    {
                        "username": "cursydd",
                        "content": "\\treturn bin((a|b)^c).count(\\'1\\')+bin(a&b&((a|b)^c)).count(\\'1\\')\\n\\n"
                    },
                    {
                        "username": "20951a1293",
                        "content": "Explaination would be appreciated :)"
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "how to be good at like this problems ? "
                    }
                ]
            },
            {
                "id": 1919442,
                "content": [
                    {
                        "username": "anurag-k",
                        "content": "Anyone think this should be easy?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "[@user5822gZ](/user5822gZ) true and yet even using naive string comparison, this is an easy question"
                    },
                    {
                        "username": "ginbankaikamishininoyari",
                        "content": "[@user5822gZ](/user5822gZ) are you talking about me i heard you from very far away through the leetcode servers \\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "yea and leetcode think stone game is Medium also"
                    },
                    {
                        "username": "user5822gZ",
                        "content": "Maybe they forgot to mention not to use bitset or something. It\\'s probably not so easy for a newbie who isn\\'t proficient with bit manipulation, but then again, what is easy for someone who isn\\'t proficient in some area."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "very easy\\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "\"i love bit manipulation\" ... said no one, ever "
                    },
                    {
                        "username": "madhavgoyal2k2",
                        "content": "I love bit manipulation \\u2764\\uFE0F"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Bit manipulation1>>1<<1"
                    },
                    {
                        "username": "rahul1995",
                        "content": "I love bit manipulation <3"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I love bit manipulation >_>"
                    },
                    {
                        "username": "dadick",
                        "content": "Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ STL bitset is good for implementation in this need."
                    },
                    {
                        "username": "natitati",
                        "content": "Approach:\\n\\n-Iterate over bits from right to left (think how)\\n-For every 2 bits in a and b, check if ORing them would be equal to the bit in c\\n-if the answer to the previous step is false:\\n Check if the bit in C is set - this means both a and b are unset, since if at least one of them was, ORing \\n them would produce the bit in c.\\n If the bit in c is not set, we need to unset bit in a and bit in b, depending on whether they are set.\\n-Don\\'t forget to increment the flips counter. Good luck!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Another genuine 5 minute problem."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) wait for it "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) All in due course."
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "You have only solved 10 out of 600+ hard questions, maybe try one of those."
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Is there a use case for bitwise manipulation in web development? Thanks for providing your valuable insights."
                    },
                    {
                        "username": "gastelum",
                        "content": "Search about Bloom Filter, it\\'s a nice topic"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "I didnt meet yet a use case but you should try it because it\\'s fun and the world is more than web dev.\\nI wish you luck on this one, you can do it \\uD83D\\uDCAA\\uD83C\\uDFFB"
                    },
                    {
                        "username": "user1440f",
                        "content": "It is useful to store permissions on the database for a particular module (ex. user) in your project."
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@tungbuivn](/tungbuivn) my fellow, you don\\'t need to understand that much to toggle a flag. "
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Because a bit is either 0 or 1, it is useful to hold configs.  "
                    },
                    {
                        "username": "tungbuivn",
                        "content": "example: your web need to call a function called \"sum of maxtrixs after query\", you can see the 1st solution writen by c++, it is bitwise manipulation, if your leader want to upgrade it, should you rewrite entire that function ?=))"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "there are many case, almost things called \"flag\" is bitwise,in .net it is every where, even if you are not interested in it, you will never meet \"advanced skill\" if you dont know bitwise manipulation, ofcouse, you just need to understand how it work, you dont need to make yourself to expert"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "Maybe i\\'m just a dumbass, but for the test case a = 00000010\\nand b = 00000110 so a|b = 00000110 now to convert this to c = 00000101, doesn\\'t this conversion just require two bit flips?"
                    },
                    {
                        "username": "_SID_",
                        "content": "a = 010\\nb = 110\\nc = 101\\n\\nfor left most bit no need any flips  -- 0 flips\\nfor middle bit you need to change 2 bits so that it gives 0  -- 2 flips\\nfor right most bit you need to change at least one bit to 1 -- 1 flip\\nTotal -- 3 flips"
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@chSatyaSavith](/chSatyaSavith) yes you are\\n"
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "yes , it just require 2 bit flips \n1 to conevrt 3rd bit of b top 0(backwards)\n2 to convert 1st bit of b top 1(backwards)\nthis question doestn't consider these type of cases\nso when we encounter x[i]==1 and y[i]==1 do operations as just like you do for other cases"
                    },
                    {
                        "username": "bbl19982",
                        "content": "you make conversion on a or b themselves not on the result of (a OR b)"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "nvm i get it, im dumb"
                    },
                    {
                        "username": "cursydd",
                        "content": "\\treturn bin((a|b)^c).count(\\'1\\')+bin(a&b&((a|b)^c)).count(\\'1\\')\\n\\n"
                    },
                    {
                        "username": "20951a1293",
                        "content": "Explaination would be appreciated :)"
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "how to be good at like this problems ? "
                    }
                ]
            },
            {
                "id": 1568305,
                "content": [
                    {
                        "username": "anurag-k",
                        "content": "Anyone think this should be easy?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "[@user5822gZ](/user5822gZ) true and yet even using naive string comparison, this is an easy question"
                    },
                    {
                        "username": "ginbankaikamishininoyari",
                        "content": "[@user5822gZ](/user5822gZ) are you talking about me i heard you from very far away through the leetcode servers \\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "yea and leetcode think stone game is Medium also"
                    },
                    {
                        "username": "user5822gZ",
                        "content": "Maybe they forgot to mention not to use bitset or something. It\\'s probably not so easy for a newbie who isn\\'t proficient with bit manipulation, but then again, what is easy for someone who isn\\'t proficient in some area."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "very easy\\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "\"i love bit manipulation\" ... said no one, ever "
                    },
                    {
                        "username": "madhavgoyal2k2",
                        "content": "I love bit manipulation \\u2764\\uFE0F"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Bit manipulation1>>1<<1"
                    },
                    {
                        "username": "rahul1995",
                        "content": "I love bit manipulation <3"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I love bit manipulation >_>"
                    },
                    {
                        "username": "dadick",
                        "content": "Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ STL bitset is good for implementation in this need."
                    },
                    {
                        "username": "natitati",
                        "content": "Approach:\\n\\n-Iterate over bits from right to left (think how)\\n-For every 2 bits in a and b, check if ORing them would be equal to the bit in c\\n-if the answer to the previous step is false:\\n Check if the bit in C is set - this means both a and b are unset, since if at least one of them was, ORing \\n them would produce the bit in c.\\n If the bit in c is not set, we need to unset bit in a and bit in b, depending on whether they are set.\\n-Don\\'t forget to increment the flips counter. Good luck!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Another genuine 5 minute problem."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) wait for it "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) All in due course."
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "You have only solved 10 out of 600+ hard questions, maybe try one of those."
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Is there a use case for bitwise manipulation in web development? Thanks for providing your valuable insights."
                    },
                    {
                        "username": "gastelum",
                        "content": "Search about Bloom Filter, it\\'s a nice topic"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "I didnt meet yet a use case but you should try it because it\\'s fun and the world is more than web dev.\\nI wish you luck on this one, you can do it \\uD83D\\uDCAA\\uD83C\\uDFFB"
                    },
                    {
                        "username": "user1440f",
                        "content": "It is useful to store permissions on the database for a particular module (ex. user) in your project."
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@tungbuivn](/tungbuivn) my fellow, you don\\'t need to understand that much to toggle a flag. "
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Because a bit is either 0 or 1, it is useful to hold configs.  "
                    },
                    {
                        "username": "tungbuivn",
                        "content": "example: your web need to call a function called \"sum of maxtrixs after query\", you can see the 1st solution writen by c++, it is bitwise manipulation, if your leader want to upgrade it, should you rewrite entire that function ?=))"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "there are many case, almost things called \"flag\" is bitwise,in .net it is every where, even if you are not interested in it, you will never meet \"advanced skill\" if you dont know bitwise manipulation, ofcouse, you just need to understand how it work, you dont need to make yourself to expert"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "Maybe i\\'m just a dumbass, but for the test case a = 00000010\\nand b = 00000110 so a|b = 00000110 now to convert this to c = 00000101, doesn\\'t this conversion just require two bit flips?"
                    },
                    {
                        "username": "_SID_",
                        "content": "a = 010\\nb = 110\\nc = 101\\n\\nfor left most bit no need any flips  -- 0 flips\\nfor middle bit you need to change 2 bits so that it gives 0  -- 2 flips\\nfor right most bit you need to change at least one bit to 1 -- 1 flip\\nTotal -- 3 flips"
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@chSatyaSavith](/chSatyaSavith) yes you are\\n"
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "yes , it just require 2 bit flips \n1 to conevrt 3rd bit of b top 0(backwards)\n2 to convert 1st bit of b top 1(backwards)\nthis question doestn't consider these type of cases\nso when we encounter x[i]==1 and y[i]==1 do operations as just like you do for other cases"
                    },
                    {
                        "username": "bbl19982",
                        "content": "you make conversion on a or b themselves not on the result of (a OR b)"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "nvm i get it, im dumb"
                    },
                    {
                        "username": "cursydd",
                        "content": "\\treturn bin((a|b)^c).count(\\'1\\')+bin(a&b&((a|b)^c)).count(\\'1\\')\\n\\n"
                    },
                    {
                        "username": "20951a1293",
                        "content": "Explaination would be appreciated :)"
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "how to be good at like this problems ? "
                    }
                ]
            },
            {
                "id": 1920347,
                "content": [
                    {
                        "username": "anurag-k",
                        "content": "Anyone think this should be easy?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "[@user5822gZ](/user5822gZ) true and yet even using naive string comparison, this is an easy question"
                    },
                    {
                        "username": "ginbankaikamishininoyari",
                        "content": "[@user5822gZ](/user5822gZ) are you talking about me i heard you from very far away through the leetcode servers \\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "yea and leetcode think stone game is Medium also"
                    },
                    {
                        "username": "user5822gZ",
                        "content": "Maybe they forgot to mention not to use bitset or something. It\\'s probably not so easy for a newbie who isn\\'t proficient with bit manipulation, but then again, what is easy for someone who isn\\'t proficient in some area."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "very easy\\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "\"i love bit manipulation\" ... said no one, ever "
                    },
                    {
                        "username": "madhavgoyal2k2",
                        "content": "I love bit manipulation \\u2764\\uFE0F"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Bit manipulation1>>1<<1"
                    },
                    {
                        "username": "rahul1995",
                        "content": "I love bit manipulation <3"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I love bit manipulation >_>"
                    },
                    {
                        "username": "dadick",
                        "content": "Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ STL bitset is good for implementation in this need."
                    },
                    {
                        "username": "natitati",
                        "content": "Approach:\\n\\n-Iterate over bits from right to left (think how)\\n-For every 2 bits in a and b, check if ORing them would be equal to the bit in c\\n-if the answer to the previous step is false:\\n Check if the bit in C is set - this means both a and b are unset, since if at least one of them was, ORing \\n them would produce the bit in c.\\n If the bit in c is not set, we need to unset bit in a and bit in b, depending on whether they are set.\\n-Don\\'t forget to increment the flips counter. Good luck!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Another genuine 5 minute problem."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) wait for it "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) All in due course."
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "You have only solved 10 out of 600+ hard questions, maybe try one of those."
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Is there a use case for bitwise manipulation in web development? Thanks for providing your valuable insights."
                    },
                    {
                        "username": "gastelum",
                        "content": "Search about Bloom Filter, it\\'s a nice topic"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "I didnt meet yet a use case but you should try it because it\\'s fun and the world is more than web dev.\\nI wish you luck on this one, you can do it \\uD83D\\uDCAA\\uD83C\\uDFFB"
                    },
                    {
                        "username": "user1440f",
                        "content": "It is useful to store permissions on the database for a particular module (ex. user) in your project."
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@tungbuivn](/tungbuivn) my fellow, you don\\'t need to understand that much to toggle a flag. "
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Because a bit is either 0 or 1, it is useful to hold configs.  "
                    },
                    {
                        "username": "tungbuivn",
                        "content": "example: your web need to call a function called \"sum of maxtrixs after query\", you can see the 1st solution writen by c++, it is bitwise manipulation, if your leader want to upgrade it, should you rewrite entire that function ?=))"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "there are many case, almost things called \"flag\" is bitwise,in .net it is every where, even if you are not interested in it, you will never meet \"advanced skill\" if you dont know bitwise manipulation, ofcouse, you just need to understand how it work, you dont need to make yourself to expert"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "Maybe i\\'m just a dumbass, but for the test case a = 00000010\\nand b = 00000110 so a|b = 00000110 now to convert this to c = 00000101, doesn\\'t this conversion just require two bit flips?"
                    },
                    {
                        "username": "_SID_",
                        "content": "a = 010\\nb = 110\\nc = 101\\n\\nfor left most bit no need any flips  -- 0 flips\\nfor middle bit you need to change 2 bits so that it gives 0  -- 2 flips\\nfor right most bit you need to change at least one bit to 1 -- 1 flip\\nTotal -- 3 flips"
                    },
                    {
                        "username": "gunjan192002",
                        "content": "[@chSatyaSavith](/chSatyaSavith) yes you are\\n"
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "yes , it just require 2 bit flips \n1 to conevrt 3rd bit of b top 0(backwards)\n2 to convert 1st bit of b top 1(backwards)\nthis question doestn't consider these type of cases\nso when we encounter x[i]==1 and y[i]==1 do operations as just like you do for other cases"
                    },
                    {
                        "username": "bbl19982",
                        "content": "you make conversion on a or b themselves not on the result of (a OR b)"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "nvm i get it, im dumb"
                    },
                    {
                        "username": "cursydd",
                        "content": "\\treturn bin((a|b)^c).count(\\'1\\')+bin(a&b&((a|b)^c)).count(\\'1\\')\\n\\n"
                    },
                    {
                        "username": "20951a1293",
                        "content": "Explaination would be appreciated :)"
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "how to be good at like this problems ? "
                    }
                ]
            },
            {
                "id": 1919890,
                "content": [
                    {
                        "username": "aa98-45556443355666",
                        "content": "What is wrong in my approach to solve this problem ?\\n  \\n        \\n        int num1=a|b;\\n\\n        int num2=num1^c;\\n\\n        int res=0;\\n\\n        while(num2>0){\\n\\n            num2=num2&(num2-1);\\n\\n            res++;\\n        }\\n       \\n       return res;\\n\\n"
                    },
                    {
                        "username": "user1440f",
                        "content": "I think the problem is that you are not considering the case where bit in a is 1 and bit in b is 1 but bit in c is 0. Here, 2 bits will be unset in order to make the result as 0.\n\nI suggest you to use bitset in such problems."
                    },
                    {
                        "username": "tungbuivn",
                        "content": "this has two case a+b<c, so you could count down, but not by decimal number , and other case a+b>c but the bitwise does not have negative number so you must merge both case. just submit your solution and learn from other, read comment careful, some user solve it by d=(a|b)^c=>remove all bit sum ab from c, and (a&b&d)=>(c<a+b) only keep bit of c, you can do operation in decimal c-(a+b) for case 1, a+b-c for case 2"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "what num2=num2&(num2-1) stand for ? you cannot count \\'bit flip\\' like that, i suggest you convert number to an array of bit then solve it, after that you should find a way to solve without array"
                    },
                    {
                        "username": "spatecon",
                        "content": "It\\'s amazing how similar solutions from absolutely different people are. Match line by line \\uD83D\\uDE28"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "if one day, you found other code better than you, and then you will do your best to optmize your code, and finally you have small piece totally same as thier, what should you do? that mean your max performance only equal them, so my exp is do your best and submit it, if it is not 1st position then try to learn from thier, and give better solve if you can"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "dont worry, if you feel learned something on today, does that similar solution have effect to your coding skill ? =))"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "what about contests dude, even AI chatbots have same code as their\\'s."
                    },
                    {
                        "username": "Msey",
                        "content": "bitard manipulation"
                    },
                    {
                        "username": "_SID_",
                        "content": "`int getLastBit(int a){`\n        `if((a&1)==1) return 1;`\n        `return 0;`\n    `}`\n\nYou can get right side last bit of a number using above function"
                    },
                    {
                        "username": "jackgiunta",
                        "content": "Why not make \"extra\" `Integer.bitCount(a & b & ~c);`? Its much more intuitive whatever is in the answer. Honestly the answer doesn\\'t make sense. Where are you getting the random `&((a|b)^c)`?"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "(a & b & ((a | b) ^ c))\\nto me it was more understandable this way we are checking if bit of both a and b is 1 and ((a | b)^c) gives bits where there is flip needed so doing AND of it with \\'a\\' and \\'b\\' we are actually and counting 1\\'s we are actually getting number of times \\'a\\' and \\'b\\' both needs to be flipped"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/posts/%CE%BD%CE%B9%CE%BA%CF%8C%CE%BB%CE%B1%CE%BF%CF%82-%CE%BC%CF%8C%CF%83%CE%B1%CE%BB%CE%BF%CF%82-27ab081b8_documentation-activity-7091739962173194241-ABZf?utm_source=share&utm_medium=member_desktop"
                    },
                    {
                        "username": "thewickeffect",
                        "content": "This was a fun one. I feel like I understand the math for working with binary better now."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Although I\\'m not familiar with Bit Manipulation, I was still able to solve it using other approaches. It\\'s quite satisfying."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "What a joke question!"
                    },
                    {
                        "username": "Violet-",
                        "content": "Good article! Thanks LC."
                    }
                ]
            },
            {
                "id": 1919794,
                "content": [
                    {
                        "username": "aa98-45556443355666",
                        "content": "What is wrong in my approach to solve this problem ?\\n  \\n        \\n        int num1=a|b;\\n\\n        int num2=num1^c;\\n\\n        int res=0;\\n\\n        while(num2>0){\\n\\n            num2=num2&(num2-1);\\n\\n            res++;\\n        }\\n       \\n       return res;\\n\\n"
                    },
                    {
                        "username": "user1440f",
                        "content": "I think the problem is that you are not considering the case where bit in a is 1 and bit in b is 1 but bit in c is 0. Here, 2 bits will be unset in order to make the result as 0.\n\nI suggest you to use bitset in such problems."
                    },
                    {
                        "username": "tungbuivn",
                        "content": "this has two case a+b<c, so you could count down, but not by decimal number , and other case a+b>c but the bitwise does not have negative number so you must merge both case. just submit your solution and learn from other, read comment careful, some user solve it by d=(a|b)^c=>remove all bit sum ab from c, and (a&b&d)=>(c<a+b) only keep bit of c, you can do operation in decimal c-(a+b) for case 1, a+b-c for case 2"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "what num2=num2&(num2-1) stand for ? you cannot count \\'bit flip\\' like that, i suggest you convert number to an array of bit then solve it, after that you should find a way to solve without array"
                    },
                    {
                        "username": "spatecon",
                        "content": "It\\'s amazing how similar solutions from absolutely different people are. Match line by line \\uD83D\\uDE28"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "if one day, you found other code better than you, and then you will do your best to optmize your code, and finally you have small piece totally same as thier, what should you do? that mean your max performance only equal them, so my exp is do your best and submit it, if it is not 1st position then try to learn from thier, and give better solve if you can"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "dont worry, if you feel learned something on today, does that similar solution have effect to your coding skill ? =))"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "what about contests dude, even AI chatbots have same code as their\\'s."
                    },
                    {
                        "username": "Msey",
                        "content": "bitard manipulation"
                    },
                    {
                        "username": "_SID_",
                        "content": "`int getLastBit(int a){`\n        `if((a&1)==1) return 1;`\n        `return 0;`\n    `}`\n\nYou can get right side last bit of a number using above function"
                    },
                    {
                        "username": "jackgiunta",
                        "content": "Why not make \"extra\" `Integer.bitCount(a & b & ~c);`? Its much more intuitive whatever is in the answer. Honestly the answer doesn\\'t make sense. Where are you getting the random `&((a|b)^c)`?"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "(a & b & ((a | b) ^ c))\\nto me it was more understandable this way we are checking if bit of both a and b is 1 and ((a | b)^c) gives bits where there is flip needed so doing AND of it with \\'a\\' and \\'b\\' we are actually and counting 1\\'s we are actually getting number of times \\'a\\' and \\'b\\' both needs to be flipped"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/posts/%CE%BD%CE%B9%CE%BA%CF%8C%CE%BB%CE%B1%CE%BF%CF%82-%CE%BC%CF%8C%CF%83%CE%B1%CE%BB%CE%BF%CF%82-27ab081b8_documentation-activity-7091739962173194241-ABZf?utm_source=share&utm_medium=member_desktop"
                    },
                    {
                        "username": "thewickeffect",
                        "content": "This was a fun one. I feel like I understand the math for working with binary better now."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Although I\\'m not familiar with Bit Manipulation, I was still able to solve it using other approaches. It\\'s quite satisfying."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "What a joke question!"
                    },
                    {
                        "username": "Violet-",
                        "content": "Good article! Thanks LC."
                    }
                ]
            },
            {
                "id": 1919648,
                "content": [
                    {
                        "username": "aa98-45556443355666",
                        "content": "What is wrong in my approach to solve this problem ?\\n  \\n        \\n        int num1=a|b;\\n\\n        int num2=num1^c;\\n\\n        int res=0;\\n\\n        while(num2>0){\\n\\n            num2=num2&(num2-1);\\n\\n            res++;\\n        }\\n       \\n       return res;\\n\\n"
                    },
                    {
                        "username": "user1440f",
                        "content": "I think the problem is that you are not considering the case where bit in a is 1 and bit in b is 1 but bit in c is 0. Here, 2 bits will be unset in order to make the result as 0.\n\nI suggest you to use bitset in such problems."
                    },
                    {
                        "username": "tungbuivn",
                        "content": "this has two case a+b<c, so you could count down, but not by decimal number , and other case a+b>c but the bitwise does not have negative number so you must merge both case. just submit your solution and learn from other, read comment careful, some user solve it by d=(a|b)^c=>remove all bit sum ab from c, and (a&b&d)=>(c<a+b) only keep bit of c, you can do operation in decimal c-(a+b) for case 1, a+b-c for case 2"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "what num2=num2&(num2-1) stand for ? you cannot count \\'bit flip\\' like that, i suggest you convert number to an array of bit then solve it, after that you should find a way to solve without array"
                    },
                    {
                        "username": "spatecon",
                        "content": "It\\'s amazing how similar solutions from absolutely different people are. Match line by line \\uD83D\\uDE28"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "if one day, you found other code better than you, and then you will do your best to optmize your code, and finally you have small piece totally same as thier, what should you do? that mean your max performance only equal them, so my exp is do your best and submit it, if it is not 1st position then try to learn from thier, and give better solve if you can"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "dont worry, if you feel learned something on today, does that similar solution have effect to your coding skill ? =))"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "what about contests dude, even AI chatbots have same code as their\\'s."
                    },
                    {
                        "username": "Msey",
                        "content": "bitard manipulation"
                    },
                    {
                        "username": "_SID_",
                        "content": "`int getLastBit(int a){`\n        `if((a&1)==1) return 1;`\n        `return 0;`\n    `}`\n\nYou can get right side last bit of a number using above function"
                    },
                    {
                        "username": "jackgiunta",
                        "content": "Why not make \"extra\" `Integer.bitCount(a & b & ~c);`? Its much more intuitive whatever is in the answer. Honestly the answer doesn\\'t make sense. Where are you getting the random `&((a|b)^c)`?"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "(a & b & ((a | b) ^ c))\\nto me it was more understandable this way we are checking if bit of both a and b is 1 and ((a | b)^c) gives bits where there is flip needed so doing AND of it with \\'a\\' and \\'b\\' we are actually and counting 1\\'s we are actually getting number of times \\'a\\' and \\'b\\' both needs to be flipped"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/posts/%CE%BD%CE%B9%CE%BA%CF%8C%CE%BB%CE%B1%CE%BF%CF%82-%CE%BC%CF%8C%CF%83%CE%B1%CE%BB%CE%BF%CF%82-27ab081b8_documentation-activity-7091739962173194241-ABZf?utm_source=share&utm_medium=member_desktop"
                    },
                    {
                        "username": "thewickeffect",
                        "content": "This was a fun one. I feel like I understand the math for working with binary better now."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Although I\\'m not familiar with Bit Manipulation, I was still able to solve it using other approaches. It\\'s quite satisfying."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "What a joke question!"
                    },
                    {
                        "username": "Violet-",
                        "content": "Good article! Thanks LC."
                    }
                ]
            },
            {
                "id": 1919595,
                "content": [
                    {
                        "username": "aa98-45556443355666",
                        "content": "What is wrong in my approach to solve this problem ?\\n  \\n        \\n        int num1=a|b;\\n\\n        int num2=num1^c;\\n\\n        int res=0;\\n\\n        while(num2>0){\\n\\n            num2=num2&(num2-1);\\n\\n            res++;\\n        }\\n       \\n       return res;\\n\\n"
                    },
                    {
                        "username": "user1440f",
                        "content": "I think the problem is that you are not considering the case where bit in a is 1 and bit in b is 1 but bit in c is 0. Here, 2 bits will be unset in order to make the result as 0.\n\nI suggest you to use bitset in such problems."
                    },
                    {
                        "username": "tungbuivn",
                        "content": "this has two case a+b<c, so you could count down, but not by decimal number , and other case a+b>c but the bitwise does not have negative number so you must merge both case. just submit your solution and learn from other, read comment careful, some user solve it by d=(a|b)^c=>remove all bit sum ab from c, and (a&b&d)=>(c<a+b) only keep bit of c, you can do operation in decimal c-(a+b) for case 1, a+b-c for case 2"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "what num2=num2&(num2-1) stand for ? you cannot count \\'bit flip\\' like that, i suggest you convert number to an array of bit then solve it, after that you should find a way to solve without array"
                    },
                    {
                        "username": "spatecon",
                        "content": "It\\'s amazing how similar solutions from absolutely different people are. Match line by line \\uD83D\\uDE28"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "if one day, you found other code better than you, and then you will do your best to optmize your code, and finally you have small piece totally same as thier, what should you do? that mean your max performance only equal them, so my exp is do your best and submit it, if it is not 1st position then try to learn from thier, and give better solve if you can"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "dont worry, if you feel learned something on today, does that similar solution have effect to your coding skill ? =))"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "what about contests dude, even AI chatbots have same code as their\\'s."
                    },
                    {
                        "username": "Msey",
                        "content": "bitard manipulation"
                    },
                    {
                        "username": "_SID_",
                        "content": "`int getLastBit(int a){`\n        `if((a&1)==1) return 1;`\n        `return 0;`\n    `}`\n\nYou can get right side last bit of a number using above function"
                    },
                    {
                        "username": "jackgiunta",
                        "content": "Why not make \"extra\" `Integer.bitCount(a & b & ~c);`? Its much more intuitive whatever is in the answer. Honestly the answer doesn\\'t make sense. Where are you getting the random `&((a|b)^c)`?"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "(a & b & ((a | b) ^ c))\\nto me it was more understandable this way we are checking if bit of both a and b is 1 and ((a | b)^c) gives bits where there is flip needed so doing AND of it with \\'a\\' and \\'b\\' we are actually and counting 1\\'s we are actually getting number of times \\'a\\' and \\'b\\' both needs to be flipped"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/posts/%CE%BD%CE%B9%CE%BA%CF%8C%CE%BB%CE%B1%CE%BF%CF%82-%CE%BC%CF%8C%CF%83%CE%B1%CE%BB%CE%BF%CF%82-27ab081b8_documentation-activity-7091739962173194241-ABZf?utm_source=share&utm_medium=member_desktop"
                    },
                    {
                        "username": "thewickeffect",
                        "content": "This was a fun one. I feel like I understand the math for working with binary better now."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Although I\\'m not familiar with Bit Manipulation, I was still able to solve it using other approaches. It\\'s quite satisfying."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "What a joke question!"
                    },
                    {
                        "username": "Violet-",
                        "content": "Good article! Thanks LC."
                    }
                ]
            },
            {
                "id": 1919481,
                "content": [
                    {
                        "username": "aa98-45556443355666",
                        "content": "What is wrong in my approach to solve this problem ?\\n  \\n        \\n        int num1=a|b;\\n\\n        int num2=num1^c;\\n\\n        int res=0;\\n\\n        while(num2>0){\\n\\n            num2=num2&(num2-1);\\n\\n            res++;\\n        }\\n       \\n       return res;\\n\\n"
                    },
                    {
                        "username": "user1440f",
                        "content": "I think the problem is that you are not considering the case where bit in a is 1 and bit in b is 1 but bit in c is 0. Here, 2 bits will be unset in order to make the result as 0.\n\nI suggest you to use bitset in such problems."
                    },
                    {
                        "username": "tungbuivn",
                        "content": "this has two case a+b<c, so you could count down, but not by decimal number , and other case a+b>c but the bitwise does not have negative number so you must merge both case. just submit your solution and learn from other, read comment careful, some user solve it by d=(a|b)^c=>remove all bit sum ab from c, and (a&b&d)=>(c<a+b) only keep bit of c, you can do operation in decimal c-(a+b) for case 1, a+b-c for case 2"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "what num2=num2&(num2-1) stand for ? you cannot count \\'bit flip\\' like that, i suggest you convert number to an array of bit then solve it, after that you should find a way to solve without array"
                    },
                    {
                        "username": "spatecon",
                        "content": "It\\'s amazing how similar solutions from absolutely different people are. Match line by line \\uD83D\\uDE28"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "if one day, you found other code better than you, and then you will do your best to optmize your code, and finally you have small piece totally same as thier, what should you do? that mean your max performance only equal them, so my exp is do your best and submit it, if it is not 1st position then try to learn from thier, and give better solve if you can"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "dont worry, if you feel learned something on today, does that similar solution have effect to your coding skill ? =))"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "what about contests dude, even AI chatbots have same code as their\\'s."
                    },
                    {
                        "username": "Msey",
                        "content": "bitard manipulation"
                    },
                    {
                        "username": "_SID_",
                        "content": "`int getLastBit(int a){`\n        `if((a&1)==1) return 1;`\n        `return 0;`\n    `}`\n\nYou can get right side last bit of a number using above function"
                    },
                    {
                        "username": "jackgiunta",
                        "content": "Why not make \"extra\" `Integer.bitCount(a & b & ~c);`? Its much more intuitive whatever is in the answer. Honestly the answer doesn\\'t make sense. Where are you getting the random `&((a|b)^c)`?"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "(a & b & ((a | b) ^ c))\\nto me it was more understandable this way we are checking if bit of both a and b is 1 and ((a | b)^c) gives bits where there is flip needed so doing AND of it with \\'a\\' and \\'b\\' we are actually and counting 1\\'s we are actually getting number of times \\'a\\' and \\'b\\' both needs to be flipped"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/posts/%CE%BD%CE%B9%CE%BA%CF%8C%CE%BB%CE%B1%CE%BF%CF%82-%CE%BC%CF%8C%CF%83%CE%B1%CE%BB%CE%BF%CF%82-27ab081b8_documentation-activity-7091739962173194241-ABZf?utm_source=share&utm_medium=member_desktop"
                    },
                    {
                        "username": "thewickeffect",
                        "content": "This was a fun one. I feel like I understand the math for working with binary better now."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Although I\\'m not familiar with Bit Manipulation, I was still able to solve it using other approaches. It\\'s quite satisfying."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "What a joke question!"
                    },
                    {
                        "username": "Violet-",
                        "content": "Good article! Thanks LC."
                    }
                ]
            },
            {
                "id": 1994357,
                "content": [
                    {
                        "username": "aa98-45556443355666",
                        "content": "What is wrong in my approach to solve this problem ?\\n  \\n        \\n        int num1=a|b;\\n\\n        int num2=num1^c;\\n\\n        int res=0;\\n\\n        while(num2>0){\\n\\n            num2=num2&(num2-1);\\n\\n            res++;\\n        }\\n       \\n       return res;\\n\\n"
                    },
                    {
                        "username": "user1440f",
                        "content": "I think the problem is that you are not considering the case where bit in a is 1 and bit in b is 1 but bit in c is 0. Here, 2 bits will be unset in order to make the result as 0.\n\nI suggest you to use bitset in such problems."
                    },
                    {
                        "username": "tungbuivn",
                        "content": "this has two case a+b<c, so you could count down, but not by decimal number , and other case a+b>c but the bitwise does not have negative number so you must merge both case. just submit your solution and learn from other, read comment careful, some user solve it by d=(a|b)^c=>remove all bit sum ab from c, and (a&b&d)=>(c<a+b) only keep bit of c, you can do operation in decimal c-(a+b) for case 1, a+b-c for case 2"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "what num2=num2&(num2-1) stand for ? you cannot count \\'bit flip\\' like that, i suggest you convert number to an array of bit then solve it, after that you should find a way to solve without array"
                    },
                    {
                        "username": "spatecon",
                        "content": "It\\'s amazing how similar solutions from absolutely different people are. Match line by line \\uD83D\\uDE28"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "if one day, you found other code better than you, and then you will do your best to optmize your code, and finally you have small piece totally same as thier, what should you do? that mean your max performance only equal them, so my exp is do your best and submit it, if it is not 1st position then try to learn from thier, and give better solve if you can"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "dont worry, if you feel learned something on today, does that similar solution have effect to your coding skill ? =))"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "what about contests dude, even AI chatbots have same code as their\\'s."
                    },
                    {
                        "username": "Msey",
                        "content": "bitard manipulation"
                    },
                    {
                        "username": "_SID_",
                        "content": "`int getLastBit(int a){`\n        `if((a&1)==1) return 1;`\n        `return 0;`\n    `}`\n\nYou can get right side last bit of a number using above function"
                    },
                    {
                        "username": "jackgiunta",
                        "content": "Why not make \"extra\" `Integer.bitCount(a & b & ~c);`? Its much more intuitive whatever is in the answer. Honestly the answer doesn\\'t make sense. Where are you getting the random `&((a|b)^c)`?"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "(a & b & ((a | b) ^ c))\\nto me it was more understandable this way we are checking if bit of both a and b is 1 and ((a | b)^c) gives bits where there is flip needed so doing AND of it with \\'a\\' and \\'b\\' we are actually and counting 1\\'s we are actually getting number of times \\'a\\' and \\'b\\' both needs to be flipped"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/posts/%CE%BD%CE%B9%CE%BA%CF%8C%CE%BB%CE%B1%CE%BF%CF%82-%CE%BC%CF%8C%CF%83%CE%B1%CE%BB%CE%BF%CF%82-27ab081b8_documentation-activity-7091739962173194241-ABZf?utm_source=share&utm_medium=member_desktop"
                    },
                    {
                        "username": "thewickeffect",
                        "content": "This was a fun one. I feel like I understand the math for working with binary better now."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Although I\\'m not familiar with Bit Manipulation, I was still able to solve it using other approaches. It\\'s quite satisfying."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "What a joke question!"
                    },
                    {
                        "username": "Violet-",
                        "content": "Good article! Thanks LC."
                    }
                ]
            },
            {
                "id": 1924396,
                "content": [
                    {
                        "username": "aa98-45556443355666",
                        "content": "What is wrong in my approach to solve this problem ?\\n  \\n        \\n        int num1=a|b;\\n\\n        int num2=num1^c;\\n\\n        int res=0;\\n\\n        while(num2>0){\\n\\n            num2=num2&(num2-1);\\n\\n            res++;\\n        }\\n       \\n       return res;\\n\\n"
                    },
                    {
                        "username": "user1440f",
                        "content": "I think the problem is that you are not considering the case where bit in a is 1 and bit in b is 1 but bit in c is 0. Here, 2 bits will be unset in order to make the result as 0.\n\nI suggest you to use bitset in such problems."
                    },
                    {
                        "username": "tungbuivn",
                        "content": "this has two case a+b<c, so you could count down, but not by decimal number , and other case a+b>c but the bitwise does not have negative number so you must merge both case. just submit your solution and learn from other, read comment careful, some user solve it by d=(a|b)^c=>remove all bit sum ab from c, and (a&b&d)=>(c<a+b) only keep bit of c, you can do operation in decimal c-(a+b) for case 1, a+b-c for case 2"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "what num2=num2&(num2-1) stand for ? you cannot count \\'bit flip\\' like that, i suggest you convert number to an array of bit then solve it, after that you should find a way to solve without array"
                    },
                    {
                        "username": "spatecon",
                        "content": "It\\'s amazing how similar solutions from absolutely different people are. Match line by line \\uD83D\\uDE28"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "if one day, you found other code better than you, and then you will do your best to optmize your code, and finally you have small piece totally same as thier, what should you do? that mean your max performance only equal them, so my exp is do your best and submit it, if it is not 1st position then try to learn from thier, and give better solve if you can"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "dont worry, if you feel learned something on today, does that similar solution have effect to your coding skill ? =))"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "what about contests dude, even AI chatbots have same code as their\\'s."
                    },
                    {
                        "username": "Msey",
                        "content": "bitard manipulation"
                    },
                    {
                        "username": "_SID_",
                        "content": "`int getLastBit(int a){`\n        `if((a&1)==1) return 1;`\n        `return 0;`\n    `}`\n\nYou can get right side last bit of a number using above function"
                    },
                    {
                        "username": "jackgiunta",
                        "content": "Why not make \"extra\" `Integer.bitCount(a & b & ~c);`? Its much more intuitive whatever is in the answer. Honestly the answer doesn\\'t make sense. Where are you getting the random `&((a|b)^c)`?"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "(a & b & ((a | b) ^ c))\\nto me it was more understandable this way we are checking if bit of both a and b is 1 and ((a | b)^c) gives bits where there is flip needed so doing AND of it with \\'a\\' and \\'b\\' we are actually and counting 1\\'s we are actually getting number of times \\'a\\' and \\'b\\' both needs to be flipped"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/posts/%CE%BD%CE%B9%CE%BA%CF%8C%CE%BB%CE%B1%CE%BF%CF%82-%CE%BC%CF%8C%CF%83%CE%B1%CE%BB%CE%BF%CF%82-27ab081b8_documentation-activity-7091739962173194241-ABZf?utm_source=share&utm_medium=member_desktop"
                    },
                    {
                        "username": "thewickeffect",
                        "content": "This was a fun one. I feel like I understand the math for working with binary better now."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Although I\\'m not familiar with Bit Manipulation, I was still able to solve it using other approaches. It\\'s quite satisfying."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "What a joke question!"
                    },
                    {
                        "username": "Violet-",
                        "content": "Good article! Thanks LC."
                    }
                ]
            },
            {
                "id": 1922545,
                "content": [
                    {
                        "username": "aa98-45556443355666",
                        "content": "What is wrong in my approach to solve this problem ?\\n  \\n        \\n        int num1=a|b;\\n\\n        int num2=num1^c;\\n\\n        int res=0;\\n\\n        while(num2>0){\\n\\n            num2=num2&(num2-1);\\n\\n            res++;\\n        }\\n       \\n       return res;\\n\\n"
                    },
                    {
                        "username": "user1440f",
                        "content": "I think the problem is that you are not considering the case where bit in a is 1 and bit in b is 1 but bit in c is 0. Here, 2 bits will be unset in order to make the result as 0.\n\nI suggest you to use bitset in such problems."
                    },
                    {
                        "username": "tungbuivn",
                        "content": "this has two case a+b<c, so you could count down, but not by decimal number , and other case a+b>c but the bitwise does not have negative number so you must merge both case. just submit your solution and learn from other, read comment careful, some user solve it by d=(a|b)^c=>remove all bit sum ab from c, and (a&b&d)=>(c<a+b) only keep bit of c, you can do operation in decimal c-(a+b) for case 1, a+b-c for case 2"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "what num2=num2&(num2-1) stand for ? you cannot count \\'bit flip\\' like that, i suggest you convert number to an array of bit then solve it, after that you should find a way to solve without array"
                    },
                    {
                        "username": "spatecon",
                        "content": "It\\'s amazing how similar solutions from absolutely different people are. Match line by line \\uD83D\\uDE28"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "if one day, you found other code better than you, and then you will do your best to optmize your code, and finally you have small piece totally same as thier, what should you do? that mean your max performance only equal them, so my exp is do your best and submit it, if it is not 1st position then try to learn from thier, and give better solve if you can"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "dont worry, if you feel learned something on today, does that similar solution have effect to your coding skill ? =))"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "what about contests dude, even AI chatbots have same code as their\\'s."
                    },
                    {
                        "username": "Msey",
                        "content": "bitard manipulation"
                    },
                    {
                        "username": "_SID_",
                        "content": "`int getLastBit(int a){`\n        `if((a&1)==1) return 1;`\n        `return 0;`\n    `}`\n\nYou can get right side last bit of a number using above function"
                    },
                    {
                        "username": "jackgiunta",
                        "content": "Why not make \"extra\" `Integer.bitCount(a & b & ~c);`? Its much more intuitive whatever is in the answer. Honestly the answer doesn\\'t make sense. Where are you getting the random `&((a|b)^c)`?"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "(a & b & ((a | b) ^ c))\\nto me it was more understandable this way we are checking if bit of both a and b is 1 and ((a | b)^c) gives bits where there is flip needed so doing AND of it with \\'a\\' and \\'b\\' we are actually and counting 1\\'s we are actually getting number of times \\'a\\' and \\'b\\' both needs to be flipped"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/posts/%CE%BD%CE%B9%CE%BA%CF%8C%CE%BB%CE%B1%CE%BF%CF%82-%CE%BC%CF%8C%CF%83%CE%B1%CE%BB%CE%BF%CF%82-27ab081b8_documentation-activity-7091739962173194241-ABZf?utm_source=share&utm_medium=member_desktop"
                    },
                    {
                        "username": "thewickeffect",
                        "content": "This was a fun one. I feel like I understand the math for working with binary better now."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Although I\\'m not familiar with Bit Manipulation, I was still able to solve it using other approaches. It\\'s quite satisfying."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "What a joke question!"
                    },
                    {
                        "username": "Violet-",
                        "content": "Good article! Thanks LC."
                    }
                ]
            },
            {
                "id": 1920490,
                "content": [
                    {
                        "username": "aa98-45556443355666",
                        "content": "What is wrong in my approach to solve this problem ?\\n  \\n        \\n        int num1=a|b;\\n\\n        int num2=num1^c;\\n\\n        int res=0;\\n\\n        while(num2>0){\\n\\n            num2=num2&(num2-1);\\n\\n            res++;\\n        }\\n       \\n       return res;\\n\\n"
                    },
                    {
                        "username": "user1440f",
                        "content": "I think the problem is that you are not considering the case where bit in a is 1 and bit in b is 1 but bit in c is 0. Here, 2 bits will be unset in order to make the result as 0.\n\nI suggest you to use bitset in such problems."
                    },
                    {
                        "username": "tungbuivn",
                        "content": "this has two case a+b<c, so you could count down, but not by decimal number , and other case a+b>c but the bitwise does not have negative number so you must merge both case. just submit your solution and learn from other, read comment careful, some user solve it by d=(a|b)^c=>remove all bit sum ab from c, and (a&b&d)=>(c<a+b) only keep bit of c, you can do operation in decimal c-(a+b) for case 1, a+b-c for case 2"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "what num2=num2&(num2-1) stand for ? you cannot count \\'bit flip\\' like that, i suggest you convert number to an array of bit then solve it, after that you should find a way to solve without array"
                    },
                    {
                        "username": "spatecon",
                        "content": "It\\'s amazing how similar solutions from absolutely different people are. Match line by line \\uD83D\\uDE28"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "if one day, you found other code better than you, and then you will do your best to optmize your code, and finally you have small piece totally same as thier, what should you do? that mean your max performance only equal them, so my exp is do your best and submit it, if it is not 1st position then try to learn from thier, and give better solve if you can"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "dont worry, if you feel learned something on today, does that similar solution have effect to your coding skill ? =))"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "what about contests dude, even AI chatbots have same code as their\\'s."
                    },
                    {
                        "username": "Msey",
                        "content": "bitard manipulation"
                    },
                    {
                        "username": "_SID_",
                        "content": "`int getLastBit(int a){`\n        `if((a&1)==1) return 1;`\n        `return 0;`\n    `}`\n\nYou can get right side last bit of a number using above function"
                    },
                    {
                        "username": "jackgiunta",
                        "content": "Why not make \"extra\" `Integer.bitCount(a & b & ~c);`? Its much more intuitive whatever is in the answer. Honestly the answer doesn\\'t make sense. Where are you getting the random `&((a|b)^c)`?"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "(a & b & ((a | b) ^ c))\\nto me it was more understandable this way we are checking if bit of both a and b is 1 and ((a | b)^c) gives bits where there is flip needed so doing AND of it with \\'a\\' and \\'b\\' we are actually and counting 1\\'s we are actually getting number of times \\'a\\' and \\'b\\' both needs to be flipped"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/posts/%CE%BD%CE%B9%CE%BA%CF%8C%CE%BB%CE%B1%CE%BF%CF%82-%CE%BC%CF%8C%CF%83%CE%B1%CE%BB%CE%BF%CF%82-27ab081b8_documentation-activity-7091739962173194241-ABZf?utm_source=share&utm_medium=member_desktop"
                    },
                    {
                        "username": "thewickeffect",
                        "content": "This was a fun one. I feel like I understand the math for working with binary better now."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Although I\\'m not familiar with Bit Manipulation, I was still able to solve it using other approaches. It\\'s quite satisfying."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "What a joke question!"
                    },
                    {
                        "username": "Violet-",
                        "content": "Good article! Thanks LC."
                    }
                ]
            },
            {
                "id": 1920489,
                "content": [
                    {
                        "username": "aa98-45556443355666",
                        "content": "What is wrong in my approach to solve this problem ?\\n  \\n        \\n        int num1=a|b;\\n\\n        int num2=num1^c;\\n\\n        int res=0;\\n\\n        while(num2>0){\\n\\n            num2=num2&(num2-1);\\n\\n            res++;\\n        }\\n       \\n       return res;\\n\\n"
                    },
                    {
                        "username": "user1440f",
                        "content": "I think the problem is that you are not considering the case where bit in a is 1 and bit in b is 1 but bit in c is 0. Here, 2 bits will be unset in order to make the result as 0.\n\nI suggest you to use bitset in such problems."
                    },
                    {
                        "username": "tungbuivn",
                        "content": "this has two case a+b<c, so you could count down, but not by decimal number , and other case a+b>c but the bitwise does not have negative number so you must merge both case. just submit your solution and learn from other, read comment careful, some user solve it by d=(a|b)^c=>remove all bit sum ab from c, and (a&b&d)=>(c<a+b) only keep bit of c, you can do operation in decimal c-(a+b) for case 1, a+b-c for case 2"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "what num2=num2&(num2-1) stand for ? you cannot count \\'bit flip\\' like that, i suggest you convert number to an array of bit then solve it, after that you should find a way to solve without array"
                    },
                    {
                        "username": "spatecon",
                        "content": "It\\'s amazing how similar solutions from absolutely different people are. Match line by line \\uD83D\\uDE28"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "if one day, you found other code better than you, and then you will do your best to optmize your code, and finally you have small piece totally same as thier, what should you do? that mean your max performance only equal them, so my exp is do your best and submit it, if it is not 1st position then try to learn from thier, and give better solve if you can"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "dont worry, if you feel learned something on today, does that similar solution have effect to your coding skill ? =))"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "what about contests dude, even AI chatbots have same code as their\\'s."
                    },
                    {
                        "username": "Msey",
                        "content": "bitard manipulation"
                    },
                    {
                        "username": "_SID_",
                        "content": "`int getLastBit(int a){`\n        `if((a&1)==1) return 1;`\n        `return 0;`\n    `}`\n\nYou can get right side last bit of a number using above function"
                    },
                    {
                        "username": "jackgiunta",
                        "content": "Why not make \"extra\" `Integer.bitCount(a & b & ~c);`? Its much more intuitive whatever is in the answer. Honestly the answer doesn\\'t make sense. Where are you getting the random `&((a|b)^c)`?"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "(a & b & ((a | b) ^ c))\\nto me it was more understandable this way we are checking if bit of both a and b is 1 and ((a | b)^c) gives bits where there is flip needed so doing AND of it with \\'a\\' and \\'b\\' we are actually and counting 1\\'s we are actually getting number of times \\'a\\' and \\'b\\' both needs to be flipped"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/posts/%CE%BD%CE%B9%CE%BA%CF%8C%CE%BB%CE%B1%CE%BF%CF%82-%CE%BC%CF%8C%CF%83%CE%B1%CE%BB%CE%BF%CF%82-27ab081b8_documentation-activity-7091739962173194241-ABZf?utm_source=share&utm_medium=member_desktop"
                    },
                    {
                        "username": "thewickeffect",
                        "content": "This was a fun one. I feel like I understand the math for working with binary better now."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Although I\\'m not familiar with Bit Manipulation, I was still able to solve it using other approaches. It\\'s quite satisfying."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "What a joke question!"
                    },
                    {
                        "username": "Violet-",
                        "content": "Good article! Thanks LC."
                    }
                ]
            },
            {
                "id": 1920301,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "First Medium Question that is not hard\\uD83D\\uDE02"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "Should probably be an easy question. The bitwise operations are extremely simple once you are introduced to them, and even if you don\\'t know it off the top of your head (like me) you can solve this with rudimentary String comparison, using the String value of the binary representation of the integer."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "lemuel5",
                        "content": "can anyone explain this question in easier way"
                    },
                    {
                        "username": "lilpotatowoo",
                        "content": "how many times do you change a and b so that when you \"or\" them it equals c?"
                    },
                    {
                        "username": "coderboi329",
                        "content": "this is a trivia question.... "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "said your Ego :)"
                    },
                    {
                        "username": "chettriyuvraj",
                        "content": "Solving this was oddly satisfying :)"
                    },
                    {
                        "username": "cleydyr",
                        "content": "Why does a = 7, b = 3, c = 9 require 4 flips instead of 5? In understand that from right to left (less significative bit to most significative bit) we'd require 1 flip, then 2, 1 , 1."
                    },
                    {
                        "username": "cleydyr",
                        "content": "[@EricRaw](/EricRaw) :facepalm: I misread your answer initially, but now I understand your point! Thank you!"
                    },
                    {
                        "username": "cleydyr",
                        "content": "[@EricRaw](/EricRaw) , why \"the first digit doesn\\'t need a change so answer = 0\"? I see the first digits (to the left) to be 0 for a and 0 for b, so 0 | 0 = 0, but the digit in c is 1. Am I missing something?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "a = 0111\nb = 0011\nc = 1001\n(from right to left)\n- the first digit \ndoesn't need a change so \nanswer = 0\n- the second digit \na change (1 => 0)\nb change (1 => 0)\nanswer = 2\n- the third digit\na change (1 => 0)\nanswer is 3\n- the fourth digit\na or b change (0 => 1) (one of it)\nanswer is 4"
                    },
                    {
                        "username": "mdxaasil",
                        "content": "class Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        flips=0\\n        for i in range(32):\\n            bitA=a&1\\n            bitB=b&1\\n            bitC=c&1\\n            \\n            if(bitC == (bitA|bitB)):\\n                continue\\n            else:\\n                if(bitC==0):\\n                    if(bitA==1 and bitB==1):\\n                        flips+=2\\n                    else:\\n                        flips+=1\\n                else:\\n                    flips+=1\\n            \\n            a=a>>1\\n            b=b>>1\\n            c=c>>1\\n        return flips\\n\\nCan someone explain me why it fails for few test cases? Whats the edge case?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The logic is not quite right. If bitA=bitB=bitC=0 then no flips are required. Similarly, if bitC=1 then one flip is require only if bitA=bitB."
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Surely the question is framed by an Intern. Very crisp and strange question language."
                    },
                    {
                        "username": "ijogendrajat",
                        "content": "need dart language support for this problem."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Simple Solution using dictionary \n\nassume that we have 3 bits, a,b,c and what should be the count of the flips\nabc|flipCount\n000=>0\n001=>1\n010=>1\n011=>0\n100=>1\n101=>0\n110=>2\n111=>0\n\nSo how about create a dictionary/map for these values, and then keep extracting last bits from a,b,c. and combine them, and lookinto map for flip count,\n\nhttps://leetcode.com/problems/minimum-flips-to-make-a-or-b-equal-to-c/solutions/3607503/simple-solution-using-dictionary/"
                    }
                ]
            },
            {
                "id": 1920287,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "First Medium Question that is not hard\\uD83D\\uDE02"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "Should probably be an easy question. The bitwise operations are extremely simple once you are introduced to them, and even if you don\\'t know it off the top of your head (like me) you can solve this with rudimentary String comparison, using the String value of the binary representation of the integer."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "lemuel5",
                        "content": "can anyone explain this question in easier way"
                    },
                    {
                        "username": "lilpotatowoo",
                        "content": "how many times do you change a and b so that when you \"or\" them it equals c?"
                    },
                    {
                        "username": "coderboi329",
                        "content": "this is a trivia question.... "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "said your Ego :)"
                    },
                    {
                        "username": "chettriyuvraj",
                        "content": "Solving this was oddly satisfying :)"
                    },
                    {
                        "username": "cleydyr",
                        "content": "Why does a = 7, b = 3, c = 9 require 4 flips instead of 5? In understand that from right to left (less significative bit to most significative bit) we'd require 1 flip, then 2, 1 , 1."
                    },
                    {
                        "username": "cleydyr",
                        "content": "[@EricRaw](/EricRaw) :facepalm: I misread your answer initially, but now I understand your point! Thank you!"
                    },
                    {
                        "username": "cleydyr",
                        "content": "[@EricRaw](/EricRaw) , why \"the first digit doesn\\'t need a change so answer = 0\"? I see the first digits (to the left) to be 0 for a and 0 for b, so 0 | 0 = 0, but the digit in c is 1. Am I missing something?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "a = 0111\nb = 0011\nc = 1001\n(from right to left)\n- the first digit \ndoesn't need a change so \nanswer = 0\n- the second digit \na change (1 => 0)\nb change (1 => 0)\nanswer = 2\n- the third digit\na change (1 => 0)\nanswer is 3\n- the fourth digit\na or b change (0 => 1) (one of it)\nanswer is 4"
                    },
                    {
                        "username": "mdxaasil",
                        "content": "class Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        flips=0\\n        for i in range(32):\\n            bitA=a&1\\n            bitB=b&1\\n            bitC=c&1\\n            \\n            if(bitC == (bitA|bitB)):\\n                continue\\n            else:\\n                if(bitC==0):\\n                    if(bitA==1 and bitB==1):\\n                        flips+=2\\n                    else:\\n                        flips+=1\\n                else:\\n                    flips+=1\\n            \\n            a=a>>1\\n            b=b>>1\\n            c=c>>1\\n        return flips\\n\\nCan someone explain me why it fails for few test cases? Whats the edge case?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The logic is not quite right. If bitA=bitB=bitC=0 then no flips are required. Similarly, if bitC=1 then one flip is require only if bitA=bitB."
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Surely the question is framed by an Intern. Very crisp and strange question language."
                    },
                    {
                        "username": "ijogendrajat",
                        "content": "need dart language support for this problem."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Simple Solution using dictionary \n\nassume that we have 3 bits, a,b,c and what should be the count of the flips\nabc|flipCount\n000=>0\n001=>1\n010=>1\n011=>0\n100=>1\n101=>0\n110=>2\n111=>0\n\nSo how about create a dictionary/map for these values, and then keep extracting last bits from a,b,c. and combine them, and lookinto map for flip count,\n\nhttps://leetcode.com/problems/minimum-flips-to-make-a-or-b-equal-to-c/solutions/3607503/simple-solution-using-dictionary/"
                    }
                ]
            },
            {
                "id": 1920197,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "First Medium Question that is not hard\\uD83D\\uDE02"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "Should probably be an easy question. The bitwise operations are extremely simple once you are introduced to them, and even if you don\\'t know it off the top of your head (like me) you can solve this with rudimentary String comparison, using the String value of the binary representation of the integer."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "lemuel5",
                        "content": "can anyone explain this question in easier way"
                    },
                    {
                        "username": "lilpotatowoo",
                        "content": "how many times do you change a and b so that when you \"or\" them it equals c?"
                    },
                    {
                        "username": "coderboi329",
                        "content": "this is a trivia question.... "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "said your Ego :)"
                    },
                    {
                        "username": "chettriyuvraj",
                        "content": "Solving this was oddly satisfying :)"
                    },
                    {
                        "username": "cleydyr",
                        "content": "Why does a = 7, b = 3, c = 9 require 4 flips instead of 5? In understand that from right to left (less significative bit to most significative bit) we'd require 1 flip, then 2, 1 , 1."
                    },
                    {
                        "username": "cleydyr",
                        "content": "[@EricRaw](/EricRaw) :facepalm: I misread your answer initially, but now I understand your point! Thank you!"
                    },
                    {
                        "username": "cleydyr",
                        "content": "[@EricRaw](/EricRaw) , why \"the first digit doesn\\'t need a change so answer = 0\"? I see the first digits (to the left) to be 0 for a and 0 for b, so 0 | 0 = 0, but the digit in c is 1. Am I missing something?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "a = 0111\nb = 0011\nc = 1001\n(from right to left)\n- the first digit \ndoesn't need a change so \nanswer = 0\n- the second digit \na change (1 => 0)\nb change (1 => 0)\nanswer = 2\n- the third digit\na change (1 => 0)\nanswer is 3\n- the fourth digit\na or b change (0 => 1) (one of it)\nanswer is 4"
                    },
                    {
                        "username": "mdxaasil",
                        "content": "class Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        flips=0\\n        for i in range(32):\\n            bitA=a&1\\n            bitB=b&1\\n            bitC=c&1\\n            \\n            if(bitC == (bitA|bitB)):\\n                continue\\n            else:\\n                if(bitC==0):\\n                    if(bitA==1 and bitB==1):\\n                        flips+=2\\n                    else:\\n                        flips+=1\\n                else:\\n                    flips+=1\\n            \\n            a=a>>1\\n            b=b>>1\\n            c=c>>1\\n        return flips\\n\\nCan someone explain me why it fails for few test cases? Whats the edge case?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The logic is not quite right. If bitA=bitB=bitC=0 then no flips are required. Similarly, if bitC=1 then one flip is require only if bitA=bitB."
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Surely the question is framed by an Intern. Very crisp and strange question language."
                    },
                    {
                        "username": "ijogendrajat",
                        "content": "need dart language support for this problem."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Simple Solution using dictionary \n\nassume that we have 3 bits, a,b,c and what should be the count of the flips\nabc|flipCount\n000=>0\n001=>1\n010=>1\n011=>0\n100=>1\n101=>0\n110=>2\n111=>0\n\nSo how about create a dictionary/map for these values, and then keep extracting last bits from a,b,c. and combine them, and lookinto map for flip count,\n\nhttps://leetcode.com/problems/minimum-flips-to-make-a-or-b-equal-to-c/solutions/3607503/simple-solution-using-dictionary/"
                    }
                ]
            },
            {
                "id": 1920160,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "First Medium Question that is not hard\\uD83D\\uDE02"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "Should probably be an easy question. The bitwise operations are extremely simple once you are introduced to them, and even if you don\\'t know it off the top of your head (like me) you can solve this with rudimentary String comparison, using the String value of the binary representation of the integer."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "lemuel5",
                        "content": "can anyone explain this question in easier way"
                    },
                    {
                        "username": "lilpotatowoo",
                        "content": "how many times do you change a and b so that when you \"or\" them it equals c?"
                    },
                    {
                        "username": "coderboi329",
                        "content": "this is a trivia question.... "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "said your Ego :)"
                    },
                    {
                        "username": "chettriyuvraj",
                        "content": "Solving this was oddly satisfying :)"
                    },
                    {
                        "username": "cleydyr",
                        "content": "Why does a = 7, b = 3, c = 9 require 4 flips instead of 5? In understand that from right to left (less significative bit to most significative bit) we'd require 1 flip, then 2, 1 , 1."
                    },
                    {
                        "username": "cleydyr",
                        "content": "[@EricRaw](/EricRaw) :facepalm: I misread your answer initially, but now I understand your point! Thank you!"
                    },
                    {
                        "username": "cleydyr",
                        "content": "[@EricRaw](/EricRaw) , why \"the first digit doesn\\'t need a change so answer = 0\"? I see the first digits (to the left) to be 0 for a and 0 for b, so 0 | 0 = 0, but the digit in c is 1. Am I missing something?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "a = 0111\nb = 0011\nc = 1001\n(from right to left)\n- the first digit \ndoesn't need a change so \nanswer = 0\n- the second digit \na change (1 => 0)\nb change (1 => 0)\nanswer = 2\n- the third digit\na change (1 => 0)\nanswer is 3\n- the fourth digit\na or b change (0 => 1) (one of it)\nanswer is 4"
                    },
                    {
                        "username": "mdxaasil",
                        "content": "class Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        flips=0\\n        for i in range(32):\\n            bitA=a&1\\n            bitB=b&1\\n            bitC=c&1\\n            \\n            if(bitC == (bitA|bitB)):\\n                continue\\n            else:\\n                if(bitC==0):\\n                    if(bitA==1 and bitB==1):\\n                        flips+=2\\n                    else:\\n                        flips+=1\\n                else:\\n                    flips+=1\\n            \\n            a=a>>1\\n            b=b>>1\\n            c=c>>1\\n        return flips\\n\\nCan someone explain me why it fails for few test cases? Whats the edge case?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The logic is not quite right. If bitA=bitB=bitC=0 then no flips are required. Similarly, if bitC=1 then one flip is require only if bitA=bitB."
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Surely the question is framed by an Intern. Very crisp and strange question language."
                    },
                    {
                        "username": "ijogendrajat",
                        "content": "need dart language support for this problem."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Simple Solution using dictionary \n\nassume that we have 3 bits, a,b,c and what should be the count of the flips\nabc|flipCount\n000=>0\n001=>1\n010=>1\n011=>0\n100=>1\n101=>0\n110=>2\n111=>0\n\nSo how about create a dictionary/map for these values, and then keep extracting last bits from a,b,c. and combine them, and lookinto map for flip count,\n\nhttps://leetcode.com/problems/minimum-flips-to-make-a-or-b-equal-to-c/solutions/3607503/simple-solution-using-dictionary/"
                    }
                ]
            },
            {
                "id": 1919971,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "First Medium Question that is not hard\\uD83D\\uDE02"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "Should probably be an easy question. The bitwise operations are extremely simple once you are introduced to them, and even if you don\\'t know it off the top of your head (like me) you can solve this with rudimentary String comparison, using the String value of the binary representation of the integer."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "lemuel5",
                        "content": "can anyone explain this question in easier way"
                    },
                    {
                        "username": "lilpotatowoo",
                        "content": "how many times do you change a and b so that when you \"or\" them it equals c?"
                    },
                    {
                        "username": "coderboi329",
                        "content": "this is a trivia question.... "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "said your Ego :)"
                    },
                    {
                        "username": "chettriyuvraj",
                        "content": "Solving this was oddly satisfying :)"
                    },
                    {
                        "username": "cleydyr",
                        "content": "Why does a = 7, b = 3, c = 9 require 4 flips instead of 5? In understand that from right to left (less significative bit to most significative bit) we'd require 1 flip, then 2, 1 , 1."
                    },
                    {
                        "username": "cleydyr",
                        "content": "[@EricRaw](/EricRaw) :facepalm: I misread your answer initially, but now I understand your point! Thank you!"
                    },
                    {
                        "username": "cleydyr",
                        "content": "[@EricRaw](/EricRaw) , why \"the first digit doesn\\'t need a change so answer = 0\"? I see the first digits (to the left) to be 0 for a and 0 for b, so 0 | 0 = 0, but the digit in c is 1. Am I missing something?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "a = 0111\nb = 0011\nc = 1001\n(from right to left)\n- the first digit \ndoesn't need a change so \nanswer = 0\n- the second digit \na change (1 => 0)\nb change (1 => 0)\nanswer = 2\n- the third digit\na change (1 => 0)\nanswer is 3\n- the fourth digit\na or b change (0 => 1) (one of it)\nanswer is 4"
                    },
                    {
                        "username": "mdxaasil",
                        "content": "class Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        flips=0\\n        for i in range(32):\\n            bitA=a&1\\n            bitB=b&1\\n            bitC=c&1\\n            \\n            if(bitC == (bitA|bitB)):\\n                continue\\n            else:\\n                if(bitC==0):\\n                    if(bitA==1 and bitB==1):\\n                        flips+=2\\n                    else:\\n                        flips+=1\\n                else:\\n                    flips+=1\\n            \\n            a=a>>1\\n            b=b>>1\\n            c=c>>1\\n        return flips\\n\\nCan someone explain me why it fails for few test cases? Whats the edge case?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The logic is not quite right. If bitA=bitB=bitC=0 then no flips are required. Similarly, if bitC=1 then one flip is require only if bitA=bitB."
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Surely the question is framed by an Intern. Very crisp and strange question language."
                    },
                    {
                        "username": "ijogendrajat",
                        "content": "need dart language support for this problem."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Simple Solution using dictionary \n\nassume that we have 3 bits, a,b,c and what should be the count of the flips\nabc|flipCount\n000=>0\n001=>1\n010=>1\n011=>0\n100=>1\n101=>0\n110=>2\n111=>0\n\nSo how about create a dictionary/map for these values, and then keep extracting last bits from a,b,c. and combine them, and lookinto map for flip count,\n\nhttps://leetcode.com/problems/minimum-flips-to-make-a-or-b-equal-to-c/solutions/3607503/simple-solution-using-dictionary/"
                    }
                ]
            },
            {
                "id": 1919944,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "First Medium Question that is not hard\\uD83D\\uDE02"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "Should probably be an easy question. The bitwise operations are extremely simple once you are introduced to them, and even if you don\\'t know it off the top of your head (like me) you can solve this with rudimentary String comparison, using the String value of the binary representation of the integer."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "lemuel5",
                        "content": "can anyone explain this question in easier way"
                    },
                    {
                        "username": "lilpotatowoo",
                        "content": "how many times do you change a and b so that when you \"or\" them it equals c?"
                    },
                    {
                        "username": "coderboi329",
                        "content": "this is a trivia question.... "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "said your Ego :)"
                    },
                    {
                        "username": "chettriyuvraj",
                        "content": "Solving this was oddly satisfying :)"
                    },
                    {
                        "username": "cleydyr",
                        "content": "Why does a = 7, b = 3, c = 9 require 4 flips instead of 5? In understand that from right to left (less significative bit to most significative bit) we'd require 1 flip, then 2, 1 , 1."
                    },
                    {
                        "username": "cleydyr",
                        "content": "[@EricRaw](/EricRaw) :facepalm: I misread your answer initially, but now I understand your point! Thank you!"
                    },
                    {
                        "username": "cleydyr",
                        "content": "[@EricRaw](/EricRaw) , why \"the first digit doesn\\'t need a change so answer = 0\"? I see the first digits (to the left) to be 0 for a and 0 for b, so 0 | 0 = 0, but the digit in c is 1. Am I missing something?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "a = 0111\nb = 0011\nc = 1001\n(from right to left)\n- the first digit \ndoesn't need a change so \nanswer = 0\n- the second digit \na change (1 => 0)\nb change (1 => 0)\nanswer = 2\n- the third digit\na change (1 => 0)\nanswer is 3\n- the fourth digit\na or b change (0 => 1) (one of it)\nanswer is 4"
                    },
                    {
                        "username": "mdxaasil",
                        "content": "class Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        flips=0\\n        for i in range(32):\\n            bitA=a&1\\n            bitB=b&1\\n            bitC=c&1\\n            \\n            if(bitC == (bitA|bitB)):\\n                continue\\n            else:\\n                if(bitC==0):\\n                    if(bitA==1 and bitB==1):\\n                        flips+=2\\n                    else:\\n                        flips+=1\\n                else:\\n                    flips+=1\\n            \\n            a=a>>1\\n            b=b>>1\\n            c=c>>1\\n        return flips\\n\\nCan someone explain me why it fails for few test cases? Whats the edge case?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The logic is not quite right. If bitA=bitB=bitC=0 then no flips are required. Similarly, if bitC=1 then one flip is require only if bitA=bitB."
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Surely the question is framed by an Intern. Very crisp and strange question language."
                    },
                    {
                        "username": "ijogendrajat",
                        "content": "need dart language support for this problem."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Simple Solution using dictionary \n\nassume that we have 3 bits, a,b,c and what should be the count of the flips\nabc|flipCount\n000=>0\n001=>1\n010=>1\n011=>0\n100=>1\n101=>0\n110=>2\n111=>0\n\nSo how about create a dictionary/map for these values, and then keep extracting last bits from a,b,c. and combine them, and lookinto map for flip count,\n\nhttps://leetcode.com/problems/minimum-flips-to-make-a-or-b-equal-to-c/solutions/3607503/simple-solution-using-dictionary/"
                    }
                ]
            },
            {
                "id": 1919935,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "First Medium Question that is not hard\\uD83D\\uDE02"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "Should probably be an easy question. The bitwise operations are extremely simple once you are introduced to them, and even if you don\\'t know it off the top of your head (like me) you can solve this with rudimentary String comparison, using the String value of the binary representation of the integer."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "lemuel5",
                        "content": "can anyone explain this question in easier way"
                    },
                    {
                        "username": "lilpotatowoo",
                        "content": "how many times do you change a and b so that when you \"or\" them it equals c?"
                    },
                    {
                        "username": "coderboi329",
                        "content": "this is a trivia question.... "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "said your Ego :)"
                    },
                    {
                        "username": "chettriyuvraj",
                        "content": "Solving this was oddly satisfying :)"
                    },
                    {
                        "username": "cleydyr",
                        "content": "Why does a = 7, b = 3, c = 9 require 4 flips instead of 5? In understand that from right to left (less significative bit to most significative bit) we'd require 1 flip, then 2, 1 , 1."
                    },
                    {
                        "username": "cleydyr",
                        "content": "[@EricRaw](/EricRaw) :facepalm: I misread your answer initially, but now I understand your point! Thank you!"
                    },
                    {
                        "username": "cleydyr",
                        "content": "[@EricRaw](/EricRaw) , why \"the first digit doesn\\'t need a change so answer = 0\"? I see the first digits (to the left) to be 0 for a and 0 for b, so 0 | 0 = 0, but the digit in c is 1. Am I missing something?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "a = 0111\nb = 0011\nc = 1001\n(from right to left)\n- the first digit \ndoesn't need a change so \nanswer = 0\n- the second digit \na change (1 => 0)\nb change (1 => 0)\nanswer = 2\n- the third digit\na change (1 => 0)\nanswer is 3\n- the fourth digit\na or b change (0 => 1) (one of it)\nanswer is 4"
                    },
                    {
                        "username": "mdxaasil",
                        "content": "class Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        flips=0\\n        for i in range(32):\\n            bitA=a&1\\n            bitB=b&1\\n            bitC=c&1\\n            \\n            if(bitC == (bitA|bitB)):\\n                continue\\n            else:\\n                if(bitC==0):\\n                    if(bitA==1 and bitB==1):\\n                        flips+=2\\n                    else:\\n                        flips+=1\\n                else:\\n                    flips+=1\\n            \\n            a=a>>1\\n            b=b>>1\\n            c=c>>1\\n        return flips\\n\\nCan someone explain me why it fails for few test cases? Whats the edge case?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The logic is not quite right. If bitA=bitB=bitC=0 then no flips are required. Similarly, if bitC=1 then one flip is require only if bitA=bitB."
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Surely the question is framed by an Intern. Very crisp and strange question language."
                    },
                    {
                        "username": "ijogendrajat",
                        "content": "need dart language support for this problem."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Simple Solution using dictionary \n\nassume that we have 3 bits, a,b,c and what should be the count of the flips\nabc|flipCount\n000=>0\n001=>1\n010=>1\n011=>0\n100=>1\n101=>0\n110=>2\n111=>0\n\nSo how about create a dictionary/map for these values, and then keep extracting last bits from a,b,c. and combine them, and lookinto map for flip count,\n\nhttps://leetcode.com/problems/minimum-flips-to-make-a-or-b-equal-to-c/solutions/3607503/simple-solution-using-dictionary/"
                    }
                ]
            },
            {
                "id": 1919724,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "First Medium Question that is not hard\\uD83D\\uDE02"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "Should probably be an easy question. The bitwise operations are extremely simple once you are introduced to them, and even if you don\\'t know it off the top of your head (like me) you can solve this with rudimentary String comparison, using the String value of the binary representation of the integer."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "lemuel5",
                        "content": "can anyone explain this question in easier way"
                    },
                    {
                        "username": "lilpotatowoo",
                        "content": "how many times do you change a and b so that when you \"or\" them it equals c?"
                    },
                    {
                        "username": "coderboi329",
                        "content": "this is a trivia question.... "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "said your Ego :)"
                    },
                    {
                        "username": "chettriyuvraj",
                        "content": "Solving this was oddly satisfying :)"
                    },
                    {
                        "username": "cleydyr",
                        "content": "Why does a = 7, b = 3, c = 9 require 4 flips instead of 5? In understand that from right to left (less significative bit to most significative bit) we'd require 1 flip, then 2, 1 , 1."
                    },
                    {
                        "username": "cleydyr",
                        "content": "[@EricRaw](/EricRaw) :facepalm: I misread your answer initially, but now I understand your point! Thank you!"
                    },
                    {
                        "username": "cleydyr",
                        "content": "[@EricRaw](/EricRaw) , why \"the first digit doesn\\'t need a change so answer = 0\"? I see the first digits (to the left) to be 0 for a and 0 for b, so 0 | 0 = 0, but the digit in c is 1. Am I missing something?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "a = 0111\nb = 0011\nc = 1001\n(from right to left)\n- the first digit \ndoesn't need a change so \nanswer = 0\n- the second digit \na change (1 => 0)\nb change (1 => 0)\nanswer = 2\n- the third digit\na change (1 => 0)\nanswer is 3\n- the fourth digit\na or b change (0 => 1) (one of it)\nanswer is 4"
                    },
                    {
                        "username": "mdxaasil",
                        "content": "class Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        flips=0\\n        for i in range(32):\\n            bitA=a&1\\n            bitB=b&1\\n            bitC=c&1\\n            \\n            if(bitC == (bitA|bitB)):\\n                continue\\n            else:\\n                if(bitC==0):\\n                    if(bitA==1 and bitB==1):\\n                        flips+=2\\n                    else:\\n                        flips+=1\\n                else:\\n                    flips+=1\\n            \\n            a=a>>1\\n            b=b>>1\\n            c=c>>1\\n        return flips\\n\\nCan someone explain me why it fails for few test cases? Whats the edge case?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The logic is not quite right. If bitA=bitB=bitC=0 then no flips are required. Similarly, if bitC=1 then one flip is require only if bitA=bitB."
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Surely the question is framed by an Intern. Very crisp and strange question language."
                    },
                    {
                        "username": "ijogendrajat",
                        "content": "need dart language support for this problem."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Simple Solution using dictionary \n\nassume that we have 3 bits, a,b,c and what should be the count of the flips\nabc|flipCount\n000=>0\n001=>1\n010=>1\n011=>0\n100=>1\n101=>0\n110=>2\n111=>0\n\nSo how about create a dictionary/map for these values, and then keep extracting last bits from a,b,c. and combine them, and lookinto map for flip count,\n\nhttps://leetcode.com/problems/minimum-flips-to-make-a-or-b-equal-to-c/solutions/3607503/simple-solution-using-dictionary/"
                    }
                ]
            },
            {
                "id": 1919645,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "First Medium Question that is not hard\\uD83D\\uDE02"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "Should probably be an easy question. The bitwise operations are extremely simple once you are introduced to them, and even if you don\\'t know it off the top of your head (like me) you can solve this with rudimentary String comparison, using the String value of the binary representation of the integer."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "lemuel5",
                        "content": "can anyone explain this question in easier way"
                    },
                    {
                        "username": "lilpotatowoo",
                        "content": "how many times do you change a and b so that when you \"or\" them it equals c?"
                    },
                    {
                        "username": "coderboi329",
                        "content": "this is a trivia question.... "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "said your Ego :)"
                    },
                    {
                        "username": "chettriyuvraj",
                        "content": "Solving this was oddly satisfying :)"
                    },
                    {
                        "username": "cleydyr",
                        "content": "Why does a = 7, b = 3, c = 9 require 4 flips instead of 5? In understand that from right to left (less significative bit to most significative bit) we'd require 1 flip, then 2, 1 , 1."
                    },
                    {
                        "username": "cleydyr",
                        "content": "[@EricRaw](/EricRaw) :facepalm: I misread your answer initially, but now I understand your point! Thank you!"
                    },
                    {
                        "username": "cleydyr",
                        "content": "[@EricRaw](/EricRaw) , why \"the first digit doesn\\'t need a change so answer = 0\"? I see the first digits (to the left) to be 0 for a and 0 for b, so 0 | 0 = 0, but the digit in c is 1. Am I missing something?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "a = 0111\nb = 0011\nc = 1001\n(from right to left)\n- the first digit \ndoesn't need a change so \nanswer = 0\n- the second digit \na change (1 => 0)\nb change (1 => 0)\nanswer = 2\n- the third digit\na change (1 => 0)\nanswer is 3\n- the fourth digit\na or b change (0 => 1) (one of it)\nanswer is 4"
                    },
                    {
                        "username": "mdxaasil",
                        "content": "class Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        flips=0\\n        for i in range(32):\\n            bitA=a&1\\n            bitB=b&1\\n            bitC=c&1\\n            \\n            if(bitC == (bitA|bitB)):\\n                continue\\n            else:\\n                if(bitC==0):\\n                    if(bitA==1 and bitB==1):\\n                        flips+=2\\n                    else:\\n                        flips+=1\\n                else:\\n                    flips+=1\\n            \\n            a=a>>1\\n            b=b>>1\\n            c=c>>1\\n        return flips\\n\\nCan someone explain me why it fails for few test cases? Whats the edge case?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The logic is not quite right. If bitA=bitB=bitC=0 then no flips are required. Similarly, if bitC=1 then one flip is require only if bitA=bitB."
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Surely the question is framed by an Intern. Very crisp and strange question language."
                    },
                    {
                        "username": "ijogendrajat",
                        "content": "need dart language support for this problem."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Simple Solution using dictionary \n\nassume that we have 3 bits, a,b,c and what should be the count of the flips\nabc|flipCount\n000=>0\n001=>1\n010=>1\n011=>0\n100=>1\n101=>0\n110=>2\n111=>0\n\nSo how about create a dictionary/map for these values, and then keep extracting last bits from a,b,c. and combine them, and lookinto map for flip count,\n\nhttps://leetcode.com/problems/minimum-flips-to-make-a-or-b-equal-to-c/solutions/3607503/simple-solution-using-dictionary/"
                    }
                ]
            },
            {
                "id": 1919642,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "First Medium Question that is not hard\\uD83D\\uDE02"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "Should probably be an easy question. The bitwise operations are extremely simple once you are introduced to them, and even if you don\\'t know it off the top of your head (like me) you can solve this with rudimentary String comparison, using the String value of the binary representation of the integer."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "lemuel5",
                        "content": "can anyone explain this question in easier way"
                    },
                    {
                        "username": "lilpotatowoo",
                        "content": "how many times do you change a and b so that when you \"or\" them it equals c?"
                    },
                    {
                        "username": "coderboi329",
                        "content": "this is a trivia question.... "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "said your Ego :)"
                    },
                    {
                        "username": "chettriyuvraj",
                        "content": "Solving this was oddly satisfying :)"
                    },
                    {
                        "username": "cleydyr",
                        "content": "Why does a = 7, b = 3, c = 9 require 4 flips instead of 5? In understand that from right to left (less significative bit to most significative bit) we'd require 1 flip, then 2, 1 , 1."
                    },
                    {
                        "username": "cleydyr",
                        "content": "[@EricRaw](/EricRaw) :facepalm: I misread your answer initially, but now I understand your point! Thank you!"
                    },
                    {
                        "username": "cleydyr",
                        "content": "[@EricRaw](/EricRaw) , why \"the first digit doesn\\'t need a change so answer = 0\"? I see the first digits (to the left) to be 0 for a and 0 for b, so 0 | 0 = 0, but the digit in c is 1. Am I missing something?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "a = 0111\nb = 0011\nc = 1001\n(from right to left)\n- the first digit \ndoesn't need a change so \nanswer = 0\n- the second digit \na change (1 => 0)\nb change (1 => 0)\nanswer = 2\n- the third digit\na change (1 => 0)\nanswer is 3\n- the fourth digit\na or b change (0 => 1) (one of it)\nanswer is 4"
                    },
                    {
                        "username": "mdxaasil",
                        "content": "class Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        flips=0\\n        for i in range(32):\\n            bitA=a&1\\n            bitB=b&1\\n            bitC=c&1\\n            \\n            if(bitC == (bitA|bitB)):\\n                continue\\n            else:\\n                if(bitC==0):\\n                    if(bitA==1 and bitB==1):\\n                        flips+=2\\n                    else:\\n                        flips+=1\\n                else:\\n                    flips+=1\\n            \\n            a=a>>1\\n            b=b>>1\\n            c=c>>1\\n        return flips\\n\\nCan someone explain me why it fails for few test cases? Whats the edge case?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The logic is not quite right. If bitA=bitB=bitC=0 then no flips are required. Similarly, if bitC=1 then one flip is require only if bitA=bitB."
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Surely the question is framed by an Intern. Very crisp and strange question language."
                    },
                    {
                        "username": "ijogendrajat",
                        "content": "need dart language support for this problem."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Simple Solution using dictionary \n\nassume that we have 3 bits, a,b,c and what should be the count of the flips\nabc|flipCount\n000=>0\n001=>1\n010=>1\n011=>0\n100=>1\n101=>0\n110=>2\n111=>0\n\nSo how about create a dictionary/map for these values, and then keep extracting last bits from a,b,c. and combine them, and lookinto map for flip count,\n\nhttps://leetcode.com/problems/minimum-flips-to-make-a-or-b-equal-to-c/solutions/3607503/simple-solution-using-dictionary/"
                    }
                ]
            }
        ]
    },
    {
        "title": "Number of Operations to Make Network Connected",
        "question_content": "<p>There are <code>n</code> computers numbered from <code>0</code> to <code>n - 1</code> connected by ethernet cables <code>connections</code> forming a network where <code>connections[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> represents a connection between computers <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>. Any computer can reach any other computer directly or indirectly through the network.</p>\n\n<p>You are given an initial computer network <code>connections</code>. You can extract certain cables between two directly connected computers, and place them between any pair of disconnected computers to make them directly connected.</p>\n\n<p>Return <em>the minimum number of times you need to do this in order to make all the computers connected</em>. If it is not possible, return <code>-1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/01/02/sample_1_1677.png\" style=\"width: 500px; height: 148px;\" />\n<pre>\n<strong>Input:</strong> n = 4, connections = [[0,1],[0,2],[1,2]]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> Remove cable between computer 1 and 2 and place between computers 1 and 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/01/02/sample_2_1677.png\" style=\"width: 500px; height: 129px;\" />\n<pre>\n<strong>Input:</strong> n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]]\n<strong>Output:</strong> 2\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 6, connections = [[0,1],[0,2],[0,3],[1,2]]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> There are not enough cables.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= connections.length &lt;= min(n * (n - 1) / 2, 10<sup>5</sup>)</code></li>\n\t<li><code>connections[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li>There are no repeated connections.</li>\n\t<li>No two computers are connected by more than one cable.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 717403,
                "title": "c-dfs-number-of-islands-detailed-explanation",
                "content": "Goal: We need to connect all the computers (directly or indirectly). We have to return the minimum number of operations that are required to connect the computers. An operation consists of removing a cable between two directly connected computers and put it between two disconnected computers.\\n\\nThis problem is a simple variation of counting the number of islands. \\n\\nWe know that the minimum number of edges required for a graph with `n` nodes to remain connected is `n - 1`. Similarly, if there are k components in a disconnected graph, then we need at least `k - 1` edges to connect every component.\\n\\nWith that in our mind, we will start with our **base condition**. If the number of edges in the graph is greater than `n - 1` or not. If not, we will `return -1`.\\n\\nNext, we will count the number of components (`k`). As I already mentioned, we will need `k - 1` operations to connect the computers (components). And that is our **answer!** \\n\\nWe can also solve this using Union-Find approach and count the number of components. I solved this problem using DFS and the code is shown below. \\n\\nPlease leave any of  your doubts/comments in the comments section!\\n\\n```\\nclass Solution {\\nprivate:\\n    void dfs(vector<vector<int>> &adj, vector<bool> &visited, int src)\\n    {\\n        visited[src] = true;\\n        for(int i : adj[src])\\n            if(!visited[i])\\n                dfs(adj, visited, i);\\n    }\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        \\n        if(connections.size() < n - 1)\\n            return -1;\\n        vector<vector<int>> adj(n);\\n        for(auto v : connections)\\n        {\\n            adj[v[0]].push_back(v[1]);\\n            adj[v[1]].push_back(v[0]);\\n        }\\n        vector<bool> visited(n, false);\\n        int components = 0;\\n        for(int i=0; i<n; i++)\\n            if(!visited[i])\\n            {\\n                dfs(adj, visited, i);\\n                components++;\\n            }\\n        return components - 1;\\n    }\\n};\\n```\\n\\nIf you liked my explanation, would you be so kind as to upvote my post? It gives me motivation to explain more questions in a detailed manner. Happy coding! :)",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void dfs(vector<vector<int>> &adj, vector<bool> &visited, int src)\\n    {\\n        visited[src] = true;\\n        for(int i : adj[src])\\n            if(!visited[i])\\n                dfs(adj, visited, i);\\n    }\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        \\n        if(connections.size() < n - 1)\\n            return -1;\\n        vector<vector<int>> adj(n);\\n        for(auto v : connections)\\n        {\\n            adj[v[0]].push_back(v[1]);\\n            adj[v[1]].push_back(v[0]);\\n        }\\n        vector<bool> visited(n, false);\\n        int components = 0;\\n        for(int i=0; i<n; i++)\\n            if(!visited[i])\\n            {\\n                dfs(adj, visited, i);\\n                components++;\\n            }\\n        return components - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477679,
                "title": "python-count-the-connected-networks",
                "content": "## **Explanation**\\nWe need at least `n - 1` cables to connect all nodes (like a tree).\\nIf `connections.size() < n - 1`, we can directly return `-1`.\\n\\nOne trick is that, if we have enough cables,\\nwe don\\'t need to worry about where we can get the cable from.\\n\\nWe only need to count the number of connected networks.\\nTo connect two unconneccted networks, we need to set one cable.\\n\\nThe number of operations we need = the number of **connected networks** - 1\\n<br>\\n\\n## **Complexity**\\nTime `O(connections)`\\nSpace `O(n)`\\n<br>\\n\\n**Python:**\\n```python\\n    def makeConnected(self, n, connections):\\n        if len(connections) < n - 1: return -1\\n        G = [set() for i in xrange(n)]\\n        for i, j in connections:\\n            G[i].add(j)\\n            G[j].add(i)\\n        seen = [0] * n\\n\\n        def dfs(i):\\n            if seen[i]: return 0\\n            seen[i] = 1\\n            for j in G[i]: dfs(j)\\n            return 1\\n\\n        return sum(dfs(i) for i in xrange(n)) - 1\\n```\\n",
                "solutionTags": [],
                "code": "```python\\n    def makeConnected(self, n, connections):\\n        if len(connections) < n - 1: return -1\\n        G = [set() for i in xrange(n)]\\n        for i, j in connections:\\n            G[i].add(j)\\n            G[j].add(i)\\n        seen = [0] * n\\n\\n        def dfs(i):\\n            if seen[i]: return 0\\n            seen[i] = 1\\n            for j in G[i]: dfs(j)\\n            return 1\\n\\n        return sum(dfs(i) for i in xrange(n)) - 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 477660,
                "title": "java-count-number-of-connected-components-clean-code",
                "content": "**\\u2714\\uFE0F Solution 1a: Naive Union-Find ~ 23ms**\\n```java\\nclass Solution {\\n    public int makeConnected(int n, int[][] connections) {\\n        if (connections.length < n - 1) return -1; // To connect all nodes need at least n-1 edges\\n        int[] parent = new int[n];\\n        for (int i = 0; i < n; i++) parent[i] = i;\\n        int components = n;\\n        for (int[] c : connections) {\\n            int p1 = findParent(parent, c[0]);\\n            int p2 = findParent(parent, c[1]);\\n            if (p1 != p2) {\\n                parent[p1] = p2; // Union 2 component\\n                components--;\\n            }\\n        }\\n        return components - 1; // Need (components-1) cables to connect components together\\n    }\\n    private int findParent(int[] parent, int i) {\\n        while (i != parent[i]) i = parent[i];\\n        return i; // Without Path Compression\\n    }\\n}\\n```\\nComplexity:\\n- Time: `O(n*m)`, `m` is the length of connections. Can cause **TLE** with this testcase:  https://ideone.com/ZQHtLm\\n- Space: `O(n)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 1b: Union-Find with Path Compression ~ 3ms**\\n```java\\nclass Solution {\\n    public int makeConnected(int n, int[][] connections) {\\n        if (connections.length < n - 1) return -1; // To connect all nodes need at least n-1 edges\\n        int[] parent = new int[n];\\n        for (int i = 0; i < n; i++) parent[i] = i;\\n        int components = n;\\n        for (int[] c : connections) {\\n            int p1 = findParent(parent, c[0]);\\n            int p2 = findParent(parent, c[1]);\\n            if (p1 != p2) {\\n                parent[p1] = p2; // Union 2 component\\n                components--;\\n            }\\n        }\\n        return components - 1; // Need (components-1) cables to connect components together\\n    }\\n    private int findParent(int[] parent, int i) {\\n        if (i == parent[i]) return i;\\n        return parent[i] = findParent(parent, parent[i]); // Path compression\\n    }\\n}\\n```\\nComplexity:\\n- Time: `O(n+mlogn)`, `m` is the length of connections\\n- Space: `O(n)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 1c: Union-Find with Path Compression and Union by Size ~ 3ms**\\n```java\\nclass Solution {\\n    public int makeConnected(int n, int[][] connections) {\\n        if (connections.length < n - 1) return -1; // To connect all nodes need at least n-1 edges\\n        int[] parent = new int[n];\\n        int[] size = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n        int components = n;\\n        for (int[] c : connections) {\\n            int p1 = findParent(parent, c[0]);\\n            int p2 = findParent(parent, c[1]);\\n            if (p1 != p2) {\\n                if (size[p1] < size[p2]) { // Merge small size to large size\\n                    size[p2] += size[p1];\\n                    parent[p1] = p2;\\n                } else {\\n                    size[p1] += size[p2];\\n                    parent[p2] = p1;\\n                }\\n                components--;\\n            }\\n        }\\n        return components - 1; // Need (components-1) cables to connect components together\\n    }\\n    private int findParent(int[] parent, int i) {\\n        if (i == parent[i]) return i;\\n        return parent[i] = findParent(parent, parent[i]); // Path compression\\n    }\\n}\\n```\\nComplexity:\\n- Time: `O(n + m*\\u03B1(n))` \\u2248 `O(n + m)`, `m` is the length of connections (union operations). \\n   Explanation: Using both **path compression** and **union by size** ensures that the **amortized time** per operation is only `\\u03B1(n)`, which is optimal, where `\\u03B1(n)` is the inverse Ackermann function. This function has a value `\\u03B1(n) < 5` for any value of n that can be written in this physical universe, so the disjoint-set operations take place in essentially constant time.\\nReference: https://en.wikipedia.org/wiki/Disjoint-set_data_structure or https://www.slideshare.net/WeiLi73/time-complexity-of-union-find-55858534 for more information.\\n- Space: `O(n)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: DFS ~ 11ms**\\n```java\\nclass Solution {\\n    public int makeConnected(int n, int[][] connections) {\\n        if (connections.length < n - 1) return -1; // To connect all nodes need at least n-1 edges\\n        List<Integer>[] graph = new List[n];\\n        for (int i = 0; i < n; i++) graph[i] = new ArrayList<>();\\n        for (int[] c : connections) {\\n            graph[c[0]].add(c[1]);\\n            graph[c[1]].add(c[0]);\\n        }\\n        int components = 0;\\n        boolean[] visited = new boolean[n];\\n        for (int v = 0; v < n; v++) components += dfs(v, graph, visited);\\n        return components - 1; // Need (components-1) cables to connect components together\\n    }\\n    int dfs(int u, List<Integer>[] graph, boolean[] visited) {\\n        if (visited[u]) return 0;\\n        visited[u] = true;\\n        for (int v : graph[u]) dfs(v, graph, visited);\\n        return 1;\\n    }\\n}\\n```\\nComplexity:\\n- Time: `O(n+m)`, `m` is the length of connections\\n- Space: `O(n)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 3: BFS ~ 12ms**\\n```java\\nclass Solution {\\n    public int makeConnected(int n, int[][] connections) {\\n        if (connections.length < n - 1) return -1; // To connect all nodes need at least n-1 edges\\n        List<Integer>[] graph = new List[n];\\n        for (int i = 0; i < n; i++) graph[i] = new ArrayList<>();\\n        for (int[] c : connections) {\\n            graph[c[0]].add(c[1]);\\n            graph[c[1]].add(c[0]);\\n        }\\n        int components = 0;\\n        boolean[] visited = new boolean[n];\\n        for (int v = 0; v < n; v++) components += bfs(v, graph, visited);\\n        return components - 1; // Need (components-1) cables to connect components together\\n    }\\n    int bfs(int src, List<Integer>[] graph, boolean[] visited) {\\n        if (visited[src]) return 0;\\n        visited[src] = true;\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(src);\\n        while (!q.isEmpty()) {\\n            int u = q.poll();\\n            for (int v : graph[u]) {\\n                if (!visited[v]) {\\n                    visited[v] = true;\\n                    q.offer(v);\\n                }\\n            }\\n        }\\n        return 1;\\n    }\\n}\\n```\\nComplexity:\\n- Time: `O(n+m)`, `m` is the length of connections\\n- Space: `O(n)`",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int makeConnected(int n, int[][] connections) {\\n        if (connections.length < n - 1) return -1; // To connect all nodes need at least n-1 edges\\n        int[] parent = new int[n];\\n        for (int i = 0; i < n; i++) parent[i] = i;\\n        int components = n;\\n        for (int[] c : connections) {\\n            int p1 = findParent(parent, c[0]);\\n            int p2 = findParent(parent, c[1]);\\n            if (p1 != p2) {\\n                parent[p1] = p2; // Union 2 component\\n                components--;\\n            }\\n        }\\n        return components - 1; // Need (components-1) cables to connect components together\\n    }\\n    private int findParent(int[] parent, int i) {\\n        while (i != parent[i]) i = parent[i];\\n        return i; // Without Path Compression\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int makeConnected(int n, int[][] connections) {\\n        if (connections.length < n - 1) return -1; // To connect all nodes need at least n-1 edges\\n        int[] parent = new int[n];\\n        for (int i = 0; i < n; i++) parent[i] = i;\\n        int components = n;\\n        for (int[] c : connections) {\\n            int p1 = findParent(parent, c[0]);\\n            int p2 = findParent(parent, c[1]);\\n            if (p1 != p2) {\\n                parent[p1] = p2; // Union 2 component\\n                components--;\\n            }\\n        }\\n        return components - 1; // Need (components-1) cables to connect components together\\n    }\\n    private int findParent(int[] parent, int i) {\\n        if (i == parent[i]) return i;\\n        return parent[i] = findParent(parent, parent[i]); // Path compression\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int makeConnected(int n, int[][] connections) {\\n        if (connections.length < n - 1) return -1; // To connect all nodes need at least n-1 edges\\n        int[] parent = new int[n];\\n        int[] size = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n        int components = n;\\n        for (int[] c : connections) {\\n            int p1 = findParent(parent, c[0]);\\n            int p2 = findParent(parent, c[1]);\\n            if (p1 != p2) {\\n                if (size[p1] < size[p2]) { // Merge small size to large size\\n                    size[p2] += size[p1];\\n                    parent[p1] = p2;\\n                } else {\\n                    size[p1] += size[p2];\\n                    parent[p2] = p1;\\n                }\\n                components--;\\n            }\\n        }\\n        return components - 1; // Need (components-1) cables to connect components together\\n    }\\n    private int findParent(int[] parent, int i) {\\n        if (i == parent[i]) return i;\\n        return parent[i] = findParent(parent, parent[i]); // Path compression\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int makeConnected(int n, int[][] connections) {\\n        if (connections.length < n - 1) return -1; // To connect all nodes need at least n-1 edges\\n        List<Integer>[] graph = new List[n];\\n        for (int i = 0; i < n; i++) graph[i] = new ArrayList<>();\\n        for (int[] c : connections) {\\n            graph[c[0]].add(c[1]);\\n            graph[c[1]].add(c[0]);\\n        }\\n        int components = 0;\\n        boolean[] visited = new boolean[n];\\n        for (int v = 0; v < n; v++) components += dfs(v, graph, visited);\\n        return components - 1; // Need (components-1) cables to connect components together\\n    }\\n    int dfs(int u, List<Integer>[] graph, boolean[] visited) {\\n        if (visited[u]) return 0;\\n        visited[u] = true;\\n        for (int v : graph[u]) dfs(v, graph, visited);\\n        return 1;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int makeConnected(int n, int[][] connections) {\\n        if (connections.length < n - 1) return -1; // To connect all nodes need at least n-1 edges\\n        List<Integer>[] graph = new List[n];\\n        for (int i = 0; i < n; i++) graph[i] = new ArrayList<>();\\n        for (int[] c : connections) {\\n            graph[c[0]].add(c[1]);\\n            graph[c[1]].add(c[0]);\\n        }\\n        int components = 0;\\n        boolean[] visited = new boolean[n];\\n        for (int v = 0; v < n; v++) components += bfs(v, graph, visited);\\n        return components - 1; // Need (components-1) cables to connect components together\\n    }\\n    int bfs(int src, List<Integer>[] graph, boolean[] visited) {\\n        if (visited[src]) return 0;\\n        visited[src] = true;\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(src);\\n        while (!q.isEmpty()) {\\n            int u = q.poll();\\n            for (int v : graph[u]) {\\n                if (!visited[v]) {\\n                    visited[v] = true;\\n                    q.offer(v);\\n                }\\n            }\\n        }\\n        return 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477677,
                "title": "java-union-find-count-components-and-extra-edges",
                "content": "```\\nclass Solution {\\n    public static int findParent(int[] par, int i) {\\n        if(par[i] == i) return i;\\n        return par[i] = findParent(par, par[i]);\\n    }\\n    public int makeConnected(int n, int[][] connections) {\\n        int[] parent = new int[n];\\n        for(int i = 0; i < n; i++) parent[i] = i;\\n        int m = connections.length;\\n        int components = 0;\\n        int extraEdge = 0;\\n        for(int i = 0; i < m; i++) {\\n            int p1 = findParent(parent, connections[i][0]);\\n            int p2 = findParent(parent, connections[i][1]);\\n            if(p1 == p2) extraEdge++;\\n            else parent[p1] = p2;\\n        }\\n        for(int i = 0; i < n; i++) if(parent[i] == i) components++;\\n        return (extraEdge >= components - 1) ? components - 1 : -1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public static int findParent(int[] par, int i) {\\n        if(par[i] == i) return i;\\n        return par[i] = findParent(par, par[i]);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3330357,
                "title": "c-easy-solution-dfs",
                "content": "Har Har Mahadev\\u2764\\uFE0F\\uD83D\\uDD49\\uFE0F\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCheck number of wire we have if number of wire is less than connections than it\\'s not possible to connect all devices\\n\\nCheck number of components , after counting number of components we can return ans-1 (Because we can connect n devices with n-1 wire)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCollect data in adjacency list and after that run DFS don\\'t forget to maintain a visited array to not visit one node again and again\\n\\nStart from \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(V+E), where V is the number of vertices and E is the number of edges in the graph.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n The space complexity of the DFS algorithm is O(V).\\nAnd we are making adjacency list is O(V+E)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    void dfs(vector<int> adj[], vector<bool> &visited, int src)\\n    {\\n        visited[src] = true;\\n        for(int i : adj[src]){\\n            if(!visited[i]){\\n                dfs(adj, visited, i);\\n            }\\n        }\\n    }\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& arr) {\\n        int len = arr.size();\\n        if(len<n-1) return -1;\\n         vector<int> adj[n];\\n        for(auto v : arr)\\n        {\\n            adj[v[0]].push_back(v[1]);\\n            adj[v[1]].push_back(v[0]);\\n        }\\n        vector<bool> visited(n, false);\\n        int ans = 0;\\n        for(int i=0; i<n; i++)\\n        if(!visited[i])\\n        {\\n            dfs(adj, visited, i);\\n            ans++;\\n        }\\n        return ans - 1;\\n    }\\n};\\n\\n\\n\\n\\n```\\nI hope you guys understand the solution , if there is any confusion or any improvements in the solution please inform me.\\n\\nJai Shree Ram \\uD83D\\uDEA9\\uD83D\\uDE4F.\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(vector<int> adj[], vector<bool> &visited, int src)\\n    {\\n        visited[src] = true;\\n        for(int i : adj[src]){\\n            if(!visited[i]){\\n                dfs(adj, visited, i);\\n            }\\n        }\\n    }\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& arr) {\\n        int len = arr.size();\\n        if(len<n-1) return -1;\\n         vector<int> adj[n];\\n        for(auto v : arr)\\n        {\\n            adj[v[0]].push_back(v[1]);\\n            adj[v[1]].push_back(v[0]);\\n        }\\n        vector<bool> visited(n, false);\\n        int ans = 0;\\n        for(int i=0; i<n; i++)\\n        if(!visited[i])\\n        {\\n            dfs(adj, visited, i);\\n            ans++;\\n        }\\n        return ans - 1;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477835,
                "title": "6-lines-clean-unicode-find",
                "content": "```\\ndef makeConnected(self, n, connections):\\n    if len(connections) < n - 1:\\n        return -1\\n    s = \\'\\'.join(map(chr, range(n)))\\n    for a, b in connections:\\n        s = s.replace(s[a], s[b])\\n    return len(set(s)) - 1\\n```\\nPython 3, accepted in 940 ms. Union-Find but with a silly data structure: A string `s` where `s[i]` tells me the current component of computer `i`. As a unicode character. Initially the components (i.e., characters) are all different, but then I join components by turning members of component `s[a]` into members of component `s[b]`.\\n\\n(I had written a faster solution first, but then I saw that basically the same had already been posted by @lee215)",
                "solutionTags": [],
                "code": "```\\ndef makeConnected(self, n, connections):\\n    if len(connections) < n - 1:\\n        return -1\\n    s = \\'\\'.join(map(chr, range(n)))\\n    for a, b in connections:\\n        s = s.replace(s[a], s[b])\\n    return len(set(s)) - 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 618686,
                "title": "c-union-find-connected-components",
                "content": "```\\nclass Solution {\\n    vector<int>parent;\\n    int find(int x) {\\n        return (parent[x] == x) ? x : find(parent[x]);\\n    }\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        \\n        int c = connections.size();\\n        if (n-1 > c) return -1;\\n        \\n        parent.resize(n);\\n        for (int i = 0; i < n; i++)\\n            parent[i] = i;\\n        \\n        for (int i = 0; i < c; i++) {\\n            int x = find(connections[i][0]);\\n            int y = find(connections[i][1]);\\n            if (x != y) parent[y] = x;\\n        }\\n        \\n        int ans = 0;\\n        for (int i = 0; i < n; i++)\\n            if (parent[i] == i)\\n                ans++;\\n        \\n        return ans-1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<int>parent;\\n    int find(int x) {\\n        return (parent[x] == x) ? x : find(parent[x]);\\n    }\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        \\n        int c = connections.size();\\n        if (n-1 > c) return -1;\\n        \\n        parent.resize(n);\\n        for (int i = 0; i < n; i++)\\n            parent[i] = i;\\n        \\n        for (int i = 0; i < c; i++) {\\n            int x = find(connections[i][0]);\\n            int y = find(connections[i][1]);\\n            if (x != y) parent[y] = x;\\n        }\\n        \\n        int ans = 0;\\n        for (int i = 0; i < n; i++)\\n            if (parent[i] == i)\\n                ans++;\\n        \\n        return ans-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3330446,
                "title": "image-explanation-easiest-dfs-c-java-python",
                "content": "# Video Solution\\n`Number of Operations to Make Network Connected by Aryan Mittal`\\n![amazon4.png](https://assets.leetcode.com/users/images/aab14c28-39f6-4861-9bc5-bcfb63e395cb_1679539145.628633.png)\\n\\n\\n# Approach & Intuition\\n![image.png](https://assets.leetcode.com/users/images/c23955a7-f24c-4973-ba46-a6aa86e11158_1679534811.488079.png)\\n![image.png](https://assets.leetcode.com/users/images/7c7503b9-55d8-4536-a03d-9e578748a8f3_1679534861.280428.png)\\n![image.png](https://assets.leetcode.com/users/images/b6e7ea4d-7db6-402c-ab24-824d068c3f8b_1679534876.419747.png)\\n![image.png](https://assets.leetcode.com/users/images/a37283db-05c2-4b24-bfe9-d19998fbbc7b_1679534911.6596534.png)\\n![image.png](https://assets.leetcode.com/users/images/7f6fdd0a-3e70-4f57-8aaa-57a2da392761_1679534936.9420202.png)\\nAlthough the same problem of finding number of component can be solved by `BFS`, `DFS` & also with help of `Union Find` but DFS is the most easiest and intuitive way.\\n![image.png](https://assets.leetcode.com/users/images/6322fadc-c5f6-4438-80d9-b39d6a3ec9d7_1679536214.2747602.png)\\n![image.png](https://assets.leetcode.com/users/images/77e241ff-a1ef-4604-9aa6-07da8cbf97e0_1679536048.559381.png)\\n![image.png](https://assets.leetcode.com/users/images/710ed5d2-9162-4184-8257-138ec74c2fc5_1679536073.5923595.png)\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &adj, vector<bool> &visited, int src){\\n        visited[src] = true;\\n        for(int i : adj[src])\\n            if(!visited[i])\\n                dfs(adj, visited, i);\\n    }\\n\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        if(connections.size() < n - 1) return -1;\\n        vector<vector<int>> adj(n);\\n        for(auto c : connections){\\n            adj[c[0]].push_back(c[1]);\\n            adj[c[1]].push_back(c[0]);\\n        }\\n\\n        vector<bool> visited(n, false);\\n        int components = 0;\\n        for(int i=0; i<n; i++)\\n            if(!visited[i]){\\n                dfs(adj, visited, i);\\n                components++;\\n            }\\n        return components - 1;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    int dfs(int u, List<Integer>[] graph, boolean[] visited) {\\n        if (visited[u]) return 0;\\n        visited[u] = true;\\n        for (int v : graph[u]) dfs(v, graph, visited);\\n        return 1;\\n    }\\n\\n    public int makeConnected(int n, int[][] connections) {\\n        if (connections.length < n - 1) return -1;\\n        List<Integer>[] graph = new List[n];\\n        for (int i = 0; i < n; i++) graph[i] = new ArrayList<>();\\n        for (int[] c : connections) {\\n            graph[c[0]].add(c[1]);\\n            graph[c[1]].add(c[0]);\\n        }\\n        \\n        int components = 0;\\n        boolean[] visited = new boolean[n];\\n        for (int v = 0; v < n; v++) components += dfs(v, graph, visited);\\n        return components - 1;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        if len(connections) < n - 1: return -1\\n        \\n        graph = [set() for i in range(n)]\\n        for u, v in connections:\\n            graph[u].add(v)\\n            graph[v].add(u)\\n        visited = [0] * n\\n\\n        def dfs(node):\\n            if visited[node]: return 0\\n            visited[node] = 1\\n            for neighbor in graph[node]: dfs(neighbor)\\n            return 1\\n\\n        return sum(dfs(node) for node in range(n)) - 1\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &adj, vector<bool> &visited, int src){\\n        visited[src] = true;\\n        for(int i : adj[src])\\n            if(!visited[i])\\n                dfs(adj, visited, i);\\n    }\\n\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        if(connections.size() < n - 1) return -1;\\n        vector<vector<int>> adj(n);\\n        for(auto c : connections){\\n            adj[c[0]].push_back(c[1]);\\n            adj[c[1]].push_back(c[0]);\\n        }\\n\\n        vector<bool> visited(n, false);\\n        int components = 0;\\n        for(int i=0; i<n; i++)\\n            if(!visited[i]){\\n                dfs(adj, visited, i);\\n                components++;\\n            }\\n        return components - 1;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    int dfs(int u, List<Integer>[] graph, boolean[] visited) {\\n        if (visited[u]) return 0;\\n        visited[u] = true;\\n        for (int v : graph[u]) dfs(v, graph, visited);\\n        return 1;\\n    }\\n\\n    public int makeConnected(int n, int[][] connections) {\\n        if (connections.length < n - 1) return -1;\\n        List<Integer>[] graph = new List[n];\\n        for (int i = 0; i < n; i++) graph[i] = new ArrayList<>();\\n        for (int[] c : connections) {\\n            graph[c[0]].add(c[1]);\\n            graph[c[1]].add(c[0]);\\n        }\\n        \\n        int components = 0;\\n        boolean[] visited = new boolean[n];\\n        for (int v = 0; v < n; v++) components += dfs(v, graph, visited);\\n        return components - 1;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        if len(connections) < n - 1: return -1\\n        \\n        graph = [set() for i in range(n)]\\n        for u, v in connections:\\n            graph[u].add(v)\\n            graph[v].add(u)\\n        visited = [0] * n\\n\\n        def dfs(node):\\n            if visited[node]: return 0\\n            visited[node] = 1\\n            for neighbor in graph[node]: dfs(neighbor)\\n            return 1\\n\\n        return sum(dfs(node) for node in range(n)) - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240564,
                "title": "clean-dfs-python",
                "content": "**We have to find no. of connected components in a undirected graph**\\n```\\nimport collections\\nclass Solution:\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        if len(connections)<n-1: # this is a edge condi. to connect n components we need min n-1 cables. \\n            return -1\\n        \\n        \\n        d=collections.defaultdict(list) # converting given list to adjacency list as it will help us to run dfs function.\\n        for i ,j in connections:\\n            d[i].append(j)\\n            d[j].append(i)\\n        \\n        \\n        visited=set()    # this will track the visited vertex\\n        numofconnected=0 # this will track the no. of separate  components\\n        \\n        \\n        def dfs(root):\\n            visited.add(root)\\n            for j in d[root]:# traversing each neighbour vertex of root and visit them in one go and add them to visited\\n                if j not in visited:\\n                    dfs(j)\\n        \\n        \\n        for i in range(n): # running loop to track how many vertex we can visit through i \\n            if i not in visited:\\n                numofconnected+=1# as this is not visited so this will be the start of a new separate component .\\n                dfs(i)\\n        return numofconnected-1 # to connect n separate components we require min n-1 cables .\\n        \\n```\\n![image](https://assets.leetcode.com/users/images/6f011696-9d14-43cb-9ea4-4d4ab3d74369_1622366404.3161256.png)\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nimport collections\\nclass Solution:\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        if len(connections)<n-1: # this is a edge condi. to connect n components we need min n-1 cables. \\n            return -1\\n        \\n        \\n        d=collections.defaultdict(list) # converting given list to adjacency list as it will help us to run dfs function.\\n        for i ,j in connections:\\n            d[i].append(j)\\n            d[j].append(i)\\n        \\n        \\n        visited=set()    # this will track the visited vertex\\n        numofconnected=0 # this will track the no. of separate  components\\n        \\n        \\n        def dfs(root):\\n            visited.add(root)\\n            for j in d[root]:# traversing each neighbour vertex of root and visit them in one go and add them to visited\\n                if j not in visited:\\n                    dfs(j)\\n        \\n        \\n        for i in range(n): # running loop to track how many vertex we can visit through i \\n            if i not in visited:\\n                numofconnected+=1# as this is not visited so this will be the start of a new separate component .\\n                dfs(i)\\n        return numofconnected-1 # to connect n separate components we require min n-1 cables .\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 477664,
                "title": "java-python-3-union-find-w-brief-explanation-and-analysis",
                "content": "1. Perform union find during the traversal of the `connections`; deduct the number of components when merging any two components;\\n2. If there are less than n - 1 connections, no way to make the network connected; Otherwise need `number of components - 1` operations for the network to be fully connected.\\n\\n```java\\n    private int[] root; // components roots.\\n    private int count; // # of components. \\n    public int makeConnected(int n, int[][] connections) {\\n        count = n; // # of nodes.\\n        root = IntStream.range(0, n).toArray(); // Initialization of the roots of the nodes to themselves.\\n        for (int[] c : connections) { \\n            union(c[0], c[1]); //  if the 2 connected nodes are NOT in the same component yet, merge their components. \\n        } \\n        return connections.length < n - 1 ? -1 : count - 1;\\n    }\\n    private int find(int x) {\\n        while (x != root[x]) \\n            x = root[x];\\n        return x;\\n    }\\n    private void union(int x, int y) {\\n        int rx = find(x), ry = find(y);\\n        if (rx == ry) \\n            return;\\n        root[rx] = ry; \\n        --count;\\n    }\\n```\\n```python\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        self.id, self.count = list(range(n)), n\\n        \\n        def union(x: int, y: int) -> None:\\n            \\n            def find(x: int) -> int:\\n                while x != self.id[x]:\\n                    x = self.id[x]\\n                return x   \\n\\n            rx, ry = find(x), find(y)\\n            if rx == ry:\\n                return\\n            self.id[rx] = ry\\n            self.count -= 1\\n        \\n        for c1, c2 in connections:\\n            union(c1, c2)\\n        return -1 if len(connections) < n - 1 else self.count - 1\\n```\\n\\n----\\nWeighted Quick Union w/ Path Compression.\\n```java\\n    private int[] root, size; // components roots and sizes.\\n    private int count; // # of components.\\n    public int makeConnected(int n, int[][] connections) {\\n        count = n; // # of nodes.\\n        root = IntStream.range(0, n).toArray(); // Initialization of the roots of the nodes to themselves.\\n        size = IntStream.range(0, n). map(i -> 1).toArray(); // Initialize the size of the component to 1 for each node.\\n        for (int[] c : connections) {\\n            union(c[0], c[1]); // merge the nodes if they are in same component.\\n        }\\n        return connections.length < n - 1 ? -1 : count - 1; \\n    }\\n    private int find(int x) {\\n        while (x != root[x]) {\\n            root[x] = root[root[x]]; // path compression.\\n            x = root[x];\\n        }\\n        return x;\\n    }\\n    private void union(int x, int y) {\\n        int rx = find(x), ry = find(y);\\n        if (rx == ry) return;\\n\\t\\t// merge to larger components.\\n        if (size[rx] > size[ry]) { \\n            size[rx] += size[ry]; \\n            root[ry] = rx; \\n        }else {\\n            size[ry] += size[rx]; \\n            root[rx] = ry;\\n        } \\n        --count;\\n    }\\n```\\n```python\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        self.id, self.size, self.count = list(range(n)), [1] * n, n\\n        \\n        def union(x: int, y: int) -> None:\\n            \\n            def find(x: int) -> int:\\n                while x != self.id[x]:\\n                    self.id[x] = self.id[self.id[x]]\\n                    x = self.id[x]\\n                return x   \\n\\n            rx, ry = find(x), find(y)\\n            if rx == ry:\\n                return\\n            if self.size[rx] > self.size[ry]:\\n                self.size[rx] += self.size[ry]\\n                self.id[ry] = rx\\n            else:\\n                self.size[ry] += self.size[rx]\\n                self.id[rx] = ry\\n            self.count -= 1\\n        \\n        for c1, c2 in connections:\\n            union(c1, c2)\\n        return -1 if len(connections) < n - 1 else self.count - 1\\n```\\n**Analysis:**\\n\\nTime: O(n), space: O(n).",
                "solutionTags": [],
                "code": "```java\\n    private int[] root; // components roots.\\n    private int count; // # of components. \\n    public int makeConnected(int n, int[][] connections) {\\n        count = n; // # of nodes.\\n        root = IntStream.range(0, n).toArray(); // Initialization of the roots of the nodes to themselves.\\n        for (int[] c : connections) { \\n            union(c[0], c[1]); //  if the 2 connected nodes are NOT in the same component yet, merge their components. \\n        } \\n        return connections.length < n - 1 ? -1 : count - 1;\\n    }\\n    private int find(int x) {\\n        while (x != root[x]) \\n            x = root[x];\\n        return x;\\n    }\\n    private void union(int x, int y) {\\n        int rx = find(x), ry = find(y);\\n        if (rx == ry) \\n            return;\\n        root[rx] = ry; \\n        --count;\\n    }\\n```\n```python\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        self.id, self.count = list(range(n)), n\\n        \\n        def union(x: int, y: int) -> None:\\n            \\n            def find(x: int) -> int:\\n                while x != self.id[x]:\\n                    x = self.id[x]\\n                return x   \\n\\n            rx, ry = find(x), find(y)\\n            if rx == ry:\\n                return\\n            self.id[rx] = ry\\n            self.count -= 1\\n        \\n        for c1, c2 in connections:\\n            union(c1, c2)\\n        return -1 if len(connections) < n - 1 else self.count - 1\\n```\n```java\\n    private int[] root, size; // components roots and sizes.\\n    private int count; // # of components.\\n    public int makeConnected(int n, int[][] connections) {\\n        count = n; // # of nodes.\\n        root = IntStream.range(0, n).toArray(); // Initialization of the roots of the nodes to themselves.\\n        size = IntStream.range(0, n). map(i -> 1).toArray(); // Initialize the size of the component to 1 for each node.\\n        for (int[] c : connections) {\\n            union(c[0], c[1]); // merge the nodes if they are in same component.\\n        }\\n        return connections.length < n - 1 ? -1 : count - 1; \\n    }\\n    private int find(int x) {\\n        while (x != root[x]) {\\n            root[x] = root[root[x]]; // path compression.\\n            x = root[x];\\n        }\\n        return x;\\n    }\\n    private void union(int x, int y) {\\n        int rx = find(x), ry = find(y);\\n        if (rx == ry) return;\\n\\t\\t// merge to larger components.\\n        if (size[rx] > size[ry]) { \\n            size[rx] += size[ry]; \\n            root[ry] = rx; \\n        }else {\\n            size[ry] += size[rx]; \\n            root[rx] = ry;\\n        } \\n        --count;\\n    }\\n```\n```python\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        self.id, self.size, self.count = list(range(n)), [1] * n, n\\n        \\n        def union(x: int, y: int) -> None:\\n            \\n            def find(x: int) -> int:\\n                while x != self.id[x]:\\n                    self.id[x] = self.id[self.id[x]]\\n                    x = self.id[x]\\n                return x   \\n\\n            rx, ry = find(x), find(y)\\n            if rx == ry:\\n                return\\n            if self.size[rx] > self.size[ry]:\\n                self.size[rx] += self.size[ry]\\n                self.id[ry] = rx\\n            else:\\n                self.size[ry] += self.size[rx]\\n                self.id[rx] = ry\\n            self.count -= 1\\n        \\n        for c1, c2 in connections:\\n            union(c1, c2)\\n        return -1 if len(connections) < n - 1 else self.count - 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3331562,
                "title": "from-75-to-100-union-find-with-images-java-c",
                "content": "# Intuition\\nFeels like grouping of networks right?\\nHow can we group some objects based on connections?\\nWell, the answer is to use the union find method. All the nodes that are connected, will be part of a group.\\n\\nFor example 1:\\n```\\nInput: n = 4, connections = [[0,1],[0,2],[1,2]]\\n\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/f446870e-e6f0-4408-a263-2884ace49ba9_1679561017.4923828.png)\\n\\n\\nFor example 3:\\n```\\nInput: n = 6, connections = [[0,1],[0,2],[0,3],[1,2]]\\n\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/26d9d9c3-1783-4529-8d38-81e7593e9187_1679561314.1289692.png)\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUnion Find with ranks.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N+E)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# 75% Efficient:\\n\\n``` Java []\\nclass Solution {\\n    int[] parent;\\n    int[] rank;\\n    int find(int x){\\n        while(parent[x]!=x){\\n            x = parent[parent[x]];\\n        }\\n        return x;\\n    }\\n    void makeUnion(int x, int y){\\n        int parX = find(x);\\n        int parY = find(y);\\n        if(parX == parY){\\n            return;\\n        }\\n        else if(rank[parX]<rank[parY]){\\n            parent[parX] = parY;\\n        }\\n        else if(rank[parX]>rank[parY]){\\n            parent[parY] = parX;\\n        }\\n        else{\\n            parent[parY] = parX;\\n            rank[parX]++;\\n        }\\n    }\\n    public int makeConnected(int n, int[][] connections) {\\n        int edges = connections.length;\\n        if(edges<n-1){\\n            return -1;\\n        }\\n        parent = new int[n];\\n        rank = new int[n];\\n        for(int i=0; i<n; i++){\\n            parent[i] = i;\\n        }\\n        for(int[] con : connections){\\n            makeUnion(con[0], con[1]);\\n        }\\n        Set<Integer> set = new HashSet<>();\\n        for(int i=0; i<n; i++){\\n            int par = find(i);\\n            set.add(par);\\n        }\\n        int unions = set.size();\\n        return unions-1;\\n    }\\n}\\n\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int find(int x, int parent[]){\\n        while(parent[x]!=x){\\n            x = parent[parent[x]];\\n        }\\n        return x;\\n    }\\n\\n    void makeUnion(int x, int y, int parent[], int rank[]){\\n        int parX = find(x, parent);\\n        int parY = find(y, parent);\\n        if(parX == parY){\\n            return;\\n        }\\n        else if(rank[parX]<rank[parY]){\\n            parent[parX] = parY;\\n        }\\n        else if(rank[parX]>rank[parY]){\\n            parent[parY] = parX;\\n        }\\n        else{\\n            parent[parY] = parX;\\n            rank[parX]++;\\n        }\\n    }\\n\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        int edges = connections.size();\\n        if(edges<n-1){\\n            return -1;\\n        }\\n        int parent[n];\\n        int rank[n];\\n        for(int i=0; i<n; i++){\\n            parent[i] = i;\\n        }\\n        for(auto con : connections){\\n            makeUnion(con[0], con[1], parent, rank);\\n        }\\n        set<int> groups;\\n        for(int i=0; i<n; i++){\\n            int par = find(i, parent);\\n            groups.insert(par);\\n        }\\n        int unions = groups.size();\\n        return unions-1;\\n    }\\n};\\n```\\n\\n# 100% Efficient:\\n\\n\\n``` Java []\\nclass Solution {\\n    int[] parent;\\n    int[] rank;\\n    int find(int x){\\n        while(parent[x]!=x){\\n            x = parent[parent[x]];\\n        }\\n        return x;\\n    }\\n    int makeUnion(int x, int y){\\n        int parX = find(x);\\n        int parY = find(y);\\n        if(parX == parY){\\n            return 0;\\n        }\\n        else if(rank[parX]<rank[parY]){\\n            parent[parX] = parY;\\n        }\\n        else if(rank[parX]>rank[parY]){\\n            parent[parY] = parX;\\n        }\\n        else{\\n            parent[parY] = parX;\\n            rank[parX]++;\\n        }\\n        return 1;\\n    }\\n    public int makeConnected(int n, int[][] connections) {\\n        int edges = connections.length;\\n        if(edges<n-1){\\n            return -1;\\n        }\\n        parent = new int[n];\\n        rank = new int[n];\\n        for(int i=0; i<n; i++){\\n            parent[i] = i;\\n        }\\n        int components = n;\\n        for(int[] con : connections){\\n            components -= makeUnion(con[0], con[1]);\\n        }\\n        return components-1;\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int find(int x, int parent[]){\\n        while(parent[x]!=x){\\n            x = parent[parent[x]];\\n        }\\n        return x;\\n    }\\n\\n    int makeUnion(int x, int y, int parent[], int rank[]){\\n        int parX = find(x, parent);\\n        int parY = find(y, parent);\\n        if(parX == parY){\\n            return 0;\\n        }\\n        else if(rank[parX]<rank[parY]){\\n            parent[parX] = parY;\\n        }\\n        else if(rank[parX]>rank[parY]){\\n            parent[parY] = parX;\\n        }\\n        else{\\n            parent[parY] = parX;\\n            rank[parX]++;\\n        }\\n        return 1;\\n    }\\n\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        int edges = connections.size();\\n        if(edges<n-1){\\n            return -1;\\n        }\\n        int parent[n];\\n        int rank[n];\\n        for(int i=0; i<n; i++){\\n            parent[i] = i;\\n        }\\n        int components = n;\\n        for(auto con : connections){\\n            components -= makeUnion(con[0], con[1], parent, rank);\\n        }\\n        return components-1;\\n    }\\n};\\n\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/05ec548b-8f31-4b4d-88c1-50cfa8ad7d7e_1679561909.9536836.png)\\n\\n![image.png](https://assets.leetcode.com/users/images/1788262d-a9a0-418a-b0b4-bb5b97a59ca0_1679561923.9796534.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nInput: n = 4, connections = [[0,1],[0,2],[1,2]]\\n\\n```\n```\\nInput: n = 6, connections = [[0,1],[0,2],[0,3],[1,2]]\\n\\n```\n``` Java []\\nclass Solution {\\n    int[] parent;\\n    int[] rank;\\n    int find(int x){\\n        while(parent[x]!=x){\\n            x = parent[parent[x]];\\n        }\\n        return x;\\n    }\\n    void makeUnion(int x, int y){\\n        int parX = find(x);\\n        int parY = find(y);\\n        if(parX == parY){\\n            return;\\n        }\\n        else if(rank[parX]<rank[parY]){\\n            parent[parX] = parY;\\n        }\\n        else if(rank[parX]>rank[parY]){\\n            parent[parY] = parX;\\n        }\\n        else{\\n            parent[parY] = parX;\\n            rank[parX]++;\\n        }\\n    }\\n    public int makeConnected(int n, int[][] connections) {\\n        int edges = connections.length;\\n        if(edges<n-1){\\n            return -1;\\n        }\\n        parent = new int[n];\\n        rank = new int[n];\\n        for(int i=0; i<n; i++){\\n            parent[i] = i;\\n        }\\n        for(int[] con : connections){\\n            makeUnion(con[0], con[1]);\\n        }\\n        Set<Integer> set = new HashSet<>();\\n        for(int i=0; i<n; i++){\\n            int par = find(i);\\n            set.add(par);\\n        }\\n        int unions = set.size();\\n        return unions-1;\\n    }\\n}\\n\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int find(int x, int parent[]){\\n        while(parent[x]!=x){\\n            x = parent[parent[x]];\\n        }\\n        return x;\\n    }\\n\\n    void makeUnion(int x, int y, int parent[], int rank[]){\\n        int parX = find(x, parent);\\n        int parY = find(y, parent);\\n        if(parX == parY){\\n            return;\\n        }\\n        else if(rank[parX]<rank[parY]){\\n            parent[parX] = parY;\\n        }\\n        else if(rank[parX]>rank[parY]){\\n            parent[parY] = parX;\\n        }\\n        else{\\n            parent[parY] = parX;\\n            rank[parX]++;\\n        }\\n    }\\n\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        int edges = connections.size();\\n        if(edges<n-1){\\n            return -1;\\n        }\\n        int parent[n];\\n        int rank[n];\\n        for(int i=0; i<n; i++){\\n            parent[i] = i;\\n        }\\n        for(auto con : connections){\\n            makeUnion(con[0], con[1], parent, rank);\\n        }\\n        set<int> groups;\\n        for(int i=0; i<n; i++){\\n            int par = find(i, parent);\\n            groups.insert(par);\\n        }\\n        int unions = groups.size();\\n        return unions-1;\\n    }\\n};\\n```\n``` Java []\\nclass Solution {\\n    int[] parent;\\n    int[] rank;\\n    int find(int x){\\n        while(parent[x]!=x){\\n            x = parent[parent[x]];\\n        }\\n        return x;\\n    }\\n    int makeUnion(int x, int y){\\n        int parX = find(x);\\n        int parY = find(y);\\n        if(parX == parY){\\n            return 0;\\n        }\\n        else if(rank[parX]<rank[parY]){\\n            parent[parX] = parY;\\n        }\\n        else if(rank[parX]>rank[parY]){\\n            parent[parY] = parX;\\n        }\\n        else{\\n            parent[parY] = parX;\\n            rank[parX]++;\\n        }\\n        return 1;\\n    }\\n    public int makeConnected(int n, int[][] connections) {\\n        int edges = connections.length;\\n        if(edges<n-1){\\n            return -1;\\n        }\\n        parent = new int[n];\\n        rank = new int[n];\\n        for(int i=0; i<n; i++){\\n            parent[i] = i;\\n        }\\n        int components = n;\\n        for(int[] con : connections){\\n            components -= makeUnion(con[0], con[1]);\\n        }\\n        return components-1;\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int find(int x, int parent[]){\\n        while(parent[x]!=x){\\n            x = parent[parent[x]];\\n        }\\n        return x;\\n    }\\n\\n    int makeUnion(int x, int y, int parent[], int rank[]){\\n        int parX = find(x, parent);\\n        int parY = find(y, parent);\\n        if(parX == parY){\\n            return 0;\\n        }\\n        else if(rank[parX]<rank[parY]){\\n            parent[parX] = parY;\\n        }\\n        else if(rank[parX]>rank[parY]){\\n            parent[parY] = parX;\\n        }\\n        else{\\n            parent[parY] = parX;\\n            rank[parX]++;\\n        }\\n        return 1;\\n    }\\n\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        int edges = connections.size();\\n        if(edges<n-1){\\n            return -1;\\n        }\\n        int parent[n];\\n        int rank[n];\\n        for(int i=0; i<n; i++){\\n            parent[i] = i;\\n        }\\n        int components = n;\\n        for(auto con : connections){\\n            components -= makeUnion(con[0], con[1], parent, rank);\\n        }\\n        return components-1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477676,
                "title": "union-find-missing-connections",
                "content": "We connect computers using Union-Find. If two computers are already in the same connected group, we have an extra cable (`++extra_cables`).\\n\\n**Update:** as [SleepyFarmer](https://leetcode.com/sleepyfarmer) observed below, we can connect all `n` computers if we have at least `n - 1` total cables. So, we can check this in the beginning return `-1` right away if we do not have enough cables.\\n\\nInitially, `n` computers need to be connected. If computers are in the different groups, we connect them and decrease `n`. In the end, we need to connect the remaining `n - 1` computers. \\n\\n**Update:** I am now using rank (as number of elements in the group) to join smaller group into a larger one, and the runtime complexity went down to 88 ms from 104 ms. Note than the rank is typically the \"depth\" of the tree, but with path compression \"depth\" becomes one. So, my recommendation is to use number of elements as a proxy for the rank if you use the path compression.\\n\\n```CPP\\nint find(vector<int> &ds, int i) {\\n    return ds[i] < 0 ? i : ds[i] = find(ds, ds[i]);\\n}\\nint makeConnected(int n, vector<vector<int>>& connections) {\\n    if (connections.size() < n - 1) return -1;\\n    vector<int> ds(n, -1);\\n    for (auto &c : connections) {\\n        auto i = find(ds, c[0]), j = find(ds, c[1]);\\n        if (i != j) {\\n            if (ds[j] < ds[i])\\n                swap(i, j);\\n            ds[i] += ds[j];\\n            ds[j] = i;\\n            --n;\\n        }\\n    }\\n    return n - 1;\\n}\\n```\\n**Complexity Analysis**\\n- Time: O(m), where `m` is the number of connections (union operations). Since we are using the path compression, a single union operation is O(log*(m)) per [this Wikipedia article](https://en.wikipedia.org/wiki/Proof_of_O(log*n)_time_complexity_of_union%E2%80%93find). With ranking, it is O(\\u03B1(m)), where \\u03B1 is the inverse of the Ackerman function. For practical purposes, we can consider \\u03B1(m) a constant. So, we are performing `m` operations, each taking a constant time. \\n- Memory: O(n) for the disjoint set.",
                "solutionTags": [],
                "code": "```CPP\\nint find(vector<int> &ds, int i) {\\n    return ds[i] < 0 ? i : ds[i] = find(ds, ds[i]);\\n}\\nint makeConnected(int n, vector<vector<int>>& connections) {\\n    if (connections.size() < n - 1) return -1;\\n    vector<int> ds(n, -1);\\n    for (auto &c : connections) {\\n        auto i = find(ds, c[0]), j = find(ds, c[1]);\\n        if (i != j) {\\n            if (ds[j] < ds[i])\\n                swap(i, j);\\n            ds[i] += ds[j];\\n            ds[j] = i;\\n            --n;\\n        }\\n    }\\n    return n - 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1044680,
                "title": "c-solution-easy-to-understand-dfs-traversal-with-explanation",
                "content": "The main idea is here to get the number of connected component in graph ;\\nNumber of edge in graph = connections.size() , so we can make connection of connections.size()+1 computer connected.. //condition for returning -1 \\n\\nif we want to connection among all computer so number of connected component must be 1.. \\nnumber of conneted component -1 will be required cabel to make one connection\\n\\n```\\nclass Solution {\\npublic:\\n    void dfs_traversal(vector<vector<int>>& graph , vector<bool>& visited , int start){\\n        visited[start]=true;\\n        for(auto it : graph[start]){\\n            if(!visited[it]){\\n                dfs_traversal(graph , visited , it );\\n            }\\n        }\\n    }\\n    \\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        if(n>connections.size()+1)\\n            return -1;\\n        \\n        vector<vector<int>> graph(n);\\n        for(auto con : connections){\\n            graph[con[0]].push_back(con[1]);\\n            graph[con[1]].push_back(con[0]);\\n        }\\n        vector<bool> visited(n ,false);\\n        int component=0;\\n        for(int i=0;i<n;i++){\\n            if(!visited[i]){\\n                component++;\\n                dfs_traversal(graph , visited , i);\\n            }\\n        }\\n        return component-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs_traversal(vector<vector<int>>& graph , vector<bool>& visited , int start){\\n        visited[start]=true;\\n        for(auto it : graph[start]){\\n            if(!visited[it]){\\n                dfs_traversal(graph , visited , it );\\n            }\\n        }\\n    }\\n    \\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        if(n>connections.size()+1)\\n            return -1;\\n        \\n        vector<vector<int>> graph(n);\\n        for(auto con : connections){\\n            graph[con[0]].push_back(con[1]);\\n            graph[con[1]].push_back(con[0]);\\n        }\\n        vector<bool> visited(n ,false);\\n        int component=0;\\n        for(int i=0;i<n;i++){\\n            if(!visited[i]){\\n                component++;\\n                dfs_traversal(graph , visited , i);\\n            }\\n        }\\n        return component-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 482964,
                "title": "python-3-dfs-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n# \\u6392\\u9664\\u8FB9\\u4E0D\\u591F\\u7684\\u60C5\\u51B5\\n        if len(connections) < n - 1:\\n            return -1\\n        self.visited = set()\\n \\n#\\u5EFA\\u56FE\\n        self.graph = [[] for _ in range(n)]\\n        \\n        count = 0\\n        for connection in connections:\\n            self.graph[connection[0]].append(connection[1])\\n            self.graph[connection[1]].append(connection[0])\\n  #\\u9010\\u4E2Anode\\u6392\\u67E5\\uFF0C\\u627E\\u51FA\\u8054\\u901A\\u5B50\\u56FE\\u4E2A\\u6570\\n        for i in range(n):\\n            if i not in self.visited:\\n                self.dfs(i)\\n                count += 1\\n        return count - 1\\n            \\n    #\\u7528dfs\\u6765\\u627E\\u8054\\u901A\\u5B50\\u56FE\\n    def dfs(self, i):\\n        self.visited.add(i)\\n        \\n        for next_node in self.graph[i]:\\n            if next_node not in self.visited:\\n                self.dfs(next_node)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n# \\u6392\\u9664\\u8FB9\\u4E0D\\u591F\\u7684\\u60C5\\u51B5\\n        if len(connections) < n - 1:\\n            return -1\\n        self.visited = set()\\n \\n#\\u5EFA\\u56FE\\n        self.graph = [[] for _ in range(n)]\\n        \\n        count = 0\\n        for connection in connections:\\n            self.graph[connection[0]].append(connection[1])\\n            self.graph[connection[1]].append(connection[0])\\n  #\\u9010\\u4E2Anode\\u6392\\u67E5\\uFF0C\\u627E\\u51FA\\u8054\\u901A\\u5B50\\u56FE\\u4E2A\\u6570\\n        for i in range(n):\\n            if i not in self.visited:\\n                self.dfs(i)\\n                count += 1\\n        return count - 1\\n            \\n    #\\u7528dfs\\u6765\\u627E\\u8054\\u901A\\u5B50\\u56FE\\n    def dfs(self, i):\\n        self.visited.add(i)\\n        \\n        for next_node in self.graph[i]:\\n            if next_node not in self.visited:\\n                self.dfs(next_node)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3330666,
                "title": "c-line-by-line-explanation-dfs",
                "content": "# Complete And Clean Code is in last\\n\\n# Intuition\\nfrom the quesion , we can say we need to find the count of group of computer which are not connected to any other computer ( they may connected in group but does not coonected to another group)\\n\\nAlso we require to count wires, that are availble ,\\nnumber of wire can be easly find by given number of connection\\n```\\nint m = con.size();\\n```\\n\\n# Approach\\nTo start solving quetion , we need to know , which computer is connected to which one , in short we need a adjency list \\n\\nlet\\'s create adjency list.......\\n```\\nvector<int> adj[n];\\n  for(auto a : con){\\n    adj[a[0]].push_back(a[1]);\\n    adj[a[1]].push_back(a[0]);\\n  }\\n``` \\nonce we have adjency list we can use DFS to travell along all the computer that are connected to each other.\\nAs we have N numbers of computer , let\\'s make a array that will tell use given index of computer is visted or not , if a computer is vister that mean have already counted it.\\n```\\nvector<int> vis(n,0);\\n```\\nHere comes main concept .. if i start to travell from a computer at index 0 , i can travell along all the computers that are directly or indirectly connected to index 0 computer , while traversing we will mark as visted so that we are not come to visit any computer again.\\n\\nOnce a group of compter visted and marked as visted , we will try to find another group of computer that are not visted , repeating this process we can find numbers of group of computer that are not connected.\\n```\\nint c=0;\\nfor(int i =0; i<n;i++){\\n  if(!vis[i]){\\n    c++;\\n    dfs(adj,vis,i);\\n  }\\n}\\n```\\nhere is our DFS fuction\\n```\\nvoid dfs(vector<int> adj[] , vector<int> &vis , int i){\\n  vis[i]=1;\\n  for(auto a : adj[i]){\\n    if(!vis[a]){\\n      dfs(adj,vis,a);\\n    }\\n  }\\n}\\n```\\n\\nAt last we will check either number of wire is more that our requirement , to connect N numbers of computer we needd atleast N-1 wires , here \"m\" is numbers of wires .\\n```\\nif(m>=n-1) return c-1;\\nreturn -1;\\n```\\nYE KARNA BHI IMPORTANT H\\n\\n```\\nREAD IT ? DO A VOTE UP...\\n```\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void dfs(vector<int> adj[] , vector<int> &vis , int i){\\n        vis[i]=1;\\n        for(auto a : adj[i]){\\n            if(!vis[a]){\\n                dfs(adj,vis,a);\\n            }\\n        }\\n    }\\n\\n    int makeConnected(int n, vector<vector<int>>& con) {\\n        vector<int> adj[n];\\n        vector<int> vis(n,0);\\n        for(auto a : con){\\n            adj[a[0]].push_back(a[1]);\\n            adj[a[1]].push_back(a[0]);\\n        }\\n        int c=0;\\n        int m = con.size();\\n        for(int i =0; i<n;i++){\\n            if(!vis[i]){\\n                c++;\\n                dfs(adj,vis,i);\\n            }\\n        }\\n        if(m>=n-1) return c-1;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nint m = con.size();\\n```\n```\\nvector<int> adj[n];\\n  for(auto a : con){\\n    adj[a[0]].push_back(a[1]);\\n    adj[a[1]].push_back(a[0]);\\n  }\\n```\n```\\nvector<int> vis(n,0);\\n```\n```\\nint c=0;\\nfor(int i =0; i<n;i++){\\n  if(!vis[i]){\\n    c++;\\n    dfs(adj,vis,i);\\n  }\\n}\\n```\n```\\nvoid dfs(vector<int> adj[] , vector<int> &vis , int i){\\n  vis[i]=1;\\n  for(auto a : adj[i]){\\n    if(!vis[a]){\\n      dfs(adj,vis,a);\\n    }\\n  }\\n}\\n```\n```\\nif(m>=n-1) return c-1;\\nreturn -1;\\n```\n```\\nREAD IT ? DO A VOTE UP...\\n```\n```\\nclass Solution {\\npublic:\\n\\n    void dfs(vector<int> adj[] , vector<int> &vis , int i){\\n        vis[i]=1;\\n        for(auto a : adj[i]){\\n            if(!vis[a]){\\n                dfs(adj,vis,a);\\n            }\\n        }\\n    }\\n\\n    int makeConnected(int n, vector<vector<int>>& con) {\\n        vector<int> adj[n];\\n        vector<int> vis(n,0);\\n        for(auto a : con){\\n            adj[a[0]].push_back(a[1]);\\n            adj[a[1]].push_back(a[0]);\\n        }\\n        int c=0;\\n        int m = con.size();\\n        for(int i =0; i<n;i++){\\n            if(!vis[i]){\\n                c++;\\n                dfs(adj,vis,i);\\n            }\\n        }\\n        if(m>=n-1) return c-1;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1195926,
                "title": "easy-to-understand-java-implementation-using-find-disconnected-components-concept",
                "content": "To connect all vertices **V** you need atleast **V-1** edges. If you don\\'t have that there is no possible way to connect all vertices and simply return -1. Else find all disconnected components lets say N and to connect N disconnected components you will need **N-1** edges and simply return **N-1**.\\nSolve - https://leetcode.com/problems/number-of-provinces/ to understand disconnected components.\\n```\\nclass Solution {\\n    public int makeConnected(int n, int[][] connections) {\\n        if(connections.length<n-1)\\n            return -1;\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n            adj.add(new ArrayList<>());\\n        for(int[] edge : connections){\\n            adj.get(edge[0]).add(edge[1]);\\n            adj.get(edge[1]).add(edge[0]);\\n        }\\n        boolean[] visited = new boolean[n];\\n        int count = 0;\\n        for(int i=0;i<n;i++){\\n            if(!visited[i]){\\n                count++;\\n                dfs(adj, i, visited);\\n            }\\n        }\\n        return count-1;\\n    }\\n    void dfs(ArrayList<ArrayList<Integer>> adj, int node, boolean[] visited){\\n        if(visited[node])\\n            return;\\n        visited[node] = true;\\n        for(int i : adj.get(node)){\\n            dfs(adj, i, visited);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int makeConnected(int n, int[][] connections) {\\n        if(connections.length<n-1)\\n            return -1;\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n            adj.add(new ArrayList<>());\\n        for(int[] edge : connections){\\n            adj.get(edge[0]).add(edge[1]);\\n            adj.get(edge[1]).add(edge[0]);\\n        }\\n        boolean[] visited = new boolean[n];\\n        int count = 0;\\n        for(int i=0;i<n;i++){\\n            if(!visited[i]){\\n                count++;\\n                dfs(adj, i, visited);\\n            }\\n        }\\n        return count-1;\\n    }\\n    void dfs(ArrayList<ArrayList<Integer>> adj, int node, boolean[] visited){\\n        if(visited[node])\\n            return;\\n        visited[node] = true;\\n        for(int i : adj.get(node)){\\n            dfs(adj, i, visited);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 906317,
                "title": "java-solution-with-detailed-explanation",
                "content": "class Solution {\\n    \\n     /*Steps to solve the problem: \\n        \\n        1) Make Adjacency List -> count of Edges(E)\\n        2) DFS Traversal -> count of Components(C)\\n        3) n -> count of Nodes(N)\\n        4) Redundant Edges: R = E - [(N-1) - (C-1)] <--- important step\\n           $ When number of components is 1, formula becomes:\\n            R = E - [N-1]\\n           -For N nodes N-1 edges are required for complete connection.\\n            Rest will be redundant, hence the formula.\\n        5) Negative Cases (return -1): \\n           - E<N-1  \\n           - R<C-1 \\n        6) Else return C-1 (This is the minimum number of edges required to connect C components);\\n        \\n        If you have enough redudant edges R >= C-1, then you can use C-1 edges to connect a network.\\n        \\n        */\\n        \\n    public int makeConnected(int n, int[][] connections) {\\n        \\n\\t\\t/* Count of Nodes -> N */\\n        int N = n;  \\n\\t\\t\\n\\t\\t/* Count of Edges -> E */\\n        int E = connections.length; \\n\\t\\t\\n        int R = 0;\\n        int C = 0;\\n        \\n        if(E<N-1)\\n            return -1;\\n        \\n\\t\\t/* Create Adjaceny List */\\n        List<List<Integer>> adj = new ArrayList<>();\\n        \\n          for(int i = 0; i<n; i++)\\n             adj.add(new ArrayList<>());\\n        \\n          for(int[] c : connections){\\n                adj.get(c[0]).add(c[1]);\\n                adj.get(c[1]).add(c[0]);\\n            }\\n        \\n        boolean[] visited = new boolean[n];\\n        \\n\\t\\t/* Perform DFS traversal to count components -> C */\\n        for(int i = 0; i<n; i++){\\n            if(!visited[i]){\\n                dfs(adj,visited,i);\\n                C++;\\n            }\\n        }\\n        \\n\\t\\t/* Calculate Redundant Edges -> R */\\n        R = E-((N-1)-(C-1));\\n\\n        if(R<C-1)\\n            return -1;\\n        \\n        return C-1;\\n    }\\n    \\n\\t/* DFS Traversal */\\n    public void dfs(List<List<Integer>> adj, boolean[] visited, int i){\\n        \\n        if(visited[i])\\n            return;\\n        \\n        visited[i] = true;\\n        \\n        List<Integer> connection = adj.get(i);\\n        for(int c : connection){\\n            if(!visited[c])\\n                dfs(adj,visited,c);\\n        }\\n        return;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    \\n     /*Steps to solve the problem: \\n        \\n        1) Make Adjacency List -> count of Edges(E)\\n        2) DFS Traversal -> count of Components(C)\\n        3) n -> count of Nodes(N)\\n        4) Redundant Edges: R = E - [(N-1) - (C-1)] <--- important step\\n           $ When number of components is 1, formula becomes:\\n            R = E - [N-1]\\n           -For N nodes N-1 edges are required for complete connection.\\n            Rest will be redundant, hence the formula.\\n        5) Negative Cases (return -1): \\n           - E<N-1  \\n           - R<C-1 \\n        6) Else return C-1 (This is the minimum number of edges required to connect C components);\\n        \\n        If you have enough redudant edges R >= C-1, then you can use C-1 edges to connect a network.\\n        \\n        */\\n        \\n    public int makeConnected(int n, int[][] connections) {\\n        \\n\\t\\t/* Count of Nodes -> N */\\n        int N = n;  \\n\\t\\t\\n\\t\\t/* Count of Edges -> E */\\n        int E = connections.length; \\n\\t\\t\\n        int R = 0;\\n        int C = 0;\\n        \\n        if(E<N-1)\\n            return -1;\\n        \\n\\t\\t/* Create Adjaceny List */\\n        List<List<Integer>> adj = new ArrayList<>();\\n        \\n          for(int i = 0; i<n; i++)\\n             adj.add(new ArrayList<>());\\n        \\n          for(int[] c : connections){\\n                adj.get(c[0]).add(c[1]);\\n                adj.get(c[1]).add(c[0]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 477806,
                "title": "python-union-find",
                "content": "This problem can easily be solved using the Union-Find (aka Disjoint-Set) data structure.\\nUnion connects the parent nodes of two nodes. Find returns the deepest parent node of a node.\\nUnion runs in ```O(1)``` and Find runs in ```O(a(n)) < O(5) = O(1)``` if union by rank/size is used in combination with path compression/halving/ splitting (see the proof on [Wikipedia](https://en.wikipedia.org/wiki/Disjoint-set_data_structure)).\\n\\nTo connect all n nodes in a graph at least n - 1 connections are needed. Therefore we can return -1 if that requirement is not met.\\nUnite all nodes using the given connections. Then count how many disjoint groups of nodes there are: There is one group for every node that is its own parent. Subtract 1 and we get the number of required connections.\\n\\n**Shortest version without optimization techniques** (time: ```O(n + m * n)```, space: ```O(n)```)\\n```python\\nclass Solution:\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        if len(connections) < n - 1:\\n            return -1\\n        \\n        parent = list(range(n))\\n        find = lambda x: x if parent[x] == x else find(parent[x])\\n        \\n        for a, b in connections:\\n            parent[find(b)] = find(a)\\n        \\n        return sum(parent[x] == x for x in range(n)) - 1\\n```\\n\\nTime complexity: ```O(n + m)``` (m is the number of connections)\\nSpace complexity: ```O(n)```\\n\\n**Short version using union by rank and path splitting** (time: ```O(n + m)```, space: ```O(n)```)\\n```python\\nclass Solution:\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        if len(connections) < n - 1:\\n            return -1\\n        \\n        parent = list(range(n))\\n        rank = [0] * n\\n        \\n        for a, b in connections:\\n            while a != parent[a]:\\n                a, parent[a] = parent[a], parent[parent[a]]\\n            while b != parent[b]:\\n                b, parent[b] = parent[b], parent[parent[b]]\\n            \\n            if rank[a] == rank[b]:\\n                rank[a] += 1\\n            elif rank[a] < rank[b]:\\n                a, b, = b, a\\n            \\n            parent[b] = a\\n        \\n        return sum(parent[x] == x for x in range(n)) - 1\\n```\\n**Long OOP version using union by rank and path compression** (time: ```O(n + m)```, space: ```O(n)```)\\n```python\\nclass UnionFind:\\n    def __init__(self):\\n        self.parent = {}\\n        self.rank = {}\\n    \\n    def union(self, a, b):\\n        a, b = self.find(a), self.find(b)\\n        \\n        if a == b:\\n            return\\n        \\n        if self.rank[a] == self.rank[b]:\\n            self.rank[a] += 1\\n        elif self.rank[b] > self.rank[a]:\\n            a, b = b, a\\n            \\n        self.parent[b] = a\\n    \\n    def find(self, x):\\n        if x not in self.parent:\\n            self.parent[x] = x\\n            self.rank[x] = 0\\n        \\n        if x != self.parent[x]:\\n            self.parent[x] = self.find(self.parent[x])\\n        \\n        return self.parent[x]\\n    \\nclass Solution:\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        if len(connections) < n - 1:\\n            return -1\\n        \\n        uf = UnionFind()\\n        \\n        for i, j in connections:\\n            uf.union(i, j)\\n        \\n        return sum(uf.find(x) == x for x in range(n)) - 1\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```O(1)```\n```O(a(n)) < O(5) = O(1)```\n```O(n + m * n)```\n```O(n)```\n```python\\nclass Solution:\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        if len(connections) < n - 1:\\n            return -1\\n        \\n        parent = list(range(n))\\n        find = lambda x: x if parent[x] == x else find(parent[x])\\n        \\n        for a, b in connections:\\n            parent[find(b)] = find(a)\\n        \\n        return sum(parent[x] == x for x in range(n)) - 1\\n```\n```O(n + m)```\n```O(n)```\n```O(n + m)```\n```O(n)```\n```python\\nclass Solution:\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        if len(connections) < n - 1:\\n            return -1\\n        \\n        parent = list(range(n))\\n        rank = [0] * n\\n        \\n        for a, b in connections:\\n            while a != parent[a]:\\n                a, parent[a] = parent[a], parent[parent[a]]\\n            while b != parent[b]:\\n                b, parent[b] = parent[b], parent[parent[b]]\\n            \\n            if rank[a] == rank[b]:\\n                rank[a] += 1\\n            elif rank[a] < rank[b]:\\n                a, b, = b, a\\n            \\n            parent[b] = a\\n        \\n        return sum(parent[x] == x for x in range(n)) - 1\\n```\n```O(n + m)```\n```O(n)```\n```python\\nclass UnionFind:\\n    def __init__(self):\\n        self.parent = {}\\n        self.rank = {}\\n    \\n    def union(self, a, b):\\n        a, b = self.find(a), self.find(b)\\n        \\n        if a == b:\\n            return\\n        \\n        if self.rank[a] == self.rank[b]:\\n            self.rank[a] += 1\\n        elif self.rank[b] > self.rank[a]:\\n            a, b = b, a\\n            \\n        self.parent[b] = a\\n    \\n    def find(self, x):\\n        if x not in self.parent:\\n            self.parent[x] = x\\n            self.rank[x] = 0\\n        \\n        if x != self.parent[x]:\\n            self.parent[x] = self.find(self.parent[x])\\n        \\n        return self.parent[x]\\n    \\nclass Solution:\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        if len(connections) < n - 1:\\n            return -1\\n        \\n        uf = UnionFind()\\n        \\n        for i, j in connections:\\n            uf.union(i, j)\\n        \\n        return sum(uf.find(x) == x for x in range(n)) - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3331931,
                "title": "java-easy-bfs-similar-to-number-of-islands",
                "content": "**Similar to number of islands with a slight change. The change is if the number of edges is less than n-1 (because we know minimum number of edges required for a graph of n vertices to remain connected is n-1) then we will return -1 or else If the number of edges is >= n-1 then we have sufficient wires to connect all the computers so we return (components-1) as counting the number of components signifies how many group of computers are not connected. So we required (components-1) number of wires so that all computers are directly or indirectly connected with each other.**\\n```\\nclass Solution {\\n    public int makeConnected(int n, int[][] connections) {\\n        if(connections.length<n-1)\\n            return -1;\\n        List<List<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int i=0;i<connections.length;i++){\\n            adj.get(connections[i][0]).add(connections[i][1]);\\n            adj.get(connections[i][1]).add(connections[i][0]);\\n        }\\n        boolean vis[]=new boolean[n];\\n        Queue<Integer> qu=new LinkedList<>();\\n        qu.add(0);\\n        int comp=0;\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                bfs(i,vis,adj);\\n                comp++;\\n            }\\n        }\\n        return comp-1;\\n    }\\n    public void bfs(int node,boolean[] vis,List<List<Integer>> adj){\\n        Queue<Integer> qu=new LinkedList<>();\\n        qu.add(node);\\n        while(!qu.isEmpty()){\\n            int curr=qu.poll();\\n            for(int adjnode:adj.get(curr)){\\n                if(!vis[adjnode]){\\n                    qu.add(adjnode);\\n                    vis[adjnode]=true;\\n                }\\n            }\\n        }\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/5c243964-c160-4231-97b7-b7f2dc373604_1679569819.3938613.png)\\n\\n![image](https://assets.leetcode.com/users/images/6cebf425-8b1f-482e-bb28-4c8a9585114b_1679569882.6787083.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int makeConnected(int n, int[][] connections) {\\n        if(connections.length<n-1)\\n            return -1;\\n        List<List<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int i=0;i<connections.length;i++){\\n            adj.get(connections[i][0]).add(connections[i][1]);\\n            adj.get(connections[i][1]).add(connections[i][0]);\\n        }\\n        boolean vis[]=new boolean[n];\\n        Queue<Integer> qu=new LinkedList<>();\\n        qu.add(0);\\n        int comp=0;\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                bfs(i,vis,adj);\\n                comp++;\\n            }\\n        }\\n        return comp-1;\\n    }\\n    public void bfs(int node,boolean[] vis,List<List<Integer>> adj){\\n        Queue<Integer> qu=new LinkedList<>();\\n        qu.add(node);\\n        while(!qu.isEmpty()){\\n            int curr=qu.poll();\\n            for(int adjnode:adj.get(curr)){\\n                if(!vis[adjnode]){\\n                    qu.add(adjnode);\\n                    vis[adjnode]=true;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 510654,
                "title": "java-union-find-99-time-100-space-with-explanation",
                "content": "1. use union find to get the num of connected networks.\\n2. check whether these 2 computers are already connected or not when do the union, then u can get the num of extra cables.\\n3. need `n-1` cables to connect `n` different networks, so compare the `extra cables`  & `num of networks - 1`.\\n```\\nclass Solution {\\n    public int makeConnected(int n, int[][] connections) {\\n        int[] c = new int[n];\\n        int group = 0, extra = 0;\\n        for(int i = 0; i < n; i++) c[i] = i;\\n        for(int[] a : connections)\\n            if(union(a[0], a[1], c))\\n                extra ++;\\n        for(int i = 0; i < n; i++) {\\n            if(find(i, c) == i)\\n                group ++;\\n        }\\n        return extra >= group - 1 ? group - 1 : -1;\\n    }\\n    \\n    boolean union(int a, int b, int[] c) {\\n        if(find(a, c) != find(b, c)){\\n            c[c[a]] = c[b];\\n            return false;\\n        }\\n        else return true;\\n    }\\n    \\n    int find(int a, int[] c) {\\n        if(c[a] != a) \\n            c[a] = find(c[a], c);\\n        return c[a];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public int makeConnected(int n, int[][] connections) {\\n        int[] c = new int[n];\\n        int group = 0, extra = 0;\\n        for(int i = 0; i < n; i++) c[i] = i;\\n        for(int[] a : connections)\\n            if(union(a[0], a[1], c))\\n                extra ++;\\n        for(int i = 0; i < n; i++) {\\n            if(find(i, c) == i)\\n                group ++;\\n        }\\n        return extra >= group - 1 ? group - 1 : -1;\\n    }\\n    \\n    boolean union(int a, int b, int[] c) {\\n        if(find(a, c) != find(b, c)){\\n            c[c[a]] = c[b];\\n            return false;\\n        }\\n        else return true;\\n    }\\n    \\n    int find(int a, int[] c) {\\n        if(c[a] != a) \\n            c[a] = find(c[a], c);\\n        return c[a];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324150,
                "title": "easy-c-union-find-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        //there should be atleast n-1 connctions to make the network connected\\n        if(connections.size()<n-1)\\n            return -1;\\n        \\n        //return  the number of computers that are not connected\\n        vector<int> parent(n,-1);\\n        \\n        int count=1;\\n        //union the connections\\n        for(int i=0;i<connections.size();i++)\\n        {\\n            uni(parent,connections[i][0],connections[i][1],count);\\n        }\\n        \\n        //the number of disconnected computers\\n        return n-count;\\n        \\n    }\\n    int findAbsParent(vector<int>& parent,int i)\\n    {\\n        while(parent[i]!=-1)\\n            i=parent[i];\\n        return i;\\n    }\\n    \\n    void uni(vector<int>& parent,int x,int y,int& count)\\n    {\\n        int parent1=findAbsParent(parent,x);\\n        int parent2=findAbsParent(parent,y);\\n        if(parent1!=parent2)\\n        {\\n            //if they both belong to different components\\n            //make them as single components\\n            parent[parent1]=parent2;\\n            count++;\\n        }\\n    }\\n};\\n```\\n**Upvote if this helps you:)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        //there should be atleast n-1 connctions to make the network connected\\n        if(connections.size()<n-1)\\n            return -1;\\n        \\n        //return  the number of computers that are not connected\\n        vector<int> parent(n,-1);\\n        \\n        int count=1;\\n        //union the connections\\n        for(int i=0;i<connections.size();i++)\\n        {\\n            uni(parent,connections[i][0],connections[i][1],count);\\n        }\\n        \\n        //the number of disconnected computers\\n        return n-count;\\n        \\n    }\\n    int findAbsParent(vector<int>& parent,int i)\\n    {\\n        while(parent[i]!=-1)\\n            i=parent[i];\\n        return i;\\n    }\\n    \\n    void uni(vector<int>& parent,int x,int y,int& count)\\n    {\\n        int parent1=findAbsParent(parent,x);\\n        int parent2=findAbsParent(parent,y);\\n        if(parent1!=parent2)\\n        {\\n            //if they both belong to different components\\n            //make them as single components\\n            parent[parent1]=parent2;\\n            count++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 849437,
                "title": "connected-components-in-undirected-graph",
                "content": "Minimum edges to make n nodes connected is n - 1.\\n\\nCount of existing connected components - 1 is minimum edges to add make the whole graph connected.\\n\\nTo find all the components of a graph, we simply loop through its vertices, and do DFS search on unvisited ones. A search that begins at v will find the entire component containing v (and no more) before returning. \\n```\\nclass Solution {\\n    public int makeConnected(int n, int[][] connections) {\\n        if (connections.length < n - 1) {\\n            return -1;\\n        }\\n        \\n        List<List<Integer>> adjList = buildGraph(n, connections);\\n        \\n        boolean[] visited = new boolean[n];\\n        int countConnectedComponent = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (!visited[i]) {\\n                dfs(visited, i, adjList);\\n                // Detects a connected component\\n                countConnectedComponent++;\\n            }\\n        }\\n        \\n        return countConnectedComponent - 1;\\n    }\\n    \\n    private  List<List<Integer>> buildGraph(int n, int[][] connections) {\\n        List<List<Integer>> adjList = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            adjList.add(new ArrayList<>());\\n        }\\n        for (int[] connection: connections) {\\n            adjList.get(connection[0]).add(connection[1]);\\n            adjList.get(connection[1]).add(connection[0]);\\n        }\\n        return adjList;\\n    }\\n    \\n    private void dfs(boolean[] visited, int from, List<List<Integer>> adjList) {\\n        visited[from] = true;\\n        for (int to : adjList.get(from)) {\\n            if (!visited[to]) {\\n                dfs(visited, to, adjList);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int makeConnected(int n, int[][] connections) {\\n        if (connections.length < n - 1) {\\n            return -1;\\n        }\\n        \\n        List<List<Integer>> adjList = buildGraph(n, connections);\\n        \\n        boolean[] visited = new boolean[n];\\n        int countConnectedComponent = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (!visited[i]) {\\n                dfs(visited, i, adjList);\\n                // Detects a connected component\\n                countConnectedComponent++;\\n            }\\n        }\\n        \\n        return countConnectedComponent - 1;\\n    }\\n    \\n    private  List<List<Integer>> buildGraph(int n, int[][] connections) {\\n        List<List<Integer>> adjList = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            adjList.add(new ArrayList<>());\\n        }\\n        for (int[] connection: connections) {\\n            adjList.get(connection[0]).add(connection[1]);\\n            adjList.get(connection[1]).add(connection[0]);\\n        }\\n        return adjList;\\n    }\\n    \\n    private void dfs(boolean[] visited, int from, List<List<Integer>> adjList) {\\n        visited[from] = true;\\n        for (int to : adjList.get(from)) {\\n            if (!visited[to]) {\\n                dfs(visited, to, adjList);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3331326,
                "title": "c-easy-dfs-solution",
                "content": "# Intuition \\nThe main idea is here to get the number of connected components in graph \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\nDFS traversal to find number of connected components\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> ad[],int i,vector<int>&vis){\\n        for(auto k : ad[i]){\\n            if(!vis[k]){\\n                vis[k]=1;\\n                dfs(ad,k,vis);\\n            }\\n        }\\n    }\\n    int makeConnected(int n, vector<vector<int>>& v) {\\n        if(n-1>v.size())return -1;\\n        vector<int> ad[n];\\n        vector<int>vis(n,0);\\n        int c=0;\\n        for(auto i:v){\\n            ad[i[0]].push_back(i[1]);\\n            ad[i[1]].push_back(i[0]);\\n        }\\n        for(int i=0;i<n;i++){\\n              if(!vis[i]){\\n                  vis[i]=1;\\n                  c++;\\n                  dfs(ad,i,vis);\\n              }\\n        }\\n        return c-1;\\n    }\\n};\\n```\\n![upvote (3).jpg](https://assets.leetcode.com/users/images/42607605-5d40-4e5a-8ea4-faaba4fd647d_1679556252.9584877.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> ad[],int i,vector<int>&vis){\\n        for(auto k : ad[i]){\\n            if(!vis[k]){\\n                vis[k]=1;\\n                dfs(ad,k,vis);\\n            }\\n        }\\n    }\\n    int makeConnected(int n, vector<vector<int>>& v) {\\n        if(n-1>v.size())return -1;\\n        vector<int> ad[n];\\n        vector<int>vis(n,0);\\n        int c=0;\\n        for(auto i:v){\\n            ad[i[0]].push_back(i[1]);\\n            ad[i[1]].push_back(i[0]);\\n        }\\n        for(int i=0;i<n;i++){\\n              if(!vis[i]){\\n                  vis[i]=1;\\n                  c++;\\n                  dfs(ad,i,vis);\\n              }\\n        }\\n        return c-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3330419,
                "title": "java-easy-solution-100-faster-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nPLEASE UPVOTE IF YOU LIKE\\n```\\n\\n\\nclass Solution {\\n    public int makeConnected(int n, int[][] connections) {\\n       // if there are not enough cables than return -1 as  there should be minimum n-1 edges to connect n nodes\\n        if(connections.length < n-1)\\n            return -1;\\n        \\n        int[] parent = new int[n];\\n        int[] rank = new int[n];\\n        \\n        for(int i = 0; i<n; i++){\\n            parent[i] = i;\\n        }\\n        Arrays.fill(rank, 1);\\n        \\n        for(int i = 0; i< connections.length; i++){\\n            union(parent, rank, connections[i][0], connections[i][1]);\\n        }\\n        \\n        int countOfUnconnectedComputers =0;\\n        for(int i = 0; i< parent.length; i++){\\n            if(parent[i] == i)\\n                countOfUnconnectedComputers++;\\n            \\n        } \\n        countOfUnconnectedComputers--; // since one root will be there\\n        \\n        return countOfUnconnectedComputers;\\n        \\n        \\n    }\\n    \\n    private void union(int[] parent, int[] rank, int x, int y){\\n        int parentX = find(parent, x);\\n        int parentY = find(parent, y);\\n        \\n        if(parentX==parentY)\\n            return;\\n        \\n        if(rank[parentX] > rank[parentY]){\\n            parent[parentY] = parent[parentX];\\n        }else if(rank[parentX] < rank[parentY]){\\n             parent[parentX] = parent[parentY];\\n        }else{\\n            parent[parentY] = parent[parentX];\\n            rank[parentX]++;\\n        }\\n        \\n        return;\\n\\n    }\\n    \\n    private int find(int[] parent, int x){\\n        if(parent[x] ==x)\\n            return x;\\n        \\n        return parent[x] = find(parent, parent[x]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n\\nclass Solution {\\n    public int makeConnected(int n, int[][] connections) {\\n       // if there are not enough cables than return -1 as  there should be minimum n-1 edges to connect n nodes\\n        if(connections.length < n-1)\\n            return -1;\\n        \\n        int[] parent = new int[n];\\n        int[] rank = new int[n];\\n        \\n        for(int i = 0; i<n; i++){\\n            parent[i] = i;\\n        }\\n        Arrays.fill(rank, 1);\\n        \\n        for(int i = 0; i< connections.length; i++){\\n            union(parent, rank, connections[i][0], connections[i][1]);\\n        }\\n        \\n        int countOfUnconnectedComputers =0;\\n        for(int i = 0; i< parent.length; i++){\\n            if(parent[i] == i)\\n                countOfUnconnectedComputers++;\\n            \\n        } \\n        countOfUnconnectedComputers--; // since one root will be there\\n        \\n        return countOfUnconnectedComputers;\\n        \\n        \\n    }\\n    \\n    private void union(int[] parent, int[] rank, int x, int y){\\n        int parentX = find(parent, x);\\n        int parentY = find(parent, y);\\n        \\n        if(parentX==parentY)\\n            return;\\n        \\n        if(rank[parentX] > rank[parentY]){\\n            parent[parentY] = parent[parentX];\\n        }else if(rank[parentX] < rank[parentY]){\\n             parent[parentX] = parent[parentY];\\n        }else{\\n            parent[parentY] = parent[parentX];\\n            rank[parentX]++;\\n        }\\n        \\n        return;\\n\\n    }\\n    \\n    private int find(int[] parent, int x){\\n        if(parent[x] ==x)\\n            return x;\\n        \\n        return parent[x] = find(parent, parent[x]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1742653,
                "title": "c-begginner-friendly-if-you-know-union-find-algo",
                "content": "**Main idea:-**\\n1) join all computers as question says.\\n2) Now find total number of different components // (finding parent will be enough count it.)\\n3) At last we require only  count(different component) - 1 cables to  connect different computers;\\n   \\nand in code we are doing the same->\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> parent;\\n    vector<int> rank;\\n    \\n    int findPar(int u){\\n        if(parent[u]==u) return u;\\n        return parent[u]=findPar(parent[u]); //path compresssion, storing the computed value;\\n    }\\n    void unionn(int u, int v){\\n        u= findPar(u);\\n        v= findPar(v);\\n        //smaller rank guy gets attached to the higher rank guy\\n        //only same rank -> then increase any one\\'s rank\\n        \\n        if(rank[u]<rank[v]) \\n            parent[u]=v; //smaller rank is u and its parent is v\\n        else if(rank[v]<rank[u])\\n            parent[v]=u;  //smaller rank is v and its parent is u\\n        else {\\n            parent[v]=u;\\n            rank[v]++;\\n        }\\n    }\\n    \\n    int makeConnected(int n, vector<vector<int>>& conn) {\\n        if(conn.size()< n-1) return -1; // to combine n computer we require n-1 wires but here it\\'s not the case\\n        \\n        //filling parent and rank array;\\n        for(int i=0;i<n;i++)\\n            parent.push_back(i), rank.push_back(0);\\n        \\n        //iterating to connection array and connecting them\\n        for(auto &it: conn)\\n            unionn(it[0], it[1]);\\n        \\n        //counting number of different components;\\n        int differentComponents= 0;\\n        for(int i=0;i<n;i++)\\n            if(parent[i]==i) differentComponents++;\\n        \\n        //total {DifferentComponents} components are there and we need to join them in mininimum cable \\n        //so best way to join them will be linearly( think ) which will require DifferentComponents-1 cables only;\\n        return differentComponents-1;\\n    }\\n};\\n```\\n\\n**Complexity Analysis**\\n\\nTime: O(m), where m is the number of connections (union operations) or (alpha*m) here alpha can be considered to be constant as we are doing path compression.\\nMemory: O(n+n) = O(n) for the disjoint set.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> parent;\\n    vector<int> rank;\\n    \\n    int findPar(int u){\\n        if(parent[u]==u) return u;\\n        return parent[u]=findPar(parent[u]); //path compresssion, storing the computed value;\\n    }\\n    void unionn(int u, int v){\\n        u= findPar(u);\\n        v= findPar(v);\\n        //smaller rank guy gets attached to the higher rank guy\\n        //only same rank -> then increase any one\\'s rank\\n        \\n        if(rank[u]<rank[v]) \\n            parent[u]=v; //smaller rank is u and its parent is v\\n        else if(rank[v]<rank[u])\\n            parent[v]=u;  //smaller rank is v and its parent is u\\n        else {\\n            parent[v]=u;\\n            rank[v]++;\\n        }\\n    }\\n    \\n    int makeConnected(int n, vector<vector<int>>& conn) {\\n        if(conn.size()< n-1) return -1; // to combine n computer we require n-1 wires but here it\\'s not the case\\n        \\n        //filling parent and rank array;\\n        for(int i=0;i<n;i++)\\n            parent.push_back(i), rank.push_back(0);\\n        \\n        //iterating to connection array and connecting them\\n        for(auto &it: conn)\\n            unionn(it[0], it[1]);\\n        \\n        //counting number of different components;\\n        int differentComponents= 0;\\n        for(int i=0;i<n;i++)\\n            if(parent[i]==i) differentComponents++;\\n        \\n        //total {DifferentComponents} components are there and we need to join them in mininimum cable \\n        //so best way to join them will be linearly( think ) which will require DifferentComponents-1 cables only;\\n        return differentComponents-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3330773,
                "title": "c-easy-solution-dfs-approach-heavily-commented",
                "content": "## **\\u2705\\u2705C++ || Easy Solution || \\uD83D\\uDCAF\\uD83D\\uDCAFDFS Approach || Heavily Commented**\\n# **Please Upvote as it really motivates me**\\n\\n```\\nclass Solution {\\npublic:\\n\\t//Depth First search function\\n    void dfs(int node,vector<vector<int>>&g,vector<int>&vis){\\n        vis[node]=0;\\n        for(auto&child:g[node]){\\n            if(vis[child]){\\n                dfs(child,g,vis);\\n            }\\n        }\\n    }\\n    int makeConnected(int n, vector<vector<int>>& conn) {\\n\\t\\t//When we have no. of edges less than n-1 we cant make it happen as tree will not form\\n\\t\\t//so return -1\\n        if(conn.size()<n-1){\\n            return -1;\\n        }\\n\\t\\t//vector of vector for the adj list\\n        vector<vector<int>>g(n);\\n        for(int i=0;i<conn.size();i++){\\n            g[conn[i][0]].push_back(conn[i][1]);\\n            g[conn[i][1]].push_back(conn[i][0]);\\n        }\\n\\t\\t//vector of int for storing the visited nodes\\n        vector<int>vis(n,1);\\n\\t\\t//no of different connected components\\n        int connectedComponents=0;\\n\\t\\t//Traversing to all the different connected components nodes\\n        for(int i=0;i<n;i++){\\n\\t\\t//if not visited\\n            if(vis[i]){\\n                dfs(i,g,vis);\\n\\t\\t\\t\\t//increase no of components\\n                connectedComponents++;\\n            }\\n        }\\n\\t\\t//return no of components-1\\n        return connectedComponents-1;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/7f423b57-81a2-46ce-9ab2-72ad38f668f7_1675480558.466273.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t//Depth First search function\\n    void dfs(int node,vector<vector<int>>&g,vector<int>&vis){\\n        vis[node]=0;\\n        for(auto&child:g[node]){\\n            if(vis[child]){\\n                dfs(child,g,vis);\\n            }\\n        }\\n    }\\n    int makeConnected(int n, vector<vector<int>>& conn) {\\n\\t\\t//When we have no. of edges less than n-1 we cant make it happen as tree will not form\\n\\t\\t//so return -1\\n        if(conn.size()<n-1){\\n            return -1;\\n        }\\n\\t\\t//vector of vector for the adj list\\n        vector<vector<int>>g(n);\\n        for(int i=0;i<conn.size();i++){\\n            g[conn[i][0]].push_back(conn[i][1]);\\n            g[conn[i][1]].push_back(conn[i][0]);\\n        }\\n\\t\\t//vector of int for storing the visited nodes\\n        vector<int>vis(n,1);\\n\\t\\t//no of different connected components\\n        int connectedComponents=0;\\n\\t\\t//Traversing to all the different connected components nodes\\n        for(int i=0;i<n;i++){\\n\\t\\t//if not visited\\n            if(vis[i]){\\n                dfs(i,g,vis);\\n\\t\\t\\t\\t//increase no of components\\n                connectedComponents++;\\n            }\\n        }\\n\\t\\t//return no of components-1\\n        return connectedComponents-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3330395,
                "title": "easy-solutions-in-java-python-and-c-look-at-once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks us to connect all the computers in a network using a minimum number of cables. We can consider each connected component in the network as a separate graph, and we need to connect all the separate graphs into a single graph. We can use the Union-Find algorithm to keep track of the connected components and connect them as required.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. If the number of connections is less than n-1, it is not possible to connect all the computers, so return -1.\\n2. Initialize the parent array for the Union-Find algorithm, where parent[i] is the parent of computer i.\\n3. Union the connected computers by iterating over the connections array and finding their parent using the find operation in the Union-Find algorithm.\\n4. Count the number of disjoint sets (connected components) by iterating over the parent array and counting the number of nodes where parent[i] is equal to i.\\n5. The number of cables needed to connect all the computers is equal to the number of disjoint sets minus 1.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n + Elog(V)), where n is the number of computers, E is the number of connections, and V is the number of disjoint sets. The Union-Find algorithm has a time complexity of O(Elog(V)), and we need to iterate over the connections array once, which takes O(E) time. Counting the number of disjoint sets takes O(n) time.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n), as we need to store the parent array for the Union-Find algorithm.\\n\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n# Code\\n``` Java []\\nclass Solution {\\n    public int makeConnected(int n, int[][] connections) {\\n        // if there are not enough cables to connect all computers, return -1\\n        if (connections.length < n - 1) {\\n            return -1;\\n        }\\n        \\n        // initialize parent array for Union-Find algorithm\\n        int[] parent = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n        \\n        // union connected computers\\n        for (int[] connection : connections) {\\n            int parent1 = findParent(parent, connection[0]);\\n            int parent2 = findParent(parent, connection[1]);\\n            if (parent1 != parent2) {\\n                parent[parent1] = parent2;\\n            }\\n        }\\n        \\n        // count the number of disjoint sets (connected components)\\n        int numSets = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (parent[i] == i) {\\n                numSets++;\\n            }\\n        }\\n        \\n        // the number of cables needed is equal to the number of disjoint sets minus 1\\n        return numSets - 1;\\n    }\\n    \\n    // find the parent of the given node in the Union-Find algorithm\\n    private int findParent(int[] parent, int node) {\\n        if (parent[node] != node) {\\n            parent[node] = findParent(parent, parent[node]);\\n        }\\n        return parent[node];\\n    }\\n}\\n\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        // if there are not enough cables to connect all computers, return -1\\n        if (connections.size() < n - 1) {\\n            return -1;\\n        }\\n        \\n        // initialize parent array for Union-Find algorithm\\n        vector<int> parent(n);\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n        \\n        // union connected computers\\n        for (auto connection : connections) {\\n            int parent1 = findParent(parent, connection[0]);\\n            int parent2 = findParent(parent, connection[1]);\\n            if (parent1 != parent2) {\\n                parent[parent1] = parent2;\\n            }\\n        }\\n        \\n        // count the number of disjoint sets (connected components)\\n        int numSets = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (parent[i] == i) {\\n                numSets++;\\n            }\\n        }\\n        \\n        // the number of cables needed is equal to the number of disjoint sets minus 1\\n        return numSets - 1;\\n    }\\n    \\n    // find the parent of the given node in the Union-Find algorithm\\n    int findParent(vector<int>& parent, int node) {\\n        if (parent[node] != node) {\\n            parent[node] = findParent(parent, parent[node]);\\n        }\\n        return parent[node];\\n    }\\n};\\n\\n```\\n``` Python []\\nclass Solution(object):\\n    def makeConnected(self, n, connections):\\n        # if there are not enough cables to connect all computers, return -1\\n        if len(connections) < n - 1:\\n            return -1\\n        \\n        # initialize parent array for Union-Find algorithm\\n        parent = [i for i in range(n)]\\n        \\n        # union connected computers\\n        for connection in connections:\\n            parent1 = self.findParent(parent, connection[0])\\n            parent2 = self.findParent(parent, connection[1])\\n            if parent1 != parent2:\\n                parent[parent1] = parent2\\n        \\n        # count the number of disjoint sets (connected components)\\n        numSets = 0\\n        for i in range(n):\\n            if parent[i] == i:\\n                numSets += 1\\n        \\n        # the number of cables needed is equal to the number of disjoint sets minus 1\\n        return numSets - 1\\n    \\n    # find the parent of the given node in the Union-Find algorithm\\n    def findParent(self, parent, node):\\n        if parent[node] != node:\\n            parent[node] = self.findParent(parent, parent[node])\\n        return parent[node]\\n\\n```\\n\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Depth-First Search",
                    "Union Find"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n``` Java []\\nclass Solution {\\n    public int makeConnected(int n, int[][] connections) {\\n        // if there are not enough cables to connect all computers, return -1\\n        if (connections.length < n - 1) {\\n            return -1;\\n        }\\n        \\n        // initialize parent array for Union-Find algorithm\\n        int[] parent = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n        \\n        // union connected computers\\n        for (int[] connection : connections) {\\n            int parent1 = findParent(parent, connection[0]);\\n            int parent2 = findParent(parent, connection[1]);\\n            if (parent1 != parent2) {\\n                parent[parent1] = parent2;\\n            }\\n        }\\n        \\n        // count the number of disjoint sets (connected components)\\n        int numSets = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (parent[i] == i) {\\n                numSets++;\\n            }\\n        }\\n        \\n        // the number of cables needed is equal to the number of disjoint sets minus 1\\n        return numSets - 1;\\n    }\\n    \\n    // find the parent of the given node in the Union-Find algorithm\\n    private int findParent(int[] parent, int node) {\\n        if (parent[node] != node) {\\n            parent[node] = findParent(parent, parent[node]);\\n        }\\n        return parent[node];\\n    }\\n}\\n\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        // if there are not enough cables to connect all computers, return -1\\n        if (connections.size() < n - 1) {\\n            return -1;\\n        }\\n        \\n        // initialize parent array for Union-Find algorithm\\n        vector<int> parent(n);\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n        \\n        // union connected computers\\n        for (auto connection : connections) {\\n            int parent1 = findParent(parent, connection[0]);\\n            int parent2 = findParent(parent, connection[1]);\\n            if (parent1 != parent2) {\\n                parent[parent1] = parent2;\\n            }\\n        }\\n        \\n        // count the number of disjoint sets (connected components)\\n        int numSets = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (parent[i] == i) {\\n                numSets++;\\n            }\\n        }\\n        \\n        // the number of cables needed is equal to the number of disjoint sets minus 1\\n        return numSets - 1;\\n    }\\n    \\n    // find the parent of the given node in the Union-Find algorithm\\n    int findParent(vector<int>& parent, int node) {\\n        if (parent[node] != node) {\\n            parent[node] = findParent(parent, parent[node]);\\n        }\\n        return parent[node];\\n    }\\n};\\n\\n```\n``` Python []\\nclass Solution(object):\\n    def makeConnected(self, n, connections):\\n        # if there are not enough cables to connect all computers, return -1\\n        if len(connections) < n - 1:\\n            return -1\\n        \\n        # initialize parent array for Union-Find algorithm\\n        parent = [i for i in range(n)]\\n        \\n        # union connected computers\\n        for connection in connections:\\n            parent1 = self.findParent(parent, connection[0])\\n            parent2 = self.findParent(parent, connection[1])\\n            if parent1 != parent2:\\n                parent[parent1] = parent2\\n        \\n        # count the number of disjoint sets (connected components)\\n        numSets = 0\\n        for i in range(n):\\n            if parent[i] == i:\\n                numSets += 1\\n        \\n        # the number of cables needed is equal to the number of disjoint sets minus 1\\n        return numSets - 1\\n    \\n    # find the parent of the given node in the Union-Find algorithm\\n    def findParent(self, parent, node):\\n        if parent[node] != node:\\n            parent[node] = self.findParent(parent, parent[node])\\n        return parent[node]\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668626,
                "title": "java-simple-solution-union-find-disjoint-set-with-comments",
                "content": "**(*Don\\'t worry the code seems lengthy but easy to understand*)**\\n**Steps to solve the problem** \\n\\n**1.** Find the total number of loops/cycles in the given graph.\\n**2.** Find total number of isolated components (computers).\\n**3.** If we have a cycle means we have an extra connection(wire) which we can use to connect the unconnected components.\\n**4.** So we can return total number of unconnected components(computers) as an answer because that much amount of wires will be required optimally to connect them with the graph,only if we have sufficiant extra wires, i.e cycles >= unconnected components.\\n\\nTo find the total cycles we are using Union Find method, where we are maintaining a parent array to store ultimate parents of every node/component.\\nWe can determine whether 2 nodes are in the same connected component or not in the graph.\\n\\n```\\nclass Solution {\\n    public int makeConnected(int n, int[][] connections) {\\n        int[] parent = new int[n];  // Array to find the ultimate parent in union find method.\\n        \\n        for(int i=0;i<n;i++) parent[i] = i;  // At first all the elements are not connected we combine them gradually according to our given graph of connections.\\n        \\n        int cycles = 0;  // Variable to store total number of cycles/loops.\\n        \\n        int unconnected_computers = 0;  // variable to store total unconnected components.\\n        \\n        for(int[] link : connections) {\\n            \\n            int from = link[0];\\n            int to = link[1];\\n            \\n            if(find_parent(from, parent) == find_parent(to, parent)) cycles++;  // if parent of one node is equal to parent of other node which implies that both nodes are connected previously and forms a cycle with this union.\\n            \\n            union(from, to, parent);\\n            \\n        }\\n        \\n        // loop to count total number of unconnected components.\\n        for(int i=0;i<n;i++) {\\n            if(parent[i] == i) unconnected_computers++;\\n        }\\n    \\n        // Number of cycles represents Number of extra connections, which we can use to connect the unconnected computers.\\n        if(cycles >= unconnected_computers-1) return unconnected_computers-1;\\n        return -1;\\n    }\\n    \\n    // Method to find parent of every node.\\n    public int find_parent(int node, int[] parent) {\\n        if(parent[node] == node) return node;\\n        return find_parent(parent[node], parent);\\n    }\\n    \\n    // Method to create the union of two sets.\\n    public void union(int from, int to, int[] parent) {\\n        from = find_parent(from, parent);\\n        to = find_parent(to, parent);\\n        \\n        parent[to] = from;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public int makeConnected(int n, int[][] connections) {\\n        int[] parent = new int[n];  // Array to find the ultimate parent in union find method.\\n        \\n        for(int i=0;i<n;i++) parent[i] = i;  // At first all the elements are not connected we combine them gradually according to our given graph of connections.\\n        \\n        int cycles = 0;  // Variable to store total number of cycles/loops.\\n        \\n        int unconnected_computers = 0;  // variable to store total unconnected components.\\n        \\n        for(int[] link : connections) {\\n            \\n            int from = link[0];\\n            int to = link[1];\\n            \\n            if(find_parent(from, parent) == find_parent(to, parent)) cycles++;  // if parent of one node is equal to parent of other node which implies that both nodes are connected previously and forms a cycle with this union.\\n            \\n            union(from, to, parent);\\n            \\n        }\\n        \\n        // loop to count total number of unconnected components.\\n        for(int i=0;i<n;i++) {\\n            if(parent[i] == i) unconnected_computers++;\\n        }\\n    \\n        // Number of cycles represents Number of extra connections, which we can use to connect the unconnected computers.\\n        if(cycles >= unconnected_computers-1) return unconnected_computers-1;\\n        return -1;\\n    }\\n    \\n    // Method to find parent of every node.\\n    public int find_parent(int node, int[] parent) {\\n        if(parent[node] == node) return node;\\n        return find_parent(parent[node], parent);\\n    }\\n    \\n    // Method to create the union of two sets.\\n    public void union(int from, int to, int[] parent) {\\n        from = find_parent(from, parent);\\n        to = find_parent(to, parent);\\n        \\n        parent[to] = from;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 679179,
                "title": "easy-java-dfs-method",
                "content": "```\\nclass Solution {\\n    public int makeConnected(int n, int[][] connections) {\\n        if(n>connections.length+1)\\n            return -1;\\n        Map<Integer,List<Integer>> graph=new HashMap<>();\\n        for(int i=0;i<n;i++)\\n            graph.put(i,new ArrayList<Integer>());\\n        for(int[] row:connections){\\n            graph.get(row[0]).add(row[1]);\\n            graph.get(row[1]).add(row[0]);\\n        }\\n        int ans=0;\\n        boolean[] visited=new boolean[n];\\n        for(int i=0;i<n;i++){\\n            if(!visited[i]){\\n                dfsUtil(i,graph,visited);\\n                ans++;\\n            }\\n        }\\n        return ans-1;\\n    }\\n    public void dfsUtil(int i,Map<Integer,List<Integer>> graph,boolean[] visited){\\n        visited[i]=true;\\n        for(int nei:graph.get(i)){\\n            if(!visited[nei])\\n                dfsUtil(nei,graph,visited);\\n        }\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int makeConnected(int n, int[][] connections) {\\n        if(n>connections.length+1)\\n            return -1;\\n        Map<Integer,List<Integer>> graph=new HashMap<>();\\n        for(int i=0;i<n;i++)\\n            graph.put(i,new ArrayList<Integer>());\\n        for(int[] row:connections){\\n            graph.get(row[0]).add(row[1]);\\n            graph.get(row[1]).add(row[0]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 540276,
                "title": "python-3-union-find-easy-to-understand",
                "content": "\\n```\\nclass Solution:``\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        parent = list(range(n))\\n        self.count = n\\n        self.redundant = 0\\n        def find(x):\\n            if x != parent[x]:\\n                parent[x] = find(parent[x])\\n            return parent[x]\\n        def union(x,y):\\n            rootx = find(x)\\n            rooty = find(y)\\n            if rootx != rooty:\\n                parent[rootx] = rooty\\n                self.count -= 1\\n            else:\\n                self.redundant +=1\\n        \\n        for x, y in connections:\\n            union(x, y)\\n        \\n        if self.redundant >= self.count - 1:\\n            return self.count - 1\\n        else:\\n            return -1\\n\\t\\t\\t\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:``\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        parent = list(range(n))\\n        self.count = n\\n        self.redundant = 0\\n        def find(x):\\n            if x != parent[x]:\\n                parent[x] = find(parent[x])\\n            return parent[x]\\n        def union(x,y):\\n            rootx = find(x)\\n            rooty = find(y)\\n            if rootx != rooty:\\n                parent[rootx] = rooty\\n                self.count -= 1\\n            else:\\n                self.redundant +=1\\n        \\n        for x, y in connections:\\n            union(x, y)\\n        \\n        if self.redundant >= self.count - 1:\\n            return self.count - 1\\n        else:\\n            return -1\\n\\t\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3331840,
                "title": "easy-to-understand-code-with-detailed-explanation",
                "content": "# Approach\\nThe problem requires us to determine the minimum number of cables that need to be added to an existing network of computers to make all the computers connected. If this is not possible, we need to return -1.\\n\\nThe solution follows a simple algorithmic approach:\\n\\n1. Check if the number of cables in the network is less than the minimum required to connect all the computers. If yes, return -1 since it is not possible to connect all computers.\\n\\n2. Create a graph data structure from the existing network by iterating through the connections and creating an adjacency list of neighbors for each computer. Since the connections are bi-directional, we add each computer to the other computer\\'s adjacency list.\\n\\n3. Use Depth First Search (DFS) to traverse the graph and count the number of separate networks. We initialize a count variable `networkCount` to 0, and we traverse the graph starting from each unvisited computer node. For each unvisited node, we mark it as visited, then traverse its neighbors recursively using DFS. The DFS traversal will cover all the connected nodes in **a particular network**. After the traversal is complete, we increment `networkCount` to indicate that we have discovered a separate network.\\n\\n4. Return `networkCount - 1` since the minimum number of cables required to connect all the computers equals the number of networks in the graph minus one. This is because each cable connects two computers, and we need to have a single network, so we need `networkCount - 1` cables to connect all the separate networks.\\n\\n## JavaScript Code\\n```\\nvar makeConnected = function (n, connections) {\\n  // If number of connections is less than required to connect all the nodes\\n  // then it\\'s not possible to connect all computers\\n  if (connections.length < n - 1) return -1;\\n\\n  // create an empty object to store the neighbors of each node\\n  let neighbors = {};\\n\\n  // create an array to track whether each node has been visited during traversal\\n  let isVisited = Array(n).fill(false);\\n\\n  // initialize each node\\'s neighbors array to be empty\\n  for (let node = 0; node < n; node++) neighbors[node] = [];\\n\\n  // Loop through each connection and add each node to the other\\'s list of neighbors\\n  for (const connection of connections) {\\n    neighbors[connection[0]].push(connection[1]);\\n    neighbors[connection[1]].push(connection[0]);\\n  }\\n\\n  // initialize a counter for the number of separate networks in the network\\n  let networkCount = 0;\\n\\n  // loop through each node in the network\\n  for (let node = 0; node < n; node++) {\\n    // if the node has not been visited yet, traverse its network of connected nodes\\n    if (!isVisited[node]) {\\n      traverseNetwork(node);\\n      // increment the network count because we have found another separate network\\n      networkCount++;\\n    }\\n  }\\n\\n  // The number of additional connections needed to connect all computers is equal to the\\n  // number of networks found minus 1 (since one connection connects 2 networks)\\n  return networkCount - 1;\\n\\n  // This is a recursive function that performs a depth-first search traversal of the network\\n  // starting at the given source node. It marks each visited node as visited in the isVisited array.\\n  // The purpose of this function is to find all the nodes that are connected to the same network.\\n  function traverseNetwork(sourceNode) {\\n    isVisited[sourceNode] = true;\\n\\n    // For each neighbor of the source node, if the neighbor has not been visited,\\n    // perform a recursive traversal from the neighbor node.\\n    for (const neighborNode of neighbors[sourceNode]) {\\n      if (!isVisited[neighborNode]) {\\n        traverseNetwork(neighborNode);\\n      }\\n    }\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nvar makeConnected = function (n, connections) {\\n  // If number of connections is less than required to connect all the nodes\\n  // then it\\'s not possible to connect all computers\\n  if (connections.length < n - 1) return -1;\\n\\n  // create an empty object to store the neighbors of each node\\n  let neighbors = {};\\n\\n  // create an array to track whether each node has been visited during traversal\\n  let isVisited = Array(n).fill(false);\\n\\n  // initialize each node\\'s neighbors array to be empty\\n  for (let node = 0; node < n; node++) neighbors[node] = [];\\n\\n  // Loop through each connection and add each node to the other\\'s list of neighbors\\n  for (const connection of connections) {\\n    neighbors[connection[0]].push(connection[1]);\\n    neighbors[connection[1]].push(connection[0]);\\n  }\\n\\n  // initialize a counter for the number of separate networks in the network\\n  let networkCount = 0;\\n\\n  // loop through each node in the network\\n  for (let node = 0; node < n; node++) {\\n    // if the node has not been visited yet, traverse its network of connected nodes\\n    if (!isVisited[node]) {\\n      traverseNetwork(node);\\n      // increment the network count because we have found another separate network\\n      networkCount++;\\n    }\\n  }\\n\\n  // The number of additional connections needed to connect all computers is equal to the\\n  // number of networks found minus 1 (since one connection connects 2 networks)\\n  return networkCount - 1;\\n\\n  // This is a recursive function that performs a depth-first search traversal of the network\\n  // starting at the given source node. It marks each visited node as visited in the isVisited array.\\n  // The purpose of this function is to find all the nodes that are connected to the same network.\\n  function traverseNetwork(sourceNode) {\\n    isVisited[sourceNode] = true;\\n\\n    // For each neighbor of the source node, if the neighbor has not been visited,\\n    // perform a recursive traversal from the neighbor node.\\n    for (const neighborNode of neighbors[sourceNode]) {\\n      if (!isVisited[neighborNode]) {\\n        traverseNetwork(neighborNode);\\n      }\\n    }\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1479008,
                "title": "c-90-faster-union-find-comments-for-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    //Find Parent function\\n \\tint find(int x, vector<int>& parent) {\\n \\t\\tif (parent[x] == x) return parent[x];\\n        return parent[x] = find(parent[x], parent);\\n \\t}\\n    \\n    //Main Problem Solver Function\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        \\n        //Initializing parent array with their own parent values\\n        vector<int> parent(n);\\n        for(int i=0; i<n; i++){\\n            parent[i] = i;\\n        }\\n        \\n        //For counting components\\n \\t\\tint compo = 0;\\n        \\n        for (auto& it: connections) {\\n \\t\\t\\tint x = find(it[0], parent);\\n \\t\\t\\tint y = find(it[1], parent);\\n \\t\\t\\t\\n            //If parent are same that means they were connected and now again they are being connected so continue/skip\\n            if (x == y){\\n                continue;\\n            }\\n            \\n            //If Parent not same, then Union them and increment compo.\\n            else {\\n                parent[y] = x; //union\\n                compo++;\\n            }\\n \\t\\t}\\n        \\n        //We know to connect n computers we need n-1 cables so if connections.size() < n-1 return -1\\n\\t\\t//else required - already connected and i.e. (n-1) - (components)\\n        return connections.size() < n-1 ? -1 : n-1-compo;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    //Find Parent function\\n \\tint find(int x, vector<int>& parent) {\\n \\t\\tif (parent[x] == x) return parent[x];\\n        return parent[x] = find(parent[x], parent);\\n \\t}\\n    \\n    //Main Problem Solver Function\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        \\n        //Initializing parent array with their own parent values\\n        vector<int> parent(n);\\n        for(int i=0; i<n; i++){\\n            parent[i] = i;\\n        }\\n        \\n        //For counting components\\n \\t\\tint compo = 0;\\n        \\n        for (auto& it: connections) {\\n \\t\\t\\tint x = find(it[0], parent);\\n \\t\\t\\tint y = find(it[1], parent);\\n \\t\\t\\t\\n            //If parent are same that means they were connected and now again they are being connected so continue/skip\\n            if (x == y){\\n                continue;\\n            }\\n            \\n            //If Parent not same, then Union them and increment compo.\\n            else {\\n                parent[y] = x; //union\\n                compo++;\\n            }\\n \\t\\t}\\n        \\n        //We know to connect n computers we need n-1 cables so if connections.size() < n-1 return -1\\n\\t\\t//else required - already connected and i.e. (n-1) - (components)\\n        return connections.size() < n-1 ? -1 : n-1-compo;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3352288,
                "title": "day-82-dfs-easiest-beginner-friendly-sol",
                "content": "**NOTE - PLEASE READ INTUITION AND APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Intuition of this Problem :\\nThe logic behind the code is to use depth-first search (DFS) to traverse the network and count the number of connected components. We can use DFS to find all the computers that are reachable from a given computer, and mark them as visited.\\n\\nThe DFS function takes the network, the visited vector, and the index of the source computer as input. It first marks the source computer as visited, and then iterates through all the adjacent computers of the source computer. For each unvisited adjacent computer, the DFS function is called recursively.\\n\\nIn the main function, we iterate through all the computers in the network, and call the DFS function on each unvisited computer. For each call to the DFS function, we increment a counter that keeps track of the number of connected components in the network.\\n\\nFinally, we return the number of connected components minus one, since we need to perform one operation to connect each component.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach for this Problem :\\n1. If the size of connections is less than n - 1, return -1.\\n2. Create an adjacency list for each computer.\\n3. Create a visited boolean vector of size n.\\n4. Initialize minOperations to zero.\\n5. For each computer in the network:\\n    - a. If the computer is not visited, perform dfs on the network starting from that computer.\\n    - b. Mark all the visited computers.\\n    - c. Increment minOperations by one.\\n1. Return minOperations - 1 as the minimum number of operations.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code :\\n```C++ []\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& network, vector<bool>& visited, int srcComputer) {\\n        visited[srcComputer] = true;\\n        for (int adjComputer : network[srcComputer]) {\\n            if (!visited[adjComputer]) {\\n                dfs(network, visited, adjComputer);  \\n            }\\n        }\\n    }\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        if (connections.size() < n - 1)\\n            return -1;\\n        vector<vector<int>> network(n);\\n        for (auto connection : connections) {\\n            network[connection[0]].push_back(connection[1]);\\n            network[connection[1]].push_back(connection[0]);\\n        }\\n        //this type of dfs pattern we generally use when we want to find our ans in disconnected part\\n        vector<bool> visited(n, false);\\n        int minOperations = 0;\\n        for (int computer = 0; computer < n; computer++) {\\n            if (!visited[computer]) {\\n                dfs(network, visited, computer);\\n                minOperations++;\\n            }\\n        }\\n        return minOperations - 1;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public void dfs(List<List<Integer>> network, boolean[] visited, int srcComputer) {\\n        visited[srcComputer] = true;\\n        for (int adjComputer : network.get(srcComputer)) {\\n            if (!visited[adjComputer]) {\\n                dfs(network, visited, adjComputer);  \\n            }\\n        }\\n    }\\n    \\n    public int makeConnected(int n, List<List<Integer>> connections) {\\n        if (connections.size() < n - 1)\\n            return -1;\\n        \\n        List<List<Integer>> network = new ArrayList<>(n);\\n        for (int i = 0; i < n; i++) {\\n            network.add(new ArrayList<>());\\n        }\\n        \\n        for (List<Integer> connection : connections) {\\n            network.get(connection.get(0)).add(connection.get(1));\\n            network.get(connection.get(1)).add(connection.get(0));\\n        }\\n        \\n        boolean[] visited = new boolean[n];\\n        int minOperations = 0;\\n        for (int computer = 0; computer < n; computer++) {\\n            if (!visited[computer]) {\\n                dfs(network, visited, computer);\\n                minOperations++;\\n            }\\n        }\\n        return minOperations - 1;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def dfs(self, network, visited, srcComputer):\\n        visited[srcComputer] = True\\n        for adjComputer in network[srcComputer]:\\n            if not visited[adjComputer]:\\n                self.dfs(network, visited, adjComputer)\\n    \\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        if len(connections) < n - 1:\\n            return -1\\n        \\n        network = [[] for i in range(n)]\\n        for connection in connections:\\n            network[connection[0]].append(connection[1])\\n            network[connection[1]].append(connection[0])\\n        \\n        visited = [False] * n\\n        minOperations = 0\\n        for computer in range(n):\\n            if not visited[computer]:\\n                self.dfs(network, visited, computer)\\n                minOperations += 1\\n        \\n        return minOperations - 1\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- **Time complexity :** \\n\\nThe time complexity of the algorithm depends on the number of edges and vertices in the network. The dfs function visits each vertex at most once, and for each vertex, it visits all its adjacent vertices. Therefore, the time complexity of the dfs function is **O(V + E), where V is the number of vertices and E is the number of edges in the network.**\\n\\nIn the main function, we perform dfs for each unvisited computer in the network, which takes O(V + E) time. Therefore, the total time complexity of the algorithm is **O(V + E), where V is the number of computers and E is the number of connections.**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity :**\\n\\nThe space complexity of the algorithm depends on the size of the input and the size of the auxiliary data structures used.\\n\\nWe use a boolean vector of size n to keep track of visited computers, so the space complexity is O(n).\\n\\nWe also use an adjacency list to represent the network, which takes O(E) space, where E is the number of connections.\\n\\nTherefore, **the total space complexity of the algorithm is O(n + E).**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& network, vector<bool>& visited, int srcComputer) {\\n        visited[srcComputer] = true;\\n        for (int adjComputer : network[srcComputer]) {\\n            if (!visited[adjComputer]) {\\n                dfs(network, visited, adjComputer);  \\n            }\\n        }\\n    }\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        if (connections.size() < n - 1)\\n            return -1;\\n        vector<vector<int>> network(n);\\n        for (auto connection : connections) {\\n            network[connection[0]].push_back(connection[1]);\\n            network[connection[1]].push_back(connection[0]);\\n        }\\n        //this type of dfs pattern we generally use when we want to find our ans in disconnected part\\n        vector<bool> visited(n, false);\\n        int minOperations = 0;\\n        for (int computer = 0; computer < n; computer++) {\\n            if (!visited[computer]) {\\n                dfs(network, visited, computer);\\n                minOperations++;\\n            }\\n        }\\n        return minOperations - 1;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public void dfs(List<List<Integer>> network, boolean[] visited, int srcComputer) {\\n        visited[srcComputer] = true;\\n        for (int adjComputer : network.get(srcComputer)) {\\n            if (!visited[adjComputer]) {\\n                dfs(network, visited, adjComputer);  \\n            }\\n        }\\n    }\\n    \\n    public int makeConnected(int n, List<List<Integer>> connections) {\\n        if (connections.size() < n - 1)\\n            return -1;\\n        \\n        List<List<Integer>> network = new ArrayList<>(n);\\n        for (int i = 0; i < n; i++) {\\n            network.add(new ArrayList<>());\\n        }\\n        \\n        for (List<Integer> connection : connections) {\\n            network.get(connection.get(0)).add(connection.get(1));\\n            network.get(connection.get(1)).add(connection.get(0));\\n        }\\n        \\n        boolean[] visited = new boolean[n];\\n        int minOperations = 0;\\n        for (int computer = 0; computer < n; computer++) {\\n            if (!visited[computer]) {\\n                dfs(network, visited, computer);\\n                minOperations++;\\n            }\\n        }\\n        return minOperations - 1;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def dfs(self, network, visited, srcComputer):\\n        visited[srcComputer] = True\\n        for adjComputer in network[srcComputer]:\\n            if not visited[adjComputer]:\\n                self.dfs(network, visited, adjComputer)\\n    \\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        if len(connections) < n - 1:\\n            return -1\\n        \\n        network = [[] for i in range(n)]\\n        for connection in connections:\\n            network[connection[0]].append(connection[1])\\n            network[connection[1]].append(connection[0])\\n        \\n        visited = [False] * n\\n        minOperations = 0\\n        for computer in range(n):\\n            if not visited[computer]:\\n                self.dfs(network, visited, computer)\\n                minOperations += 1\\n        \\n        return minOperations - 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3330401,
                "title": "complete-intuition-explained-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/c2f42477-c6e4-45ad-8185-776b03252aeb_1679532996.0526953.png)\\n![image](https://assets.leetcode.com/users/images/52f1efb2-1dd6-46c7-95f4-16d2c2e97db8_1679533004.0631475.png)\\n\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&adj, vector<bool>&visited, int currNode)\\n    { \\n        visited[currNode] = true;\\n        for (int adjNode : adj[currNode])\\n        {\\n            if (visited[adjNode]) continue;\\n            dfs(adj, visited, adjNode);\\n        }\\n    }\\n    int makeConnected(int n, vector<vector<int>>& connections) \\n    {\\n        int currWireCount = connections.size();\\n        int requiredWireCount = n - 1;\\n        if (currWireCount < requiredWireCount) return -1;\\n        //========================================================\\n        vector<vector<int>>adj(n);\\n        for (vector<int>connection : connections)\\n        {\\n            adj[connection[0]].push_back(connection[1]);\\n            adj[connection[1]].push_back(connection[0]);\\n        }\\n        //==========================================================\\n        vector<bool>visited(n, false);\\n        int componentCount = 0;\\n        for (int node = 0; node < n; node++)\\n        {\\n            if (visited[node]) continue;\\n            dfs(adj, visited, node);\\n            componentCount++;\\n        }\\n        //===========================================================\\n        return componentCount - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&adj, vector<bool>&visited, int currNode)\\n    { \\n        visited[currNode] = true;\\n        for (int adjNode : adj[currNode])\\n        {\\n            if (visited[adjNode]) continue;\\n            dfs(adj, visited, adjNode);\\n        }\\n    }\\n    int makeConnected(int n, vector<vector<int>>& connections) \\n    {\\n        int currWireCount = connections.size();\\n        int requiredWireCount = n - 1;\\n        if (currWireCount < requiredWireCount) return -1;\\n        //========================================================\\n        vector<vector<int>>adj(n);\\n        for (vector<int>connection : connections)\\n        {\\n            adj[connection[0]].push_back(connection[1]);\\n            adj[connection[1]].push_back(connection[0]);\\n        }\\n        //==========================================================\\n        vector<bool>visited(n, false);\\n        int componentCount = 0;\\n        for (int node = 0; node < n; node++)\\n        {\\n            if (visited[node]) continue;\\n            dfs(adj, visited, node);\\n            componentCount++;\\n        }\\n        //===========================================================\\n        return componentCount - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299765,
                "title": "python3-dfs-solution",
                "content": "```\\nclass Solution:\\n    def makeConnected(self, n: int, a: List[List[int]]) -> int:\\n        length = len(a)\\n        if length < n - 1:\\n            return -1\\n        nodes = set()\\n        connections = defaultdict(list)\\n        \\n        for src,dest in a:\\n            connections[src].append(dest)\\n            connections[dest].append(src)\\n        \\n        def dfs(src):\\n            if src in nodes:\\n                return\\n            nodes.add(src)\\n            for node in connections[src]:\\n                dfs(node)\\n            \\n        \\n        result = 0\\n        for i in range(n):\\n            if i not in nodes:\\n                dfs(i)\\n                result+=1\\n        \\n        return result - 1\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def makeConnected(self, n: int, a: List[List[int]]) -> int:\\n        length = len(a)\\n        if length < n - 1:\\n            return -1\\n        nodes = set()\\n        connections = defaultdict(list)\\n        \\n        for src,dest in a:\\n            connections[src].append(dest)\\n            connections[dest].append(src)\\n        \\n        def dfs(src):\\n            if src in nodes:\\n                return\\n            nodes.add(src)\\n            for node in connections[src]:\\n                dfs(node)\\n            \\n        \\n        result = 0\\n        for i in range(n):\\n            if i not in nodes:\\n                dfs(i)\\n                result+=1\\n        \\n        return result - 1\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1861718,
                "title": "javascript-clean-union-find-w-explanation-99",
                "content": "Version W/o Explanation (see below for commented):\\n```\\nconst makeConnected = (n, connections) => {\\n  const parent = Array(n).fill(-1); \\n  let spare = 0, notConnected = n - 1\\n  \\n  for (let [node, connection] of connections) {\\n    if (find(node) !== find(connection)) {\\n      union(node, connection);\\n      notConnected--;\\n    } else spare++;\\n  }\\n  \\n  return notConnected <= spare ? notConnected : -1;\\n  \\n  function find(node) {\\n    if (parent[node] === -1) return node\\n    parent[node] = find(parent[node])\\n    return parent[node]\\n  }\\n  \\n  function union(node1, node2) {\\n    const parent1 = find(node1), parent2 = find(node2);\\n    if (parent1 !== parent2) parent[parent2] = parent1;\\n  }\\n};\\n```\\n\\nVersion w/ Explanation:\\n```\\nconst makeConnected = (n, connections) => {\\n  //Initialize our UnionFind Array.  Basic intuition is that indexes \\n  //stand for nodes, -1 means they aren\\'t connected to anything.\\n  //As our Union function runs, it will create these connections.\\n  //Find will tell us what group nodes belong to.\\n  const parent = Array(n).fill(-1); \\n  \\n  //Spare tracks how many unnecessary connections we have -\\n  //If we try to connect two computers already in the same group, \\n  //we increment spare.  Not connected tracks how many \\n  //Are not in groups. -1 is because one cable connectes two computers.\\n  //You need five cables to connect six computers, not six, etc.\\n  let spare = 0, notConnected = n - 1\\n  \\n  //Iterate through node / connections.  If both nodes aren\\'t in the same group -\\n  //I.e. Are not already connected, we connect them and decrement the not\\n  //connected counter.  If we get a connection for two computers that are already\\n  //connected, we increment the spare counter.\\n  for (let [node, connection] of connections) {\\n    if (find(node) !== find(connection)) {\\n      union(node, connection);\\n      notConnected--;\\n    } else spare++;\\n  }\\n  \\n  //If our count of unconnected computers is less than our spares,\\n  //We simply return the not connected number.  Else, we can\\'t\\n  //connect them all and return -1.\\n  return notConnected <= spare ? notConnected : -1;\\n  \\n  //Standard find function.  If node at idx === -1 it belongs\\n  //in it\\'s own group / to itself.  If not, we dfs to find the parent node.\\n  //Parent node is the \\'chosen\\' one to represent the group.  If we union\\n  //1 and 2 for example, we pick either 1 or 2 to be the \\'group representative\\'.\\n  function find(node) {\\n    if (parent[node] === -1) return node\\n    parent[node] = find(parent[node])\\n    return parent[node]\\n  }\\n  \\n  //Standard union.  We check to make sure nodes aren\\'t already in the same\\n  //group first.  If not, we set parent[parent2] = parent1.  Works the same way\\n  //around if we pick parent[parent1] = parent2.  Just need to arbitrarily pick\\n  //one to be the \\'group representative\\'.  That said, there is an optimization for\\n  //this algorithm called Union By Rank that will always union smaller groups to \\n  //larger ones to reduce dfs look up times.  That\\'s not implemented here.\\n  function union(node1, node2) {\\n    const parent1 = find(node1), parent2 = find(node2);\\n    if (parent1 !== parent2) parent[parent2] = parent1;\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst makeConnected = (n, connections) => {\\n  const parent = Array(n).fill(-1); \\n  let spare = 0, notConnected = n - 1\\n  \\n  for (let [node, connection] of connections) {\\n    if (find(node) !== find(connection)) {\\n      union(node, connection);\\n      notConnected--;\\n    } else spare++;\\n  }\\n  \\n  return notConnected <= spare ? notConnected : -1;\\n  \\n  function find(node) {\\n    if (parent[node] === -1) return node\\n    parent[node] = find(parent[node])\\n    return parent[node]\\n  }\\n  \\n  function union(node1, node2) {\\n    const parent1 = find(node1), parent2 = find(node2);\\n    if (parent1 !== parent2) parent[parent2] = parent1;\\n  }\\n};\\n```\n```\\nconst makeConnected = (n, connections) => {\\n  //Initialize our UnionFind Array.  Basic intuition is that indexes \\n  //stand for nodes, -1 means they aren\\'t connected to anything.\\n  //As our Union function runs, it will create these connections.\\n  //Find will tell us what group nodes belong to.\\n  const parent = Array(n).fill(-1); \\n  \\n  //Spare tracks how many unnecessary connections we have -\\n  //If we try to connect two computers already in the same group, \\n  //we increment spare.  Not connected tracks how many \\n  //Are not in groups. -1 is because one cable connectes two computers.\\n  //You need five cables to connect six computers, not six, etc.\\n  let spare = 0, notConnected = n - 1\\n  \\n  //Iterate through node / connections.  If both nodes aren\\'t in the same group -\\n  //I.e. Are not already connected, we connect them and decrement the not\\n  //connected counter.  If we get a connection for two computers that are already\\n  //connected, we increment the spare counter.\\n  for (let [node, connection] of connections) {\\n    if (find(node) !== find(connection)) {\\n      union(node, connection);\\n      notConnected--;\\n    } else spare++;\\n  }\\n  \\n  //If our count of unconnected computers is less than our spares,\\n  //We simply return the not connected number.  Else, we can\\'t\\n  //connect them all and return -1.\\n  return notConnected <= spare ? notConnected : -1;\\n  \\n  //Standard find function.  If node at idx === -1 it belongs\\n  //in it\\'s own group / to itself.  If not, we dfs to find the parent node.\\n  //Parent node is the \\'chosen\\' one to represent the group.  If we union\\n  //1 and 2 for example, we pick either 1 or 2 to be the \\'group representative\\'.\\n  function find(node) {\\n    if (parent[node] === -1) return node\\n    parent[node] = find(parent[node])\\n    return parent[node]\\n  }\\n  \\n  //Standard union.  We check to make sure nodes aren\\'t already in the same\\n  //group first.  If not, we set parent[parent2] = parent1.  Works the same way\\n  //around if we pick parent[parent1] = parent2.  Just need to arbitrarily pick\\n  //one to be the \\'group representative\\'.  That said, there is an optimization for\\n  //this algorithm called Union By Rank that will always union smaller groups to \\n  //larger ones to reduce dfs look up times.  That\\'s not implemented here.\\n  function union(node1, node2) {\\n    const parent1 = find(node1), parent2 = find(node2);\\n    if (parent1 !== parent2) parent[parent2] = parent1;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1182150,
                "title": "c-union-find-with-rank-and-path-compression",
                "content": "```\\nclass Solution {\\npublic:\\n    int find(int node, vector<int> &parent){\\n        if(parent[node] == node) return node;\\n\\t\\t// Path compression\\n        return parent[node] = find(parent[node], parent);\\n    }\\n    \\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        if(connections.size() < n-1) return -1;\\n        int comp = 0;\\n        vector<int> parent(n);\\n        vector<int> rank(n);\\n        for(int i=0; i<n; i++){\\n            parent[i] = i;\\n            rank[i] = 0;\\n        }\\n        \\n        for(auto i: connections){\\n            int p1 = find(i[0], parent);\\n            int p2 = find(i[1], parent);\\n            \\n            if(rank[p1] < rank[p2]){\\n                parent[p1] = p2;\\n            }\\n            else if(rank[p2] < rank[p1]){\\n                parent[p2] = p1;\\n            }\\n            else{\\n                parent[p1] = p2;\\n                rank[p2]++;\\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            if(parent[i] == i) comp++;\\n        }\\n        \\n        return comp-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(int node, vector<int> &parent){\\n        if(parent[node] == node) return node;\\n\\t\\t// Path compression\\n        return parent[node] = find(parent[node], parent);\\n    }\\n    \\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        if(connections.size() < n-1) return -1;\\n        int comp = 0;\\n        vector<int> parent(n);\\n        vector<int> rank(n);\\n        for(int i=0; i<n; i++){\\n            parent[i] = i;\\n            rank[i] = 0;\\n        }\\n        \\n        for(auto i: connections){\\n            int p1 = find(i[0], parent);\\n            int p2 = find(i[1], parent);\\n            \\n            if(rank[p1] < rank[p2]){\\n                parent[p1] = p2;\\n            }\\n            else if(rank[p2] < rank[p1]){\\n                parent[p2] = p1;\\n            }\\n            else{\\n                parent[p1] = p2;\\n                rank[p2]++;\\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            if(parent[i] == i) comp++;\\n        }\\n        \\n        return comp-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3330520,
                "title": "python-union-find-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse Union find to count the redundant connections and connected clusters.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        count = 0           # number of redundant connections\\n        network = [i for i in range(n)]\\n\\n        def find(x):\\n            if network[x] != x:\\n                network[x] = find(network[x])\\n            return network[x]\\n        \\n        def union(a, b):\\n            # return True if 2 nodes are already connected.\\n            root_a = find(a)\\n            root_b = find(b)\\n            network[root_a] = root_b\\n            return True if root_a == root_b else False\\n        \\n        for link in connections:\\n            if union(link[0], link[1]):\\n                count += 1\\n\\n        # count the number of connected clusters\\n        a = len(set([find(i) for i in range(n)]))\\n        return -1 if a - 1 > count else a - 1\\n```",
                "solutionTags": [
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        count = 0           # number of redundant connections\\n        network = [i for i in range(n)]\\n\\n        def find(x):\\n            if network[x] != x:\\n                network[x] = find(network[x])\\n            return network[x]\\n        \\n        def union(a, b):\\n            # return True if 2 nodes are already connected.\\n            root_a = find(a)\\n            root_b = find(b)\\n            network[root_a] = root_b\\n            return True if root_a == root_b else False\\n        \\n        for link in connections:\\n            if union(link[0], link[1]):\\n                count += 1\\n\\n        # count the number of connected clusters\\n        a = len(set([find(i) for i in range(n)]))\\n        return -1 if a - 1 > count else a - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2245909,
                "title": "c-2-methods-easy-to-understand",
                "content": "**Please upvote if you like the Solution**\\n\\n### *Method 1: Using DFS*\\n\\n```\\nclass Solution {\\n\\tprivate:\\n    void dfs(int source, vector<vector<int>>& edges, vector<bool>& vis){\\n        vis[source] = true;\\n        for(auto x:edges[source])\\n            if(!vis[x])\\n                dfs(x, edges, vis);\\n        return;\\n    }\\n\\tpublic:\\n    int makeConnected(int n, vector<vector<int>>& conct) {\\n        int sz = conct.size();\\n        if(sz<n-1)      return -1;\\n        vector<bool> vis(n, false);\\n        vector<vector<int>> edges(n);\\n        for(auto it:conct){ \\n            edges[it[0]].push_back(it[1]);\\n            edges[it[1]].push_back(it[0]);\\n        }\\n        int count = 0;\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                count++;\\n                dfs(i, edges, vis);\\n            }\\n        }\\n        return count-1;\\n\\t}\\n};\\n```\\n\\n### *Method 2: Using Union Find: Best Method*\\n```\\nclass Solution {\\nprivate:\\nint findPar(int v, vector<int>& par){\\n        if(par[v]==v)   return v;\\n        return par[v] = findPar(par[v], par);\\n}\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& conct) {\\n\\tint sz = conct.size();\\n    if(sz<n-1)      return -1;\\n\\tvector<int> par(n);\\n        for(int i=0;i<n;i++)\\n            par[i] = i;\\n        \\n        for(auto it:conct){\\n            int a = findPar(it[0], par);\\n            int b = findPar(it[1], par);\\n            if(a!=b)    par[b] = a;\\n        }\\n        int count = 0;\\n        for(int i=0;i<n;i++)\\n            if(par[i]==i)   count++;\\n        return count-1;\\n    }\\n};\\n```\\n\\nPlease Upvote if you like the solution!!!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n\\tprivate:\\n    void dfs(int source, vector<vector<int>>& edges, vector<bool>& vis){\\n        vis[source] = true;\\n        for(auto x:edges[source])\\n            if(!vis[x])\\n                dfs(x, edges, vis);\\n        return;\\n    }\\n\\tpublic:\\n    int makeConnected(int n, vector<vector<int>>& conct) {\\n        int sz = conct.size();\\n        if(sz<n-1)      return -1;\\n        vector<bool> vis(n, false);\\n        vector<vector<int>> edges(n);\\n        for(auto it:conct){ \\n            edges[it[0]].push_back(it[1]);\\n            edges[it[1]].push_back(it[0]);\\n        }\\n        int count = 0;\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                count++;\\n                dfs(i, edges, vis);\\n            }\\n        }\\n        return count-1;\\n\\t}\\n};\\n```\n```\\nclass Solution {\\nprivate:\\nint findPar(int v, vector<int>& par){\\n        if(par[v]==v)   return v;\\n        return par[v] = findPar(par[v], par);\\n}\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& conct) {\\n\\tint sz = conct.size();\\n    if(sz<n-1)      return -1;\\n\\tvector<int> par(n);\\n        for(int i=0;i<n;i++)\\n            par[i] = i;\\n        \\n        for(auto it:conct){\\n            int a = findPar(it[0], par);\\n            int b = findPar(it[1], par);\\n            if(a!=b)    par[b] = a;\\n        }\\n        int count = 0;\\n        for(int i=0;i<n;i++)\\n            if(par[i]==i)   count++;\\n        return count-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 657221,
                "title": "c-simple-union-find-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int find(vector<int> &parent, int v){\\n        int root = v;\\n        while(root != parent[root]){\\n            root = parent[root];\\n        }\\n        \\n        return root;\\n    }\\n    \\n    void unify(vector<int> &parent, int u, int v){\\n        int root_u = find(parent, u);\\n        int root_v = find(parent, v);\\n        \\n        if(root_u == root_v){\\n            return;\\n        }\\n        parent[root_u] = root_v;\\n    }\\n    \\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        int i, j, used = 0, redundent = 0, total = 0;\\n        vector<int> parent(n);\\n        for(i = 0; i < n; i++){\\n            parent[i] = i;\\n        }\\n        \\n        for(i = 0; i < connections.size(); i++){\\n            if(find(parent, connections[i][0]) == find(parent, connections[i][1])){\\n                redundent++;\\n            }else{\\n                used++;\\n                unify(parent, connections[i][0], connections[i][1]);\\n            }\\n        }\\n        \\n        for(i = 0; i < n; i++){\\n            total += parent[i] == i? 1 : 0;\\n        }\\n        \\n        // cout << used << \" \" << redundent << \" \" << total << endl;\\n        return total - 1 <= redundent ? total-1 : -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int find(vector<int> &parent, int v){\\n        int root = v;\\n        while(root != parent[root]){\\n            root = parent[root];\\n        }\\n        \\n        return root;\\n    }\\n    \\n    void unify(vector<int> &parent, int u, int v){\\n        int root_u = find(parent, u);\\n        int root_v = find(parent, v);\\n        \\n        if(root_u == root_v){\\n            return;\\n        }\\n        parent[root_u] = root_v;\\n    }\\n    \\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        int i, j, used = 0, redundent = 0, total = 0;\\n        vector<int> parent(n);\\n        for(i = 0; i < n; i++){\\n            parent[i] = i;\\n        }\\n        \\n        for(i = 0; i < connections.size(); i++){\\n            if(find(parent, connections[i][0]) == find(parent, connections[i][1])){\\n                redundent++;\\n            }else{\\n                used++;\\n                unify(parent, connections[i][0], connections[i][1]);\\n            }\\n        }\\n        \\n        for(i = 0; i < n; i++){\\n            total += parent[i] == i? 1 : 0;\\n        }\\n        \\n        // cout << used << \" \" << redundent << \" \" << total << endl;\\n        return total - 1 <= redundent ? total-1 : -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 479089,
                "title": "python-union-find",
                "content": "```python\\nclass Solution:\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        if len(connections) < n - 1:\\n            return -1\\n        p = {x : x for x in range(n)}\\n        def find(x):\\n            while x != p[x]:\\n                p[x] = p[p[x]]\\n                x = p[x]\\n            return x\\n           \\n        for x, y in connections:\\n            p[find(x)] = find(y)\\n        \\n        return len({find(x) for x in range(n)}) - 1\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        if len(connections) < n - 1:\\n            return -1\\n        p = {x : x for x in range(n)}\\n        def find(x):\\n            while x != p[x]:\\n                p[x] = p[p[x]]\\n                x = p[x]\\n            return x\\n           \\n        for x, y in connections:\\n            p[find(x)] = find(y)\\n        \\n        return len({find(x) for x in range(n)}) - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332605,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    void dfs(vector<int> adj[], vector<bool> &visited, int src)\\n    {\\n        visited[src] = true;\\n        for(int i : adj[src]){\\n            if(!visited[i]){\\n                dfs(adj, visited, i);\\n            }\\n        }\\n    }\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& arr) {\\n        int len = arr.size();\\n        if(len<n-1) return -1;\\n         vector<int> adj[n];\\n        for(auto v : arr)\\n        {\\n            adj[v[0]].push_back(v[1]);\\n            adj[v[1]].push_back(v[0]);\\n        }\\n        vector<bool> visited(n, false);\\n        int ans = 0;\\n        for(int i=0; i<n; i++)\\n        if(!visited[i])\\n        {\\n            dfs(adj, visited, i);\\n            ans++;\\n        }\\n        return ans - 1;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(vector<int> adj[], vector<bool> &visited, int src)\\n    {\\n        visited[src] = true;\\n        for(int i : adj[src]){\\n            if(!visited[i]){\\n                dfs(adj, visited, i);\\n            }\\n        }\\n    }\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& arr) {\\n        int len = arr.size();\\n        if(len<n-1) return -1;\\n         vector<int> adj[n];\\n        for(auto v : arr)\\n        {\\n            adj[v[0]].push_back(v[1]);\\n            adj[v[1]].push_back(v[0]);\\n        }\\n        vector<bool> visited(n, false);\\n        int ans = 0;\\n        for(int i=0; i<n; i++)\\n        if(!visited[i])\\n        {\\n            dfs(adj, visited, i);\\n            ans++;\\n        }\\n        return ans - 1;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3331139,
                "title": "c-dfs-easy-efficient-approach",
                "content": "# Intuition\\nWe can use dfs to find total number of disconnected computers.\\n\\n# Complexity\\n### Time complexity:\\nO(N+E): dfs + O(N+E): creating adjacency list \\n~**O(N+E)**\\n\\n### Space complexity:\\nO(N): visited vector + O(N+E): adjacency list + O(N): recursion auxiliary space\\n~**O(N+E)**\\n\\nwhere N: number of nodes, E: number of edges\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n\\n    //Mark connected computers as visited in vis vector by using dfs.\\n    void dfsConnectedComputers(int node, vector<int> adj[], vector<int> &vis)\\n    {\\n        vis[node]=1;\\n        for(auto &it:adj[node])\\n        {\\n            if(!vis[it])\\n                dfsConnectedComputers(it, adj, vis);\\n        }\\n    }\\n\\n    int makeConnected(int n, vector<vector<int>>& connections) \\n    {\\n        int edges = connections.size();\\n        if(edges<n-1) return -1; //Minimum no. of egdes should be (n-1).\\n        vector<int> adj[n];\\n        for(auto &it:connections) //creating adjacency list\\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n\\n        vector<int> vis(n,0);\\n        int disconnected=0;\\n        \\n        for(int node=0; node<n; node++) //count disconnected computers\\n        {\\n            if(!vis[node]) \\n            {\\n                disconnected++;\\n                dfsConnectedComputers(node, adj, vis);\\n            }\\n        }\\n    \\n        return disconnected-1;\\n    }\\n};\\n```\\n# Please upvote if you like this approach :)",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n\\n    //Mark connected computers as visited in vis vector by using dfs.\\n    void dfsConnectedComputers(int node, vector<int> adj[], vector<int> &vis)\\n    {\\n        vis[node]=1;\\n        for(auto &it:adj[node])\\n        {\\n            if(!vis[it])\\n                dfsConnectedComputers(it, adj, vis);\\n        }\\n    }\\n\\n    int makeConnected(int n, vector<vector<int>>& connections) \\n    {\\n        int edges = connections.size();\\n        if(edges<n-1) return -1; //Minimum no. of egdes should be (n-1).\\n        vector<int> adj[n];\\n        for(auto &it:connections) //creating adjacency list\\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n\\n        vector<int> vis(n,0);\\n        int disconnected=0;\\n        \\n        for(int node=0; node<n; node++) //count disconnected computers\\n        {\\n            if(!vis[node]) \\n            {\\n                disconnected++;\\n                dfsConnectedComputers(node, adj, vis);\\n            }\\n        }\\n    \\n        return disconnected-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3330586,
                "title": "kotlin-easy-union-find",
                "content": "Find the number of the islands, and connect them with `islands - 1`\\n\\n```\\nclass Solution {\\n  private lateinit var parents: IntArray\\n\\n  private fun find(x: Int): Int {\\n    if (parents[x] != x) parents[x] = find(parents[x])\\n    return parents[x]\\n  }\\n  private fun union(x: Int, y: Int) {\\n    val px = find(x)\\n    val py = find(y)\\n    parents[py] = px\\n  }\\n  fun makeConnected(n: Int, connections: Array<IntArray>): Int {\\n    if (connections.size < (n - 1)) return -1\\n    parents = IntArray(n + 1) { it }\\n    for ((a, b) in connections) union(a, b)\\n    var res = 0\\n    for(i in 0 until n)\\n      if (find(i) == i) res++\\n    return res - 1\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n  private lateinit var parents: IntArray\\n\\n  private fun find(x: Int): Int {\\n    if (parents[x] != x) parents[x] = find(parents[x])\\n    return parents[x]\\n  }\\n  private fun union(x: Int, y: Int) {\\n    val px = find(x)\\n    val py = find(y)\\n    parents[py] = px\\n  }\\n  fun makeConnected(n: Int, connections: Array<IntArray>): Int {\\n    if (connections.size < (n - 1)) return -1\\n    parents = IntArray(n + 1) { it }\\n    for ((a, b) in connections) union(a, b)\\n    var res = 0\\n    for(i in 0 until n)\\n      if (find(i) == i) res++\\n    return res - 1\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2769213,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    \\n    int findPar(int node, int parent[]){\\n        if(node == parent[node]){\\n            return node;\\n        }\\n        return parent[node] = findPar(parent[node],parent);\\n    }\\n    \\n    public int makeConnected(int n, int[][] connections) {\\n        int parent[]=new int[n];\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n        }\\n        int leftWire=0;\\n        int component =0;\\n        int m = connections.length;\\n        for(int i=0;i<m;i++){\\n            int p1 =findPar(connections[i][0],parent);\\n            int p2 =findPar(connections[i][1],parent);\\n            if(p1 != p2){\\n                parent[p1]=p2;\\n            }else{\\n                leftWire++;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(parent[i] == i){\\n                component++;\\n            }\\n        }\\n        return (component-1) <= leftWire?component-1:-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int findPar(int node, int parent[]){\\n        if(node == parent[node]){\\n            return node;\\n        }\\n        return parent[node] = findPar(parent[node],parent);\\n    }\\n    \\n    public int makeConnected(int n, int[][] connections) {\\n        int parent[]=new int[n];\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n        }\\n        int leftWire=0;\\n        int component =0;\\n        int m = connections.length;\\n        for(int i=0;i<m;i++){\\n            int p1 =findPar(connections[i][0],parent);\\n            int p2 =findPar(connections[i][1],parent);\\n            if(p1 != p2){\\n                parent[p1]=p2;\\n            }else{\\n                leftWire++;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(parent[i] == i){\\n                component++;\\n            }\\n        }\\n        return (component-1) <= leftWire?component-1:-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2440478,
                "title": "easy-way",
                "content": "class Solution {\\n    public static int find(int x,int parent[])\\n    {\\n        if(parent[x]==x)\\n            return x;\\n        else\\n             return find(parent[x],parent);\\n    }\\n    public static void union(int i,int j,int parent[],int arr[])\\n    {\\n        int x = find(i,parent);\\n        int y = find(j,parent);\\n        if(x==y){\\n            arr[0]++;\\n            return;}\\n        else {\\n               //System.out.println(i+\",\"+j+\",\"+x+\",\"+y);\\n            parent[y]= x;}\\n    }\\n    public int makeConnected(int n, int[][] connections) {\\n        \\n        int m= connections.length;\\n          if(connections.length < n-1)return -1;\\n        int parent[] = new int[n];\\n        for(int i=0;i<n;i++)\\n            parent[i]=i;\\n        \\n        int arr[] = new int[1];\\n        for(int i=0;i<m;i++)\\n        {      \\n            int a= connections[i][0];\\n            int b= connections[i][1];\\n            union(a,b,parent,arr);\\n          \\n        }\\n     int noOfConnectedComponent =-1;\\n        for(int i=0;i<n;i++){\\n            if(parent[i]==i)\\n                noOfConnectedComponent++;\\n        }\\n        \\n        \\n        if(arr[0]<noOfConnectedComponent)\\n            return -1;\\n        else\\n            return noOfConnectedComponent;\\n    }\\n}",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "class Solution {\\n    public static int find(int x,int parent[])\\n    {\\n        if(parent[x]==x)\\n            return x;\\n        else\\n             return find(parent[x],parent);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2300024,
                "title": "union-find-please-upvote-if-you-like-it",
                "content": "```\\nclass DSU {\\npublic:\\n\\tvector<int> parent, size;\\n\\npublic:\\n\\tDSU(int n) {\\n\\t\\tfor (int i = 0; i <= n; i++) {\\n\\t\\t\\tparent.push_back(i);\\n\\t\\t\\tsize.push_back(1);\\t\\t\\n\\t\\t}\\n\\t}\\n\\n\\npublic:\\n\\tint findPar(int node) {\\n\\t\\tif (parent[node] == node) {\\n\\t\\t\\treturn node;\\n\\t\\t}\\n\\t\\treturn parent[node] = findPar(parent[node]);\\n\\t}\\n\\npublic:\\n\\tvoid unionSize(int u, int v) {\\n\\t\\tint pu = findPar(u);\\n\\t\\tint pv = findPar(v);\\n\\t\\tif (pu == pv) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif (size[pu] < size[pv]) {\\n\\t\\t\\tparent[pu] = pv;\\n\\t\\t\\tsize[pv] += size[pu];\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tparent[pv] = pu;\\n\\t\\t\\tsize[pu] += size[pv];\\n\\t\\t}\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        int m = connections.size();\\n        DSU dsu(n); \\n        int cnt = 0 ;\\n        for(auto it : connections){\\n            int a = dsu.findPar(it[0]);\\n            int b = dsu.findPar(it[1]);\\n            dsu.unionSize(it[0], it[1]);\\n            \\n        }\\n        if((n - m) > 1 )return -1;\\n       for(int i=0;i<n;i++){\\n           if(dsu.parent[i] == i)cnt++;   \\n           }\\n        return cnt-1; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass DSU {\\npublic:\\n\\tvector<int> parent, size;\\n\\npublic:\\n\\tDSU(int n) {\\n\\t\\tfor (int i = 0; i <= n; i++) {\\n\\t\\t\\tparent.push_back(i);\\n\\t\\t\\tsize.push_back(1);\\t\\t\\n\\t\\t}\\n\\t}\\n\\n\\npublic:\\n\\tint findPar(int node) {\\n\\t\\tif (parent[node] == node) {\\n\\t\\t\\treturn node;\\n\\t\\t}\\n\\t\\treturn parent[node] = findPar(parent[node]);\\n\\t}\\n\\npublic:\\n\\tvoid unionSize(int u, int v) {\\n\\t\\tint pu = findPar(u);\\n\\t\\tint pv = findPar(v);\\n\\t\\tif (pu == pv) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif (size[pu] < size[pv]) {\\n\\t\\t\\tparent[pu] = pv;\\n\\t\\t\\tsize[pv] += size[pu];\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tparent[pv] = pu;\\n\\t\\t\\tsize[pu] += size[pv];\\n\\t\\t}\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        int m = connections.size();\\n        DSU dsu(n); \\n        int cnt = 0 ;\\n        for(auto it : connections){\\n            int a = dsu.findPar(it[0]);\\n            int b = dsu.findPar(it[1]);\\n            dsu.unionSize(it[0], it[1]);\\n            \\n        }\\n        if((n - m) > 1 )return -1;\\n       for(int i=0;i<n;i++){\\n           if(dsu.parent[i] == i)cnt++;   \\n           }\\n        return cnt-1; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2136423,
                "title": "python-kruskal-s-algorithm",
                "content": "```\\nclass Solution:\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        # you need at least n - 1 edges to connect n nodes\\n        if n - 1 > len(connections):\\n            return -1\\n        \\n        link = list(range(n))\\n        size = n * [1]\\n        conCount = 1\\n        \\n        def find(x):\\n            while x != link[x]:\\n                x = link[x]\\n            return x\\n        \\n        def same(a, b):\\n            return find(a) == find(b)\\n        \\n        def unite(a, b):\\n            a, b = find(a), find(b)\\n            if size[a] < size[b]:\\n                a, b = b, a\\n            size[a] += size[b]\\n            link[b] = a\\n        \\n        for a, b in connections:\\n            if not same(a, b):\\n                unite(a, b)\\n                conCount += 1\\n        \\n        return n - conCount",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        # you need at least n - 1 edges to connect n nodes\\n        if n - 1 > len(connections):\\n            return -1\\n        \\n        link = list(range(n))\\n        size = n * [1]\\n        conCount = 1\\n        \\n        def find(x):\\n            while x != link[x]:\\n                x = link[x]\\n            return x\\n        \\n        def same(a, b):\\n            return find(a) == find(b)\\n        \\n        def unite(a, b):\\n            a, b = find(a), find(b)\\n            if size[a] < size[b]:\\n                a, b = b, a\\n            size[a] += size[b]\\n            link[b] = a\\n        \\n        for a, b in connections:\\n            if not same(a, b):\\n                unite(a, b)\\n                conCount += 1\\n        \\n        return n - conCount",
                "codeTag": "Java"
            },
            {
                "id": 1975459,
                "title": "c-bfs",
                "content": "Make adjacency list of the given graph and traverse se, whenever you find a disconnected component count 1.\\n\\n```\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& c) {\\n        int edges = c.size();;\\n        \\n        if( edges < n - 1 ){\\n            return -1;\\n        }\\n        \\n        vector<int> adj[n];\\n        vector<int> vis(n, 0);\\n        \\n        for( int i=0; i < c.size(); i++ ) {\\n            adj[ c[i][0] ].push_back( c[i][1] );\\n            adj[ c[i][1] ].push_back( c[i][0] );\\n        }\\n        queue<int> q;\\n        int count = 0;\\n        \\n        for(int i = 0; i<n; i++) {\\n            if( !vis[i] ) {\\n               count++;\\n               vis[i] = 1;\\n                q.push(i);\\n               while(!q.empty()){  \\n                int node = q.front();\\n                q.pop();\\n                for(auto x : adj[node]) {\\n                    if( !vis[x] ) {\\n                        q.push(x);\\n                        vis[x] = 1;\\n                    }\\n                } \\n             }\\n           }\\n        }\\n        count--;\\n        return count;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& c) {\\n        int edges = c.size();;\\n        \\n        if( edges < n - 1 ){\\n            return -1;\\n        }\\n        \\n        vector<int> adj[n];\\n        vector<int> vis(n, 0);\\n        \\n        for( int i=0; i < c.size(); i++ ) {\\n            adj[ c[i][0] ].push_back( c[i][1] );\\n            adj[ c[i][1] ].push_back( c[i][0] );\\n        }\\n        queue<int> q;\\n        int count = 0;\\n        \\n        for(int i = 0; i<n; i++) {\\n            if( !vis[i] ) {\\n               count++;\\n               vis[i] = 1;\\n                q.push(i);\\n               while(!q.empty()){  \\n                int node = q.front();\\n                q.pop();\\n                for(auto x : adj[node]) {\\n                    if( !vis[x] ) {\\n                        q.push(x);\\n                        vis[x] = 1;\\n                    }\\n                } \\n             }\\n           }\\n        }\\n        count--;\\n        return count;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1963765,
                "title": "easy-solution-faster-than-others-simple-dfs-solution-for-finding-connected-components",
                "content": "```\\nclass Solution {\\nprivate:\\n    void dfs(vector<vector<int>> &adj, vector<bool> &visited, int src)\\n    {\\n        visited[src] = true;\\n        for(int i : adj[src])\\n            if(!visited[i])\\n                dfs(adj, visited, i);\\n    }\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        \\n        //we need n-1 edges atleast for n vertices is connection size is lesser means we don\\'t have sufficient edges\\n        if(connections.size() < n - 1)\\n            return -1;\\n        vector<vector<int>> adj(n);\\n        for(auto v : connections)\\n        {\\n            adj[v[0]].push_back(v[1]);\\n            adj[v[1]].push_back(v[0]);\\n        }\\n        vector<bool> visited(n, false);\\n        int components = 0;\\n        for(int i=0; i<n; i++)\\n            if(!visited[i])\\n            {\\n                dfs(adj, visited, i);\\n                components++;\\n            }\\n        return components - 1;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\nprivate:\\n    void dfs(vector<vector<int>> &adj, vector<bool> &visited, int src)\\n    {\\n        visited[src] = true;\\n        for(int i : adj[src])\\n            if(!visited[i])\\n                dfs(adj, visited, i);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1722935,
                "title": "c-count-connected-components-union-find",
                "content": "**Logic:** We have to count number of connected components and subtract 1 to find number of edges required to connect the graph. \\n\\nThe code below is optimized version of union find: Union by rank and find with path compression. \\n**Time complexity**: ```O(edges*\\u03B1(nodes)) \\u2248 O(edges)```\\n```\\nclass DSU{\\n    vector<int> rank, parent;\\n    public:\\n    DSU(int n){\\n        rank.resize(n,0);\\n        parent.resize(n,0);\\n        iota(parent.begin(), parent.end(), 0);\\n    }\\n    \\n    int findParent(int u){\\n        if(u == parent[u]) return u;\\n        return parent[u] = findParent(parent[u]);\\n    }\\n    \\n    void unionParent(int u, int v){\\n        int parU = findParent(u);\\n        int parV = findParent(v);\\n        \\n        if(rank[parU] < rank[parV]){\\n            parent[parU] = parV;\\n        }\\n        else if(rank[parV] < rank[parU]){\\n            parent[parV] = parU;\\n        }\\n        else if(rank[parU] == rank[parV]){\\n            parent[parU] = parV;\\n            rank[parV] += 1;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        int edges = connections.size();\\n        \\n        //In order to make graph connected, there should be at least n-1 edges\\n        if(edges < n-1) return -1;\\n        \\n        //Use union find to count number of connected components\\n        //No. of operations needed = TotalConnectedComp - 1.\\n        \\n        int connectedComponent = n;\\n        DSU ds(n);\\n        for(auto& edge: connections){\\n            int u = edge[0], v = edge[1];\\n            int parU = ds.findParent(u);\\n            int parV = ds.findParent(v);\\n            \\n            if(parU != parV){\\n                ds.unionParent(u, v);\\n                connectedComponent -= 1;\\n            }\\n        }\\n\\t\\tint operationsNeeded = connectedComponent - 1;\\n        return operationsNeeded;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "```O(edges*\\u03B1(nodes)) \\u2248 O(edges)```\n```\\nclass DSU{\\n    vector<int> rank, parent;\\n    public:\\n    DSU(int n){\\n        rank.resize(n,0);\\n        parent.resize(n,0);\\n        iota(parent.begin(), parent.end(), 0);\\n    }\\n    \\n    int findParent(int u){\\n        if(u == parent[u]) return u;\\n        return parent[u] = findParent(parent[u]);\\n    }\\n    \\n    void unionParent(int u, int v){\\n        int parU = findParent(u);\\n        int parV = findParent(v);\\n        \\n        if(rank[parU] < rank[parV]){\\n            parent[parU] = parV;\\n        }\\n        else if(rank[parV] < rank[parU]){\\n            parent[parV] = parU;\\n        }\\n        else if(rank[parU] == rank[parV]){\\n            parent[parU] = parV;\\n            rank[parV] += 1;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        int edges = connections.size();\\n        \\n        //In order to make graph connected, there should be at least n-1 edges\\n        if(edges < n-1) return -1;\\n        \\n        //Use union find to count number of connected components\\n        //No. of operations needed = TotalConnectedComp - 1.\\n        \\n        int connectedComponent = n;\\n        DSU ds(n);\\n        for(auto& edge: connections){\\n            int u = edge[0], v = edge[1];\\n            int parU = ds.findParent(u);\\n            int parV = ds.findParent(v);\\n            \\n            if(parU != parV){\\n                ds.unionParent(u, v);\\n                connectedComponent -= 1;\\n            }\\n        }\\n\\t\\tint operationsNeeded = connectedComponent - 1;\\n        return operationsNeeded;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1511712,
                "title": "c-simple-dfs-solution",
                "content": "**204 ms, faster than 100.00% of C# online submissions**\\n\\n```\\npublic class Solution {\\n    public int MakeConnected(int n, int[][] connections) {\\n        \\n        if(connections.Length < n - 1){\\n            return -1;\\n        }\\n     \\n        Dictionary<int, List<int>> connectionsAsMap = BuildMapFromArray(connections);\\n        bool[] visited = new bool[n];\\n        int count = -1;\\n        \\n        for(int visitedIndex = 0; visitedIndex < n; visitedIndex++){\\n            if(!visited[visitedIndex]){\\n                DFS(visitedIndex, connectionsAsMap, visited);\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    private void DFS(int source, Dictionary<int, List<int>> connectionsAsMap, bool[] visited){\\n        \\n        visited[source] = true;\\n        \\n        List<int> connectionAdjacents = connectionsAsMap.ContainsKey(source) ? connectionsAsMap[source] : new List<int>();\\n        \\n        foreach(int connectionAdjacent in connectionAdjacents){\\n            \\n            if(!visited[connectionAdjacent]){\\n                DFS(connectionAdjacent, connectionsAsMap, visited);\\n            }\\n        }\\n    }\\n    \\n    private Dictionary<int, List<int>> BuildMapFromArray(int[][] connections){\\n        \\n        Dictionary<int, List<int>> result = new Dictionary<int, List<int>>();\\n        \\n        foreach(int[] connection in connections){\\n            \\n            if(!result.ContainsKey(connection[0])){\\n                result.Add(connection[0], new List<int>());\\n            }\\n            \\n            if(!result.ContainsKey(connection[1])){\\n                result.Add(connection[1], new List<int>());\\n            }\\n            \\n            result[connection[0]].Add(connection[1]);\\n            result[connection[1]].Add(connection[0]);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\npublic class Solution {\\n    public int MakeConnected(int n, int[][] connections) {\\n        \\n        if(connections.Length < n - 1){\\n            return -1;\\n        }\\n     \\n        Dictionary<int, List<int>> connectionsAsMap = BuildMapFromArray(connections);\\n        bool[] visited = new bool[n];\\n        int count = -1;\\n        \\n        for(int visitedIndex = 0; visitedIndex < n; visitedIndex++){\\n            if(!visited[visitedIndex]){\\n                DFS(visitedIndex, connectionsAsMap, visited);\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    private void DFS(int source, Dictionary<int, List<int>> connectionsAsMap, bool[] visited){\\n        \\n        visited[source] = true;\\n        \\n        List<int> connectionAdjacents = connectionsAsMap.ContainsKey(source) ? connectionsAsMap[source] : new List<int>();\\n        \\n        foreach(int connectionAdjacent in connectionAdjacents){\\n            \\n            if(!visited[connectionAdjacent]){\\n                DFS(connectionAdjacent, connectionsAsMap, visited);\\n            }\\n        }\\n    }\\n    \\n    private Dictionary<int, List<int>> BuildMapFromArray(int[][] connections){\\n        \\n        Dictionary<int, List<int>> result = new Dictionary<int, List<int>>();\\n        \\n        foreach(int[] connection in connections){\\n            \\n            if(!result.ContainsKey(connection[0])){\\n                result.Add(connection[0], new List<int>());\\n            }\\n            \\n            if(!result.ContainsKey(connection[1])){\\n                result.Add(connection[1], new List<int>());\\n            }\\n            \\n            result[connection[0]].Add(connection[1]);\\n            result[connection[1]].Add(connection[0]);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 649206,
                "title": "detailed-dfs-explanation-with-c-code",
                "content": "(Number of connected components-1 ) is the requied answer.\\nJust think none of the computers are connected.Clearly n-1 is the minimum number of wires required to connect them.\\nNow visualise each of those computers as connected components.As once we reach one of the computers in the connected component we reach everything in that component.So, (Number of connected components-1 ) is the requied answer.\\n\\nNow twist is that to connect all computers you need n-1 wires.But so if total wires less than n-1 return -1.\\n\\nSee the code below for more clarity!.\\n\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& graph,vector<int>& visited,int i)\\n    {\\n        if(visited[i])\\n            return;\\n        visited[i]=1;\\n        for(auto x:graph[i])\\n        {\\n            dfs(graph,visited,x);\\n        }\\n    }\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        vector<vector<int>> graph(n);\\n        for(auto& a:connections)\\n        {\\n            graph[a[0]].push_back(a[1]);\\n            graph[a[1]].push_back(a[0]);\\n        }\\n        vector<int> visited(n);\\n        int ctr=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!visited[i])\\n            {\\n                dfs(graph,visited,i);\\n                ctr++;\\n            }\\n        }\\n        if(connections.size()>=n-1)\\n            return ctr-1;\\n        else\\n            return -1;\\n    }\\n};\\n```\\nHope it helped!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& graph,vector<int>& visited,int i)\\n    {\\n        if(visited[i])\\n            return;\\n        visited[i]=1;\\n        for(auto x:graph[i])\\n        {\\n            dfs(graph,visited,x);\\n        }\\n    }\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        vector<vector<int>> graph(n);\\n        for(auto& a:connections)\\n        {\\n            graph[a[0]].push_back(a[1]);\\n            graph[a[1]].push_back(a[0]);\\n        }\\n        vector<int> visited(n);\\n        int ctr=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!visited[i])\\n            {\\n                dfs(graph,visited,i);\\n                ctr++;\\n            }\\n        }\\n        if(connections.size()>=n-1)\\n            return ctr-1;\\n        else\\n            return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 619346,
                "title": "java-simple-union-find",
                "content": "```\\nclass Solution {\\n    \\n    class UnionFind{\\n        int[] parent;\\n        \\n        public UnionFind(int n){\\n            parent = new int[n];\\n            for(int node = 0; node<n; node++){\\n                parent[node] = node;\\n            }\\n        }\\n        \\n        public void union(int A, int B){\\n            int parentA = find(A);\\n            int parentB = find(B);\\n            parent[parentA] = parentB;\\n        }\\n        \\n        private int find(int A){\\n            while(parent[A]!=A){\\n                A = parent[A];\\n            }\\n            return A;\\n        }\\n    }\\n\\n    \\n    public int makeConnected(int n, int[][] connections) {\\n        if(connections.length < n-1)return -1;\\n        UnionFind uf = new UnionFind(n);\\n        for(int[] conn : connections){\\n            uf.union(conn[0],conn[1]);\\n        }\\n        int notConnectedTerminals = 0;\\n        for(int i = 0; i<n;i++){\\n            if(i==uf.parent[i])notConnectedTerminals++;\\n        }\\n        return notConnectedTerminals-1;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    \\n    class UnionFind{\\n        int[] parent;\\n        \\n        public UnionFind(int n){\\n            parent = new int[n];\\n            for(int node = 0; node<n; node++){\\n                parent[node] = node;\\n            }\\n        }\\n        \\n        public void union(int A, int B){\\n            int parentA = find(A);\\n            int parentB = find(B);\\n            parent[parentA] = parentB;\\n        }\\n        \\n        private int find(int A){\\n            while(parent[A]!=A){\\n                A = parent[A];\\n            }\\n            return A;\\n        }\\n    }\\n\\n    \\n    public int makeConnected(int n, int[][] connections) {\\n        if(connections.length < n-1)return -1;\\n        UnionFind uf = new UnionFind(n);\\n        for(int[] conn : connections){\\n            uf.union(conn[0],conn[1]);\\n        }\\n        int notConnectedTerminals = 0;\\n        for(int i = 0; i<n;i++){\\n            if(i==uf.parent[i])notConnectedTerminals++;\\n        }\\n        return notConnectedTerminals-1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 486393,
                "title": "c-union-find-faster-than-81-less-than-100-easy-to-understand",
                "content": "```\\nclass Solution {\\nprivate:\\n    int find(vector<int>& parent, int num) {\\n        if (parent[num] != num) {\\n            parent[num] = find(parent, parent[num]);\\n        }\\n        return parent[num];\\n    }\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        if (n == 1) {\\n            return 0;\\n        }\\n\\n        vector<int> parent(n, 0);\\n        iota(parent.begin(), parent.end(), 0);\\n        int duplicate = 0;\\n        for (vector<int>& connection : connections) {\\n            int pu = find(parent, connection[0]);\\n            int pv = find(parent, connection[1]);\\n            if (pu != pv) {\\n                parent[pu] = pv;\\n            }\\n            else {\\n                duplicate += 1;\\n            }\\n        }\\n\\n        int components = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (i == parent[i]) {\\n                components += 1;\\n            }\\n        }\\n\\n        return components - 1 > duplicate ? -1 : components - 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int find(vector<int>& parent, int num) {\\n        if (parent[num] != num) {\\n            parent[num] = find(parent, parent[num]);\\n        }\\n        return parent[num];\\n    }\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        if (n == 1) {\\n            return 0;\\n        }\\n\\n        vector<int> parent(n, 0);\\n        iota(parent.begin(), parent.end(), 0);\\n        int duplicate = 0;\\n        for (vector<int>& connection : connections) {\\n            int pu = find(parent, connection[0]);\\n            int pv = find(parent, connection[1]);\\n            if (pu != pv) {\\n                parent[pu] = pv;\\n            }\\n            else {\\n                duplicate += 1;\\n            }\\n        }\\n\\n        int components = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (i == parent[i]) {\\n                components += 1;\\n            }\\n        }\\n\\n        return components - 1 > duplicate ? -1 : components - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954417,
                "title": "python-union-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Disjoint:\\n    def __init__(self,n):\\n        self.rank = [1 for i in range(n)]\\n        self.parent = [i for i in range(n)]\\n\\n    def find(self,x):\\n        if self.parent[x] == x:\\n            return x\\n        self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n    \\n    def union(self,u,v):\\n        if self.find(u) == self.find(v):\\n            return\\n        \\n\\n        pu = self.find(u)\\n        pv = self.find(v)\\n        if self.rank[pu] > self.rank[pv]:\\n            self.parent[pv] = pu\\n        elif self.rank[pu] < self.rank[pv]:\\n            self.parent[pu] = pv\\n        else:\\n            self.parent[pv] = pu\\n            self.rank[pu] += 1\\n\\n\\n\\nclass Solution:\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        ds = Disjoint(n)\\n        extra = 0\\n        for i in connections:\\n            pu = ds.find(i[0])\\n            pv = ds.find(i[1])\\n            if pu == pv:\\n                extra += 1\\n            else:\\n                ds.union(pu,pv)\\n            \\n        ans = 0\\n        for i in range(n):\\n            if ds.parent[i] == i:\\n                ans += 1\\n        \\n        ans -= 1\\n        if extra >= ans:\\n            return ans\\n        else:\\n            return -1\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass Disjoint:\\n    def __init__(self,n):\\n        self.rank = [1 for i in range(n)]\\n        self.parent = [i for i in range(n)]\\n\\n    def find(self,x):\\n        if self.parent[x] == x:\\n            return x\\n        self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n    \\n    def union(self,u,v):\\n        if self.find(u) == self.find(v):\\n            return\\n        \\n\\n        pu = self.find(u)\\n        pv = self.find(v)\\n        if self.rank[pu] > self.rank[pv]:\\n            self.parent[pv] = pu\\n        elif self.rank[pu] < self.rank[pv]:\\n            self.parent[pu] = pv\\n        else:\\n            self.parent[pv] = pu\\n            self.rank[pu] += 1\\n\\n\\n\\nclass Solution:\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        ds = Disjoint(n)\\n        extra = 0\\n        for i in connections:\\n            pu = ds.find(i[0])\\n            pv = ds.find(i[1])\\n            if pu == pv:\\n                extra += 1\\n            else:\\n                ds.union(pu,pv)\\n            \\n        ans = 0\\n        for i in range(n):\\n            if ds.parent[i] == i:\\n                ans += 1\\n        \\n        ans -= 1\\n        if extra >= ans:\\n            return ans\\n        else:\\n            return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3333729,
                "title": "breadth-first-search-python3",
                "content": "\\n\\n# 1. Breadth First Search--->O(N)\\n```\\nclass Solution(object):\\n    def makeConnected(self, n, connections):\\n        if len(connections)<n-1:\\n            return -1\\n        graph=defaultdict(list)\\n        for src,dst in connections:\\n            graph[src].append(dst)\\n            graph[dst].append(src)\\n        visit=[False]*n\\n        def bfs(start):\\n            q=deque()\\n            q.append(start)\\n            while len(q)>0:\\n                poping=q.popleft()\\n                for i in graph[poping]:\\n                    if not visit[i]:\\n                        visit[i]=True\\n                        q.append(i)\\n        count=0\\n        for i in range(n):\\n            if not visit[i]:\\n                count+=1\\n                bfs(i)\\n        return count-1\\n\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def makeConnected(self, n, connections):\\n        if len(connections)<n-1:\\n            return -1\\n        graph=defaultdict(list)\\n        for src,dst in connections:\\n            graph[src].append(dst)\\n            graph[dst].append(src)\\n        visit=[False]*n\\n        def bfs(start):\\n            q=deque()\\n            q.append(start)\\n            while len(q)>0:\\n                poping=q.popleft()\\n                for i in graph[poping]:\\n                    if not visit[i]:\\n                        visit[i]=True\\n                        q.append(i)\\n        count=0\\n        for i in range(n):\\n            if not visit[i]:\\n                count+=1\\n                bfs(i)\\n        return count-1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332887,
                "title": "connected-networks-java-union-find",
                "content": "Hi,\\n\\nThe basic understanding to connect n nodes requires a minimum of n-1 edges. In case of multiple groups of nodes we might need more nodes as they may be in tree like data structure.\\n\\nUsing the above approach we have to see whether n-1 edges are available. And to get the multiple group of nodes we use union find.\\n\\n1. Initially the parent for all the nodes will the node itself\\n2. If two nodes are connected then we use Union method to join the nodes with parent of second node as first node\\n3. Find the parent of the node by looking into the parent array until you reach the node where the parent of the node is the node itself\\n4. Finally count the number of groups and not connected nodes by finding the number of parent nodes with unique values.\\n5. Return the count-1.\\n\\n```\\n    public int makeConnected(int n, int[][] roads) {\\n    \\tif(roads.length<n-1)\\n    \\t\\treturn -1;\\n    \\tint parent[] =  new int[n];\\n    \\tfor(int i=0; i<n; i++){\\n    \\t\\tparent[i]=i;\\n    \\t}\\n    \\tfor(int[] i: roads){\\n    \\t\\tunion(i[0], i[1], parent);\\n    \\t}\\n    \\tint res=0;\\n    \\tfor(int i=0; i<n; i++){\\n    \\t\\tif(parent[i]==i)\\n    \\t\\t\\tres++;\\n    \\t}\\n    \\treturn res-1;\\n    }\\n\\t\\n    private void union(int i, int j, int[] parent) {\\n\\t\\tif(find(i, parent)!=find(j, parent)){\\n\\t\\t\\tparent[parent[j]] = parent[i];\\n\\t\\t}\\n\\t\\t\\n\\t}\\n\\n\\tprivate int find(int i, int[] parent) {\\n\\t\\tif(parent[i]!=i)\\n\\t\\t\\tparent[i] = find(parent[i], parent);\\n\\t\\treturn parent[i];\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "Hi,\\n\\nThe basic understanding to connect n nodes requires a minimum of n-1 edges. In case of multiple groups of nodes we might need more nodes as they may be in tree like data structure.\\n\\nUsing the above approach we have to see whether n-1 edges are available. And to get the multiple group of nodes we use union find.\\n\\n1. Initially the parent for all the nodes will the node itself\\n2. If two nodes are connected then we use Union method to join the nodes with parent of second node as first node\\n3. Find the parent of the node by looking into the parent array until you reach the node where the parent of the node is the node itself\\n4. Finally count the number of groups and not connected nodes by finding the number of parent nodes with unique values.\\n5. Return the count-1.\\n\\n```\\n    public int makeConnected(int n, int[][] roads) {\\n    \\tif(roads.length<n-1)\\n    \\t\\treturn -1;\\n    \\tint parent[] =  new int[n];\\n    \\tfor(int i=0; i<n; i++){\\n    \\t\\tparent[i]=i;\\n    \\t}\\n    \\tfor(int[] i: roads){\\n    \\t\\tunion(i[0], i[1], parent);\\n    \\t}\\n    \\tint res=0;\\n    \\tfor(int i=0; i<n; i++){\\n    \\t\\tif(parent[i]==i)\\n    \\t\\t\\tres++;\\n    \\t}\\n    \\treturn res-1;\\n    }\\n\\t\\n    private void union(int i, int j, int[] parent) {\\n\\t\\tif(find(i, parent)!=find(j, parent)){\\n\\t\\t\\tparent[parent[j]] = parent[i];\\n\\t\\t}\\n\\t\\t\\n\\t}\\n\\n\\tprivate int find(int i, int[] parent) {\\n\\t\\tif(parent[i]!=i)\\n\\t\\t\\tparent[i] = find(parent[i], parent);\\n\\t\\treturn parent[i];\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3331005,
                "title": "python-short-and-clean-disjoint-set-union-dsu-union-find",
                "content": "# Approach\\n1. If number of `connections` is less than `n - 1` to begin with, it\\'s impossible to connect all computers. Hence return `-1`. \\n\\n2. Create a `DSU (Disjoint-Set-Union)` with `n` nodes.\\n\\n3. Merge the sets by calling `union(u, v)` for every link `u <-> v` in `connectiona`.\\n\\n4. Get the count of disjoint-sets at the end, say `ds_count`.\\n\\n5. We need to move `ds_count - 1` links to connect them all.\\n\\n# Complexity\\n- Time complexity: $$O(n + e)$$\\n\\n- Space complexity: $$O(n)$$\\n\\nwhere,\\n`n is the number of computers`,\\n`e is the number of connections between them`.\\n\\n# Code\\n```\\nclass Solution:\\n    def makeConnected(self, n: int, connections: list[list[int]]) -> int:\\n        if len(connections) < n - 1: return -1\\n\\n        dsu = DSU(range(n))\\n        for u, v in connections: dsu.union(u, v)\\n        return dsu.ds_count() - 1\\n\\nT = Hashable\\nclass DSU:\\n    def __init__(self, xs: Iterable[T] = ()) -> None:\\n        self.parents: Mapping[T, T] = {x: x for x in xs}\\n        self.sizes: Mapping[T, int] = {x: 1 for x in xs}\\n        self.count: int = len(self.parents)\\n\\n    def find(self, u: T) -> T:\\n        self.parents[u] = u if self.parents[u] == u else self.find(self.parents[u])\\n        return self.parents[u]\\n    \\n    def union(self, u: T, v: T) -> None:\\n        ur, vr = self.find(u), self.find(v)\\n        if ur == vr: return\\n        low, high = (ur, vr) if self.sizes[ur] < self.sizes[vr] else (vr, ur)\\n        self.parents[low] = high\\n        self.sizes[high] += self.sizes[low]\\n        self.count -= 1\\n    \\n    def is_connected(self, u: T, v: T) -> bool:\\n        return self.find(u) == self.find(v)\\n    \\n    def ds_count(self) -> int:\\n        return self.count\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def makeConnected(self, n: int, connections: list[list[int]]) -> int:\\n        if len(connections) < n - 1: return -1\\n\\n        dsu = DSU(range(n))\\n        for u, v in connections: dsu.union(u, v)\\n        return dsu.ds_count() - 1\\n\\nT = Hashable\\nclass DSU:\\n    def __init__(self, xs: Iterable[T] = ()) -> None:\\n        self.parents: Mapping[T, T] = {x: x for x in xs}\\n        self.sizes: Mapping[T, int] = {x: 1 for x in xs}\\n        self.count: int = len(self.parents)\\n\\n    def find(self, u: T) -> T:\\n        self.parents[u] = u if self.parents[u] == u else self.find(self.parents[u])\\n        return self.parents[u]\\n    \\n    def union(self, u: T, v: T) -> None:\\n        ur, vr = self.find(u), self.find(v)\\n        if ur == vr: return\\n        low, high = (ur, vr) if self.sizes[ur] < self.sizes[vr] else (vr, ur)\\n        self.parents[low] = high\\n        self.sizes[high] += self.sizes[low]\\n        self.count -= 1\\n    \\n    def is_connected(self, u: T, v: T) -> bool:\\n        return self.find(u) == self.find(v)\\n    \\n    def ds_count(self) -> int:\\n        return self.count\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3330870,
                "title": "java-easy-to-understand-solution-explained",
                "content": "# Intuition\\nSince the problem is asking us to connect all the computers together using minimum cables. This means that there are computers which are not connected to each other or there are different connected components(single node or multiple nodes connected)\\n\\nFirst thing that should come to our minds to identify different connected components in graphs is Union Find algorithm.\\n\\nSome special cases:\\n1) If the connections(edges) are less that n-1, then we will not be able to connect all computer(nodes) return -1.\\nexample: if there are 4 nodes we need minimum n-1 i.e 4-1= 3 edges(connections) to connect them.\\n\\n# Approach\\n1) Apply union find.\\n2) Number of cables would iterating over the parent array finding the number of disjoint sets or different connected components -1\\n\\n# Complexity\\n- Time complexity:\\nO(n + Elog(V)), where n is the number of computers, E is the number of connections, and V is the number of disjoint sets. The Union-Find algorithm has a time complexity of O(Elog(V)), and we need to iterate over the connections array once, which takes O(E) time. Counting the number of disjoint sets takes O(n) time.\\n\\n\\n- Space complexity:\\nO(n) since we are using it to store parent array.\\n# Code\\n```\\nclass Solution {\\n    \\n    class UnionFind{\\n        int [] parent;\\n\\n        public UnionFind(int n){\\n            parent = new int[n];\\n            for(int i=0; i<n; i++){\\n                parent[i]=i;\\n            }\\n        }\\n\\n        private int find(int x){\\n            if(parent[x]!=x){\\n                parent[x] = find(parent[x]);\\n            }\\n            return parent[x];\\n        }\\n    }\\n\\n    public int makeConnected(int n, int[][] connections) {\\n        if (connections.length < n - 1) {\\n            return -1;\\n        }\\n\\n        int uniqueSets = 0;\\n        UnionFind uf = new UnionFind(n);\\n        for(int [] eachConnection : connections){\\n            int findU = uf.find(eachConnection[0]);\\n            int findV = uf.find(eachConnection[1]);\\n            if(findU!=findV){\\n                uf.parent[findV] = findU;\\n            }\\n        }\\n\\n        /* finding unique connected components(disjoint sets) */\\n        for(int i=0; i<uf.parent.length; i++){\\n            if(uf.parent[i]==i){\\n                uniqueSets++;\\n            }\\n        }\\n\\n        return uniqueSets-1;\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    \\n    class UnionFind{\\n        int [] parent;\\n\\n        public UnionFind(int n){\\n            parent = new int[n];\\n            for(int i=0; i<n; i++){\\n                parent[i]=i;\\n            }\\n        }\\n\\n        private int find(int x){\\n            if(parent[x]!=x){\\n                parent[x] = find(parent[x]);\\n            }\\n            return parent[x];\\n        }\\n    }\\n\\n    public int makeConnected(int n, int[][] connections) {\\n        if (connections.length < n - 1) {\\n            return -1;\\n        }\\n\\n        int uniqueSets = 0;\\n        UnionFind uf = new UnionFind(n);\\n        for(int [] eachConnection : connections){\\n            int findU = uf.find(eachConnection[0]);\\n            int findV = uf.find(eachConnection[1]);\\n            if(findU!=findV){\\n                uf.parent[findV] = findU;\\n            }\\n        }\\n\\n        /* finding unique connected components(disjoint sets) */\\n        for(int i=0; i<uf.parent.length; i++){\\n            if(uf.parent[i]==i){\\n                uniqueSets++;\\n            }\\n        }\\n\\n        return uniqueSets-1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3330754,
                "title": "c-bfs-and-dfs-easy-to-understand",
                "content": "# Intuition\\nIf you try to solve a few examples on notebook, you would realise that if we find the number of components that are connected together, the number of cables needed to connect them would be number of connected components-1. \\n\\n#### Example\\n```\\n      o --- 1      4 --- 5       \\n      |     |                      \\n      2 --- 3      6   \\n\\n```\\nIn this diagram, we have three different connected components:\\n```\\n[0,1,2,3], [4,5], [6]\\n```\\nWe can see that there are two cables needed to connect all of the components together (which is not possible here).\\n# Approach\\n- First for both BFS and DFS we need an adjacency matrix to store all the nodes connected to a node. \\n- We also need a visited array that will mark the nodes visited.\\n- We will loop over all the nodes and check if the node is visited or not. \\nIf not, then it is a part of connected component that is unvisited. We will increase the count and call bfs/dfs to mark the nodes that are part of this component as visited\\n- In the BFS approach we will use a queue to traverse the nodes connected and mark them visited. While in DFS, we will recursively mark the nodes which are connected to the current node. \\n\\n\\n# Code\\n## BFS\\n```\\nclass Solution {\\npublic:\\n    // to mark the nodes reachable from curr as visited\\n    void bfs(vector<vector<int>>& adj,int curr, vector<bool>& vis ){\\n        queue<int>q;\\n        q.push(curr);\\n        vis[curr]=true;\\n        while(!q.empty()){\\n            curr=q.front();\\n            q.pop();\\n            for(auto& node:adj[curr]){\\n                if(!vis[node]){ \\n                    vis[node]=true;\\n                    q.push(node);\\n                }\\n            }\\n        }\\n    }\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        if(connections.size()<n-1) return -1; // if the number of connections is less than n-1 that means that we cannot connect all nodes reachable\\n\\n        vector<bool>vis(n,false);\\n        vector<vector<int>>adj(n); // adjacency matrix\\n        for(auto& c:connections){\\n            adj[c[0]].push_back(c[1]);\\n            adj[c[1]].push_back(c[0]);\\n        }\\n        int conn=-1;\\n        for(int i=0;i<n;++i){\\n            if(!vis[i]){ // if not visited, a connected component is present that is unvisited\\n                ++conn; \\n                bfs(adj,i,vis);\\n            }\\n        }\\n        return conn;\\n    }\\n};\\n```\\n## DFS\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& adj,int curr, vector<bool>& vis ){\\n        vis[curr]=true;\\n        for(auto& node:adj[curr]){\\n            if(!vis[node]){\\n                dfs(adj,node,vis);\\n            }\\n        }\\n    }\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        if(connections.size()<n-1) return -1;\\n\\n        vector<bool>vis(n,false);\\n        vector<vector<int>>adj(n); // adjacency matrix\\n        for(auto& c:connections){\\n            adj[c[0]].push_back(c[1]);\\n            adj[c[1]].push_back(c[0]);\\n        }\\n        int conn=-1;\\n        for(int i=0;i<n;++i){\\n            if(!vis[i]){ // if not visited, a connected component is present that is unvisited\\n                ++conn;\\n                dfs(adj,i,vis);\\n            }\\n        }\\n        return conn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n      o --- 1      4 --- 5       \\n      |     |                      \\n      2 --- 3      6   \\n\\n```\n```\\n[0,1,2,3], [4,5], [6]\\n```\n```\\nclass Solution {\\npublic:\\n    // to mark the nodes reachable from curr as visited\\n    void bfs(vector<vector<int>>& adj,int curr, vector<bool>& vis ){\\n        queue<int>q;\\n        q.push(curr);\\n        vis[curr]=true;\\n        while(!q.empty()){\\n            curr=q.front();\\n            q.pop();\\n            for(auto& node:adj[curr]){\\n                if(!vis[node]){ \\n                    vis[node]=true;\\n                    q.push(node);\\n                }\\n            }\\n        }\\n    }\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        if(connections.size()<n-1) return -1; // if the number of connections is less than n-1 that means that we cannot connect all nodes reachable\\n\\n        vector<bool>vis(n,false);\\n        vector<vector<int>>adj(n); // adjacency matrix\\n        for(auto& c:connections){\\n            adj[c[0]].push_back(c[1]);\\n            adj[c[1]].push_back(c[0]);\\n        }\\n        int conn=-1;\\n        for(int i=0;i<n;++i){\\n            if(!vis[i]){ // if not visited, a connected component is present that is unvisited\\n                ++conn; \\n                bfs(adj,i,vis);\\n            }\\n        }\\n        return conn;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& adj,int curr, vector<bool>& vis ){\\n        vis[curr]=true;\\n        for(auto& node:adj[curr]){\\n            if(!vis[node]){\\n                dfs(adj,node,vis);\\n            }\\n        }\\n    }\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        if(connections.size()<n-1) return -1;\\n\\n        vector<bool>vis(n,false);\\n        vector<vector<int>>adj(n); // adjacency matrix\\n        for(auto& c:connections){\\n            adj[c[0]].push_back(c[1]);\\n            adj[c[1]].push_back(c[0]);\\n        }\\n        int conn=-1;\\n        for(int i=0;i<n;++i){\\n            if(!vis[i]){ // if not visited, a connected component is present that is unvisited\\n                ++conn;\\n                dfs(adj,i,vis);\\n            }\\n        }\\n        return conn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3330743,
                "title": "easy-java-solution-using-bfs-and-disjoint-set-easy-to-understand",
                "content": "\\n# Complexity\\n- Time complexity: **O(N+E)**\\n\\n- Space complexity: **O(N+E)**\\n\\n# Disjoint_set Code\\n1. **Crate a disjoint set and initilize it with the connections.**\\n2. **Initilize a counter with n-1 connections**\\n3. **Now for each new connection check if it belongs to same set , if not decrease the number of connections**\\n```\\nclass Solution {\\n\\n    class disjoint_set{\\n        List<Integer> rank = new ArrayList<>();\\n        List<Integer> parent = new ArrayList<>();\\n    \\n        disjoint_set(int n){\\n            for(int i = 0;i <= n;i++){\\n                rank.add(0);\\n                parent.add(i);\\n            }\\n        }\\n    \\n        public int findUparent(int node){\\n            if(node == parent.get(node)){\\n                return node;\\n            }\\n            int res = findUparent(parent.get(node));\\n    \\n            parent.set(node, res);\\n    \\n            return parent.get(node);\\n        }\\n    \\n        public boolean union_by_rank(int u, int v){\\n            int upu = findUparent(u);\\n            int upv = findUparent(v);\\n    \\n            if(upu == upv){\\n                return false;\\n            }\\n    \\n            if(rank.get(upv) > rank.get(upu)){\\n                parent.set(upu, upv);\\n            }\\n            else if(rank.get(upv) < rank.get(upu)){\\n                parent.set(upv,upu);\\n            }\\n            else{\\n                parent.set(upv, upu);\\n                rank.set(upv, rank.get(upv)+1);\\n            }\\n\\n            return true;\\n        }\\n    }\\n\\n    public int makeConnected(int n, int[][] connections) {\\n        disjoint_set uf = new disjoint_set(n);\\n\\n        if (connections.length < n - 1) {\\n            return -1;\\n        }\\n\\n        int newConn = n - 1;\\n        for (var conn : connections) {\\n            if (uf.union_by_rank(conn[0], conn[1])) {\\n                newConn--;\\n            }\\n        }\\n\\n        return newConn;\\n    }\\n}\\n```\\n# BFS Code\\n**perform a basic bfs and then return the number of disconnected components -1.**\\n```\\nclass Solution {\\n    public int makeConnected(int n, int[][] connections) {\\n        if(n-1 > connections.length){\\n            return -1;\\n        }\\n\\n        boolean[] visited = new boolean[n];\\n\\n        int ct = 0;\\n\\n        HashMap<Integer,List<Integer>> graph = new HashMap<>();\\n\\n        for(int i = 0;i < connections.length;i++){\\n            int u = connections[i][0];\\n            int v = connections[i][1];\\n\\n            graph.computeIfAbsent(u, k -> new ArrayList<>()).add(v);\\n            graph.computeIfAbsent(v, k -> new ArrayList<>()).add(u);\\n        }\\n\\n        for(int i = 0;i < n;i++){\\n            if(!visited[i]){\\n                ct++;\\n                bfs(graph,visited,i);\\n            }\\n        }\\n\\n        return ct-1;\\n    }\\n\\n    private void bfs(HashMap<Integer,List<Integer>> graph,boolean[] visited, int i){\\n        visited[i] = true;\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(i);\\n\\n        while(!q.isEmpty()){\\n            int x = q.poll();\\n\\n            if(!graph.containsKey(x)){\\n                continue;\\n            }\\n\\n            for(int it : graph.get(x)){\\n                if(!visited[it]){\\n                    visited[it] = true;\\n                    q.offer(it);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n\\n    class disjoint_set{\\n        List<Integer> rank = new ArrayList<>();\\n        List<Integer> parent = new ArrayList<>();\\n    \\n        disjoint_set(int n){\\n            for(int i = 0;i <= n;i++){\\n                rank.add(0);\\n                parent.add(i);\\n            }\\n        }\\n    \\n        public int findUparent(int node){\\n            if(node == parent.get(node)){\\n                return node;\\n            }\\n            int res = findUparent(parent.get(node));\\n    \\n            parent.set(node, res);\\n    \\n            return parent.get(node);\\n        }\\n    \\n        public boolean union_by_rank(int u, int v){\\n            int upu = findUparent(u);\\n            int upv = findUparent(v);\\n    \\n            if(upu == upv){\\n                return false;\\n            }\\n    \\n            if(rank.get(upv) > rank.get(upu)){\\n                parent.set(upu, upv);\\n            }\\n            else if(rank.get(upv) < rank.get(upu)){\\n                parent.set(upv,upu);\\n            }\\n            else{\\n                parent.set(upv, upu);\\n                rank.set(upv, rank.get(upv)+1);\\n            }\\n\\n            return true;\\n        }\\n    }\\n\\n    public int makeConnected(int n, int[][] connections) {\\n        disjoint_set uf = new disjoint_set(n);\\n\\n        if (connections.length < n - 1) {\\n            return -1;\\n        }\\n\\n        int newConn = n - 1;\\n        for (var conn : connections) {\\n            if (uf.union_by_rank(conn[0], conn[1])) {\\n                newConn--;\\n            }\\n        }\\n\\n        return newConn;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int makeConnected(int n, int[][] connections) {\\n        if(n-1 > connections.length){\\n            return -1;\\n        }\\n\\n        boolean[] visited = new boolean[n];\\n\\n        int ct = 0;\\n\\n        HashMap<Integer,List<Integer>> graph = new HashMap<>();\\n\\n        for(int i = 0;i < connections.length;i++){\\n            int u = connections[i][0];\\n            int v = connections[i][1];\\n\\n            graph.computeIfAbsent(u, k -> new ArrayList<>()).add(v);\\n            graph.computeIfAbsent(v, k -> new ArrayList<>()).add(u);\\n        }\\n\\n        for(int i = 0;i < n;i++){\\n            if(!visited[i]){\\n                ct++;\\n                bfs(graph,visited,i);\\n            }\\n        }\\n\\n        return ct-1;\\n    }\\n\\n    private void bfs(HashMap<Integer,List<Integer>> graph,boolean[] visited, int i){\\n        visited[i] = true;\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(i);\\n\\n        while(!q.isEmpty()){\\n            int x = q.poll();\\n\\n            if(!graph.containsKey(x)){\\n                continue;\\n            }\\n\\n            for(int it : graph.get(x)){\\n                if(!visited[it]){\\n                    visited[it] = true;\\n                    q.offer(it);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3330435,
                "title": "java-dfs-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs long as we have at least `n-1` cables, we should be able to connect all the `n` computers together. If there are `groups` number of disconnected groups of computers in the networks, the minimum number of cables required to connect all computerse together will be `groups - 1`. Thus, all we need to do is to find the total number of disconnected groups. We can use DFS to identify one group at a time and keep track of the total count.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n+e)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n+e)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  boolean[] seen;\\n  List<Integer>[] adj;\\n\\n  private void dfs(int node) {\\n    seen[node] = true;\\n\\n    for (var neighbor : adj[node])\\n      if (!seen[neighbor])\\n        dfs(neighbor);\\n  }\\n\\n  public int makeConnected(int n, int[][] connections) {\\n    if (connections.length < n-1) return -1;\\n\\n    seen = new boolean[n];\\n    adj = new ArrayList[n];\\n\\n    for (var i=0; i<n; i++)\\n      adj[i] = new ArrayList<>();\\n\\n    for (var con : connections) {\\n      adj[con[0]].add(con[1]);\\n      adj[con[1]].add(con[0]);\\n    }\\n    var groups = 0;\\n\\n    for (var i=0; i<n; i++) {\\n      if (!seen[i]) {\\n        dfs(i);\\n        groups++;\\n      }\\n    }\\n    return groups - 1;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n  boolean[] seen;\\n  List<Integer>[] adj;\\n\\n  private void dfs(int node) {\\n    seen[node] = true;\\n\\n    for (var neighbor : adj[node])\\n      if (!seen[neighbor])\\n        dfs(neighbor);\\n  }\\n\\n  public int makeConnected(int n, int[][] connections) {\\n    if (connections.length < n-1) return -1;\\n\\n    seen = new boolean[n];\\n    adj = new ArrayList[n];\\n\\n    for (var i=0; i<n; i++)\\n      adj[i] = new ArrayList<>();\\n\\n    for (var con : connections) {\\n      adj[con[0]].add(con[1]);\\n      adj[con[1]].add(con[0]);\\n    }\\n    var groups = 0;\\n\\n    for (var i=0; i<n; i++) {\\n      if (!seen[i]) {\\n        dfs(i);\\n        groups++;\\n      }\\n    }\\n    return groups - 1;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3248275,
                "title": "c-dsu-explained-striver-s-approach",
                "content": "```\\nclass DisjointSet {\\n    \\npublic: \\n    vector<int> rank, parent, size; \\n    // rank: array to store rank of each set\\n    // parent: array to store parent of each node\\n    // size: array to store size of each set\\n    DisjointSet(int n) {\\n        rank.resize(n+1, 0); \\n        parent.resize(n+1);\\n        size.resize(n+1); \\n        // initialize each node as a parent of itself\\n        // and the size of each set as 1\\n        for(int i = 0;i<=n;i++) {\\n            parent[i] = i; \\n            size[i] = 1; \\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        // find the ultimate parent of the given node\\n        // using path compression\\n        if(node == parent[node])\\n            return node; \\n        return parent[node] = findUPar(parent[node]); \\n    }\\n\\n    void unionByRank(int u, int v) {\\n        // union two sets based on their rank\\n        int ulp_u = findUPar(u); \\n        int ulp_v = findUPar(v); \\n        if(ulp_u == ulp_v) return; \\n        if(rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v; \\n        }\\n        else if(rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u; \\n        }\\n        else {\\n            parent[ulp_v] = ulp_u; \\n            rank[ulp_u]++; \\n        }\\n    }\\n\\n    void unionBySize(int u, int v) {\\n        // union two sets based on their size\\n        int ulp_u = findUPar(u); \\n        int ulp_v = findUPar(v); \\n        if(ulp_u == ulp_v) return; \\n        if(size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v; \\n            size[ulp_v] += size[ulp_u]; \\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v]; \\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& adj) {\\n        DisjointSet ds(n); // create a disjoint set object\\n        int extra=0; // count the number of extra edges\\n        for(auto it: adj){\\n            int u=it[0];\\n            int v=it[1];\\n\\n            if(ds.findUPar(u)==ds.findUPar(v)){\\n                extra++;\\n            }\\n            else{\\n                ds.unionBySize(u,v); // union two sets\\n            }\\n        }\\n\\n        int ans=0; // count the number of connected components\\n        for(int i=0;i<n;i++){\\n            if(ds.parent[i]==i)\\n            ans++;\\n        }\\n        ans=ans-1; // subtract 1 from the count to get the number of cables required\\n        if(extra>=ans)\\n        return ans; // if we have enough extra cables to connect all the components, return the answer\\n\\n        return -1; // otherwise, it\\'s impossible to connect all the components\\n    }\\n}; \\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass DisjointSet {\\n    \\npublic: \\n    vector<int> rank, parent, size; \\n    // rank: array to store rank of each set\\n    // parent: array to store parent of each node\\n    // size: array to store size of each set\\n    DisjointSet(int n) {\\n        rank.resize(n+1, 0); \\n        parent.resize(n+1);\\n        size.resize(n+1); \\n        // initialize each node as a parent of itself\\n        // and the size of each set as 1\\n        for(int i = 0;i<=n;i++) {\\n            parent[i] = i; \\n            size[i] = 1; \\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        // find the ultimate parent of the given node\\n        // using path compression\\n        if(node == parent[node])\\n            return node; \\n        return parent[node] = findUPar(parent[node]); \\n    }\\n\\n    void unionByRank(int u, int v) {\\n        // union two sets based on their rank\\n        int ulp_u = findUPar(u); \\n        int ulp_v = findUPar(v); \\n        if(ulp_u == ulp_v) return; \\n        if(rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v; \\n        }\\n        else if(rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u; \\n        }\\n        else {\\n            parent[ulp_v] = ulp_u; \\n            rank[ulp_u]++; \\n        }\\n    }\\n\\n    void unionBySize(int u, int v) {\\n        // union two sets based on their size\\n        int ulp_u = findUPar(u); \\n        int ulp_v = findUPar(v); \\n        if(ulp_u == ulp_v) return; \\n        if(size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v; \\n            size[ulp_v] += size[ulp_u]; \\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v]; \\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& adj) {\\n        DisjointSet ds(n); // create a disjoint set object\\n        int extra=0; // count the number of extra edges\\n        for(auto it: adj){\\n            int u=it[0];\\n            int v=it[1];\\n\\n            if(ds.findUPar(u)==ds.findUPar(v)){\\n                extra++;\\n            }\\n            else{\\n                ds.unionBySize(u,v); // union two sets\\n            }\\n        }\\n\\n        int ans=0; // count the number of connected components\\n        for(int i=0;i<n;i++){\\n            if(ds.parent[i]==i)\\n            ans++;\\n        }\\n        ans=ans-1; // subtract 1 from the count to get the number of cables required\\n        if(extra>=ans)\\n        return ans; // if we have enough extra cables to connect all the components, return the answer\\n\\n        return -1; // otherwise, it\\'s impossible to connect all the components\\n    }\\n}; \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2914509,
                "title": "c-dsu-easy-approach",
                "content": "Here is my c++ code for this problem.\\n# Complexity\\n- Time complexity:O(V)\\n\\n- Space complexity:O(V)\\n\\n# Code\\n```\\nclass disjointset{\\n    public:\\n    vector<int>par;\\n    disjointset(int n){\\n        par.resize(n+1);\\n        for(int i=0; i<=n; i++){\\n            par[i]=i;\\n        }\\n    }\\n    int findp(int u){\\n        if(par[u]==u){return u;}\\n        return par[u]=findp(par[u]);\\n    }\\n    void un(int u, int v){\\n        par[findp(u)]=par[findp(v)];\\n    }\\n};\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        disjointset d(n);\\n        int cnt=0, cnt1=0;\\n        for(auto it: connections){\\n            if(d.findp(it[0])!=d.findp(it[1])){\\n                d.un(it[0], it[1]);\\n            }\\n            else{\\n                cnt++;\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            if(d.findp(i)==i){cnt1++;}\\n        }\\n        if(cnt1-1<=cnt){return cnt1-1;}\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass disjointset{\\n    public:\\n    vector<int>par;\\n    disjointset(int n){\\n        par.resize(n+1);\\n        for(int i=0; i<=n; i++){\\n            par[i]=i;\\n        }\\n    }\\n    int findp(int u){\\n        if(par[u]==u){return u;}\\n        return par[u]=findp(par[u]);\\n    }\\n    void un(int u, int v){\\n        par[findp(u)]=par[findp(v)];\\n    }\\n};\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        disjointset d(n);\\n        int cnt=0, cnt1=0;\\n        for(auto it: connections){\\n            if(d.findp(it[0])!=d.findp(it[1])){\\n                d.un(it[0], it[1]);\\n            }\\n            else{\\n                cnt++;\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            if(d.findp(i)==i){cnt1++;}\\n        }\\n        if(cnt1-1<=cnt){return cnt1-1;}\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2502984,
                "title": "python-easy-solution-with-explanation-bfs",
                "content": "```\\n# Approach: First check if total number of edges available in network is greater or equal to n-1 (n is number of nodes). If not, then return -1, because it is theoretically not possible to connect all the nodes with less edges. Else, find total\\n# number of isolated clusters (you can use BFS, DFS, Union-Find). Here we have used BFS to find total isolated clusters. Finally, we will require (total_clusters - 1) number of wires to connect them all.\\n\\nfrom collections import deque\\n\\nclass Solution(object):\\n    def makeConnected(self, n, connections):\\n        \"\"\"\\n        :type n: int\\n        :type connections: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        \\n        if len(connections) < n - 1:\\n            return -1\\n        \\n        cluster, queue, graph, visited = 0, deque([]), [[] for i in range(n)], set([])\\n        \\n        # Creating Graph\\n        for c in connections:\\n            graph[c[0]].append(c[1])\\n            graph[c[1]].append(c[0])\\n            \\n        # Counting isolated clusters using BFS\\n        for i in range(n):\\n            if i not in visited:\\n                cluster += 1\\n                queue.append(i)\\n                visited.add(i)\\n                \\n                # BFS\\n                while queue:\\n                    node = queue.popleft()\\n                    \\n                    for nhbrs in graph[node]:\\n                        if nhbrs not in visited:\\n                            queue.append(nhbrs)\\n                            visited.add(nhbrs)\\n        \\n        # Counting Min number of times to get connections\\n        return (cluster - 1)\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Approach: First check if total number of edges available in network is greater or equal to n-1 (n is number of nodes). If not, then return -1, because it is theoretically not possible to connect all the nodes with less edges. Else, find total\\n# number of isolated clusters (you can use BFS, DFS, Union-Find). Here we have used BFS to find total isolated clusters. Finally, we will require (total_clusters - 1) number of wires to connect them all.\\n\\nfrom collections import deque\\n\\nclass Solution(object):\\n    def makeConnected(self, n, connections):\\n        \"\"\"\\n        :type n: int\\n        :type connections: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        \\n        if len(connections) < n - 1:\\n            return -1\\n        \\n        cluster, queue, graph, visited = 0, deque([]), [[] for i in range(n)], set([])\\n        \\n        # Creating Graph\\n        for c in connections:\\n            graph[c[0]].append(c[1])\\n            graph[c[1]].append(c[0])\\n            \\n        # Counting isolated clusters using BFS\\n        for i in range(n):\\n            if i not in visited:\\n                cluster += 1\\n                queue.append(i)\\n                visited.add(i)\\n                \\n                # BFS\\n                while queue:\\n                    node = queue.popleft()\\n                    \\n                    for nhbrs in graph[node]:\\n                        if nhbrs not in visited:\\n                            queue.append(nhbrs)\\n                            visited.add(nhbrs)\\n        \\n        # Counting Min number of times to get connections\\n        return (cluster - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2119609,
                "title": "count-the-connected-network-c",
                "content": "**Explanation**\\nWe need at least n - 1 cables to connect all nodes (like a tree).\\nIf connections.size() < n - 1, we can directly return -1.\\n\\nOne trick is that, if we have enough cables,\\nwe don\\'t need to worry about where we can get the cable from.\\n\\nWe only need to count the number of connected networks.\\nTo connect two unconneccted networks, we need to set one cable.\\n\\nThe number of operations we need = the number of connected networks - 1\\n\\n\\n**Complexity**\\nTime O(connections)\\nSpace O(n)\\n\\n\\n```\\nclass Solution {\\n    int bfsOfGraph(int V, vector<int> adj[])\\n    {\\n        int ans=0;\\n    vector<bool> vis(V, false);\\n    for (int i = 0; i < V; ++i) \\n    {\\n        if (!vis[i]) \\n        {\\n            queue<int> q;\\n            vis[i] = true;\\n            q.push(i);\\n            ans++;\\n            while (!q.empty()) {\\n                int g_node = q.front();\\n                q.pop();\\n                // bfs_traversal.push_back(g_node);\\n                for (auto it : adj[g_node]) {\\n                    if (!vis[it]) {\\n                        vis[it] = true;\\n                        q.push(it);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return ans;\\n}\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& con)\\n    {\\n        vector<int>adj[n];\\n            if(con.size()<n-1)\\n               return -1;\\n\\t\\t\\t   //adjency list\\n        for(int i=0;i<con.size();i++)\\n        {\\n                adj[con[i][1]].push_back(con[i][0]);\\n                adj[con[i][0]].push_back(con[i][1]);\\n\\n        }\\n    \\n            return bfsOfGraph(n,adj)-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    int bfsOfGraph(int V, vector<int> adj[])\\n    {\\n        int ans=0;\\n    vector<bool> vis(V, false);\\n    for (int i = 0; i < V; ++i) \\n    {\\n        if (!vis[i]) \\n        {\\n            queue<int> q;\\n            vis[i] = true;\\n            q.push(i);\\n            ans++;\\n            while (!q.empty()) {\\n                int g_node = q.front();\\n                q.pop();\\n                // bfs_traversal.push_back(g_node);\\n                for (auto it : adj[g_node]) {\\n                    if (!vis[it]) {\\n                        vis[it] = true;\\n                        q.push(it);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return ans;\\n}\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& con)\\n    {\\n        vector<int>adj[n];\\n            if(con.size()<n-1)\\n               return -1;\\n\\t\\t\\t   //adjency list\\n        for(int i=0;i<con.size();i++)\\n        {\\n                adj[con[i][1]].push_back(con[i][0]);\\n                adj[con[i][0]].push_back(con[i][1]);\\n\\n        }\\n    \\n            return bfsOfGraph(n,adj)-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1897354,
                "title": "number-of-operations-to-make-network-connected-dfs",
                "content": "void dfs(int src, ArrayList<ArrayList<Integer>> adj, boolean[]visit){\\n        visit[src]=true;\\n        \\n        for(int i:adj.get(src)){\\n            if(!visit[i]){\\n                dfs(i, adj, visit);\\n            }\\n        }\\n    }\\n    \\n    public int makeConnected(int n, int[][] connections) {\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        \\n        int m = connections.length;\\n        if(m<n-1){\\n            return -1;\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        \\n        for(int[] i:connections){\\n            adj.get(i[0]).add(i[1]);\\n            adj.get(i[1]).add(i[0]);\\n        }\\n        \\n        boolean[]visit = new boolean[n];\\n        int cou=0;\\n        \\n        for(int i=0; i<n; i++){\\n            if(!visit[i]){\\n                cou++;\\n                dfs(i, adj, visit);\\n            }\\n        }\\n        return cou-1;\\n    }",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "void dfs(int src, ArrayList<ArrayList<Integer>> adj, boolean[]visit){\\n        visit[src]=true;\\n        \\n        for(int i:adj.get(src)){\\n            if(!visit[i]){\\n                dfs(i, adj, visit);\\n            }\\n        }\\n    }\\n    \\n    public int makeConnected(int n, int[][] connections) {\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        \\n        int m = connections.length;\\n        if(m<n-1){\\n            return -1;\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        \\n        for(int[] i:connections){\\n            adj.get(i[0]).add(i[1]);\\n            adj.get(i[1]).add(i[0]);\\n        }\\n        \\n        boolean[]visit = new boolean[n];\\n        int cou=0;\\n        \\n        for(int i=0; i<n; i++){\\n            if(!visit[i]){\\n                cou++;\\n                dfs(i, adj, visit);\\n            }\\n        }\\n        return cou-1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1392873,
                "title": "easy-to-understand-python-solution-using-dfs",
                "content": "# The 2 Main Logic of This Implementation Are :-\\n\\t\\'\\'\\'\\n    For every 2 disconnected subGraph, we need 1 edge to connect them.\\n    that means, return the number of disconnected subGraph - 1 \\n    \\'\\'\\'\\n    \\n    \\'\\'\\'\\n    Perform DFS, on every node\\n    If it\\'s Un Visited, add one to the counter of disconnected subGraphs.\\n    then visit it and perform DFS on that node.\\n    \\'\\'\\'\\n\\t\\n\\t\\'\\'\\'  T.C = S.C = O( V + E )\\'\\'\\'\\n```\\nclass Solution:\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        \\n        if len(connections) < n - 1: return -1\\n        \\n        def DO_DFS(isVisited, graph, node):\\n            stack = [node]\\n            while stack:\\n                vertices = stack.pop()\\n                if vertices not in isVisited:\\n                    isVisited.add(vertices)\\n                    \\n                    for vertex in graph[vertices]:\\n                        if vertex not in isVisited:\\n                            stack.append(vertex)\\n        \\n        graph = [ set() for _ in range(n) ]\\n        \\n        for u, v in connections:\\n            graph[u].add(v)\\n            graph[v].add(u)\\n            \\n        isVisited = set()\\n        disconnectedSubGraph = 0\\n        \\n        for node in range(n):\\n            if node not in isVisited:\\n                disconnectedSubGraph += 1\\n                DO_DFS(isVisited, graph, node)\\n                \\n        return disconnectedSubGraph - 1\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        \\n        if len(connections) < n - 1: return -1\\n        \\n        def DO_DFS(isVisited, graph, node):\\n            stack = [node]\\n            while stack:\\n                vertices = stack.pop()\\n                if vertices not in isVisited:\\n                    isVisited.add(vertices)\\n                    \\n                    for vertex in graph[vertices]:\\n                        if vertex not in isVisited:\\n                            stack.append(vertex)\\n        \\n        graph = [ set() for _ in range(n) ]\\n        \\n        for u, v in connections:\\n            graph[u].add(v)\\n            graph[v].add(u)\\n            \\n        isVisited = set()\\n        disconnectedSubGraph = 0\\n        \\n        for node in range(n):\\n            if node not in isVisited:\\n                disconnectedSubGraph += 1\\n                DO_DFS(isVisited, graph, node)\\n                \\n        return disconnectedSubGraph - 1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317370,
                "title": "c-dfs-disjoint-set-easy-to-understand",
                "content": "FIRST approach using DFS,\\nwe will make a adjacency list and simply call DFS traversal,\\nand check for the components in the graph,\\n```\\nclass Solution {\\npublic:\\n// DFS traversal of graph\\n    void DFS(int s,vector<int>& visited,vector<int> adj[])\\n    {\\n        visited[s]=1;\\n        for(auto i:adj[s])\\n        {\\n            if(!visited[i])\\n                DFS(i,visited,adj);\\n        }\\n    }\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n\\t\\n\\t// if the number of edges are less than minimum numbers of edges to connect the graph(i.e. n-1)\\n\\t// then just return -1\\n        if(connections.size()<n-1)\\n            return -1;\\n\\t\\t\\t\\n        int count=0;\\n        vector<int> visited(n,0);\\n        // making the adjacency list \\n        vector<int> adj[n];\\n        for(int i=0;i<connections.size();i++)\\n        {\\n            adj[connections[i][0]].push_back(connections[i][1]);\\n            adj[connections[i][1]].push_back(connections[i][0]);\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(!visited[i])\\n               { DFS(i,visited,adj);\\n                 count++;\\n               }\\n        }\\n\\t\\t// returning the minimum number of operations to connect the computers \\n        return count-1;\\n    }\\n};\\n```\\n\\nSECOND approach using disjoint set (union find)\\n\\n```\\nclass Solution {\\npublic:\\n    \\n     // making parent and rank array\\n        vector<int> parent;\\n        vector<int> rank;\\n        \\n    // making every node its parent\\n    // and assignin rank of every element 0\\n        void make_set(int n)\\n        {\\n            parent=vector<int>(n);\\n            for(int i=0;i<n;i++)\\n                parent[i]=i;\\n            rank=vector<int>(n,0);\\n        }\\n    // path compression\\n    //  this will make a common parent for all the elements that are connected\\n        int find_set(int &x)\\n        {\\n            if(x==parent[x])\\n                return x;\\n            return parent[x]=find_set(parent[x]);\\n        }\\n    // to make union of two elements\\n        void unionmake(int u,int v)\\n        {\\n            u=find_set(u);\\n            v=find_set(v);\\n            if(rank[u]<rank[v])\\n                parent[u]=v;\\n            else if(rank[u]>rank[v])\\n                parent[v]=u;\\n            else {\\n                parent[v]=u;\\n                rank[v]++;\\n            }\\n        }\\n   \\n    \\n    \\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n\\n         make_set(n);\\n        // making union of every edge\\n         for(auto connection:connections)\\n            unionmake(connection[0],connection[1]);\\n        \\n        int connected=0;\\n        // checking for the element being parent of itself\\n        // on incrementing connected it will give the number of components.\\n        for(int i=0;i<n;i++)\\n       { \\n            if(parent[i]==i) \\n               connected++;\\n       }\\n        // if the number of edges are for than the minimum no. of edges required to connect all the computers \\n        // then return connected-1\\n        if(n-1<=connections.size()) return connected-1;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n// DFS traversal of graph\\n    void DFS(int s,vector<int>& visited,vector<int> adj[])\\n    {\\n        visited[s]=1;\\n        for(auto i:adj[s])\\n        {\\n            if(!visited[i])\\n                DFS(i,visited,adj);\\n        }\\n    }\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n\\t\\n\\t// if the number of edges are less than minimum numbers of edges to connect the graph(i.e. n-1)\\n\\t// then just return -1\\n        if(connections.size()<n-1)\\n            return -1;\\n\\t\\t\\t\\n        int count=0;\\n        vector<int> visited(n,0);\\n        // making the adjacency list \\n        vector<int> adj[n];\\n        for(int i=0;i<connections.size();i++)\\n        {\\n            adj[connections[i][0]].push_back(connections[i][1]);\\n            adj[connections[i][1]].push_back(connections[i][0]);\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(!visited[i])\\n               { DFS(i,visited,adj);\\n                 count++;\\n               }\\n        }\\n\\t\\t// returning the minimum number of operations to connect the computers \\n        return count-1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n     // making parent and rank array\\n        vector<int> parent;\\n        vector<int> rank;\\n        \\n    // making every node its parent\\n    // and assignin rank of every element 0\\n        void make_set(int n)\\n        {\\n            parent=vector<int>(n);\\n            for(int i=0;i<n;i++)\\n                parent[i]=i;\\n            rank=vector<int>(n,0);\\n        }\\n    // path compression\\n    //  this will make a common parent for all the elements that are connected\\n        int find_set(int &x)\\n        {\\n            if(x==parent[x])\\n                return x;\\n            return parent[x]=find_set(parent[x]);\\n        }\\n    // to make union of two elements\\n        void unionmake(int u,int v)\\n        {\\n            u=find_set(u);\\n            v=find_set(v);\\n            if(rank[u]<rank[v])\\n                parent[u]=v;\\n            else if(rank[u]>rank[v])\\n                parent[v]=u;\\n            else {\\n                parent[v]=u;\\n                rank[v]++;\\n            }\\n        }\\n   \\n    \\n    \\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n\\n         make_set(n);\\n        // making union of every edge\\n         for(auto connection:connections)\\n            unionmake(connection[0],connection[1]);\\n        \\n        int connected=0;\\n        // checking for the element being parent of itself\\n        // on incrementing connected it will give the number of components.\\n        for(int i=0;i<n;i++)\\n       { \\n            if(parent[i]==i) \\n               connected++;\\n       }\\n        // if the number of edges are for than the minimum no. of edges required to connect all the computers \\n        // then return connected-1\\n        if(n-1<=connections.size()) return connected-1;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1196759,
                "title": "simple-dfs-c-solution",
                "content": "min no of edges to connect n node is n-1 so connecting wire must be greater or equal to n-1\\nthen , Simply just find   (no. of connected component -1)  using dfs method\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void dfs(int u,vector<vector<int>> &v, vector<bool> & vis){\\n        \\n        if(vis[u]) return;\\n        \\n        vis[u]=true;\\n        \\n        for(auto it: v[u]){\\n            \\n            dfs(it,v,vis);\\n        }\\n        \\n    }\\n    \\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        \\n        int len=connections.size();\\n        \\n        if(len<n-1) return -1;\\n        \\n        \\n        vector<vector<int>> v(n);\\n        \\n        int x,y;\\n        \\n        for(int i=0;i<len;i++){\\n            x=connections[i][0];\\n            y=connections[i][1];\\n            \\n            v[x].push_back(y);\\n            v[y].push_back(x);\\n            \\n        }\\n        \\n        int cnt=0;\\n        \\n        vector<bool> vis(n,false);\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            if(!vis[i]) {\\n                \\n                cnt++;\\n                \\n                dfs(i,v,vis);\\n            }\\n        }\\n        \\n        return cnt-1;\\n        \\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(int u,vector<vector<int>> &v, vector<bool> & vis){\\n        \\n        if(vis[u]) return;\\n        \\n        vis[u]=true;\\n        \\n        for(auto it: v[u]){\\n            \\n            dfs(it,v,vis);\\n        }\\n        \\n    }\\n    \\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        \\n        int len=connections.size();\\n        \\n        if(len<n-1) return -1;\\n        \\n        \\n        vector<vector<int>> v(n);\\n        \\n        int x,y;\\n        \\n        for(int i=0;i<len;i++){\\n            x=connections[i][0];\\n            y=connections[i][1];\\n            \\n            v[x].push_back(y);\\n            v[y].push_back(x);\\n            \\n        }\\n        \\n        int cnt=0;\\n        \\n        vector<bool> vis(n,false);\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            if(!vis[i]) {\\n                \\n                cnt++;\\n                \\n                dfs(i,v,vis);\\n            }\\n        }\\n        \\n        return cnt-1;\\n        \\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175998,
                "title": "python-union-by-rank-dfs",
                "content": "Union Find Solution\\n```\\nclass Solution:\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        if len(connections) < n - 1:\\n            return -1\\n\\n        parent_nodes = {i: i for i in range(n)}\\n        rank_nodes = {i: 0 for i in range(n)}\\n\\n        def find(node):\\n            if node != parent_nodes[node]:\\n                parent_nodes[node] = find(parent_nodes[node])\\n            return parent_nodes[node]\\n\\n        def merge(node_x, node_y):\\n            parent_x = find(node_x)\\n            parent_y = find(node_y)\\n            if parent_x != parent_y:\\n                rank_x = rank_nodes[parent_x]\\n                rank_y = rank_nodes[parent_y]\\n                if rank_x < rank_y:\\n                    parent_nodes[parent_x] = parent_y\\n                elif rank_x > rank_y:\\n                    parent_nodes[parent_y] = parent_x\\n                elif rank_x == rank_y:\\n                    parent_nodes[parent_x] = parent_y\\n                    rank_nodes[parent_y] += 1\\n                return True\\n            return False\\n        \\n        for u, v in connections:\\n            if merge(u, v):\\n                n -= 1\\n           \\n        return n - 1\\n```\\n\\nDepth First Search Solution\\n```\\n\\nclass Solution:\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        if len(connections) + 1 < n:\\n            return -1\\n        \\n        graph = collections.defaultdict(set)\\n        \\n        for u, v in connections:\\n            graph[u].add(v)\\n            graph[v].add(u)\\n        \\n        visited_nodes = set()\\n        collection_of_nodes = 0\\n        \\n        def dfs(node):\\n            visited_nodes.add(node)\\n            for adj_node in graph[node]:\\n                if adj_node not in visited_nodes:\\n                    dfs(adj_node)\\n        \\n        for node in range(n):\\n            if node not in visited_nodes:\\n                dfs(node)\\n                collection_of_nodes += 1\\n        \\n        return collection_of_nodes - 1\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        if len(connections) < n - 1:\\n            return -1\\n\\n        parent_nodes = {i: i for i in range(n)}\\n        rank_nodes = {i: 0 for i in range(n)}\\n\\n        def find(node):\\n            if node != parent_nodes[node]:\\n                parent_nodes[node] = find(parent_nodes[node])\\n            return parent_nodes[node]\\n\\n        def merge(node_x, node_y):\\n            parent_x = find(node_x)\\n            parent_y = find(node_y)\\n            if parent_x != parent_y:\\n                rank_x = rank_nodes[parent_x]\\n                rank_y = rank_nodes[parent_y]\\n                if rank_x < rank_y:\\n                    parent_nodes[parent_x] = parent_y\\n                elif rank_x > rank_y:\\n                    parent_nodes[parent_y] = parent_x\\n                elif rank_x == rank_y:\\n                    parent_nodes[parent_x] = parent_y\\n                    rank_nodes[parent_y] += 1\\n                return True\\n            return False\\n        \\n        for u, v in connections:\\n            if merge(u, v):\\n                n -= 1\\n           \\n        return n - 1\\n```\n```\\n\\nclass Solution:\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        if len(connections) + 1 < n:\\n            return -1\\n        \\n        graph = collections.defaultdict(set)\\n        \\n        for u, v in connections:\\n            graph[u].add(v)\\n            graph[v].add(u)\\n        \\n        visited_nodes = set()\\n        collection_of_nodes = 0\\n        \\n        def dfs(node):\\n            visited_nodes.add(node)\\n            for adj_node in graph[node]:\\n                if adj_node not in visited_nodes:\\n                    dfs(adj_node)\\n        \\n        for node in range(n):\\n            if node not in visited_nodes:\\n                dfs(node)\\n                collection_of_nodes += 1\\n        \\n        return collection_of_nodes - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1045027,
                "title": "java-union-find-beats-100-2ms",
                "content": "\\n    // O(n+connections.length)\\n    public int makeConnected(int n, int[][] connections) {\\n\\n\\t\\tif (connections.length < n - 1)\\n\\t\\t\\treturn -1;\\n\\n\\t\\tint[] rank = new int[n];\\n\\t\\tint[] parent = new int[n];\\n\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tparent[i] = i;\\n\\n\\t\\tint groups = n;\\n\\n\\t\\tfor (int[] connection : connections) {\\n\\t\\t\\tint u = connection[0];\\n\\t\\t\\tint v = connection[1];\\n\\t\\t\\tboolean flag = union(parent, rank, u, v);\\n\\t\\t\\tif (flag)\\n\\t\\t\\t\\tgroups--;\\n\\t\\t}\\n\\n\\t\\treturn groups - 1;\\n\\t}\\n\\n\\t// O(1)\\n\\tpublic static int find(int[] parent, int x) {\\n\\n\\t\\tif (parent[x] == x)\\n\\t\\t\\treturn x;\\n\\n\\t\\tint temp = find(parent, parent[x]);\\n\\t\\tparent[x] = temp;\\n\\t\\treturn temp;\\n\\t}\\n\\n\\t// O(1)\\n\\tpublic static boolean union(int[] parent, int[] rank, int x, int y) {\\n\\n\\t\\tint parentx = find(parent, x);\\n\\t\\tint parenty = find(parent, y);\\n\\n\\t\\tif (parentx == parenty)\\n\\t\\t\\treturn false;\\n\\n\\t\\tint rankx = rank[parentx];\\n\\t\\tint ranky = rank[parenty];\\n\\n\\t\\tif (rankx < ranky)\\n\\t\\t\\tparent[parentx] = parenty;\\n\\t\\telse if (rankx > ranky)\\n\\t\\t\\tparent[parenty] = parentx;\\n\\t\\telse {\\n\\t\\t\\tparent[parentx] = parenty;\\n\\t\\t\\trank[parenty]++;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n",
                "solutionTags": [],
                "code": "\\n    // O(n+connections.length)\\n    public int makeConnected(int n, int[][] connections) {\\n\\n\\t\\tif (connections.length < n - 1)\\n\\t\\t\\treturn -1;\\n\\n\\t\\tint[] rank = new int[n];\\n\\t\\tint[] parent = new int[n];\\n\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tparent[i] = i;\\n\\n\\t\\tint groups = n;\\n\\n\\t\\tfor (int[] connection : connections) {\\n\\t\\t\\tint u = connection[0];\\n\\t\\t\\tint v = connection[1];\\n\\t\\t\\tboolean flag = union(parent, rank, u, v);\\n\\t\\t\\tif (flag)\\n\\t\\t\\t\\tgroups--;\\n\\t\\t}\\n\\n\\t\\treturn groups - 1;\\n\\t}\\n\\n\\t// O(1)\\n\\tpublic static int find(int[] parent, int x) {\\n\\n\\t\\tif (parent[x] == x)\\n\\t\\t\\treturn x;\\n\\n\\t\\tint temp = find(parent, parent[x]);\\n\\t\\tparent[x] = temp;\\n\\t\\treturn temp;\\n\\t}\\n\\n\\t// O(1)\\n\\tpublic static boolean union(int[] parent, int[] rank, int x, int y) {\\n\\n\\t\\tint parentx = find(parent, x);\\n\\t\\tint parenty = find(parent, y);\\n\\n\\t\\tif (parentx == parenty)\\n\\t\\t\\treturn false;\\n\\n\\t\\tint rankx = rank[parentx];\\n\\t\\tint ranky = rank[parenty];\\n\\n\\t\\tif (rankx < ranky)\\n\\t\\t\\tparent[parentx] = parenty;\\n\\t\\telse if (rankx > ranky)\\n\\t\\t\\tparent[parenty] = parentx;\\n\\t\\telse {\\n\\t\\t\\tparent[parentx] = parenty;\\n\\t\\t\\trank[parenty]++;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 722758,
                "title": "python-dfs-union-find-soln",
                "content": "```\\nclass Solution(object):\\n    def makeConnected(self, n, connections):\\n        \"\"\"\\n        :type n: int\\n        :type connections: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if len(connections) < n - 1:\\n            return -1\\n        \\n        parent = [-1] * n\\n\\n        def find(x):\\n            if parent[x] == -1:\\n                return x\\n            parent[x] = find(parent[x])\\n            return parent[x]\\n        \\n        def union(x, y):\\n            parentX = find(x)\\n            parentY = find(y)\\n            if parentX != parentY:\\n                parent[parentY] = parentX\\n            \\n        for a, b in connections:\\n            union(a, b)\\n        \\n        count = 0\\n        for i in parent:\\n            if i < 0:\\n                count += 1\\n        return count - 1\\n                \\n               \\n        \"\"\"\\n        # DFS solution\\n        \\n        if len(connections) < n - 1:\\n            return -1\\n        \\n        def dfs(node, graph, visited):\\n            visited.add(node)\\n            for neighbor in graph[node]:\\n                if neighbor not in visited:\\n                    dfs(neighbor, graph, visited)\\n        \\n        graph = collections.defaultdict(list)\\n        for a,b in connections:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n            \\n        count = 0\\n        visited = set()\\n        for i in range(n):\\n            if i not in visited:\\n                dfs(i, graph, visited)\\n                count += 1\\n        return count - 1\\n        \"\"\"\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def makeConnected(self, n, connections):\\n        \"\"\"\\n        :type n: int\\n        :type connections: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if len(connections) < n - 1:\\n            return -1\\n        \\n        parent = [-1] * n\\n\\n        def find(x):\\n            if parent[x] == -1:\\n                return x\\n            parent[x] = find(parent[x])\\n            return parent[x]\\n        \\n        def union(x, y):\\n            parentX = find(x)\\n            parentY = find(y)\\n            if parentX != parentY:\\n                parent[parentY] = parentX\\n            \\n        for a, b in connections:\\n            union(a, b)\\n        \\n        count = 0\\n        for i in parent:\\n            if i < 0:\\n                count += 1\\n        return count - 1\\n                \\n               \\n        \"\"\"\\n        # DFS solution\\n        \\n        if len(connections) < n - 1:\\n            return -1\\n        \\n        def dfs(node, graph, visited):\\n            visited.add(node)\\n            for neighbor in graph[node]:\\n                if neighbor not in visited:\\n                    dfs(neighbor, graph, visited)\\n        \\n        graph = collections.defaultdict(list)\\n        for a,b in connections:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n            \\n        count = 0\\n        visited = set()\\n        for i in range(n):\\n            if i not in visited:\\n                dfs(i, graph, visited)\\n                count += 1\\n        return count - 1\\n        \"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 501526,
                "title": "java-easy-to-understand-dfs-count-connected-component",
                "content": "```\\nclass Solution {\\n    public int makeConnected(int n, int[][] connections) {\\n      boolean visited []=new boolean[n];\\n       ArrayList<Integer>[] adj=new ArrayList[n];\\n        for(int i=0;i<adj.length;i++){\\n            adj[i]=new ArrayList<Integer>();\\n        }\\n      \\n            for(int arr[]:connections){\\n               adj[arr[0]].add(arr[1]);\\n                adj[arr[1]].add(arr[0]);\\n                  \\n              }\\n          \\n          int no_of_component=0;\\n        for(int i=0;i<n;i++){\\n            if(visited[i]!=true){\\n                no_of_component++;\\n                dfs(i,visited,adj);\\n            }\\n            \\n        }\\n        return connections.length>=n-1?no_of_component-1:-1;\\n    }\\n        public void dfs(int n,boolean visited[],ArrayList<Integer>[]adj){\\n            if(visited[n]!=true){\\n                visited[n]=true;\\n                for(int a:adj[n]){\\n                    if(visited[a]!=true){\\n                        dfs(a,visited,adj);\\n                    }\\n                }\\n            }\\n        }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int makeConnected(int n, int[][] connections) {\\n      boolean visited []=new boolean[n];\\n       ArrayList<Integer>[] adj=new ArrayList[n];\\n        for(int i=0;i<adj.length;i++){\\n            adj[i]=new ArrayList<Integer>();\\n        }\\n      \\n            for(int arr[]:connections){\\n               adj[arr[0]].add(arr[1]);\\n                adj[arr[1]].add(arr[0]);\\n                  \\n              }\\n          \\n          int no_of_component=0;\\n        for(int i=0;i<n;i++){\\n            if(visited[i]!=true){\\n                no_of_component++;\\n                dfs(i,visited,adj);\\n            }\\n            \\n        }\\n        return connections.length>=n-1?no_of_component-1:-1;\\n    }\\n        public void dfs(int n,boolean visited[],ArrayList<Integer>[]adj){\\n            if(visited[n]!=true){\\n                visited[n]=true;\\n                for(int a:adj[n]){\\n                    if(visited[a]!=true){\\n                        dfs(a,visited,adj);\\n                    }\\n                }\\n            }\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3335291,
                "title": "100-easy-solution-dfs-count-the-number-of-disconnected-components-in-graph",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthere is n-1 edges required to connect n nodes in graph if number of edges less than n-1 graph cannot be connected , simply return -1.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nthis problem is application of count number of components in graph.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nwe use dfs here so the time complexity is simply \\n$$O(V+E)$$.\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nhere  V: no. of vertices in graph\\n      E: no. of edges in graph \\nby dfs - $$O(V)$$\\nby adjacency list - $$O(V+E)$$\\n\\noverall time complexity is = $$O(V+E)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void dfs(vector<int> adj[],vector<bool> &visited,int src){\\n        visited[src] = true;\\n        for(auto i:adj[src]){\\n            if(!visited[i]){\\n                dfs(adj,visited,i);\\n            }\\n        }\\n     }\\n\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        // if no. of edges is less than n-1 , there is no way to graph connected\\n        if(connections.size()<n-1) return -1;\\n\\n        // this problem is application of count the no. of components in graph\\n        // creating adjacency list\\n        vector<int> adj[n];\\n        for(auto v:connections){\\n            adj[v[0]].push_back(v[1]);\\n            adj[v[1]].push_back(v[0]);\\n        }\\n\\n        //create a visited arrray to track all visited node\\n        vector<bool> visited(n,false);\\n\\n        //count the no. of disconnected components and return no. of components-1 as the answer\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            if(!visited[i]){\\n                dfs(adj,visited,i);\\n                ans++;\\n            }\\n        }\\n        return ans-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void dfs(vector<int> adj[],vector<bool> &visited,int src){\\n        visited[src] = true;\\n        for(auto i:adj[src]){\\n            if(!visited[i]){\\n                dfs(adj,visited,i);\\n            }\\n        }\\n     }\\n\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        // if no. of edges is less than n-1 , there is no way to graph connected\\n        if(connections.size()<n-1) return -1;\\n\\n        // this problem is application of count the no. of components in graph\\n        // creating adjacency list\\n        vector<int> adj[n];\\n        for(auto v:connections){\\n            adj[v[0]].push_back(v[1]);\\n            adj[v[1]].push_back(v[0]);\\n        }\\n\\n        //create a visited arrray to track all visited node\\n        vector<bool> visited(n,false);\\n\\n        //count the no. of disconnected components and return no. of components-1 as the answer\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            if(!visited[i]){\\n                dfs(adj,visited,i);\\n                ans++;\\n            }\\n        }\\n        return ans-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332607,
                "title": "easy-and-clear-solution-python3",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    nbCC=0    \\n    def makeConnected(self, n: int, cnx: List[List[int]]) -> int:\\n        if len(cnx) < n - 1:\\n            return -1\\n        adj=[]\\n        visit=set()\\n        for i in range(n):\\n            adj.append([])\\n        for i in cnx:\\n            adj[i[0]].append(i[1])\\n            adj[i[1]].append(i[0])\\n        def dfs(node:int):\\n            visit.add(node)\\n            for i in adj[node]:\\n                if i not in visit:\\n                    dfs(i)\\n        for j in range(n):\\n            if j not in visit:\\n                print(j)\\n                self.nbCC+=1\\n                dfs(j)\\n        return self.nbCC-1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    nbCC=0    \\n    def makeConnected(self, n: int, cnx: List[List[int]]) -> int:\\n        if len(cnx) < n - 1:\\n            return -1\\n        adj=[]\\n        visit=set()\\n        for i in range(n):\\n            adj.append([])\\n        for i in cnx:\\n            adj[i[0]].append(i[1])\\n            adj[i[1]].append(i[0])\\n        def dfs(node:int):\\n            visit.add(node)\\n            for i in adj[node]:\\n                if i not in visit:\\n                    dfs(i)\\n        for j in range(n):\\n            if j not in visit:\\n                print(j)\\n                self.nbCC+=1\\n                dfs(j)\\n        return self.nbCC-1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3331881,
                "title": "c-solution",
                "content": "\\nclass Solution {\\npublic:\\n\\n     \\n    void dfs(int source , vector<vector<int>> &adjList , vector<int> &visited)\\n    {\\n        visited[source] = 1;\\n        for(int i=0; i<adjList[source].size(); i++)\\n        {\\n            int node = adjList[source][i];\\n\\n            if(visited[node] == 0) dfs(node, adjList,visited);\\n        }\\n    }  \\n\\n    \\n   \\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n\\n           int s = connections.size();\\n           vector<vector<int>> adjList(n);\\n           int connected_components = 0;\\n           vector<int> visited(n,0);\\n\\n           for(auto i : connections)\\n           {\\n               adjList[i[0]].push_back(i[1]);\\n               adjList[i[1]].push_back(i[0]);\\n           } \\n\\n           for(int i=0; i<n; i++)\\n           {\\n              if(visited[i]==0)\\n              {\\n                  dfs(i,adjList,visited);\\n                  connected_components++;\\n              }\\n           }\\n\\n           return  s >= n-1 ? connected_components-1 : -1;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n\\n     \\n    void dfs(int source , vector<vector<int>> &adjList , vector<int> &visited)\\n    {\\n        visited[source] = 1;\\n        for(int i=0; i<adjList[source].size(); i++)\\n        {\\n            int node = adjList[source][i];\\n\\n            if(visited[node] == 0) dfs(node, adjList,visited);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3331869,
                "title": "can-connected",
                "content": "\\n```\\nclass Solution {\\n    static int MaxCon;\\n    static int dots;\\n    public void dfs(int start, HashSet<Integer>[] grapf, HashSet<Integer> visited)\\n    {\\n        visited.remove(start);\\n        for(int neib : grapf[start])\\n        {\\n            MaxCon++;\\n            if (visited.contains(neib))\\n                dfs(neib, grapf, visited);\\n        }\\n        dots++;\\n    }\\n    public void fullGraph(HashSet<Integer>[] grapf, int[][] connections)\\n    {\\n        for(int[] con : connections)\\n        {\\n            grapf[con[0]].add(con[1]);\\n            grapf[con[1]].add(con[0]);\\n        }\\n    }\\n    public int makeConnected(int n, int[][] connections) {\\n        MaxCon = 0;\\n        dots = 0;\\n        HashSet<Integer>[] grapf = new HashSet[n];\\n        for(int i = 0; i < n; i++)\\n            grapf[i] = new HashSet<>();\\n        HashSet<Integer> visited = new HashSet<>();\\n        for(int i = 0; i < n; i++) visited.add(i);\\n        fullGraph(grapf, connections);\\n        int countCol = -1;\\n        int use = 0;\\n        for(int i = 0; i < n; i++) {\\n            if (visited.contains(i)) {\\n                MaxCon = 0;\\n                dots = 0;\\n                countCol++;\\n                dfs(i, grapf, visited);\\n                use += MaxCon/2 -dots + 1;\\n            }\\n\\n        }\\n        if(use >= countCol)\\n            return countCol;\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static int MaxCon;\\n    static int dots;\\n    public void dfs(int start, HashSet<Integer>[] grapf, HashSet<Integer> visited)\\n    {\\n        visited.remove(start);\\n        for(int neib : grapf[start])\\n        {\\n            MaxCon++;\\n            if (visited.contains(neib))\\n                dfs(neib, grapf, visited);\\n        }\\n        dots++;\\n    }\\n    public void fullGraph(HashSet<Integer>[] grapf, int[][] connections)\\n    {\\n        for(int[] con : connections)\\n        {\\n            grapf[con[0]].add(con[1]);\\n            grapf[con[1]].add(con[0]);\\n        }\\n    }\\n    public int makeConnected(int n, int[][] connections) {\\n        MaxCon = 0;\\n        dots = 0;\\n        HashSet<Integer>[] grapf = new HashSet[n];\\n        for(int i = 0; i < n; i++)\\n            grapf[i] = new HashSet<>();\\n        HashSet<Integer> visited = new HashSet<>();\\n        for(int i = 0; i < n; i++) visited.add(i);\\n        fullGraph(grapf, connections);\\n        int countCol = -1;\\n        int use = 0;\\n        for(int i = 0; i < n; i++) {\\n            if (visited.contains(i)) {\\n                MaxCon = 0;\\n                dots = 0;\\n                countCol++;\\n                dfs(i, grapf, visited);\\n                use += MaxCon/2 -dots + 1;\\n            }\\n\\n        }\\n        if(use >= countCol)\\n            return countCol;\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3331449,
                "title": "simple-ruby-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(m), where m is the number of connections (union operations). Since we are using the path compression, a single union operation is O(log*(m)) per this Wikipedia article. With ranking, it is O(\\u03B1(m)), where \\u03B1 is the inverse of the Ackerman function. For practical purposes, we can consider \\u03B1(m) a constant. So, we are performing m operations, each taking a constant time.\\n\\n- Space complexity:\\nO(n) for the disjoint set.\\n\\n# Code\\n```\\n# Runtime 135 ms, Beats 100%\\n# Memory 215.3 MB, Beats 100%\\n# @param {Integer} n\\n# @param {Integer[][]} connections\\n# @return {Integer}\\ndef make_connected(n, connections)\\n  return -1 if connections.size < n - 1\\n\\n  number = n\\n  ds = Array.new(n, -1)\\n\\n  connections.each do |c|\\n    i = find(ds, c[0])\\n    j = find(ds, c[1])\\n\\n    if i != j\\n      if ds[j] < ds[i]\\n        i, j = j, i\\n      end\\n\\n      ds[i] += ds[j]\\n      ds[j] = i\\n      number -= 1\\n    end\\n  end\\n\\n  number - 1\\nend\\n\\ndef find(ds, i)\\n  ds[i] < 0 ? i : ds[i] = find(ds, ds[i])\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# Runtime 135 ms, Beats 100%\\n# Memory 215.3 MB, Beats 100%\\n# @param {Integer} n\\n# @param {Integer[][]} connections\\n# @return {Integer}\\ndef make_connected(n, connections)\\n  return -1 if connections.size < n - 1\\n\\n  number = n\\n  ds = Array.new(n, -1)\\n\\n  connections.each do |c|\\n    i = find(ds, c[0])\\n    j = find(ds, c[1])\\n\\n    if i != j\\n      if ds[j] < ds[i]\\n        i, j = j, i\\n      end\\n\\n      ds[i] += ds[j]\\n      ds[j] = i\\n      number -= 1\\n    end\\n  end\\n\\n  number - 1\\nend\\n\\ndef find(ds, i)\\n  ds[i] < 0 ? i : ds[i] = find(ds, ds[i])\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3331360,
                "title": "java-easy-to-understand-bfs-solution-commented",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int makeConnected(int n, int[][] connections) {\\n    LinkedList<Integer>[] g = new LinkedList[n];                 //create graph\\n    for(int i = 0; i != n; ++i) g[i] = new LinkedList<>();\\n\\n    for(int[] c: connections){                                   //put in graph all components\\n      g[c[0]].add(c[1]); \\n      g[c[1]].add(c[0]);\\n    }\\n\\n    int[] vis = new int[n];                                      //visited for BFS\\n    int free_edges = 0, components = 0;                          //will count in graph all components and all edges for it\\n    for(int i = 0; i != n; ++i)\\n      if(vis[i] == 0){                                //we have new component\\n        int edges = 0, vertexes = 0;                  //for all vertexes and edges in it\\n        \\n        LinkedList<Integer> q = new LinkedList<>();   //BFS for component\\n        q.add(i);\\n        while(!q.isEmpty()){\\n          int node = q.poll();\\n          if(vis[node] == 1) continue;\\n          vis[node] = 1;\\n          ++vertexes;\\n          edges += g[node].size();\\n\\n          for(int neib: g[node])\\n            if(vis[neib] == 0) q.add(neib);\\n        }\\n\\n        free_edges += (edges>>1) - vertexes + 1;      //fetch all free edges (convert component into DAG)\\n        ++components;\\n      }\\n\\n    if(free_edges < (components - 1) ) return -1;     //check number of components and free edges\\n    return components - 1;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int makeConnected(int n, int[][] connections) {\\n    LinkedList<Integer>[] g = new LinkedList[n];                 //create graph\\n    for(int i = 0; i != n; ++i) g[i] = new LinkedList<>();\\n\\n    for(int[] c: connections){                                   //put in graph all components\\n      g[c[0]].add(c[1]); \\n      g[c[1]].add(c[0]);\\n    }\\n\\n    int[] vis = new int[n];                                      //visited for BFS\\n    int free_edges = 0, components = 0;                          //will count in graph all components and all edges for it\\n    for(int i = 0; i != n; ++i)\\n      if(vis[i] == 0){                                //we have new component\\n        int edges = 0, vertexes = 0;                  //for all vertexes and edges in it\\n        \\n        LinkedList<Integer> q = new LinkedList<>();   //BFS for component\\n        q.add(i);\\n        while(!q.isEmpty()){\\n          int node = q.poll();\\n          if(vis[node] == 1) continue;\\n          vis[node] = 1;\\n          ++vertexes;\\n          edges += g[node].size();\\n\\n          for(int neib: g[node])\\n            if(vis[neib] == 0) q.add(neib);\\n        }\\n\\n        free_edges += (edges>>1) - vertexes + 1;      //fetch all free edges (convert component into DAG)\\n        ++components;\\n      }\\n\\n    if(free_edges < (components - 1) ) return -1;     //check number of components and free edges\\n    return components - 1;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3331187,
                "title": "python3-solution-dfs-approach",
                "content": "# Complexity\\n- Time complexity:\\nO(E+V)\\n\\n- Space complexity:\\nO(V)\\n\\n# Code\\n```\\nclass Solution:\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        adj=defaultdict(list)\\n        for ele1,ele2 in connections:\\n            adj[ele1].append(ele2)\\n            adj[ele2].append(ele1)\\n        self.cables=0\\n        def dfs(i,visited,adj,parent):\\n            if(i in visited):\\n                self.cables+=1\\n                return\\n            visited.add(i)\\n            for child in adj[i]:\\n                if child!=parent:\\n                    dfs(child,visited,adj,i)\\n        c=0\\n        visited=set()\\n        for i in range(n):\\n            if i not in visited:\\n                c+=1\\n                dfs(i,visited,adj,-1)\\n        if(self.cables//2>=c-1):\\n            return c-1\\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        adj=defaultdict(list)\\n        for ele1,ele2 in connections:\\n            adj[ele1].append(ele2)\\n            adj[ele2].append(ele1)\\n        self.cables=0\\n        def dfs(i,visited,adj,parent):\\n            if(i in visited):\\n                self.cables+=1\\n                return\\n            visited.add(i)\\n            for child in adj[i]:\\n                if child!=parent:\\n                    dfs(child,visited,adj,i)\\n        c=0\\n        visited=set()\\n        for i in range(n):\\n            if i not in visited:\\n                c+=1\\n                dfs(i,visited,adj,-1)\\n        if(self.cables//2>=c-1):\\n            return c-1\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3330837,
                "title": "animation-dfs-bfs-no-of-components-1-meme-most-upvoted",
                "content": "# Intuition\\n![dfs.png](https://assets.leetcode.com/users/images/d72cfcad-2174-4901-9ae3-24508e63786f_1679546606.0385344.png)\\nThe graph above has seven nodes. We needed at least six edges to connect the entire graph (which we have), so we could form a connected graph. As you can see, the component with four nodes has \"extra\" edges which we replaced to connect the entire graph.\\n\\nTo figure out how many connected components there are in the graph, we first mark all nodes as unvisited. We create a variable called numberOfConnectedComponents to count the number of connected components in the graph and initialize it to 0.\\n\\nWe iterate through all the nodes from 0 to n - 1, checking whether each node has been visited or not. If node is not visited, we begin a DFS traversal from node and increment numberOfConnectedComponents by 1 (a new connected component is discovered). The DFS traversal would visit all of the nodes in the component to which node belongs.\\n\\nAs an answer, we return numberofConnectedComponents - 1.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Check the size of connections. If it is less than n - 1, we don\\'t have enough edges to connect the entire graph . We return -1 in this case.\\n2. Create an adjacency list using connections where ans[x] contains all the neighbors of node x.\\n3. Create an integer numberOfConnectedComponents which stores the number of connected components in the graph. Initialize it to 0.\\n4. Create a visit array of length n to keep track of nodes that have been visited.\\n5. Iterate through all of the nodes, and for each node i check if it has been visited or not. If node i is not visited, we increment numberOfConnectedComponents by 1 and start a DFS traversal:\\n6. We use the dfs function to perform the traversal. For each call, pass node, edges, and visit as the parameters. We start with node i.\\n7. We mark node as visited.\\n8. We iterate over all the neighbors of node. If any neighbor has not yet been visited, we recursively call dfs with neighbor as the node.\\n9. Return numberOfConnectedComponents - 1.\\n\\n```java []\\n    public int makeConnected(int n, int[][] c) {\\n        if(c.length<n-1) return -1;\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for(int i=0;i<n+1;i++) ans.add(new ArrayList<>());\\n        for(int k[]:c){\\n            ans.get(k[0]).add(k[1]);\\n            ans.get(k[1]).add(k[0]);\\n        }\\n        int res=0, vis[] = new int[n];\\n        for(int i=0;i<n;i++)\\n            if(vis[i]==0){\\n                res++;\\n                dfs(i,ans,vis);\\n            }\\n        return res-1;\\n    }\\n    void dfs(int node,List<List<Integer>> ans,int vis[] ){\\n        vis[node]=1;\\n        for(int k:ans.get(node))\\n            if(vis[k]==0) dfs(k,ans,vis);\\n    }\\n```\\n```java []\\npublic int makeConnected(int n, int[][] c) {\\n        if(c.length<n-1) return -1;\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for(int i=0;i<n+1;i++) ans.add(new ArrayList<>());\\n        for(int k[]:c){\\n            ans.get(k[0]).add(k[1]);\\n            ans.get(k[1]).add(k[0]);\\n        }\\n        int res=0, vis[] = new int[n];\\n        for(int i=0;i<n;i++)\\n            if(vis[i]==0){\\n                res++;\\n                bfs(i,ans,vis);\\n            }\\n        return res-1;\\n}\\nvoid bfs(int node,List<List<Integer>> ans,int vis[] ){\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(node);\\n        while(!q.isEmpty())\\n            for(int k:ans.get(q.remove()))\\n                if(vis[k]==0){\\n                    vis[k]=1;\\n                    q.offer(k);\\n                }\\n    }\\n```\\n# Complexity\\n- Time complexity:O(v+2(e))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(v+2(e))\\n\\n![MEME.png](https://assets.leetcode.com/users/images/622bb8af-7374-4c81-9415-ba22f8c7c597_1679546860.0409193.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Graph"
                ],
                "code": "```java []\\n    public int makeConnected(int n, int[][] c) {\\n        if(c.length<n-1) return -1;\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for(int i=0;i<n+1;i++) ans.add(new ArrayList<>());\\n        for(int k[]:c){\\n            ans.get(k[0]).add(k[1]);\\n            ans.get(k[1]).add(k[0]);\\n        }\\n        int res=0, vis[] = new int[n];\\n        for(int i=0;i<n;i++)\\n            if(vis[i]==0){\\n                res++;\\n                dfs(i,ans,vis);\\n            }\\n        return res-1;\\n    }\\n    void dfs(int node,List<List<Integer>> ans,int vis[] ){\\n        vis[node]=1;\\n        for(int k:ans.get(node))\\n            if(vis[k]==0) dfs(k,ans,vis);\\n    }\\n```\n```java []\\npublic int makeConnected(int n, int[][] c) {\\n        if(c.length<n-1) return -1;\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for(int i=0;i<n+1;i++) ans.add(new ArrayList<>());\\n        for(int k[]:c){\\n            ans.get(k[0]).add(k[1]);\\n            ans.get(k[1]).add(k[0]);\\n        }\\n        int res=0, vis[] = new int[n];\\n        for(int i=0;i<n;i++)\\n            if(vis[i]==0){\\n                res++;\\n                bfs(i,ans,vis);\\n            }\\n        return res-1;\\n}\\nvoid bfs(int node,List<List<Integer>> ans,int vis[] ){\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(node);\\n        while(!q.isEmpty())\\n            for(int k:ans.get(q.remove()))\\n                if(vis[k]==0){\\n                    vis[k]=1;\\n                    q.offer(k);\\n                }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3330505,
                "title": "easy-to-understand-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<int>g[],vector<int>&vis){\\n        vis[node] = 1;\\n        for(auto i:g[node]){\\n            if(!vis[i]){\\n                dfs(i,g,vis);\\n            }\\n        }\\n    }\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        vector<int>g[n];\\n        int m = connections.size();\\n        if(m < n-1) return -1;\\n        for(int i=0; i<m; i++){\\n            int u = connections[i][0], v = connections[i][1];\\n            g[u].push_back(v);\\n            g[v].push_back(u);\\n        }\\n        vector<int>vis(n,0);\\n        int cnt = 0;\\n        for(int i=0; i<n; i++){\\n            if(!vis[i]){\\n                cnt++;\\n                dfs(i,g,vis);\\n            }\\n        }\\n        return cnt-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<int>g[],vector<int>&vis){\\n        vis[node] = 1;\\n        for(auto i:g[node]){\\n            if(!vis[i]){\\n                dfs(i,g,vis);\\n            }\\n        }\\n    }\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        vector<int>g[n];\\n        int m = connections.size();\\n        if(m < n-1) return -1;\\n        for(int i=0; i<m; i++){\\n            int u = connections[i][0], v = connections[i][1];\\n            g[u].push_back(v);\\n            g[v].push_back(u);\\n        }\\n        vector<int>vis(n,0);\\n        int cnt = 0;\\n        for(int i=0; i<n; i++){\\n            if(!vis[i]){\\n                cnt++;\\n                dfs(i,g,vis);\\n            }\\n        }\\n        return cnt-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3330464,
                "title": "short-sweet-easy-to-understand-c-dfs",
                "content": "````\\nclass Solution {\\npublic:\\n    void solve(int s,vector<bool> &v,vector<vector<int>> &g){\\n        if(v[s])return;\\n        v[s] = true;\\n        for(auto &i: g[s]){\\n            solve(i,v,g);\\n        }\\n    }\\n    int makeConnected(int n, vector<vector<int>>& v) {\\n        if(v.size()<n-1)return -1;\\n        vector<vector<int>> g(n);\\n        for(auto &i: v){\\n            g[i[0]].push_back(i[1]);\\n            g[i[1]].push_back(i[0]);\\n        }\\n        vector<bool> vis(n,false);\\n        int ans = -1;\\n        for(int i = 0; i < n; i++){\\n            if(!vis[i]){\\n                solve(i,vis,g);\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    void solve(int s,vector<bool> &v,vector<vector<int>> &g){\\n        if(v[s])return;\\n        v[s] = true;\\n        for(auto &i: g[s]){\\n            solve(i,v,g);\\n        }\\n    }\\n    int makeConnected(int n, vector<vector<int>>& v) {\\n        if(v.size()<n-1)return -1;\\n        vector<vector<int>> g(n);\\n        for(auto &i: v){\\n            g[i[0]].push_back(i[1]);\\n            g[i[1]].push_back(i[0]);\\n        }\\n        vector<bool> vis(n,false);\\n        int ans = -1;\\n        for(int i = 0; i < n; i++){\\n            if(!vis[i]){\\n                solve(i,vis,g);\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3330341,
                "title": "c-dfs",
                "content": "# Code\\n```\\nclass Solution {\\n    void dfs(vector<vector<int>>& edges, int src, vector<int>& vis) {\\n        if(vis[src])return;\\n        \\n        vis[src] = 1;\\n        \\n        for(auto &nbr: edges[src]) {\\n            dfs(edges,nbr,vis);\\n        }\\n    }\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        \\n        int m = connections.size();\\n        \\n        if(n-1 > m)return -1;\\n        \\n        vector<vector<int>> edges(n);\\n        vector<int> vis(n);\\n        int compo = 0;\\n        \\n        for(auto &con: connections) {\\n            int u = con[0], v = con[1];\\n            \\n            edges[u].push_back(v);\\n            edges[v].push_back(u);\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(!vis[i]) {\\n                dfs(edges,i,vis);\\n                compo++;\\n            }\\n        }\\n        \\n        return compo - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(vector<vector<int>>& edges, int src, vector<int>& vis) {\\n        if(vis[src])return;\\n        \\n        vis[src] = 1;\\n        \\n        for(auto &nbr: edges[src]) {\\n            dfs(edges,nbr,vis);\\n        }\\n    }\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        \\n        int m = connections.size();\\n        \\n        if(n-1 > m)return -1;\\n        \\n        vector<vector<int>> edges(n);\\n        vector<int> vis(n);\\n        int compo = 0;\\n        \\n        for(auto &con: connections) {\\n            int u = con[0], v = con[1];\\n            \\n            edges[u].push_back(v);\\n            edges[v].push_back(u);\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(!vis[i]) {\\n                dfs(edges,i,vis);\\n                compo++;\\n            }\\n        }\\n        \\n        return compo - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149382,
                "title": "c-2-approches-dfs-union-find-connected-components",
                "content": "# Approach : 1\\n\\n- By dfs we can find the number of components\\n- for any graph of n node we are required atleast n-1 nodes to be connected\\n - for example below image has 4 node so it is required 3 edges (concept of spanning tree)\\n![image.png](https://assets.leetcode.com/users/images/95dcc3ee-ee79-41dc-913d-d0676c12d8f2_1675659861.7957478.png)\\n```\\n    void dfs(int src,vector<int> adj[],vector<bool> &vis,int &size)\\n    {\\n        size++;\\n        vis[src]=true;\\n        for(auto it : adj[src])\\n        {\\n            if(vis[it]==false)\\n                dfs(it,adj,vis,size);\\n        }\\n    }\\n    int makeConnected(int n, vector<vector<int>>& connections) \\n    {\\n        int totalEdges=connections.size(),components=0,size=0;\\n        vector<int> adj[n];\\n        for(auto it : connections)\\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<bool> vis(n,false);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(vis[i]==false)\\n            {\\n                size=0; //size is nothing but no. of node in a component\\n                dfs(i,adj,vis,size);\\n                components++;\\n                totalEdges-=(size-1);// for a graph of n nodes wants n-1 edges to be connected\\n            }\\n        }\\n        if(components-1<=totalEdges)   return components-1;\\n        return -1;\\n    }\\n```\\n\\n---\\n\\n\\n# Approach 2\\n\\n - firstly we have to find number of disconnected components . We can find this by union find (DST).\\n - we have to make a common parent for every component .\\n - now for every component we count extra edges (extra cables) .\\n - extra edeges = (total edges in component - (no of nodes -1))\\n - if(extra edges >= (no. of components - 1) ) we return no. of components - 1\\n - else return -1\\n \\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int find_par(int u,vector<int> &par)\\n    {\\n        if(par[u]==u)\\n            return u;\\n        \\n        return par[u]=find_par(par[u],par);//Path Compression\\n    }\\n\\n    void union_(int u,int v,vector<int> &par,vector<int> &rank)\\n    {\\n        u=find_par(u,par);\\n        v=find_par(v,par);\\n        if(rank[u]>rank[v])\\n            par[v]=u;\\n        else if(rank[u]<rank[v])\\n            par[u]=v;\\n        else\\n        {\\n            par[u]=v;\\n            rank[v]++;\\n        }\\n    }\\n    int makeConnected(int n, vector<vector<int>>& connections) \\n    {\\n        \\n        vector<int> par(n,0);   //parent array\\n        vector<int> rank(n,0);  //union by rank\\n        for(int i=0;i<n;i++)\\n            par[i]=i;           //initially every node is parent itself\\n        for(auto it : connections)\\n            union_(it[0],it[1],par,rank);\\n\\n        unordered_set<int> st; // no. of components\\n        for(int i=0;i<n;i++)\\n        {\\n            int temp=find_par(i,par);\\n            st.insert(temp);\\n        }\\n        \\n        if(st.size()==1) //if given graph is already connected \\n            return 0;\\n        unordered_map<int,int> mp_edges; //for every component to count no . of edges\\n        unordered_map<int,unordered_set<int>> mp_nodes;//for every component to count no . of nodes\\n        for(auto it : connections)\\n        {\\n            mp_edges[par[it[0]]]++;\\n            mp_nodes[par[it[0]]].insert(it[0]);\\n            mp_nodes[par[it[0]]].insert(it[1]);\\n            \\n        }\\n        int extra_edges=0;\\n        for(auto it : st)\\n        {\\n            if(mp_nodes[it].size()!=0) // if component contains single node\\n                extra_edges+=(mp_edges[it]-(mp_nodes[it].size()-1));\\n        }\\n        \\n        if(st.size()-1 <=extra_edges )\\n            return st.size()-1;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\n    void dfs(int src,vector<int> adj[],vector<bool> &vis,int &size)\\n    {\\n        size++;\\n        vis[src]=true;\\n        for(auto it : adj[src])\\n        {\\n            if(vis[it]==false)\\n                dfs(it,adj,vis,size);\\n        }\\n    }\\n    int makeConnected(int n, vector<vector<int>>& connections) \\n    {\\n        int totalEdges=connections.size(),components=0,size=0;\\n        vector<int> adj[n];\\n        for(auto it : connections)\\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<bool> vis(n,false);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(vis[i]==false)\\n            {\\n                size=0; //size is nothing but no. of node in a component\\n                dfs(i,adj,vis,size);\\n                components++;\\n                totalEdges-=(size-1);// for a graph of n nodes wants n-1 edges to be connected\\n            }\\n        }\\n        if(components-1<=totalEdges)   return components-1;\\n        return -1;\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int find_par(int u,vector<int> &par)\\n    {\\n        if(par[u]==u)\\n            return u;\\n        \\n        return par[u]=find_par(par[u],par);//Path Compression\\n    }\\n\\n    void union_(int u,int v,vector<int> &par,vector<int> &rank)\\n    {\\n        u=find_par(u,par);\\n        v=find_par(v,par);\\n        if(rank[u]>rank[v])\\n            par[v]=u;\\n        else if(rank[u]<rank[v])\\n            par[u]=v;\\n        else\\n        {\\n            par[u]=v;\\n            rank[v]++;\\n        }\\n    }\\n    int makeConnected(int n, vector<vector<int>>& connections) \\n    {\\n        \\n        vector<int> par(n,0);   //parent array\\n        vector<int> rank(n,0);  //union by rank\\n        for(int i=0;i<n;i++)\\n            par[i]=i;           //initially every node is parent itself\\n        for(auto it : connections)\\n            union_(it[0],it[1],par,rank);\\n\\n        unordered_set<int> st; // no. of components\\n        for(int i=0;i<n;i++)\\n        {\\n            int temp=find_par(i,par);\\n            st.insert(temp);\\n        }\\n        \\n        if(st.size()==1) //if given graph is already connected \\n            return 0;\\n        unordered_map<int,int> mp_edges; //for every component to count no . of edges\\n        unordered_map<int,unordered_set<int>> mp_nodes;//for every component to count no . of nodes\\n        for(auto it : connections)\\n        {\\n            mp_edges[par[it[0]]]++;\\n            mp_nodes[par[it[0]]].insert(it[0]);\\n            mp_nodes[par[it[0]]].insert(it[1]);\\n            \\n        }\\n        int extra_edges=0;\\n        for(auto it : st)\\n        {\\n            if(mp_nodes[it].size()!=0) // if component contains single node\\n                extra_edges+=(mp_edges[it]-(mp_nodes[it].size()-1));\\n        }\\n        \\n        if(st.size()-1 <=extra_edges )\\n            return st.size()-1;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080793,
                "title": "c-easy-intuitive-union-find-algorithmic-apporach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind total number of components via Union find algorithm \\nWe have total wires= connections.size()\\nfor each component there would be component.size() i.e. no. of computers -1 number of wires requied to keep the component connected. with this we will calcuate number of wires which we cannot use \\n\\navailable wires=total wires-unavailable wires\\n\\nrequired wires=no. of components-1 \\nif(available wires>= required wires) return number of required wires \\nor return -1 i.e. not possible \\n\\n# Complexity\\n- Time complexity:O(connections.size() * O(V))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        int wires=connections.size();        \\n\\n        vector<int> nums(n);\\n        for(int i=0;i<n;i++) nums[i]=i;\\n\\n        for(int i=0;i<connections.size();i++){\\n            int v1,v2;\\n            v1=connections[i][0];\\n            v2=connections[i][1];\\n            int p1,p2;\\n            p1=nums[v1];\\n            p2=nums[v2];\\n\\n            int index=v1;\\n            while(index!=p1){\\n                index=p1;\\n                p1=nums[index];\\n            }\\n            index=v2;\\n            while(index!=p2){\\n                index=p2;\\n                p2=nums[index];\\n            }\\n            nums[p2]=p1;\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            int index=i;\\n            int p=nums[i];\\n            while(p!=index){\\n                index=p;\\n                p=nums[index];\\n            }\\n            nums[i]=p;\\n        }\\n\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n\\n        int components=mp.size();\\n\\n        if(components==1) return 0;\\n        \\n        int required=components-1;\\n\\n        int unavailable=0;\\n        for(auto i : mp){\\n            unavailable+=(i.second-1);\\n        }\\n        if(required<=wires-unavailable) return required;\\n        return -1;     \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        int wires=connections.size();        \\n\\n        vector<int> nums(n);\\n        for(int i=0;i<n;i++) nums[i]=i;\\n\\n        for(int i=0;i<connections.size();i++){\\n            int v1,v2;\\n            v1=connections[i][0];\\n            v2=connections[i][1];\\n            int p1,p2;\\n            p1=nums[v1];\\n            p2=nums[v2];\\n\\n            int index=v1;\\n            while(index!=p1){\\n                index=p1;\\n                p1=nums[index];\\n            }\\n            index=v2;\\n            while(index!=p2){\\n                index=p2;\\n                p2=nums[index];\\n            }\\n            nums[p2]=p1;\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            int index=i;\\n            int p=nums[i];\\n            while(p!=index){\\n                index=p;\\n                p=nums[index];\\n            }\\n            nums[i]=p;\\n        }\\n\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n\\n        int components=mp.size();\\n\\n        if(components==1) return 0;\\n        \\n        int required=components-1;\\n\\n        int unavailable=0;\\n        for(auto i : mp){\\n            unavailable+=(i.second-1);\\n        }\\n        if(required<=wires-unavailable) return required;\\n        return -1;     \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046799,
                "title": "c-dsu-simple-and-step-wise-explanation",
                "content": "First of all dont panic seeing the code size, understand the intuition first then the code is just translating ur logic to c++. JUST DONT PANIC seeing the code length \\uD83D\\uDE03\\n\\n**Prerequisite for this problem :- Disjoint Set Union**\\n\\n**Also if you found the solution useful, please dont forget to upvote it so that others can also benefit from it.**\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. To connect n connected components, i need n-1 edges ( no of connected components = no of ultimate parents using disjoint set)\\n2. The tricky part is here, edges must be already present which must be taken out to connected disconnected components\\n3. Thus, we count the no of extra edges.\\n4. If extra_edges > n - 1, then we return n-1 else -1 as connecting all components aint possible.\\n\\n# Complexity\\n- Time complexity: O(V + E) where V = total nodes, E = total edges\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(V) where V = total nodes\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DisjointSet\\n{\\nprivate:\\n    vector<int> parent, size;\\n\\npublic:\\n    DisjointSet(int n)\\n    {\\n        size.resize(n + 1, 1);\\n        parent.resize(n + 1);\\n        for (int i = 0; i <= n; i++)\\n            parent[i] = i;\\n    }\\n\\n    // methods\\n    int getparent(int node)\\n    {\\n        // if node is itself ultimate parent, return node\\n        if (node == parent[node])\\n            return node;\\n        // path compression\\n        return parent[node] = getparent(parent[node]);\\n    }\\n\\n    void unionbysize(int u, int v)\\n    {\\n        int pu = getparent(u);\\n        int pv = getparent(v);\\n        // if already of same component, then no union needed\\n        if (pu == pv)\\n            return;\\n        // else unionize them\\n        if (size[pu] > size[pv])\\n        {\\n            parent[pv] = pu;\\n            size[pu] += size[pv];\\n        }\\n        else\\n        {\\n            parent[pu] = pv;\\n            size[pv] += size[pu];\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {   \\n        int extraedges = 0;\\n        int noofcomponents = 0;\\n        DisjointSet ds(n);\\n\\n        // Unionization of nodes using Disjoing set\\n        for (auto x : connections)\\n        {\\n            int u = x[0];\\n            int v = x[1];\\n            // if already belonging to same parent, \\n            // then this edge formation isn\\'t necessary to make nodes part of same component\\n            // hence this is an extra edge\\n            if (ds.getparent(u) == ds.getparent(v))\\n                extraedges++;\\n            else\\n                ds.unionbysize(u, v);\\n        }\\n\\n        // counting no of components in the graph\\n        for (int i = 0; i < n; i++)\\n            if (i == ds.getparent(i))\\n                noofcomponents++;\\n\\n        return (extraedges >= noofcomponents - 1) ? (noofcomponents - 1) : -1;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Graph"
                ],
                "code": "```\\nclass DisjointSet\\n{\\nprivate:\\n    vector<int> parent, size;\\n\\npublic:\\n    DisjointSet(int n)\\n    {\\n        size.resize(n + 1, 1);\\n        parent.resize(n + 1);\\n        for (int i = 0; i <= n; i++)\\n            parent[i] = i;\\n    }\\n\\n    // methods\\n    int getparent(int node)\\n    {\\n        // if node is itself ultimate parent, return node\\n        if (node == parent[node])\\n            return node;\\n        // path compression\\n        return parent[node] = getparent(parent[node]);\\n    }\\n\\n    void unionbysize(int u, int v)\\n    {\\n        int pu = getparent(u);\\n        int pv = getparent(v);\\n        // if already of same component, then no union needed\\n        if (pu == pv)\\n            return;\\n        // else unionize them\\n        if (size[pu] > size[pv])\\n        {\\n            parent[pv] = pu;\\n            size[pu] += size[pv];\\n        }\\n        else\\n        {\\n            parent[pu] = pv;\\n            size[pv] += size[pu];\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {   \\n        int extraedges = 0;\\n        int noofcomponents = 0;\\n        DisjointSet ds(n);\\n\\n        // Unionization of nodes using Disjoing set\\n        for (auto x : connections)\\n        {\\n            int u = x[0];\\n            int v = x[1];\\n            // if already belonging to same parent, \\n            // then this edge formation isn\\'t necessary to make nodes part of same component\\n            // hence this is an extra edge\\n            if (ds.getparent(u) == ds.getparent(v))\\n                extraedges++;\\n            else\\n                ds.unionbysize(u, v);\\n        }\\n\\n        // counting no of components in the graph\\n        for (int i = 0; i < n; i++)\\n            if (i == ds.getparent(i))\\n                noofcomponents++;\\n\\n        return (extraedges >= noofcomponents - 1) ? (noofcomponents - 1) : -1;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3024124,
                "title": "c-easy-approach-using-disjoint-set-striver-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DisjointSet {\\n    \\npublic: \\n    vector<int> rank, parent, size; \\n    DisjointSet(int n) {\\n        rank.resize(n+1, 0); \\n        parent.resize(n+1);\\n        size.resize(n+1); \\n        for(int i = 0;i<=n;i++) {\\n            parent[i] = i; \\n            size[i] = 1; \\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if(node == parent[node])\\n            return node; \\n        return parent[node] = findUPar(parent[node]); \\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int ulp_u = findUPar(u); \\n        int ulp_v = findUPar(v); \\n        if(ulp_u == ulp_v) return; \\n        if(rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v; \\n        }\\n        else if(rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u; \\n        }\\n        else {\\n            parent[ulp_v] = ulp_u; \\n            rank[ulp_u]++; \\n        }\\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u); \\n        int ulp_v = findUPar(v); \\n        if(ulp_u == ulp_v) return; \\n        if(size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v; \\n            size[ulp_v] += size[ulp_u]; \\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v]; \\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& adj) {\\n        DisjointSet ds(n);\\n        int extra=0;\\n        for(auto it: adj){\\n            int u=it[0];\\n            int v=it[1];\\n\\n            if(ds.findUPar(u)==ds.findUPar(v)){\\n                extra++;\\n            }\\n            else{\\n                ds.unionBySize(u,v);\\n            }\\n        }\\n\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(ds.parent[i]==i)\\n            ans++;\\n        }\\n        ans=ans-1;\\n        if(extra>=ans)\\n        return ans;\\n\\n        return -1;\\n    }\\n};\\n```\\n\\n![upvote.png](https://assets.leetcode.com/users/images/c28ea540-73ef-4a31-a549-78d97a32aeca_1673258001.0946848.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DisjointSet {\\n    \\npublic: \\n    vector<int> rank, parent, size; \\n    DisjointSet(int n) {\\n        rank.resize(n+1, 0); \\n        parent.resize(n+1);\\n        size.resize(n+1); \\n        for(int i = 0;i<=n;i++) {\\n            parent[i] = i; \\n            size[i] = 1; \\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if(node == parent[node])\\n            return node; \\n        return parent[node] = findUPar(parent[node]); \\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int ulp_u = findUPar(u); \\n        int ulp_v = findUPar(v); \\n        if(ulp_u == ulp_v) return; \\n        if(rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v; \\n        }\\n        else if(rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u; \\n        }\\n        else {\\n            parent[ulp_v] = ulp_u; \\n            rank[ulp_u]++; \\n        }\\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u); \\n        int ulp_v = findUPar(v); \\n        if(ulp_u == ulp_v) return; \\n        if(size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v; \\n            size[ulp_v] += size[ulp_u]; \\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v]; \\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& adj) {\\n        DisjointSet ds(n);\\n        int extra=0;\\n        for(auto it: adj){\\n            int u=it[0];\\n            int v=it[1];\\n\\n            if(ds.findUPar(u)==ds.findUPar(v)){\\n                extra++;\\n            }\\n            else{\\n                ds.unionBySize(u,v);\\n            }\\n        }\\n\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(ds.parent[i]==i)\\n            ans++;\\n        }\\n        ans=ans-1;\\n        if(extra>=ans)\\n        return ans;\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891188,
                "title": "java-disjoint-set-union-find-explained",
                "content": "# Code\\n```\\nclass Solution {\\n    public int makeConnected(int n, int[][] connections) {\\n        DisjointSet ds = new DisjointSet(n);\\n        int extra = 0;//stores the number of extra edges available\\n        for(int i = 0; i<connections.length; i++){\\n            int u = connections[i][0];\\n            int v = connections[i][1];\\n            if(ds.findParent(u) == ds.findParent(v)) extra++; //if both have the same ultimate parent then they are already connected which would mean the loop reached them again through an extra edge\\n            else ds.unionBySize(u,v);// connecting new nodes\\n        }\\n        int count=0;//number of components\\n        for(int i = 0; i<n; i++){\\n            if(ds.parent.get(i) == i) count++;//if a node is a parent of itself that would mean it\\'s an ultimate parent of itself and some other nodes which would make a component\\n        }\\n\\n        //number of edges required to connect all components in a graph = number of components - 1\\n        if(count-1 <= extra) return count-1;\\n        else return -1;\\n    }\\n}\\n\\n//Disjoint set class\\nclass DisjointSet{\\n    List<Integer> parent = new ArrayList<>();\\n    List<Integer> size = new ArrayList<>();\\n\\n    public DisjointSet(int n){\\n        for(int i = 0; i<=n; i++){\\n            parent.add(i);\\n            size.add(1);\\n        }\\n    }\\n\\n    public int findParent(int node){\\n        if(node == parent.get(node)){\\n            return node;\\n        }\\n        int p = findParent(parent.get(node));\\n        parent.set(node, p);\\n        return parent.get(node);\\n    }\\n\\n    public void unionBySize(int u, int v){\\n        int pu = findParent(u);\\n        int pv = findParent(v);\\n        if(pu == pv) return;\\n        if(size.get(pu) < size.get(pv)){\\n            parent.set(pu, pv);\\n            size.set(pv, size.get(pv)+size.get(pu));\\n        }else{\\n            parent.set(pv, pu);\\n            size.set(pu, size.get(pv)+size.get(pu));\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int makeConnected(int n, int[][] connections) {\\n        DisjointSet ds = new DisjointSet(n);\\n        int extra = 0;//stores the number of extra edges available\\n        for(int i = 0; i<connections.length; i++){\\n            int u = connections[i][0];\\n            int v = connections[i][1];\\n            if(ds.findParent(u) == ds.findParent(v)) extra++; //if both have the same ultimate parent then they are already connected which would mean the loop reached them again through an extra edge\\n            else ds.unionBySize(u,v);// connecting new nodes\\n        }\\n        int count=0;//number of components\\n        for(int i = 0; i<n; i++){\\n            if(ds.parent.get(i) == i) count++;//if a node is a parent of itself that would mean it\\'s an ultimate parent of itself and some other nodes which would make a component\\n        }\\n\\n        //number of edges required to connect all components in a graph = number of components - 1\\n        if(count-1 <= extra) return count-1;\\n        else return -1;\\n    }\\n}\\n\\n//Disjoint set class\\nclass DisjointSet{\\n    List<Integer> parent = new ArrayList<>();\\n    List<Integer> size = new ArrayList<>();\\n\\n    public DisjointSet(int n){\\n        for(int i = 0; i<=n; i++){\\n            parent.add(i);\\n            size.add(1);\\n        }\\n    }\\n\\n    public int findParent(int node){\\n        if(node == parent.get(node)){\\n            return node;\\n        }\\n        int p = findParent(parent.get(node));\\n        parent.set(node, p);\\n        return parent.get(node);\\n    }\\n\\n    public void unionBySize(int u, int v){\\n        int pu = findParent(u);\\n        int pv = findParent(v);\\n        if(pu == pv) return;\\n        if(size.get(pu) < size.get(pv)){\\n            parent.set(pu, pv);\\n            size.set(pv, size.get(pv)+size.get(pu));\\n        }else{\\n            parent.set(pv, pu);\\n            size.set(pu, size.get(pv)+size.get(pu));\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2883120,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> g[100005];\\n    int vis[100005];\\n    void dfs(int u) {\\n        vis[u] = 1;\\n        for(auto v: g[u]) {\\n            if(!vis[v]) dfs(v);\\n        }\\n    }\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        if(n > connections.size()+1) return -1;\\n        memset(vis, 0, sizeof(vis));\\n        for(auto x: connections) {\\n            g[x[0]].push_back(x[1]);\\n            g[x[1]].push_back(x[0]);\\n        }\\n        int ans = 0;\\n        for(int u=0; u<n; u++) {\\n            if(!vis[u]) {\\n                ans++;\\n                dfs(u);\\n            }\\n        }\\n        return ans-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> g[100005];\\n    int vis[100005];\\n    void dfs(int u) {\\n        vis[u] = 1;\\n        for(auto v: g[u]) {\\n            if(!vis[v]) dfs(v);\\n        }\\n    }\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        if(n > connections.size()+1) return -1;\\n        memset(vis, 0, sizeof(vis));\\n        for(auto x: connections) {\\n            g[x[0]].push_back(x[1]);\\n            g[x[1]].push_back(x[0]);\\n        }\\n        int ans = 0;\\n        for(int u=0; u<n; u++) {\\n            if(!vis[u]) {\\n                ans++;\\n                dfs(u);\\n            }\\n        }\\n        return ans-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2836661,
                "title": "c-bfs-dfs-easy-approach",
                "content": "Here is my c++ code for this problem.\\nBFS:-\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint makeConnected(int n, vector<vector<int>>& connections) {\\n\\t\\t\\tif(connections.size()<n-1){return -1;}\\n\\t\\t\\tvector<int>v(n, 0);\\n\\t\\t\\tvector<int>adj[n];\\n\\t\\t\\tfor(int i=0; i<connections.size(); i++){\\n\\t\\t\\t\\tadj[connections[i][0]].push_back(connections[i][1]);\\n\\t\\t\\t\\tadj[connections[i][1]].push_back(connections[i][0]);\\n\\t\\t\\t}\\n\\t\\t\\tint cnt=0;\\n\\t\\t\\tfor(int i=0; i<n; i++){\\n\\t\\t\\t\\tif(!v[i]){\\n\\t\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\t\\tqueue<int>q;\\n\\t\\t\\t\\t\\tq.push(i);\\n\\t\\t\\t\\t\\tv[i]=1;\\n\\t\\t\\t\\t\\twhile(!q.empty()){\\n\\t\\t\\t\\t\\t\\tint x=q.front();\\n\\t\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t\\t\\tfor(auto it: adj[x]){\\n\\t\\t\\t\\t\\t\\t\\tif(!v[it]){\\n\\t\\t\\t\\t\\t\\t\\t\\tv[it]=1;\\n\\t\\t\\t\\t\\t\\t\\t\\tq.push(it);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn cnt-1;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'\\nDFS:-\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvoid dfs(int x, vector<int>& v, vector<int>adj[]){\\n\\t\\t\\tv[x]=1;\\n\\t\\t\\tfor(auto it: adj[x]){\\n\\t\\t\\t\\tif(!v[it]){\\n\\t\\t\\t\\t\\tdfs(it, v, adj);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint makeConnected(int n, vector<vector<int>>& connections) {\\n\\t\\t\\tif(connections.size()<n-1){return -1;}\\n\\t\\t\\tvector<int>v(n, 0);\\n\\t\\t\\tvector<int>adj[n];\\n\\t\\t\\tfor(int i=0; i<connections.size(); i++){\\n\\t\\t\\t\\tadj[connections[i][0]].push_back(connections[i][1]);\\n\\t\\t\\t\\tadj[connections[i][1]].push_back(connections[i][0]);\\n\\t\\t\\t}\\n\\t\\t\\tint cnt=0;\\n\\t\\t\\tfor(int i=0; i<n; i++){\\n\\t\\t\\t\\tif(!v[i]){\\n\\t\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\t\\tdfs(i, v, adj);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn cnt-1;\\n\\t\\t}\\n\\t};\\n,,,",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint makeConnected(int n, vector<vector<int>>& connections) {\\n\\t\\t\\tif(connections.size()<n-1){return -1;}",
                "codeTag": "Java"
            },
            {
                "id": 2801757,
                "title": "dfs-union-find-c",
                "content": "# DFS\\n```\\nclass Solution {\\n    void dfs(int node, vector<int> adj[], vector<int> &vis) {\\n        vis[node] = 1;\\n        for(int ad : adj[node]) {\\n            if(!vis[ad]) dfs(ad, adj, vis);\\n        }\\n    }\\n    \\npublic:\\n    int makeConnected(int n, vector<vector<int>>& c) {\\n        if(c.size() < n -1) return -1;\\n        \\n        int ans = -1;\\n        vector<int> vis(n, 0);\\n        vector<int> adj[n];\\n        for(auto e : c) adj[e[0]].push_back(e[1]), adj[e[1]].push_back(e[0]);\\n        \\n        for(int i=0; i<n; i++) \\n            if(!vis[i]) ans++, dfs(i, adj, vis);\\n        \\n        return ans; \\n    }\\n};\\n```\\n\\n# Union Find\\n```\\nclass Solution {\\n    int findPrnt(int node, vector<int> &prnt) {\\n        if(node == prnt[node]) return node;\\n        return prnt[node] = findPrnt(prnt[node], prnt);\\n    }\\n    void unionn(int u, int v, vector<int> &rank ,vector<int> &prnt) {\\n        u = findPrnt(u, prnt), v = findPrnt(v, prnt);\\n        \\n        if(rank[u] < rank[v]) prnt[u] = v;\\n        else if(rank[u] > rank[v]) prnt[v] = u;\\n        else rank[u]++, prnt[v] = u;\\n    }\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        if(n - 1 > connections.size()) return -1;\\n        \\n        vector<int> rank(n, 0), prnt(n);\\n        for(int i=0; i<n; i++) prnt[i] = i;\\n        for(auto e : connections) unionn(e[0], e[1], rank, prnt);\\n        \\n        int ans = 0;\\n        for(int i=0; i<n; i++) {\\n            if(prnt[i] == i) ans++;\\n        }\\n        return ans - 1;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int node, vector<int> adj[], vector<int> &vis) {\\n        vis[node] = 1;\\n        for(int ad : adj[node]) {\\n            if(!vis[ad]) dfs(ad, adj, vis);\\n        }\\n    }\\n    \\npublic:\\n    int makeConnected(int n, vector<vector<int>>& c) {\\n        if(c.size() < n -1) return -1;\\n        \\n        int ans = -1;\\n        vector<int> vis(n, 0);\\n        vector<int> adj[n];\\n        for(auto e : c) adj[e[0]].push_back(e[1]), adj[e[1]].push_back(e[0]);\\n        \\n        for(int i=0; i<n; i++) \\n            if(!vis[i]) ans++, dfs(i, adj, vis);\\n        \\n        return ans; \\n    }\\n};\\n```\n```\\nclass Solution {\\n    int findPrnt(int node, vector<int> &prnt) {\\n        if(node == prnt[node]) return node;\\n        return prnt[node] = findPrnt(prnt[node], prnt);\\n    }\\n    void unionn(int u, int v, vector<int> &rank ,vector<int> &prnt) {\\n        u = findPrnt(u, prnt), v = findPrnt(v, prnt);\\n        \\n        if(rank[u] < rank[v]) prnt[u] = v;\\n        else if(rank[u] > rank[v]) prnt[v] = u;\\n        else rank[u]++, prnt[v] = u;\\n    }\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        if(n - 1 > connections.size()) return -1;\\n        \\n        vector<int> rank(n, 0), prnt(n);\\n        for(int i=0; i<n; i++) prnt[i] = i;\\n        for(auto e : connections) unionn(e[0], e[1], rank, prnt);\\n        \\n        int ans = 0;\\n        for(int i=0; i<n; i++) {\\n            if(prnt[i] == i) ans++;\\n        }\\n        return ans - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2657463,
                "title": "java-cleancode",
                "content": "Yep. It is the worst solution that you can find.\\nEnjoy \\n\\n```\\nimport java.util.HashMap;\\nimport java.util.HashSet;\\nimport java.util.Map;\\nimport java.util.Set;\\n\\nclass Solution {\\n  public int  makeConnected(int n, int[][] connections) {\\n        if (connections.length+1<n) return -1;\\n\\n        Map<Integer, Set<Integer>> provs= new HashMap<>();\\n        Set<Integer> inProvs = new HashSet<>();\\n        inProvs.add(0);\\n        provs.put(0, new HashSet<Integer>(inProvs));\\n        int zxc  = 1;\\n        for (int[] connection : connections) {\\n            int i = connection[0];\\n            int j = connection[1];\\n            if (inProvs.contains(i)) {\\n                if (inProvs.contains(j)) {\\n                    int iCont = 0;\\n                    int jCont = 0;\\n                    for (Map.Entry<Integer, Set<Integer>> entry : provs.entrySet()) {\\n                        \\n                            if (entry.getValue().contains(i)) iCont = entry.getKey();\\n                            if (entry.getValue().contains(j)) jCont = entry.getKey();\\n                        \\n                    }\\n                    if (iCont != jCont) {\\n                        provs.get(iCont).addAll(provs.get(jCont));\\n                        provs.remove(jCont);\\n                    }\\n                } else {\\n                    int iCont = 0;\\n                    for (Map.Entry<Integer, Set<Integer>> entry : provs.entrySet()) {\\n                        if (entry.getValue().contains(i)) iCont = entry.getKey();\\n                    }\\n                    provs.get(iCont).add(j);\\n                    inProvs.add(j);\\n                }\\n            } else {\\n                if (inProvs.contains(j)) {\\n                    int jCont = 0;\\n                    for (Map.Entry<Integer, Set<Integer>> entry : provs.entrySet()) {\\n                        if (entry.getValue().contains(j)) jCont = entry.getKey();\\n\\n                    }\\n                    provs.get(jCont).add(i);\\n                    inProvs.add(i);\\n                } else {\\n                    Set<Integer> temp = new HashSet<>();\\n                    temp.add(i);\\n                    temp.add(j);\\n                    provs.put(zxc, temp);\\n                    zxc++;\\n                    inProvs.add(i);\\n                    inProvs.add(j);\\n                }\\n            }\\n\\n        }\\n   return provs.size() - 1 + n - inProvs.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nimport java.util.HashMap;\\nimport java.util.HashSet;\\nimport java.util.Map;\\nimport java.util.Set;\\n\\nclass Solution {\\n  public int  makeConnected(int n, int[][] connections) {\\n        if (connections.length+1<n) return -1;\\n\\n        Map<Integer, Set<Integer>> provs= new HashMap<>();\\n        Set<Integer> inProvs = new HashSet<>();\\n        inProvs.add(0);\\n        provs.put(0, new HashSet<Integer>(inProvs));\\n        int zxc  = 1;\\n        for (int[] connection : connections) {\\n            int i = connection[0];\\n            int j = connection[1];\\n            if (inProvs.contains(i)) {\\n                if (inProvs.contains(j)) {\\n                    int iCont = 0;\\n                    int jCont = 0;\\n                    for (Map.Entry<Integer, Set<Integer>> entry : provs.entrySet()) {\\n                        \\n                            if (entry.getValue().contains(i)) iCont = entry.getKey();\\n                            if (entry.getValue().contains(j)) jCont = entry.getKey();\\n                        \\n                    }\\n                    if (iCont != jCont) {\\n                        provs.get(iCont).addAll(provs.get(jCont));\\n                        provs.remove(jCont);\\n                    }\\n                } else {\\n                    int iCont = 0;\\n                    for (Map.Entry<Integer, Set<Integer>> entry : provs.entrySet()) {\\n                        if (entry.getValue().contains(i)) iCont = entry.getKey();\\n                    }\\n                    provs.get(iCont).add(j);\\n                    inProvs.add(j);\\n                }\\n            } else {\\n                if (inProvs.contains(j)) {\\n                    int jCont = 0;\\n                    for (Map.Entry<Integer, Set<Integer>> entry : provs.entrySet()) {\\n                        if (entry.getValue().contains(j)) jCont = entry.getKey();\\n\\n                    }\\n                    provs.get(jCont).add(i);\\n                    inProvs.add(i);\\n                } else {\\n                    Set<Integer> temp = new HashSet<>();\\n                    temp.add(i);\\n                    temp.add(j);\\n                    provs.put(zxc, temp);\\n                    zxc++;\\n                    inProvs.add(i);\\n                    inProvs.add(j);\\n                }\\n            }\\n\\n        }\\n   return provs.size() - 1 + n - inProvs.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2471749,
                "title": "simple-code-using-union-find-detailed-explanation-with-go-to-template-for-find-beats-100",
                "content": "(Union Find) O(n+m)\\nIf the number of current cables is less than n - 1, then obviously the task cannot be completed.\\n\\nNext, find the number of connected blocks according to the current cable connection. This can be achieved union find with path compression technique.\\n\\nFinally, if there are currently k connected blocks, the answer is k - 1. This is because every time a connection block is connected, only one cable move is required (we have ensured that the number of cables is sufficient).\\n\\nTime complexity\\nThe time complexity of the union find operation is approximately constant, so the total time complexity is O(n+m). Where m is the number of current cables.\\n\\nSpace complexity\\nRequires additional O(n) space to support lookup in union find.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> p;\\n    \\n    int find(int x) {\\n        if (p[x] != x) p[x] = find(p[x]);\\n        return p[x];\\n    }\\n    \\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        if (n - 1 > connections.size()) return -1;\\n        int ans = n;\\n        for (int i = 0; i < n; ++ i) p.emplace_back(i);\\n        for (auto &e : connections) {\\n            auto a = e[0], b = e[1];\\n            if (find(a) != find(b)) {\\n                p[find(a)] = find(b);\\n                -- ans;\\n            }\\n        }\\n        return ans - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> p;\\n    \\n    int find(int x) {\\n        if (p[x] != x) p[x] = find(p[x]);\\n        return p[x];\\n    }\\n    \\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        if (n - 1 > connections.size()) return -1;\\n        int ans = n;\\n        for (int i = 0; i < n; ++ i) p.emplace_back(i);\\n        for (auto &e : connections) {\\n            auto a = e[0], b = e[1];\\n            if (find(a) != find(b)) {\\n                p[find(a)] = find(b);\\n                -- ans;\\n            }\\n        }\\n        return ans - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299320,
                "title": "union-disjoint-algo-easy-to-understand",
                "content": "Algo\\n\\nWe want to figure out -> extra Connection -> cycle detected\\nCycle detection done by disjoint set algo\\nwe only traverse through the connection and cnt those whose parent are same.\\nparent same mean cycle / extra connection\\nbut here our task is to figure out the no of edge we used to connect whole system\\nfor which find Unconnected computers by traversing in parent\\n if itself parent it mean not connected but not include starting point.\\ntwo possiblities extra Connection >= Unconnected-1 return unconnected-1 because one computer is always the starting one .\\nConnections < UnConnected return -1 not enough wire.\\n\\nclass Solution {\\npublic:\\n    \\n    \\n    vector<int>parent;\\n    vector<int>rank;\\n    int extraConnection = 0;\\n    \\n    int findParent(int node)\\n    {\\n        if(parent[node] == node)\\n            return node;\\n        return findParent(parent[node]);\\n    }\\n    \\n    \\n    void unionn(int x , int y)\\n    {\\n        x = findParent(x);\\n        y = findParent(y);\\n        \\n        // Parent are same -> cycle / extra Connection\\n        if(x == y)\\n            extraConnection++;\\n        \\n        // Parent are not same.\\n       else if(x != y){\\n        \\n        if(rank[x] > rank[y])\\n            parent[y] = x;\\n        else if(rank[y] > rank[x])\\n            parent[x] = y;\\n        else{\\n            parent[y] = x;\\n            rank[y]++;\\n        }\\n            \\n      }      \\n    }\\n    \\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        \\n        // initialisation\\n        \\n        parent= vector<int>(n);\\n        rank = vector<int>(n,0);\\n        \\n        for(int i = 0 ; i < n ; i++)\\n            parent[i] = i;\\n        \\n        \\n        for(int i = 0 ; i < connections.size() ; i++)\\n        {\\n            unionn(connections[i][0] , connections[i][1]);\\n        }\\n        \\n        // Find No. of Unconnected computer\\n        \\n        cout<<extraConnection <<endl;\\n        \\n        int unConnectedComp = 0;\\n        \\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            \\n            if(parent[i] == i)\\n                unConnectedComp++;\\n        }\\n    \\n        // Return only the required wired to be connected.\\n        if(extraConnection >= unConnectedComp-1)\\n            return unConnectedComp-1;\\n        else if(extraConnection < unConnectedComp)\\n                return -1;\\n        return 1; // ignore this\\n    }\\n};\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    \\n    vector<int>parent;\\n    vector<int>rank;\\n    int extraConnection = 0;\\n    \\n    int findParent(int node)\\n    {\\n        if(parent[node] == node)\\n            return node;\\n        return findParent(parent[node]);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2273658,
                "title": "c-dfs-number-of-components-explanation",
                "content": "**The logic is simple if the no of connections or the wires is less than (n-1) [minimum no of wires needed to connect all the computers] then return the answer as -1. If not then first make an adjacency list and find the no of components in the graph using DFS traversal you can also find that using BFS traversal. Once you found the no of components(count) then the no of wires needed to be changed to connect (count) components is (count-1) and return the answer.**\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> adj[], vector<int> &vis, int i)\\n    {\\n        vis[i] = true;\\n        for(auto it:adj[i])\\n        {\\n            if(vis[it] == false)\\n            {\\n                dfs(adj, vis, it);\\n            }\\n        }\\n    }\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        int ans = -1;\\n        int comp = 0;\\n        if(connections.size() < n-1)\\n        {\\n            return -1;\\n        }\\n        vector<int> adj[n];\\n        for(int i=0;i<connections.size();++i)\\n        {\\n            adj[connections[i][0]].push_back(connections[i][1]);\\n            adj[connections[i][1]].push_back(connections[i][0]);\\n        }\\n        vector<int> vis(n, false);\\n        for(int i=0;i<n;++i)\\n        {\\n            if(vis[i] == false)\\n            {\\n                comp++;\\n                dfs(adj, vis, i);\\n            }\\n        }\\n        ans = comp-1;\\n        return ans;\\n    }\\n};\\n```\\n**Hope the solution helps you. If it does please upvote this solution. Thanks in advance!!!!**",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> adj[], vector<int> &vis, int i)\\n    {\\n        vis[i] = true;\\n        for(auto it:adj[i])\\n        {\\n            if(vis[it] == false)\\n            {\\n                dfs(adj, vis, it);\\n            }\\n        }\\n    }\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        int ans = -1;\\n        int comp = 0;\\n        if(connections.size() < n-1)\\n        {\\n            return -1;\\n        }\\n        vector<int> adj[n];\\n        for(int i=0;i<connections.size();++i)\\n        {\\n            adj[connections[i][0]].push_back(connections[i][1]);\\n            adj[connections[i][1]].push_back(connections[i][0]);\\n        }\\n        vector<int> vis(n, false);\\n        for(int i=0;i<n;++i)\\n        {\\n            if(vis[i] == false)\\n            {\\n                comp++;\\n                dfs(adj, vis, i);\\n            }\\n        }\\n        ans = comp-1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2173071,
                "title": "c-dfs-connected-components-easy-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs (int n, vector<vector<int>>& graph, int i ,vector<bool>& visited  ) {\\n        if( i<0 || i>=n ) return;\\n        if( visited[i] ) return;\\n        visited[i]=1;\\n        int m = graph[i].size();\\n        \\n        for ( int j=0; j<m; j++) {\\n            dfs(n,graph,graph[i][j], visited);\\n        }\\n        \\n        \\n    }\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        \\n        int e = connections.size();\\n        if( n > e+1 ) return -1;\\n        vector<vector<int>> graph(n);\\n        \\n        // make graph\\n        for ( int i=0; i<e; i++) {\\n            graph[connections[i][0]].push_back(connections[i][1]);\\n            graph[connections[i][1]].push_back(connections[i][0]);\\n        }\\n        vector<bool> visited(n,0);\\n        int count=0; // connected components\\n        for ( int i=0; i<n; i++){\\n            if( !visited[i] ) {\\n               dfs(n, graph, i , visited); \\n               count++;\\n            }\\n        }\\n        return count-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs (int n, vector<vector<int>>& graph, int i ,vector<bool>& visited  ) {\\n        if( i<0 || i>=n ) return;\\n        if( visited[i] ) return;\\n        visited[i]=1;\\n        int m = graph[i].size();\\n        \\n        for ( int j=0; j<m; j++) {\\n            dfs(n,graph,graph[i][j], visited);\\n        }\\n        \\n        \\n    }\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        \\n        int e = connections.size();\\n        if( n > e+1 ) return -1;\\n        vector<vector<int>> graph(n);\\n        \\n        // make graph\\n        for ( int i=0; i<e; i++) {\\n            graph[connections[i][0]].push_back(connections[i][1]);\\n            graph[connections[i][1]].push_back(connections[i][0]);\\n        }\\n        vector<bool> visited(n,0);\\n        int count=0; // connected components\\n        for ( int i=0; i<n; i++){\\n            if( !visited[i] ) {\\n               dfs(n, graph, i , visited); \\n               count++;\\n            }\\n        }\\n        return count-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2064807,
                "title": "union-java",
                "content": "```\\nclass Solution {\\n    \\n    int findPar(int node, int parent[]){\\n        if(node == parent[node]){\\n            return node;\\n        }\\n        return parent[node] = findPar(parent[node],parent);\\n    }\\n    \\n    public int makeConnected(int n, int[][] connections) {\\n        int parent[]=new int[n];\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n        }\\n        int leftWire=0;\\n        int component =0;\\n        int m = connections.length;\\n        for(int i=0;i<m;i++){\\n            int p1 =findPar(connections[i][0],parent);\\n            int p2 =findPar(connections[i][1],parent);\\n            if(p1 != p2){\\n                parent[p1]=p2;\\n            }else{\\n                leftWire++;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(parent[i] == i){\\n                component++;\\n            }\\n        }\\n        return (component-1) <= leftWire?component-1:-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int findPar(int node, int parent[]){\\n        if(node == parent[node]){\\n            return node;\\n        }\\n        return parent[node] = findPar(parent[node],parent);\\n    }\\n    \\n    public int makeConnected(int n, int[][] connections) {\\n        int parent[]=new int[n];\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n        }\\n        int leftWire=0;\\n        int component =0;\\n        int m = connections.length;\\n        for(int i=0;i<m;i++){\\n            int p1 =findPar(connections[i][0],parent);\\n            int p2 =findPar(connections[i][1],parent);\\n            if(p1 != p2){\\n                parent[p1]=p2;\\n            }else{\\n                leftWire++;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(parent[i] == i){\\n                component++;\\n            }\\n        }\\n        return (component-1) <= leftWire?component-1:-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1970935,
                "title": "dsu-python",
                "content": "\\n```python\\n\\nclass DSU:\\n    \\n    def __init__(self, n):\\n        self.parent = [computer for computer in range(n)]\\n        self.rank = [0 for _ in range(n)]\\n        self.size = n\\n        \\n    def find(self, node):\\n        \\n        if self.parent[node] == node:\\n            return node\\n        \\n        self.parent[node] = self.find(self.parent[node])\\n        return self.parent[node]\\n    \\n    def union(self, node1, node2):\\n        \\n        node1 = self.find(node1)\\n        node2 = self.find(node2)\\n        \\n        if node1 == node2:\\n            return \\n        \\n        if self.rank[node1] > self.rank[node2]:\\n            node1, node2 = node2, node1\\n            \\n        self.parent[node1] = node2\\n        \\n        if self.rank[node1] == self.rank[node2]:\\n            self.rank[node2] += 1\\n            \\n        self.size -= 1\\n    \\n\\nclass Solution:\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        \\n        dsu = DSU(n)\\n        \\n        available_connections = 0\\n        \\n        for node1, node2 in connections:\\n            \\n            # find the representatives of the two nodes\\n            rep1 = dsu.find(node1)\\n            rep2 = dsu.find(node2)\\n            \\n            # if the both the nodes belong to the same component, then, the two nodes are already connected and we get an extra cable for connections.\\n            if rep1 == rep2:\\n                available_connections += 1\\n                continue\\n                \\n            dsu.union(rep1, rep2)\\n            \\n        required_connections = dsu.size - 1\\n        \\n        if available_connections < required_connections:\\n            return -1\\n        \\n        return required_connections\\n                \\n           \\n\\n\\n\\n```",
                "solutionTags": [
                    "Graph"
                ],
                "code": "```python\\n\\nclass DSU:\\n    \\n    def __init__(self, n):\\n        self.parent = [computer for computer in range(n)]\\n        self.rank = [0 for _ in range(n)]\\n        self.size = n\\n        \\n    def find(self, node):\\n        \\n        if self.parent[node] == node:\\n            return node\\n        \\n        self.parent[node] = self.find(self.parent[node])\\n        return self.parent[node]\\n    \\n    def union(self, node1, node2):\\n        \\n        node1 = self.find(node1)\\n        node2 = self.find(node2)\\n        \\n        if node1 == node2:\\n            return \\n        \\n        if self.rank[node1] > self.rank[node2]:\\n            node1, node2 = node2, node1\\n            \\n        self.parent[node1] = node2\\n        \\n        if self.rank[node1] == self.rank[node2]:\\n            self.rank[node2] += 1\\n            \\n        self.size -= 1\\n    \\n\\nclass Solution:\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        \\n        dsu = DSU(n)\\n        \\n        available_connections = 0\\n        \\n        for node1, node2 in connections:\\n            \\n            # find the representatives of the two nodes\\n            rep1 = dsu.find(node1)\\n            rep2 = dsu.find(node2)\\n            \\n            # if the both the nodes belong to the same component, then, the two nodes are already connected and we get an extra cable for connections.\\n            if rep1 == rep2:\\n                available_connections += 1\\n                continue\\n                \\n            dsu.union(rep1, rep2)\\n            \\n        required_connections = dsu.size - 1\\n        \\n        if available_connections < required_connections:\\n            return -1\\n        \\n        return required_connections\\n                \\n           \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1917636,
                "title": "two-approach-union-find-dfs-c",
                "content": "# 1st Approach\\n\\n=> Here we used  Conneted component method.\\n=> number of conneted component -1 will be required cabel to make one the connection.\\n\\n**Code:**  \\n\\n```\\nclass Solution {\\npublic:\\n    void dfs(int node , vector<int>g[] , vector<int>&vis){\\n        vis[node] = 1;\\n        for(auto it : g[node]){\\n            if(!vis[it]){\\n                dfs(it,g,vis);\\n            }\\n        }\\n    }\\n    \\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        vector<int>g[n];\\n        int m = connections.size();\\n        if(m < n-1)return -1;\\n        for(int i = 0 ; i < m ; i++){\\n            g[connections[i][0]].push_back(connections[i][1]);\\n            g[connections[i][1]].push_back(connections[i][0]);\\n        }\\n        vector<int>vis(n,0);\\n        int c = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            if(!vis[i]){\\n                c++;\\n                dfs(i,g,vis);\\n            }\\n        }\\n        return c-1;\\n    }\\n};\\n```\\n\\n# 2nd  Approach\\n\\n=> Join all the computers\\n=> Now find total number of different components\\n=> Then we will require only cables so we (different components - 1) because 3 computer require only 2 cables so we need to use remove 1 value from them.\\n=> **T.C = O(M) || S.C = O(N) + O(N) = O(N)**\\n\\n**Code:**\\n```\\nclass Solution {\\n    vector<int>parent;\\n    int findPar(int node){\\n        return (parent[node] == node ? node : findPar(parent[node]));\\n    }\\n    \\n    bool join(int a,int b){\\n        int x = findPar(a);\\n        int y = findPar(b);\\n        \\n        if(x == y)return false;\\n        parent[y] = x;\\n        return true;\\n    }\\n    \\npublic:\\n    int makeConnected(int n, vector<vector<int>>& graph) {\\n        int m = graph.size();\\n        int cnt = 0;\\n        if(m < n-1)return -1;\\n        parent.resize(n);\\n        \\n        for(int i=0;i<n;i++)parent[i] = i;\\n        \\n        for(int i=0;i<m;i++){\\n            int x = graph[i][0];\\n            int y = graph[i][1];\\n            \\n            if(x == y){\\n                continue;\\n            }\\n            join(x,y);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(parent[i] == i)cnt++;\\n        }\\n        return cnt-1;\\n    }\\n};\\n```\\n\\nIf You want to learn graph topics **patternwise** then follow this Tutorial : [https://bit.ly/35IsSsB](http://)\\n\\n\\n**PLEASE UPVOTE IF YOU LIKE THE SOLUTION & EXPLANATION , PLEASE !!**\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n",
                "solutionTags": [
                    "Depth-First Search",
                    "Union Find",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node , vector<int>g[] , vector<int>&vis){\\n        vis[node] = 1;\\n        for(auto it : g[node]){\\n            if(!vis[it]){\\n                dfs(it,g,vis);\\n            }\\n        }\\n    }\\n    \\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        vector<int>g[n];\\n        int m = connections.size();\\n        if(m < n-1)return -1;\\n        for(int i = 0 ; i < m ; i++){\\n            g[connections[i][0]].push_back(connections[i][1]);\\n            g[connections[i][1]].push_back(connections[i][0]);\\n        }\\n        vector<int>vis(n,0);\\n        int c = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            if(!vis[i]){\\n                c++;\\n                dfs(i,g,vis);\\n            }\\n        }\\n        return c-1;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    vector<int>parent;\\n    int findPar(int node){\\n        return (parent[node] == node ? node : findPar(parent[node]));\\n    }\\n    \\n    bool join(int a,int b){\\n        int x = findPar(a);\\n        int y = findPar(b);\\n        \\n        if(x == y)return false;\\n        parent[y] = x;\\n        return true;\\n    }\\n    \\npublic:\\n    int makeConnected(int n, vector<vector<int>>& graph) {\\n        int m = graph.size();\\n        int cnt = 0;\\n        if(m < n-1)return -1;\\n        parent.resize(n);\\n        \\n        for(int i=0;i<n;i++)parent[i] = i;\\n        \\n        for(int i=0;i<m;i++){\\n            int x = graph[i][0];\\n            int y = graph[i][1];\\n            \\n            if(x == y){\\n                continue;\\n            }\\n            join(x,y);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(parent[i] == i)cnt++;\\n        }\\n        return cnt-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1836763,
                "title": "number-of-operations-to-make-network-connected-cpp-c-with-explanation",
                "content": "**As the question says:**\\nYou can extract certain cables between two directly connected computers, and place them between any pair of disconnected computers to make them directly connected.\\n\\n**Let\\'s try to make it simple.**\\n\\nNow, Let say we have 2 computers and there is no edge b/w them. So, we need only 1 edge to connect both the computers, which means, number of times we need to connect both the computers will be 1.\\n\\n**Let\\'s take an example from first Testcase,**\\n![image](https://assets.leetcode.com/users/images/11b4a10a-ab52-4840-80de-1d45e291e240_1646917117.8101857.png)\\n\\nYou see there are 2 disconected components and, computer 1 & computer 3 are connected in right side via 1 edge only.\\n\\n**Similarly, in the second Testcase,**\\n![image](https://assets.leetcode.com/users/images/805e28f4-ea8a-44c1-82ce-17b719edecbe_1646917168.4368849.png)\\n\\nWe have 3 components in total and we are using 2 edges in total to connect all the 3 components.\\n\\nIn short, the `number of components` we will have, then `number of components-1` edges will take to connect all the components.\\n\\n**Let\\'s say 1 edge takes 1 unit of time.**\\nHence, `number of components-1` edges will take `number of components-1` unit of time.\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    //Time: O(V+E), Space: O(V+E)\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        if(n > connections.size()+1) return -1;\\n\\n        vector<bool> visited(n, false);\\n        vector<int> adj[n];\\n        \\n        //build the graph\\n        for(auto connection : connections){\\n            adj[connection[0]].push_back(connection[1]);\\n            adj[connection[1]].push_back(connection[0]);\\n        }\\n        \\n        //Start the DFS and find the number of components\\n        int components = 0;\\n        for(int i=0; i<n; i++){\\n            if(!visited[i]){\\n                dfs(adj, i, visited);\\n                components++;\\n            }\\n        }\\n        return components-1;\\n    }\\n    \\n    void dfs(vector<int> adj[], int v, vector<bool>& visited){\\n        visited[v] = true;\\n        for(auto j : adj[v]){\\n            if(!visited[j])\\n                dfs(adj, j, visited);\\n        }\\n    }\\n};\\n```\\n\\n**Happy Learning**\\n**Thanks**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Time: O(V+E), Space: O(V+E)\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        if(n > connections.size()+1) return -1;\\n\\n        vector<bool> visited(n, false);\\n        vector<int> adj[n];\\n        \\n        //build the graph\\n        for(auto connection : connections){\\n            adj[connection[0]].push_back(connection[1]);\\n            adj[connection[1]].push_back(connection[0]);\\n        }\\n        \\n        //Start the DFS and find the number of components\\n        int components = 0;\\n        for(int i=0; i<n; i++){\\n            if(!visited[i]){\\n                dfs(adj, i, visited);\\n                components++;\\n            }\\n        }\\n        return components-1;\\n    }\\n    \\n    void dfs(vector<int> adj[], int v, vector<bool>& visited){\\n        visited[v] = true;\\n        for(auto j : adj[v]){\\n            if(!visited[j])\\n                dfs(adj, j, visited);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1811544,
                "title": "c-dsu-union-find-simple-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    #define F0R(i, a) for(int i = 0; i < (a); ++i)\\n    //DSU Template\\n    struct UnionFind{\\n        vector<int> par;\\n\\n        UnionFind(int n) : par(n){\\n            F0R(i,n) par[i] = i;\\n        }\\n\\n        int root(int x) {\\n            if (par[x] == x) return x;\\n            return par[x] = root(par[x]);\\n        }\\n\\n        void merge(int x, int y){\\n            int rx = root(x);\\n            int ry = root(y);\\n            if (rx == ry) return;\\n            par[rx] = ry;\\n        }\\n\\n        bool same(int x, int y){\\n            return root(x) == root(y);\\n        }\\n    };\\n \\n    \\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        \\n        UnionFind DSU(n);\\n        \\n        int cnt=0;\\n        for(auto &x:connections){\\n            if(DSU.same(x[0],x[1]))\\n                cnt++;\\n            else\\n                DSU.merge(x[0],x[1]);\\n        }\\n        \\n        set<int>s;\\n        for(int i=0;i<n;i++){\\n            s.insert(DSU.root(i));\\n        }\\n        \\n        int req=s.size()-1;\\n        \\n        if(req==0)\\n            return 0;\\n        \\n        if(req<=cnt)\\n            return req;\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define F0R(i, a) for(int i = 0; i < (a); ++i)\\n    //DSU Template\\n    struct UnionFind{\\n        vector<int> par;\\n\\n        UnionFind(int n) : par(n){\\n            F0R(i,n) par[i] = i;\\n        }\\n\\n        int root(int x) {\\n            if (par[x] == x) return x;\\n            return par[x] = root(par[x]);\\n        }\\n\\n        void merge(int x, int y){\\n            int rx = root(x);\\n            int ry = root(y);\\n            if (rx == ry) return;\\n            par[rx] = ry;\\n        }\\n\\n        bool same(int x, int y){\\n            return root(x) == root(y);\\n        }\\n    };\\n \\n    \\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        \\n        UnionFind DSU(n);\\n        \\n        int cnt=0;\\n        for(auto &x:connections){\\n            if(DSU.same(x[0],x[1]))\\n                cnt++;\\n            else\\n                DSU.merge(x[0],x[1]);\\n        }\\n        \\n        set<int>s;\\n        for(int i=0;i<n;i++){\\n            s.insert(DSU.root(i));\\n        }\\n        \\n        int req=s.size()-1;\\n        \\n        if(req==0)\\n            return 0;\\n        \\n        if(req<=cnt)\\n            return req;\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1636602,
                "title": "c-o-n-disjoint-sets-union-find",
                "content": "```\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& con) {\\n        vector<int> vis(n, 0);\\n        int count = 0, unvis = 0;\\n        vector<int> parent(n, -1);\\n        \\n        // counting the extra edges using disjoint sets concept...\\n        // when we find an edge connecting nodes with same parent ( or basically already connected node), we consider that\\n        // as an extra edge that can be removed...\\n        for(int i = 0;i<con.size();i++)\\n        {\\n            int x = min(con[i][0], con[i][1]);\\n            int y = max(con[i][1], con[i][0]);\\n            int p1 = x, p2 = y;\\n            while(parent[p1]!=-1)\\n            {\\n                p1 = parent[p1];\\n            }\\n            if(p1!=x)\\n                parent[x] = p1;\\n            while(parent[p2]!=-1)\\n            {\\n                p2 = parent[p2];\\n            }\\n            if(p2!=y)\\n                parent[y] = p2;\\n            if(p1 == p2)\\n                count++;\\n            else\\n                parent[p2] = p1;\\n        }\\n        map<int, int> m;\\n        \\n        // Now we should have only 1 node with parent = -1.. Rest all extra nodes with parent = -1 represent an unconnected\\n        // portion of graph... We just need to connect this node to main branch to make both parts connected...\\n        // we count all such sections as unvis... unvis-1 is taken as we will have 1 node with parent = -1 when all nodes are \\n        // connected...\\n        for(int i=0;i<n;i++)\\n        {\\n            if(parent[i] == -1)\\n                unvis++;\\n        }\\n        \\n        // if we have more extra edges than unvis portions then we can connect graph else we cant..\\n        // min edges needed are unvis-1 [the disconnected portions]....\\n        if(unvis-1>count)\\n            return -1;\\n        else\\n            return unvis-1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& con) {\\n        vector<int> vis(n, 0);\\n        int count = 0, unvis = 0;\\n        vector<int> parent(n, -1);\\n        \\n        // counting the extra edges using disjoint sets concept...\\n        // when we find an edge connecting nodes with same parent ( or basically already connected node), we consider that\\n        // as an extra edge that can be removed...\\n        for(int i = 0;i<con.size();i++)\\n        {\\n            int x = min(con[i][0], con[i][1]);\\n            int y = max(con[i][1], con[i][0]);\\n            int p1 = x, p2 = y;\\n            while(parent[p1]!=-1)\\n            {\\n                p1 = parent[p1];\\n            }\\n            if(p1!=x)\\n                parent[x] = p1;\\n            while(parent[p2]!=-1)\\n            {\\n                p2 = parent[p2];\\n            }\\n            if(p2!=y)\\n                parent[y] = p2;\\n            if(p1 == p2)\\n                count++;\\n            else\\n                parent[p2] = p1;\\n        }\\n        map<int, int> m;\\n        \\n        // Now we should have only 1 node with parent = -1.. Rest all extra nodes with parent = -1 represent an unconnected\\n        // portion of graph... We just need to connect this node to main branch to make both parts connected...\\n        // we count all such sections as unvis... unvis-1 is taken as we will have 1 node with parent = -1 when all nodes are \\n        // connected...\\n        for(int i=0;i<n;i++)\\n        {\\n            if(parent[i] == -1)\\n                unvis++;\\n        }\\n        \\n        // if we have more extra edges than unvis portions then we can connect graph else we cant..\\n        // min edges needed are unvis-1 [the disconnected portions]....\\n        if(unvis-1>count)\\n            return -1;\\n        else\\n            return unvis-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1631752,
                "title": "python-union-find-solution-with-comments-explanation",
                "content": "```\\nclass Solution:\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        \\n        # Find the root of the given node,\\n        # Also compress the path along the way, which is crucial,\\n        # As it makes sure every node in the same set belongs to the \\n        # same root \\n        def find_root(node1: int, root: List[int]) -> int:\\n            while (node1 != root[node1]):\\n                root[node1] = root[root[node1]]\\n                node1 = root[node1]\\n            return node1\\n        \\n        num_components = n\\n        # if the connections are less than n - 1, then \\n        # there must be dangling nodes, return -1 \\n        if len(connections) < n - 1:\\n            return -1\\n    \\n        # Initialize the disjoint set, initially every node is independent\\n        parent = [0] * n\\n        for i in range(n):\\n            parent[i] = i\\n        \\n        # For each connection, find the root of nodes \\n        # If they are not the same, we union them by changing\\n        # node1\\'s root to node2\\'s root. This operation reduce the \\n        # number of component by 1\\n        for connection in connections:\\n            root1 = find_root(connection[0], parent)\\n            root2 = find_root(connection[1], parent)\\n            if root1 != root2:\\n                parent[root1] = root2\\n                num_components -= 1\\n        \\n        # The number of operations to get num_components\\n        return num_components - 1\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        \\n        # Find the root of the given node,\\n        # Also compress the path along the way, which is crucial,\\n        # As it makes sure every node in the same set belongs to the \\n        # same root \\n        def find_root(node1: int, root: List[int]) -> int:\\n            while (node1 != root[node1]):\\n                root[node1] = root[root[node1]]\\n                node1 = root[node1]\\n            return node1\\n        \\n        num_components = n\\n        # if the connections are less than n - 1, then \\n        # there must be dangling nodes, return -1 \\n        if len(connections) < n - 1:\\n            return -1\\n    \\n        # Initialize the disjoint set, initially every node is independent\\n        parent = [0] * n\\n        for i in range(n):\\n            parent[i] = i\\n        \\n        # For each connection, find the root of nodes \\n        # If they are not the same, we union them by changing\\n        # node1\\'s root to node2\\'s root. This operation reduce the \\n        # number of component by 1\\n        for connection in connections:\\n            root1 = find_root(connection[0], parent)\\n            root2 = find_root(connection[1], parent)\\n            if root1 != root2:\\n                parent[root1] = root2\\n                num_components -= 1\\n        \\n        # The number of operations to get num_components\\n        return num_components - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1586061,
                "title": "java-1-union-find-2-graph-coloring",
                "content": "Union Find  99%\\n```\\nclass Solution {\\n    public int makeConnected(int n, int[][] connections) {\\n        if(n>connections.length+1){\\n            return -1;\\n        }\\n        int[] v=new int[n];\\n        for(int i=0;i<n;i++){\\n            v[i]=i;\\n        }\\n        for(int []con:connections){\\n            int a=con[0];\\n            int b=con[1];\\n            while(a!=v[a]){\\n                a=v[a];\\n            }\\n            while(b!=v[b]){\\n                b=v[b];\\n            }\\n            v[b]=a;\\n            v[con[0]]=a;\\n            v[con[1]]=a;\\n        }\\n        int res=0;\\n        for(int i=0;i<n;i++){\\n            if(v[i]==i){\\n                res++;\\n            }\\n        }\\n        return res-1;\\n    } \\n}\\n```\\n\\nGraph+Coloring 60%\\n```\\nclass Solution {\\n    public int makeConnected(int n, int[][] connections) {\\n        if(n>connections.length+1){\\n            return -1;\\n        }\\n        int v[]=new int[n];\\n        List<Integer>[] conns=new ArrayList[n];\\n        for(int i=0;i<n;i++){\\n            conns[i]=new ArrayList();\\n        }\\n        for(int[] cv:connections){\\n            conns[cv[0]].add(cv[1]);\\n            conns[cv[1]].add(cv[0]);\\n        }\\n        int color=0;\\n        for(int i=0;i<n;i++){\\n            if(v[i]==0){\\n                coloring(conns,v,i,++color);\\n            }\\n        }\\n        return color-1;\\n    }\\n\\n    private void coloring(List<Integer>[] conns, int v[], int a, int color){\\n        v[a]=color;\\n        for(int b:conns[a]){\\n            if(v[b]==0){\\n                coloring(conns,v,b,color);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int makeConnected(int n, int[][] connections) {\\n        if(n>connections.length+1){\\n            return -1;\\n        }\\n        int[] v=new int[n];\\n        for(int i=0;i<n;i++){\\n            v[i]=i;\\n        }\\n        for(int []con:connections){\\n            int a=con[0];\\n            int b=con[1];\\n            while(a!=v[a]){\\n                a=v[a];\\n            }\\n            while(b!=v[b]){\\n                b=v[b];\\n            }\\n            v[b]=a;\\n            v[con[0]]=a;\\n            v[con[1]]=a;\\n        }\\n        int res=0;\\n        for(int i=0;i<n;i++){\\n            if(v[i]==i){\\n                res++;\\n            }\\n        }\\n        return res-1;\\n    } \\n}\\n```\n```\\nclass Solution {\\n    public int makeConnected(int n, int[][] connections) {\\n        if(n>connections.length+1){\\n            return -1;\\n        }\\n        int v[]=new int[n];\\n        List<Integer>[] conns=new ArrayList[n];\\n        for(int i=0;i<n;i++){\\n            conns[i]=new ArrayList();\\n        }\\n        for(int[] cv:connections){\\n            conns[cv[0]].add(cv[1]);\\n            conns[cv[1]].add(cv[0]);\\n        }\\n        int color=0;\\n        for(int i=0;i<n;i++){\\n            if(v[i]==0){\\n                coloring(conns,v,i,++color);\\n            }\\n        }\\n        return color-1;\\n    }\\n\\n    private void coloring(List<Integer>[] conns, int v[], int a, int color){\\n        v[a]=color;\\n        for(int b:conns[a]){\\n            if(v[b]==0){\\n                coloring(conns,v,b,color);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1573849,
                "title": "c-simple-application-of-dfs-connected-components",
                "content": "```\\nclass Solution {\\npublic:\\n    void makeGraph(vector<vector<int>>& connections,vector<int> adj[]){\\n        for(int i=0; i<connections.size(); i++){\\n            adj[connections[i][0]].push_back(connections[i][1]);\\n            adj[connections[i][1]].push_back(connections[i][0]);\\n        }\\n    }\\n    void dfs(vector<int> adj[],int s,vector<bool>& visited,int &nodes,int &paths){\\n        visited[s] = true;\\n        nodes++;\\n        paths += adj[s].size();\\n        for(int &v:adj[s]){\\n            if(!visited[v]){\\n                dfs(adj,v,visited,nodes,paths);\\n            }\\n        }\\n    }\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        vector<int> adj[n];\\n        vector<bool> visited(n,false);\\n        int components = 0;\\n        int nodes = 0;\\n        int paths = 0;\\n        int availablePaths = 0;\\n        makeGraph(connections,adj);\\n        \\n        for(int i=0; i<n; i++){\\n            if(!visited[i]){\\n                components++;\\n                dfs(adj,i,visited,nodes,paths);\\n                availablePaths += (paths/2 - nodes + 1);\\n                nodes = 0;\\n                paths = 0;\\n            }\\n        }\\n        if(components == 1)\\n            return 0;\\n        int requiredPaths = components - 1;\\n        if(availablePaths >= requiredPaths)\\n            return requiredPaths;\\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void makeGraph(vector<vector<int>>& connections,vector<int> adj[]){\\n        for(int i=0; i<connections.size(); i++){\\n            adj[connections[i][0]].push_back(connections[i][1]);\\n            adj[connections[i][1]].push_back(connections[i][0]);\\n        }\\n    }\\n    void dfs(vector<int> adj[],int s,vector<bool>& visited,int &nodes,int &paths){\\n        visited[s] = true;\\n        nodes++;\\n        paths += adj[s].size();\\n        for(int &v:adj[s]){\\n            if(!visited[v]){\\n                dfs(adj,v,visited,nodes,paths);\\n            }\\n        }\\n    }\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        vector<int> adj[n];\\n        vector<bool> visited(n,false);\\n        int components = 0;\\n        int nodes = 0;\\n        int paths = 0;\\n        int availablePaths = 0;\\n        makeGraph(connections,adj);\\n        \\n        for(int i=0; i<n; i++){\\n            if(!visited[i]){\\n                components++;\\n                dfs(adj,i,visited,nodes,paths);\\n                availablePaths += (paths/2 - nodes + 1);\\n                nodes = 0;\\n                paths = 0;\\n            }\\n        }\\n        if(components == 1)\\n            return 0;\\n        int requiredPaths = components - 1;\\n        if(availablePaths >= requiredPaths)\\n            return requiredPaths;\\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1573046,
                "title": "python-clean-and-simple-union-find-solution",
                "content": "```\\nclass Solution:\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        uf = UnionFind(list(range(n)))\\n        redundant, wires = 0, n-1\\n        \\n        for start, end in connections:\\n            if uf.union(start, end):\\n                wires -= 1\\n            else:\\n                redundant += 1\\n\\n        return wires if wires <= redundant else -1\\n\\nclass UnionFind:\\n    def __init__(self, parent):\\n        self.parent = parent\\n    \\n    def find(self, node):\\n        while self.parent[node] != node:\\n            node = self.parent[node]\\n        return node\\n    \\n    def union(self, x, y):\\n        parent_x, parent_y = self.find(x), self.find(y)\\n        \\n        if parent_x == parent_y:\\n            return False     \\n        if parent_x < parent_y:\\n            self.parent[parent_y] = parent_x\\n        else:\\n            self.parent[parent_x] = parent_y\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        uf = UnionFind(list(range(n)))\\n        redundant, wires = 0, n-1\\n        \\n        for start, end in connections:\\n            if uf.union(start, end):\\n                wires -= 1\\n            else:\\n                redundant += 1\\n\\n        return wires if wires <= redundant else -1\\n\\nclass UnionFind:\\n    def __init__(self, parent):\\n        self.parent = parent\\n    \\n    def find(self, node):\\n        while self.parent[node] != node:\\n            node = self.parent[node]\\n        return node\\n    \\n    def union(self, x, y):\\n        parent_x, parent_y = self.find(x), self.find(y)\\n        \\n        if parent_x == parent_y:\\n            return False     \\n        if parent_x < parent_y:\\n            self.parent[parent_y] = parent_x\\n        else:\\n            self.parent[parent_x] = parent_y\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1541422,
                "title": "union-find-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& c) {\\n      int size=c.size(),ans=0;\\n        if(size<n-1)\\n            return -1;\\n        vector<int>un(n,-1);\\n        for(int i=0;i<size;i++){\\n          auto a=  parent(c[i][0],un);\\n           auto b= parent(c[i][1],un);\\n            if(a!=b)\\n                un[b]=a;\\n        }\\n        for(auto & i:un)\\n            if(i==-1)\\n                ans++;\\n        return ans-1;\\n    }\\n   int parent(int a,vector<int>& un){\\n        while(un[a]!=-1)\\n            a=un[a];\\n       return a;\\n    }\\n};\\n```\\nDo **UPVOTE** if it helps:)",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& c) {\\n      int size=c.size(),ans=0;\\n        if(size<n-1)\\n            return -1;\\n        vector<int>un(n,-1);\\n        for(int i=0;i<size;i++){\\n          auto a=  parent(c[i][0],un);\\n           auto b= parent(c[i][1],un);\\n            if(a!=b)\\n                un[b]=a;\\n        }\\n        for(auto & i:un)\\n            if(i==-1)\\n                ans++;\\n        return ans-1;\\n    }\\n   int parent(int a,vector<int>& un){\\n        while(un[a]!=-1)\\n            a=un[a];\\n       return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1501303,
                "title": "c-bfs-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void bfs(vector<vector<int>>&adj,int i,vector<bool>&vis){\\n        queue<int>q;\\n        q.push(i);\\n        vis[i]=true;\\n        while(!q.empty()){\\n            int x=q.front();\\n            q.pop();\\n            for(int i=0;i<adj[x].size();i++){\\n                if(!vis[adj[x][i]]){\\n                    q.push(adj[x][i]);\\n                    vis[adj[x][i]]=true;\\n                }\\n            }\\n        }\\n    }\\n    int makeConnected(int n, vector<vector<int>>& con) {\\n        int m=con.size();\\n        if(m < 1) return m;\\n        \\n        if(m < n-1) return -1;\\n\\t\\t\\n        vector<vector<int>>adj(n);\\n        for(int i=0;i<m;i++){\\n            adj[con[i][0]].push_back(con[i][1]);\\n            adj[con[i][1]].push_back(con[i][0]);\\n        }\\n        \\n        vector<bool>vis(n,false);\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                count++;\\n                bfs(adj,i,vis);\\n            }\\n        }\\n        return count-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void bfs(vector<vector<int>>&adj,int i,vector<bool>&vis){\\n        queue<int>q;\\n        q.push(i);\\n        vis[i]=true;\\n        while(!q.empty()){\\n            int x=q.front();\\n            q.pop();\\n            for(int i=0;i<adj[x].size();i++){\\n                if(!vis[adj[x][i]]){\\n                    q.push(adj[x][i]);\\n                    vis[adj[x][i]]=true;\\n                }\\n            }\\n        }\\n    }\\n    int makeConnected(int n, vector<vector<int>>& con) {\\n        int m=con.size();\\n        if(m < 1) return m;\\n        \\n        if(m < n-1) return -1;\\n\\t\\t\\n        vector<vector<int>>adj(n);\\n        for(int i=0;i<m;i++){\\n            adj[con[i][0]].push_back(con[i][1]);\\n            adj[con[i][1]].push_back(con[i][0]);\\n        }\\n        \\n        vector<bool>vis(n,false);\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                count++;\\n                bfs(adj,i,vis);\\n            }\\n        }\\n        return count-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390810,
                "title": "python-count-components-with-dfs-interview-solution-faster-than-95-86",
                "content": "```\\n# 1. Create Adjacency List\\n# 2. DFS to find number of components\\n# 3 Use formula to see if possible\\nclass Solution:\\n    \\n    def create_adj_list(self, n, connections):\\n      graph = {i: [] for i in range(n)}\\n      for node, child in connections:\\n        graph[node].append(child)\\n        graph[child].append(node)\\n      return graph\\n    \\n    def dfs(self, node, visited, graph):\\n      visited.add(node)\\n      for neighbour in graph.get(node):\\n        if neighbour not in visited:\\n          self.dfs(neighbour, visited, graph)\\n          \\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n      # Not enough edges for all nodes\\n      if len(connections) < n - 1:\\n        return -1\\n      # Create the graph using adj_list\\n      graph = self.create_adj_list(n, connections)\\n      # Perform DFS to get count of components\\n      visited, total_components = set(), 0\\n      for node in range(n):\\n        if node not in visited:\\n            self.dfs(node, visited, graph)\\n            total_components += 1\\n      # Get count of edges that are redundant\\n                        # total # of edges - (minimum number of edges required)  \\n      redundant_edges = len(connections) - ((n-1) - (total_components - 1))\\n      if redundant_edges < total_components - 1: return -1\\n      return total_components - 1\\n\\t",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "class Solution:\\n    \\n    def create_adj_list(self, n, connections):\\n      graph = {i: [] for i in range(n)}",
                "codeTag": "Java"
            },
            {
                "id": 1374785,
                "title": "java-union-find-using-path-compression-and-union-by-size-faster-than-100",
                "content": "**Do vote up if you like it :)**\\n```\\nclass Solution {\\n    \\n    public static int[] par;\\n    \\n    public static int[] size;\\n    \\n    public static int findPar(int v){\\n        if(v == par[v])\\n            return v;\\n        return par[v] = findPar(par[v]);\\n    }\\n    \\n    public static void mergeOrUnionBySize(int gpu, int gpv) {\\n        if(size[gpv] > size[gpu]) {\\n            par[gpu] = gpv;\\n            size[gpv] += size[gpu];\\n        }    \\n        else {\\n            par[gpv] = gpu;\\n            size[gpu] += size[gpv];\\n        }\\n    }\\n    \\n    public int makeConnected(int N, int[][] connections) {\\n        par = new int[N];\\n        size = new int[N];\\n        \\n        for(int i = 0 ; i < N; i++) {\\n            par[i] = i;\\n        }\\n        \\n        int extraCount = 0;\\n        int connectedComponentCount = N;\\n        \\n        for(int[] connection : connections) {\\n            int GlobalParentOfu = findPar(connection[0]);\\n            int GlobalParentOfv = findPar(connection[1]);\\n            \\n            if(GlobalParentOfu != GlobalParentOfv) { \\n                mergeOrUnionBySize(GlobalParentOfu, GlobalParentOfv);\\n                connectedComponentCount--;\\n            }\\n            else {\\n                extraCount++;\\n            }\\n        }\\n        \\n        return extraCount >= connectedComponentCount - 1 ? connectedComponentCount - 1 : -1; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public static int[] par;\\n    \\n    public static int[] size;\\n    \\n    public static int findPar(int v){\\n        if(v == par[v])\\n            return v;\\n        return par[v] = findPar(par[v]);\\n    }\\n    \\n    public static void mergeOrUnionBySize(int gpu, int gpv) {\\n        if(size[gpv] > size[gpu]) {\\n            par[gpu] = gpv;\\n            size[gpv] += size[gpu];\\n        }    \\n        else {\\n            par[gpv] = gpu;\\n            size[gpu] += size[gpv];\\n        }\\n    }\\n    \\n    public int makeConnected(int N, int[][] connections) {\\n        par = new int[N];\\n        size = new int[N];\\n        \\n        for(int i = 0 ; i < N; i++) {\\n            par[i] = i;\\n        }\\n        \\n        int extraCount = 0;\\n        int connectedComponentCount = N;\\n        \\n        for(int[] connection : connections) {\\n            int GlobalParentOfu = findPar(connection[0]);\\n            int GlobalParentOfv = findPar(connection[1]);\\n            \\n            if(GlobalParentOfu != GlobalParentOfv) { \\n                mergeOrUnionBySize(GlobalParentOfu, GlobalParentOfv);\\n                connectedComponentCount--;\\n            }\\n            else {\\n                extraCount++;\\n            }\\n        }\\n        \\n        return extraCount >= connectedComponentCount - 1 ? connectedComponentCount - 1 : -1; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1361980,
                "title": "simple-approach",
                "content": "**DFS**\\n```\\nclass Solution {\\npublic:\\n        \\n    void connect(vector<vector<int>> &adj,vector<bool> &vis,int src){\\n            \\n         vis[src]=true;\\n         for(auto it:adj[src]){\\n             if(!vis[it]){\\n                 connect(adj,vis,it);    \\n             }\\n         }\\n    }   \\n        \\n    int makeConnected(int n, vector<vector<int>>& connections){\\n            \\n        if(n-1>connections.size())return -1;\\n            \\n        vector<vector<int>> adj(n);\\n            \\n        for(auto it:connections){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n            \\n        vector<bool> vis(n,false);\\n        \\n        int comp=0;\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){     \\n              connect(adj,vis,i);\\n              comp++;\\n            }\\n        } \\n            \\n        int neededwires=comp-1;  \\n            \\nreturn neededwires;        \\n    }\\n};\\n```\\n\\n**DSU**\\n```\\n\\nclass Solution {\\npublic:\\n        \\n    int find(int x,vector<int> &par){\\n            \\n         if(par[x]==x){\\n             return x;    \\n         }   \\n         int temp=find(par[x],par);\\n         par[x]=temp;\\n            \\n     return temp;   \\n    } \\n        \\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        \\n       if(n-1>connections.size()){\\n           return -1;    \\n       }     \\n            \\n        vector<int> par(n);\\n        for(int i=0;i<n;i++){\\n            par[i]=i;     \\n        }    \\n        \\n        for(auto it:connections){      \\n            \\n            int lx=find(it[0],par);    \\n            int ly=find(it[1],par); \\n                \\n            if(lx!=ly){\\n               par[lx]=ly;    \\n            }    \\n        }\\n        int cnt=0;    \\n        for(int i=0;i<n;i++){\\n            if(par[i]==i){\\n                cnt++;    \\n            }   \\n        }    \\nreturn cnt-1;            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        \\n    void connect(vector<vector<int>> &adj,vector<bool> &vis,int src){\\n            \\n         vis[src]=true;\\n         for(auto it:adj[src]){\\n             if(!vis[it]){\\n                 connect(adj,vis,it);    \\n             }\\n         }\\n    }   \\n        \\n    int makeConnected(int n, vector<vector<int>>& connections){\\n            \\n        if(n-1>connections.size())return -1;\\n            \\n        vector<vector<int>> adj(n);\\n            \\n        for(auto it:connections){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n            \\n        vector<bool> vis(n,false);\\n        \\n        int comp=0;\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){     \\n              connect(adj,vis,i);\\n              comp++;\\n            }\\n        } \\n            \\n        int neededwires=comp-1;  \\n            \\nreturn neededwires;        \\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n        \\n    int find(int x,vector<int> &par){\\n            \\n         if(par[x]==x){\\n             return x;    \\n         }   \\n         int temp=find(par[x],par);\\n         par[x]=temp;\\n            \\n     return temp;   \\n    } \\n        \\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        \\n       if(n-1>connections.size()){\\n           return -1;    \\n       }     \\n            \\n        vector<int> par(n);\\n        for(int i=0;i<n;i++){\\n            par[i]=i;     \\n        }    \\n        \\n        for(auto it:connections){      \\n            \\n            int lx=find(it[0],par);    \\n            int ly=find(it[1],par); \\n                \\n            if(lx!=ly){\\n               par[lx]=ly;    \\n            }    \\n        }\\n        int cnt=0;    \\n        for(int i=0;i<n;i++){\\n            if(par[i]==i){\\n                cnt++;    \\n            }   \\n        }    \\nreturn cnt-1;            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1348167,
                "title": "union-find-with-path-compression-and-union-by-rank-c-98-faster",
                "content": "```\\nint find(int x,vector<int>& parent){\\n        if(x!=parent[x]) parent[x]=find(parent[x],parent);\\n        return parent[x];\\n    }\\n    void unions(int x,int y,vector<int>& parent,vector<int>& rank){\\n        int rootX=find(x,parent);\\n        int rootY=find(y,parent);\\n        if(rootX==rootY) return;\\n        if(rank[rootX]>rank[rootY]) parent[rootY]=rootX;\\n        else{\\n            parent[rootX]=rootY;\\n            if(rank[rootX]==rank[rootY]) rank[rootY]++;\\n        }\\n    }\\n    int makeConnected(int n, vector<vector<int>>& cn) {\\n        int m=cn.size();\\n        if(m<n-1) return -1;\\n        vector<int> parent(n);\\n        vector<int> rank(n,0);\\n        for(int i=0;i<n;i++) parent[i]=i;\\n        for(int i=0;i<cn.size();i++) unions(cn[i][0],cn[i][1],parent,rank);\\n        set<int> st;\\n        for(int i=0;i<n;i++){\\n            int x=find(i,parent);\\n            st.insert(x);\\n        }\\n        return st.size()-1;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nint find(int x,vector<int>& parent){\\n        if(x!=parent[x]) parent[x]=find(parent[x],parent);\\n        return parent[x];\\n    }\\n    void unions(int x,int y,vector<int>& parent,vector<int>& rank){\\n        int rootX=find(x,parent);\\n        int rootY=find(y,parent);\\n        if(rootX==rootY) return;\\n        if(rank[rootX]>rank[rootY]) parent[rootY]=rootX;\\n        else{\\n            parent[rootX]=rootY;\\n            if(rank[rootX]==rank[rootY]) rank[rootY]++;\\n        }\\n    }\\n    int makeConnected(int n, vector<vector<int>>& cn) {\\n        int m=cn.size();\\n        if(m<n-1) return -1;\\n        vector<int> parent(n);\\n        vector<int> rank(n,0);\\n        for(int i=0;i<n;i++) parent[i]=i;\\n        for(int i=0;i<cn.size();i++) unions(cn[i][0],cn[i][1],parent,rank);\\n        set<int> st;\\n        for(int i=0;i<n;i++){\\n            int x=find(i,parent);\\n            st.insert(x);\\n        }\\n        return st.size()-1;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1321229,
                "title": "c-dfs-number-of-island",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(int i, vector<int> adj[], vector<int> &vis){\\n        vis[i]=1;\\n        for(auto x: adj[i]){\\n            if(vis[x]==0){\\n                dfs(x,adj,vis);\\n            }\\n        }\\n    }\\n    int noOfComponents(int n, vector<int> adj[]){\\n        int i, cnt=0;\\n        vector<int> vis(n,0);\\n        for(i=0;i<n;i++){\\n            if(vis[i]==0){\\n                dfs(i,adj,vis);\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        int i,x,y,noOfComp,redundant,ans;\\n        vector<int> adj[n];\\n        for(i=0;i<connections.size();i++){\\n            x=connections[i][0]; y=connections[i][1];\\n            adj[x].push_back(y); adj[y].push_back(x);\\n        }\\n        noOfComp=noOfComponents(n,adj);\\n        redundant=connections.size()-((n-1)-(noOfComp-1));\\n        if(redundant>=(noOfComp-1)) ans = noOfComp-1;\\n        else ans=-1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int i, vector<int> adj[], vector<int> &vis){\\n        vis[i]=1;\\n        for(auto x: adj[i]){\\n            if(vis[x]==0){\\n                dfs(x,adj,vis);\\n            }\\n        }\\n    }\\n    int noOfComponents(int n, vector<int> adj[]){\\n        int i, cnt=0;\\n        vector<int> vis(n,0);\\n        for(i=0;i<n;i++){\\n            if(vis[i]==0){\\n                dfs(i,adj,vis);\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        int i,x,y,noOfComp,redundant,ans;\\n        vector<int> adj[n];\\n        for(i=0;i<connections.size();i++){\\n            x=connections[i][0]; y=connections[i][1];\\n            adj[x].push_back(y); adj[y].push_back(x);\\n        }\\n        noOfComp=noOfComponents(n,adj);\\n        redundant=connections.size()-((n-1)-(noOfComp-1));\\n        if(redundant>=(noOfComp-1)) ans = noOfComp-1;\\n        else ans=-1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1320484,
                "title": "c-union-find-by-rank-and-path-compression-o-eloge",
                "content": "```\\nclass Solution {\\npublic:\\n    int find(int x,vector<int>&p){\\n        if(x==p[x])\\n            return x;\\n        p[x] = find(p[x],p);\\n        return p[x];\\n    }\\n    void unionf(int x,int y, vector<int>&p,vector<int>&r){\\n    \\n        int px = find(x,p);\\n        int py = find(y,p);\\n        if(px==py)\\n            return;\\n        if(r[px]>r[py])\\n            p[py] = px;\\n        else if(r[py]>r[px])\\n            p[px] = py;\\n        else{\\n            p[py] = px;\\n            r[px]++;\\n        }\\n            \\n    }\\n    int makeConnected(int n, vector<vector<int>>& cn) {\\n        int m = cn.size();\\n        if(m<n-1) return -1;\\n        \\n        vector<int> parent(n),rank(n,0);\\n        for(int i=0;i<n;i++) parent[i] = i; // initialization.\\n        \\n        for(int i=0;i<cn.size();i++)        //connecting edges\\n            unionf(cn[i][0],cn[i][1],parent,rank);\\n        \\n        int res = 0;\\n        \\n        set<int> s; // store unique parents or components\\n        \\n        for(int i=0;i<n;i++){\\n            int x = find(parent[i],parent); //find original unique parents\\n            s.insert(x);\\n        }\\n            \\n        \\n        return s.size()-1;  \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(int x,vector<int>&p){\\n        if(x==p[x])\\n            return x;\\n        p[x] = find(p[x],p);\\n        return p[x];\\n    }\\n    void unionf(int x,int y, vector<int>&p,vector<int>&r){\\n    \\n        int px = find(x,p);\\n        int py = find(y,p);\\n        if(px==py)\\n            return;\\n        if(r[px]>r[py])\\n            p[py] = px;\\n        else if(r[py]>r[px])\\n            p[px] = py;\\n        else{\\n            p[py] = px;\\n            r[px]++;\\n        }\\n            \\n    }\\n    int makeConnected(int n, vector<vector<int>>& cn) {\\n        int m = cn.size();\\n        if(m<n-1) return -1;\\n        \\n        vector<int> parent(n),rank(n,0);\\n        for(int i=0;i<n;i++) parent[i] = i; // initialization.\\n        \\n        for(int i=0;i<cn.size();i++)        //connecting edges\\n            unionf(cn[i][0],cn[i][1],parent,rank);\\n        \\n        int res = 0;\\n        \\n        set<int> s; // store unique parents or components\\n        \\n        for(int i=0;i<n;i++){\\n            int x = find(parent[i],parent); //find original unique parents\\n            s.insert(x);\\n        }\\n            \\n        \\n        return s.size()-1;  \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1296053,
                "title": "c-easy-simple-dfs-union-find-counting-graph-componnents",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int makeConnected(int n, vector<vector<int>> &connections)\\n    {\\n        int totalCable = connections.size();\\n        //base case if given cable are less then n-1 then we can\\'t connect each other\\n\\t\\t//because to coonect n computer in linear manner we required minimum n-1 cable\\n\\t\\tif (totalCable < n - 1)\\n        {\\n            return -1;\\n        }\\n\\t\\t//make graph of it and simply count components\\n        vector<int> adj[n];\\n        for (auto it : connections)\\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        int componnents = 0;\\n        bool visited[n];\\n        memset(visited, false, sizeof(visited));\\n\\t\\t//counting componnents by dfs traversal\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (!visited[i])\\n            {\\n                componnents++;\\n                dfs(i, adj, visited);\\n            }\\n        }\\n\\t\\t//if there is m componnents in this graph then we required minimum m-1 connection (cable) to join them\\n\\t\\t//returning componnents-1\\n        return (componnents - 1);\\n    }\\n\\n    void dfs(int node, vector<int> adj[], bool visited[])\\n    {\\n        visited[node] = true;\\n        for (auto it : adj[node])\\n        {\\n            if (!visited[it])\\n            {\\n                dfs(it, adj, visited);\\n            }\\n        }\\n    }\\n};\\n```\\n****\\n****\\n**Union Find Method**\\n```\\nclass Solution\\n{\\npublic:\\n    int makeConnected(int n, vector<vector<int>> &connections)\\n    {\\n        int totalCable = connections.size();\\n        if (totalCable < n - 1)\\n        {\\n            return -1;\\n        }   \\n        vector<int>rank(n,0);\\n        vector<int>parent(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            parent[i]=i;\\n        }\\n        int ans = n;\\n        for(auto it:connections)\\n        {\\n            int a = parentof(it[0],parent);\\n            int b = parentof(it[1],parent);\\n            if(a!=b)\\n            {\\n                if(rank[a]<rank[b])\\n                {\\n                    parent[a] = b;\\n                }\\n                else if(rank[b]<rank[a])\\n                {\\n                    parent[b] = a;\\n                }\\n                else\\n                {\\n                    parent[a] = b;\\n                    rank[b]++;\\n                }\\n                ans--;\\n            }\\n        }\\n        return ans-1;\\n    }\\n    \\n    int parentof(int a,vector<int>&parent)\\n    {\\n        if(parent[a]==a)\\n        {\\n            return a;\\n        }\\n        return parent[a] = parentof(parent[a],parent);\\n    }  \\n};\\n```\\n\\n*If Helpful Upvote it* **:)**",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int makeConnected(int n, vector<vector<int>> &connections)\\n    {\\n        int totalCable = connections.size();\\n        //base case if given cable are less then n-1 then we can\\'t connect each other\\n\\t\\t//because to coonect n computer in linear manner we required minimum n-1 cable\\n\\t\\tif (totalCable < n - 1)\\n        {\\n            return -1;\\n        }\\n\\t\\t//make graph of it and simply count components\\n        vector<int> adj[n];\\n        for (auto it : connections)\\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        int componnents = 0;\\n        bool visited[n];\\n        memset(visited, false, sizeof(visited));\\n\\t\\t//counting componnents by dfs traversal\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (!visited[i])\\n            {\\n                componnents++;\\n                dfs(i, adj, visited);\\n            }\\n        }\\n\\t\\t//if there is m componnents in this graph then we required minimum m-1 connection (cable) to join them\\n\\t\\t//returning componnents-1\\n        return (componnents - 1);\\n    }\\n\\n    void dfs(int node, vector<int> adj[], bool visited[])\\n    {\\n        visited[node] = true;\\n        for (auto it : adj[node])\\n        {\\n            if (!visited[it])\\n            {\\n                dfs(it, adj, visited);\\n            }\\n        }\\n    }\\n};\\n```\n```\\nclass Solution\\n{\\npublic:\\n    int makeConnected(int n, vector<vector<int>> &connections)\\n    {\\n        int totalCable = connections.size();\\n        if (totalCable < n - 1)\\n        {\\n            return -1;\\n        }   \\n        vector<int>rank(n,0);\\n        vector<int>parent(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            parent[i]=i;\\n        }\\n        int ans = n;\\n        for(auto it:connections)\\n        {\\n            int a = parentof(it[0],parent);\\n            int b = parentof(it[1],parent);\\n            if(a!=b)\\n            {\\n                if(rank[a]<rank[b])\\n                {\\n                    parent[a] = b;\\n                }\\n                else if(rank[b]<rank[a])\\n                {\\n                    parent[b] = a;\\n                }\\n                else\\n                {\\n                    parent[a] = b;\\n                    rank[b]++;\\n                }\\n                ans--;\\n            }\\n        }\\n        return ans-1;\\n    }\\n    \\n    int parentof(int a,vector<int>&parent)\\n    {\\n        if(parent[a]==a)\\n        {\\n            return a;\\n        }\\n        return parent[a] = parentof(parent[a],parent);\\n    }  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1271741,
                "title": "c-using-union-and-find-simple-and-clean-code",
                "content": "```\\n    // using union and find\\n    \\n    int find( vector<int>&parent,int x){\\n        if(parent[x]==x)\\n        return x;\\n        else\\n               parent[x]=find(parent,parent[x]);\\n        return parent[x];\\n        \\n    }\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        if(connections.size()<n-1)\\n            return -1;\\n        \\n        vector<int>parent(n);\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n        }\\n        int edge_count=0;\\n        int x,y,root_x,root_y;\\n        for(int i=0;i<connections.size();i++){\\n             x=connections[i][0];\\n             y=connections[i][1];\\n            root_x=find(parent,x);\\n            root_y=find(parent,y);\\n            if(root_x==root_y)\\n                edge_count++;\\n             else\\n                parent[root_y]=root_x;\\n           // cout<<parent[root_y]<<\"  \";\\n            \\n        }\\n        unordered_set<int>myset;\\n        for(int i=0;i<n;i++){\\n                myset.insert(find(parent,i));\\n        }\\n       \\n        //size of myset will give number of parent node i.e. no of different  connected component\\n        if(myset.size()-1<=edge_count)\\n            return myset.size()-1;\\n        \\n            return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n    // using union and find\\n    \\n    int find( vector<int>&parent,int x){\\n        if(parent[x]==x)\\n        return x;\\n        else\\n               parent[x]=find(parent,parent[x]);\\n        return parent[x];\\n        \\n    }\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        if(connections.size()<n-1)\\n            return -1;\\n        \\n        vector<int>parent(n);\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n        }\\n        int edge_count=0;\\n        int x,y,root_x,root_y;\\n        for(int i=0;i<connections.size();i++){\\n             x=connections[i][0];\\n             y=connections[i][1];\\n            root_x=find(parent,x);\\n            root_y=find(parent,y);\\n            if(root_x==root_y)\\n                edge_count++;\\n             else\\n                parent[root_y]=root_x;\\n           // cout<<parent[root_y]<<\"  \";\\n            \\n        }\\n        unordered_set<int>myset;\\n        for(int i=0;i<n;i++){\\n                myset.insert(find(parent,i));\\n        }\\n       \\n        //size of myset will give number of parent node i.e. no of different  connected component\\n        if(myset.size()-1<=edge_count)\\n            return myset.size()-1;\\n        \\n            return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1269538,
                "title": "c-dfs-detailed-explanation",
                "content": "**INTUTION :-**\\n\\n**This problem is same as No. of Islands**\\n* The minimum number of edges required for a graph with n nodes to remain connected is ```n-1 ```\\n*  if there are **k** components in a disconnected graph, then we need at least **k - 1** edges to connect every component.\\n*  we will count the number of components  **k**\\n*  we will need k - 1 operations to connect the computers (components). And that is our ans.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<vector<int>> &adj,vector<bool> &vis,int idx){\\n        vis[idx]=true;\\n        for(int i:adj[idx]){\\n            if(!vis[i]){\\n                dfs(adj,vis,i);\\n            }\\n        }\\n    }\\n    \\n    int makeConnected(int n, vector<vector<int>>& arr) {\\n        if(arr.size()<n-1) return -1;      //  if no of edges is less than no of vertex\\n        \\n        vector<vector<int>> adj(n);\\n        \\n\\t\\t// Creating adjacency list\\n        for(auto x : arr){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        vector<bool> vis(n,false);\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){     // if that computer is not visited \\n                dfs(adj,vis,i);\\n                ans++;     \\n            }\\n        }\\n        return ans-1;\\n    }\\n};",
                "solutionTags": [],
                "code": "```n-1 ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1257705,
                "title": "union-find-with-path-compression-and-dfs-c",
                "content": "The problem simply requires you to find connected components in the network, as the number of operations would be simply the number of connected components - 1.\\n\\nBoth DFS as well as union find could be used. Inspired by Lee215\\'s template, the following is the union find with path compression algorithm :\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int , int> parent;\\n    int components;\\n    int redundant_links = 0;\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        if(n - 1 > connections.size())\\n            return -1;\\n        components = n;\\n        for(auto c : connections)\\n            uni(c[0] , c[1]);\\n        \\n        return components - 1;\\n    }\\n    \\n    int find(int x){\\n        if(!parent.count(x))\\n            parent[x] = x;\\n        if(parent[x]!=x)\\n            parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n    \\n    void uni(int x , int y){\\n        x = find(x) , y = find(y);\\n        if(x == y)\\n            redundant_links+= 1;\\n        else\\n            parent[y] = x, components--;\\n    }\\n};\\n```\\nThe DFS counterpart would be this :\\n```\\nclass Solution {\\npublic:\\n    \\n    map<int , vector<int>> graph;\\n    \\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        \\n        if(connections.size() < n - 1)\\n            return -1;\\n       vector<bool> visited(n , false);\\n        \\n        int components = 0;\\n        for(auto e : connections){\\n            graph[e[0]].push_back(e[1]);\\n            graph[e[1]].push_back(e[0]);\\n        }\\n        \\n        for(int i = 0; i <n ; i++){\\n            if(!visited[i]){\\n                dfs(i, visited);\\n                components++;\\n            }\\n        }\\n        return components - 1;\\n        \\n    }\\n        void dfs(int i , vector<bool>& visited){\\n        \\n        if(!visited[i]){\\n            visited[i] = true;\\n            for(int n : graph[i])\\n                dfs(n , visited);\\n        }\\n    }\\n    \\n};\\n```\\nDFS is clearly the faster algorithm here.\\n",
                "solutionTags": [
                    "Depth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int , int> parent;\\n    int components;\\n    int redundant_links = 0;\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        if(n - 1 > connections.size())\\n            return -1;\\n        components = n;\\n        for(auto c : connections)\\n            uni(c[0] , c[1]);\\n        \\n        return components - 1;\\n    }\\n    \\n    int find(int x){\\n        if(!parent.count(x))\\n            parent[x] = x;\\n        if(parent[x]!=x)\\n            parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n    \\n    void uni(int x , int y){\\n        x = find(x) , y = find(y);\\n        if(x == y)\\n            redundant_links+= 1;\\n        else\\n            parent[y] = x, components--;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    map<int , vector<int>> graph;\\n    \\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        \\n        if(connections.size() < n - 1)\\n            return -1;\\n       vector<bool> visited(n , false);\\n        \\n        int components = 0;\\n        for(auto e : connections){\\n            graph[e[0]].push_back(e[1]);\\n            graph[e[1]].push_back(e[0]);\\n        }\\n        \\n        for(int i = 0; i <n ; i++){\\n            if(!visited[i]){\\n                dfs(i, visited);\\n                components++;\\n            }\\n        }\\n        return components - 1;\\n        \\n    }\\n        void dfs(int i , vector<bool>& visited){\\n        \\n        if(!visited[i]){\\n            visited[i] = true;\\n            for(int n : graph[i])\\n                dfs(n , visited);\\n        }\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1227126,
                "title": "c-simple-dfs-detailed-explanation",
                "content": "First of all we can see in order to make network connected, atleast ```n-1``` edges must be present in the network(same as number of edges in minimum spanning tree) so we can check the size of connections vector if it is less than ```n-1``` we will return ```-1``` otherwise there is always a solution exists.\\nAnd we can also see that ```minimum number of operation = number of connected component - 1```.\\nbecause we can always connect two connected component using 1 edge similarly we can connect ```x``` connected component using ```x-1``` edge/operations. so we have to find the number of connected component in given connections.\\nso we can start doing dfs from 0th vertex and count the number of times we have to make dfs call which is our final answer.\\nbelow is the implementation for the same.\\n```\\nclass Solution{\\n    public:\\n    vector<bool> visited;\\n    vector<vector<int>> conn;\\n    void dfs(int n){\\n        visited[n] = true;\\n        for(auto x:conn[n]){\\n            if(!visited[x]) dfs(x);\\n        }\\n    }\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        if(n > (connections.size()+1)) return -1;\\n        visited.resize(n);\\n        fill(visited.begin(),visited.end(),false);\\n        conn.resize(n);\\n        for(auto x:connections){\\n            conn[x[0]].push_back(x[1]);\\n            conn[x[1]].push_back(x[0]);\\n        }\\n        int ans =-1;\\n        for(int i=0;i<n;i++){\\n            if(!visited[i]){\\n                dfs(i);ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```n-1```\n```n-1```\n```-1```\n```minimum number of operation = number of connected component - 1```\n```x```\n```x-1```\n```\\nclass Solution{\\n    public:\\n    vector<bool> visited;\\n    vector<vector<int>> conn;\\n    void dfs(int n){\\n        visited[n] = true;\\n        for(auto x:conn[n]){\\n            if(!visited[x]) dfs(x);\\n        }\\n    }\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        if(n > (connections.size()+1)) return -1;\\n        visited.resize(n);\\n        fill(visited.begin(),visited.end(),false);\\n        conn.resize(n);\\n        for(auto x:connections){\\n            conn[x[0]].push_back(x[1]);\\n            conn[x[1]].push_back(x[0]);\\n        }\\n        int ans =-1;\\n        for(int i=0;i<n;i++){\\n            if(!visited[i]){\\n                dfs(i);ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 1224289,
                "title": "c-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<int> graph[], vector<bool> &visited)\\n    {\\n        visited[node] = true;\\n        for(auto x : graph[node])\\n        {\\n            if(!visited[x])\\n                dfs(x, graph, visited);\\n        }\\n    }\\n    \\n    int disconnectedComponents(int n, vector<int> graph[])\\n    {\\n        vector<bool> visited(n, false);\\n        int ans = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(!visited[i])\\n            {\\n                ans++;\\n                dfs(i, graph, visited);    \\n            }            \\n        }\\n        return ans;\\n    }\\n    \\n    void makeGraph(vector<int> graph[], vector<vector<int>>& connections)\\n    {\\n        for(auto x : connections)\\n        {\\n            graph[x[0]].push_back(x[1]);\\n            graph[x[1]].push_back(x[0]);\\n        }\\n    }\\n    \\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        vector<int>graph[n];\\n        makeGraph(graph, connections);\\n        int x = disconnectedComponents(n, graph);\\n        if(x == 1)\\n        {\\n            return 0;\\n        }\\n        if(x - 1 > connections.size() - (n - (x - 1) - 1))\\n        {\\n            return -1;\\n        }\\n        return x - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<int> graph[], vector<bool> &visited)\\n    {\\n        visited[node] = true;\\n        for(auto x : graph[node])\\n        {\\n            if(!visited[x])\\n                dfs(x, graph, visited);\\n        }\\n    }\\n    \\n    int disconnectedComponents(int n, vector<int> graph[])\\n    {\\n        vector<bool> visited(n, false);\\n        int ans = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(!visited[i])\\n            {\\n                ans++;\\n                dfs(i, graph, visited);    \\n            }            \\n        }\\n        return ans;\\n    }\\n    \\n    void makeGraph(vector<int> graph[], vector<vector<int>>& connections)\\n    {\\n        for(auto x : connections)\\n        {\\n            graph[x[0]].push_back(x[1]);\\n            graph[x[1]].push_back(x[0]);\\n        }\\n    }\\n    \\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        vector<int>graph[n];\\n        makeGraph(graph, connections);\\n        int x = disconnectedComponents(n, graph);\\n        if(x == 1)\\n        {\\n            return 0;\\n        }\\n        if(x - 1 > connections.size() - (n - (x - 1) - 1))\\n        {\\n            return -1;\\n        }\\n        return x - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1147192,
                "title": "javascript-solution-using-dfs",
                "content": "```\\nvar makeConnected = function(n, connections) {\\n    let edges = connections.length;\\n    if(edges < n-1) return -1;\\n    let g = [];\\n    for(let i=0;i<n;i++) g[i] = []\\n    for(let i=0;i<edges;i++){\\n        g[connections[i][0]].push(connections[i][1]);\\n        g[connections[i][1]].push(connections[i][0]);\\n    } \\n    let v = Array(n).fill(0),c=0;\\n    for(let i=0;i<n;i++){\\n        if(!v[i]){\\n            c++;\\n            dfs(i,g,v)\\n        }\\n    }\\n    return c-1;\\n};\\nfunction dfs(i,con,v){\\n    v[i] = 1;\\n    for(let x of con[i]){\\n        if(!v[x]) dfs(x,con,v)\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar makeConnected = function(n, connections) {\\n    let edges = connections.length;\\n    if(edges < n-1) return -1;\\n    let g = [];\\n    for(let i=0;i<n;i++) g[i] = []\\n    for(let i=0;i<edges;i++){\\n        g[connections[i][0]].push(connections[i][1]);\\n        g[connections[i][1]].push(connections[i][0]);\\n    } \\n    let v = Array(n).fill(0),c=0;\\n    for(let i=0;i<n;i++){\\n        if(!v[i]){\\n            c++;\\n            dfs(i,g,v)\\n        }\\n    }\\n    return c-1;\\n};\\nfunction dfs(i,con,v){\\n    v[i] = 1;\\n    for(let x of con[i]){\\n        if(!v[x]) dfs(x,con,v)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1136374,
                "title": "javascript-union-find",
                "content": "```\\nvar makeConnected = function(n, connections) {  // n nodes, 0 to n-1\\n  let parents = [...Array(n).keys()];           // initially all nodes point to self, ie [0, 1, 2, ...]\\n  let connected = n;                            // initially all nodes are unconnected\\n  let redundant = 0;\\n\\n  function find(id) {\\n    if(parents[id] !== id) \\n      parents[id] = find(parents[id]); // compress \\n    return parents[id];\\n  }\\n  \\n  function union(a, b) {\\n    let [rootA, rootB] = [find(a), find(b)];\\n    if(rootA !== rootB) {\\n      parents[rootB] = rootA;\\n      connected--;\\n    } else { // already connected, ie redundant\\n      redundant++;\\n    }\\n  }\\n    \\n  connections.forEach(con => union(...con));\\n  return (redundant >= connected - 1) ? connected - 1 : -1;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Union Find"
                ],
                "code": "```\\nvar makeConnected = function(n, connections) {  // n nodes, 0 to n-1\\n  let parents = [...Array(n).keys()];           // initially all nodes point to self, ie [0, 1, 2, ...]\\n  let connected = n;                            // initially all nodes are unconnected\\n  let redundant = 0;\\n\\n  function find(id) {\\n    if(parents[id] !== id) \\n      parents[id] = find(parents[id]); // compress \\n    return parents[id];\\n  }\\n  \\n  function union(a, b) {\\n    let [rootA, rootB] = [find(a), find(b)];\\n    if(rootA !== rootB) {\\n      parents[rootB] = rootA;\\n      connected--;\\n    } else { // already connected, ie redundant\\n      redundant++;\\n    }\\n  }\\n    \\n  connections.forEach(con => union(...con));\\n  return (redundant >= connected - 1) ? connected - 1 : -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1121458,
                "title": "swift-easy-to-understand-beats-100-o-m-n",
                "content": "```\\nfunc makeConnected(_ n: Int, _ connections: [[Int]]) -> Int {\\n        // To connect all nodes need at least n-1 edges\\n        if (connections.count < n - 1) {return -1}\\n        var graph = Array(repeating:[Int](), count:n) \\n        for connection in connections {\\n            graph[connection[0]].append(connection[1])\\n            graph[connection[1]].append(connection[0])\\n        }\\n        var components = 0\\n        var visited = Set<Int>()\\n        for i in 0..<n {\\n            if(visited.insert(i).inserted) {\\n                dfsHelper(i, graph,&visited)\\n                components += 1\\n            }\\n        }\\n        // Need (components-1) cables to connect components together\\n        return components - 1\\n        \\n    }\\n    \\n    \\n    func dfsHelper(_ node:Int, _ graph:[[Int]], _ visited:inout Set<Int>) {\\n        for neighbor in graph[node] {\\n            if(visited.insert(neighbor).inserted) {\\n                dfsHelper(neighbor, graph,&visited)\\n            }\\n        }\\n    }\\n",
                "solutionTags": [
                    "Swift",
                    "Depth-First Search"
                ],
                "code": "```\\nfunc makeConnected(_ n: Int, _ connections: [[Int]]) -> Int {\\n        // To connect all nodes need at least n-1 edges\\n        if (connections.count < n - 1) {return -1}\\n        var graph = Array(repeating:[Int](), count:n) \\n        for connection in connections {\\n            graph[connection[0]].append(connection[1])\\n            graph[connection[1]].append(connection[0])\\n        }\\n        var components = 0\\n        var visited = Set<Int>()\\n        for i in 0..<n {\\n            if(visited.insert(i).inserted) {\\n                dfsHelper(i, graph,&visited)\\n                components += 1\\n            }\\n        }\\n        // Need (components-1) cables to connect components together\\n        return components - 1\\n        \\n    }\\n    \\n    \\n    func dfsHelper(_ node:Int, _ graph:[[Int]], _ visited:inout Set<Int>) {\\n        for neighbor in graph[node] {\\n            if(visited.insert(neighbor).inserted) {\\n                dfsHelper(neighbor, graph,&visited)\\n            }\\n        }\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1118343,
                "title": "c-brief-union-find-faster-than-89-63",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> prnt,sz;\\n    int extra=0;\\n    int find(int ch)\\n    { \\n        int t=ch;\\n        while(prnt[ch]!=ch)ch=prnt[ch];\\n        \\n        prnt[t]=ch;\\n        return ch;    \\n    }\\n    void merge(int i,int j)\\n    {\\n        int Pi=find(i),Pj=find(j);\\n            if(Pi!=Pj)\\n                {\\n                    if(sz[Pi]>sz[Pj])\\n                    {\\n                        prnt[Pj]=Pi;\\n                        sz[Pi]+=sz[Pj];\\n                    }\\n                    else\\n                    {\\n                        prnt[Pi]=Pj;\\n                        sz[Pj]+=sz[Pi];\\n                    }\\n                }\\n            else extra++;                \\n    }\\n    int makeConnected(int n, vector<vector<int>>& con) {\\n        int sets=0;\\n        prnt.resize(n);sz.resize(n,1);\\n        for(int i=0;i<n;++i) prnt[i]=i;\\n        \\n        for(auto v: con)\\n            merge(v[0],v[1]);\\n        \\n        for(int i=0;i<n;i++) \\n            if(prnt[i]==i) sets++;\\n        \\n        sets--;\\n        return sets>extra?-1:sets;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> prnt,sz;\\n    int extra=0;\\n    int find(int ch)\\n    { \\n        int t=ch;\\n        while(prnt[ch]!=ch)ch=prnt[ch];\\n        \\n        prnt[t]=ch;\\n        return ch;    \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1068324,
                "title": "c-simple-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& adj, int i, vector<bool>& visited) {\\n        visited[i]= true;       \\n        for(auto j : adj[i])\\n          if(!visited[j]) dfs(adj, j, visited);        \\n    }\\n    \\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        if(n>connections.size()+1) return -1;\\n        vector<vector<int>>adj(n);\\n        vector<bool>visited(n, false);\\n        int comp=0;\\n        \\n        for(auto connection:connections) {\\n            adj[connection[0]].push_back(connection[1]);\\n            adj[connection[1]].push_back(connection[0]);\\n        }\\n        \\n        for(int i=0; i<n; i++)\\n            if(visited[i]==false) {\\n                comp++;\\n                dfs(adj, i, visited);\\n            }\\n        return comp-1;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "class Solution {\\npublic:\\n    void dfs(vector<vector<int>>& adj, int i, vector<bool>& visited) {\\n        visited[i]= true;       \\n        for(auto j : adj[i])\\n          if(!visited[j]) dfs(adj, j, visited);        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1066048,
                "title": "python-bfs-w-comment",
                "content": "```py\\n\\'\\'\\'\\nw: graph, connected component --> BFS\\nh: Union-Find may be the straightforward method, but we can also use\\n    BFS to connect the node:\\n    1) for each node, we find the connected nodes, if the node\\n        was seen, we continue\\n    2) we record the number of components and the size of each component\\n    3) the minimum number of operation is \\n        Total number of nodes - total number of nodes are connected + \\n        total number of component - 1\\n\\'\\'\\'\\nimport collections\\nclass Solution:\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        # if the connections are less than n-1\\n        # it is impossible to connect all the computers\\n        if len(connections) < n-1:\\n            return -1\\n        \\n        graph = collections.defaultdict(set)\\n        for n1, n2 in connections:\\n            graph[n1].add(n2)\\n            graph[n2].add(n1)\\n            \\n        component = 0 # record how many component we have\\n        seen = set()\\n        cnt = {}\\n        \\n        for node in graph:\\n            if node not in seen:\\n                component += 1\\n            else:\\n                continue\\n            queue = [node]\\n            seen.add(node)\\n            for i in queue:\\n                for nei in graph[i]:\\n                    if nei not in seen:\\n                        queue.append(nei)\\n                        seen.add(nei)\\n            cnt[node] = len(queue) # this is the size of the connected component\\n\\n        return n - sum(cnt.values()) + component - 1\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```py\\n\\'\\'\\'\\nw: graph, connected component --> BFS\\nh: Union-Find may be the straightforward method, but we can also use\\n    BFS to connect the node:\\n    1) for each node, we find the connected nodes, if the node\\n        was seen, we continue\\n    2) we record the number of components and the size of each component\\n    3) the minimum number of operation is \\n        Total number of nodes - total number of nodes are connected + \\n        total number of component - 1\\n\\'\\'\\'\\nimport collections\\nclass Solution:\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        # if the connections are less than n-1\\n        # it is impossible to connect all the computers\\n        if len(connections) < n-1:\\n            return -1\\n        \\n        graph = collections.defaultdict(set)\\n        for n1, n2 in connections:\\n            graph[n1].add(n2)\\n            graph[n2].add(n1)\\n            \\n        component = 0 # record how many component we have\\n        seen = set()\\n        cnt = {}\\n        \\n        for node in graph:\\n            if node not in seen:\\n                component += 1\\n            else:\\n                continue\\n            queue = [node]\\n            seen.add(node)\\n            for i in queue:\\n                for nei in graph[i]:\\n                    if nei not in seen:\\n                        queue.append(nei)\\n                        seen.add(nei)\\n            cnt[node] = len(queue) # this is the size of the connected component\\n\\n        return n - sum(cnt.values()) + component - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1018000,
                "title": "java-simple-and-easy-explanation-3ms",
                "content": "We know that minimum number of cable required to conect all **n** computer is **n-1** *(spanning tree)*\\n\\n1. if total available cable is less than **n-1** then it is impossible to connect all computers so, simply retruen **-1**\\n\\n2. now using **union find** obtain the total number of connected compontent form given connection.\\nsay there is **m** comnneted component, then we need to rearrange minimun **m-1** wires in order to make all computers connected.  so return **m-1**.\\n```\\n\\nclass Solution {\\n    public int makeConnected(int n, int[][] connections) {\\n\\t\\tif (connections.length < n - 1)\\n\\t\\t\\treturn -1;\\n\\n\\t\\tint[] parent = new int[n];\\n\\t\\tint[] size = new int[n];\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tparent[i] = i;\\n\\t\\t\\tsize[i] = 1;\\n\\t\\t}\\n\\n\\t\\tint m = n, ap, bp;\\n\\t\\tfor (int[] t : connections) {\\n\\t\\t\\tap = getParent(t[0], parent);\\n\\t\\t\\tbp = getParent(t[1], parent);\\n\\t\\t\\t\\n\\t\\t\\t//if they a and b are not already connected then simply connect them and mark them as connected component\\n\\t\\t\\tif (ap != bp) {\\n\\t\\t\\t\\tunion(t[0], t[1], size, parent);\\n\\t\\t\\t\\tm--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn m - 1;\\n\\t}\\n\\n    private int getParent(int i, int[] parent) {\\n\\t\\tif (parent[i] != i) {\\n\\t\\t\\tparent[i] = getParent(parent[i], parent);\\n\\t\\t}\\n\\t\\treturn parent[i];\\n\\t}\\n\\n\\tprivate void union(int a, int b, int[] size, int[] parent) {\\n\\t\\tint ap = getParent(a, parent);\\n\\t\\tint bp = getParent(b, parent);\\n\\t\\tif (size[ap] >= size[bp]) {\\n\\t\\t\\tparent[bp] = ap;\\n            size[ap] += size[bp];\\n\\t\\t} else{\\n\\t\\t\\tparent[ap] = bp;\\n            size[bp] += size[ap]; \\n        }\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int makeConnected(int n, int[][] connections) {\\n\\t\\tif (connections.length < n - 1)\\n\\t\\t\\treturn -1;\\n\\n\\t\\tint[] parent = new int[n];\\n\\t\\tint[] size = new int[n];\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tparent[i] = i;\\n\\t\\t\\tsize[i] = 1;\\n\\t\\t}\\n\\n\\t\\tint m = n, ap, bp;\\n\\t\\tfor (int[] t : connections) {\\n\\t\\t\\tap = getParent(t[0], parent);\\n\\t\\t\\tbp = getParent(t[1], parent);\\n\\t\\t\\t\\n\\t\\t\\t//if they a and b are not already connected then simply connect them and mark them as connected component\\n\\t\\t\\tif (ap != bp) {\\n\\t\\t\\t\\tunion(t[0], t[1], size, parent);\\n\\t\\t\\t\\tm--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn m - 1;\\n\\t}\\n\\n    private int getParent(int i, int[] parent) {\\n\\t\\tif (parent[i] != i) {\\n\\t\\t\\tparent[i] = getParent(parent[i], parent);\\n\\t\\t}\\n\\t\\treturn parent[i];\\n\\t}\\n\\n\\tprivate void union(int a, int b, int[] size, int[] parent) {\\n\\t\\tint ap = getParent(a, parent);\\n\\t\\tint bp = getParent(b, parent);\\n\\t\\tif (size[ap] >= size[bp]) {\\n\\t\\t\\tparent[bp] = ap;\\n            size[ap] += size[bp];\\n\\t\\t} else{\\n\\t\\t\\tparent[ap] = bp;\\n            size[bp] += size[ap]; \\n        }\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 979126,
                "title": "java-o-v-e-dfs-find-connected-components",
                "content": "**Upvote if you like this solution.**\\n\\n```\\n\\tboolean[] visited;\\n    List<Integer>[] adj;\\n\\n    int components = 0;\\n    int edges = 0;\\n    int size = 0;\\n\\n    public int makeConnected(int n, int[][] connections) {\\n        adj = new List[n];\\n        visited = new boolean[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            adj[i] = new ArrayList<>();\\n\\n        }\\n        for (int[] edge : connections) {\\n            adj[edge[0]].add(edge[1]);\\n            adj[edge[1]].add(edge[0]);\\n        }\\n        int redundantEdges = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (!visited[i]) {\\n                dfs(i);\\n                edges = edges / 2;\\n                if (edges > size - 1)\\n                    redundantEdges += edges - (size - 1);\\n\\n                components++;\\n                size = 0;\\n                edges = 0;\\n            }\\n        }\\n        return redundantEdges >= (components - 1) ? components - 1 : -1;\\n    }\\n\\n    private void dfs(int i) {\\n        size++;\\n        visited[i] = true;\\n\\n        for (int v : adj[i]) {\\n            edges++;\\n            if (!visited[v]) {\\n                dfs(v);\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "**Upvote if you like this solution.**\\n\\n```\\n\\tboolean[] visited;\\n    List<Integer>[] adj;\\n\\n    int components = 0;\\n    int edges = 0;\\n    int size = 0;\\n\\n    public int makeConnected(int n, int[][] connections) {\\n        adj = new List[n];\\n        visited = new boolean[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            adj[i] = new ArrayList<>();\\n\\n        }\\n        for (int[] edge : connections) {\\n            adj[edge[0]].add(edge[1]);\\n            adj[edge[1]].add(edge[0]);\\n        }\\n        int redundantEdges = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (!visited[i]) {\\n                dfs(i);\\n                edges = edges / 2;\\n                if (edges > size - 1)\\n                    redundantEdges += edges - (size - 1);\\n\\n                components++;\\n                size = 0;\\n                edges = 0;\\n            }\\n        }\\n        return redundantEdges >= (components - 1) ? components - 1 : -1;\\n    }\\n\\n    private void dfs(int i) {\\n        size++;\\n        visited[i] = true;\\n\\n        for (int v : adj[i]) {\\n            edges++;\\n            if (!visited[v]) {\\n                dfs(v);\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 959645,
                "title": "c-easy-to-understand-dfs-solution",
                "content": "Minimum number of edges required to connect n nodes is n-1. Therefore if there are k nodes unconnected then k-1 edges are required. \\n\\nWe first make the adjacency list and then use DFS to visit all the node that are connected.\\n\\n```\\nclass Solution {\\npublic:\\n    void dfs( vector<vector<int>>& adj, vector<bool> &visited, int start){\\n        visited[start] = true;\\n        for(int i : adj[start])\\n        {\\n            if(!visited[i])\\n                dfs(adj, visited, i);\\n        }\\n    }\\n    \\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        if(connections.size() < n-1)\\n            return -1;\\n        vector<vector<int>> adj(n);\\n        for(auto x : connections)\\n        {\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        vector<bool> visited(n, false);\\n        int result = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(!visited[i])\\n            {\\n                dfs(adj,visited,i);\\n                result++;\\n            }\\n        }\\n        return result-1;\\n    }\\n};\\n```\\n\\nPlease upvote my post if you like my solution.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs( vector<vector<int>>& adj, vector<bool> &visited, int start){\\n        visited[start] = true;\\n        for(int i : adj[start])\\n        {\\n            if(!visited[i])\\n                dfs(adj, visited, i);\\n        }\\n    }\\n    \\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        if(connections.size() < n-1)\\n            return -1;\\n        vector<vector<int>> adj(n);\\n        for(auto x : connections)\\n        {\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        vector<bool> visited(n, false);\\n        int result = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(!visited[i])\\n            {\\n                dfs(adj,visited,i);\\n                result++;\\n            }\\n        }\\n        return result-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 939157,
                "title": "c-union-find-96-faster-union-find-template",
                "content": "```\\nclass Solution {\\n    class UnionFind{\\n        int num;\\n        int numComponents;\\n        vector<int> rank;\\n        vector<int> parent;\\n        public:\\n        UnionFind(int n){\\n            num = n; numComponents = n;\\n            rank = vector<int>(n, 0);\\n            parent = vector<int>(n);\\n            for(int i = 0; i<n; i++) parent[i] = i;\\n        }\\n        \\n        int size(){return num;}\\n        \\n        int components(){return numComponents;}\\n        \\n        int find(int p){\\n            while(p != parent[p]){\\n                parent[p] = parent[parent[p]];\\n                p = parent[p];\\n            }\\n            return p;\\n        }\\n        \\n        void unionn(int p, int q){\\n            int rootp = find(p); int rootq = find(q);\\n            if(rootp == rootq) return;\\n            if(rank[rootp] < rank[rootq]) parent[rootp] = rootq;\\n            else{\\n                parent[rootq] = rootp;\\n                if(rank[rootp] == rank[rootq]){rank[rootp]++;}\\n            }\\n            numComponents--;\\n        }\\n        \\n        int connected(int p, int q){\\n            return find(p) == find(q);\\n        }\\n        \\n    };\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        int redundant = 0, required = 0;\\n        UnionFind uf(n);\\n        for(int i = 0; i<connections.size(); i++){\\n            if(uf.find(connections[i][0]) == uf.find(connections[i][1])) redundant++;\\n            else uf.unionn(connections[i][0], connections[i][1]);\\n        }\\n        \\n        return uf.components()-1 <= redundant ? uf.components()-1 : -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    class UnionFind{\\n        int num;\\n        int numComponents;\\n        vector<int> rank;\\n        vector<int> parent;\\n        public:\\n        UnionFind(int n){\\n            num = n; numComponents = n;\\n            rank = vector<int>(n, 0);\\n            parent = vector<int>(n);\\n            for(int i = 0; i<n; i++) parent[i] = i;\\n        }\\n        \\n        int size(){return num;}\\n        \\n        int components(){return numComponents;}\\n        \\n        int find(int p){\\n            while(p != parent[p]){\\n                parent[p] = parent[parent[p]];\\n                p = parent[p];\\n            }\\n            return p;\\n        }\\n        \\n        void unionn(int p, int q){\\n            int rootp = find(p); int rootq = find(q);\\n            if(rootp == rootq) return;\\n            if(rank[rootp] < rank[rootq]) parent[rootp] = rootq;\\n            else{\\n                parent[rootq] = rootp;\\n                if(rank[rootp] == rank[rootq]){rank[rootp]++;}\\n            }\\n            numComponents--;\\n        }\\n        \\n        int connected(int p, int q){\\n            return find(p) == find(q);\\n        }\\n        \\n    };\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        int redundant = 0, required = 0;\\n        UnionFind uf(n);\\n        for(int i = 0; i<connections.size(); i++){\\n            if(uf.find(connections[i][0]) == uf.find(connections[i][1])) redundant++;\\n            else uf.unionn(connections[i][0], connections[i][1]);\\n        }\\n        \\n        return uf.components()-1 <= redundant ? uf.components()-1 : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 863402,
                "title": "cpp-union-path-greedy",
                "content": "class Solution {\\npublic:\\n    int find(vector<int>&parent,int x){\\n        if(x!=parent[x])\\n            parent[x]=find(parent,parent[x]);\\n        return parent[x];\\n    }\\n    void unionpath(int a,int b,vector<int>&parent,vector<int>&rank){\\n        int xx=find(parent,a);\\n        int yy=find(parent,b);\\n        if(rank[xx]<rank[yy])\\n            parent[xx]=yy;\\n        else if(rank[yy]<rank[xx])\\n            parent[yy]=xx;\\n        else{\\n            parent[xx]=yy;\\n            rank[xx]++;\\n        }\\n    }\\n    int makeConnected(int n, vector<vector<int>>& con) {\\n        int i;\\n        int mm=con.size();\\n        \\n        vector<int>parent(n);\\n        vector<int>rank(n);\\n        for(i=0;i<n;i++)\\n            parent[i]=i,rank[i]=0;\\n        for(i=0;i<mm;i++){\\n            unionpath(con[i][0],con[i][1],parent,rank);\\n        }\\n        map<int,int>m;\\n        for(i=0;i<n;i++)\\n            m[find(parent,parent[i])]++;\\n        //mm total cables;\\n        int val=m.size()-1;//unique values except main root;\\n        cout<<val;\\n        map<int,int>::iterator it;\\n        int one=0;\\n        int maxi=0;\\n        for(it=m.begin();it!=m.end();it++){\\n            maxi=max(maxi,(*it).second);\\n        }\\n        mm=mm-maxi+1;//avaliable cables\\n        if(val<=mm)\\n            return val;\\n        else\\n        return -1;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int find(vector<int>&parent,int x){\\n        if(x!=parent[x])\\n            parent[x]=find(parent,parent[x]);\\n        return parent[x];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 830833,
                "title": "c-simple-solution-using-no-of-islands-logic",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(int i,vector<bool>&ans,vector<vector<int>>&out){\\n        if(ans[i]==1){\\n            return;\\n        }\\n        ans[i]=1;\\n        for(int j=0;j<out[i].size();j++){\\n            dfs(out[i][j],ans,out);\\n        }\\n    }\\n    int makeConnected(int n, vector<vector<int>>& c) {\\n        vector<vector<int>>out(n);\\n        vector<bool>ans(n,0);\\n        for(int i=0;i<c.size();i++){\\n            out[c[i][0]].push_back(c[i][1]);\\n            out[c[i][1]].push_back(c[i][0]);\\n        }\\n        int res=0;\\n        for(int i=0;i<n;i++){\\n            if(ans[i]==0){\\n                res++;\\n                dfs(i,ans,out);\\n            }\\n        }\\n        if(c.size()>=n-1){\\n            return res-1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int i,vector<bool>&ans,vector<vector<int>>&out){\\n        if(ans[i]==1){\\n            return;\\n        }\\n        ans[i]=1;\\n        for(int j=0;j<out[i].size();j++){\\n            dfs(out[i][j],ans,out);\\n        }\\n    }\\n    int makeConnected(int n, vector<vector<int>>& c) {\\n        vector<vector<int>>out(n);\\n        vector<bool>ans(n,0);\\n        for(int i=0;i<c.size();i++){\\n            out[c[i][0]].push_back(c[i][1]);\\n            out[c[i][1]].push_back(c[i][0]);\\n        }\\n        int res=0;\\n        for(int i=0;i<n;i++){\\n            if(ans[i]==0){\\n                res++;\\n                dfs(i,ans,out);\\n            }\\n        }\\n        if(c.size()>=n-1){\\n            return res-1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 707560,
                "title": "python-3-dfs-recursion-easy-to-read-solution",
                "content": "```\\nclass Solution:\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        def dfs(node):\\n            nonlocal totalFound\\n            if node not in visited:\\n                visited.add(node)\\n                for i in graph[node]:\\n                    dfs(i)\\n        if len(connections) < n - 1:\\n            return -1\\n        graph = defaultdict(list)\\n        for u , v in connections:\\n            graph[u].append(v)\\n            graph[v].append(u)            \\n        totalFound = 0\\n        visited = set()\\n        for i in range(n):\\n            if i not in visited:\\n                totalFound += 1\\n                dfs(i)\\n        return totalFound - 1\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        def dfs(node):\\n            nonlocal totalFound\\n            if node not in visited:\\n                visited.add(node)\\n                for i in graph[node]:\\n                    dfs(i)\\n        if len(connections) < n - 1:\\n            return -1\\n        graph = defaultdict(list)\\n        for u , v in connections:\\n            graph[u].append(v)\\n            graph[v].append(u)            \\n        totalFound = 0\\n        visited = set()\\n        for i in range(n):\\n            if i not in visited:\\n                totalFound += 1\\n                dfs(i)\\n        return totalFound - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 702395,
                "title": "c-solution-using-dfs-detailed-explanation-with-comments",
                "content": "```\\n//use dfs\\n//adjacency_list\\n//to connect n nodes you need to have n-1 edges\\n// if you have number of edges > number of connected components\\n// if yes then no of connected components is the answer\\n\\nstruct adjacency_list\\n{\\n    int key;\\n    struct adjacency_list *next;\\n};\\n\\nstruct adjacency_list *new_node(struct adjacency_list *node, int key)\\n{\\n    struct adjacency_list *temp = malloc(sizeof(struct adjacency_list));\\n    temp->key = key;\\n    temp->next = node;\\n    return temp;\\n}\\n\\nvoid make_adjacency_list(struct adjacency_list *adjacency_list[], int n, int **connections, int connectionsSize)\\n{\\n    for (int i = 0; i < n; i++)\\n    {\\n        adjacency_list[i] = NULL;\\n    }\\n    for (int i = 0; i < connectionsSize; i++)\\n    {\\n         adjacency_list[connections[i][0]] = new_node(adjacency_list[connections[i][0]], connections[i][1]);\\n        adjacency_list[connections[i][1]] = new_node(adjacency_list[connections[i][1]], connections[i][0]);\\n        \\n    }\\n}\\n\\n\\n//number of nodes is n\\n//this implies that minimum number of edges to connect every node will be n-1\\n//counted the number of edges using dfs\\n// edges_count is incremented every time a new node is pushed into the stack\\n//stack is implicit in this case because I am using recursive DFS is used instead of iterative where actual stack is used\\n\\nvoid DFS(int i, struct adjacency_list *adjacency_list[], int n, bool visited[])\\n{\\n    if (visited[i])\\n    {\\n        return;\\n    }\\n    visited[i] = true;\\n    struct adjacency_list *temp ;\\n    temp = adjacency_list[i];\\n    while (temp)\\n    {\\n        if (!visited[temp->key])\\n        {\\n            DFS(temp->key, adjacency_list, n, visited);\\n        }\\n        temp = temp->next;\\n    }\\n}\\n\\nint makeConnected(int n, int **connections, int connectionsSize, int *connectionsColSize)\\n{\\n    struct adjacency_list *adjacency_list[n];\\n    make_adjacency_list(adjacency_list, n, connections, connectionsSize);\\n    \\n\\n    //Initialising visited to false because initially no node is visited\\n    bool visited[n];\\n    for (int i = 0; i < n; i++)\\n    {\\n        visited[i] = false;\\n    }\\n    //  printf(\"Edges count : %d\\\\n\")\\n    //each DFS will visit all the nodes connected to the source vertex hence number of dfs calls is the number of connected components\\n    int connected_comps = 0;\\n    for (int i = 0; i < n; i++)\\n    {\\n        if (!visited[i])\\n        {\\n            connected_comps++;\\n\\n            DFS(i, adjacency_list, n, visited);\\n        }\\n    }\\n    //no of edges is less than minimum no of edges required implies connecting every node is impossible\\n    // the number of elements in connections is the number of edges in the graph \\n    if (connectionsSize < n - 1)\\n    {\\n        return -1;\\n    }\\n    \\n    //if connectionSize is > n-1 then it means there are enough edges\\n    //if there are \\'n\\' connected components then we have to shift n-1 connected components to connect them all\\n    return connected_comps - 1;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n//use dfs\\n//adjacency_list\\n//to connect n nodes you need to have n-1 edges\\n// if you have number of edges > number of connected components\\n// if yes then no of connected components is the answer\\n\\nstruct adjacency_list\\n{\\n    int key;\\n    struct adjacency_list *next;\\n};\\n\\nstruct adjacency_list *new_node(struct adjacency_list *node, int key)\\n{\\n    struct adjacency_list *temp = malloc(sizeof(struct adjacency_list));\\n    temp->key = key;\\n    temp->next = node;\\n    return temp;\\n}\\n\\nvoid make_adjacency_list(struct adjacency_list *adjacency_list[], int n, int **connections, int connectionsSize)\\n{\\n    for (int i = 0; i < n; i++)\\n    {\\n        adjacency_list[i] = NULL;\\n    }\\n    for (int i = 0; i < connectionsSize; i++)\\n    {\\n         adjacency_list[connections[i][0]] = new_node(adjacency_list[connections[i][0]], connections[i][1]);\\n        adjacency_list[connections[i][1]] = new_node(adjacency_list[connections[i][1]], connections[i][0]);\\n        \\n    }\\n}\\n\\n\\n//number of nodes is n\\n//this implies that minimum number of edges to connect every node will be n-1\\n//counted the number of edges using dfs\\n// edges_count is incremented every time a new node is pushed into the stack\\n//stack is implicit in this case because I am using recursive DFS is used instead of iterative where actual stack is used\\n\\nvoid DFS(int i, struct adjacency_list *adjacency_list[], int n, bool visited[])\\n{\\n    if (visited[i])\\n    {\\n        return;\\n    }\\n    visited[i] = true;\\n    struct adjacency_list *temp ;\\n    temp = adjacency_list[i];\\n    while (temp)\\n    {\\n        if (!visited[temp->key])\\n        {\\n            DFS(temp->key, adjacency_list, n, visited);\\n        }\\n        temp = temp->next;\\n    }\\n}\\n\\nint makeConnected(int n, int **connections, int connectionsSize, int *connectionsColSize)\\n{\\n    struct adjacency_list *adjacency_list[n];\\n    make_adjacency_list(adjacency_list, n, connections, connectionsSize);\\n    \\n\\n    //Initialising visited to false because initially no node is visited\\n    bool visited[n];\\n    for (int i = 0; i < n; i++)\\n    {\\n        visited[i] = false;\\n    }\\n    //  printf(\"Edges count : %d\\\\n\")\\n    //each DFS will visit all the nodes connected to the source vertex hence number of dfs calls is the number of connected components\\n    int connected_comps = 0;\\n    for (int i = 0; i < n; i++)\\n    {\\n        if (!visited[i])\\n        {\\n            connected_comps++;\\n\\n            DFS(i, adjacency_list, n, visited);\\n        }\\n    }\\n    //no of edges is less than minimum no of edges required implies connecting every node is impossible\\n    // the number of elements in connections is the number of edges in the graph \\n    if (connectionsSize < n - 1)\\n    {\\n        return -1;\\n    }\\n    \\n    //if connectionSize is > n-1 then it means there are enough edges\\n    //if there are \\'n\\' connected components then we have to shift n-1 connected components to connect them all\\n    return connected_comps - 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 483447,
                "title": "similar-to-leetcode-323-number-of-connected-components-in-an-undirected-graph",
                "content": "```\\n\\t\\t## APPROACH : GRAPH / DFS ##\\n        ## SIMILAR TO LEETCODE :: 323. Number of Connected Components in an Undirected Graph ##\\n        \\n        if(len(connections) < n-1) : return -1\\n        graph = collections.defaultdict(list)\\n        for x, y in connections:\\n            graph[x].append(y)\\n            graph[y].append(x)\\n        \\n        def dfs(node, visited):\\n            \\n            visited.add(node)\\n            \\n            for neighbor in graph[node]:\\n                if neighbor not in visited:\\n                    dfs(neighbor, visited)\\n        \\n        count = 0\\n        visited = set()\\n        for node in range(n):\\n            if node not in visited:\\n                dfs(node, visited)\\n                count += 1\\n        return count - 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\t\\t## APPROACH : GRAPH / DFS ##\\n        ## SIMILAR TO LEETCODE :: 323. Number of Connected Components in an Undirected Graph ##\\n        \\n        if(len(connections) < n-1) : return -1\\n        graph = collections.defaultdict(list)\\n        for x, y in connections:\\n            graph[x].append(y)\\n            graph[y].append(x)\\n        \\n        def dfs(node, visited):\\n            \\n            visited.add(node)\\n            \\n            for neighbor in graph[node]:\\n                if neighbor not in visited:\\n                    dfs(neighbor, visited)\\n        \\n        count = 0\\n        visited = set()\\n        for node in range(n):\\n            if node not in visited:\\n                dfs(node, visited)\\n                count += 1\\n        return count - 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 480797,
                "title": "c-union-find-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        if (connections.size() < n - 1) { return -1; }\\n        vector<int> uf;\\n        for (int i = 0; i < n; i++) {\\n            uf.push_back(i);\\n        }\\n        int components = n;\\n        for (const vector<int>& pair: connections){\\n            int root0 = findRoot(pair[0], uf);\\n            int root1 = findRoot(pair[1], uf);\\n            if (root0 != root1) {\\n                components--;\\n                uf[root0] = root1;\\n            }\\n        }\\n        return components - 1;\\n    }\\n       \\nprivate:\\n    int findRoot(int i, vector<int>& uf) {\\n        while (i != uf[i]) {\\n            uf[i] = uf[uf[i]]; //flatten the tree to accelerate search, can be omitted if hard to understand\\n            i = uf[i];\\n        }\\n        return i;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        if (connections.size() < n - 1) { return -1; }",
                "codeTag": "Java"
            },
            {
                "id": 478699,
                "title": "python-bfs-dfs-count-connected-components",
                "content": "Problem reduces to number of connected components in undirected graph\\n\\n#### DFS\\n\\n```\\nimport collections\\nclass Solution:\\n    def dfs(self,node):\\n        for neighbor in self.graph[node]:\\n            if neighbor not in self.seen:\\n                self.seen.add(neighbor)\\n                self.dfs(neighbor)\\n\\n\\n    def makeConnected(self, n, connections):\\n        num_cables=len(connections)\\n        if num_cables<n-1:\\n            return -1\\n        self.graph = collections.defaultdict(list)\\n        for i, j in connections:\\n            self.graph[i].append(j)\\n            self.graph[j].append(i)\\n        num_connected_components=0\\n        self.seen=set()\\n        for node in range(n):\\n            if node not in self.seen:\\n                num_connected_components=num_connected_components+1\\n                self.seen.add(node)\\n                self.dfs(node)\\n        return num_connected_components-1\\n```\\n\\n#### BFS\\n\\n```\\nimport collections\\nclass Solution:\\n    def bfs(self,node):\\n        queue=collections.deque()\\n        queue.append(node)\\n        while(queue):\\n            _node_=queue.popleft()\\n            for neighbor in self.graph[_node_]:\\n                if neighbor not in self.seen:\\n                    queue.append(neighbor)\\n                    self.seen.add(neighbor)\\n\\n\\n    def makeConnected(self, n, connections):\\n        num_cables=len(connections)\\n        if num_cables<n-1:\\n            return -1\\n        self.graph = collections.defaultdict(list)\\n        for i, j in connections:\\n            self.graph[i].append(j)\\n            self.graph[j].append(i)\\n        num_connected_components=0\\n        self.seen=set()\\n        for node in range(n):\\n            if node not in self.seen:\\n                num_connected_components=num_connected_components+1\\n                self.seen.add(node)\\n                self.bfs(node)\\n        return num_connected_components-1\\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\nclass Solution:\\n    def dfs(self,node):\\n        for neighbor in self.graph[node]:\\n            if neighbor not in self.seen:\\n                self.seen.add(neighbor)\\n                self.dfs(neighbor)\\n\\n\\n    def makeConnected(self, n, connections):\\n        num_cables=len(connections)\\n        if num_cables<n-1:\\n            return -1\\n        self.graph = collections.defaultdict(list)\\n        for i, j in connections:\\n            self.graph[i].append(j)\\n            self.graph[j].append(i)\\n        num_connected_components=0\\n        self.seen=set()\\n        for node in range(n):\\n            if node not in self.seen:\\n                num_connected_components=num_connected_components+1\\n                self.seen.add(node)\\n                self.dfs(node)\\n        return num_connected_components-1\\n```\n```\\nimport collections\\nclass Solution:\\n    def bfs(self,node):\\n        queue=collections.deque()\\n        queue.append(node)\\n        while(queue):\\n            _node_=queue.popleft()\\n            for neighbor in self.graph[_node_]:\\n                if neighbor not in self.seen:\\n                    queue.append(neighbor)\\n                    self.seen.add(neighbor)\\n\\n\\n    def makeConnected(self, n, connections):\\n        num_cables=len(connections)\\n        if num_cables<n-1:\\n            return -1\\n        self.graph = collections.defaultdict(list)\\n        for i, j in connections:\\n            self.graph[i].append(j)\\n            self.graph[j].append(i)\\n        num_connected_components=0\\n        self.seen=set()\\n        for node in range(n):\\n            if node not in self.seen:\\n                num_connected_components=num_connected_components+1\\n                self.seen.add(node)\\n                self.bfs(node)\\n        return num_connected_components-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477840,
                "title": "c-solution-union-find",
                "content": "```\\npublic class Solution \\n{\\n    public int MakeConnected(int n, int[][] connections) \\n    {\\n        if(connections.Length < n - 1) return -1;\\n        var uf = new UnionFind<int>();\\n        for(int i = 0; i < n; i++) uf.Union(i, i);\\n        foreach(var con in connections) uf.Union(con[0], con[1]);\\n        return uf.GroupCount() - 1;\\n    }\\n}\\n\\npublic class UnionFind<T>\\n{\\n    private Dictionary<T, T> parentMap;\\n    private int groupCount;\\n    \\n    public UnionFind()\\n    {\\n        groupCount = 0;\\n        parentMap = new Dictionary<T, T>();\\n    }\\n    \\n    public void Union(T item1, T item2)\\n    {\\n        T group1 = Find(item1), group2 = Find(item2);\\n        if(!group1.Equals(group2))\\n        {\\n            parentMap[group1] = group2;\\n            groupCount--;\\n        }\\n    }\\n    \\n    public T Find(T item)\\n    {\\n        if(!parentMap.ContainsKey(item)) \\n        {\\n            groupCount++;\\n            parentMap[item] = item;\\n        }\\n        \\n        if(!parentMap[item].Equals(item)) parentMap[item] = Find(parentMap[item]);\\n        return parentMap[item];\\n    }\\n    \\n    public int GroupCount()\\n    {\\n        return groupCount;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int MakeConnected(int n, int[][] connections) \\n    {\\n        if(connections.Length < n - 1) return -1;\\n        var uf = new UnionFind<int>();\\n        for(int i = 0; i < n; i++) uf.Union(i, i);\\n        foreach(var con in connections) uf.Union(con[0], con[1]);\\n        return uf.GroupCount() - 1;\\n    }\\n}\\n\\npublic class UnionFind<T>\\n{\\n    private Dictionary<T, T> parentMap;\\n    private int groupCount;\\n    \\n    public UnionFind()\\n    {\\n        groupCount = 0;\\n        parentMap = new Dictionary<T, T>();\\n    }\\n    \\n    public void Union(T item1, T item2)\\n    {\\n        T group1 = Find(item1), group2 = Find(item2);\\n        if(!group1.Equals(group2))\\n        {\\n            parentMap[group1] = group2;\\n            groupCount--;\\n        }\\n    }\\n    \\n    public T Find(T item)\\n    {\\n        if(!parentMap.ContainsKey(item)) \\n        {\\n            groupCount++;\\n            parentMap[item] = item;\\n        }\\n        \\n        if(!parentMap[item].Equals(item)) parentMap[item] = Find(parentMap[item]);\\n        return parentMap[item];\\n    }\\n    \\n    public int GroupCount()\\n    {\\n        return groupCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477670,
                "title": "python-union-find-with-explanation",
                "content": "My idea is that when iterating all the connections, keep in record how many lines are actually redundant so that they may be moved elsewhere later to connect yet disjoint clusters of computers.\\n\\nIf two computers are already connected (whether directly or indirectly) before the connection is about to be added between them, then this new connection is not really necessary, so it can be moved and put between another pair of computers at the end, to connect two disjoint clusters of computers and to build one single bigger cluster.\\n\\n`n` computers need at least `n - 1` lines between them to be grouped all together. Suppose at last, there are `m` disjoint clusters (i.e. require at least `m - 1` lines) and `n` redundant lines that we can make use of to connect disjoint clusters. If `n >= m - 1`, that means there are sufficient lines to connect all the clusters; otherwise, there are just not enough lines to connect all the clusters.\\n\\n```python\\nfrom typing import *\\n\\nclass Solution:\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        mapping = {k: k for k in range(n)} # union-find map. At first, computers are all disconnected from each other\\n        redundantConnectionCount = 0 # lines that are redundant\\n\\n        for a, b in connections:\\n            if self.isConnected(mapping, a, b): # if two computers are already connected to each other (whether direct or through other computers), this new line is not really necessary\\n                redundantConnectionCount += 1 # can move this line for future use\\n            else: # if two computers are not connected to each other, then this line must be added between them\\n                self.union(mapping, a, b) # mark these two computers are connected to each other\\n\\n        disjointClusters = set(self.root(mapping, k) for k in mapping.keys()) # after adding all necessary lines, how many disjoint clusters of computers there are\\n        needConnectionCount = len(disjointClusters) - 1 # n disjoint computers need at least n - 1 lines to be grouped into single one cluster\\n        if redundantConnectionCount >= needConnectionCount: # if redundant lines are enough to connect all the remaining disjoint clusters\\n            return needConnectionCount # then need at least n - 1 lines\\n        else: # redundant lines are not sufficient\\n            return -1 # impossible\\n\\n    # following is union-find routines\\n    def isConnected(self, mapping: dict, p: Type, q: Type) -> bool:\\n        return self.root(mapping, p) == self.root(mapping, q)\\n\\n    def root(self, mapping: dict, p: Type) -> Type:\\n\\n        while mapping[p] != p:\\n            mapping[p] = mapping[mapping[p]]\\n            p = mapping[p]\\n\\n        return p\\n\\n    def union(self, mapping: dict, p: Type, q: Type) -> None:\\n        rootOfP = self.root(mapping, p)\\n        rootOfQ = self.root(mapping, q)\\n        mapping[rootOfP] = rootOfQ\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```python\\nfrom typing import *\\n\\nclass Solution:\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        mapping = {k: k for k in range(n)} # union-find map. At first, computers are all disconnected from each other\\n        redundantConnectionCount = 0 # lines that are redundant\\n\\n        for a, b in connections:\\n            if self.isConnected(mapping, a, b): # if two computers are already connected to each other (whether direct or through other computers), this new line is not really necessary\\n                redundantConnectionCount += 1 # can move this line for future use\\n            else: # if two computers are not connected to each other, then this line must be added between them\\n                self.union(mapping, a, b) # mark these two computers are connected to each other\\n\\n        disjointClusters = set(self.root(mapping, k) for k in mapping.keys()) # after adding all necessary lines, how many disjoint clusters of computers there are\\n        needConnectionCount = len(disjointClusters) - 1 # n disjoint computers need at least n - 1 lines to be grouped into single one cluster\\n        if redundantConnectionCount >= needConnectionCount: # if redundant lines are enough to connect all the remaining disjoint clusters\\n            return needConnectionCount # then need at least n - 1 lines\\n        else: # redundant lines are not sufficient\\n            return -1 # impossible\\n\\n    # following is union-find routines\\n    def isConnected(self, mapping: dict, p: Type, q: Type) -> bool:\\n        return self.root(mapping, p) == self.root(mapping, q)\\n\\n    def root(self, mapping: dict, p: Type) -> Type:\\n\\n        while mapping[p] != p:\\n            mapping[p] = mapping[mapping[p]]\\n            p = mapping[p]\\n\\n        return p\\n\\n    def union(self, mapping: dict, p: Type, q: Type) -> None:\\n        rootOfP = self.root(mapping, p)\\n        rootOfQ = self.root(mapping, q)\\n        mapping[rootOfP] = rootOfQ\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049497,
                "title": "simple-solution-with-using-depth-first-search-in-python3",
                "content": "# Intuition\\nThe problem description is the following:\\n- there\\'s an **undirected graph** with `n` nodes and `connections` edges\\n- our goal is to find **the minimum amount of connections we should switch** in order to make all the network **connected**\\n\\n**PS: there\\'re at least two valid solutions.** The first one is **Union-Find** (Prim\\'s or Kruskal Algorithm), but we\\'ll focus on at simplified approach of finding [connected components](https://en.wikipedia.org/wiki/Component_(graph_theory)). \\n\\n```\\n# Example\\nn = 4 # vertices\\nconnections = [[0,1],[0,2],[1,2]] # edges\\n\\n# This can looks like\\n# (0) - (1)\\n#   \\\\   /\\n#    (2)\\n# (3)\\n\\n# The vertice (3) isn\\'t connected with any other vertices.\\n# Connected component represents a chain of edges, where you\\n# can travel from one node to another.\\n# 0-1-2 and 3 are two connected components (vertice 3 we can treat\\n# as a valid one, even if it doesn\\'t have any edges) \\n\\n# The answer is the number of connected components - 1,\\n# because we want to define a number of edges to reconnect\\n\\n```\\n\\n# Approach\\n1. check in advance, if the count of nodes `n - 1 == len(connections)` and return `-1` if it\\'s not.\\n2. create an `adjList`\\n3. initialize an `ans = -1` and set of visited nodes `seen`\\n4. define `dfs` function to treat all of the nodes after the first as a part of **connected component**\\n5. iterate over all count of nodes `n` and count the amount of connected components\\n6. return `ans`\\n\\n# Complexity\\n- Time complexity: **O(n + m)**, to iterate over `connections` and in range of `n`\\n\\n- Space complexity: **O(n + m)**, the same, but for storing vertices and edges in `adjList`\\n\\n# Code\\n```\\nclass Solution:\\n    def makeConnected(self, n: int, connections: list[list[int]]) -> int:\\n        if n - 1 > len(connections):\\n            return -1\\n\\n        adjList = [[] for _ in range(n)]\\n        \\n        for u, v in connections: \\n            adjList[u].append(v)\\n            adjList[v].append(u)\\n        \\n        ans = -1\\n        seen = set()\\n\\n        def dfs(node):\\n            for n in adjList[node]:\\n                if n not in seen:\\n                    seen.add(n)\\n                    dfs(n)\\n\\n        for i in range(n):\\n            if i not in seen:\\n                seen.add(i)\\n                ans += 1\\n                dfs(i)\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\n# Example\\nn = 4 # vertices\\nconnections = [[0,1],[0,2],[1,2]] # edges\\n\\n# This can looks like\\n# (0) - (1)\\n#   \\\\   /\\n#    (2)\\n# (3)\\n\\n# The vertice (3) isn\\'t connected with any other vertices.\\n# Connected component represents a chain of edges, where you\\n# can travel from one node to another.\\n# 0-1-2 and 3 are two connected components (vertice 3 we can treat\\n# as a valid one, even if it doesn\\'t have any edges) \\n\\n# The answer is the number of connected components - 1,\\n# because we want to define a number of edges to reconnect\\n\\n```\n```\\nclass Solution:\\n    def makeConnected(self, n: int, connections: list[list[int]]) -> int:\\n        if n - 1 > len(connections):\\n            return -1\\n\\n        adjList = [[] for _ in range(n)]\\n        \\n        for u, v in connections: \\n            adjList[u].append(v)\\n            adjList[v].append(u)\\n        \\n        ans = -1\\n        seen = set()\\n\\n        def dfs(node):\\n            for n in adjList[node]:\\n                if n not in seen:\\n                    seen.add(n)\\n                    dfs(n)\\n\\n        for i in range(n):\\n            if i not in seen:\\n                seen.add(i)\\n                ans += 1\\n                dfs(i)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994750,
                "title": "java-disjointset-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(m * log(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/2afc34cc-04fa-4568-80e2-60c92cf26a80_1693710877.7233145.png)\\n\\n\\n# Code\\n```\\nclass DisjointSet {\\n    List<Integer> size = new ArrayList<>();\\n    List<Integer> parent = new ArrayList<>();\\n    \\n    public DisjointSet(int n) {\\n        // Initialize the parent and size lists for each node.\\n        for (int i = 0; i <= n; i++) {\\n            parent.add(i);  // Each node is initially its own parent.\\n            size.add(1);    // Initially, each set has a size of 1.\\n        }\\n    }\\n    \\n    public int findUPar(int node) {\\n        if (node == parent.get(node)) {\\n            return node;  // If the node is its own parent, it\\'s the representative of its set.\\n        }\\n        // Recursively find the ultimate parent and update the parent list for path compression.\\n        int ulp = findUPar(parent.get(node));\\n        parent.set(node, ulp); // Path compression: update the parent to the ultimate parent.\\n        return parent.get(node);\\n    }\\n    \\n    public void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u);  // Find ultimate parent of u.\\n        int ulp_v = findUPar(v);  // Find ultimate parent of v.\\n        \\n        if (ulp_u == ulp_v) return;  // If they share the same parent, they are in the same set.\\n        \\n        if (size.get(ulp_u) < size.get(ulp_v)) {\\n            // Attach the smaller set to the larger set and update the size.\\n            parent.set(ulp_u, ulp_v);\\n            size.set(ulp_v, size.get(ulp_v) + size.get(ulp_u));\\n        } else {\\n            parent.set(ulp_v, ulp_u);\\n            size.set(ulp_u, size.get(ulp_u) + size.get(ulp_v));\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public int makeConnected(int n, int[][] connections) {\\n        \\n        DisjointSet ds = new DisjointSet(n);\\n\\n        int m = connections.length;\\n        int extraEdges = 0;\\n\\n        // Check each connection and determine if it creates an extra edge or connects existing components.\\n        for (int i = 0; i < m; i++) {\\n            int u = connections[i][0];\\n            int v = connections[i][1];\\n\\n            if (ds.findUPar(u) == ds.findUPar(v)) {\\n                extraEdges++; // The connection creates an extra edge within the same component.\\n            } else {\\n                ds.unionBySize(u, v); // Union the two nodes to connect their components.\\n            }\\n        }\\n\\n        int connectedComponents = 0;\\n\\n        // Count the number of connected components in the disjoint set.\\n        for (int i = 0; i < n; i++) {\\n            if (ds.findUPar(i) == i) {\\n                connectedComponents++;\\n            }\\n        }\\n\\n        int requiredEdges = connectedComponents - 1;\\n\\n        if (extraEdges >= requiredEdges) {\\n            return requiredEdges; // There are enough extra edges to connect all components.\\n        }\\n        return -1; // Not enough extra edges to connect all components.\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass DisjointSet {\\n    List<Integer> size = new ArrayList<>();\\n    List<Integer> parent = new ArrayList<>();\\n    \\n    public DisjointSet(int n) {\\n        // Initialize the parent and size lists for each node.\\n        for (int i = 0; i <= n; i++) {\\n            parent.add(i);  // Each node is initially its own parent.\\n            size.add(1);    // Initially, each set has a size of 1.\\n        }\\n    }\\n    \\n    public int findUPar(int node) {\\n        if (node == parent.get(node)) {\\n            return node;  // If the node is its own parent, it\\'s the representative of its set.\\n        }\\n        // Recursively find the ultimate parent and update the parent list for path compression.\\n        int ulp = findUPar(parent.get(node));\\n        parent.set(node, ulp); // Path compression: update the parent to the ultimate parent.\\n        return parent.get(node);\\n    }\\n    \\n    public void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u);  // Find ultimate parent of u.\\n        int ulp_v = findUPar(v);  // Find ultimate parent of v.\\n        \\n        if (ulp_u == ulp_v) return;  // If they share the same parent, they are in the same set.\\n        \\n        if (size.get(ulp_u) < size.get(ulp_v)) {\\n            // Attach the smaller set to the larger set and update the size.\\n            parent.set(ulp_u, ulp_v);\\n            size.set(ulp_v, size.get(ulp_v) + size.get(ulp_u));\\n        } else {\\n            parent.set(ulp_v, ulp_u);\\n            size.set(ulp_u, size.get(ulp_u) + size.get(ulp_v));\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public int makeConnected(int n, int[][] connections) {\\n        \\n        DisjointSet ds = new DisjointSet(n);\\n\\n        int m = connections.length;\\n        int extraEdges = 0;\\n\\n        // Check each connection and determine if it creates an extra edge or connects existing components.\\n        for (int i = 0; i < m; i++) {\\n            int u = connections[i][0];\\n            int v = connections[i][1];\\n\\n            if (ds.findUPar(u) == ds.findUPar(v)) {\\n                extraEdges++; // The connection creates an extra edge within the same component.\\n            } else {\\n                ds.unionBySize(u, v); // Union the two nodes to connect their components.\\n            }\\n        }\\n\\n        int connectedComponents = 0;\\n\\n        // Count the number of connected components in the disjoint set.\\n        for (int i = 0; i < n; i++) {\\n            if (ds.findUPar(i) == i) {\\n                connectedComponents++;\\n            }\\n        }\\n\\n        int requiredEdges = connectedComponents - 1;\\n\\n        if (extraEdges >= requiredEdges) {\\n            return requiredEdges; // There are enough extra edges to connect all components.\\n        }\\n        return -1; // Not enough extra edges to connect all components.\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979747,
                "title": "c-disjoint-set-union-dsu",
                "content": "\\n# Code\\n```\\nclass DisjointSetUnion {\\n    vector<int> size, parent;\\n    public:\\n    DisjointSetUnion(int n) {\\n        parent.resize(n+1);\\n        size.resize(n+1, 1);\\n        for(int i=0;i<=n;i++) {\\n            parent[i] = i;\\n        }\\n    }\\n    int findParent(int node) {\\n        if(node == parent[node]) {\\n            return node;\\n        }\\n        return parent[node] = findParent(parent[node]);\\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int pu = findParent(u);\\n        int pv = findParent(v);\\n        if(pu == pv) return;\\n        if(size[pu]<size[pv]) {\\n            parent[pu] = pv;\\n            size[pv] += size[pu];\\n        }\\n        else {\\n            parent[pv] = pu;\\n            size[pu] += size[pv];\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        DisjointSetUnion dsu(n);\\n        int wireFree = 0;\\n        for(auto &connection : connections) {\\n            if(dsu.findParent(connection[0]) == dsu.findParent(connection[1])) {\\n                wireFree++;\\n                continue;\\n            }\\n            dsu.unionBySize(connection[0], connection[1]);\\n        }\\n        int component = 0;\\n        set<int> s;\\n        for(int i=0;i<n;i++) {\\n            if(s.find(dsu.findParent(i)) == s.end()) {\\n                component++;\\n                s.insert(dsu.findParent(i));\\n            }\\n        }\\n        if((s.size()-1) <= wireFree) {\\n            return s.size()-1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DisjointSetUnion {\\n    vector<int> size, parent;\\n    public:\\n    DisjointSetUnion(int n) {\\n        parent.resize(n+1);\\n        size.resize(n+1, 1);\\n        for(int i=0;i<=n;i++) {\\n            parent[i] = i;\\n        }\\n    }\\n    int findParent(int node) {\\n        if(node == parent[node]) {\\n            return node;\\n        }\\n        return parent[node] = findParent(parent[node]);\\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int pu = findParent(u);\\n        int pv = findParent(v);\\n        if(pu == pv) return;\\n        if(size[pu]<size[pv]) {\\n            parent[pu] = pv;\\n            size[pv] += size[pu];\\n        }\\n        else {\\n            parent[pv] = pu;\\n            size[pu] += size[pv];\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        DisjointSetUnion dsu(n);\\n        int wireFree = 0;\\n        for(auto &connection : connections) {\\n            if(dsu.findParent(connection[0]) == dsu.findParent(connection[1])) {\\n                wireFree++;\\n                continue;\\n            }\\n            dsu.unionBySize(connection[0], connection[1]);\\n        }\\n        int component = 0;\\n        set<int> s;\\n        for(int i=0;i<n;i++) {\\n            if(s.find(dsu.findParent(i)) == s.end()) {\\n                component++;\\n                s.insert(dsu.findParent(i));\\n            }\\n        }\\n        if((s.size()-1) <= wireFree) {\\n            return s.size()-1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747376,
                "title": "c-solution-dsu-union-by-size",
                "content": "\\n# Complexity\\n- Time complexity:$$O(E*4\\u03B1)$$+$$O(N*4\\u03B1)$$ where E = no. of edges and N = no. of nodes\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(2N)$$ N = no. of nodes\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DisjointSet{\\n    \\n    public:\\n    vector<int>rank,parent,size;\\n    DisjointSet(int n){\\n        rank.resize(n+1,0);\\n        parent.resize(n+1);\\n        size.resize(n+1);\\n        for (int i = 1; i <=n; i++)\\n        {\\n            parent[i]=i;\\n            size[i]=1;\\n        }\\n        \\n    }\\n    int findPar(int node){\\n        if(node==parent[node]) return node;\\n        return parent[node]=findPar(parent[node]);\\n    }\\n    void unionByRank(int u,int v){\\n        int ulp_u = findPar(u);\\n        int ulp_v = findPar(v);\\n        if(ulp_u == ulp_v) return;\\n\\n        if (rank[ulp_u]<rank[ulp_v]) parent[ulp_u]=ulp_v;\\n\\n        else if(rank[ulp_u]>rank[ulp_v]) parent[ulp_v]= ulp_u;\\n\\n        else{\\n            parent[ulp_v] = ulp_u;\\n            rank[ulp_u]++;\\n        }\\n        \\n    }\\n    void unionBySize(int u,int v){\\n        int ulp_u = findPar(u);\\n        int ulp_v = findPar(v);\\n        if(ulp_u == ulp_v) return;\\n        if(size[ulp_u]<size[ulp_v]){\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v]+=size[ulp_u];\\n        }\\n        else{\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u]+=size[ulp_v];\\n        }\\n        }\\n};\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n\\n        DisjointSet ds(n);\\n        int cntExtra = 0;\\n        for(auto it:connections){\\n            int u = it[0];\\n            int v = it[1];\\n            if(ds.findPar(u)==ds.findPar(v)) cntExtra++;\\n            else ds.unionBySize(u,v);\\n        }\\n\\n        int cntC =0;\\n        for(int i =0;i<n;i++){\\n            if(ds.parent[i]==i) cntC++;\\n        }\\n\\n        int ans = cntC-1;\\n        if(cntExtra>=ans) return ans;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass DisjointSet{\\n    \\n    public:\\n    vector<int>rank,parent,size;\\n    DisjointSet(int n){\\n        rank.resize(n+1,0);\\n        parent.resize(n+1);\\n        size.resize(n+1);\\n        for (int i = 1; i <=n; i++)\\n        {\\n            parent[i]=i;\\n            size[i]=1;\\n        }\\n        \\n    }\\n    int findPar(int node){\\n        if(node==parent[node]) return node;\\n        return parent[node]=findPar(parent[node]);\\n    }\\n    void unionByRank(int u,int v){\\n        int ulp_u = findPar(u);\\n        int ulp_v = findPar(v);\\n        if(ulp_u == ulp_v) return;\\n\\n        if (rank[ulp_u]<rank[ulp_v]) parent[ulp_u]=ulp_v;\\n\\n        else if(rank[ulp_u]>rank[ulp_v]) parent[ulp_v]= ulp_u;\\n\\n        else{\\n            parent[ulp_v] = ulp_u;\\n            rank[ulp_u]++;\\n        }\\n        \\n    }\\n    void unionBySize(int u,int v){\\n        int ulp_u = findPar(u);\\n        int ulp_v = findPar(v);\\n        if(ulp_u == ulp_v) return;\\n        if(size[ulp_u]<size[ulp_v]){\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v]+=size[ulp_u];\\n        }\\n        else{\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u]+=size[ulp_v];\\n        }\\n        }\\n};\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n\\n        DisjointSet ds(n);\\n        int cntExtra = 0;\\n        for(auto it:connections){\\n            int u = it[0];\\n            int v = it[1];\\n            if(ds.findPar(u)==ds.findPar(v)) cntExtra++;\\n            else ds.unionBySize(u,v);\\n        }\\n\\n        int cntC =0;\\n        for(int i =0;i<n;i++){\\n            if(ds.parent[i]==i) cntC++;\\n        }\\n\\n        int ans = cntC-1;\\n        if(cntExtra>=ans) return ans;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736228,
                "title": "java-connected-components-dfs-util-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is asking to determine the minimum number of operations needed to make all the computers connected. We can approach this problem by using graph traversal, specifically depth-first search (DFS). By counting the number of connected components in the graph, we can determine the minimum number of cables needed to connect all the computers.\\n# Approach\\n- Create an adjacency list representation of the graph using an array of ArrayLists. Each index of the array represents a computer, and the ArrayList at that index contains the neighboring computers.\\n- Iterate over the connections and add the corresponding edges to the adjacency list.\\n- Initialize a count variable to keep track of the number of connected components.\\n- Perform DFS traversal on the graph:\\n    - Initialize a visited array to mark visited computers.\\n    -Iterate over each computer in the graph.\\n    - If the computer has not been visited, perform DFS traversal from that computer and increment the count by 1.\\n- If the number of connections is less than n - 1 (number of computers minus 1), return -1, as there are not enough cables to connect all the computers.\\n- Otherwise, return count - 1 as the minimum number of operations needed to make all the computers connected.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n+E)$$here n is the number of computers and E is the number of connections.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:The adjacency list representation requires O(E) space. Additionally, the visited array and other variables used in the DFS traversal take O(n) space. Therefore, the overall space complexity is $$O(n + E)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    Integer count=0;\\n    public int makeConnected(int n, int[][] connections) {\\n        ArrayList<Integer>[] graph=new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            graph[i]=new ArrayList<>();\\n        }\\n        for(int[] edge:connections){\\n            int u=edge[0];\\n            int v=edge[1];\\n\\n            graph[u].add(v);\\n            graph[v].add(u);\\n        }\\n        dfs(graph);\\n        if (connections.length < n - 1) {\\n            return -1;\\n        }\\n        return count - 1;\\n    }\\n    void dfs(ArrayList<Integer>[] graph){\\n        boolean[] vis=new boolean[graph.length];\\n        for (int i = 0; i < graph.length; i++) {\\n            if (!vis[i]){\\n                dfsutil(graph,vis,i);\\n                count+=1;\\n            }\\n        }\\n    }\\n    void dfsutil(ArrayList<Integer>[] graph, boolean[] vis, int vertex) {\\n        vis[vertex]=true;\\n        for (int i = 0; i <graph[vertex].size() ; i++) {\\n            int e=graph[vertex].get(i);\\n            if (!vis[e]){\\n                dfsutil(graph,vis,e);\\n            }\\n        }\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    Integer count=0;\\n    public int makeConnected(int n, int[][] connections) {\\n        ArrayList<Integer>[] graph=new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            graph[i]=new ArrayList<>();\\n        }\\n        for(int[] edge:connections){\\n            int u=edge[0];\\n            int v=edge[1];\\n\\n            graph[u].add(v);\\n            graph[v].add(u);\\n        }\\n        dfs(graph);\\n        if (connections.length < n - 1) {\\n            return -1;\\n        }\\n        return count - 1;\\n    }\\n    void dfs(ArrayList<Integer>[] graph){\\n        boolean[] vis=new boolean[graph.length];\\n        for (int i = 0; i < graph.length; i++) {\\n            if (!vis[i]){\\n                dfsutil(graph,vis,i);\\n                count+=1;\\n            }\\n        }\\n    }\\n    void dfsutil(ArrayList<Integer>[] graph, boolean[] vis, int vertex) {\\n        vis[vertex]=true;\\n        for (int i = 0; i <graph[vertex].size() ; i++) {\\n            int e=graph[vertex].get(i);\\n            if (!vis[e]){\\n                dfsutil(graph,vis,e);\\n            }\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716467,
                "title": "very-easy-and-full-explained-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe dfs function is a helper function that performs a depth-first search (DFS) traversal on a graph. It takes the following parameters:\\n\\nn: The number of nodes in the graph.\\nadj: An array of vectors representing the adjacency list of the graph.\\nnode: The current node being visited.\\nvis: A vector representing the visited status of each node.\\nInside dfs, the vis vector is updated to mark the current node as visited.\\n\\nFor each neighbor ch of the current node, if it hasn\\'t been visited (vis[ch] == 0), a recursive call to dfs is made with ch as the new current node.\\n\\nAfter visiting all neighbors of the current node, the dfs function returns.\\n\\nThe makeConnected function starts by initializing a variable e with the number of connections in the connections vector.\\n\\nIt then creates an array of vectors adj of size n to represent the adjacency list of the graph.\\n\\nA loop iterates over each connection in the connections vector and adds bidirectional edges to the adjacency list.\\n\\nA vector vis of size n is created and initialized with zeros to keep track of the visited status of each node.\\n\\nAnother variable cnt is initialized to keep track of the number of connected components.\\n\\nA loop iterates over each node in the graph. If the node hasn\\'t been visited (!vis[i]), it means it belongs to a new connected component. In this case, cnt is incremented, and the dfs function is called with the current node.\\n\\nAfter all nodes have been visited, if the number of connections (e) is less than the number of nodes minus 1 (n-1), it means it is not possible to make all nodes connected. In this case, the function returns -1.\\n\\nOtherwise, the function returns the number of connected components minus 1 (cnt-1), which represents the minimum number of additional connections needed to make all nodes connected.\\n\\nThis code essentially performs a DFS traversal to count the number of connected components in the graph and checks if there are enough connections to connect all nodes.\\n# Complexity\\n- Time complexity:\\nO(V+E), since we traverse all vertices and all edges of the graph.\\n\\n- Space complexity:\\nO(V+E) for adj[] matrix construction and O(V) auxilary space, were V is number of vertices and E is number of edges.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void dfs(int n,vector<int>adj[],int node,vector<int>&vis)\\n    {\\n        vis[node]=1;\\n        for(auto ch:adj[node])\\n        {\\n            if(vis[ch]==0)\\n            {\\n                dfs(n,adj,ch,vis);\\n            }\\n        }\\n        return ;\\n    }\\n\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        int e = connections.size();\\n        vector<int>adj[n];\\n        for(int i=0;i<e;i++)\\n        {\\n            int a = connections[i][0];\\n            int b = connections[i][1];\\n            adj[a].push_back(b);\\n            adj[b].push_back(a);\\n        }\\n        vector<int>vis(n,0);\\n        int cnt = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i])\\n            {\\n                cnt++;\\n                dfs(n,adj,i,vis);\\n            }\\n        }\\n        if(e<n-1){\\n            return -1;\\n        }\\n        else{\\n            return cnt-1;\\n        }\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void dfs(int n,vector<int>adj[],int node,vector<int>&vis)\\n    {\\n        vis[node]=1;\\n        for(auto ch:adj[node])\\n        {\\n            if(vis[ch]==0)\\n            {\\n                dfs(n,adj,ch,vis);\\n            }\\n        }\\n        return ;\\n    }\\n\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        int e = connections.size();\\n        vector<int>adj[n];\\n        for(int i=0;i<e;i++)\\n        {\\n            int a = connections[i][0];\\n            int b = connections[i][1];\\n            adj[a].push_back(b);\\n            adj[b].push_back(a);\\n        }\\n        vector<int>vis(n,0);\\n        int cnt = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i])\\n            {\\n                cnt++;\\n                dfs(n,adj,i,vis);\\n            }\\n        }\\n        if(e<n-1){\\n            return -1;\\n        }\\n        else{\\n            return cnt-1;\\n        }\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566932,
                "title": "disjoint-set-implementation-easy-implementation",
                "content": "after implementing disjoint set, we will simply now see the number of components in the graph.\\n\\nwe can simply tell the number of components by knowing the number of super parent, or the ultimate parents(learn dsu).\\n\\nwe will also not use the extra edges build the graph so that we can know the number of extra edges.\\n\\nextra edges will be like {0,1} {0,2} {2,1}\\nhere 2,1 is an extra edge as the node 1 and 2 both have the same ultimate parent\\n\\nnow we will simply see if the number of extra edges are in adequate amount or not\\n\\nwe need at least n-1 edges to connect n components.\\n# Code\\n```\\nclass DisjointSet2 {\\n\\n    int size[];\\n    int parent[];\\n\\n    public DisjointSet2(int n) {\\n        size = new int[n];\\n        parent = new int[n];\\n        for (int i = 0; i < parent.length; i++) {\\n            size[i] = 0;\\n            parent[i] = i;\\n        }\\n    }\\n\\n    public int ultimateParent(int node) {\\n        if (parent[node] == node) {\\n            return parent[node];\\n        }\\n        int up = ultimateParent(parent[node]);\\n        parent[node] = up;\\n        return up;\\n    }\\n\\n    public void unionBySize(int u, int v) {\\n        int ultimateParentu = ultimateParent(u);\\n        int ultimateParentv = ultimateParent(v);\\n        if (size[ultimateParentu] > size[ultimateParentv]) {\\n            parent[ultimateParentv] = ultimateParentu;\\n            size[ultimateParentu]++;\\n        } else if (size[ultimateParentu] < size[ultimateParentv]) {\\n            parent[ultimateParentu] = ultimateParentv;\\n            size[ultimateParentv]++;\\n        } else {\\n            parent[ultimateParentu] = ultimateParentv;\\n            size[ultimateParentv]++;\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public int makeConnected(int n, int[][] connections) {\\n        return util1(n,connections);\\n    }\\n    public int util1(int n , int matrix[][]){\\n        DisjointSet2 ds = new DisjointSet2(n);\\n        int extraEdges = 0;\\n        for(int i = 0;i<matrix.length;i++){\\n            int nodeA = matrix[i][0];\\n            int nodeB = matrix[i][1];\\n            if(ds.ultimateParent(nodeB) != ds.ultimateParent(nodeA)){\\n                ds.unionBySize(nodeA, nodeB);\\n            }else{\\n                extraEdges++;\\n            }\\n        }\\n        int numberComp = 0;\\n        int arr[] = ds.parent;\\n        for(int i = 0;i<arr.length;i++){\\n            if(arr[i] == i){\\n                numberComp++;\\n            }\\n        }\\n\\n        if(extraEdges >= (numberComp-1)){\\n            return numberComp - 1;\\n        }\\n        return -1;\\n    }\\n}\\n```\\nyou can check out my github repository where i am uploading famous interview questions topic wise with solutions.\\nlink-- https://github.com/Abhaydutt2003/DataStructureAndAlgoPractice \\nkindly upvote if you like my solution. you can ask doubts below.\\n",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass DisjointSet2 {\\n\\n    int size[];\\n    int parent[];\\n\\n    public DisjointSet2(int n) {\\n        size = new int[n];\\n        parent = new int[n];\\n        for (int i = 0; i < parent.length; i++) {\\n            size[i] = 0;\\n            parent[i] = i;\\n        }\\n    }\\n\\n    public int ultimateParent(int node) {\\n        if (parent[node] == node) {\\n            return parent[node];\\n        }\\n        int up = ultimateParent(parent[node]);\\n        parent[node] = up;\\n        return up;\\n    }\\n\\n    public void unionBySize(int u, int v) {\\n        int ultimateParentu = ultimateParent(u);\\n        int ultimateParentv = ultimateParent(v);\\n        if (size[ultimateParentu] > size[ultimateParentv]) {\\n            parent[ultimateParentv] = ultimateParentu;\\n            size[ultimateParentu]++;\\n        } else if (size[ultimateParentu] < size[ultimateParentv]) {\\n            parent[ultimateParentu] = ultimateParentv;\\n            size[ultimateParentv]++;\\n        } else {\\n            parent[ultimateParentu] = ultimateParentv;\\n            size[ultimateParentv]++;\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public int makeConnected(int n, int[][] connections) {\\n        return util1(n,connections);\\n    }\\n    public int util1(int n , int matrix[][]){\\n        DisjointSet2 ds = new DisjointSet2(n);\\n        int extraEdges = 0;\\n        for(int i = 0;i<matrix.length;i++){\\n            int nodeA = matrix[i][0];\\n            int nodeB = matrix[i][1];\\n            if(ds.ultimateParent(nodeB) != ds.ultimateParent(nodeA)){\\n                ds.unionBySize(nodeA, nodeB);\\n            }else{\\n                extraEdges++;\\n            }\\n        }\\n        int numberComp = 0;\\n        int arr[] = ds.parent;\\n        for(int i = 0;i<arr.length;i++){\\n            if(arr[i] == i){\\n                numberComp++;\\n            }\\n        }\\n\\n        if(extraEdges >= (numberComp-1)){\\n            return numberComp - 1;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566473,
                "title": "dfs-striver-beginner-friendly",
                "content": "```\\nclass Solution {\\n    private:\\n    void dfs(int source , vector<bool>&vis , vector<int>adj[]){\\n        vis[source] = true;\\n        for(auto it: adj[source]){\\n            if(!vis[it]){\\n                dfs(it , vis ,adj);\\n            }\\n        }\\n    }\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        vector<int>adj[n];\\n        int nl = connections.size();\\n        if(nl < n-1)return -1;\\n        for(int i = 0 ; i < nl ; i ++){\\n            int u = connections[i][0];\\n            int v = connections[i][1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        vector<bool>vis(n,false);\\n        int cnt = 0;\\n        dfs(0 , vis ,adj);\\n            \\n            bool flag  = false;\\n        for(int i = 1 ; i < n ; i ++){\\n            if(!vis[i]){\\n                cnt ++;\\n                flag  = true;\\n                cout<<i<<endl;\\n                dfs( i , vis , adj);\\n            }\\n        }\\n     return  flag == false ? 0 : cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n    void dfs(int source , vector<bool>&vis , vector<int>adj[]){\\n        vis[source] = true;\\n        for(auto it: adj[source]){\\n            if(!vis[it]){\\n                dfs(it , vis ,adj);\\n            }\\n        }\\n    }\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        vector<int>adj[n];\\n        int nl = connections.size();\\n        if(nl < n-1)return -1;\\n        for(int i = 0 ; i < nl ; i ++){\\n            int u = connections[i][0];\\n            int v = connections[i][1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        vector<bool>vis(n,false);\\n        int cnt = 0;\\n        dfs(0 , vis ,adj);\\n            \\n            bool flag  = false;\\n        for(int i = 1 ; i < n ; i ++){\\n            if(!vis[i]){\\n                cnt ++;\\n                flag  = true;\\n                cout<<i<<endl;\\n                dfs( i , vis , adj);\\n            }\\n        }\\n     return  flag == false ? 0 : cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            }
        ],
        "discussions": [
            {
                "id": 1840926,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Switch to wireless technology to avoid such type of problems in life "
                    },
                    {
                        "username": "RCchoudhary",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE00 Nice"
                    },
                    {
                        "username": "hahahamid",
                        "content": "real"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "big bren"
                    },
                    {
                        "username": "santanusen",
                        "content": "Ha ha! On a serious note, the backbone networks are still wired, involving optical cables. Though they do have satellite links as emergency failover, those have terrible latencies."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@TsuruLee](/TsuruLee) now deal with 3D Array \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "I think they will create new problems about something like where to place the router to make the signal cover all devices"
                    },
                    {
                        "username": "kaskabay",
                        "content": "Test case:\\n100\\n[[17,51],[33,83],[53,62],[25,34],[35,90],[29,41],[14,53],[40,84],[41,64],[13,68],[44,85],[57,58],[50,74],[20,69],[15,62],[25,88],[4,56],[37,39],[30,62],[69,79],[33,85],[24,83],[35,77],[2,73],[6,28],[46,98],[11,82],[29,72],[67,71],[12,49],[42,56],[56,65],[40,70],[24,64],[29,51],[20,27],[45,88],[58,92],[60,99],[33,46],[19,69],[33,89],[54,82],[16,50],[35,73],[19,45],[19,72],[1,79],[27,80],[22,41],[52,61],[50,85],[27,45],[4,84],[11,96],[0,99],[29,94],[9,19],[66,99],[20,39],[16,85],[12,27],[16,67],[61,80],[67,83],[16,17],[24,27],[16,25],[41,79],[51,95],[46,47],[27,51],[31,44],[0,69],[61,63],[33,95],[17,88],[70,87],[40,42],[21,42],[67,77],[33,65],[3,25],[39,83],[34,40],[15,79],[30,90],[58,95],[45,56],[37,48],[24,91],[31,93],[83,90],[17,86],[61,65],[15,48],[34,56],[12,26],[39,98],[1,48],[21,76],[72,96],[30,69],[46,80],[6,29],[29,81],[22,77],[85,90],[79,83],[6,26],[33,57],[3,65],[63,84],[77,94],[26,90],[64,77],[0,3],[27,97],[66,89],[18,77],[27,43]]\\n\\nThe test case above have 88 already connected computers and 121 cables. So, we only need 12 (100-88) computers to be connected or in other words maximum of 12 cables relocated. How is that possible that answer is 13? It seems that it is not optimal way. I may be wrong in assumtions, if so please let me know."
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "suppose you have 6 computers 123 are connected in a straight line [1-2-3] & all others are connected in the same way [4-5-6] although all computers are connected the answer will be -1 because we cannot reach 4 5 6 starting at 1 2 3"
                    },
                    {
                        "username": "sainadth1123434",
                        "content": "Yeah thats correct even i got this error donno if the solution provided correct or not"
                    },
                    {
                        "username": "ramakiran",
                        "content": "[@ramakiran](/ramakiran) \\nthis is the shorter version of above case there will be 2 connected components so the answer will be 1 \\n"
                    },
                    {
                        "username": "ramakiran",
                        "content": "[@rockstar4095](/rockstar4095)   \\nn=6\\n[[0,1],[0,2],[1,2],[3,4],[4,5]]"
                    },
                    {
                        "username": "pramod74",
                        "content": "[@rockstar4095](/rockstar4095) Absolutely, that\\'s what is puzzling me aIso. Not sure if the question needs to be reworded to make this clear! "
                    },
                    {
                        "username": "B0PD0P",
                        "content": "[@kunadilov](/kunadilov)  we have 12 computers that are not connected, then we need at minimum 11 edges to connect these 12 computers with each other and then one extra edge to connect this component to the original component, shouldn't the answer be 12 ?"
                    },
                    {
                        "username": "kunadilov",
                        "content": "[@rockstar4095](/rockstar4095) This 88 computers connected in 2 different networks. So, you have 87 connected and 2 connected between each other. In a result you need minimum 13 connections. "
                    },
                    {
                        "username": "rockstar4095",
                        "content": "same problem with 100-88 computers.\n\ncan anyone provide a smaller example for this configuration?\nare there two or more initial networks actually  instead of one?\n\nI have a very nice 10-lines solution and it fails on this testcase))"
                    },
                    {
                        "username": "rockstar4095",
                        "content": "[@rush2rain](/rush2rain) \\n\\nfrom description:\\n\\n\"Any computer can reach any other computer directly or indirectly through the network.\"\\n\\n\"You are given an initial computer network connections.\"\\n\\naccording to this description, all the initial given computers must be connected."
                    },
                    {
                        "username": "jasona",
                        "content": "[@rush2rain](/rush2rain) ahh thanks! they need to introduce a smaller test case demonstrating that "
                    },
                    {
                        "username": "rush2rain",
                        "content": "Previously, I also attempted the same way. But there happens to be one flaw. What if 88 connected computers are making two separate components of 44 systems each. In that case, we need a wire to connect the two components together as well. So, we need to count the number of components that the whole set of computers is making. "
                    },
                    {
                        "username": "yyol",
                        "content": "same question"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one whose mind screwed up on this question ?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "you just need two things .\\n1. n-1>connections.length  return -1  (don\\'t have enough edge to connect all)\\n2. find number of connected components , return count-1"
                    },
                    {
                        "username": "thatsassygurl21",
                        "content": "Java implentation of your approach:\\nclass Solution {\\n    public int makeConnected(int n, int[][] con){\\n     if(con.length<n-1)return -1;\\n     List<List<Integer>> adj=new ArrayList<>();\\n     for(int i=0;i<n;i++)adj.add(new ArrayList<>());\\n     for(int i=0;i<con.length;i++)\\n     {\\n         adj.get(con[i][0]).add(con[i][1]);\\n          adj.get(con[i][1]).add(con[i][0]);\\n     }\\n     int ans=0;\\n     int vis[]=new int[n];\\n     for(int i=0;i<n;i++)\\n\\n     {\\n         if(vis[i]==0)\\n         {\\n             ans++;\\n             dfs(vis, adj,i);\\n         }   \\n    }\\n    return ans-1;\\n\\n\\n}\\n\\nvoid dfs(int []vis,List<List<Integer>> adj, int n )\\n{\\n    vis[n]=1;\\n    for(int i=0;i<adj.get(n).size();i++)\\n    {\\n    if(vis[adj.get(n).get(i)]==0)\\n    {\\n        dfs(vis,adj,adj.get(n).get(i));\\n    }\\n    }\\n}}"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@daveamol](/daveamol) What is count you are talking about, is it number of disconnected systems?"
                    },
                    {
                        "username": "daveamol",
                        "content": "This is the check I was looking for. That the total numbers of edges for every node to be connected has to be at least (n-1). As minimum edges required to connect n nodes is n-1.\\n\\nI wrote the check like this instead for clarity -\\nconnections.length >= n - 1, then return count - 1, else return -1"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Union Find week ? We are ready!"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "[@UchihaKim](/UchihaKim) you can determine if the node are having same parent node using find(), so if you find the edges are repeated, that mean you can swap that edge to connect other node."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "[@hiper2d](/hiper2d) I solve yesterday question using BFS then I took a look on the related topics and found Union Find, I am still learning it for now,  I can solve the problem using DFS but I want to solve it with that beautiful  DS. If you can give me some tips I\\'d be grateful if you help me."
                    },
                    {
                        "username": "hiper2d",
                        "content": "Same thing here. I keep using Union Find without even considering DFS and BFS. For some reason, this data structure is more obvious solution"
                    },
                    {
                        "username": "Rajkumar_007",
                        "content": "Hint : Find number of clusters"
                    },
                    {
                        "username": "hosua",
                        "content": "Weird, I tried solving this with BFS and got TLE, but it worked fine with DFS. Anyone understand why?"
                    },
                    {
                        "username": "hosua",
                        "content": "[@Crispy_coffee](/Crispy_coffee) I did something similar to this and got TLE"
                    },
                    {
                        "username": "czjnbb",
                        "content": "My py BFS beated more than 80%."
                    },
                    {
                        "username": "try_solving_hard",
                        "content": "Here\\'s my BFS submisson. #referrence Accepted in 1st attempt itself. #pride.\\n\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        \\n        // Find total number of connected components\\n        // Indegree / outdegree sum of all nodes in a connected component\\n        // Find total no of extra cables => (degree sum - required)/2\\n        // where required = (nodes in connected component - 1) * 2\\n        // If extra cables >= connected components - 1\\n        //      return connected components - 1\\n        // Else, \\n        //      return - 1\\n\\n        // Construct Graph\\n\\n        vector<int> adj[n];\\n        vector<long long> deg(n, 0);\\n\\n        for(auto c : connections)\\n        {\\n            adj[c[0]].push_back(c[1]);\\n            adj[c[1]].push_back(c[0]);\\n            deg[c[0]]++;\\n            deg[c[1]]++;\\n        }\\n\\n        vector<bool> vis(n, false);\\n        int cc = 0, extra = 0;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            if (!vis[i])\\n            {\\n                cc++;\\n                long long degree_sum = 0;\\n                int nodes = 0;\\n                vis[i] = true;\\n\\n                queue<int> q({i});\\n\\n                while(!q.empty())\\n                {\\n                    auto v = q.front();\\n                    q.pop();\\n\\n                    nodes++;\\n\\n                    degree_sum += deg[v];\\n\\n                    for(auto nbr : adj[v])\\n                    {\\n                        if (!vis[nbr])\\n                        {\\n                            vis[nbr] = true;\\n                            q.push(nbr);\\n\\n                        }\\n                    }\\n                }\\n\\n                int curr_ex = (degree_sum - ((nodes - 1) * 2)) / 2;\\n                extra += curr_ex;\\n            }\\n        }\\n\\n        return extra >= cc - 1 ? cc - 1 : -1;\\n\\n    }\\n};"
                    },
                    {
                        "username": "RamilZaripov",
                        "content": "I had a TLE on my BFS attempt, after reading your comment also switched to DFS and everything worked!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "I saw your comment and after submmiting my DFS approach i find this solution in submitted solution graph\\n\\n```c++\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& c) \\n    {\\n        if(c.size() < n -1) return -1;\\n        vector<int> adj[n];\\n        for(auto it : c)   \\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        } \\n\\n        int ct = 0;\\n        queue<int> q;\\n        vector<int> vis(n, 0);\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(!vis[i])\\n            {\\n                q.push(i);\\n                vis[i] = 1;\\n                while(!q.empty())\\n                {\\n                    int node = q.front();\\n                    q.pop();\\n                    for(auto it : adj[node])\\n                    {\\n                        if(!vis[it])\\n                        {\\n                            q.push(it);\\n                            vis[it] = 1;\\n                        }\\n                    }\\n                }\\n                ct++;\\n            }\\n        }\\n        return ct-1; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "cJayesh",
                        "content": "This happened with me in python.\nBFS uses more space than DFS.\nAlso depending on implementation, BFS has more add_to_list/add_to_set/enqueue/dequeue operations than DFS.\n"
                    },
                    {
                        "username": "user2575jO",
                        "content": "If `n==1` we will have `1 <= connections.length <= 0`. So this test case will not work."
                    },
                    {
                        "username": "Krrabs",
                        "content": "Union Find approach:\nGo through all the given connections and connect `connections[i][a] to connections[i][b]` pairs if `a & b` are already in a same graph you have an extra edge which can be used for connecting unconnected graphs.\n\nAt the end of `connections array` you should have count of extra edges and unconnected graphs, from these two information you can calculate the answer."
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "I thought about finding Indegree of each node (i.e. number of incoming edges) and then the count of nodes with 0 indegree(no incoming edge) shouldn\\'t it be the answer? It fails some testcases. (Yes, I have considered the case where number of wires are less than n-1) "
                    },
                    {
                        "username": "saichandra004",
                        "content": "Let's suppose we have 100 nodes.\n\n50 nodes are connected in a network.\nother 50 nodes are connected in another network (disjoint graph).\n\nFor the whole 100 nodes to be connected, we need 1 connection to join these two independent networks.\n\nBut if we only count the indegree, this seems that all the nodes are connected, but in reality, there are two different networks. Hence this indegree will lead to answers lesser than expected."
                    }
                ]
            },
            {
                "id": 1569737,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Switch to wireless technology to avoid such type of problems in life "
                    },
                    {
                        "username": "RCchoudhary",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE00 Nice"
                    },
                    {
                        "username": "hahahamid",
                        "content": "real"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "big bren"
                    },
                    {
                        "username": "santanusen",
                        "content": "Ha ha! On a serious note, the backbone networks are still wired, involving optical cables. Though they do have satellite links as emergency failover, those have terrible latencies."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@TsuruLee](/TsuruLee) now deal with 3D Array \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "I think they will create new problems about something like where to place the router to make the signal cover all devices"
                    },
                    {
                        "username": "kaskabay",
                        "content": "Test case:\\n100\\n[[17,51],[33,83],[53,62],[25,34],[35,90],[29,41],[14,53],[40,84],[41,64],[13,68],[44,85],[57,58],[50,74],[20,69],[15,62],[25,88],[4,56],[37,39],[30,62],[69,79],[33,85],[24,83],[35,77],[2,73],[6,28],[46,98],[11,82],[29,72],[67,71],[12,49],[42,56],[56,65],[40,70],[24,64],[29,51],[20,27],[45,88],[58,92],[60,99],[33,46],[19,69],[33,89],[54,82],[16,50],[35,73],[19,45],[19,72],[1,79],[27,80],[22,41],[52,61],[50,85],[27,45],[4,84],[11,96],[0,99],[29,94],[9,19],[66,99],[20,39],[16,85],[12,27],[16,67],[61,80],[67,83],[16,17],[24,27],[16,25],[41,79],[51,95],[46,47],[27,51],[31,44],[0,69],[61,63],[33,95],[17,88],[70,87],[40,42],[21,42],[67,77],[33,65],[3,25],[39,83],[34,40],[15,79],[30,90],[58,95],[45,56],[37,48],[24,91],[31,93],[83,90],[17,86],[61,65],[15,48],[34,56],[12,26],[39,98],[1,48],[21,76],[72,96],[30,69],[46,80],[6,29],[29,81],[22,77],[85,90],[79,83],[6,26],[33,57],[3,65],[63,84],[77,94],[26,90],[64,77],[0,3],[27,97],[66,89],[18,77],[27,43]]\\n\\nThe test case above have 88 already connected computers and 121 cables. So, we only need 12 (100-88) computers to be connected or in other words maximum of 12 cables relocated. How is that possible that answer is 13? It seems that it is not optimal way. I may be wrong in assumtions, if so please let me know."
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "suppose you have 6 computers 123 are connected in a straight line [1-2-3] & all others are connected in the same way [4-5-6] although all computers are connected the answer will be -1 because we cannot reach 4 5 6 starting at 1 2 3"
                    },
                    {
                        "username": "sainadth1123434",
                        "content": "Yeah thats correct even i got this error donno if the solution provided correct or not"
                    },
                    {
                        "username": "ramakiran",
                        "content": "[@ramakiran](/ramakiran) \\nthis is the shorter version of above case there will be 2 connected components so the answer will be 1 \\n"
                    },
                    {
                        "username": "ramakiran",
                        "content": "[@rockstar4095](/rockstar4095)   \\nn=6\\n[[0,1],[0,2],[1,2],[3,4],[4,5]]"
                    },
                    {
                        "username": "pramod74",
                        "content": "[@rockstar4095](/rockstar4095) Absolutely, that\\'s what is puzzling me aIso. Not sure if the question needs to be reworded to make this clear! "
                    },
                    {
                        "username": "B0PD0P",
                        "content": "[@kunadilov](/kunadilov)  we have 12 computers that are not connected, then we need at minimum 11 edges to connect these 12 computers with each other and then one extra edge to connect this component to the original component, shouldn't the answer be 12 ?"
                    },
                    {
                        "username": "kunadilov",
                        "content": "[@rockstar4095](/rockstar4095) This 88 computers connected in 2 different networks. So, you have 87 connected and 2 connected between each other. In a result you need minimum 13 connections. "
                    },
                    {
                        "username": "rockstar4095",
                        "content": "same problem with 100-88 computers.\n\ncan anyone provide a smaller example for this configuration?\nare there two or more initial networks actually  instead of one?\n\nI have a very nice 10-lines solution and it fails on this testcase))"
                    },
                    {
                        "username": "rockstar4095",
                        "content": "[@rush2rain](/rush2rain) \\n\\nfrom description:\\n\\n\"Any computer can reach any other computer directly or indirectly through the network.\"\\n\\n\"You are given an initial computer network connections.\"\\n\\naccording to this description, all the initial given computers must be connected."
                    },
                    {
                        "username": "jasona",
                        "content": "[@rush2rain](/rush2rain) ahh thanks! they need to introduce a smaller test case demonstrating that "
                    },
                    {
                        "username": "rush2rain",
                        "content": "Previously, I also attempted the same way. But there happens to be one flaw. What if 88 connected computers are making two separate components of 44 systems each. In that case, we need a wire to connect the two components together as well. So, we need to count the number of components that the whole set of computers is making. "
                    },
                    {
                        "username": "yyol",
                        "content": "same question"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one whose mind screwed up on this question ?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "you just need two things .\\n1. n-1>connections.length  return -1  (don\\'t have enough edge to connect all)\\n2. find number of connected components , return count-1"
                    },
                    {
                        "username": "thatsassygurl21",
                        "content": "Java implentation of your approach:\\nclass Solution {\\n    public int makeConnected(int n, int[][] con){\\n     if(con.length<n-1)return -1;\\n     List<List<Integer>> adj=new ArrayList<>();\\n     for(int i=0;i<n;i++)adj.add(new ArrayList<>());\\n     for(int i=0;i<con.length;i++)\\n     {\\n         adj.get(con[i][0]).add(con[i][1]);\\n          adj.get(con[i][1]).add(con[i][0]);\\n     }\\n     int ans=0;\\n     int vis[]=new int[n];\\n     for(int i=0;i<n;i++)\\n\\n     {\\n         if(vis[i]==0)\\n         {\\n             ans++;\\n             dfs(vis, adj,i);\\n         }   \\n    }\\n    return ans-1;\\n\\n\\n}\\n\\nvoid dfs(int []vis,List<List<Integer>> adj, int n )\\n{\\n    vis[n]=1;\\n    for(int i=0;i<adj.get(n).size();i++)\\n    {\\n    if(vis[adj.get(n).get(i)]==0)\\n    {\\n        dfs(vis,adj,adj.get(n).get(i));\\n    }\\n    }\\n}}"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@daveamol](/daveamol) What is count you are talking about, is it number of disconnected systems?"
                    },
                    {
                        "username": "daveamol",
                        "content": "This is the check I was looking for. That the total numbers of edges for every node to be connected has to be at least (n-1). As minimum edges required to connect n nodes is n-1.\\n\\nI wrote the check like this instead for clarity -\\nconnections.length >= n - 1, then return count - 1, else return -1"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Union Find week ? We are ready!"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "[@UchihaKim](/UchihaKim) you can determine if the node are having same parent node using find(), so if you find the edges are repeated, that mean you can swap that edge to connect other node."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "[@hiper2d](/hiper2d) I solve yesterday question using BFS then I took a look on the related topics and found Union Find, I am still learning it for now,  I can solve the problem using DFS but I want to solve it with that beautiful  DS. If you can give me some tips I\\'d be grateful if you help me."
                    },
                    {
                        "username": "hiper2d",
                        "content": "Same thing here. I keep using Union Find without even considering DFS and BFS. For some reason, this data structure is more obvious solution"
                    },
                    {
                        "username": "Rajkumar_007",
                        "content": "Hint : Find number of clusters"
                    },
                    {
                        "username": "hosua",
                        "content": "Weird, I tried solving this with BFS and got TLE, but it worked fine with DFS. Anyone understand why?"
                    },
                    {
                        "username": "hosua",
                        "content": "[@Crispy_coffee](/Crispy_coffee) I did something similar to this and got TLE"
                    },
                    {
                        "username": "czjnbb",
                        "content": "My py BFS beated more than 80%."
                    },
                    {
                        "username": "try_solving_hard",
                        "content": "Here\\'s my BFS submisson. #referrence Accepted in 1st attempt itself. #pride.\\n\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        \\n        // Find total number of connected components\\n        // Indegree / outdegree sum of all nodes in a connected component\\n        // Find total no of extra cables => (degree sum - required)/2\\n        // where required = (nodes in connected component - 1) * 2\\n        // If extra cables >= connected components - 1\\n        //      return connected components - 1\\n        // Else, \\n        //      return - 1\\n\\n        // Construct Graph\\n\\n        vector<int> adj[n];\\n        vector<long long> deg(n, 0);\\n\\n        for(auto c : connections)\\n        {\\n            adj[c[0]].push_back(c[1]);\\n            adj[c[1]].push_back(c[0]);\\n            deg[c[0]]++;\\n            deg[c[1]]++;\\n        }\\n\\n        vector<bool> vis(n, false);\\n        int cc = 0, extra = 0;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            if (!vis[i])\\n            {\\n                cc++;\\n                long long degree_sum = 0;\\n                int nodes = 0;\\n                vis[i] = true;\\n\\n                queue<int> q({i});\\n\\n                while(!q.empty())\\n                {\\n                    auto v = q.front();\\n                    q.pop();\\n\\n                    nodes++;\\n\\n                    degree_sum += deg[v];\\n\\n                    for(auto nbr : adj[v])\\n                    {\\n                        if (!vis[nbr])\\n                        {\\n                            vis[nbr] = true;\\n                            q.push(nbr);\\n\\n                        }\\n                    }\\n                }\\n\\n                int curr_ex = (degree_sum - ((nodes - 1) * 2)) / 2;\\n                extra += curr_ex;\\n            }\\n        }\\n\\n        return extra >= cc - 1 ? cc - 1 : -1;\\n\\n    }\\n};"
                    },
                    {
                        "username": "RamilZaripov",
                        "content": "I had a TLE on my BFS attempt, after reading your comment also switched to DFS and everything worked!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "I saw your comment and after submmiting my DFS approach i find this solution in submitted solution graph\\n\\n```c++\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& c) \\n    {\\n        if(c.size() < n -1) return -1;\\n        vector<int> adj[n];\\n        for(auto it : c)   \\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        } \\n\\n        int ct = 0;\\n        queue<int> q;\\n        vector<int> vis(n, 0);\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(!vis[i])\\n            {\\n                q.push(i);\\n                vis[i] = 1;\\n                while(!q.empty())\\n                {\\n                    int node = q.front();\\n                    q.pop();\\n                    for(auto it : adj[node])\\n                    {\\n                        if(!vis[it])\\n                        {\\n                            q.push(it);\\n                            vis[it] = 1;\\n                        }\\n                    }\\n                }\\n                ct++;\\n            }\\n        }\\n        return ct-1; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "cJayesh",
                        "content": "This happened with me in python.\nBFS uses more space than DFS.\nAlso depending on implementation, BFS has more add_to_list/add_to_set/enqueue/dequeue operations than DFS.\n"
                    },
                    {
                        "username": "user2575jO",
                        "content": "If `n==1` we will have `1 <= connections.length <= 0`. So this test case will not work."
                    },
                    {
                        "username": "Krrabs",
                        "content": "Union Find approach:\nGo through all the given connections and connect `connections[i][a] to connections[i][b]` pairs if `a & b` are already in a same graph you have an extra edge which can be used for connecting unconnected graphs.\n\nAt the end of `connections array` you should have count of extra edges and unconnected graphs, from these two information you can calculate the answer."
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "I thought about finding Indegree of each node (i.e. number of incoming edges) and then the count of nodes with 0 indegree(no incoming edge) shouldn\\'t it be the answer? It fails some testcases. (Yes, I have considered the case where number of wires are less than n-1) "
                    },
                    {
                        "username": "saichandra004",
                        "content": "Let's suppose we have 100 nodes.\n\n50 nodes are connected in a network.\nother 50 nodes are connected in another network (disjoint graph).\n\nFor the whole 100 nodes to be connected, we need 1 connection to join these two independent networks.\n\nBut if we only count the indegree, this seems that all the nodes are connected, but in reality, there are two different networks. Hence this indegree will lead to answers lesser than expected."
                    }
                ]
            },
            {
                "id": 1840985,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Switch to wireless technology to avoid such type of problems in life "
                    },
                    {
                        "username": "RCchoudhary",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE00 Nice"
                    },
                    {
                        "username": "hahahamid",
                        "content": "real"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "big bren"
                    },
                    {
                        "username": "santanusen",
                        "content": "Ha ha! On a serious note, the backbone networks are still wired, involving optical cables. Though they do have satellite links as emergency failover, those have terrible latencies."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@TsuruLee](/TsuruLee) now deal with 3D Array \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "I think they will create new problems about something like where to place the router to make the signal cover all devices"
                    },
                    {
                        "username": "kaskabay",
                        "content": "Test case:\\n100\\n[[17,51],[33,83],[53,62],[25,34],[35,90],[29,41],[14,53],[40,84],[41,64],[13,68],[44,85],[57,58],[50,74],[20,69],[15,62],[25,88],[4,56],[37,39],[30,62],[69,79],[33,85],[24,83],[35,77],[2,73],[6,28],[46,98],[11,82],[29,72],[67,71],[12,49],[42,56],[56,65],[40,70],[24,64],[29,51],[20,27],[45,88],[58,92],[60,99],[33,46],[19,69],[33,89],[54,82],[16,50],[35,73],[19,45],[19,72],[1,79],[27,80],[22,41],[52,61],[50,85],[27,45],[4,84],[11,96],[0,99],[29,94],[9,19],[66,99],[20,39],[16,85],[12,27],[16,67],[61,80],[67,83],[16,17],[24,27],[16,25],[41,79],[51,95],[46,47],[27,51],[31,44],[0,69],[61,63],[33,95],[17,88],[70,87],[40,42],[21,42],[67,77],[33,65],[3,25],[39,83],[34,40],[15,79],[30,90],[58,95],[45,56],[37,48],[24,91],[31,93],[83,90],[17,86],[61,65],[15,48],[34,56],[12,26],[39,98],[1,48],[21,76],[72,96],[30,69],[46,80],[6,29],[29,81],[22,77],[85,90],[79,83],[6,26],[33,57],[3,65],[63,84],[77,94],[26,90],[64,77],[0,3],[27,97],[66,89],[18,77],[27,43]]\\n\\nThe test case above have 88 already connected computers and 121 cables. So, we only need 12 (100-88) computers to be connected or in other words maximum of 12 cables relocated. How is that possible that answer is 13? It seems that it is not optimal way. I may be wrong in assumtions, if so please let me know."
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "suppose you have 6 computers 123 are connected in a straight line [1-2-3] & all others are connected in the same way [4-5-6] although all computers are connected the answer will be -1 because we cannot reach 4 5 6 starting at 1 2 3"
                    },
                    {
                        "username": "sainadth1123434",
                        "content": "Yeah thats correct even i got this error donno if the solution provided correct or not"
                    },
                    {
                        "username": "ramakiran",
                        "content": "[@ramakiran](/ramakiran) \\nthis is the shorter version of above case there will be 2 connected components so the answer will be 1 \\n"
                    },
                    {
                        "username": "ramakiran",
                        "content": "[@rockstar4095](/rockstar4095)   \\nn=6\\n[[0,1],[0,2],[1,2],[3,4],[4,5]]"
                    },
                    {
                        "username": "pramod74",
                        "content": "[@rockstar4095](/rockstar4095) Absolutely, that\\'s what is puzzling me aIso. Not sure if the question needs to be reworded to make this clear! "
                    },
                    {
                        "username": "B0PD0P",
                        "content": "[@kunadilov](/kunadilov)  we have 12 computers that are not connected, then we need at minimum 11 edges to connect these 12 computers with each other and then one extra edge to connect this component to the original component, shouldn't the answer be 12 ?"
                    },
                    {
                        "username": "kunadilov",
                        "content": "[@rockstar4095](/rockstar4095) This 88 computers connected in 2 different networks. So, you have 87 connected and 2 connected between each other. In a result you need minimum 13 connections. "
                    },
                    {
                        "username": "rockstar4095",
                        "content": "same problem with 100-88 computers.\n\ncan anyone provide a smaller example for this configuration?\nare there two or more initial networks actually  instead of one?\n\nI have a very nice 10-lines solution and it fails on this testcase))"
                    },
                    {
                        "username": "rockstar4095",
                        "content": "[@rush2rain](/rush2rain) \\n\\nfrom description:\\n\\n\"Any computer can reach any other computer directly or indirectly through the network.\"\\n\\n\"You are given an initial computer network connections.\"\\n\\naccording to this description, all the initial given computers must be connected."
                    },
                    {
                        "username": "jasona",
                        "content": "[@rush2rain](/rush2rain) ahh thanks! they need to introduce a smaller test case demonstrating that "
                    },
                    {
                        "username": "rush2rain",
                        "content": "Previously, I also attempted the same way. But there happens to be one flaw. What if 88 connected computers are making two separate components of 44 systems each. In that case, we need a wire to connect the two components together as well. So, we need to count the number of components that the whole set of computers is making. "
                    },
                    {
                        "username": "yyol",
                        "content": "same question"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one whose mind screwed up on this question ?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "you just need two things .\\n1. n-1>connections.length  return -1  (don\\'t have enough edge to connect all)\\n2. find number of connected components , return count-1"
                    },
                    {
                        "username": "thatsassygurl21",
                        "content": "Java implentation of your approach:\\nclass Solution {\\n    public int makeConnected(int n, int[][] con){\\n     if(con.length<n-1)return -1;\\n     List<List<Integer>> adj=new ArrayList<>();\\n     for(int i=0;i<n;i++)adj.add(new ArrayList<>());\\n     for(int i=0;i<con.length;i++)\\n     {\\n         adj.get(con[i][0]).add(con[i][1]);\\n          adj.get(con[i][1]).add(con[i][0]);\\n     }\\n     int ans=0;\\n     int vis[]=new int[n];\\n     for(int i=0;i<n;i++)\\n\\n     {\\n         if(vis[i]==0)\\n         {\\n             ans++;\\n             dfs(vis, adj,i);\\n         }   \\n    }\\n    return ans-1;\\n\\n\\n}\\n\\nvoid dfs(int []vis,List<List<Integer>> adj, int n )\\n{\\n    vis[n]=1;\\n    for(int i=0;i<adj.get(n).size();i++)\\n    {\\n    if(vis[adj.get(n).get(i)]==0)\\n    {\\n        dfs(vis,adj,adj.get(n).get(i));\\n    }\\n    }\\n}}"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@daveamol](/daveamol) What is count you are talking about, is it number of disconnected systems?"
                    },
                    {
                        "username": "daveamol",
                        "content": "This is the check I was looking for. That the total numbers of edges for every node to be connected has to be at least (n-1). As minimum edges required to connect n nodes is n-1.\\n\\nI wrote the check like this instead for clarity -\\nconnections.length >= n - 1, then return count - 1, else return -1"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Union Find week ? We are ready!"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "[@UchihaKim](/UchihaKim) you can determine if the node are having same parent node using find(), so if you find the edges are repeated, that mean you can swap that edge to connect other node."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "[@hiper2d](/hiper2d) I solve yesterday question using BFS then I took a look on the related topics and found Union Find, I am still learning it for now,  I can solve the problem using DFS but I want to solve it with that beautiful  DS. If you can give me some tips I\\'d be grateful if you help me."
                    },
                    {
                        "username": "hiper2d",
                        "content": "Same thing here. I keep using Union Find without even considering DFS and BFS. For some reason, this data structure is more obvious solution"
                    },
                    {
                        "username": "Rajkumar_007",
                        "content": "Hint : Find number of clusters"
                    },
                    {
                        "username": "hosua",
                        "content": "Weird, I tried solving this with BFS and got TLE, but it worked fine with DFS. Anyone understand why?"
                    },
                    {
                        "username": "hosua",
                        "content": "[@Crispy_coffee](/Crispy_coffee) I did something similar to this and got TLE"
                    },
                    {
                        "username": "czjnbb",
                        "content": "My py BFS beated more than 80%."
                    },
                    {
                        "username": "try_solving_hard",
                        "content": "Here\\'s my BFS submisson. #referrence Accepted in 1st attempt itself. #pride.\\n\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        \\n        // Find total number of connected components\\n        // Indegree / outdegree sum of all nodes in a connected component\\n        // Find total no of extra cables => (degree sum - required)/2\\n        // where required = (nodes in connected component - 1) * 2\\n        // If extra cables >= connected components - 1\\n        //      return connected components - 1\\n        // Else, \\n        //      return - 1\\n\\n        // Construct Graph\\n\\n        vector<int> adj[n];\\n        vector<long long> deg(n, 0);\\n\\n        for(auto c : connections)\\n        {\\n            adj[c[0]].push_back(c[1]);\\n            adj[c[1]].push_back(c[0]);\\n            deg[c[0]]++;\\n            deg[c[1]]++;\\n        }\\n\\n        vector<bool> vis(n, false);\\n        int cc = 0, extra = 0;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            if (!vis[i])\\n            {\\n                cc++;\\n                long long degree_sum = 0;\\n                int nodes = 0;\\n                vis[i] = true;\\n\\n                queue<int> q({i});\\n\\n                while(!q.empty())\\n                {\\n                    auto v = q.front();\\n                    q.pop();\\n\\n                    nodes++;\\n\\n                    degree_sum += deg[v];\\n\\n                    for(auto nbr : adj[v])\\n                    {\\n                        if (!vis[nbr])\\n                        {\\n                            vis[nbr] = true;\\n                            q.push(nbr);\\n\\n                        }\\n                    }\\n                }\\n\\n                int curr_ex = (degree_sum - ((nodes - 1) * 2)) / 2;\\n                extra += curr_ex;\\n            }\\n        }\\n\\n        return extra >= cc - 1 ? cc - 1 : -1;\\n\\n    }\\n};"
                    },
                    {
                        "username": "RamilZaripov",
                        "content": "I had a TLE on my BFS attempt, after reading your comment also switched to DFS and everything worked!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "I saw your comment and after submmiting my DFS approach i find this solution in submitted solution graph\\n\\n```c++\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& c) \\n    {\\n        if(c.size() < n -1) return -1;\\n        vector<int> adj[n];\\n        for(auto it : c)   \\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        } \\n\\n        int ct = 0;\\n        queue<int> q;\\n        vector<int> vis(n, 0);\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(!vis[i])\\n            {\\n                q.push(i);\\n                vis[i] = 1;\\n                while(!q.empty())\\n                {\\n                    int node = q.front();\\n                    q.pop();\\n                    for(auto it : adj[node])\\n                    {\\n                        if(!vis[it])\\n                        {\\n                            q.push(it);\\n                            vis[it] = 1;\\n                        }\\n                    }\\n                }\\n                ct++;\\n            }\\n        }\\n        return ct-1; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "cJayesh",
                        "content": "This happened with me in python.\nBFS uses more space than DFS.\nAlso depending on implementation, BFS has more add_to_list/add_to_set/enqueue/dequeue operations than DFS.\n"
                    },
                    {
                        "username": "user2575jO",
                        "content": "If `n==1` we will have `1 <= connections.length <= 0`. So this test case will not work."
                    },
                    {
                        "username": "Krrabs",
                        "content": "Union Find approach:\nGo through all the given connections and connect `connections[i][a] to connections[i][b]` pairs if `a & b` are already in a same graph you have an extra edge which can be used for connecting unconnected graphs.\n\nAt the end of `connections array` you should have count of extra edges and unconnected graphs, from these two information you can calculate the answer."
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "I thought about finding Indegree of each node (i.e. number of incoming edges) and then the count of nodes with 0 indegree(no incoming edge) shouldn\\'t it be the answer? It fails some testcases. (Yes, I have considered the case where number of wires are less than n-1) "
                    },
                    {
                        "username": "saichandra004",
                        "content": "Let's suppose we have 100 nodes.\n\n50 nodes are connected in a network.\nother 50 nodes are connected in another network (disjoint graph).\n\nFor the whole 100 nodes to be connected, we need 1 connection to join these two independent networks.\n\nBut if we only count the indegree, this seems that all the nodes are connected, but in reality, there are two different networks. Hence this indegree will lead to answers lesser than expected."
                    }
                ]
            },
            {
                "id": 1840994,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Switch to wireless technology to avoid such type of problems in life "
                    },
                    {
                        "username": "RCchoudhary",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE00 Nice"
                    },
                    {
                        "username": "hahahamid",
                        "content": "real"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "big bren"
                    },
                    {
                        "username": "santanusen",
                        "content": "Ha ha! On a serious note, the backbone networks are still wired, involving optical cables. Though they do have satellite links as emergency failover, those have terrible latencies."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@TsuruLee](/TsuruLee) now deal with 3D Array \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "I think they will create new problems about something like where to place the router to make the signal cover all devices"
                    },
                    {
                        "username": "kaskabay",
                        "content": "Test case:\\n100\\n[[17,51],[33,83],[53,62],[25,34],[35,90],[29,41],[14,53],[40,84],[41,64],[13,68],[44,85],[57,58],[50,74],[20,69],[15,62],[25,88],[4,56],[37,39],[30,62],[69,79],[33,85],[24,83],[35,77],[2,73],[6,28],[46,98],[11,82],[29,72],[67,71],[12,49],[42,56],[56,65],[40,70],[24,64],[29,51],[20,27],[45,88],[58,92],[60,99],[33,46],[19,69],[33,89],[54,82],[16,50],[35,73],[19,45],[19,72],[1,79],[27,80],[22,41],[52,61],[50,85],[27,45],[4,84],[11,96],[0,99],[29,94],[9,19],[66,99],[20,39],[16,85],[12,27],[16,67],[61,80],[67,83],[16,17],[24,27],[16,25],[41,79],[51,95],[46,47],[27,51],[31,44],[0,69],[61,63],[33,95],[17,88],[70,87],[40,42],[21,42],[67,77],[33,65],[3,25],[39,83],[34,40],[15,79],[30,90],[58,95],[45,56],[37,48],[24,91],[31,93],[83,90],[17,86],[61,65],[15,48],[34,56],[12,26],[39,98],[1,48],[21,76],[72,96],[30,69],[46,80],[6,29],[29,81],[22,77],[85,90],[79,83],[6,26],[33,57],[3,65],[63,84],[77,94],[26,90],[64,77],[0,3],[27,97],[66,89],[18,77],[27,43]]\\n\\nThe test case above have 88 already connected computers and 121 cables. So, we only need 12 (100-88) computers to be connected or in other words maximum of 12 cables relocated. How is that possible that answer is 13? It seems that it is not optimal way. I may be wrong in assumtions, if so please let me know."
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "suppose you have 6 computers 123 are connected in a straight line [1-2-3] & all others are connected in the same way [4-5-6] although all computers are connected the answer will be -1 because we cannot reach 4 5 6 starting at 1 2 3"
                    },
                    {
                        "username": "sainadth1123434",
                        "content": "Yeah thats correct even i got this error donno if the solution provided correct or not"
                    },
                    {
                        "username": "ramakiran",
                        "content": "[@ramakiran](/ramakiran) \\nthis is the shorter version of above case there will be 2 connected components so the answer will be 1 \\n"
                    },
                    {
                        "username": "ramakiran",
                        "content": "[@rockstar4095](/rockstar4095)   \\nn=6\\n[[0,1],[0,2],[1,2],[3,4],[4,5]]"
                    },
                    {
                        "username": "pramod74",
                        "content": "[@rockstar4095](/rockstar4095) Absolutely, that\\'s what is puzzling me aIso. Not sure if the question needs to be reworded to make this clear! "
                    },
                    {
                        "username": "B0PD0P",
                        "content": "[@kunadilov](/kunadilov)  we have 12 computers that are not connected, then we need at minimum 11 edges to connect these 12 computers with each other and then one extra edge to connect this component to the original component, shouldn't the answer be 12 ?"
                    },
                    {
                        "username": "kunadilov",
                        "content": "[@rockstar4095](/rockstar4095) This 88 computers connected in 2 different networks. So, you have 87 connected and 2 connected between each other. In a result you need minimum 13 connections. "
                    },
                    {
                        "username": "rockstar4095",
                        "content": "same problem with 100-88 computers.\n\ncan anyone provide a smaller example for this configuration?\nare there two or more initial networks actually  instead of one?\n\nI have a very nice 10-lines solution and it fails on this testcase))"
                    },
                    {
                        "username": "rockstar4095",
                        "content": "[@rush2rain](/rush2rain) \\n\\nfrom description:\\n\\n\"Any computer can reach any other computer directly or indirectly through the network.\"\\n\\n\"You are given an initial computer network connections.\"\\n\\naccording to this description, all the initial given computers must be connected."
                    },
                    {
                        "username": "jasona",
                        "content": "[@rush2rain](/rush2rain) ahh thanks! they need to introduce a smaller test case demonstrating that "
                    },
                    {
                        "username": "rush2rain",
                        "content": "Previously, I also attempted the same way. But there happens to be one flaw. What if 88 connected computers are making two separate components of 44 systems each. In that case, we need a wire to connect the two components together as well. So, we need to count the number of components that the whole set of computers is making. "
                    },
                    {
                        "username": "yyol",
                        "content": "same question"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one whose mind screwed up on this question ?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "you just need two things .\\n1. n-1>connections.length  return -1  (don\\'t have enough edge to connect all)\\n2. find number of connected components , return count-1"
                    },
                    {
                        "username": "thatsassygurl21",
                        "content": "Java implentation of your approach:\\nclass Solution {\\n    public int makeConnected(int n, int[][] con){\\n     if(con.length<n-1)return -1;\\n     List<List<Integer>> adj=new ArrayList<>();\\n     for(int i=0;i<n;i++)adj.add(new ArrayList<>());\\n     for(int i=0;i<con.length;i++)\\n     {\\n         adj.get(con[i][0]).add(con[i][1]);\\n          adj.get(con[i][1]).add(con[i][0]);\\n     }\\n     int ans=0;\\n     int vis[]=new int[n];\\n     for(int i=0;i<n;i++)\\n\\n     {\\n         if(vis[i]==0)\\n         {\\n             ans++;\\n             dfs(vis, adj,i);\\n         }   \\n    }\\n    return ans-1;\\n\\n\\n}\\n\\nvoid dfs(int []vis,List<List<Integer>> adj, int n )\\n{\\n    vis[n]=1;\\n    for(int i=0;i<adj.get(n).size();i++)\\n    {\\n    if(vis[adj.get(n).get(i)]==0)\\n    {\\n        dfs(vis,adj,adj.get(n).get(i));\\n    }\\n    }\\n}}"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@daveamol](/daveamol) What is count you are talking about, is it number of disconnected systems?"
                    },
                    {
                        "username": "daveamol",
                        "content": "This is the check I was looking for. That the total numbers of edges for every node to be connected has to be at least (n-1). As minimum edges required to connect n nodes is n-1.\\n\\nI wrote the check like this instead for clarity -\\nconnections.length >= n - 1, then return count - 1, else return -1"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Union Find week ? We are ready!"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "[@UchihaKim](/UchihaKim) you can determine if the node are having same parent node using find(), so if you find the edges are repeated, that mean you can swap that edge to connect other node."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "[@hiper2d](/hiper2d) I solve yesterday question using BFS then I took a look on the related topics and found Union Find, I am still learning it for now,  I can solve the problem using DFS but I want to solve it with that beautiful  DS. If you can give me some tips I\\'d be grateful if you help me."
                    },
                    {
                        "username": "hiper2d",
                        "content": "Same thing here. I keep using Union Find without even considering DFS and BFS. For some reason, this data structure is more obvious solution"
                    },
                    {
                        "username": "Rajkumar_007",
                        "content": "Hint : Find number of clusters"
                    },
                    {
                        "username": "hosua",
                        "content": "Weird, I tried solving this with BFS and got TLE, but it worked fine with DFS. Anyone understand why?"
                    },
                    {
                        "username": "hosua",
                        "content": "[@Crispy_coffee](/Crispy_coffee) I did something similar to this and got TLE"
                    },
                    {
                        "username": "czjnbb",
                        "content": "My py BFS beated more than 80%."
                    },
                    {
                        "username": "try_solving_hard",
                        "content": "Here\\'s my BFS submisson. #referrence Accepted in 1st attempt itself. #pride.\\n\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        \\n        // Find total number of connected components\\n        // Indegree / outdegree sum of all nodes in a connected component\\n        // Find total no of extra cables => (degree sum - required)/2\\n        // where required = (nodes in connected component - 1) * 2\\n        // If extra cables >= connected components - 1\\n        //      return connected components - 1\\n        // Else, \\n        //      return - 1\\n\\n        // Construct Graph\\n\\n        vector<int> adj[n];\\n        vector<long long> deg(n, 0);\\n\\n        for(auto c : connections)\\n        {\\n            adj[c[0]].push_back(c[1]);\\n            adj[c[1]].push_back(c[0]);\\n            deg[c[0]]++;\\n            deg[c[1]]++;\\n        }\\n\\n        vector<bool> vis(n, false);\\n        int cc = 0, extra = 0;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            if (!vis[i])\\n            {\\n                cc++;\\n                long long degree_sum = 0;\\n                int nodes = 0;\\n                vis[i] = true;\\n\\n                queue<int> q({i});\\n\\n                while(!q.empty())\\n                {\\n                    auto v = q.front();\\n                    q.pop();\\n\\n                    nodes++;\\n\\n                    degree_sum += deg[v];\\n\\n                    for(auto nbr : adj[v])\\n                    {\\n                        if (!vis[nbr])\\n                        {\\n                            vis[nbr] = true;\\n                            q.push(nbr);\\n\\n                        }\\n                    }\\n                }\\n\\n                int curr_ex = (degree_sum - ((nodes - 1) * 2)) / 2;\\n                extra += curr_ex;\\n            }\\n        }\\n\\n        return extra >= cc - 1 ? cc - 1 : -1;\\n\\n    }\\n};"
                    },
                    {
                        "username": "RamilZaripov",
                        "content": "I had a TLE on my BFS attempt, after reading your comment also switched to DFS and everything worked!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "I saw your comment and after submmiting my DFS approach i find this solution in submitted solution graph\\n\\n```c++\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& c) \\n    {\\n        if(c.size() < n -1) return -1;\\n        vector<int> adj[n];\\n        for(auto it : c)   \\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        } \\n\\n        int ct = 0;\\n        queue<int> q;\\n        vector<int> vis(n, 0);\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(!vis[i])\\n            {\\n                q.push(i);\\n                vis[i] = 1;\\n                while(!q.empty())\\n                {\\n                    int node = q.front();\\n                    q.pop();\\n                    for(auto it : adj[node])\\n                    {\\n                        if(!vis[it])\\n                        {\\n                            q.push(it);\\n                            vis[it] = 1;\\n                        }\\n                    }\\n                }\\n                ct++;\\n            }\\n        }\\n        return ct-1; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "cJayesh",
                        "content": "This happened with me in python.\nBFS uses more space than DFS.\nAlso depending on implementation, BFS has more add_to_list/add_to_set/enqueue/dequeue operations than DFS.\n"
                    },
                    {
                        "username": "user2575jO",
                        "content": "If `n==1` we will have `1 <= connections.length <= 0`. So this test case will not work."
                    },
                    {
                        "username": "Krrabs",
                        "content": "Union Find approach:\nGo through all the given connections and connect `connections[i][a] to connections[i][b]` pairs if `a & b` are already in a same graph you have an extra edge which can be used for connecting unconnected graphs.\n\nAt the end of `connections array` you should have count of extra edges and unconnected graphs, from these two information you can calculate the answer."
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "I thought about finding Indegree of each node (i.e. number of incoming edges) and then the count of nodes with 0 indegree(no incoming edge) shouldn\\'t it be the answer? It fails some testcases. (Yes, I have considered the case where number of wires are less than n-1) "
                    },
                    {
                        "username": "saichandra004",
                        "content": "Let's suppose we have 100 nodes.\n\n50 nodes are connected in a network.\nother 50 nodes are connected in another network (disjoint graph).\n\nFor the whole 100 nodes to be connected, we need 1 connection to join these two independent networks.\n\nBut if we only count the indegree, this seems that all the nodes are connected, but in reality, there are two different networks. Hence this indegree will lead to answers lesser than expected."
                    }
                ]
            },
            {
                "id": 1841051,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Switch to wireless technology to avoid such type of problems in life "
                    },
                    {
                        "username": "RCchoudhary",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE00 Nice"
                    },
                    {
                        "username": "hahahamid",
                        "content": "real"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "big bren"
                    },
                    {
                        "username": "santanusen",
                        "content": "Ha ha! On a serious note, the backbone networks are still wired, involving optical cables. Though they do have satellite links as emergency failover, those have terrible latencies."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@TsuruLee](/TsuruLee) now deal with 3D Array \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "I think they will create new problems about something like where to place the router to make the signal cover all devices"
                    },
                    {
                        "username": "kaskabay",
                        "content": "Test case:\\n100\\n[[17,51],[33,83],[53,62],[25,34],[35,90],[29,41],[14,53],[40,84],[41,64],[13,68],[44,85],[57,58],[50,74],[20,69],[15,62],[25,88],[4,56],[37,39],[30,62],[69,79],[33,85],[24,83],[35,77],[2,73],[6,28],[46,98],[11,82],[29,72],[67,71],[12,49],[42,56],[56,65],[40,70],[24,64],[29,51],[20,27],[45,88],[58,92],[60,99],[33,46],[19,69],[33,89],[54,82],[16,50],[35,73],[19,45],[19,72],[1,79],[27,80],[22,41],[52,61],[50,85],[27,45],[4,84],[11,96],[0,99],[29,94],[9,19],[66,99],[20,39],[16,85],[12,27],[16,67],[61,80],[67,83],[16,17],[24,27],[16,25],[41,79],[51,95],[46,47],[27,51],[31,44],[0,69],[61,63],[33,95],[17,88],[70,87],[40,42],[21,42],[67,77],[33,65],[3,25],[39,83],[34,40],[15,79],[30,90],[58,95],[45,56],[37,48],[24,91],[31,93],[83,90],[17,86],[61,65],[15,48],[34,56],[12,26],[39,98],[1,48],[21,76],[72,96],[30,69],[46,80],[6,29],[29,81],[22,77],[85,90],[79,83],[6,26],[33,57],[3,65],[63,84],[77,94],[26,90],[64,77],[0,3],[27,97],[66,89],[18,77],[27,43]]\\n\\nThe test case above have 88 already connected computers and 121 cables. So, we only need 12 (100-88) computers to be connected or in other words maximum of 12 cables relocated. How is that possible that answer is 13? It seems that it is not optimal way. I may be wrong in assumtions, if so please let me know."
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "suppose you have 6 computers 123 are connected in a straight line [1-2-3] & all others are connected in the same way [4-5-6] although all computers are connected the answer will be -1 because we cannot reach 4 5 6 starting at 1 2 3"
                    },
                    {
                        "username": "sainadth1123434",
                        "content": "Yeah thats correct even i got this error donno if the solution provided correct or not"
                    },
                    {
                        "username": "ramakiran",
                        "content": "[@ramakiran](/ramakiran) \\nthis is the shorter version of above case there will be 2 connected components so the answer will be 1 \\n"
                    },
                    {
                        "username": "ramakiran",
                        "content": "[@rockstar4095](/rockstar4095)   \\nn=6\\n[[0,1],[0,2],[1,2],[3,4],[4,5]]"
                    },
                    {
                        "username": "pramod74",
                        "content": "[@rockstar4095](/rockstar4095) Absolutely, that\\'s what is puzzling me aIso. Not sure if the question needs to be reworded to make this clear! "
                    },
                    {
                        "username": "B0PD0P",
                        "content": "[@kunadilov](/kunadilov)  we have 12 computers that are not connected, then we need at minimum 11 edges to connect these 12 computers with each other and then one extra edge to connect this component to the original component, shouldn't the answer be 12 ?"
                    },
                    {
                        "username": "kunadilov",
                        "content": "[@rockstar4095](/rockstar4095) This 88 computers connected in 2 different networks. So, you have 87 connected and 2 connected between each other. In a result you need minimum 13 connections. "
                    },
                    {
                        "username": "rockstar4095",
                        "content": "same problem with 100-88 computers.\n\ncan anyone provide a smaller example for this configuration?\nare there two or more initial networks actually  instead of one?\n\nI have a very nice 10-lines solution and it fails on this testcase))"
                    },
                    {
                        "username": "rockstar4095",
                        "content": "[@rush2rain](/rush2rain) \\n\\nfrom description:\\n\\n\"Any computer can reach any other computer directly or indirectly through the network.\"\\n\\n\"You are given an initial computer network connections.\"\\n\\naccording to this description, all the initial given computers must be connected."
                    },
                    {
                        "username": "jasona",
                        "content": "[@rush2rain](/rush2rain) ahh thanks! they need to introduce a smaller test case demonstrating that "
                    },
                    {
                        "username": "rush2rain",
                        "content": "Previously, I also attempted the same way. But there happens to be one flaw. What if 88 connected computers are making two separate components of 44 systems each. In that case, we need a wire to connect the two components together as well. So, we need to count the number of components that the whole set of computers is making. "
                    },
                    {
                        "username": "yyol",
                        "content": "same question"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one whose mind screwed up on this question ?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "you just need two things .\\n1. n-1>connections.length  return -1  (don\\'t have enough edge to connect all)\\n2. find number of connected components , return count-1"
                    },
                    {
                        "username": "thatsassygurl21",
                        "content": "Java implentation of your approach:\\nclass Solution {\\n    public int makeConnected(int n, int[][] con){\\n     if(con.length<n-1)return -1;\\n     List<List<Integer>> adj=new ArrayList<>();\\n     for(int i=0;i<n;i++)adj.add(new ArrayList<>());\\n     for(int i=0;i<con.length;i++)\\n     {\\n         adj.get(con[i][0]).add(con[i][1]);\\n          adj.get(con[i][1]).add(con[i][0]);\\n     }\\n     int ans=0;\\n     int vis[]=new int[n];\\n     for(int i=0;i<n;i++)\\n\\n     {\\n         if(vis[i]==0)\\n         {\\n             ans++;\\n             dfs(vis, adj,i);\\n         }   \\n    }\\n    return ans-1;\\n\\n\\n}\\n\\nvoid dfs(int []vis,List<List<Integer>> adj, int n )\\n{\\n    vis[n]=1;\\n    for(int i=0;i<adj.get(n).size();i++)\\n    {\\n    if(vis[adj.get(n).get(i)]==0)\\n    {\\n        dfs(vis,adj,adj.get(n).get(i));\\n    }\\n    }\\n}}"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@daveamol](/daveamol) What is count you are talking about, is it number of disconnected systems?"
                    },
                    {
                        "username": "daveamol",
                        "content": "This is the check I was looking for. That the total numbers of edges for every node to be connected has to be at least (n-1). As minimum edges required to connect n nodes is n-1.\\n\\nI wrote the check like this instead for clarity -\\nconnections.length >= n - 1, then return count - 1, else return -1"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Union Find week ? We are ready!"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "[@UchihaKim](/UchihaKim) you can determine if the node are having same parent node using find(), so if you find the edges are repeated, that mean you can swap that edge to connect other node."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "[@hiper2d](/hiper2d) I solve yesterday question using BFS then I took a look on the related topics and found Union Find, I am still learning it for now,  I can solve the problem using DFS but I want to solve it with that beautiful  DS. If you can give me some tips I\\'d be grateful if you help me."
                    },
                    {
                        "username": "hiper2d",
                        "content": "Same thing here. I keep using Union Find without even considering DFS and BFS. For some reason, this data structure is more obvious solution"
                    },
                    {
                        "username": "Rajkumar_007",
                        "content": "Hint : Find number of clusters"
                    },
                    {
                        "username": "hosua",
                        "content": "Weird, I tried solving this with BFS and got TLE, but it worked fine with DFS. Anyone understand why?"
                    },
                    {
                        "username": "hosua",
                        "content": "[@Crispy_coffee](/Crispy_coffee) I did something similar to this and got TLE"
                    },
                    {
                        "username": "czjnbb",
                        "content": "My py BFS beated more than 80%."
                    },
                    {
                        "username": "try_solving_hard",
                        "content": "Here\\'s my BFS submisson. #referrence Accepted in 1st attempt itself. #pride.\\n\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        \\n        // Find total number of connected components\\n        // Indegree / outdegree sum of all nodes in a connected component\\n        // Find total no of extra cables => (degree sum - required)/2\\n        // where required = (nodes in connected component - 1) * 2\\n        // If extra cables >= connected components - 1\\n        //      return connected components - 1\\n        // Else, \\n        //      return - 1\\n\\n        // Construct Graph\\n\\n        vector<int> adj[n];\\n        vector<long long> deg(n, 0);\\n\\n        for(auto c : connections)\\n        {\\n            adj[c[0]].push_back(c[1]);\\n            adj[c[1]].push_back(c[0]);\\n            deg[c[0]]++;\\n            deg[c[1]]++;\\n        }\\n\\n        vector<bool> vis(n, false);\\n        int cc = 0, extra = 0;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            if (!vis[i])\\n            {\\n                cc++;\\n                long long degree_sum = 0;\\n                int nodes = 0;\\n                vis[i] = true;\\n\\n                queue<int> q({i});\\n\\n                while(!q.empty())\\n                {\\n                    auto v = q.front();\\n                    q.pop();\\n\\n                    nodes++;\\n\\n                    degree_sum += deg[v];\\n\\n                    for(auto nbr : adj[v])\\n                    {\\n                        if (!vis[nbr])\\n                        {\\n                            vis[nbr] = true;\\n                            q.push(nbr);\\n\\n                        }\\n                    }\\n                }\\n\\n                int curr_ex = (degree_sum - ((nodes - 1) * 2)) / 2;\\n                extra += curr_ex;\\n            }\\n        }\\n\\n        return extra >= cc - 1 ? cc - 1 : -1;\\n\\n    }\\n};"
                    },
                    {
                        "username": "RamilZaripov",
                        "content": "I had a TLE on my BFS attempt, after reading your comment also switched to DFS and everything worked!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "I saw your comment and after submmiting my DFS approach i find this solution in submitted solution graph\\n\\n```c++\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& c) \\n    {\\n        if(c.size() < n -1) return -1;\\n        vector<int> adj[n];\\n        for(auto it : c)   \\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        } \\n\\n        int ct = 0;\\n        queue<int> q;\\n        vector<int> vis(n, 0);\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(!vis[i])\\n            {\\n                q.push(i);\\n                vis[i] = 1;\\n                while(!q.empty())\\n                {\\n                    int node = q.front();\\n                    q.pop();\\n                    for(auto it : adj[node])\\n                    {\\n                        if(!vis[it])\\n                        {\\n                            q.push(it);\\n                            vis[it] = 1;\\n                        }\\n                    }\\n                }\\n                ct++;\\n            }\\n        }\\n        return ct-1; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "cJayesh",
                        "content": "This happened with me in python.\nBFS uses more space than DFS.\nAlso depending on implementation, BFS has more add_to_list/add_to_set/enqueue/dequeue operations than DFS.\n"
                    },
                    {
                        "username": "user2575jO",
                        "content": "If `n==1` we will have `1 <= connections.length <= 0`. So this test case will not work."
                    },
                    {
                        "username": "Krrabs",
                        "content": "Union Find approach:\nGo through all the given connections and connect `connections[i][a] to connections[i][b]` pairs if `a & b` are already in a same graph you have an extra edge which can be used for connecting unconnected graphs.\n\nAt the end of `connections array` you should have count of extra edges and unconnected graphs, from these two information you can calculate the answer."
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "I thought about finding Indegree of each node (i.e. number of incoming edges) and then the count of nodes with 0 indegree(no incoming edge) shouldn\\'t it be the answer? It fails some testcases. (Yes, I have considered the case where number of wires are less than n-1) "
                    },
                    {
                        "username": "saichandra004",
                        "content": "Let's suppose we have 100 nodes.\n\n50 nodes are connected in a network.\nother 50 nodes are connected in another network (disjoint graph).\n\nFor the whole 100 nodes to be connected, we need 1 connection to join these two independent networks.\n\nBut if we only count the indegree, this seems that all the nodes are connected, but in reality, there are two different networks. Hence this indegree will lead to answers lesser than expected."
                    }
                ]
            },
            {
                "id": 1841217,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Switch to wireless technology to avoid such type of problems in life "
                    },
                    {
                        "username": "RCchoudhary",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE00 Nice"
                    },
                    {
                        "username": "hahahamid",
                        "content": "real"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "big bren"
                    },
                    {
                        "username": "santanusen",
                        "content": "Ha ha! On a serious note, the backbone networks are still wired, involving optical cables. Though they do have satellite links as emergency failover, those have terrible latencies."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@TsuruLee](/TsuruLee) now deal with 3D Array \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "I think they will create new problems about something like where to place the router to make the signal cover all devices"
                    },
                    {
                        "username": "kaskabay",
                        "content": "Test case:\\n100\\n[[17,51],[33,83],[53,62],[25,34],[35,90],[29,41],[14,53],[40,84],[41,64],[13,68],[44,85],[57,58],[50,74],[20,69],[15,62],[25,88],[4,56],[37,39],[30,62],[69,79],[33,85],[24,83],[35,77],[2,73],[6,28],[46,98],[11,82],[29,72],[67,71],[12,49],[42,56],[56,65],[40,70],[24,64],[29,51],[20,27],[45,88],[58,92],[60,99],[33,46],[19,69],[33,89],[54,82],[16,50],[35,73],[19,45],[19,72],[1,79],[27,80],[22,41],[52,61],[50,85],[27,45],[4,84],[11,96],[0,99],[29,94],[9,19],[66,99],[20,39],[16,85],[12,27],[16,67],[61,80],[67,83],[16,17],[24,27],[16,25],[41,79],[51,95],[46,47],[27,51],[31,44],[0,69],[61,63],[33,95],[17,88],[70,87],[40,42],[21,42],[67,77],[33,65],[3,25],[39,83],[34,40],[15,79],[30,90],[58,95],[45,56],[37,48],[24,91],[31,93],[83,90],[17,86],[61,65],[15,48],[34,56],[12,26],[39,98],[1,48],[21,76],[72,96],[30,69],[46,80],[6,29],[29,81],[22,77],[85,90],[79,83],[6,26],[33,57],[3,65],[63,84],[77,94],[26,90],[64,77],[0,3],[27,97],[66,89],[18,77],[27,43]]\\n\\nThe test case above have 88 already connected computers and 121 cables. So, we only need 12 (100-88) computers to be connected or in other words maximum of 12 cables relocated. How is that possible that answer is 13? It seems that it is not optimal way. I may be wrong in assumtions, if so please let me know."
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "suppose you have 6 computers 123 are connected in a straight line [1-2-3] & all others are connected in the same way [4-5-6] although all computers are connected the answer will be -1 because we cannot reach 4 5 6 starting at 1 2 3"
                    },
                    {
                        "username": "sainadth1123434",
                        "content": "Yeah thats correct even i got this error donno if the solution provided correct or not"
                    },
                    {
                        "username": "ramakiran",
                        "content": "[@ramakiran](/ramakiran) \\nthis is the shorter version of above case there will be 2 connected components so the answer will be 1 \\n"
                    },
                    {
                        "username": "ramakiran",
                        "content": "[@rockstar4095](/rockstar4095)   \\nn=6\\n[[0,1],[0,2],[1,2],[3,4],[4,5]]"
                    },
                    {
                        "username": "pramod74",
                        "content": "[@rockstar4095](/rockstar4095) Absolutely, that\\'s what is puzzling me aIso. Not sure if the question needs to be reworded to make this clear! "
                    },
                    {
                        "username": "B0PD0P",
                        "content": "[@kunadilov](/kunadilov)  we have 12 computers that are not connected, then we need at minimum 11 edges to connect these 12 computers with each other and then one extra edge to connect this component to the original component, shouldn't the answer be 12 ?"
                    },
                    {
                        "username": "kunadilov",
                        "content": "[@rockstar4095](/rockstar4095) This 88 computers connected in 2 different networks. So, you have 87 connected and 2 connected between each other. In a result you need minimum 13 connections. "
                    },
                    {
                        "username": "rockstar4095",
                        "content": "same problem with 100-88 computers.\n\ncan anyone provide a smaller example for this configuration?\nare there two or more initial networks actually  instead of one?\n\nI have a very nice 10-lines solution and it fails on this testcase))"
                    },
                    {
                        "username": "rockstar4095",
                        "content": "[@rush2rain](/rush2rain) \\n\\nfrom description:\\n\\n\"Any computer can reach any other computer directly or indirectly through the network.\"\\n\\n\"You are given an initial computer network connections.\"\\n\\naccording to this description, all the initial given computers must be connected."
                    },
                    {
                        "username": "jasona",
                        "content": "[@rush2rain](/rush2rain) ahh thanks! they need to introduce a smaller test case demonstrating that "
                    },
                    {
                        "username": "rush2rain",
                        "content": "Previously, I also attempted the same way. But there happens to be one flaw. What if 88 connected computers are making two separate components of 44 systems each. In that case, we need a wire to connect the two components together as well. So, we need to count the number of components that the whole set of computers is making. "
                    },
                    {
                        "username": "yyol",
                        "content": "same question"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one whose mind screwed up on this question ?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "you just need two things .\\n1. n-1>connections.length  return -1  (don\\'t have enough edge to connect all)\\n2. find number of connected components , return count-1"
                    },
                    {
                        "username": "thatsassygurl21",
                        "content": "Java implentation of your approach:\\nclass Solution {\\n    public int makeConnected(int n, int[][] con){\\n     if(con.length<n-1)return -1;\\n     List<List<Integer>> adj=new ArrayList<>();\\n     for(int i=0;i<n;i++)adj.add(new ArrayList<>());\\n     for(int i=0;i<con.length;i++)\\n     {\\n         adj.get(con[i][0]).add(con[i][1]);\\n          adj.get(con[i][1]).add(con[i][0]);\\n     }\\n     int ans=0;\\n     int vis[]=new int[n];\\n     for(int i=0;i<n;i++)\\n\\n     {\\n         if(vis[i]==0)\\n         {\\n             ans++;\\n             dfs(vis, adj,i);\\n         }   \\n    }\\n    return ans-1;\\n\\n\\n}\\n\\nvoid dfs(int []vis,List<List<Integer>> adj, int n )\\n{\\n    vis[n]=1;\\n    for(int i=0;i<adj.get(n).size();i++)\\n    {\\n    if(vis[adj.get(n).get(i)]==0)\\n    {\\n        dfs(vis,adj,adj.get(n).get(i));\\n    }\\n    }\\n}}"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@daveamol](/daveamol) What is count you are talking about, is it number of disconnected systems?"
                    },
                    {
                        "username": "daveamol",
                        "content": "This is the check I was looking for. That the total numbers of edges for every node to be connected has to be at least (n-1). As minimum edges required to connect n nodes is n-1.\\n\\nI wrote the check like this instead for clarity -\\nconnections.length >= n - 1, then return count - 1, else return -1"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Union Find week ? We are ready!"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "[@UchihaKim](/UchihaKim) you can determine if the node are having same parent node using find(), so if you find the edges are repeated, that mean you can swap that edge to connect other node."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "[@hiper2d](/hiper2d) I solve yesterday question using BFS then I took a look on the related topics and found Union Find, I am still learning it for now,  I can solve the problem using DFS but I want to solve it with that beautiful  DS. If you can give me some tips I\\'d be grateful if you help me."
                    },
                    {
                        "username": "hiper2d",
                        "content": "Same thing here. I keep using Union Find without even considering DFS and BFS. For some reason, this data structure is more obvious solution"
                    },
                    {
                        "username": "Rajkumar_007",
                        "content": "Hint : Find number of clusters"
                    },
                    {
                        "username": "hosua",
                        "content": "Weird, I tried solving this with BFS and got TLE, but it worked fine with DFS. Anyone understand why?"
                    },
                    {
                        "username": "hosua",
                        "content": "[@Crispy_coffee](/Crispy_coffee) I did something similar to this and got TLE"
                    },
                    {
                        "username": "czjnbb",
                        "content": "My py BFS beated more than 80%."
                    },
                    {
                        "username": "try_solving_hard",
                        "content": "Here\\'s my BFS submisson. #referrence Accepted in 1st attempt itself. #pride.\\n\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        \\n        // Find total number of connected components\\n        // Indegree / outdegree sum of all nodes in a connected component\\n        // Find total no of extra cables => (degree sum - required)/2\\n        // where required = (nodes in connected component - 1) * 2\\n        // If extra cables >= connected components - 1\\n        //      return connected components - 1\\n        // Else, \\n        //      return - 1\\n\\n        // Construct Graph\\n\\n        vector<int> adj[n];\\n        vector<long long> deg(n, 0);\\n\\n        for(auto c : connections)\\n        {\\n            adj[c[0]].push_back(c[1]);\\n            adj[c[1]].push_back(c[0]);\\n            deg[c[0]]++;\\n            deg[c[1]]++;\\n        }\\n\\n        vector<bool> vis(n, false);\\n        int cc = 0, extra = 0;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            if (!vis[i])\\n            {\\n                cc++;\\n                long long degree_sum = 0;\\n                int nodes = 0;\\n                vis[i] = true;\\n\\n                queue<int> q({i});\\n\\n                while(!q.empty())\\n                {\\n                    auto v = q.front();\\n                    q.pop();\\n\\n                    nodes++;\\n\\n                    degree_sum += deg[v];\\n\\n                    for(auto nbr : adj[v])\\n                    {\\n                        if (!vis[nbr])\\n                        {\\n                            vis[nbr] = true;\\n                            q.push(nbr);\\n\\n                        }\\n                    }\\n                }\\n\\n                int curr_ex = (degree_sum - ((nodes - 1) * 2)) / 2;\\n                extra += curr_ex;\\n            }\\n        }\\n\\n        return extra >= cc - 1 ? cc - 1 : -1;\\n\\n    }\\n};"
                    },
                    {
                        "username": "RamilZaripov",
                        "content": "I had a TLE on my BFS attempt, after reading your comment also switched to DFS and everything worked!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "I saw your comment and after submmiting my DFS approach i find this solution in submitted solution graph\\n\\n```c++\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& c) \\n    {\\n        if(c.size() < n -1) return -1;\\n        vector<int> adj[n];\\n        for(auto it : c)   \\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        } \\n\\n        int ct = 0;\\n        queue<int> q;\\n        vector<int> vis(n, 0);\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(!vis[i])\\n            {\\n                q.push(i);\\n                vis[i] = 1;\\n                while(!q.empty())\\n                {\\n                    int node = q.front();\\n                    q.pop();\\n                    for(auto it : adj[node])\\n                    {\\n                        if(!vis[it])\\n                        {\\n                            q.push(it);\\n                            vis[it] = 1;\\n                        }\\n                    }\\n                }\\n                ct++;\\n            }\\n        }\\n        return ct-1; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "cJayesh",
                        "content": "This happened with me in python.\nBFS uses more space than DFS.\nAlso depending on implementation, BFS has more add_to_list/add_to_set/enqueue/dequeue operations than DFS.\n"
                    },
                    {
                        "username": "user2575jO",
                        "content": "If `n==1` we will have `1 <= connections.length <= 0`. So this test case will not work."
                    },
                    {
                        "username": "Krrabs",
                        "content": "Union Find approach:\nGo through all the given connections and connect `connections[i][a] to connections[i][b]` pairs if `a & b` are already in a same graph you have an extra edge which can be used for connecting unconnected graphs.\n\nAt the end of `connections array` you should have count of extra edges and unconnected graphs, from these two information you can calculate the answer."
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "I thought about finding Indegree of each node (i.e. number of incoming edges) and then the count of nodes with 0 indegree(no incoming edge) shouldn\\'t it be the answer? It fails some testcases. (Yes, I have considered the case where number of wires are less than n-1) "
                    },
                    {
                        "username": "saichandra004",
                        "content": "Let's suppose we have 100 nodes.\n\n50 nodes are connected in a network.\nother 50 nodes are connected in another network (disjoint graph).\n\nFor the whole 100 nodes to be connected, we need 1 connection to join these two independent networks.\n\nBut if we only count the indegree, this seems that all the nodes are connected, but in reality, there are two different networks. Hence this indegree will lead to answers lesser than expected."
                    }
                ]
            },
            {
                "id": 1840941,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Switch to wireless technology to avoid such type of problems in life "
                    },
                    {
                        "username": "RCchoudhary",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE00 Nice"
                    },
                    {
                        "username": "hahahamid",
                        "content": "real"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "big bren"
                    },
                    {
                        "username": "santanusen",
                        "content": "Ha ha! On a serious note, the backbone networks are still wired, involving optical cables. Though they do have satellite links as emergency failover, those have terrible latencies."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@TsuruLee](/TsuruLee) now deal with 3D Array \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "I think they will create new problems about something like where to place the router to make the signal cover all devices"
                    },
                    {
                        "username": "kaskabay",
                        "content": "Test case:\\n100\\n[[17,51],[33,83],[53,62],[25,34],[35,90],[29,41],[14,53],[40,84],[41,64],[13,68],[44,85],[57,58],[50,74],[20,69],[15,62],[25,88],[4,56],[37,39],[30,62],[69,79],[33,85],[24,83],[35,77],[2,73],[6,28],[46,98],[11,82],[29,72],[67,71],[12,49],[42,56],[56,65],[40,70],[24,64],[29,51],[20,27],[45,88],[58,92],[60,99],[33,46],[19,69],[33,89],[54,82],[16,50],[35,73],[19,45],[19,72],[1,79],[27,80],[22,41],[52,61],[50,85],[27,45],[4,84],[11,96],[0,99],[29,94],[9,19],[66,99],[20,39],[16,85],[12,27],[16,67],[61,80],[67,83],[16,17],[24,27],[16,25],[41,79],[51,95],[46,47],[27,51],[31,44],[0,69],[61,63],[33,95],[17,88],[70,87],[40,42],[21,42],[67,77],[33,65],[3,25],[39,83],[34,40],[15,79],[30,90],[58,95],[45,56],[37,48],[24,91],[31,93],[83,90],[17,86],[61,65],[15,48],[34,56],[12,26],[39,98],[1,48],[21,76],[72,96],[30,69],[46,80],[6,29],[29,81],[22,77],[85,90],[79,83],[6,26],[33,57],[3,65],[63,84],[77,94],[26,90],[64,77],[0,3],[27,97],[66,89],[18,77],[27,43]]\\n\\nThe test case above have 88 already connected computers and 121 cables. So, we only need 12 (100-88) computers to be connected or in other words maximum of 12 cables relocated. How is that possible that answer is 13? It seems that it is not optimal way. I may be wrong in assumtions, if so please let me know."
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "suppose you have 6 computers 123 are connected in a straight line [1-2-3] & all others are connected in the same way [4-5-6] although all computers are connected the answer will be -1 because we cannot reach 4 5 6 starting at 1 2 3"
                    },
                    {
                        "username": "sainadth1123434",
                        "content": "Yeah thats correct even i got this error donno if the solution provided correct or not"
                    },
                    {
                        "username": "ramakiran",
                        "content": "[@ramakiran](/ramakiran) \\nthis is the shorter version of above case there will be 2 connected components so the answer will be 1 \\n"
                    },
                    {
                        "username": "ramakiran",
                        "content": "[@rockstar4095](/rockstar4095)   \\nn=6\\n[[0,1],[0,2],[1,2],[3,4],[4,5]]"
                    },
                    {
                        "username": "pramod74",
                        "content": "[@rockstar4095](/rockstar4095) Absolutely, that\\'s what is puzzling me aIso. Not sure if the question needs to be reworded to make this clear! "
                    },
                    {
                        "username": "B0PD0P",
                        "content": "[@kunadilov](/kunadilov)  we have 12 computers that are not connected, then we need at minimum 11 edges to connect these 12 computers with each other and then one extra edge to connect this component to the original component, shouldn't the answer be 12 ?"
                    },
                    {
                        "username": "kunadilov",
                        "content": "[@rockstar4095](/rockstar4095) This 88 computers connected in 2 different networks. So, you have 87 connected and 2 connected between each other. In a result you need minimum 13 connections. "
                    },
                    {
                        "username": "rockstar4095",
                        "content": "same problem with 100-88 computers.\n\ncan anyone provide a smaller example for this configuration?\nare there two or more initial networks actually  instead of one?\n\nI have a very nice 10-lines solution and it fails on this testcase))"
                    },
                    {
                        "username": "rockstar4095",
                        "content": "[@rush2rain](/rush2rain) \\n\\nfrom description:\\n\\n\"Any computer can reach any other computer directly or indirectly through the network.\"\\n\\n\"You are given an initial computer network connections.\"\\n\\naccording to this description, all the initial given computers must be connected."
                    },
                    {
                        "username": "jasona",
                        "content": "[@rush2rain](/rush2rain) ahh thanks! they need to introduce a smaller test case demonstrating that "
                    },
                    {
                        "username": "rush2rain",
                        "content": "Previously, I also attempted the same way. But there happens to be one flaw. What if 88 connected computers are making two separate components of 44 systems each. In that case, we need a wire to connect the two components together as well. So, we need to count the number of components that the whole set of computers is making. "
                    },
                    {
                        "username": "yyol",
                        "content": "same question"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one whose mind screwed up on this question ?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "you just need two things .\\n1. n-1>connections.length  return -1  (don\\'t have enough edge to connect all)\\n2. find number of connected components , return count-1"
                    },
                    {
                        "username": "thatsassygurl21",
                        "content": "Java implentation of your approach:\\nclass Solution {\\n    public int makeConnected(int n, int[][] con){\\n     if(con.length<n-1)return -1;\\n     List<List<Integer>> adj=new ArrayList<>();\\n     for(int i=0;i<n;i++)adj.add(new ArrayList<>());\\n     for(int i=0;i<con.length;i++)\\n     {\\n         adj.get(con[i][0]).add(con[i][1]);\\n          adj.get(con[i][1]).add(con[i][0]);\\n     }\\n     int ans=0;\\n     int vis[]=new int[n];\\n     for(int i=0;i<n;i++)\\n\\n     {\\n         if(vis[i]==0)\\n         {\\n             ans++;\\n             dfs(vis, adj,i);\\n         }   \\n    }\\n    return ans-1;\\n\\n\\n}\\n\\nvoid dfs(int []vis,List<List<Integer>> adj, int n )\\n{\\n    vis[n]=1;\\n    for(int i=0;i<adj.get(n).size();i++)\\n    {\\n    if(vis[adj.get(n).get(i)]==0)\\n    {\\n        dfs(vis,adj,adj.get(n).get(i));\\n    }\\n    }\\n}}"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@daveamol](/daveamol) What is count you are talking about, is it number of disconnected systems?"
                    },
                    {
                        "username": "daveamol",
                        "content": "This is the check I was looking for. That the total numbers of edges for every node to be connected has to be at least (n-1). As minimum edges required to connect n nodes is n-1.\\n\\nI wrote the check like this instead for clarity -\\nconnections.length >= n - 1, then return count - 1, else return -1"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Union Find week ? We are ready!"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "[@UchihaKim](/UchihaKim) you can determine if the node are having same parent node using find(), so if you find the edges are repeated, that mean you can swap that edge to connect other node."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "[@hiper2d](/hiper2d) I solve yesterday question using BFS then I took a look on the related topics and found Union Find, I am still learning it for now,  I can solve the problem using DFS but I want to solve it with that beautiful  DS. If you can give me some tips I\\'d be grateful if you help me."
                    },
                    {
                        "username": "hiper2d",
                        "content": "Same thing here. I keep using Union Find without even considering DFS and BFS. For some reason, this data structure is more obvious solution"
                    },
                    {
                        "username": "Rajkumar_007",
                        "content": "Hint : Find number of clusters"
                    },
                    {
                        "username": "hosua",
                        "content": "Weird, I tried solving this with BFS and got TLE, but it worked fine with DFS. Anyone understand why?"
                    },
                    {
                        "username": "hosua",
                        "content": "[@Crispy_coffee](/Crispy_coffee) I did something similar to this and got TLE"
                    },
                    {
                        "username": "czjnbb",
                        "content": "My py BFS beated more than 80%."
                    },
                    {
                        "username": "try_solving_hard",
                        "content": "Here\\'s my BFS submisson. #referrence Accepted in 1st attempt itself. #pride.\\n\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        \\n        // Find total number of connected components\\n        // Indegree / outdegree sum of all nodes in a connected component\\n        // Find total no of extra cables => (degree sum - required)/2\\n        // where required = (nodes in connected component - 1) * 2\\n        // If extra cables >= connected components - 1\\n        //      return connected components - 1\\n        // Else, \\n        //      return - 1\\n\\n        // Construct Graph\\n\\n        vector<int> adj[n];\\n        vector<long long> deg(n, 0);\\n\\n        for(auto c : connections)\\n        {\\n            adj[c[0]].push_back(c[1]);\\n            adj[c[1]].push_back(c[0]);\\n            deg[c[0]]++;\\n            deg[c[1]]++;\\n        }\\n\\n        vector<bool> vis(n, false);\\n        int cc = 0, extra = 0;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            if (!vis[i])\\n            {\\n                cc++;\\n                long long degree_sum = 0;\\n                int nodes = 0;\\n                vis[i] = true;\\n\\n                queue<int> q({i});\\n\\n                while(!q.empty())\\n                {\\n                    auto v = q.front();\\n                    q.pop();\\n\\n                    nodes++;\\n\\n                    degree_sum += deg[v];\\n\\n                    for(auto nbr : adj[v])\\n                    {\\n                        if (!vis[nbr])\\n                        {\\n                            vis[nbr] = true;\\n                            q.push(nbr);\\n\\n                        }\\n                    }\\n                }\\n\\n                int curr_ex = (degree_sum - ((nodes - 1) * 2)) / 2;\\n                extra += curr_ex;\\n            }\\n        }\\n\\n        return extra >= cc - 1 ? cc - 1 : -1;\\n\\n    }\\n};"
                    },
                    {
                        "username": "RamilZaripov",
                        "content": "I had a TLE on my BFS attempt, after reading your comment also switched to DFS and everything worked!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "I saw your comment and after submmiting my DFS approach i find this solution in submitted solution graph\\n\\n```c++\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& c) \\n    {\\n        if(c.size() < n -1) return -1;\\n        vector<int> adj[n];\\n        for(auto it : c)   \\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        } \\n\\n        int ct = 0;\\n        queue<int> q;\\n        vector<int> vis(n, 0);\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(!vis[i])\\n            {\\n                q.push(i);\\n                vis[i] = 1;\\n                while(!q.empty())\\n                {\\n                    int node = q.front();\\n                    q.pop();\\n                    for(auto it : adj[node])\\n                    {\\n                        if(!vis[it])\\n                        {\\n                            q.push(it);\\n                            vis[it] = 1;\\n                        }\\n                    }\\n                }\\n                ct++;\\n            }\\n        }\\n        return ct-1; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "cJayesh",
                        "content": "This happened with me in python.\nBFS uses more space than DFS.\nAlso depending on implementation, BFS has more add_to_list/add_to_set/enqueue/dequeue operations than DFS.\n"
                    },
                    {
                        "username": "user2575jO",
                        "content": "If `n==1` we will have `1 <= connections.length <= 0`. So this test case will not work."
                    },
                    {
                        "username": "Krrabs",
                        "content": "Union Find approach:\nGo through all the given connections and connect `connections[i][a] to connections[i][b]` pairs if `a & b` are already in a same graph you have an extra edge which can be used for connecting unconnected graphs.\n\nAt the end of `connections array` you should have count of extra edges and unconnected graphs, from these two information you can calculate the answer."
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "I thought about finding Indegree of each node (i.e. number of incoming edges) and then the count of nodes with 0 indegree(no incoming edge) shouldn\\'t it be the answer? It fails some testcases. (Yes, I have considered the case where number of wires are less than n-1) "
                    },
                    {
                        "username": "saichandra004",
                        "content": "Let's suppose we have 100 nodes.\n\n50 nodes are connected in a network.\nother 50 nodes are connected in another network (disjoint graph).\n\nFor the whole 100 nodes to be connected, we need 1 connection to join these two independent networks.\n\nBut if we only count the indegree, this seems that all the nodes are connected, but in reality, there are two different networks. Hence this indegree will lead to answers lesser than expected."
                    }
                ]
            },
            {
                "id": 1841039,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Switch to wireless technology to avoid such type of problems in life "
                    },
                    {
                        "username": "RCchoudhary",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE00 Nice"
                    },
                    {
                        "username": "hahahamid",
                        "content": "real"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "big bren"
                    },
                    {
                        "username": "santanusen",
                        "content": "Ha ha! On a serious note, the backbone networks are still wired, involving optical cables. Though they do have satellite links as emergency failover, those have terrible latencies."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@TsuruLee](/TsuruLee) now deal with 3D Array \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "I think they will create new problems about something like where to place the router to make the signal cover all devices"
                    },
                    {
                        "username": "kaskabay",
                        "content": "Test case:\\n100\\n[[17,51],[33,83],[53,62],[25,34],[35,90],[29,41],[14,53],[40,84],[41,64],[13,68],[44,85],[57,58],[50,74],[20,69],[15,62],[25,88],[4,56],[37,39],[30,62],[69,79],[33,85],[24,83],[35,77],[2,73],[6,28],[46,98],[11,82],[29,72],[67,71],[12,49],[42,56],[56,65],[40,70],[24,64],[29,51],[20,27],[45,88],[58,92],[60,99],[33,46],[19,69],[33,89],[54,82],[16,50],[35,73],[19,45],[19,72],[1,79],[27,80],[22,41],[52,61],[50,85],[27,45],[4,84],[11,96],[0,99],[29,94],[9,19],[66,99],[20,39],[16,85],[12,27],[16,67],[61,80],[67,83],[16,17],[24,27],[16,25],[41,79],[51,95],[46,47],[27,51],[31,44],[0,69],[61,63],[33,95],[17,88],[70,87],[40,42],[21,42],[67,77],[33,65],[3,25],[39,83],[34,40],[15,79],[30,90],[58,95],[45,56],[37,48],[24,91],[31,93],[83,90],[17,86],[61,65],[15,48],[34,56],[12,26],[39,98],[1,48],[21,76],[72,96],[30,69],[46,80],[6,29],[29,81],[22,77],[85,90],[79,83],[6,26],[33,57],[3,65],[63,84],[77,94],[26,90],[64,77],[0,3],[27,97],[66,89],[18,77],[27,43]]\\n\\nThe test case above have 88 already connected computers and 121 cables. So, we only need 12 (100-88) computers to be connected or in other words maximum of 12 cables relocated. How is that possible that answer is 13? It seems that it is not optimal way. I may be wrong in assumtions, if so please let me know."
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "suppose you have 6 computers 123 are connected in a straight line [1-2-3] & all others are connected in the same way [4-5-6] although all computers are connected the answer will be -1 because we cannot reach 4 5 6 starting at 1 2 3"
                    },
                    {
                        "username": "sainadth1123434",
                        "content": "Yeah thats correct even i got this error donno if the solution provided correct or not"
                    },
                    {
                        "username": "ramakiran",
                        "content": "[@ramakiran](/ramakiran) \\nthis is the shorter version of above case there will be 2 connected components so the answer will be 1 \\n"
                    },
                    {
                        "username": "ramakiran",
                        "content": "[@rockstar4095](/rockstar4095)   \\nn=6\\n[[0,1],[0,2],[1,2],[3,4],[4,5]]"
                    },
                    {
                        "username": "pramod74",
                        "content": "[@rockstar4095](/rockstar4095) Absolutely, that\\'s what is puzzling me aIso. Not sure if the question needs to be reworded to make this clear! "
                    },
                    {
                        "username": "B0PD0P",
                        "content": "[@kunadilov](/kunadilov)  we have 12 computers that are not connected, then we need at minimum 11 edges to connect these 12 computers with each other and then one extra edge to connect this component to the original component, shouldn't the answer be 12 ?"
                    },
                    {
                        "username": "kunadilov",
                        "content": "[@rockstar4095](/rockstar4095) This 88 computers connected in 2 different networks. So, you have 87 connected and 2 connected between each other. In a result you need minimum 13 connections. "
                    },
                    {
                        "username": "rockstar4095",
                        "content": "same problem with 100-88 computers.\n\ncan anyone provide a smaller example for this configuration?\nare there two or more initial networks actually  instead of one?\n\nI have a very nice 10-lines solution and it fails on this testcase))"
                    },
                    {
                        "username": "rockstar4095",
                        "content": "[@rush2rain](/rush2rain) \\n\\nfrom description:\\n\\n\"Any computer can reach any other computer directly or indirectly through the network.\"\\n\\n\"You are given an initial computer network connections.\"\\n\\naccording to this description, all the initial given computers must be connected."
                    },
                    {
                        "username": "jasona",
                        "content": "[@rush2rain](/rush2rain) ahh thanks! they need to introduce a smaller test case demonstrating that "
                    },
                    {
                        "username": "rush2rain",
                        "content": "Previously, I also attempted the same way. But there happens to be one flaw. What if 88 connected computers are making two separate components of 44 systems each. In that case, we need a wire to connect the two components together as well. So, we need to count the number of components that the whole set of computers is making. "
                    },
                    {
                        "username": "yyol",
                        "content": "same question"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one whose mind screwed up on this question ?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "you just need two things .\\n1. n-1>connections.length  return -1  (don\\'t have enough edge to connect all)\\n2. find number of connected components , return count-1"
                    },
                    {
                        "username": "thatsassygurl21",
                        "content": "Java implentation of your approach:\\nclass Solution {\\n    public int makeConnected(int n, int[][] con){\\n     if(con.length<n-1)return -1;\\n     List<List<Integer>> adj=new ArrayList<>();\\n     for(int i=0;i<n;i++)adj.add(new ArrayList<>());\\n     for(int i=0;i<con.length;i++)\\n     {\\n         adj.get(con[i][0]).add(con[i][1]);\\n          adj.get(con[i][1]).add(con[i][0]);\\n     }\\n     int ans=0;\\n     int vis[]=new int[n];\\n     for(int i=0;i<n;i++)\\n\\n     {\\n         if(vis[i]==0)\\n         {\\n             ans++;\\n             dfs(vis, adj,i);\\n         }   \\n    }\\n    return ans-1;\\n\\n\\n}\\n\\nvoid dfs(int []vis,List<List<Integer>> adj, int n )\\n{\\n    vis[n]=1;\\n    for(int i=0;i<adj.get(n).size();i++)\\n    {\\n    if(vis[adj.get(n).get(i)]==0)\\n    {\\n        dfs(vis,adj,adj.get(n).get(i));\\n    }\\n    }\\n}}"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@daveamol](/daveamol) What is count you are talking about, is it number of disconnected systems?"
                    },
                    {
                        "username": "daveamol",
                        "content": "This is the check I was looking for. That the total numbers of edges for every node to be connected has to be at least (n-1). As minimum edges required to connect n nodes is n-1.\\n\\nI wrote the check like this instead for clarity -\\nconnections.length >= n - 1, then return count - 1, else return -1"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Union Find week ? We are ready!"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "[@UchihaKim](/UchihaKim) you can determine if the node are having same parent node using find(), so if you find the edges are repeated, that mean you can swap that edge to connect other node."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "[@hiper2d](/hiper2d) I solve yesterday question using BFS then I took a look on the related topics and found Union Find, I am still learning it for now,  I can solve the problem using DFS but I want to solve it with that beautiful  DS. If you can give me some tips I\\'d be grateful if you help me."
                    },
                    {
                        "username": "hiper2d",
                        "content": "Same thing here. I keep using Union Find without even considering DFS and BFS. For some reason, this data structure is more obvious solution"
                    },
                    {
                        "username": "Rajkumar_007",
                        "content": "Hint : Find number of clusters"
                    },
                    {
                        "username": "hosua",
                        "content": "Weird, I tried solving this with BFS and got TLE, but it worked fine with DFS. Anyone understand why?"
                    },
                    {
                        "username": "hosua",
                        "content": "[@Crispy_coffee](/Crispy_coffee) I did something similar to this and got TLE"
                    },
                    {
                        "username": "czjnbb",
                        "content": "My py BFS beated more than 80%."
                    },
                    {
                        "username": "try_solving_hard",
                        "content": "Here\\'s my BFS submisson. #referrence Accepted in 1st attempt itself. #pride.\\n\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        \\n        // Find total number of connected components\\n        // Indegree / outdegree sum of all nodes in a connected component\\n        // Find total no of extra cables => (degree sum - required)/2\\n        // where required = (nodes in connected component - 1) * 2\\n        // If extra cables >= connected components - 1\\n        //      return connected components - 1\\n        // Else, \\n        //      return - 1\\n\\n        // Construct Graph\\n\\n        vector<int> adj[n];\\n        vector<long long> deg(n, 0);\\n\\n        for(auto c : connections)\\n        {\\n            adj[c[0]].push_back(c[1]);\\n            adj[c[1]].push_back(c[0]);\\n            deg[c[0]]++;\\n            deg[c[1]]++;\\n        }\\n\\n        vector<bool> vis(n, false);\\n        int cc = 0, extra = 0;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            if (!vis[i])\\n            {\\n                cc++;\\n                long long degree_sum = 0;\\n                int nodes = 0;\\n                vis[i] = true;\\n\\n                queue<int> q({i});\\n\\n                while(!q.empty())\\n                {\\n                    auto v = q.front();\\n                    q.pop();\\n\\n                    nodes++;\\n\\n                    degree_sum += deg[v];\\n\\n                    for(auto nbr : adj[v])\\n                    {\\n                        if (!vis[nbr])\\n                        {\\n                            vis[nbr] = true;\\n                            q.push(nbr);\\n\\n                        }\\n                    }\\n                }\\n\\n                int curr_ex = (degree_sum - ((nodes - 1) * 2)) / 2;\\n                extra += curr_ex;\\n            }\\n        }\\n\\n        return extra >= cc - 1 ? cc - 1 : -1;\\n\\n    }\\n};"
                    },
                    {
                        "username": "RamilZaripov",
                        "content": "I had a TLE on my BFS attempt, after reading your comment also switched to DFS and everything worked!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "I saw your comment and after submmiting my DFS approach i find this solution in submitted solution graph\\n\\n```c++\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& c) \\n    {\\n        if(c.size() < n -1) return -1;\\n        vector<int> adj[n];\\n        for(auto it : c)   \\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        } \\n\\n        int ct = 0;\\n        queue<int> q;\\n        vector<int> vis(n, 0);\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(!vis[i])\\n            {\\n                q.push(i);\\n                vis[i] = 1;\\n                while(!q.empty())\\n                {\\n                    int node = q.front();\\n                    q.pop();\\n                    for(auto it : adj[node])\\n                    {\\n                        if(!vis[it])\\n                        {\\n                            q.push(it);\\n                            vis[it] = 1;\\n                        }\\n                    }\\n                }\\n                ct++;\\n            }\\n        }\\n        return ct-1; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "cJayesh",
                        "content": "This happened with me in python.\nBFS uses more space than DFS.\nAlso depending on implementation, BFS has more add_to_list/add_to_set/enqueue/dequeue operations than DFS.\n"
                    },
                    {
                        "username": "user2575jO",
                        "content": "If `n==1` we will have `1 <= connections.length <= 0`. So this test case will not work."
                    },
                    {
                        "username": "Krrabs",
                        "content": "Union Find approach:\nGo through all the given connections and connect `connections[i][a] to connections[i][b]` pairs if `a & b` are already in a same graph you have an extra edge which can be used for connecting unconnected graphs.\n\nAt the end of `connections array` you should have count of extra edges and unconnected graphs, from these two information you can calculate the answer."
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "I thought about finding Indegree of each node (i.e. number of incoming edges) and then the count of nodes with 0 indegree(no incoming edge) shouldn\\'t it be the answer? It fails some testcases. (Yes, I have considered the case where number of wires are less than n-1) "
                    },
                    {
                        "username": "saichandra004",
                        "content": "Let's suppose we have 100 nodes.\n\n50 nodes are connected in a network.\nother 50 nodes are connected in another network (disjoint graph).\n\nFor the whole 100 nodes to be connected, we need 1 connection to join these two independent networks.\n\nBut if we only count the indegree, this seems that all the nodes are connected, but in reality, there are two different networks. Hence this indegree will lead to answers lesser than expected."
                    }
                ]
            },
            {
                "id": 1841255,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Switch to wireless technology to avoid such type of problems in life "
                    },
                    {
                        "username": "RCchoudhary",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE00 Nice"
                    },
                    {
                        "username": "hahahamid",
                        "content": "real"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "big bren"
                    },
                    {
                        "username": "santanusen",
                        "content": "Ha ha! On a serious note, the backbone networks are still wired, involving optical cables. Though they do have satellite links as emergency failover, those have terrible latencies."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@TsuruLee](/TsuruLee) now deal with 3D Array \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "I think they will create new problems about something like where to place the router to make the signal cover all devices"
                    },
                    {
                        "username": "kaskabay",
                        "content": "Test case:\\n100\\n[[17,51],[33,83],[53,62],[25,34],[35,90],[29,41],[14,53],[40,84],[41,64],[13,68],[44,85],[57,58],[50,74],[20,69],[15,62],[25,88],[4,56],[37,39],[30,62],[69,79],[33,85],[24,83],[35,77],[2,73],[6,28],[46,98],[11,82],[29,72],[67,71],[12,49],[42,56],[56,65],[40,70],[24,64],[29,51],[20,27],[45,88],[58,92],[60,99],[33,46],[19,69],[33,89],[54,82],[16,50],[35,73],[19,45],[19,72],[1,79],[27,80],[22,41],[52,61],[50,85],[27,45],[4,84],[11,96],[0,99],[29,94],[9,19],[66,99],[20,39],[16,85],[12,27],[16,67],[61,80],[67,83],[16,17],[24,27],[16,25],[41,79],[51,95],[46,47],[27,51],[31,44],[0,69],[61,63],[33,95],[17,88],[70,87],[40,42],[21,42],[67,77],[33,65],[3,25],[39,83],[34,40],[15,79],[30,90],[58,95],[45,56],[37,48],[24,91],[31,93],[83,90],[17,86],[61,65],[15,48],[34,56],[12,26],[39,98],[1,48],[21,76],[72,96],[30,69],[46,80],[6,29],[29,81],[22,77],[85,90],[79,83],[6,26],[33,57],[3,65],[63,84],[77,94],[26,90],[64,77],[0,3],[27,97],[66,89],[18,77],[27,43]]\\n\\nThe test case above have 88 already connected computers and 121 cables. So, we only need 12 (100-88) computers to be connected or in other words maximum of 12 cables relocated. How is that possible that answer is 13? It seems that it is not optimal way. I may be wrong in assumtions, if so please let me know."
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "suppose you have 6 computers 123 are connected in a straight line [1-2-3] & all others are connected in the same way [4-5-6] although all computers are connected the answer will be -1 because we cannot reach 4 5 6 starting at 1 2 3"
                    },
                    {
                        "username": "sainadth1123434",
                        "content": "Yeah thats correct even i got this error donno if the solution provided correct or not"
                    },
                    {
                        "username": "ramakiran",
                        "content": "[@ramakiran](/ramakiran) \\nthis is the shorter version of above case there will be 2 connected components so the answer will be 1 \\n"
                    },
                    {
                        "username": "ramakiran",
                        "content": "[@rockstar4095](/rockstar4095)   \\nn=6\\n[[0,1],[0,2],[1,2],[3,4],[4,5]]"
                    },
                    {
                        "username": "pramod74",
                        "content": "[@rockstar4095](/rockstar4095) Absolutely, that\\'s what is puzzling me aIso. Not sure if the question needs to be reworded to make this clear! "
                    },
                    {
                        "username": "B0PD0P",
                        "content": "[@kunadilov](/kunadilov)  we have 12 computers that are not connected, then we need at minimum 11 edges to connect these 12 computers with each other and then one extra edge to connect this component to the original component, shouldn't the answer be 12 ?"
                    },
                    {
                        "username": "kunadilov",
                        "content": "[@rockstar4095](/rockstar4095) This 88 computers connected in 2 different networks. So, you have 87 connected and 2 connected between each other. In a result you need minimum 13 connections. "
                    },
                    {
                        "username": "rockstar4095",
                        "content": "same problem with 100-88 computers.\n\ncan anyone provide a smaller example for this configuration?\nare there two or more initial networks actually  instead of one?\n\nI have a very nice 10-lines solution and it fails on this testcase))"
                    },
                    {
                        "username": "rockstar4095",
                        "content": "[@rush2rain](/rush2rain) \\n\\nfrom description:\\n\\n\"Any computer can reach any other computer directly or indirectly through the network.\"\\n\\n\"You are given an initial computer network connections.\"\\n\\naccording to this description, all the initial given computers must be connected."
                    },
                    {
                        "username": "jasona",
                        "content": "[@rush2rain](/rush2rain) ahh thanks! they need to introduce a smaller test case demonstrating that "
                    },
                    {
                        "username": "rush2rain",
                        "content": "Previously, I also attempted the same way. But there happens to be one flaw. What if 88 connected computers are making two separate components of 44 systems each. In that case, we need a wire to connect the two components together as well. So, we need to count the number of components that the whole set of computers is making. "
                    },
                    {
                        "username": "yyol",
                        "content": "same question"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one whose mind screwed up on this question ?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "you just need two things .\\n1. n-1>connections.length  return -1  (don\\'t have enough edge to connect all)\\n2. find number of connected components , return count-1"
                    },
                    {
                        "username": "thatsassygurl21",
                        "content": "Java implentation of your approach:\\nclass Solution {\\n    public int makeConnected(int n, int[][] con){\\n     if(con.length<n-1)return -1;\\n     List<List<Integer>> adj=new ArrayList<>();\\n     for(int i=0;i<n;i++)adj.add(new ArrayList<>());\\n     for(int i=0;i<con.length;i++)\\n     {\\n         adj.get(con[i][0]).add(con[i][1]);\\n          adj.get(con[i][1]).add(con[i][0]);\\n     }\\n     int ans=0;\\n     int vis[]=new int[n];\\n     for(int i=0;i<n;i++)\\n\\n     {\\n         if(vis[i]==0)\\n         {\\n             ans++;\\n             dfs(vis, adj,i);\\n         }   \\n    }\\n    return ans-1;\\n\\n\\n}\\n\\nvoid dfs(int []vis,List<List<Integer>> adj, int n )\\n{\\n    vis[n]=1;\\n    for(int i=0;i<adj.get(n).size();i++)\\n    {\\n    if(vis[adj.get(n).get(i)]==0)\\n    {\\n        dfs(vis,adj,adj.get(n).get(i));\\n    }\\n    }\\n}}"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@daveamol](/daveamol) What is count you are talking about, is it number of disconnected systems?"
                    },
                    {
                        "username": "daveamol",
                        "content": "This is the check I was looking for. That the total numbers of edges for every node to be connected has to be at least (n-1). As minimum edges required to connect n nodes is n-1.\\n\\nI wrote the check like this instead for clarity -\\nconnections.length >= n - 1, then return count - 1, else return -1"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Union Find week ? We are ready!"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "[@UchihaKim](/UchihaKim) you can determine if the node are having same parent node using find(), so if you find the edges are repeated, that mean you can swap that edge to connect other node."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "[@hiper2d](/hiper2d) I solve yesterday question using BFS then I took a look on the related topics and found Union Find, I am still learning it for now,  I can solve the problem using DFS but I want to solve it with that beautiful  DS. If you can give me some tips I\\'d be grateful if you help me."
                    },
                    {
                        "username": "hiper2d",
                        "content": "Same thing here. I keep using Union Find without even considering DFS and BFS. For some reason, this data structure is more obvious solution"
                    },
                    {
                        "username": "Rajkumar_007",
                        "content": "Hint : Find number of clusters"
                    },
                    {
                        "username": "hosua",
                        "content": "Weird, I tried solving this with BFS and got TLE, but it worked fine with DFS. Anyone understand why?"
                    },
                    {
                        "username": "hosua",
                        "content": "[@Crispy_coffee](/Crispy_coffee) I did something similar to this and got TLE"
                    },
                    {
                        "username": "czjnbb",
                        "content": "My py BFS beated more than 80%."
                    },
                    {
                        "username": "try_solving_hard",
                        "content": "Here\\'s my BFS submisson. #referrence Accepted in 1st attempt itself. #pride.\\n\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        \\n        // Find total number of connected components\\n        // Indegree / outdegree sum of all nodes in a connected component\\n        // Find total no of extra cables => (degree sum - required)/2\\n        // where required = (nodes in connected component - 1) * 2\\n        // If extra cables >= connected components - 1\\n        //      return connected components - 1\\n        // Else, \\n        //      return - 1\\n\\n        // Construct Graph\\n\\n        vector<int> adj[n];\\n        vector<long long> deg(n, 0);\\n\\n        for(auto c : connections)\\n        {\\n            adj[c[0]].push_back(c[1]);\\n            adj[c[1]].push_back(c[0]);\\n            deg[c[0]]++;\\n            deg[c[1]]++;\\n        }\\n\\n        vector<bool> vis(n, false);\\n        int cc = 0, extra = 0;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            if (!vis[i])\\n            {\\n                cc++;\\n                long long degree_sum = 0;\\n                int nodes = 0;\\n                vis[i] = true;\\n\\n                queue<int> q({i});\\n\\n                while(!q.empty())\\n                {\\n                    auto v = q.front();\\n                    q.pop();\\n\\n                    nodes++;\\n\\n                    degree_sum += deg[v];\\n\\n                    for(auto nbr : adj[v])\\n                    {\\n                        if (!vis[nbr])\\n                        {\\n                            vis[nbr] = true;\\n                            q.push(nbr);\\n\\n                        }\\n                    }\\n                }\\n\\n                int curr_ex = (degree_sum - ((nodes - 1) * 2)) / 2;\\n                extra += curr_ex;\\n            }\\n        }\\n\\n        return extra >= cc - 1 ? cc - 1 : -1;\\n\\n    }\\n};"
                    },
                    {
                        "username": "RamilZaripov",
                        "content": "I had a TLE on my BFS attempt, after reading your comment also switched to DFS and everything worked!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "I saw your comment and after submmiting my DFS approach i find this solution in submitted solution graph\\n\\n```c++\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& c) \\n    {\\n        if(c.size() < n -1) return -1;\\n        vector<int> adj[n];\\n        for(auto it : c)   \\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        } \\n\\n        int ct = 0;\\n        queue<int> q;\\n        vector<int> vis(n, 0);\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(!vis[i])\\n            {\\n                q.push(i);\\n                vis[i] = 1;\\n                while(!q.empty())\\n                {\\n                    int node = q.front();\\n                    q.pop();\\n                    for(auto it : adj[node])\\n                    {\\n                        if(!vis[it])\\n                        {\\n                            q.push(it);\\n                            vis[it] = 1;\\n                        }\\n                    }\\n                }\\n                ct++;\\n            }\\n        }\\n        return ct-1; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "cJayesh",
                        "content": "This happened with me in python.\nBFS uses more space than DFS.\nAlso depending on implementation, BFS has more add_to_list/add_to_set/enqueue/dequeue operations than DFS.\n"
                    },
                    {
                        "username": "user2575jO",
                        "content": "If `n==1` we will have `1 <= connections.length <= 0`. So this test case will not work."
                    },
                    {
                        "username": "Krrabs",
                        "content": "Union Find approach:\nGo through all the given connections and connect `connections[i][a] to connections[i][b]` pairs if `a & b` are already in a same graph you have an extra edge which can be used for connecting unconnected graphs.\n\nAt the end of `connections array` you should have count of extra edges and unconnected graphs, from these two information you can calculate the answer."
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "I thought about finding Indegree of each node (i.e. number of incoming edges) and then the count of nodes with 0 indegree(no incoming edge) shouldn\\'t it be the answer? It fails some testcases. (Yes, I have considered the case where number of wires are less than n-1) "
                    },
                    {
                        "username": "saichandra004",
                        "content": "Let's suppose we have 100 nodes.\n\n50 nodes are connected in a network.\nother 50 nodes are connected in another network (disjoint graph).\n\nFor the whole 100 nodes to be connected, we need 1 connection to join these two independent networks.\n\nBut if we only count the indegree, this seems that all the nodes are connected, but in reality, there are two different networks. Hence this indegree will lead to answers lesser than expected."
                    }
                ]
            },
            {
                "id": 1841058,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Switch to wireless technology to avoid such type of problems in life "
                    },
                    {
                        "username": "RCchoudhary",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE00 Nice"
                    },
                    {
                        "username": "hahahamid",
                        "content": "real"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "big bren"
                    },
                    {
                        "username": "santanusen",
                        "content": "Ha ha! On a serious note, the backbone networks are still wired, involving optical cables. Though they do have satellite links as emergency failover, those have terrible latencies."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@TsuruLee](/TsuruLee) now deal with 3D Array \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "I think they will create new problems about something like where to place the router to make the signal cover all devices"
                    },
                    {
                        "username": "kaskabay",
                        "content": "Test case:\\n100\\n[[17,51],[33,83],[53,62],[25,34],[35,90],[29,41],[14,53],[40,84],[41,64],[13,68],[44,85],[57,58],[50,74],[20,69],[15,62],[25,88],[4,56],[37,39],[30,62],[69,79],[33,85],[24,83],[35,77],[2,73],[6,28],[46,98],[11,82],[29,72],[67,71],[12,49],[42,56],[56,65],[40,70],[24,64],[29,51],[20,27],[45,88],[58,92],[60,99],[33,46],[19,69],[33,89],[54,82],[16,50],[35,73],[19,45],[19,72],[1,79],[27,80],[22,41],[52,61],[50,85],[27,45],[4,84],[11,96],[0,99],[29,94],[9,19],[66,99],[20,39],[16,85],[12,27],[16,67],[61,80],[67,83],[16,17],[24,27],[16,25],[41,79],[51,95],[46,47],[27,51],[31,44],[0,69],[61,63],[33,95],[17,88],[70,87],[40,42],[21,42],[67,77],[33,65],[3,25],[39,83],[34,40],[15,79],[30,90],[58,95],[45,56],[37,48],[24,91],[31,93],[83,90],[17,86],[61,65],[15,48],[34,56],[12,26],[39,98],[1,48],[21,76],[72,96],[30,69],[46,80],[6,29],[29,81],[22,77],[85,90],[79,83],[6,26],[33,57],[3,65],[63,84],[77,94],[26,90],[64,77],[0,3],[27,97],[66,89],[18,77],[27,43]]\\n\\nThe test case above have 88 already connected computers and 121 cables. So, we only need 12 (100-88) computers to be connected or in other words maximum of 12 cables relocated. How is that possible that answer is 13? It seems that it is not optimal way. I may be wrong in assumtions, if so please let me know."
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "suppose you have 6 computers 123 are connected in a straight line [1-2-3] & all others are connected in the same way [4-5-6] although all computers are connected the answer will be -1 because we cannot reach 4 5 6 starting at 1 2 3"
                    },
                    {
                        "username": "sainadth1123434",
                        "content": "Yeah thats correct even i got this error donno if the solution provided correct or not"
                    },
                    {
                        "username": "ramakiran",
                        "content": "[@ramakiran](/ramakiran) \\nthis is the shorter version of above case there will be 2 connected components so the answer will be 1 \\n"
                    },
                    {
                        "username": "ramakiran",
                        "content": "[@rockstar4095](/rockstar4095)   \\nn=6\\n[[0,1],[0,2],[1,2],[3,4],[4,5]]"
                    },
                    {
                        "username": "pramod74",
                        "content": "[@rockstar4095](/rockstar4095) Absolutely, that\\'s what is puzzling me aIso. Not sure if the question needs to be reworded to make this clear! "
                    },
                    {
                        "username": "B0PD0P",
                        "content": "[@kunadilov](/kunadilov)  we have 12 computers that are not connected, then we need at minimum 11 edges to connect these 12 computers with each other and then one extra edge to connect this component to the original component, shouldn't the answer be 12 ?"
                    },
                    {
                        "username": "kunadilov",
                        "content": "[@rockstar4095](/rockstar4095) This 88 computers connected in 2 different networks. So, you have 87 connected and 2 connected between each other. In a result you need minimum 13 connections. "
                    },
                    {
                        "username": "rockstar4095",
                        "content": "same problem with 100-88 computers.\n\ncan anyone provide a smaller example for this configuration?\nare there two or more initial networks actually  instead of one?\n\nI have a very nice 10-lines solution and it fails on this testcase))"
                    },
                    {
                        "username": "rockstar4095",
                        "content": "[@rush2rain](/rush2rain) \\n\\nfrom description:\\n\\n\"Any computer can reach any other computer directly or indirectly through the network.\"\\n\\n\"You are given an initial computer network connections.\"\\n\\naccording to this description, all the initial given computers must be connected."
                    },
                    {
                        "username": "jasona",
                        "content": "[@rush2rain](/rush2rain) ahh thanks! they need to introduce a smaller test case demonstrating that "
                    },
                    {
                        "username": "rush2rain",
                        "content": "Previously, I also attempted the same way. But there happens to be one flaw. What if 88 connected computers are making two separate components of 44 systems each. In that case, we need a wire to connect the two components together as well. So, we need to count the number of components that the whole set of computers is making. "
                    },
                    {
                        "username": "yyol",
                        "content": "same question"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one whose mind screwed up on this question ?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "you just need two things .\\n1. n-1>connections.length  return -1  (don\\'t have enough edge to connect all)\\n2. find number of connected components , return count-1"
                    },
                    {
                        "username": "thatsassygurl21",
                        "content": "Java implentation of your approach:\\nclass Solution {\\n    public int makeConnected(int n, int[][] con){\\n     if(con.length<n-1)return -1;\\n     List<List<Integer>> adj=new ArrayList<>();\\n     for(int i=0;i<n;i++)adj.add(new ArrayList<>());\\n     for(int i=0;i<con.length;i++)\\n     {\\n         adj.get(con[i][0]).add(con[i][1]);\\n          adj.get(con[i][1]).add(con[i][0]);\\n     }\\n     int ans=0;\\n     int vis[]=new int[n];\\n     for(int i=0;i<n;i++)\\n\\n     {\\n         if(vis[i]==0)\\n         {\\n             ans++;\\n             dfs(vis, adj,i);\\n         }   \\n    }\\n    return ans-1;\\n\\n\\n}\\n\\nvoid dfs(int []vis,List<List<Integer>> adj, int n )\\n{\\n    vis[n]=1;\\n    for(int i=0;i<adj.get(n).size();i++)\\n    {\\n    if(vis[adj.get(n).get(i)]==0)\\n    {\\n        dfs(vis,adj,adj.get(n).get(i));\\n    }\\n    }\\n}}"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@daveamol](/daveamol) What is count you are talking about, is it number of disconnected systems?"
                    },
                    {
                        "username": "daveamol",
                        "content": "This is the check I was looking for. That the total numbers of edges for every node to be connected has to be at least (n-1). As minimum edges required to connect n nodes is n-1.\\n\\nI wrote the check like this instead for clarity -\\nconnections.length >= n - 1, then return count - 1, else return -1"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Union Find week ? We are ready!"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "[@UchihaKim](/UchihaKim) you can determine if the node are having same parent node using find(), so if you find the edges are repeated, that mean you can swap that edge to connect other node."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "[@hiper2d](/hiper2d) I solve yesterday question using BFS then I took a look on the related topics and found Union Find, I am still learning it for now,  I can solve the problem using DFS but I want to solve it with that beautiful  DS. If you can give me some tips I\\'d be grateful if you help me."
                    },
                    {
                        "username": "hiper2d",
                        "content": "Same thing here. I keep using Union Find without even considering DFS and BFS. For some reason, this data structure is more obvious solution"
                    },
                    {
                        "username": "Rajkumar_007",
                        "content": "Hint : Find number of clusters"
                    },
                    {
                        "username": "hosua",
                        "content": "Weird, I tried solving this with BFS and got TLE, but it worked fine with DFS. Anyone understand why?"
                    },
                    {
                        "username": "hosua",
                        "content": "[@Crispy_coffee](/Crispy_coffee) I did something similar to this and got TLE"
                    },
                    {
                        "username": "czjnbb",
                        "content": "My py BFS beated more than 80%."
                    },
                    {
                        "username": "try_solving_hard",
                        "content": "Here\\'s my BFS submisson. #referrence Accepted in 1st attempt itself. #pride.\\n\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        \\n        // Find total number of connected components\\n        // Indegree / outdegree sum of all nodes in a connected component\\n        // Find total no of extra cables => (degree sum - required)/2\\n        // where required = (nodes in connected component - 1) * 2\\n        // If extra cables >= connected components - 1\\n        //      return connected components - 1\\n        // Else, \\n        //      return - 1\\n\\n        // Construct Graph\\n\\n        vector<int> adj[n];\\n        vector<long long> deg(n, 0);\\n\\n        for(auto c : connections)\\n        {\\n            adj[c[0]].push_back(c[1]);\\n            adj[c[1]].push_back(c[0]);\\n            deg[c[0]]++;\\n            deg[c[1]]++;\\n        }\\n\\n        vector<bool> vis(n, false);\\n        int cc = 0, extra = 0;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            if (!vis[i])\\n            {\\n                cc++;\\n                long long degree_sum = 0;\\n                int nodes = 0;\\n                vis[i] = true;\\n\\n                queue<int> q({i});\\n\\n                while(!q.empty())\\n                {\\n                    auto v = q.front();\\n                    q.pop();\\n\\n                    nodes++;\\n\\n                    degree_sum += deg[v];\\n\\n                    for(auto nbr : adj[v])\\n                    {\\n                        if (!vis[nbr])\\n                        {\\n                            vis[nbr] = true;\\n                            q.push(nbr);\\n\\n                        }\\n                    }\\n                }\\n\\n                int curr_ex = (degree_sum - ((nodes - 1) * 2)) / 2;\\n                extra += curr_ex;\\n            }\\n        }\\n\\n        return extra >= cc - 1 ? cc - 1 : -1;\\n\\n    }\\n};"
                    },
                    {
                        "username": "RamilZaripov",
                        "content": "I had a TLE on my BFS attempt, after reading your comment also switched to DFS and everything worked!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "I saw your comment and after submmiting my DFS approach i find this solution in submitted solution graph\\n\\n```c++\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& c) \\n    {\\n        if(c.size() < n -1) return -1;\\n        vector<int> adj[n];\\n        for(auto it : c)   \\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        } \\n\\n        int ct = 0;\\n        queue<int> q;\\n        vector<int> vis(n, 0);\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(!vis[i])\\n            {\\n                q.push(i);\\n                vis[i] = 1;\\n                while(!q.empty())\\n                {\\n                    int node = q.front();\\n                    q.pop();\\n                    for(auto it : adj[node])\\n                    {\\n                        if(!vis[it])\\n                        {\\n                            q.push(it);\\n                            vis[it] = 1;\\n                        }\\n                    }\\n                }\\n                ct++;\\n            }\\n        }\\n        return ct-1; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "cJayesh",
                        "content": "This happened with me in python.\nBFS uses more space than DFS.\nAlso depending on implementation, BFS has more add_to_list/add_to_set/enqueue/dequeue operations than DFS.\n"
                    },
                    {
                        "username": "user2575jO",
                        "content": "If `n==1` we will have `1 <= connections.length <= 0`. So this test case will not work."
                    },
                    {
                        "username": "Krrabs",
                        "content": "Union Find approach:\nGo through all the given connections and connect `connections[i][a] to connections[i][b]` pairs if `a & b` are already in a same graph you have an extra edge which can be used for connecting unconnected graphs.\n\nAt the end of `connections array` you should have count of extra edges and unconnected graphs, from these two information you can calculate the answer."
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "I thought about finding Indegree of each node (i.e. number of incoming edges) and then the count of nodes with 0 indegree(no incoming edge) shouldn\\'t it be the answer? It fails some testcases. (Yes, I have considered the case where number of wires are less than n-1) "
                    },
                    {
                        "username": "saichandra004",
                        "content": "Let's suppose we have 100 nodes.\n\n50 nodes are connected in a network.\nother 50 nodes are connected in another network (disjoint graph).\n\nFor the whole 100 nodes to be connected, we need 1 connection to join these two independent networks.\n\nBut if we only count the indegree, this seems that all the nodes are connected, but in reality, there are two different networks. Hence this indegree will lead to answers lesser than expected."
                    }
                ]
            },
            {
                "id": 1840926,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Switch to wireless technology to avoid such type of problems in life "
                    },
                    {
                        "username": "RCchoudhary",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE00 Nice"
                    },
                    {
                        "username": "hahahamid",
                        "content": "real"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "big bren"
                    },
                    {
                        "username": "santanusen",
                        "content": "Ha ha! On a serious note, the backbone networks are still wired, involving optical cables. Though they do have satellite links as emergency failover, those have terrible latencies."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@TsuruLee](/TsuruLee) now deal with 3D Array \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "I think they will create new problems about something like where to place the router to make the signal cover all devices"
                    },
                    {
                        "username": "kaskabay",
                        "content": "Test case:\\n100\\n[[17,51],[33,83],[53,62],[25,34],[35,90],[29,41],[14,53],[40,84],[41,64],[13,68],[44,85],[57,58],[50,74],[20,69],[15,62],[25,88],[4,56],[37,39],[30,62],[69,79],[33,85],[24,83],[35,77],[2,73],[6,28],[46,98],[11,82],[29,72],[67,71],[12,49],[42,56],[56,65],[40,70],[24,64],[29,51],[20,27],[45,88],[58,92],[60,99],[33,46],[19,69],[33,89],[54,82],[16,50],[35,73],[19,45],[19,72],[1,79],[27,80],[22,41],[52,61],[50,85],[27,45],[4,84],[11,96],[0,99],[29,94],[9,19],[66,99],[20,39],[16,85],[12,27],[16,67],[61,80],[67,83],[16,17],[24,27],[16,25],[41,79],[51,95],[46,47],[27,51],[31,44],[0,69],[61,63],[33,95],[17,88],[70,87],[40,42],[21,42],[67,77],[33,65],[3,25],[39,83],[34,40],[15,79],[30,90],[58,95],[45,56],[37,48],[24,91],[31,93],[83,90],[17,86],[61,65],[15,48],[34,56],[12,26],[39,98],[1,48],[21,76],[72,96],[30,69],[46,80],[6,29],[29,81],[22,77],[85,90],[79,83],[6,26],[33,57],[3,65],[63,84],[77,94],[26,90],[64,77],[0,3],[27,97],[66,89],[18,77],[27,43]]\\n\\nThe test case above have 88 already connected computers and 121 cables. So, we only need 12 (100-88) computers to be connected or in other words maximum of 12 cables relocated. How is that possible that answer is 13? It seems that it is not optimal way. I may be wrong in assumtions, if so please let me know."
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "suppose you have 6 computers 123 are connected in a straight line [1-2-3] & all others are connected in the same way [4-5-6] although all computers are connected the answer will be -1 because we cannot reach 4 5 6 starting at 1 2 3"
                    },
                    {
                        "username": "sainadth1123434",
                        "content": "Yeah thats correct even i got this error donno if the solution provided correct or not"
                    },
                    {
                        "username": "ramakiran",
                        "content": "[@ramakiran](/ramakiran) \\nthis is the shorter version of above case there will be 2 connected components so the answer will be 1 \\n"
                    },
                    {
                        "username": "ramakiran",
                        "content": "[@rockstar4095](/rockstar4095)   \\nn=6\\n[[0,1],[0,2],[1,2],[3,4],[4,5]]"
                    },
                    {
                        "username": "pramod74",
                        "content": "[@rockstar4095](/rockstar4095) Absolutely, that\\'s what is puzzling me aIso. Not sure if the question needs to be reworded to make this clear! "
                    },
                    {
                        "username": "B0PD0P",
                        "content": "[@kunadilov](/kunadilov)  we have 12 computers that are not connected, then we need at minimum 11 edges to connect these 12 computers with each other and then one extra edge to connect this component to the original component, shouldn't the answer be 12 ?"
                    },
                    {
                        "username": "kunadilov",
                        "content": "[@rockstar4095](/rockstar4095) This 88 computers connected in 2 different networks. So, you have 87 connected and 2 connected between each other. In a result you need minimum 13 connections. "
                    },
                    {
                        "username": "rockstar4095",
                        "content": "same problem with 100-88 computers.\n\ncan anyone provide a smaller example for this configuration?\nare there two or more initial networks actually  instead of one?\n\nI have a very nice 10-lines solution and it fails on this testcase))"
                    },
                    {
                        "username": "rockstar4095",
                        "content": "[@rush2rain](/rush2rain) \\n\\nfrom description:\\n\\n\"Any computer can reach any other computer directly or indirectly through the network.\"\\n\\n\"You are given an initial computer network connections.\"\\n\\naccording to this description, all the initial given computers must be connected."
                    },
                    {
                        "username": "jasona",
                        "content": "[@rush2rain](/rush2rain) ahh thanks! they need to introduce a smaller test case demonstrating that "
                    },
                    {
                        "username": "rush2rain",
                        "content": "Previously, I also attempted the same way. But there happens to be one flaw. What if 88 connected computers are making two separate components of 44 systems each. In that case, we need a wire to connect the two components together as well. So, we need to count the number of components that the whole set of computers is making. "
                    },
                    {
                        "username": "yyol",
                        "content": "same question"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one whose mind screwed up on this question ?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "you just need two things .\\n1. n-1>connections.length  return -1  (don\\'t have enough edge to connect all)\\n2. find number of connected components , return count-1"
                    },
                    {
                        "username": "thatsassygurl21",
                        "content": "Java implentation of your approach:\\nclass Solution {\\n    public int makeConnected(int n, int[][] con){\\n     if(con.length<n-1)return -1;\\n     List<List<Integer>> adj=new ArrayList<>();\\n     for(int i=0;i<n;i++)adj.add(new ArrayList<>());\\n     for(int i=0;i<con.length;i++)\\n     {\\n         adj.get(con[i][0]).add(con[i][1]);\\n          adj.get(con[i][1]).add(con[i][0]);\\n     }\\n     int ans=0;\\n     int vis[]=new int[n];\\n     for(int i=0;i<n;i++)\\n\\n     {\\n         if(vis[i]==0)\\n         {\\n             ans++;\\n             dfs(vis, adj,i);\\n         }   \\n    }\\n    return ans-1;\\n\\n\\n}\\n\\nvoid dfs(int []vis,List<List<Integer>> adj, int n )\\n{\\n    vis[n]=1;\\n    for(int i=0;i<adj.get(n).size();i++)\\n    {\\n    if(vis[adj.get(n).get(i)]==0)\\n    {\\n        dfs(vis,adj,adj.get(n).get(i));\\n    }\\n    }\\n}}"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@daveamol](/daveamol) What is count you are talking about, is it number of disconnected systems?"
                    },
                    {
                        "username": "daveamol",
                        "content": "This is the check I was looking for. That the total numbers of edges for every node to be connected has to be at least (n-1). As minimum edges required to connect n nodes is n-1.\\n\\nI wrote the check like this instead for clarity -\\nconnections.length >= n - 1, then return count - 1, else return -1"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Union Find week ? We are ready!"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "[@UchihaKim](/UchihaKim) you can determine if the node are having same parent node using find(), so if you find the edges are repeated, that mean you can swap that edge to connect other node."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "[@hiper2d](/hiper2d) I solve yesterday question using BFS then I took a look on the related topics and found Union Find, I am still learning it for now,  I can solve the problem using DFS but I want to solve it with that beautiful  DS. If you can give me some tips I\\'d be grateful if you help me."
                    },
                    {
                        "username": "hiper2d",
                        "content": "Same thing here. I keep using Union Find without even considering DFS and BFS. For some reason, this data structure is more obvious solution"
                    },
                    {
                        "username": "Rajkumar_007",
                        "content": "Hint : Find number of clusters"
                    },
                    {
                        "username": "hosua",
                        "content": "Weird, I tried solving this with BFS and got TLE, but it worked fine with DFS. Anyone understand why?"
                    },
                    {
                        "username": "hosua",
                        "content": "[@Crispy_coffee](/Crispy_coffee) I did something similar to this and got TLE"
                    },
                    {
                        "username": "czjnbb",
                        "content": "My py BFS beated more than 80%."
                    },
                    {
                        "username": "try_solving_hard",
                        "content": "Here\\'s my BFS submisson. #referrence Accepted in 1st attempt itself. #pride.\\n\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        \\n        // Find total number of connected components\\n        // Indegree / outdegree sum of all nodes in a connected component\\n        // Find total no of extra cables => (degree sum - required)/2\\n        // where required = (nodes in connected component - 1) * 2\\n        // If extra cables >= connected components - 1\\n        //      return connected components - 1\\n        // Else, \\n        //      return - 1\\n\\n        // Construct Graph\\n\\n        vector<int> adj[n];\\n        vector<long long> deg(n, 0);\\n\\n        for(auto c : connections)\\n        {\\n            adj[c[0]].push_back(c[1]);\\n            adj[c[1]].push_back(c[0]);\\n            deg[c[0]]++;\\n            deg[c[1]]++;\\n        }\\n\\n        vector<bool> vis(n, false);\\n        int cc = 0, extra = 0;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            if (!vis[i])\\n            {\\n                cc++;\\n                long long degree_sum = 0;\\n                int nodes = 0;\\n                vis[i] = true;\\n\\n                queue<int> q({i});\\n\\n                while(!q.empty())\\n                {\\n                    auto v = q.front();\\n                    q.pop();\\n\\n                    nodes++;\\n\\n                    degree_sum += deg[v];\\n\\n                    for(auto nbr : adj[v])\\n                    {\\n                        if (!vis[nbr])\\n                        {\\n                            vis[nbr] = true;\\n                            q.push(nbr);\\n\\n                        }\\n                    }\\n                }\\n\\n                int curr_ex = (degree_sum - ((nodes - 1) * 2)) / 2;\\n                extra += curr_ex;\\n            }\\n        }\\n\\n        return extra >= cc - 1 ? cc - 1 : -1;\\n\\n    }\\n};"
                    },
                    {
                        "username": "RamilZaripov",
                        "content": "I had a TLE on my BFS attempt, after reading your comment also switched to DFS and everything worked!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "I saw your comment and after submmiting my DFS approach i find this solution in submitted solution graph\\n\\n```c++\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& c) \\n    {\\n        if(c.size() < n -1) return -1;\\n        vector<int> adj[n];\\n        for(auto it : c)   \\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        } \\n\\n        int ct = 0;\\n        queue<int> q;\\n        vector<int> vis(n, 0);\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(!vis[i])\\n            {\\n                q.push(i);\\n                vis[i] = 1;\\n                while(!q.empty())\\n                {\\n                    int node = q.front();\\n                    q.pop();\\n                    for(auto it : adj[node])\\n                    {\\n                        if(!vis[it])\\n                        {\\n                            q.push(it);\\n                            vis[it] = 1;\\n                        }\\n                    }\\n                }\\n                ct++;\\n            }\\n        }\\n        return ct-1; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "cJayesh",
                        "content": "This happened with me in python.\nBFS uses more space than DFS.\nAlso depending on implementation, BFS has more add_to_list/add_to_set/enqueue/dequeue operations than DFS.\n"
                    },
                    {
                        "username": "user2575jO",
                        "content": "If `n==1` we will have `1 <= connections.length <= 0`. So this test case will not work."
                    },
                    {
                        "username": "Krrabs",
                        "content": "Union Find approach:\nGo through all the given connections and connect `connections[i][a] to connections[i][b]` pairs if `a & b` are already in a same graph you have an extra edge which can be used for connecting unconnected graphs.\n\nAt the end of `connections array` you should have count of extra edges and unconnected graphs, from these two information you can calculate the answer."
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "I thought about finding Indegree of each node (i.e. number of incoming edges) and then the count of nodes with 0 indegree(no incoming edge) shouldn\\'t it be the answer? It fails some testcases. (Yes, I have considered the case where number of wires are less than n-1) "
                    },
                    {
                        "username": "saichandra004",
                        "content": "Let's suppose we have 100 nodes.\n\n50 nodes are connected in a network.\nother 50 nodes are connected in another network (disjoint graph).\n\nFor the whole 100 nodes to be connected, we need 1 connection to join these two independent networks.\n\nBut if we only count the indegree, this seems that all the nodes are connected, but in reality, there are two different networks. Hence this indegree will lead to answers lesser than expected."
                    }
                ]
            },
            {
                "id": 1569737,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Switch to wireless technology to avoid such type of problems in life "
                    },
                    {
                        "username": "RCchoudhary",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE00 Nice"
                    },
                    {
                        "username": "hahahamid",
                        "content": "real"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "big bren"
                    },
                    {
                        "username": "santanusen",
                        "content": "Ha ha! On a serious note, the backbone networks are still wired, involving optical cables. Though they do have satellite links as emergency failover, those have terrible latencies."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@TsuruLee](/TsuruLee) now deal with 3D Array \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "I think they will create new problems about something like where to place the router to make the signal cover all devices"
                    },
                    {
                        "username": "kaskabay",
                        "content": "Test case:\\n100\\n[[17,51],[33,83],[53,62],[25,34],[35,90],[29,41],[14,53],[40,84],[41,64],[13,68],[44,85],[57,58],[50,74],[20,69],[15,62],[25,88],[4,56],[37,39],[30,62],[69,79],[33,85],[24,83],[35,77],[2,73],[6,28],[46,98],[11,82],[29,72],[67,71],[12,49],[42,56],[56,65],[40,70],[24,64],[29,51],[20,27],[45,88],[58,92],[60,99],[33,46],[19,69],[33,89],[54,82],[16,50],[35,73],[19,45],[19,72],[1,79],[27,80],[22,41],[52,61],[50,85],[27,45],[4,84],[11,96],[0,99],[29,94],[9,19],[66,99],[20,39],[16,85],[12,27],[16,67],[61,80],[67,83],[16,17],[24,27],[16,25],[41,79],[51,95],[46,47],[27,51],[31,44],[0,69],[61,63],[33,95],[17,88],[70,87],[40,42],[21,42],[67,77],[33,65],[3,25],[39,83],[34,40],[15,79],[30,90],[58,95],[45,56],[37,48],[24,91],[31,93],[83,90],[17,86],[61,65],[15,48],[34,56],[12,26],[39,98],[1,48],[21,76],[72,96],[30,69],[46,80],[6,29],[29,81],[22,77],[85,90],[79,83],[6,26],[33,57],[3,65],[63,84],[77,94],[26,90],[64,77],[0,3],[27,97],[66,89],[18,77],[27,43]]\\n\\nThe test case above have 88 already connected computers and 121 cables. So, we only need 12 (100-88) computers to be connected or in other words maximum of 12 cables relocated. How is that possible that answer is 13? It seems that it is not optimal way. I may be wrong in assumtions, if so please let me know."
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "suppose you have 6 computers 123 are connected in a straight line [1-2-3] & all others are connected in the same way [4-5-6] although all computers are connected the answer will be -1 because we cannot reach 4 5 6 starting at 1 2 3"
                    },
                    {
                        "username": "sainadth1123434",
                        "content": "Yeah thats correct even i got this error donno if the solution provided correct or not"
                    },
                    {
                        "username": "ramakiran",
                        "content": "[@ramakiran](/ramakiran) \\nthis is the shorter version of above case there will be 2 connected components so the answer will be 1 \\n"
                    },
                    {
                        "username": "ramakiran",
                        "content": "[@rockstar4095](/rockstar4095)   \\nn=6\\n[[0,1],[0,2],[1,2],[3,4],[4,5]]"
                    },
                    {
                        "username": "pramod74",
                        "content": "[@rockstar4095](/rockstar4095) Absolutely, that\\'s what is puzzling me aIso. Not sure if the question needs to be reworded to make this clear! "
                    },
                    {
                        "username": "B0PD0P",
                        "content": "[@kunadilov](/kunadilov)  we have 12 computers that are not connected, then we need at minimum 11 edges to connect these 12 computers with each other and then one extra edge to connect this component to the original component, shouldn't the answer be 12 ?"
                    },
                    {
                        "username": "kunadilov",
                        "content": "[@rockstar4095](/rockstar4095) This 88 computers connected in 2 different networks. So, you have 87 connected and 2 connected between each other. In a result you need minimum 13 connections. "
                    },
                    {
                        "username": "rockstar4095",
                        "content": "same problem with 100-88 computers.\n\ncan anyone provide a smaller example for this configuration?\nare there two or more initial networks actually  instead of one?\n\nI have a very nice 10-lines solution and it fails on this testcase))"
                    },
                    {
                        "username": "rockstar4095",
                        "content": "[@rush2rain](/rush2rain) \\n\\nfrom description:\\n\\n\"Any computer can reach any other computer directly or indirectly through the network.\"\\n\\n\"You are given an initial computer network connections.\"\\n\\naccording to this description, all the initial given computers must be connected."
                    },
                    {
                        "username": "jasona",
                        "content": "[@rush2rain](/rush2rain) ahh thanks! they need to introduce a smaller test case demonstrating that "
                    },
                    {
                        "username": "rush2rain",
                        "content": "Previously, I also attempted the same way. But there happens to be one flaw. What if 88 connected computers are making two separate components of 44 systems each. In that case, we need a wire to connect the two components together as well. So, we need to count the number of components that the whole set of computers is making. "
                    },
                    {
                        "username": "yyol",
                        "content": "same question"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one whose mind screwed up on this question ?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "you just need two things .\\n1. n-1>connections.length  return -1  (don\\'t have enough edge to connect all)\\n2. find number of connected components , return count-1"
                    },
                    {
                        "username": "thatsassygurl21",
                        "content": "Java implentation of your approach:\\nclass Solution {\\n    public int makeConnected(int n, int[][] con){\\n     if(con.length<n-1)return -1;\\n     List<List<Integer>> adj=new ArrayList<>();\\n     for(int i=0;i<n;i++)adj.add(new ArrayList<>());\\n     for(int i=0;i<con.length;i++)\\n     {\\n         adj.get(con[i][0]).add(con[i][1]);\\n          adj.get(con[i][1]).add(con[i][0]);\\n     }\\n     int ans=0;\\n     int vis[]=new int[n];\\n     for(int i=0;i<n;i++)\\n\\n     {\\n         if(vis[i]==0)\\n         {\\n             ans++;\\n             dfs(vis, adj,i);\\n         }   \\n    }\\n    return ans-1;\\n\\n\\n}\\n\\nvoid dfs(int []vis,List<List<Integer>> adj, int n )\\n{\\n    vis[n]=1;\\n    for(int i=0;i<adj.get(n).size();i++)\\n    {\\n    if(vis[adj.get(n).get(i)]==0)\\n    {\\n        dfs(vis,adj,adj.get(n).get(i));\\n    }\\n    }\\n}}"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@daveamol](/daveamol) What is count you are talking about, is it number of disconnected systems?"
                    },
                    {
                        "username": "daveamol",
                        "content": "This is the check I was looking for. That the total numbers of edges for every node to be connected has to be at least (n-1). As minimum edges required to connect n nodes is n-1.\\n\\nI wrote the check like this instead for clarity -\\nconnections.length >= n - 1, then return count - 1, else return -1"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Union Find week ? We are ready!"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "[@UchihaKim](/UchihaKim) you can determine if the node are having same parent node using find(), so if you find the edges are repeated, that mean you can swap that edge to connect other node."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "[@hiper2d](/hiper2d) I solve yesterday question using BFS then I took a look on the related topics and found Union Find, I am still learning it for now,  I can solve the problem using DFS but I want to solve it with that beautiful  DS. If you can give me some tips I\\'d be grateful if you help me."
                    },
                    {
                        "username": "hiper2d",
                        "content": "Same thing here. I keep using Union Find without even considering DFS and BFS. For some reason, this data structure is more obvious solution"
                    },
                    {
                        "username": "Rajkumar_007",
                        "content": "Hint : Find number of clusters"
                    },
                    {
                        "username": "hosua",
                        "content": "Weird, I tried solving this with BFS and got TLE, but it worked fine with DFS. Anyone understand why?"
                    },
                    {
                        "username": "hosua",
                        "content": "[@Crispy_coffee](/Crispy_coffee) I did something similar to this and got TLE"
                    },
                    {
                        "username": "czjnbb",
                        "content": "My py BFS beated more than 80%."
                    },
                    {
                        "username": "try_solving_hard",
                        "content": "Here\\'s my BFS submisson. #referrence Accepted in 1st attempt itself. #pride.\\n\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        \\n        // Find total number of connected components\\n        // Indegree / outdegree sum of all nodes in a connected component\\n        // Find total no of extra cables => (degree sum - required)/2\\n        // where required = (nodes in connected component - 1) * 2\\n        // If extra cables >= connected components - 1\\n        //      return connected components - 1\\n        // Else, \\n        //      return - 1\\n\\n        // Construct Graph\\n\\n        vector<int> adj[n];\\n        vector<long long> deg(n, 0);\\n\\n        for(auto c : connections)\\n        {\\n            adj[c[0]].push_back(c[1]);\\n            adj[c[1]].push_back(c[0]);\\n            deg[c[0]]++;\\n            deg[c[1]]++;\\n        }\\n\\n        vector<bool> vis(n, false);\\n        int cc = 0, extra = 0;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            if (!vis[i])\\n            {\\n                cc++;\\n                long long degree_sum = 0;\\n                int nodes = 0;\\n                vis[i] = true;\\n\\n                queue<int> q({i});\\n\\n                while(!q.empty())\\n                {\\n                    auto v = q.front();\\n                    q.pop();\\n\\n                    nodes++;\\n\\n                    degree_sum += deg[v];\\n\\n                    for(auto nbr : adj[v])\\n                    {\\n                        if (!vis[nbr])\\n                        {\\n                            vis[nbr] = true;\\n                            q.push(nbr);\\n\\n                        }\\n                    }\\n                }\\n\\n                int curr_ex = (degree_sum - ((nodes - 1) * 2)) / 2;\\n                extra += curr_ex;\\n            }\\n        }\\n\\n        return extra >= cc - 1 ? cc - 1 : -1;\\n\\n    }\\n};"
                    },
                    {
                        "username": "RamilZaripov",
                        "content": "I had a TLE on my BFS attempt, after reading your comment also switched to DFS and everything worked!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "I saw your comment and after submmiting my DFS approach i find this solution in submitted solution graph\\n\\n```c++\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& c) \\n    {\\n        if(c.size() < n -1) return -1;\\n        vector<int> adj[n];\\n        for(auto it : c)   \\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        } \\n\\n        int ct = 0;\\n        queue<int> q;\\n        vector<int> vis(n, 0);\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(!vis[i])\\n            {\\n                q.push(i);\\n                vis[i] = 1;\\n                while(!q.empty())\\n                {\\n                    int node = q.front();\\n                    q.pop();\\n                    for(auto it : adj[node])\\n                    {\\n                        if(!vis[it])\\n                        {\\n                            q.push(it);\\n                            vis[it] = 1;\\n                        }\\n                    }\\n                }\\n                ct++;\\n            }\\n        }\\n        return ct-1; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "cJayesh",
                        "content": "This happened with me in python.\nBFS uses more space than DFS.\nAlso depending on implementation, BFS has more add_to_list/add_to_set/enqueue/dequeue operations than DFS.\n"
                    },
                    {
                        "username": "user2575jO",
                        "content": "If `n==1` we will have `1 <= connections.length <= 0`. So this test case will not work."
                    },
                    {
                        "username": "Krrabs",
                        "content": "Union Find approach:\nGo through all the given connections and connect `connections[i][a] to connections[i][b]` pairs if `a & b` are already in a same graph you have an extra edge which can be used for connecting unconnected graphs.\n\nAt the end of `connections array` you should have count of extra edges and unconnected graphs, from these two information you can calculate the answer."
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "I thought about finding Indegree of each node (i.e. number of incoming edges) and then the count of nodes with 0 indegree(no incoming edge) shouldn\\'t it be the answer? It fails some testcases. (Yes, I have considered the case where number of wires are less than n-1) "
                    },
                    {
                        "username": "saichandra004",
                        "content": "Let's suppose we have 100 nodes.\n\n50 nodes are connected in a network.\nother 50 nodes are connected in another network (disjoint graph).\n\nFor the whole 100 nodes to be connected, we need 1 connection to join these two independent networks.\n\nBut if we only count the indegree, this seems that all the nodes are connected, but in reality, there are two different networks. Hence this indegree will lead to answers lesser than expected."
                    }
                ]
            },
            {
                "id": 1840985,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Switch to wireless technology to avoid such type of problems in life "
                    },
                    {
                        "username": "RCchoudhary",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE00 Nice"
                    },
                    {
                        "username": "hahahamid",
                        "content": "real"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "big bren"
                    },
                    {
                        "username": "santanusen",
                        "content": "Ha ha! On a serious note, the backbone networks are still wired, involving optical cables. Though they do have satellite links as emergency failover, those have terrible latencies."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@TsuruLee](/TsuruLee) now deal with 3D Array \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "I think they will create new problems about something like where to place the router to make the signal cover all devices"
                    },
                    {
                        "username": "kaskabay",
                        "content": "Test case:\\n100\\n[[17,51],[33,83],[53,62],[25,34],[35,90],[29,41],[14,53],[40,84],[41,64],[13,68],[44,85],[57,58],[50,74],[20,69],[15,62],[25,88],[4,56],[37,39],[30,62],[69,79],[33,85],[24,83],[35,77],[2,73],[6,28],[46,98],[11,82],[29,72],[67,71],[12,49],[42,56],[56,65],[40,70],[24,64],[29,51],[20,27],[45,88],[58,92],[60,99],[33,46],[19,69],[33,89],[54,82],[16,50],[35,73],[19,45],[19,72],[1,79],[27,80],[22,41],[52,61],[50,85],[27,45],[4,84],[11,96],[0,99],[29,94],[9,19],[66,99],[20,39],[16,85],[12,27],[16,67],[61,80],[67,83],[16,17],[24,27],[16,25],[41,79],[51,95],[46,47],[27,51],[31,44],[0,69],[61,63],[33,95],[17,88],[70,87],[40,42],[21,42],[67,77],[33,65],[3,25],[39,83],[34,40],[15,79],[30,90],[58,95],[45,56],[37,48],[24,91],[31,93],[83,90],[17,86],[61,65],[15,48],[34,56],[12,26],[39,98],[1,48],[21,76],[72,96],[30,69],[46,80],[6,29],[29,81],[22,77],[85,90],[79,83],[6,26],[33,57],[3,65],[63,84],[77,94],[26,90],[64,77],[0,3],[27,97],[66,89],[18,77],[27,43]]\\n\\nThe test case above have 88 already connected computers and 121 cables. So, we only need 12 (100-88) computers to be connected or in other words maximum of 12 cables relocated. How is that possible that answer is 13? It seems that it is not optimal way. I may be wrong in assumtions, if so please let me know."
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "suppose you have 6 computers 123 are connected in a straight line [1-2-3] & all others are connected in the same way [4-5-6] although all computers are connected the answer will be -1 because we cannot reach 4 5 6 starting at 1 2 3"
                    },
                    {
                        "username": "sainadth1123434",
                        "content": "Yeah thats correct even i got this error donno if the solution provided correct or not"
                    },
                    {
                        "username": "ramakiran",
                        "content": "[@ramakiran](/ramakiran) \\nthis is the shorter version of above case there will be 2 connected components so the answer will be 1 \\n"
                    },
                    {
                        "username": "ramakiran",
                        "content": "[@rockstar4095](/rockstar4095)   \\nn=6\\n[[0,1],[0,2],[1,2],[3,4],[4,5]]"
                    },
                    {
                        "username": "pramod74",
                        "content": "[@rockstar4095](/rockstar4095) Absolutely, that\\'s what is puzzling me aIso. Not sure if the question needs to be reworded to make this clear! "
                    },
                    {
                        "username": "B0PD0P",
                        "content": "[@kunadilov](/kunadilov)  we have 12 computers that are not connected, then we need at minimum 11 edges to connect these 12 computers with each other and then one extra edge to connect this component to the original component, shouldn't the answer be 12 ?"
                    },
                    {
                        "username": "kunadilov",
                        "content": "[@rockstar4095](/rockstar4095) This 88 computers connected in 2 different networks. So, you have 87 connected and 2 connected between each other. In a result you need minimum 13 connections. "
                    },
                    {
                        "username": "rockstar4095",
                        "content": "same problem with 100-88 computers.\n\ncan anyone provide a smaller example for this configuration?\nare there two or more initial networks actually  instead of one?\n\nI have a very nice 10-lines solution and it fails on this testcase))"
                    },
                    {
                        "username": "rockstar4095",
                        "content": "[@rush2rain](/rush2rain) \\n\\nfrom description:\\n\\n\"Any computer can reach any other computer directly or indirectly through the network.\"\\n\\n\"You are given an initial computer network connections.\"\\n\\naccording to this description, all the initial given computers must be connected."
                    },
                    {
                        "username": "jasona",
                        "content": "[@rush2rain](/rush2rain) ahh thanks! they need to introduce a smaller test case demonstrating that "
                    },
                    {
                        "username": "rush2rain",
                        "content": "Previously, I also attempted the same way. But there happens to be one flaw. What if 88 connected computers are making two separate components of 44 systems each. In that case, we need a wire to connect the two components together as well. So, we need to count the number of components that the whole set of computers is making. "
                    },
                    {
                        "username": "yyol",
                        "content": "same question"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one whose mind screwed up on this question ?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "you just need two things .\\n1. n-1>connections.length  return -1  (don\\'t have enough edge to connect all)\\n2. find number of connected components , return count-1"
                    },
                    {
                        "username": "thatsassygurl21",
                        "content": "Java implentation of your approach:\\nclass Solution {\\n    public int makeConnected(int n, int[][] con){\\n     if(con.length<n-1)return -1;\\n     List<List<Integer>> adj=new ArrayList<>();\\n     for(int i=0;i<n;i++)adj.add(new ArrayList<>());\\n     for(int i=0;i<con.length;i++)\\n     {\\n         adj.get(con[i][0]).add(con[i][1]);\\n          adj.get(con[i][1]).add(con[i][0]);\\n     }\\n     int ans=0;\\n     int vis[]=new int[n];\\n     for(int i=0;i<n;i++)\\n\\n     {\\n         if(vis[i]==0)\\n         {\\n             ans++;\\n             dfs(vis, adj,i);\\n         }   \\n    }\\n    return ans-1;\\n\\n\\n}\\n\\nvoid dfs(int []vis,List<List<Integer>> adj, int n )\\n{\\n    vis[n]=1;\\n    for(int i=0;i<adj.get(n).size();i++)\\n    {\\n    if(vis[adj.get(n).get(i)]==0)\\n    {\\n        dfs(vis,adj,adj.get(n).get(i));\\n    }\\n    }\\n}}"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@daveamol](/daveamol) What is count you are talking about, is it number of disconnected systems?"
                    },
                    {
                        "username": "daveamol",
                        "content": "This is the check I was looking for. That the total numbers of edges for every node to be connected has to be at least (n-1). As minimum edges required to connect n nodes is n-1.\\n\\nI wrote the check like this instead for clarity -\\nconnections.length >= n - 1, then return count - 1, else return -1"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Union Find week ? We are ready!"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "[@UchihaKim](/UchihaKim) you can determine if the node are having same parent node using find(), so if you find the edges are repeated, that mean you can swap that edge to connect other node."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "[@hiper2d](/hiper2d) I solve yesterday question using BFS then I took a look on the related topics and found Union Find, I am still learning it for now,  I can solve the problem using DFS but I want to solve it with that beautiful  DS. If you can give me some tips I\\'d be grateful if you help me."
                    },
                    {
                        "username": "hiper2d",
                        "content": "Same thing here. I keep using Union Find without even considering DFS and BFS. For some reason, this data structure is more obvious solution"
                    },
                    {
                        "username": "Rajkumar_007",
                        "content": "Hint : Find number of clusters"
                    },
                    {
                        "username": "hosua",
                        "content": "Weird, I tried solving this with BFS and got TLE, but it worked fine with DFS. Anyone understand why?"
                    },
                    {
                        "username": "hosua",
                        "content": "[@Crispy_coffee](/Crispy_coffee) I did something similar to this and got TLE"
                    },
                    {
                        "username": "czjnbb",
                        "content": "My py BFS beated more than 80%."
                    },
                    {
                        "username": "try_solving_hard",
                        "content": "Here\\'s my BFS submisson. #referrence Accepted in 1st attempt itself. #pride.\\n\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        \\n        // Find total number of connected components\\n        // Indegree / outdegree sum of all nodes in a connected component\\n        // Find total no of extra cables => (degree sum - required)/2\\n        // where required = (nodes in connected component - 1) * 2\\n        // If extra cables >= connected components - 1\\n        //      return connected components - 1\\n        // Else, \\n        //      return - 1\\n\\n        // Construct Graph\\n\\n        vector<int> adj[n];\\n        vector<long long> deg(n, 0);\\n\\n        for(auto c : connections)\\n        {\\n            adj[c[0]].push_back(c[1]);\\n            adj[c[1]].push_back(c[0]);\\n            deg[c[0]]++;\\n            deg[c[1]]++;\\n        }\\n\\n        vector<bool> vis(n, false);\\n        int cc = 0, extra = 0;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            if (!vis[i])\\n            {\\n                cc++;\\n                long long degree_sum = 0;\\n                int nodes = 0;\\n                vis[i] = true;\\n\\n                queue<int> q({i});\\n\\n                while(!q.empty())\\n                {\\n                    auto v = q.front();\\n                    q.pop();\\n\\n                    nodes++;\\n\\n                    degree_sum += deg[v];\\n\\n                    for(auto nbr : adj[v])\\n                    {\\n                        if (!vis[nbr])\\n                        {\\n                            vis[nbr] = true;\\n                            q.push(nbr);\\n\\n                        }\\n                    }\\n                }\\n\\n                int curr_ex = (degree_sum - ((nodes - 1) * 2)) / 2;\\n                extra += curr_ex;\\n            }\\n        }\\n\\n        return extra >= cc - 1 ? cc - 1 : -1;\\n\\n    }\\n};"
                    },
                    {
                        "username": "RamilZaripov",
                        "content": "I had a TLE on my BFS attempt, after reading your comment also switched to DFS and everything worked!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "I saw your comment and after submmiting my DFS approach i find this solution in submitted solution graph\\n\\n```c++\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& c) \\n    {\\n        if(c.size() < n -1) return -1;\\n        vector<int> adj[n];\\n        for(auto it : c)   \\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        } \\n\\n        int ct = 0;\\n        queue<int> q;\\n        vector<int> vis(n, 0);\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(!vis[i])\\n            {\\n                q.push(i);\\n                vis[i] = 1;\\n                while(!q.empty())\\n                {\\n                    int node = q.front();\\n                    q.pop();\\n                    for(auto it : adj[node])\\n                    {\\n                        if(!vis[it])\\n                        {\\n                            q.push(it);\\n                            vis[it] = 1;\\n                        }\\n                    }\\n                }\\n                ct++;\\n            }\\n        }\\n        return ct-1; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "cJayesh",
                        "content": "This happened with me in python.\nBFS uses more space than DFS.\nAlso depending on implementation, BFS has more add_to_list/add_to_set/enqueue/dequeue operations than DFS.\n"
                    },
                    {
                        "username": "user2575jO",
                        "content": "If `n==1` we will have `1 <= connections.length <= 0`. So this test case will not work."
                    },
                    {
                        "username": "Krrabs",
                        "content": "Union Find approach:\nGo through all the given connections and connect `connections[i][a] to connections[i][b]` pairs if `a & b` are already in a same graph you have an extra edge which can be used for connecting unconnected graphs.\n\nAt the end of `connections array` you should have count of extra edges and unconnected graphs, from these two information you can calculate the answer."
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "I thought about finding Indegree of each node (i.e. number of incoming edges) and then the count of nodes with 0 indegree(no incoming edge) shouldn\\'t it be the answer? It fails some testcases. (Yes, I have considered the case where number of wires are less than n-1) "
                    },
                    {
                        "username": "saichandra004",
                        "content": "Let's suppose we have 100 nodes.\n\n50 nodes are connected in a network.\nother 50 nodes are connected in another network (disjoint graph).\n\nFor the whole 100 nodes to be connected, we need 1 connection to join these two independent networks.\n\nBut if we only count the indegree, this seems that all the nodes are connected, but in reality, there are two different networks. Hence this indegree will lead to answers lesser than expected."
                    }
                ]
            },
            {
                "id": 1840994,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Switch to wireless technology to avoid such type of problems in life "
                    },
                    {
                        "username": "RCchoudhary",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE00 Nice"
                    },
                    {
                        "username": "hahahamid",
                        "content": "real"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "big bren"
                    },
                    {
                        "username": "santanusen",
                        "content": "Ha ha! On a serious note, the backbone networks are still wired, involving optical cables. Though they do have satellite links as emergency failover, those have terrible latencies."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@TsuruLee](/TsuruLee) now deal with 3D Array \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "I think they will create new problems about something like where to place the router to make the signal cover all devices"
                    },
                    {
                        "username": "kaskabay",
                        "content": "Test case:\\n100\\n[[17,51],[33,83],[53,62],[25,34],[35,90],[29,41],[14,53],[40,84],[41,64],[13,68],[44,85],[57,58],[50,74],[20,69],[15,62],[25,88],[4,56],[37,39],[30,62],[69,79],[33,85],[24,83],[35,77],[2,73],[6,28],[46,98],[11,82],[29,72],[67,71],[12,49],[42,56],[56,65],[40,70],[24,64],[29,51],[20,27],[45,88],[58,92],[60,99],[33,46],[19,69],[33,89],[54,82],[16,50],[35,73],[19,45],[19,72],[1,79],[27,80],[22,41],[52,61],[50,85],[27,45],[4,84],[11,96],[0,99],[29,94],[9,19],[66,99],[20,39],[16,85],[12,27],[16,67],[61,80],[67,83],[16,17],[24,27],[16,25],[41,79],[51,95],[46,47],[27,51],[31,44],[0,69],[61,63],[33,95],[17,88],[70,87],[40,42],[21,42],[67,77],[33,65],[3,25],[39,83],[34,40],[15,79],[30,90],[58,95],[45,56],[37,48],[24,91],[31,93],[83,90],[17,86],[61,65],[15,48],[34,56],[12,26],[39,98],[1,48],[21,76],[72,96],[30,69],[46,80],[6,29],[29,81],[22,77],[85,90],[79,83],[6,26],[33,57],[3,65],[63,84],[77,94],[26,90],[64,77],[0,3],[27,97],[66,89],[18,77],[27,43]]\\n\\nThe test case above have 88 already connected computers and 121 cables. So, we only need 12 (100-88) computers to be connected or in other words maximum of 12 cables relocated. How is that possible that answer is 13? It seems that it is not optimal way. I may be wrong in assumtions, if so please let me know."
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "suppose you have 6 computers 123 are connected in a straight line [1-2-3] & all others are connected in the same way [4-5-6] although all computers are connected the answer will be -1 because we cannot reach 4 5 6 starting at 1 2 3"
                    },
                    {
                        "username": "sainadth1123434",
                        "content": "Yeah thats correct even i got this error donno if the solution provided correct or not"
                    },
                    {
                        "username": "ramakiran",
                        "content": "[@ramakiran](/ramakiran) \\nthis is the shorter version of above case there will be 2 connected components so the answer will be 1 \\n"
                    },
                    {
                        "username": "ramakiran",
                        "content": "[@rockstar4095](/rockstar4095)   \\nn=6\\n[[0,1],[0,2],[1,2],[3,4],[4,5]]"
                    },
                    {
                        "username": "pramod74",
                        "content": "[@rockstar4095](/rockstar4095) Absolutely, that\\'s what is puzzling me aIso. Not sure if the question needs to be reworded to make this clear! "
                    },
                    {
                        "username": "B0PD0P",
                        "content": "[@kunadilov](/kunadilov)  we have 12 computers that are not connected, then we need at minimum 11 edges to connect these 12 computers with each other and then one extra edge to connect this component to the original component, shouldn't the answer be 12 ?"
                    },
                    {
                        "username": "kunadilov",
                        "content": "[@rockstar4095](/rockstar4095) This 88 computers connected in 2 different networks. So, you have 87 connected and 2 connected between each other. In a result you need minimum 13 connections. "
                    },
                    {
                        "username": "rockstar4095",
                        "content": "same problem with 100-88 computers.\n\ncan anyone provide a smaller example for this configuration?\nare there two or more initial networks actually  instead of one?\n\nI have a very nice 10-lines solution and it fails on this testcase))"
                    },
                    {
                        "username": "rockstar4095",
                        "content": "[@rush2rain](/rush2rain) \\n\\nfrom description:\\n\\n\"Any computer can reach any other computer directly or indirectly through the network.\"\\n\\n\"You are given an initial computer network connections.\"\\n\\naccording to this description, all the initial given computers must be connected."
                    },
                    {
                        "username": "jasona",
                        "content": "[@rush2rain](/rush2rain) ahh thanks! they need to introduce a smaller test case demonstrating that "
                    },
                    {
                        "username": "rush2rain",
                        "content": "Previously, I also attempted the same way. But there happens to be one flaw. What if 88 connected computers are making two separate components of 44 systems each. In that case, we need a wire to connect the two components together as well. So, we need to count the number of components that the whole set of computers is making. "
                    },
                    {
                        "username": "yyol",
                        "content": "same question"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one whose mind screwed up on this question ?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "you just need two things .\\n1. n-1>connections.length  return -1  (don\\'t have enough edge to connect all)\\n2. find number of connected components , return count-1"
                    },
                    {
                        "username": "thatsassygurl21",
                        "content": "Java implentation of your approach:\\nclass Solution {\\n    public int makeConnected(int n, int[][] con){\\n     if(con.length<n-1)return -1;\\n     List<List<Integer>> adj=new ArrayList<>();\\n     for(int i=0;i<n;i++)adj.add(new ArrayList<>());\\n     for(int i=0;i<con.length;i++)\\n     {\\n         adj.get(con[i][0]).add(con[i][1]);\\n          adj.get(con[i][1]).add(con[i][0]);\\n     }\\n     int ans=0;\\n     int vis[]=new int[n];\\n     for(int i=0;i<n;i++)\\n\\n     {\\n         if(vis[i]==0)\\n         {\\n             ans++;\\n             dfs(vis, adj,i);\\n         }   \\n    }\\n    return ans-1;\\n\\n\\n}\\n\\nvoid dfs(int []vis,List<List<Integer>> adj, int n )\\n{\\n    vis[n]=1;\\n    for(int i=0;i<adj.get(n).size();i++)\\n    {\\n    if(vis[adj.get(n).get(i)]==0)\\n    {\\n        dfs(vis,adj,adj.get(n).get(i));\\n    }\\n    }\\n}}"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@daveamol](/daveamol) What is count you are talking about, is it number of disconnected systems?"
                    },
                    {
                        "username": "daveamol",
                        "content": "This is the check I was looking for. That the total numbers of edges for every node to be connected has to be at least (n-1). As minimum edges required to connect n nodes is n-1.\\n\\nI wrote the check like this instead for clarity -\\nconnections.length >= n - 1, then return count - 1, else return -1"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Union Find week ? We are ready!"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "[@UchihaKim](/UchihaKim) you can determine if the node are having same parent node using find(), so if you find the edges are repeated, that mean you can swap that edge to connect other node."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "[@hiper2d](/hiper2d) I solve yesterday question using BFS then I took a look on the related topics and found Union Find, I am still learning it for now,  I can solve the problem using DFS but I want to solve it with that beautiful  DS. If you can give me some tips I\\'d be grateful if you help me."
                    },
                    {
                        "username": "hiper2d",
                        "content": "Same thing here. I keep using Union Find without even considering DFS and BFS. For some reason, this data structure is more obvious solution"
                    },
                    {
                        "username": "Rajkumar_007",
                        "content": "Hint : Find number of clusters"
                    },
                    {
                        "username": "hosua",
                        "content": "Weird, I tried solving this with BFS and got TLE, but it worked fine with DFS. Anyone understand why?"
                    },
                    {
                        "username": "hosua",
                        "content": "[@Crispy_coffee](/Crispy_coffee) I did something similar to this and got TLE"
                    },
                    {
                        "username": "czjnbb",
                        "content": "My py BFS beated more than 80%."
                    },
                    {
                        "username": "try_solving_hard",
                        "content": "Here\\'s my BFS submisson. #referrence Accepted in 1st attempt itself. #pride.\\n\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        \\n        // Find total number of connected components\\n        // Indegree / outdegree sum of all nodes in a connected component\\n        // Find total no of extra cables => (degree sum - required)/2\\n        // where required = (nodes in connected component - 1) * 2\\n        // If extra cables >= connected components - 1\\n        //      return connected components - 1\\n        // Else, \\n        //      return - 1\\n\\n        // Construct Graph\\n\\n        vector<int> adj[n];\\n        vector<long long> deg(n, 0);\\n\\n        for(auto c : connections)\\n        {\\n            adj[c[0]].push_back(c[1]);\\n            adj[c[1]].push_back(c[0]);\\n            deg[c[0]]++;\\n            deg[c[1]]++;\\n        }\\n\\n        vector<bool> vis(n, false);\\n        int cc = 0, extra = 0;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            if (!vis[i])\\n            {\\n                cc++;\\n                long long degree_sum = 0;\\n                int nodes = 0;\\n                vis[i] = true;\\n\\n                queue<int> q({i});\\n\\n                while(!q.empty())\\n                {\\n                    auto v = q.front();\\n                    q.pop();\\n\\n                    nodes++;\\n\\n                    degree_sum += deg[v];\\n\\n                    for(auto nbr : adj[v])\\n                    {\\n                        if (!vis[nbr])\\n                        {\\n                            vis[nbr] = true;\\n                            q.push(nbr);\\n\\n                        }\\n                    }\\n                }\\n\\n                int curr_ex = (degree_sum - ((nodes - 1) * 2)) / 2;\\n                extra += curr_ex;\\n            }\\n        }\\n\\n        return extra >= cc - 1 ? cc - 1 : -1;\\n\\n    }\\n};"
                    },
                    {
                        "username": "RamilZaripov",
                        "content": "I had a TLE on my BFS attempt, after reading your comment also switched to DFS and everything worked!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "I saw your comment and after submmiting my DFS approach i find this solution in submitted solution graph\\n\\n```c++\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& c) \\n    {\\n        if(c.size() < n -1) return -1;\\n        vector<int> adj[n];\\n        for(auto it : c)   \\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        } \\n\\n        int ct = 0;\\n        queue<int> q;\\n        vector<int> vis(n, 0);\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(!vis[i])\\n            {\\n                q.push(i);\\n                vis[i] = 1;\\n                while(!q.empty())\\n                {\\n                    int node = q.front();\\n                    q.pop();\\n                    for(auto it : adj[node])\\n                    {\\n                        if(!vis[it])\\n                        {\\n                            q.push(it);\\n                            vis[it] = 1;\\n                        }\\n                    }\\n                }\\n                ct++;\\n            }\\n        }\\n        return ct-1; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "cJayesh",
                        "content": "This happened with me in python.\nBFS uses more space than DFS.\nAlso depending on implementation, BFS has more add_to_list/add_to_set/enqueue/dequeue operations than DFS.\n"
                    },
                    {
                        "username": "user2575jO",
                        "content": "If `n==1` we will have `1 <= connections.length <= 0`. So this test case will not work."
                    },
                    {
                        "username": "Krrabs",
                        "content": "Union Find approach:\nGo through all the given connections and connect `connections[i][a] to connections[i][b]` pairs if `a & b` are already in a same graph you have an extra edge which can be used for connecting unconnected graphs.\n\nAt the end of `connections array` you should have count of extra edges and unconnected graphs, from these two information you can calculate the answer."
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "I thought about finding Indegree of each node (i.e. number of incoming edges) and then the count of nodes with 0 indegree(no incoming edge) shouldn\\'t it be the answer? It fails some testcases. (Yes, I have considered the case where number of wires are less than n-1) "
                    },
                    {
                        "username": "saichandra004",
                        "content": "Let's suppose we have 100 nodes.\n\n50 nodes are connected in a network.\nother 50 nodes are connected in another network (disjoint graph).\n\nFor the whole 100 nodes to be connected, we need 1 connection to join these two independent networks.\n\nBut if we only count the indegree, this seems that all the nodes are connected, but in reality, there are two different networks. Hence this indegree will lead to answers lesser than expected."
                    }
                ]
            },
            {
                "id": 1841051,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Switch to wireless technology to avoid such type of problems in life "
                    },
                    {
                        "username": "RCchoudhary",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE00 Nice"
                    },
                    {
                        "username": "hahahamid",
                        "content": "real"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "big bren"
                    },
                    {
                        "username": "santanusen",
                        "content": "Ha ha! On a serious note, the backbone networks are still wired, involving optical cables. Though they do have satellite links as emergency failover, those have terrible latencies."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@TsuruLee](/TsuruLee) now deal with 3D Array \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "I think they will create new problems about something like where to place the router to make the signal cover all devices"
                    },
                    {
                        "username": "kaskabay",
                        "content": "Test case:\\n100\\n[[17,51],[33,83],[53,62],[25,34],[35,90],[29,41],[14,53],[40,84],[41,64],[13,68],[44,85],[57,58],[50,74],[20,69],[15,62],[25,88],[4,56],[37,39],[30,62],[69,79],[33,85],[24,83],[35,77],[2,73],[6,28],[46,98],[11,82],[29,72],[67,71],[12,49],[42,56],[56,65],[40,70],[24,64],[29,51],[20,27],[45,88],[58,92],[60,99],[33,46],[19,69],[33,89],[54,82],[16,50],[35,73],[19,45],[19,72],[1,79],[27,80],[22,41],[52,61],[50,85],[27,45],[4,84],[11,96],[0,99],[29,94],[9,19],[66,99],[20,39],[16,85],[12,27],[16,67],[61,80],[67,83],[16,17],[24,27],[16,25],[41,79],[51,95],[46,47],[27,51],[31,44],[0,69],[61,63],[33,95],[17,88],[70,87],[40,42],[21,42],[67,77],[33,65],[3,25],[39,83],[34,40],[15,79],[30,90],[58,95],[45,56],[37,48],[24,91],[31,93],[83,90],[17,86],[61,65],[15,48],[34,56],[12,26],[39,98],[1,48],[21,76],[72,96],[30,69],[46,80],[6,29],[29,81],[22,77],[85,90],[79,83],[6,26],[33,57],[3,65],[63,84],[77,94],[26,90],[64,77],[0,3],[27,97],[66,89],[18,77],[27,43]]\\n\\nThe test case above have 88 already connected computers and 121 cables. So, we only need 12 (100-88) computers to be connected or in other words maximum of 12 cables relocated. How is that possible that answer is 13? It seems that it is not optimal way. I may be wrong in assumtions, if so please let me know."
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "suppose you have 6 computers 123 are connected in a straight line [1-2-3] & all others are connected in the same way [4-5-6] although all computers are connected the answer will be -1 because we cannot reach 4 5 6 starting at 1 2 3"
                    },
                    {
                        "username": "sainadth1123434",
                        "content": "Yeah thats correct even i got this error donno if the solution provided correct or not"
                    },
                    {
                        "username": "ramakiran",
                        "content": "[@ramakiran](/ramakiran) \\nthis is the shorter version of above case there will be 2 connected components so the answer will be 1 \\n"
                    },
                    {
                        "username": "ramakiran",
                        "content": "[@rockstar4095](/rockstar4095)   \\nn=6\\n[[0,1],[0,2],[1,2],[3,4],[4,5]]"
                    },
                    {
                        "username": "pramod74",
                        "content": "[@rockstar4095](/rockstar4095) Absolutely, that\\'s what is puzzling me aIso. Not sure if the question needs to be reworded to make this clear! "
                    },
                    {
                        "username": "B0PD0P",
                        "content": "[@kunadilov](/kunadilov)  we have 12 computers that are not connected, then we need at minimum 11 edges to connect these 12 computers with each other and then one extra edge to connect this component to the original component, shouldn't the answer be 12 ?"
                    },
                    {
                        "username": "kunadilov",
                        "content": "[@rockstar4095](/rockstar4095) This 88 computers connected in 2 different networks. So, you have 87 connected and 2 connected between each other. In a result you need minimum 13 connections. "
                    },
                    {
                        "username": "rockstar4095",
                        "content": "same problem with 100-88 computers.\n\ncan anyone provide a smaller example for this configuration?\nare there two or more initial networks actually  instead of one?\n\nI have a very nice 10-lines solution and it fails on this testcase))"
                    },
                    {
                        "username": "rockstar4095",
                        "content": "[@rush2rain](/rush2rain) \\n\\nfrom description:\\n\\n\"Any computer can reach any other computer directly or indirectly through the network.\"\\n\\n\"You are given an initial computer network connections.\"\\n\\naccording to this description, all the initial given computers must be connected."
                    },
                    {
                        "username": "jasona",
                        "content": "[@rush2rain](/rush2rain) ahh thanks! they need to introduce a smaller test case demonstrating that "
                    },
                    {
                        "username": "rush2rain",
                        "content": "Previously, I also attempted the same way. But there happens to be one flaw. What if 88 connected computers are making two separate components of 44 systems each. In that case, we need a wire to connect the two components together as well. So, we need to count the number of components that the whole set of computers is making. "
                    },
                    {
                        "username": "yyol",
                        "content": "same question"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one whose mind screwed up on this question ?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "you just need two things .\\n1. n-1>connections.length  return -1  (don\\'t have enough edge to connect all)\\n2. find number of connected components , return count-1"
                    },
                    {
                        "username": "thatsassygurl21",
                        "content": "Java implentation of your approach:\\nclass Solution {\\n    public int makeConnected(int n, int[][] con){\\n     if(con.length<n-1)return -1;\\n     List<List<Integer>> adj=new ArrayList<>();\\n     for(int i=0;i<n;i++)adj.add(new ArrayList<>());\\n     for(int i=0;i<con.length;i++)\\n     {\\n         adj.get(con[i][0]).add(con[i][1]);\\n          adj.get(con[i][1]).add(con[i][0]);\\n     }\\n     int ans=0;\\n     int vis[]=new int[n];\\n     for(int i=0;i<n;i++)\\n\\n     {\\n         if(vis[i]==0)\\n         {\\n             ans++;\\n             dfs(vis, adj,i);\\n         }   \\n    }\\n    return ans-1;\\n\\n\\n}\\n\\nvoid dfs(int []vis,List<List<Integer>> adj, int n )\\n{\\n    vis[n]=1;\\n    for(int i=0;i<adj.get(n).size();i++)\\n    {\\n    if(vis[adj.get(n).get(i)]==0)\\n    {\\n        dfs(vis,adj,adj.get(n).get(i));\\n    }\\n    }\\n}}"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@daveamol](/daveamol) What is count you are talking about, is it number of disconnected systems?"
                    },
                    {
                        "username": "daveamol",
                        "content": "This is the check I was looking for. That the total numbers of edges for every node to be connected has to be at least (n-1). As minimum edges required to connect n nodes is n-1.\\n\\nI wrote the check like this instead for clarity -\\nconnections.length >= n - 1, then return count - 1, else return -1"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Union Find week ? We are ready!"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "[@UchihaKim](/UchihaKim) you can determine if the node are having same parent node using find(), so if you find the edges are repeated, that mean you can swap that edge to connect other node."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "[@hiper2d](/hiper2d) I solve yesterday question using BFS then I took a look on the related topics and found Union Find, I am still learning it for now,  I can solve the problem using DFS but I want to solve it with that beautiful  DS. If you can give me some tips I\\'d be grateful if you help me."
                    },
                    {
                        "username": "hiper2d",
                        "content": "Same thing here. I keep using Union Find without even considering DFS and BFS. For some reason, this data structure is more obvious solution"
                    },
                    {
                        "username": "Rajkumar_007",
                        "content": "Hint : Find number of clusters"
                    },
                    {
                        "username": "hosua",
                        "content": "Weird, I tried solving this with BFS and got TLE, but it worked fine with DFS. Anyone understand why?"
                    },
                    {
                        "username": "hosua",
                        "content": "[@Crispy_coffee](/Crispy_coffee) I did something similar to this and got TLE"
                    },
                    {
                        "username": "czjnbb",
                        "content": "My py BFS beated more than 80%."
                    },
                    {
                        "username": "try_solving_hard",
                        "content": "Here\\'s my BFS submisson. #referrence Accepted in 1st attempt itself. #pride.\\n\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        \\n        // Find total number of connected components\\n        // Indegree / outdegree sum of all nodes in a connected component\\n        // Find total no of extra cables => (degree sum - required)/2\\n        // where required = (nodes in connected component - 1) * 2\\n        // If extra cables >= connected components - 1\\n        //      return connected components - 1\\n        // Else, \\n        //      return - 1\\n\\n        // Construct Graph\\n\\n        vector<int> adj[n];\\n        vector<long long> deg(n, 0);\\n\\n        for(auto c : connections)\\n        {\\n            adj[c[0]].push_back(c[1]);\\n            adj[c[1]].push_back(c[0]);\\n            deg[c[0]]++;\\n            deg[c[1]]++;\\n        }\\n\\n        vector<bool> vis(n, false);\\n        int cc = 0, extra = 0;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            if (!vis[i])\\n            {\\n                cc++;\\n                long long degree_sum = 0;\\n                int nodes = 0;\\n                vis[i] = true;\\n\\n                queue<int> q({i});\\n\\n                while(!q.empty())\\n                {\\n                    auto v = q.front();\\n                    q.pop();\\n\\n                    nodes++;\\n\\n                    degree_sum += deg[v];\\n\\n                    for(auto nbr : adj[v])\\n                    {\\n                        if (!vis[nbr])\\n                        {\\n                            vis[nbr] = true;\\n                            q.push(nbr);\\n\\n                        }\\n                    }\\n                }\\n\\n                int curr_ex = (degree_sum - ((nodes - 1) * 2)) / 2;\\n                extra += curr_ex;\\n            }\\n        }\\n\\n        return extra >= cc - 1 ? cc - 1 : -1;\\n\\n    }\\n};"
                    },
                    {
                        "username": "RamilZaripov",
                        "content": "I had a TLE on my BFS attempt, after reading your comment also switched to DFS and everything worked!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "I saw your comment and after submmiting my DFS approach i find this solution in submitted solution graph\\n\\n```c++\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& c) \\n    {\\n        if(c.size() < n -1) return -1;\\n        vector<int> adj[n];\\n        for(auto it : c)   \\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        } \\n\\n        int ct = 0;\\n        queue<int> q;\\n        vector<int> vis(n, 0);\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(!vis[i])\\n            {\\n                q.push(i);\\n                vis[i] = 1;\\n                while(!q.empty())\\n                {\\n                    int node = q.front();\\n                    q.pop();\\n                    for(auto it : adj[node])\\n                    {\\n                        if(!vis[it])\\n                        {\\n                            q.push(it);\\n                            vis[it] = 1;\\n                        }\\n                    }\\n                }\\n                ct++;\\n            }\\n        }\\n        return ct-1; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "cJayesh",
                        "content": "This happened with me in python.\nBFS uses more space than DFS.\nAlso depending on implementation, BFS has more add_to_list/add_to_set/enqueue/dequeue operations than DFS.\n"
                    },
                    {
                        "username": "user2575jO",
                        "content": "If `n==1` we will have `1 <= connections.length <= 0`. So this test case will not work."
                    },
                    {
                        "username": "Krrabs",
                        "content": "Union Find approach:\nGo through all the given connections and connect `connections[i][a] to connections[i][b]` pairs if `a & b` are already in a same graph you have an extra edge which can be used for connecting unconnected graphs.\n\nAt the end of `connections array` you should have count of extra edges and unconnected graphs, from these two information you can calculate the answer."
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "I thought about finding Indegree of each node (i.e. number of incoming edges) and then the count of nodes with 0 indegree(no incoming edge) shouldn\\'t it be the answer? It fails some testcases. (Yes, I have considered the case where number of wires are less than n-1) "
                    },
                    {
                        "username": "saichandra004",
                        "content": "Let's suppose we have 100 nodes.\n\n50 nodes are connected in a network.\nother 50 nodes are connected in another network (disjoint graph).\n\nFor the whole 100 nodes to be connected, we need 1 connection to join these two independent networks.\n\nBut if we only count the indegree, this seems that all the nodes are connected, but in reality, there are two different networks. Hence this indegree will lead to answers lesser than expected."
                    }
                ]
            },
            {
                "id": 1841217,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Switch to wireless technology to avoid such type of problems in life "
                    },
                    {
                        "username": "RCchoudhary",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE00 Nice"
                    },
                    {
                        "username": "hahahamid",
                        "content": "real"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "big bren"
                    },
                    {
                        "username": "santanusen",
                        "content": "Ha ha! On a serious note, the backbone networks are still wired, involving optical cables. Though they do have satellite links as emergency failover, those have terrible latencies."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@TsuruLee](/TsuruLee) now deal with 3D Array \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "I think they will create new problems about something like where to place the router to make the signal cover all devices"
                    },
                    {
                        "username": "kaskabay",
                        "content": "Test case:\\n100\\n[[17,51],[33,83],[53,62],[25,34],[35,90],[29,41],[14,53],[40,84],[41,64],[13,68],[44,85],[57,58],[50,74],[20,69],[15,62],[25,88],[4,56],[37,39],[30,62],[69,79],[33,85],[24,83],[35,77],[2,73],[6,28],[46,98],[11,82],[29,72],[67,71],[12,49],[42,56],[56,65],[40,70],[24,64],[29,51],[20,27],[45,88],[58,92],[60,99],[33,46],[19,69],[33,89],[54,82],[16,50],[35,73],[19,45],[19,72],[1,79],[27,80],[22,41],[52,61],[50,85],[27,45],[4,84],[11,96],[0,99],[29,94],[9,19],[66,99],[20,39],[16,85],[12,27],[16,67],[61,80],[67,83],[16,17],[24,27],[16,25],[41,79],[51,95],[46,47],[27,51],[31,44],[0,69],[61,63],[33,95],[17,88],[70,87],[40,42],[21,42],[67,77],[33,65],[3,25],[39,83],[34,40],[15,79],[30,90],[58,95],[45,56],[37,48],[24,91],[31,93],[83,90],[17,86],[61,65],[15,48],[34,56],[12,26],[39,98],[1,48],[21,76],[72,96],[30,69],[46,80],[6,29],[29,81],[22,77],[85,90],[79,83],[6,26],[33,57],[3,65],[63,84],[77,94],[26,90],[64,77],[0,3],[27,97],[66,89],[18,77],[27,43]]\\n\\nThe test case above have 88 already connected computers and 121 cables. So, we only need 12 (100-88) computers to be connected or in other words maximum of 12 cables relocated. How is that possible that answer is 13? It seems that it is not optimal way. I may be wrong in assumtions, if so please let me know."
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "suppose you have 6 computers 123 are connected in a straight line [1-2-3] & all others are connected in the same way [4-5-6] although all computers are connected the answer will be -1 because we cannot reach 4 5 6 starting at 1 2 3"
                    },
                    {
                        "username": "sainadth1123434",
                        "content": "Yeah thats correct even i got this error donno if the solution provided correct or not"
                    },
                    {
                        "username": "ramakiran",
                        "content": "[@ramakiran](/ramakiran) \\nthis is the shorter version of above case there will be 2 connected components so the answer will be 1 \\n"
                    },
                    {
                        "username": "ramakiran",
                        "content": "[@rockstar4095](/rockstar4095)   \\nn=6\\n[[0,1],[0,2],[1,2],[3,4],[4,5]]"
                    },
                    {
                        "username": "pramod74",
                        "content": "[@rockstar4095](/rockstar4095) Absolutely, that\\'s what is puzzling me aIso. Not sure if the question needs to be reworded to make this clear! "
                    },
                    {
                        "username": "B0PD0P",
                        "content": "[@kunadilov](/kunadilov)  we have 12 computers that are not connected, then we need at minimum 11 edges to connect these 12 computers with each other and then one extra edge to connect this component to the original component, shouldn't the answer be 12 ?"
                    },
                    {
                        "username": "kunadilov",
                        "content": "[@rockstar4095](/rockstar4095) This 88 computers connected in 2 different networks. So, you have 87 connected and 2 connected between each other. In a result you need minimum 13 connections. "
                    },
                    {
                        "username": "rockstar4095",
                        "content": "same problem with 100-88 computers.\n\ncan anyone provide a smaller example for this configuration?\nare there two or more initial networks actually  instead of one?\n\nI have a very nice 10-lines solution and it fails on this testcase))"
                    },
                    {
                        "username": "rockstar4095",
                        "content": "[@rush2rain](/rush2rain) \\n\\nfrom description:\\n\\n\"Any computer can reach any other computer directly or indirectly through the network.\"\\n\\n\"You are given an initial computer network connections.\"\\n\\naccording to this description, all the initial given computers must be connected."
                    },
                    {
                        "username": "jasona",
                        "content": "[@rush2rain](/rush2rain) ahh thanks! they need to introduce a smaller test case demonstrating that "
                    },
                    {
                        "username": "rush2rain",
                        "content": "Previously, I also attempted the same way. But there happens to be one flaw. What if 88 connected computers are making two separate components of 44 systems each. In that case, we need a wire to connect the two components together as well. So, we need to count the number of components that the whole set of computers is making. "
                    },
                    {
                        "username": "yyol",
                        "content": "same question"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one whose mind screwed up on this question ?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "you just need two things .\\n1. n-1>connections.length  return -1  (don\\'t have enough edge to connect all)\\n2. find number of connected components , return count-1"
                    },
                    {
                        "username": "thatsassygurl21",
                        "content": "Java implentation of your approach:\\nclass Solution {\\n    public int makeConnected(int n, int[][] con){\\n     if(con.length<n-1)return -1;\\n     List<List<Integer>> adj=new ArrayList<>();\\n     for(int i=0;i<n;i++)adj.add(new ArrayList<>());\\n     for(int i=0;i<con.length;i++)\\n     {\\n         adj.get(con[i][0]).add(con[i][1]);\\n          adj.get(con[i][1]).add(con[i][0]);\\n     }\\n     int ans=0;\\n     int vis[]=new int[n];\\n     for(int i=0;i<n;i++)\\n\\n     {\\n         if(vis[i]==0)\\n         {\\n             ans++;\\n             dfs(vis, adj,i);\\n         }   \\n    }\\n    return ans-1;\\n\\n\\n}\\n\\nvoid dfs(int []vis,List<List<Integer>> adj, int n )\\n{\\n    vis[n]=1;\\n    for(int i=0;i<adj.get(n).size();i++)\\n    {\\n    if(vis[adj.get(n).get(i)]==0)\\n    {\\n        dfs(vis,adj,adj.get(n).get(i));\\n    }\\n    }\\n}}"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@daveamol](/daveamol) What is count you are talking about, is it number of disconnected systems?"
                    },
                    {
                        "username": "daveamol",
                        "content": "This is the check I was looking for. That the total numbers of edges for every node to be connected has to be at least (n-1). As minimum edges required to connect n nodes is n-1.\\n\\nI wrote the check like this instead for clarity -\\nconnections.length >= n - 1, then return count - 1, else return -1"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Union Find week ? We are ready!"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "[@UchihaKim](/UchihaKim) you can determine if the node are having same parent node using find(), so if you find the edges are repeated, that mean you can swap that edge to connect other node."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "[@hiper2d](/hiper2d) I solve yesterday question using BFS then I took a look on the related topics and found Union Find, I am still learning it for now,  I can solve the problem using DFS but I want to solve it with that beautiful  DS. If you can give me some tips I\\'d be grateful if you help me."
                    },
                    {
                        "username": "hiper2d",
                        "content": "Same thing here. I keep using Union Find without even considering DFS and BFS. For some reason, this data structure is more obvious solution"
                    },
                    {
                        "username": "Rajkumar_007",
                        "content": "Hint : Find number of clusters"
                    },
                    {
                        "username": "hosua",
                        "content": "Weird, I tried solving this with BFS and got TLE, but it worked fine with DFS. Anyone understand why?"
                    },
                    {
                        "username": "hosua",
                        "content": "[@Crispy_coffee](/Crispy_coffee) I did something similar to this and got TLE"
                    },
                    {
                        "username": "czjnbb",
                        "content": "My py BFS beated more than 80%."
                    },
                    {
                        "username": "try_solving_hard",
                        "content": "Here\\'s my BFS submisson. #referrence Accepted in 1st attempt itself. #pride.\\n\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        \\n        // Find total number of connected components\\n        // Indegree / outdegree sum of all nodes in a connected component\\n        // Find total no of extra cables => (degree sum - required)/2\\n        // where required = (nodes in connected component - 1) * 2\\n        // If extra cables >= connected components - 1\\n        //      return connected components - 1\\n        // Else, \\n        //      return - 1\\n\\n        // Construct Graph\\n\\n        vector<int> adj[n];\\n        vector<long long> deg(n, 0);\\n\\n        for(auto c : connections)\\n        {\\n            adj[c[0]].push_back(c[1]);\\n            adj[c[1]].push_back(c[0]);\\n            deg[c[0]]++;\\n            deg[c[1]]++;\\n        }\\n\\n        vector<bool> vis(n, false);\\n        int cc = 0, extra = 0;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            if (!vis[i])\\n            {\\n                cc++;\\n                long long degree_sum = 0;\\n                int nodes = 0;\\n                vis[i] = true;\\n\\n                queue<int> q({i});\\n\\n                while(!q.empty())\\n                {\\n                    auto v = q.front();\\n                    q.pop();\\n\\n                    nodes++;\\n\\n                    degree_sum += deg[v];\\n\\n                    for(auto nbr : adj[v])\\n                    {\\n                        if (!vis[nbr])\\n                        {\\n                            vis[nbr] = true;\\n                            q.push(nbr);\\n\\n                        }\\n                    }\\n                }\\n\\n                int curr_ex = (degree_sum - ((nodes - 1) * 2)) / 2;\\n                extra += curr_ex;\\n            }\\n        }\\n\\n        return extra >= cc - 1 ? cc - 1 : -1;\\n\\n    }\\n};"
                    },
                    {
                        "username": "RamilZaripov",
                        "content": "I had a TLE on my BFS attempt, after reading your comment also switched to DFS and everything worked!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "I saw your comment and after submmiting my DFS approach i find this solution in submitted solution graph\\n\\n```c++\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& c) \\n    {\\n        if(c.size() < n -1) return -1;\\n        vector<int> adj[n];\\n        for(auto it : c)   \\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        } \\n\\n        int ct = 0;\\n        queue<int> q;\\n        vector<int> vis(n, 0);\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(!vis[i])\\n            {\\n                q.push(i);\\n                vis[i] = 1;\\n                while(!q.empty())\\n                {\\n                    int node = q.front();\\n                    q.pop();\\n                    for(auto it : adj[node])\\n                    {\\n                        if(!vis[it])\\n                        {\\n                            q.push(it);\\n                            vis[it] = 1;\\n                        }\\n                    }\\n                }\\n                ct++;\\n            }\\n        }\\n        return ct-1; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "cJayesh",
                        "content": "This happened with me in python.\nBFS uses more space than DFS.\nAlso depending on implementation, BFS has more add_to_list/add_to_set/enqueue/dequeue operations than DFS.\n"
                    },
                    {
                        "username": "user2575jO",
                        "content": "If `n==1` we will have `1 <= connections.length <= 0`. So this test case will not work."
                    },
                    {
                        "username": "Krrabs",
                        "content": "Union Find approach:\nGo through all the given connections and connect `connections[i][a] to connections[i][b]` pairs if `a & b` are already in a same graph you have an extra edge which can be used for connecting unconnected graphs.\n\nAt the end of `connections array` you should have count of extra edges and unconnected graphs, from these two information you can calculate the answer."
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "I thought about finding Indegree of each node (i.e. number of incoming edges) and then the count of nodes with 0 indegree(no incoming edge) shouldn\\'t it be the answer? It fails some testcases. (Yes, I have considered the case where number of wires are less than n-1) "
                    },
                    {
                        "username": "saichandra004",
                        "content": "Let's suppose we have 100 nodes.\n\n50 nodes are connected in a network.\nother 50 nodes are connected in another network (disjoint graph).\n\nFor the whole 100 nodes to be connected, we need 1 connection to join these two independent networks.\n\nBut if we only count the indegree, this seems that all the nodes are connected, but in reality, there are two different networks. Hence this indegree will lead to answers lesser than expected."
                    }
                ]
            },
            {
                "id": 1840941,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Switch to wireless technology to avoid such type of problems in life "
                    },
                    {
                        "username": "RCchoudhary",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE00 Nice"
                    },
                    {
                        "username": "hahahamid",
                        "content": "real"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "big bren"
                    },
                    {
                        "username": "santanusen",
                        "content": "Ha ha! On a serious note, the backbone networks are still wired, involving optical cables. Though they do have satellite links as emergency failover, those have terrible latencies."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@TsuruLee](/TsuruLee) now deal with 3D Array \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "I think they will create new problems about something like where to place the router to make the signal cover all devices"
                    },
                    {
                        "username": "kaskabay",
                        "content": "Test case:\\n100\\n[[17,51],[33,83],[53,62],[25,34],[35,90],[29,41],[14,53],[40,84],[41,64],[13,68],[44,85],[57,58],[50,74],[20,69],[15,62],[25,88],[4,56],[37,39],[30,62],[69,79],[33,85],[24,83],[35,77],[2,73],[6,28],[46,98],[11,82],[29,72],[67,71],[12,49],[42,56],[56,65],[40,70],[24,64],[29,51],[20,27],[45,88],[58,92],[60,99],[33,46],[19,69],[33,89],[54,82],[16,50],[35,73],[19,45],[19,72],[1,79],[27,80],[22,41],[52,61],[50,85],[27,45],[4,84],[11,96],[0,99],[29,94],[9,19],[66,99],[20,39],[16,85],[12,27],[16,67],[61,80],[67,83],[16,17],[24,27],[16,25],[41,79],[51,95],[46,47],[27,51],[31,44],[0,69],[61,63],[33,95],[17,88],[70,87],[40,42],[21,42],[67,77],[33,65],[3,25],[39,83],[34,40],[15,79],[30,90],[58,95],[45,56],[37,48],[24,91],[31,93],[83,90],[17,86],[61,65],[15,48],[34,56],[12,26],[39,98],[1,48],[21,76],[72,96],[30,69],[46,80],[6,29],[29,81],[22,77],[85,90],[79,83],[6,26],[33,57],[3,65],[63,84],[77,94],[26,90],[64,77],[0,3],[27,97],[66,89],[18,77],[27,43]]\\n\\nThe test case above have 88 already connected computers and 121 cables. So, we only need 12 (100-88) computers to be connected or in other words maximum of 12 cables relocated. How is that possible that answer is 13? It seems that it is not optimal way. I may be wrong in assumtions, if so please let me know."
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "suppose you have 6 computers 123 are connected in a straight line [1-2-3] & all others are connected in the same way [4-5-6] although all computers are connected the answer will be -1 because we cannot reach 4 5 6 starting at 1 2 3"
                    },
                    {
                        "username": "sainadth1123434",
                        "content": "Yeah thats correct even i got this error donno if the solution provided correct or not"
                    },
                    {
                        "username": "ramakiran",
                        "content": "[@ramakiran](/ramakiran) \\nthis is the shorter version of above case there will be 2 connected components so the answer will be 1 \\n"
                    },
                    {
                        "username": "ramakiran",
                        "content": "[@rockstar4095](/rockstar4095)   \\nn=6\\n[[0,1],[0,2],[1,2],[3,4],[4,5]]"
                    },
                    {
                        "username": "pramod74",
                        "content": "[@rockstar4095](/rockstar4095) Absolutely, that\\'s what is puzzling me aIso. Not sure if the question needs to be reworded to make this clear! "
                    },
                    {
                        "username": "B0PD0P",
                        "content": "[@kunadilov](/kunadilov)  we have 12 computers that are not connected, then we need at minimum 11 edges to connect these 12 computers with each other and then one extra edge to connect this component to the original component, shouldn't the answer be 12 ?"
                    },
                    {
                        "username": "kunadilov",
                        "content": "[@rockstar4095](/rockstar4095) This 88 computers connected in 2 different networks. So, you have 87 connected and 2 connected between each other. In a result you need minimum 13 connections. "
                    },
                    {
                        "username": "rockstar4095",
                        "content": "same problem with 100-88 computers.\n\ncan anyone provide a smaller example for this configuration?\nare there two or more initial networks actually  instead of one?\n\nI have a very nice 10-lines solution and it fails on this testcase))"
                    },
                    {
                        "username": "rockstar4095",
                        "content": "[@rush2rain](/rush2rain) \\n\\nfrom description:\\n\\n\"Any computer can reach any other computer directly or indirectly through the network.\"\\n\\n\"You are given an initial computer network connections.\"\\n\\naccording to this description, all the initial given computers must be connected."
                    },
                    {
                        "username": "jasona",
                        "content": "[@rush2rain](/rush2rain) ahh thanks! they need to introduce a smaller test case demonstrating that "
                    },
                    {
                        "username": "rush2rain",
                        "content": "Previously, I also attempted the same way. But there happens to be one flaw. What if 88 connected computers are making two separate components of 44 systems each. In that case, we need a wire to connect the two components together as well. So, we need to count the number of components that the whole set of computers is making. "
                    },
                    {
                        "username": "yyol",
                        "content": "same question"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one whose mind screwed up on this question ?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "you just need two things .\\n1. n-1>connections.length  return -1  (don\\'t have enough edge to connect all)\\n2. find number of connected components , return count-1"
                    },
                    {
                        "username": "thatsassygurl21",
                        "content": "Java implentation of your approach:\\nclass Solution {\\n    public int makeConnected(int n, int[][] con){\\n     if(con.length<n-1)return -1;\\n     List<List<Integer>> adj=new ArrayList<>();\\n     for(int i=0;i<n;i++)adj.add(new ArrayList<>());\\n     for(int i=0;i<con.length;i++)\\n     {\\n         adj.get(con[i][0]).add(con[i][1]);\\n          adj.get(con[i][1]).add(con[i][0]);\\n     }\\n     int ans=0;\\n     int vis[]=new int[n];\\n     for(int i=0;i<n;i++)\\n\\n     {\\n         if(vis[i]==0)\\n         {\\n             ans++;\\n             dfs(vis, adj,i);\\n         }   \\n    }\\n    return ans-1;\\n\\n\\n}\\n\\nvoid dfs(int []vis,List<List<Integer>> adj, int n )\\n{\\n    vis[n]=1;\\n    for(int i=0;i<adj.get(n).size();i++)\\n    {\\n    if(vis[adj.get(n).get(i)]==0)\\n    {\\n        dfs(vis,adj,adj.get(n).get(i));\\n    }\\n    }\\n}}"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@daveamol](/daveamol) What is count you are talking about, is it number of disconnected systems?"
                    },
                    {
                        "username": "daveamol",
                        "content": "This is the check I was looking for. That the total numbers of edges for every node to be connected has to be at least (n-1). As minimum edges required to connect n nodes is n-1.\\n\\nI wrote the check like this instead for clarity -\\nconnections.length >= n - 1, then return count - 1, else return -1"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Union Find week ? We are ready!"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "[@UchihaKim](/UchihaKim) you can determine if the node are having same parent node using find(), so if you find the edges are repeated, that mean you can swap that edge to connect other node."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "[@hiper2d](/hiper2d) I solve yesterday question using BFS then I took a look on the related topics and found Union Find, I am still learning it for now,  I can solve the problem using DFS but I want to solve it with that beautiful  DS. If you can give me some tips I\\'d be grateful if you help me."
                    },
                    {
                        "username": "hiper2d",
                        "content": "Same thing here. I keep using Union Find without even considering DFS and BFS. For some reason, this data structure is more obvious solution"
                    },
                    {
                        "username": "Rajkumar_007",
                        "content": "Hint : Find number of clusters"
                    },
                    {
                        "username": "hosua",
                        "content": "Weird, I tried solving this with BFS and got TLE, but it worked fine with DFS. Anyone understand why?"
                    },
                    {
                        "username": "hosua",
                        "content": "[@Crispy_coffee](/Crispy_coffee) I did something similar to this and got TLE"
                    },
                    {
                        "username": "czjnbb",
                        "content": "My py BFS beated more than 80%."
                    },
                    {
                        "username": "try_solving_hard",
                        "content": "Here\\'s my BFS submisson. #referrence Accepted in 1st attempt itself. #pride.\\n\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        \\n        // Find total number of connected components\\n        // Indegree / outdegree sum of all nodes in a connected component\\n        // Find total no of extra cables => (degree sum - required)/2\\n        // where required = (nodes in connected component - 1) * 2\\n        // If extra cables >= connected components - 1\\n        //      return connected components - 1\\n        // Else, \\n        //      return - 1\\n\\n        // Construct Graph\\n\\n        vector<int> adj[n];\\n        vector<long long> deg(n, 0);\\n\\n        for(auto c : connections)\\n        {\\n            adj[c[0]].push_back(c[1]);\\n            adj[c[1]].push_back(c[0]);\\n            deg[c[0]]++;\\n            deg[c[1]]++;\\n        }\\n\\n        vector<bool> vis(n, false);\\n        int cc = 0, extra = 0;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            if (!vis[i])\\n            {\\n                cc++;\\n                long long degree_sum = 0;\\n                int nodes = 0;\\n                vis[i] = true;\\n\\n                queue<int> q({i});\\n\\n                while(!q.empty())\\n                {\\n                    auto v = q.front();\\n                    q.pop();\\n\\n                    nodes++;\\n\\n                    degree_sum += deg[v];\\n\\n                    for(auto nbr : adj[v])\\n                    {\\n                        if (!vis[nbr])\\n                        {\\n                            vis[nbr] = true;\\n                            q.push(nbr);\\n\\n                        }\\n                    }\\n                }\\n\\n                int curr_ex = (degree_sum - ((nodes - 1) * 2)) / 2;\\n                extra += curr_ex;\\n            }\\n        }\\n\\n        return extra >= cc - 1 ? cc - 1 : -1;\\n\\n    }\\n};"
                    },
                    {
                        "username": "RamilZaripov",
                        "content": "I had a TLE on my BFS attempt, after reading your comment also switched to DFS and everything worked!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "I saw your comment and after submmiting my DFS approach i find this solution in submitted solution graph\\n\\n```c++\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& c) \\n    {\\n        if(c.size() < n -1) return -1;\\n        vector<int> adj[n];\\n        for(auto it : c)   \\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        } \\n\\n        int ct = 0;\\n        queue<int> q;\\n        vector<int> vis(n, 0);\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(!vis[i])\\n            {\\n                q.push(i);\\n                vis[i] = 1;\\n                while(!q.empty())\\n                {\\n                    int node = q.front();\\n                    q.pop();\\n                    for(auto it : adj[node])\\n                    {\\n                        if(!vis[it])\\n                        {\\n                            q.push(it);\\n                            vis[it] = 1;\\n                        }\\n                    }\\n                }\\n                ct++;\\n            }\\n        }\\n        return ct-1; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "cJayesh",
                        "content": "This happened with me in python.\nBFS uses more space than DFS.\nAlso depending on implementation, BFS has more add_to_list/add_to_set/enqueue/dequeue operations than DFS.\n"
                    },
                    {
                        "username": "user2575jO",
                        "content": "If `n==1` we will have `1 <= connections.length <= 0`. So this test case will not work."
                    },
                    {
                        "username": "Krrabs",
                        "content": "Union Find approach:\nGo through all the given connections and connect `connections[i][a] to connections[i][b]` pairs if `a & b` are already in a same graph you have an extra edge which can be used for connecting unconnected graphs.\n\nAt the end of `connections array` you should have count of extra edges and unconnected graphs, from these two information you can calculate the answer."
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "I thought about finding Indegree of each node (i.e. number of incoming edges) and then the count of nodes with 0 indegree(no incoming edge) shouldn\\'t it be the answer? It fails some testcases. (Yes, I have considered the case where number of wires are less than n-1) "
                    },
                    {
                        "username": "saichandra004",
                        "content": "Let's suppose we have 100 nodes.\n\n50 nodes are connected in a network.\nother 50 nodes are connected in another network (disjoint graph).\n\nFor the whole 100 nodes to be connected, we need 1 connection to join these two independent networks.\n\nBut if we only count the indegree, this seems that all the nodes are connected, but in reality, there are two different networks. Hence this indegree will lead to answers lesser than expected."
                    }
                ]
            },
            {
                "id": 1841039,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Switch to wireless technology to avoid such type of problems in life "
                    },
                    {
                        "username": "RCchoudhary",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE00 Nice"
                    },
                    {
                        "username": "hahahamid",
                        "content": "real"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "big bren"
                    },
                    {
                        "username": "santanusen",
                        "content": "Ha ha! On a serious note, the backbone networks are still wired, involving optical cables. Though they do have satellite links as emergency failover, those have terrible latencies."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@TsuruLee](/TsuruLee) now deal with 3D Array \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "I think they will create new problems about something like where to place the router to make the signal cover all devices"
                    },
                    {
                        "username": "kaskabay",
                        "content": "Test case:\\n100\\n[[17,51],[33,83],[53,62],[25,34],[35,90],[29,41],[14,53],[40,84],[41,64],[13,68],[44,85],[57,58],[50,74],[20,69],[15,62],[25,88],[4,56],[37,39],[30,62],[69,79],[33,85],[24,83],[35,77],[2,73],[6,28],[46,98],[11,82],[29,72],[67,71],[12,49],[42,56],[56,65],[40,70],[24,64],[29,51],[20,27],[45,88],[58,92],[60,99],[33,46],[19,69],[33,89],[54,82],[16,50],[35,73],[19,45],[19,72],[1,79],[27,80],[22,41],[52,61],[50,85],[27,45],[4,84],[11,96],[0,99],[29,94],[9,19],[66,99],[20,39],[16,85],[12,27],[16,67],[61,80],[67,83],[16,17],[24,27],[16,25],[41,79],[51,95],[46,47],[27,51],[31,44],[0,69],[61,63],[33,95],[17,88],[70,87],[40,42],[21,42],[67,77],[33,65],[3,25],[39,83],[34,40],[15,79],[30,90],[58,95],[45,56],[37,48],[24,91],[31,93],[83,90],[17,86],[61,65],[15,48],[34,56],[12,26],[39,98],[1,48],[21,76],[72,96],[30,69],[46,80],[6,29],[29,81],[22,77],[85,90],[79,83],[6,26],[33,57],[3,65],[63,84],[77,94],[26,90],[64,77],[0,3],[27,97],[66,89],[18,77],[27,43]]\\n\\nThe test case above have 88 already connected computers and 121 cables. So, we only need 12 (100-88) computers to be connected or in other words maximum of 12 cables relocated. How is that possible that answer is 13? It seems that it is not optimal way. I may be wrong in assumtions, if so please let me know."
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "suppose you have 6 computers 123 are connected in a straight line [1-2-3] & all others are connected in the same way [4-5-6] although all computers are connected the answer will be -1 because we cannot reach 4 5 6 starting at 1 2 3"
                    },
                    {
                        "username": "sainadth1123434",
                        "content": "Yeah thats correct even i got this error donno if the solution provided correct or not"
                    },
                    {
                        "username": "ramakiran",
                        "content": "[@ramakiran](/ramakiran) \\nthis is the shorter version of above case there will be 2 connected components so the answer will be 1 \\n"
                    },
                    {
                        "username": "ramakiran",
                        "content": "[@rockstar4095](/rockstar4095)   \\nn=6\\n[[0,1],[0,2],[1,2],[3,4],[4,5]]"
                    },
                    {
                        "username": "pramod74",
                        "content": "[@rockstar4095](/rockstar4095) Absolutely, that\\'s what is puzzling me aIso. Not sure if the question needs to be reworded to make this clear! "
                    },
                    {
                        "username": "B0PD0P",
                        "content": "[@kunadilov](/kunadilov)  we have 12 computers that are not connected, then we need at minimum 11 edges to connect these 12 computers with each other and then one extra edge to connect this component to the original component, shouldn't the answer be 12 ?"
                    },
                    {
                        "username": "kunadilov",
                        "content": "[@rockstar4095](/rockstar4095) This 88 computers connected in 2 different networks. So, you have 87 connected and 2 connected between each other. In a result you need minimum 13 connections. "
                    },
                    {
                        "username": "rockstar4095",
                        "content": "same problem with 100-88 computers.\n\ncan anyone provide a smaller example for this configuration?\nare there two or more initial networks actually  instead of one?\n\nI have a very nice 10-lines solution and it fails on this testcase))"
                    },
                    {
                        "username": "rockstar4095",
                        "content": "[@rush2rain](/rush2rain) \\n\\nfrom description:\\n\\n\"Any computer can reach any other computer directly or indirectly through the network.\"\\n\\n\"You are given an initial computer network connections.\"\\n\\naccording to this description, all the initial given computers must be connected."
                    },
                    {
                        "username": "jasona",
                        "content": "[@rush2rain](/rush2rain) ahh thanks! they need to introduce a smaller test case demonstrating that "
                    },
                    {
                        "username": "rush2rain",
                        "content": "Previously, I also attempted the same way. But there happens to be one flaw. What if 88 connected computers are making two separate components of 44 systems each. In that case, we need a wire to connect the two components together as well. So, we need to count the number of components that the whole set of computers is making. "
                    },
                    {
                        "username": "yyol",
                        "content": "same question"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one whose mind screwed up on this question ?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "you just need two things .\\n1. n-1>connections.length  return -1  (don\\'t have enough edge to connect all)\\n2. find number of connected components , return count-1"
                    },
                    {
                        "username": "thatsassygurl21",
                        "content": "Java implentation of your approach:\\nclass Solution {\\n    public int makeConnected(int n, int[][] con){\\n     if(con.length<n-1)return -1;\\n     List<List<Integer>> adj=new ArrayList<>();\\n     for(int i=0;i<n;i++)adj.add(new ArrayList<>());\\n     for(int i=0;i<con.length;i++)\\n     {\\n         adj.get(con[i][0]).add(con[i][1]);\\n          adj.get(con[i][1]).add(con[i][0]);\\n     }\\n     int ans=0;\\n     int vis[]=new int[n];\\n     for(int i=0;i<n;i++)\\n\\n     {\\n         if(vis[i]==0)\\n         {\\n             ans++;\\n             dfs(vis, adj,i);\\n         }   \\n    }\\n    return ans-1;\\n\\n\\n}\\n\\nvoid dfs(int []vis,List<List<Integer>> adj, int n )\\n{\\n    vis[n]=1;\\n    for(int i=0;i<adj.get(n).size();i++)\\n    {\\n    if(vis[adj.get(n).get(i)]==0)\\n    {\\n        dfs(vis,adj,adj.get(n).get(i));\\n    }\\n    }\\n}}"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@daveamol](/daveamol) What is count you are talking about, is it number of disconnected systems?"
                    },
                    {
                        "username": "daveamol",
                        "content": "This is the check I was looking for. That the total numbers of edges for every node to be connected has to be at least (n-1). As minimum edges required to connect n nodes is n-1.\\n\\nI wrote the check like this instead for clarity -\\nconnections.length >= n - 1, then return count - 1, else return -1"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Union Find week ? We are ready!"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "[@UchihaKim](/UchihaKim) you can determine if the node are having same parent node using find(), so if you find the edges are repeated, that mean you can swap that edge to connect other node."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "[@hiper2d](/hiper2d) I solve yesterday question using BFS then I took a look on the related topics and found Union Find, I am still learning it for now,  I can solve the problem using DFS but I want to solve it with that beautiful  DS. If you can give me some tips I\\'d be grateful if you help me."
                    },
                    {
                        "username": "hiper2d",
                        "content": "Same thing here. I keep using Union Find without even considering DFS and BFS. For some reason, this data structure is more obvious solution"
                    },
                    {
                        "username": "Rajkumar_007",
                        "content": "Hint : Find number of clusters"
                    },
                    {
                        "username": "hosua",
                        "content": "Weird, I tried solving this with BFS and got TLE, but it worked fine with DFS. Anyone understand why?"
                    },
                    {
                        "username": "hosua",
                        "content": "[@Crispy_coffee](/Crispy_coffee) I did something similar to this and got TLE"
                    },
                    {
                        "username": "czjnbb",
                        "content": "My py BFS beated more than 80%."
                    },
                    {
                        "username": "try_solving_hard",
                        "content": "Here\\'s my BFS submisson. #referrence Accepted in 1st attempt itself. #pride.\\n\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        \\n        // Find total number of connected components\\n        // Indegree / outdegree sum of all nodes in a connected component\\n        // Find total no of extra cables => (degree sum - required)/2\\n        // where required = (nodes in connected component - 1) * 2\\n        // If extra cables >= connected components - 1\\n        //      return connected components - 1\\n        // Else, \\n        //      return - 1\\n\\n        // Construct Graph\\n\\n        vector<int> adj[n];\\n        vector<long long> deg(n, 0);\\n\\n        for(auto c : connections)\\n        {\\n            adj[c[0]].push_back(c[1]);\\n            adj[c[1]].push_back(c[0]);\\n            deg[c[0]]++;\\n            deg[c[1]]++;\\n        }\\n\\n        vector<bool> vis(n, false);\\n        int cc = 0, extra = 0;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            if (!vis[i])\\n            {\\n                cc++;\\n                long long degree_sum = 0;\\n                int nodes = 0;\\n                vis[i] = true;\\n\\n                queue<int> q({i});\\n\\n                while(!q.empty())\\n                {\\n                    auto v = q.front();\\n                    q.pop();\\n\\n                    nodes++;\\n\\n                    degree_sum += deg[v];\\n\\n                    for(auto nbr : adj[v])\\n                    {\\n                        if (!vis[nbr])\\n                        {\\n                            vis[nbr] = true;\\n                            q.push(nbr);\\n\\n                        }\\n                    }\\n                }\\n\\n                int curr_ex = (degree_sum - ((nodes - 1) * 2)) / 2;\\n                extra += curr_ex;\\n            }\\n        }\\n\\n        return extra >= cc - 1 ? cc - 1 : -1;\\n\\n    }\\n};"
                    },
                    {
                        "username": "RamilZaripov",
                        "content": "I had a TLE on my BFS attempt, after reading your comment also switched to DFS and everything worked!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "I saw your comment and after submmiting my DFS approach i find this solution in submitted solution graph\\n\\n```c++\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& c) \\n    {\\n        if(c.size() < n -1) return -1;\\n        vector<int> adj[n];\\n        for(auto it : c)   \\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        } \\n\\n        int ct = 0;\\n        queue<int> q;\\n        vector<int> vis(n, 0);\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(!vis[i])\\n            {\\n                q.push(i);\\n                vis[i] = 1;\\n                while(!q.empty())\\n                {\\n                    int node = q.front();\\n                    q.pop();\\n                    for(auto it : adj[node])\\n                    {\\n                        if(!vis[it])\\n                        {\\n                            q.push(it);\\n                            vis[it] = 1;\\n                        }\\n                    }\\n                }\\n                ct++;\\n            }\\n        }\\n        return ct-1; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "cJayesh",
                        "content": "This happened with me in python.\nBFS uses more space than DFS.\nAlso depending on implementation, BFS has more add_to_list/add_to_set/enqueue/dequeue operations than DFS.\n"
                    },
                    {
                        "username": "user2575jO",
                        "content": "If `n==1` we will have `1 <= connections.length <= 0`. So this test case will not work."
                    },
                    {
                        "username": "Krrabs",
                        "content": "Union Find approach:\nGo through all the given connections and connect `connections[i][a] to connections[i][b]` pairs if `a & b` are already in a same graph you have an extra edge which can be used for connecting unconnected graphs.\n\nAt the end of `connections array` you should have count of extra edges and unconnected graphs, from these two information you can calculate the answer."
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "I thought about finding Indegree of each node (i.e. number of incoming edges) and then the count of nodes with 0 indegree(no incoming edge) shouldn\\'t it be the answer? It fails some testcases. (Yes, I have considered the case where number of wires are less than n-1) "
                    },
                    {
                        "username": "saichandra004",
                        "content": "Let's suppose we have 100 nodes.\n\n50 nodes are connected in a network.\nother 50 nodes are connected in another network (disjoint graph).\n\nFor the whole 100 nodes to be connected, we need 1 connection to join these two independent networks.\n\nBut if we only count the indegree, this seems that all the nodes are connected, but in reality, there are two different networks. Hence this indegree will lead to answers lesser than expected."
                    }
                ]
            },
            {
                "id": 1841255,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Switch to wireless technology to avoid such type of problems in life "
                    },
                    {
                        "username": "RCchoudhary",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE00 Nice"
                    },
                    {
                        "username": "hahahamid",
                        "content": "real"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "big bren"
                    },
                    {
                        "username": "santanusen",
                        "content": "Ha ha! On a serious note, the backbone networks are still wired, involving optical cables. Though they do have satellite links as emergency failover, those have terrible latencies."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@TsuruLee](/TsuruLee) now deal with 3D Array \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "I think they will create new problems about something like where to place the router to make the signal cover all devices"
                    },
                    {
                        "username": "kaskabay",
                        "content": "Test case:\\n100\\n[[17,51],[33,83],[53,62],[25,34],[35,90],[29,41],[14,53],[40,84],[41,64],[13,68],[44,85],[57,58],[50,74],[20,69],[15,62],[25,88],[4,56],[37,39],[30,62],[69,79],[33,85],[24,83],[35,77],[2,73],[6,28],[46,98],[11,82],[29,72],[67,71],[12,49],[42,56],[56,65],[40,70],[24,64],[29,51],[20,27],[45,88],[58,92],[60,99],[33,46],[19,69],[33,89],[54,82],[16,50],[35,73],[19,45],[19,72],[1,79],[27,80],[22,41],[52,61],[50,85],[27,45],[4,84],[11,96],[0,99],[29,94],[9,19],[66,99],[20,39],[16,85],[12,27],[16,67],[61,80],[67,83],[16,17],[24,27],[16,25],[41,79],[51,95],[46,47],[27,51],[31,44],[0,69],[61,63],[33,95],[17,88],[70,87],[40,42],[21,42],[67,77],[33,65],[3,25],[39,83],[34,40],[15,79],[30,90],[58,95],[45,56],[37,48],[24,91],[31,93],[83,90],[17,86],[61,65],[15,48],[34,56],[12,26],[39,98],[1,48],[21,76],[72,96],[30,69],[46,80],[6,29],[29,81],[22,77],[85,90],[79,83],[6,26],[33,57],[3,65],[63,84],[77,94],[26,90],[64,77],[0,3],[27,97],[66,89],[18,77],[27,43]]\\n\\nThe test case above have 88 already connected computers and 121 cables. So, we only need 12 (100-88) computers to be connected or in other words maximum of 12 cables relocated. How is that possible that answer is 13? It seems that it is not optimal way. I may be wrong in assumtions, if so please let me know."
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "suppose you have 6 computers 123 are connected in a straight line [1-2-3] & all others are connected in the same way [4-5-6] although all computers are connected the answer will be -1 because we cannot reach 4 5 6 starting at 1 2 3"
                    },
                    {
                        "username": "sainadth1123434",
                        "content": "Yeah thats correct even i got this error donno if the solution provided correct or not"
                    },
                    {
                        "username": "ramakiran",
                        "content": "[@ramakiran](/ramakiran) \\nthis is the shorter version of above case there will be 2 connected components so the answer will be 1 \\n"
                    },
                    {
                        "username": "ramakiran",
                        "content": "[@rockstar4095](/rockstar4095)   \\nn=6\\n[[0,1],[0,2],[1,2],[3,4],[4,5]]"
                    },
                    {
                        "username": "pramod74",
                        "content": "[@rockstar4095](/rockstar4095) Absolutely, that\\'s what is puzzling me aIso. Not sure if the question needs to be reworded to make this clear! "
                    },
                    {
                        "username": "B0PD0P",
                        "content": "[@kunadilov](/kunadilov)  we have 12 computers that are not connected, then we need at minimum 11 edges to connect these 12 computers with each other and then one extra edge to connect this component to the original component, shouldn't the answer be 12 ?"
                    },
                    {
                        "username": "kunadilov",
                        "content": "[@rockstar4095](/rockstar4095) This 88 computers connected in 2 different networks. So, you have 87 connected and 2 connected between each other. In a result you need minimum 13 connections. "
                    },
                    {
                        "username": "rockstar4095",
                        "content": "same problem with 100-88 computers.\n\ncan anyone provide a smaller example for this configuration?\nare there two or more initial networks actually  instead of one?\n\nI have a very nice 10-lines solution and it fails on this testcase))"
                    },
                    {
                        "username": "rockstar4095",
                        "content": "[@rush2rain](/rush2rain) \\n\\nfrom description:\\n\\n\"Any computer can reach any other computer directly or indirectly through the network.\"\\n\\n\"You are given an initial computer network connections.\"\\n\\naccording to this description, all the initial given computers must be connected."
                    },
                    {
                        "username": "jasona",
                        "content": "[@rush2rain](/rush2rain) ahh thanks! they need to introduce a smaller test case demonstrating that "
                    },
                    {
                        "username": "rush2rain",
                        "content": "Previously, I also attempted the same way. But there happens to be one flaw. What if 88 connected computers are making two separate components of 44 systems each. In that case, we need a wire to connect the two components together as well. So, we need to count the number of components that the whole set of computers is making. "
                    },
                    {
                        "username": "yyol",
                        "content": "same question"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one whose mind screwed up on this question ?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "you just need two things .\\n1. n-1>connections.length  return -1  (don\\'t have enough edge to connect all)\\n2. find number of connected components , return count-1"
                    },
                    {
                        "username": "thatsassygurl21",
                        "content": "Java implentation of your approach:\\nclass Solution {\\n    public int makeConnected(int n, int[][] con){\\n     if(con.length<n-1)return -1;\\n     List<List<Integer>> adj=new ArrayList<>();\\n     for(int i=0;i<n;i++)adj.add(new ArrayList<>());\\n     for(int i=0;i<con.length;i++)\\n     {\\n         adj.get(con[i][0]).add(con[i][1]);\\n          adj.get(con[i][1]).add(con[i][0]);\\n     }\\n     int ans=0;\\n     int vis[]=new int[n];\\n     for(int i=0;i<n;i++)\\n\\n     {\\n         if(vis[i]==0)\\n         {\\n             ans++;\\n             dfs(vis, adj,i);\\n         }   \\n    }\\n    return ans-1;\\n\\n\\n}\\n\\nvoid dfs(int []vis,List<List<Integer>> adj, int n )\\n{\\n    vis[n]=1;\\n    for(int i=0;i<adj.get(n).size();i++)\\n    {\\n    if(vis[adj.get(n).get(i)]==0)\\n    {\\n        dfs(vis,adj,adj.get(n).get(i));\\n    }\\n    }\\n}}"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@daveamol](/daveamol) What is count you are talking about, is it number of disconnected systems?"
                    },
                    {
                        "username": "daveamol",
                        "content": "This is the check I was looking for. That the total numbers of edges for every node to be connected has to be at least (n-1). As minimum edges required to connect n nodes is n-1.\\n\\nI wrote the check like this instead for clarity -\\nconnections.length >= n - 1, then return count - 1, else return -1"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Union Find week ? We are ready!"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "[@UchihaKim](/UchihaKim) you can determine if the node are having same parent node using find(), so if you find the edges are repeated, that mean you can swap that edge to connect other node."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "[@hiper2d](/hiper2d) I solve yesterday question using BFS then I took a look on the related topics and found Union Find, I am still learning it for now,  I can solve the problem using DFS but I want to solve it with that beautiful  DS. If you can give me some tips I\\'d be grateful if you help me."
                    },
                    {
                        "username": "hiper2d",
                        "content": "Same thing here. I keep using Union Find without even considering DFS and BFS. For some reason, this data structure is more obvious solution"
                    },
                    {
                        "username": "Rajkumar_007",
                        "content": "Hint : Find number of clusters"
                    },
                    {
                        "username": "hosua",
                        "content": "Weird, I tried solving this with BFS and got TLE, but it worked fine with DFS. Anyone understand why?"
                    },
                    {
                        "username": "hosua",
                        "content": "[@Crispy_coffee](/Crispy_coffee) I did something similar to this and got TLE"
                    },
                    {
                        "username": "czjnbb",
                        "content": "My py BFS beated more than 80%."
                    },
                    {
                        "username": "try_solving_hard",
                        "content": "Here\\'s my BFS submisson. #referrence Accepted in 1st attempt itself. #pride.\\n\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        \\n        // Find total number of connected components\\n        // Indegree / outdegree sum of all nodes in a connected component\\n        // Find total no of extra cables => (degree sum - required)/2\\n        // where required = (nodes in connected component - 1) * 2\\n        // If extra cables >= connected components - 1\\n        //      return connected components - 1\\n        // Else, \\n        //      return - 1\\n\\n        // Construct Graph\\n\\n        vector<int> adj[n];\\n        vector<long long> deg(n, 0);\\n\\n        for(auto c : connections)\\n        {\\n            adj[c[0]].push_back(c[1]);\\n            adj[c[1]].push_back(c[0]);\\n            deg[c[0]]++;\\n            deg[c[1]]++;\\n        }\\n\\n        vector<bool> vis(n, false);\\n        int cc = 0, extra = 0;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            if (!vis[i])\\n            {\\n                cc++;\\n                long long degree_sum = 0;\\n                int nodes = 0;\\n                vis[i] = true;\\n\\n                queue<int> q({i});\\n\\n                while(!q.empty())\\n                {\\n                    auto v = q.front();\\n                    q.pop();\\n\\n                    nodes++;\\n\\n                    degree_sum += deg[v];\\n\\n                    for(auto nbr : adj[v])\\n                    {\\n                        if (!vis[nbr])\\n                        {\\n                            vis[nbr] = true;\\n                            q.push(nbr);\\n\\n                        }\\n                    }\\n                }\\n\\n                int curr_ex = (degree_sum - ((nodes - 1) * 2)) / 2;\\n                extra += curr_ex;\\n            }\\n        }\\n\\n        return extra >= cc - 1 ? cc - 1 : -1;\\n\\n    }\\n};"
                    },
                    {
                        "username": "RamilZaripov",
                        "content": "I had a TLE on my BFS attempt, after reading your comment also switched to DFS and everything worked!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "I saw your comment and after submmiting my DFS approach i find this solution in submitted solution graph\\n\\n```c++\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& c) \\n    {\\n        if(c.size() < n -1) return -1;\\n        vector<int> adj[n];\\n        for(auto it : c)   \\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        } \\n\\n        int ct = 0;\\n        queue<int> q;\\n        vector<int> vis(n, 0);\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(!vis[i])\\n            {\\n                q.push(i);\\n                vis[i] = 1;\\n                while(!q.empty())\\n                {\\n                    int node = q.front();\\n                    q.pop();\\n                    for(auto it : adj[node])\\n                    {\\n                        if(!vis[it])\\n                        {\\n                            q.push(it);\\n                            vis[it] = 1;\\n                        }\\n                    }\\n                }\\n                ct++;\\n            }\\n        }\\n        return ct-1; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "cJayesh",
                        "content": "This happened with me in python.\nBFS uses more space than DFS.\nAlso depending on implementation, BFS has more add_to_list/add_to_set/enqueue/dequeue operations than DFS.\n"
                    },
                    {
                        "username": "user2575jO",
                        "content": "If `n==1` we will have `1 <= connections.length <= 0`. So this test case will not work."
                    },
                    {
                        "username": "Krrabs",
                        "content": "Union Find approach:\nGo through all the given connections and connect `connections[i][a] to connections[i][b]` pairs if `a & b` are already in a same graph you have an extra edge which can be used for connecting unconnected graphs.\n\nAt the end of `connections array` you should have count of extra edges and unconnected graphs, from these two information you can calculate the answer."
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "I thought about finding Indegree of each node (i.e. number of incoming edges) and then the count of nodes with 0 indegree(no incoming edge) shouldn\\'t it be the answer? It fails some testcases. (Yes, I have considered the case where number of wires are less than n-1) "
                    },
                    {
                        "username": "saichandra004",
                        "content": "Let's suppose we have 100 nodes.\n\n50 nodes are connected in a network.\nother 50 nodes are connected in another network (disjoint graph).\n\nFor the whole 100 nodes to be connected, we need 1 connection to join these two independent networks.\n\nBut if we only count the indegree, this seems that all the nodes are connected, but in reality, there are two different networks. Hence this indegree will lead to answers lesser than expected."
                    }
                ]
            },
            {
                "id": 1841058,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Switch to wireless technology to avoid such type of problems in life "
                    },
                    {
                        "username": "RCchoudhary",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE00 Nice"
                    },
                    {
                        "username": "hahahamid",
                        "content": "real"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "big bren"
                    },
                    {
                        "username": "santanusen",
                        "content": "Ha ha! On a serious note, the backbone networks are still wired, involving optical cables. Though they do have satellite links as emergency failover, those have terrible latencies."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@TsuruLee](/TsuruLee) now deal with 3D Array \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "I think they will create new problems about something like where to place the router to make the signal cover all devices"
                    },
                    {
                        "username": "kaskabay",
                        "content": "Test case:\\n100\\n[[17,51],[33,83],[53,62],[25,34],[35,90],[29,41],[14,53],[40,84],[41,64],[13,68],[44,85],[57,58],[50,74],[20,69],[15,62],[25,88],[4,56],[37,39],[30,62],[69,79],[33,85],[24,83],[35,77],[2,73],[6,28],[46,98],[11,82],[29,72],[67,71],[12,49],[42,56],[56,65],[40,70],[24,64],[29,51],[20,27],[45,88],[58,92],[60,99],[33,46],[19,69],[33,89],[54,82],[16,50],[35,73],[19,45],[19,72],[1,79],[27,80],[22,41],[52,61],[50,85],[27,45],[4,84],[11,96],[0,99],[29,94],[9,19],[66,99],[20,39],[16,85],[12,27],[16,67],[61,80],[67,83],[16,17],[24,27],[16,25],[41,79],[51,95],[46,47],[27,51],[31,44],[0,69],[61,63],[33,95],[17,88],[70,87],[40,42],[21,42],[67,77],[33,65],[3,25],[39,83],[34,40],[15,79],[30,90],[58,95],[45,56],[37,48],[24,91],[31,93],[83,90],[17,86],[61,65],[15,48],[34,56],[12,26],[39,98],[1,48],[21,76],[72,96],[30,69],[46,80],[6,29],[29,81],[22,77],[85,90],[79,83],[6,26],[33,57],[3,65],[63,84],[77,94],[26,90],[64,77],[0,3],[27,97],[66,89],[18,77],[27,43]]\\n\\nThe test case above have 88 already connected computers and 121 cables. So, we only need 12 (100-88) computers to be connected or in other words maximum of 12 cables relocated. How is that possible that answer is 13? It seems that it is not optimal way. I may be wrong in assumtions, if so please let me know."
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "suppose you have 6 computers 123 are connected in a straight line [1-2-3] & all others are connected in the same way [4-5-6] although all computers are connected the answer will be -1 because we cannot reach 4 5 6 starting at 1 2 3"
                    },
                    {
                        "username": "sainadth1123434",
                        "content": "Yeah thats correct even i got this error donno if the solution provided correct or not"
                    },
                    {
                        "username": "ramakiran",
                        "content": "[@ramakiran](/ramakiran) \\nthis is the shorter version of above case there will be 2 connected components so the answer will be 1 \\n"
                    },
                    {
                        "username": "ramakiran",
                        "content": "[@rockstar4095](/rockstar4095)   \\nn=6\\n[[0,1],[0,2],[1,2],[3,4],[4,5]]"
                    },
                    {
                        "username": "pramod74",
                        "content": "[@rockstar4095](/rockstar4095) Absolutely, that\\'s what is puzzling me aIso. Not sure if the question needs to be reworded to make this clear! "
                    },
                    {
                        "username": "B0PD0P",
                        "content": "[@kunadilov](/kunadilov)  we have 12 computers that are not connected, then we need at minimum 11 edges to connect these 12 computers with each other and then one extra edge to connect this component to the original component, shouldn't the answer be 12 ?"
                    },
                    {
                        "username": "kunadilov",
                        "content": "[@rockstar4095](/rockstar4095) This 88 computers connected in 2 different networks. So, you have 87 connected and 2 connected between each other. In a result you need minimum 13 connections. "
                    },
                    {
                        "username": "rockstar4095",
                        "content": "same problem with 100-88 computers.\n\ncan anyone provide a smaller example for this configuration?\nare there two or more initial networks actually  instead of one?\n\nI have a very nice 10-lines solution and it fails on this testcase))"
                    },
                    {
                        "username": "rockstar4095",
                        "content": "[@rush2rain](/rush2rain) \\n\\nfrom description:\\n\\n\"Any computer can reach any other computer directly or indirectly through the network.\"\\n\\n\"You are given an initial computer network connections.\"\\n\\naccording to this description, all the initial given computers must be connected."
                    },
                    {
                        "username": "jasona",
                        "content": "[@rush2rain](/rush2rain) ahh thanks! they need to introduce a smaller test case demonstrating that "
                    },
                    {
                        "username": "rush2rain",
                        "content": "Previously, I also attempted the same way. But there happens to be one flaw. What if 88 connected computers are making two separate components of 44 systems each. In that case, we need a wire to connect the two components together as well. So, we need to count the number of components that the whole set of computers is making. "
                    },
                    {
                        "username": "yyol",
                        "content": "same question"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one whose mind screwed up on this question ?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "you just need two things .\\n1. n-1>connections.length  return -1  (don\\'t have enough edge to connect all)\\n2. find number of connected components , return count-1"
                    },
                    {
                        "username": "thatsassygurl21",
                        "content": "Java implentation of your approach:\\nclass Solution {\\n    public int makeConnected(int n, int[][] con){\\n     if(con.length<n-1)return -1;\\n     List<List<Integer>> adj=new ArrayList<>();\\n     for(int i=0;i<n;i++)adj.add(new ArrayList<>());\\n     for(int i=0;i<con.length;i++)\\n     {\\n         adj.get(con[i][0]).add(con[i][1]);\\n          adj.get(con[i][1]).add(con[i][0]);\\n     }\\n     int ans=0;\\n     int vis[]=new int[n];\\n     for(int i=0;i<n;i++)\\n\\n     {\\n         if(vis[i]==0)\\n         {\\n             ans++;\\n             dfs(vis, adj,i);\\n         }   \\n    }\\n    return ans-1;\\n\\n\\n}\\n\\nvoid dfs(int []vis,List<List<Integer>> adj, int n )\\n{\\n    vis[n]=1;\\n    for(int i=0;i<adj.get(n).size();i++)\\n    {\\n    if(vis[adj.get(n).get(i)]==0)\\n    {\\n        dfs(vis,adj,adj.get(n).get(i));\\n    }\\n    }\\n}}"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@daveamol](/daveamol) What is count you are talking about, is it number of disconnected systems?"
                    },
                    {
                        "username": "daveamol",
                        "content": "This is the check I was looking for. That the total numbers of edges for every node to be connected has to be at least (n-1). As minimum edges required to connect n nodes is n-1.\\n\\nI wrote the check like this instead for clarity -\\nconnections.length >= n - 1, then return count - 1, else return -1"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Union Find week ? We are ready!"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "[@UchihaKim](/UchihaKim) you can determine if the node are having same parent node using find(), so if you find the edges are repeated, that mean you can swap that edge to connect other node."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "[@hiper2d](/hiper2d) I solve yesterday question using BFS then I took a look on the related topics and found Union Find, I am still learning it for now,  I can solve the problem using DFS but I want to solve it with that beautiful  DS. If you can give me some tips I\\'d be grateful if you help me."
                    },
                    {
                        "username": "hiper2d",
                        "content": "Same thing here. I keep using Union Find without even considering DFS and BFS. For some reason, this data structure is more obvious solution"
                    },
                    {
                        "username": "Rajkumar_007",
                        "content": "Hint : Find number of clusters"
                    },
                    {
                        "username": "hosua",
                        "content": "Weird, I tried solving this with BFS and got TLE, but it worked fine with DFS. Anyone understand why?"
                    },
                    {
                        "username": "hosua",
                        "content": "[@Crispy_coffee](/Crispy_coffee) I did something similar to this and got TLE"
                    },
                    {
                        "username": "czjnbb",
                        "content": "My py BFS beated more than 80%."
                    },
                    {
                        "username": "try_solving_hard",
                        "content": "Here\\'s my BFS submisson. #referrence Accepted in 1st attempt itself. #pride.\\n\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        \\n        // Find total number of connected components\\n        // Indegree / outdegree sum of all nodes in a connected component\\n        // Find total no of extra cables => (degree sum - required)/2\\n        // where required = (nodes in connected component - 1) * 2\\n        // If extra cables >= connected components - 1\\n        //      return connected components - 1\\n        // Else, \\n        //      return - 1\\n\\n        // Construct Graph\\n\\n        vector<int> adj[n];\\n        vector<long long> deg(n, 0);\\n\\n        for(auto c : connections)\\n        {\\n            adj[c[0]].push_back(c[1]);\\n            adj[c[1]].push_back(c[0]);\\n            deg[c[0]]++;\\n            deg[c[1]]++;\\n        }\\n\\n        vector<bool> vis(n, false);\\n        int cc = 0, extra = 0;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            if (!vis[i])\\n            {\\n                cc++;\\n                long long degree_sum = 0;\\n                int nodes = 0;\\n                vis[i] = true;\\n\\n                queue<int> q({i});\\n\\n                while(!q.empty())\\n                {\\n                    auto v = q.front();\\n                    q.pop();\\n\\n                    nodes++;\\n\\n                    degree_sum += deg[v];\\n\\n                    for(auto nbr : adj[v])\\n                    {\\n                        if (!vis[nbr])\\n                        {\\n                            vis[nbr] = true;\\n                            q.push(nbr);\\n\\n                        }\\n                    }\\n                }\\n\\n                int curr_ex = (degree_sum - ((nodes - 1) * 2)) / 2;\\n                extra += curr_ex;\\n            }\\n        }\\n\\n        return extra >= cc - 1 ? cc - 1 : -1;\\n\\n    }\\n};"
                    },
                    {
                        "username": "RamilZaripov",
                        "content": "I had a TLE on my BFS attempt, after reading your comment also switched to DFS and everything worked!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "I saw your comment and after submmiting my DFS approach i find this solution in submitted solution graph\\n\\n```c++\\nclass Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& c) \\n    {\\n        if(c.size() < n -1) return -1;\\n        vector<int> adj[n];\\n        for(auto it : c)   \\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        } \\n\\n        int ct = 0;\\n        queue<int> q;\\n        vector<int> vis(n, 0);\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(!vis[i])\\n            {\\n                q.push(i);\\n                vis[i] = 1;\\n                while(!q.empty())\\n                {\\n                    int node = q.front();\\n                    q.pop();\\n                    for(auto it : adj[node])\\n                    {\\n                        if(!vis[it])\\n                        {\\n                            q.push(it);\\n                            vis[it] = 1;\\n                        }\\n                    }\\n                }\\n                ct++;\\n            }\\n        }\\n        return ct-1; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "cJayesh",
                        "content": "This happened with me in python.\nBFS uses more space than DFS.\nAlso depending on implementation, BFS has more add_to_list/add_to_set/enqueue/dequeue operations than DFS.\n"
                    },
                    {
                        "username": "user2575jO",
                        "content": "If `n==1` we will have `1 <= connections.length <= 0`. So this test case will not work."
                    },
                    {
                        "username": "Krrabs",
                        "content": "Union Find approach:\nGo through all the given connections and connect `connections[i][a] to connections[i][b]` pairs if `a & b` are already in a same graph you have an extra edge which can be used for connecting unconnected graphs.\n\nAt the end of `connections array` you should have count of extra edges and unconnected graphs, from these two information you can calculate the answer."
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "I thought about finding Indegree of each node (i.e. number of incoming edges) and then the count of nodes with 0 indegree(no incoming edge) shouldn\\'t it be the answer? It fails some testcases. (Yes, I have considered the case where number of wires are less than n-1) "
                    },
                    {
                        "username": "saichandra004",
                        "content": "Let's suppose we have 100 nodes.\n\n50 nodes are connected in a network.\nother 50 nodes are connected in another network (disjoint graph).\n\nFor the whole 100 nodes to be connected, we need 1 connection to join these two independent networks.\n\nBut if we only count the indegree, this seems that all the nodes are connected, but in reality, there are two different networks. Hence this indegree will lead to answers lesser than expected."
                    }
                ]
            },
            {
                "id": 1840972,
                "content": [
                    {
                        "username": "arajshow",
                        "content": "all green feels really satisfying."
                    },
                    {
                        "username": "AnantDuhan",
                        "content": "```\nclass DisjointSet {\npublic:\n    vector<int> rank, parent, size;\n\tDisjointSet(int n) {\n\t\trank.resize(n + 1, 0);\n\t\tsize.resize(n + 1);\n\t\tparent.resize(n + 1);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tparent[i] = i;\n\t\t\tsize[i] = 1;\n\t\t}\n\t}\n\n\t// finding ultimate parent\n\tint findUltimateParent(int node) {\n\t\tif (node == parent[node])\n\t\t\treturn node;\n\t\treturn parent[node] = findUltimateParent(parent[node]);\n\t}\n\n\tvoid unionByRank(int u, int v) {\n\t\tint UltimateParent_u = findUltimateParent(u);\n\t\tint UltimateParent_v = findUltimateParent(v);\n\n\t\tif (UltimateParent_u == UltimateParent_v)\n\t\t\treturn;\n\n\t\tif (rank[UltimateParent_u] < rank[UltimateParent_v])\n\t\t\tparent[UltimateParent_u] = UltimateParent_v;\n\t\telse if (rank[UltimateParent_v] < rank[UltimateParent_u])\n\t\t\tparent[UltimateParent_v] = UltimateParent_u;\n\t\telse {\n\t\t\tparent[UltimateParent_v] = UltimateParent_u;\n\t\t\trank[UltimateParent_u]++;\n\t\t}\n\t}\n\n\tvoid unionBySize(int u, int v) {\n\t\tint UltimateParent_u = findUltimateParent(u);\n\t\tint UltimateParent_v = findUltimateParent(v);\n\n\t\tif (UltimateParent_u == UltimateParent_v)\n\t\t\treturn;\n\n\t\tif (rank[UltimateParent_u] < rank[UltimateParent_v]) {\n\t\t\tparent[UltimateParent_u] = UltimateParent_v;\n\t\t\tsize[UltimateParent_v] += size[UltimateParent_u];\n\t\t} else {\n\t\t\tparent[UltimateParent_v] = UltimateParent_u;\n\t\t\tsize[UltimateParent_u] += size[UltimateParent_v];\n\t\t}\n\t}\n};\n\nclass Solution {\npublic:\n    int makeConnected(int n, vector<vector<int>>& edge) {\n        DisjointSet ds(n);\n        \n        int cntExtras = 0;\n        for(auto it: edge) {\n            int u = it[0];\n            int v = it[1];\n            \n            if(ds.findUltimateParent(u) == ds.findUltimateParent(v)) {\n                cntExtras++;\n            } else { \n                ds.unionBySize(u, v);\n            }\n        }\n        \n        int cnt = 0;\n        for(int i=0;i<n;i++) {\n            if(ds.parent[i] == i) {\n                cnt++;\n            }\n        }\n        int ans = cnt -1; \n        if(cntExtras >= ans) {\n            return ans;\n        }\n        return -1;\n    }\n};\n```"
                    },
                    {
                        "username": "kranjeet0829",
                        "content": " [@Yerzhan Kaskabay](/kaskabay)  i am also got this error  first of  i find who vertices are not connected  and then find difference  total vertices to unconnected vertices if  edges of connected vertices  and total edges of defference is equal to or greater than than we return the the unconnected vertices becuase min edges required "
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "If u cant seem to figure out why your code fails on (n=100) testcase\\n\\nsuppose you have 6 computers 123 are connected in a straight line [1-2-3] & all others are connected in the same way [4-5-6] although all computers are connected the answer will be -1 because we cannot reach 4 5 6 starting at 1 2 3"
                    },
                    {
                        "username": "layyy",
                        "content": "Union Find gives the best results"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "You have to use connected component in graph logic to solve this problem !!"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": " `your inline code...your inline code...`Very very good problem.\\nFor all initially connected computers we need to find minimum no of cables sufficient to connect them \\nIf a computer does not connect to other computers then it is under unconnected  category\\n//we count no of unconnected computers\\nTotal no of cables we have is size of connections given to us\\n//Remaining cables=Total cables- Cables sufficient\\n\\nNow we need to find min cables reqd to connect the unconnected computers.\\nOne mistake we may do here is that suppose we have 5 unconnected computers,\\nWe may assume that we require 6 cables to connect these 5 But that is valid only in case if have 1 fully connected component with us\\nIf suppose graph is broken into 3 connected components,\\nWe need 4 cables to connect them internally and 3 more to connect with remaining 3 components\\nWe can check if min_cables_reqd is <= Remaining cables\\nThen valid\\nElse\\nNot valid\\n`class Solution {\\npublic:\\n    void Join(int i,vector<bool>&visit,vector<vector<int>>&adj,int&t)\\n    {\\n        visit[i]=true;\\n\\n        for(auto p:adj[i])\\n        {\\n            if(visit[p]==false)\\n            {\\n                t++;\\n                //cout<<p<<\"->\";\\n                Join(p,visit,adj,t);\\n            }\\n        }\\n        return;\\n    }\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        //goal is to find no. of connected components\\n        //and no of total cables given \\n        //and no of unconnected componenets\\n\\n        int unconnected=0;\\n\\n        int cables=connections.size();\\n        //i need to find extra cables by applying dfs on connected components\\n        vector<vector<int>>adj(n);\\n        for(auto p:connections)\\n        {\\n            adj[p[0]].push_back(p[1]);\\n            adj[p[1]].push_back(p[0]);\\n        }\\n        vector<bool>visit(n,false);\\n        int Min_cables=0;\\n        int components=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(adj[i].size() == 0)\\n            {\\n                //cout<<i<<\" \";\\n                unconnected++;\\n            }\\n            if(visit[i] == false and adj[i].size()>0)\\n            {\\n                components++;\\n                //cout<<i<<\"->\";\\n                int t=0;\\n                Join(i,visit,adj,t);\\n                //cout<<\"-\"<<t<<\"-\";\\n                Min_cables+=t;\\n                //cout<<endl;\\n            }\\n        }\\n        int Min_cables_to_connect_unconnected=unconnected-1 + components;\\n        int remaining_cables=cables-Min_cables;\\n        //cout<<endl<<cables<<\" \"<<Min_cables<<endl;\\n        if(Min_cables_to_connect_unconnected <= remaining_cables)\\n        {\\n            return Min_cables_to_connect_unconnected;\\n        }\\n        return -1;\\n    }`"
                    },
                    {
                        "username": "cpluspluscrowe",
                        "content": "What is the last test case?  Mine succeeds for all but test case 36, which shows n = \\nbut it does not show anything for n.  I am not sure what this last test case is."
                    },
                    {
                        "username": "user2418K",
                        "content": "What the heck is wrong with the testcases validation?\\n![Case 1](https://assets.leetcode.com/users/images/e527133a-e594-4c65-b84c-da5da5cb83eb_1679613069.2600863.png)\\n![Case 2](https://assets.leetcode.com/users/images/b823080c-0c13-40e3-b182-c96a2e56aa32_1679613078.3371115.png)\\n"
                    },
                    {
                        "username": "user2418K",
                        "content": "Btw, it\\'s the result for the `Golang` implementation.\\nIt looks like there are some issues on the server..."
                    },
                    {
                        "username": "Gab_Codes",
                        "content": "\"Any computer can reach any other computer directly or indirectly through the network.\" This is not correct; there are islands in the existing network, so not all are reachable from any other computer. "
                    },
                    {
                        "username": "Gab_Codes",
                        "content": "[@AMerrill](/AMerrill) Yep, directly would mean you\\'re immediately connected; indirectly would mean you\\'re connected via another computer, so 1-4 is a direct connection and 1-3-4 is an indirect connection between 1 and 4. Islands are not connected and therefore you cant reach one from the other. e.g. 1-2 and 3-4 are islands and one could not reach 3 from 1. Since there are test cases that contains islands, the directions should be re-written to clarify this. "
                    },
                    {
                        "username": "AMerrill",
                        "content": "They mean that computers can be connected either \"directly\" by means of a single cable : {[0,2]}, or \"indirectly\" through another computer: {[0,1], [1,2]}. (Thus in both cases computers 0 & 2 are connected)"
                    }
                ]
            },
            {
                "id": 1682707,
                "content": [
                    {
                        "username": "arajshow",
                        "content": "all green feels really satisfying."
                    },
                    {
                        "username": "AnantDuhan",
                        "content": "```\nclass DisjointSet {\npublic:\n    vector<int> rank, parent, size;\n\tDisjointSet(int n) {\n\t\trank.resize(n + 1, 0);\n\t\tsize.resize(n + 1);\n\t\tparent.resize(n + 1);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tparent[i] = i;\n\t\t\tsize[i] = 1;\n\t\t}\n\t}\n\n\t// finding ultimate parent\n\tint findUltimateParent(int node) {\n\t\tif (node == parent[node])\n\t\t\treturn node;\n\t\treturn parent[node] = findUltimateParent(parent[node]);\n\t}\n\n\tvoid unionByRank(int u, int v) {\n\t\tint UltimateParent_u = findUltimateParent(u);\n\t\tint UltimateParent_v = findUltimateParent(v);\n\n\t\tif (UltimateParent_u == UltimateParent_v)\n\t\t\treturn;\n\n\t\tif (rank[UltimateParent_u] < rank[UltimateParent_v])\n\t\t\tparent[UltimateParent_u] = UltimateParent_v;\n\t\telse if (rank[UltimateParent_v] < rank[UltimateParent_u])\n\t\t\tparent[UltimateParent_v] = UltimateParent_u;\n\t\telse {\n\t\t\tparent[UltimateParent_v] = UltimateParent_u;\n\t\t\trank[UltimateParent_u]++;\n\t\t}\n\t}\n\n\tvoid unionBySize(int u, int v) {\n\t\tint UltimateParent_u = findUltimateParent(u);\n\t\tint UltimateParent_v = findUltimateParent(v);\n\n\t\tif (UltimateParent_u == UltimateParent_v)\n\t\t\treturn;\n\n\t\tif (rank[UltimateParent_u] < rank[UltimateParent_v]) {\n\t\t\tparent[UltimateParent_u] = UltimateParent_v;\n\t\t\tsize[UltimateParent_v] += size[UltimateParent_u];\n\t\t} else {\n\t\t\tparent[UltimateParent_v] = UltimateParent_u;\n\t\t\tsize[UltimateParent_u] += size[UltimateParent_v];\n\t\t}\n\t}\n};\n\nclass Solution {\npublic:\n    int makeConnected(int n, vector<vector<int>>& edge) {\n        DisjointSet ds(n);\n        \n        int cntExtras = 0;\n        for(auto it: edge) {\n            int u = it[0];\n            int v = it[1];\n            \n            if(ds.findUltimateParent(u) == ds.findUltimateParent(v)) {\n                cntExtras++;\n            } else { \n                ds.unionBySize(u, v);\n            }\n        }\n        \n        int cnt = 0;\n        for(int i=0;i<n;i++) {\n            if(ds.parent[i] == i) {\n                cnt++;\n            }\n        }\n        int ans = cnt -1; \n        if(cntExtras >= ans) {\n            return ans;\n        }\n        return -1;\n    }\n};\n```"
                    },
                    {
                        "username": "kranjeet0829",
                        "content": " [@Yerzhan Kaskabay](/kaskabay)  i am also got this error  first of  i find who vertices are not connected  and then find difference  total vertices to unconnected vertices if  edges of connected vertices  and total edges of defference is equal to or greater than than we return the the unconnected vertices becuase min edges required "
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "If u cant seem to figure out why your code fails on (n=100) testcase\\n\\nsuppose you have 6 computers 123 are connected in a straight line [1-2-3] & all others are connected in the same way [4-5-6] although all computers are connected the answer will be -1 because we cannot reach 4 5 6 starting at 1 2 3"
                    },
                    {
                        "username": "layyy",
                        "content": "Union Find gives the best results"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "You have to use connected component in graph logic to solve this problem !!"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": " `your inline code...your inline code...`Very very good problem.\\nFor all initially connected computers we need to find minimum no of cables sufficient to connect them \\nIf a computer does not connect to other computers then it is under unconnected  category\\n//we count no of unconnected computers\\nTotal no of cables we have is size of connections given to us\\n//Remaining cables=Total cables- Cables sufficient\\n\\nNow we need to find min cables reqd to connect the unconnected computers.\\nOne mistake we may do here is that suppose we have 5 unconnected computers,\\nWe may assume that we require 6 cables to connect these 5 But that is valid only in case if have 1 fully connected component with us\\nIf suppose graph is broken into 3 connected components,\\nWe need 4 cables to connect them internally and 3 more to connect with remaining 3 components\\nWe can check if min_cables_reqd is <= Remaining cables\\nThen valid\\nElse\\nNot valid\\n`class Solution {\\npublic:\\n    void Join(int i,vector<bool>&visit,vector<vector<int>>&adj,int&t)\\n    {\\n        visit[i]=true;\\n\\n        for(auto p:adj[i])\\n        {\\n            if(visit[p]==false)\\n            {\\n                t++;\\n                //cout<<p<<\"->\";\\n                Join(p,visit,adj,t);\\n            }\\n        }\\n        return;\\n    }\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        //goal is to find no. of connected components\\n        //and no of total cables given \\n        //and no of unconnected componenets\\n\\n        int unconnected=0;\\n\\n        int cables=connections.size();\\n        //i need to find extra cables by applying dfs on connected components\\n        vector<vector<int>>adj(n);\\n        for(auto p:connections)\\n        {\\n            adj[p[0]].push_back(p[1]);\\n            adj[p[1]].push_back(p[0]);\\n        }\\n        vector<bool>visit(n,false);\\n        int Min_cables=0;\\n        int components=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(adj[i].size() == 0)\\n            {\\n                //cout<<i<<\" \";\\n                unconnected++;\\n            }\\n            if(visit[i] == false and adj[i].size()>0)\\n            {\\n                components++;\\n                //cout<<i<<\"->\";\\n                int t=0;\\n                Join(i,visit,adj,t);\\n                //cout<<\"-\"<<t<<\"-\";\\n                Min_cables+=t;\\n                //cout<<endl;\\n            }\\n        }\\n        int Min_cables_to_connect_unconnected=unconnected-1 + components;\\n        int remaining_cables=cables-Min_cables;\\n        //cout<<endl<<cables<<\" \"<<Min_cables<<endl;\\n        if(Min_cables_to_connect_unconnected <= remaining_cables)\\n        {\\n            return Min_cables_to_connect_unconnected;\\n        }\\n        return -1;\\n    }`"
                    },
                    {
                        "username": "cpluspluscrowe",
                        "content": "What is the last test case?  Mine succeeds for all but test case 36, which shows n = \\nbut it does not show anything for n.  I am not sure what this last test case is."
                    },
                    {
                        "username": "user2418K",
                        "content": "What the heck is wrong with the testcases validation?\\n![Case 1](https://assets.leetcode.com/users/images/e527133a-e594-4c65-b84c-da5da5cb83eb_1679613069.2600863.png)\\n![Case 2](https://assets.leetcode.com/users/images/b823080c-0c13-40e3-b182-c96a2e56aa32_1679613078.3371115.png)\\n"
                    },
                    {
                        "username": "user2418K",
                        "content": "Btw, it\\'s the result for the `Golang` implementation.\\nIt looks like there are some issues on the server..."
                    },
                    {
                        "username": "Gab_Codes",
                        "content": "\"Any computer can reach any other computer directly or indirectly through the network.\" This is not correct; there are islands in the existing network, so not all are reachable from any other computer. "
                    },
                    {
                        "username": "Gab_Codes",
                        "content": "[@AMerrill](/AMerrill) Yep, directly would mean you\\'re immediately connected; indirectly would mean you\\'re connected via another computer, so 1-4 is a direct connection and 1-3-4 is an indirect connection between 1 and 4. Islands are not connected and therefore you cant reach one from the other. e.g. 1-2 and 3-4 are islands and one could not reach 3 from 1. Since there are test cases that contains islands, the directions should be re-written to clarify this. "
                    },
                    {
                        "username": "AMerrill",
                        "content": "They mean that computers can be connected either \"directly\" by means of a single cable : {[0,2]}, or \"indirectly\" through another computer: {[0,1], [1,2]}. (Thus in both cases computers 0 & 2 are connected)"
                    }
                ]
            },
            {
                "id": 2047442,
                "content": [
                    {
                        "username": "arajshow",
                        "content": "all green feels really satisfying."
                    },
                    {
                        "username": "AnantDuhan",
                        "content": "```\nclass DisjointSet {\npublic:\n    vector<int> rank, parent, size;\n\tDisjointSet(int n) {\n\t\trank.resize(n + 1, 0);\n\t\tsize.resize(n + 1);\n\t\tparent.resize(n + 1);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tparent[i] = i;\n\t\t\tsize[i] = 1;\n\t\t}\n\t}\n\n\t// finding ultimate parent\n\tint findUltimateParent(int node) {\n\t\tif (node == parent[node])\n\t\t\treturn node;\n\t\treturn parent[node] = findUltimateParent(parent[node]);\n\t}\n\n\tvoid unionByRank(int u, int v) {\n\t\tint UltimateParent_u = findUltimateParent(u);\n\t\tint UltimateParent_v = findUltimateParent(v);\n\n\t\tif (UltimateParent_u == UltimateParent_v)\n\t\t\treturn;\n\n\t\tif (rank[UltimateParent_u] < rank[UltimateParent_v])\n\t\t\tparent[UltimateParent_u] = UltimateParent_v;\n\t\telse if (rank[UltimateParent_v] < rank[UltimateParent_u])\n\t\t\tparent[UltimateParent_v] = UltimateParent_u;\n\t\telse {\n\t\t\tparent[UltimateParent_v] = UltimateParent_u;\n\t\t\trank[UltimateParent_u]++;\n\t\t}\n\t}\n\n\tvoid unionBySize(int u, int v) {\n\t\tint UltimateParent_u = findUltimateParent(u);\n\t\tint UltimateParent_v = findUltimateParent(v);\n\n\t\tif (UltimateParent_u == UltimateParent_v)\n\t\t\treturn;\n\n\t\tif (rank[UltimateParent_u] < rank[UltimateParent_v]) {\n\t\t\tparent[UltimateParent_u] = UltimateParent_v;\n\t\t\tsize[UltimateParent_v] += size[UltimateParent_u];\n\t\t} else {\n\t\t\tparent[UltimateParent_v] = UltimateParent_u;\n\t\t\tsize[UltimateParent_u] += size[UltimateParent_v];\n\t\t}\n\t}\n};\n\nclass Solution {\npublic:\n    int makeConnected(int n, vector<vector<int>>& edge) {\n        DisjointSet ds(n);\n        \n        int cntExtras = 0;\n        for(auto it: edge) {\n            int u = it[0];\n            int v = it[1];\n            \n            if(ds.findUltimateParent(u) == ds.findUltimateParent(v)) {\n                cntExtras++;\n            } else { \n                ds.unionBySize(u, v);\n            }\n        }\n        \n        int cnt = 0;\n        for(int i=0;i<n;i++) {\n            if(ds.parent[i] == i) {\n                cnt++;\n            }\n        }\n        int ans = cnt -1; \n        if(cntExtras >= ans) {\n            return ans;\n        }\n        return -1;\n    }\n};\n```"
                    },
                    {
                        "username": "kranjeet0829",
                        "content": " [@Yerzhan Kaskabay](/kaskabay)  i am also got this error  first of  i find who vertices are not connected  and then find difference  total vertices to unconnected vertices if  edges of connected vertices  and total edges of defference is equal to or greater than than we return the the unconnected vertices becuase min edges required "
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "If u cant seem to figure out why your code fails on (n=100) testcase\\n\\nsuppose you have 6 computers 123 are connected in a straight line [1-2-3] & all others are connected in the same way [4-5-6] although all computers are connected the answer will be -1 because we cannot reach 4 5 6 starting at 1 2 3"
                    },
                    {
                        "username": "layyy",
                        "content": "Union Find gives the best results"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "You have to use connected component in graph logic to solve this problem !!"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": " `your inline code...your inline code...`Very very good problem.\\nFor all initially connected computers we need to find minimum no of cables sufficient to connect them \\nIf a computer does not connect to other computers then it is under unconnected  category\\n//we count no of unconnected computers\\nTotal no of cables we have is size of connections given to us\\n//Remaining cables=Total cables- Cables sufficient\\n\\nNow we need to find min cables reqd to connect the unconnected computers.\\nOne mistake we may do here is that suppose we have 5 unconnected computers,\\nWe may assume that we require 6 cables to connect these 5 But that is valid only in case if have 1 fully connected component with us\\nIf suppose graph is broken into 3 connected components,\\nWe need 4 cables to connect them internally and 3 more to connect with remaining 3 components\\nWe can check if min_cables_reqd is <= Remaining cables\\nThen valid\\nElse\\nNot valid\\n`class Solution {\\npublic:\\n    void Join(int i,vector<bool>&visit,vector<vector<int>>&adj,int&t)\\n    {\\n        visit[i]=true;\\n\\n        for(auto p:adj[i])\\n        {\\n            if(visit[p]==false)\\n            {\\n                t++;\\n                //cout<<p<<\"->\";\\n                Join(p,visit,adj,t);\\n            }\\n        }\\n        return;\\n    }\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        //goal is to find no. of connected components\\n        //and no of total cables given \\n        //and no of unconnected componenets\\n\\n        int unconnected=0;\\n\\n        int cables=connections.size();\\n        //i need to find extra cables by applying dfs on connected components\\n        vector<vector<int>>adj(n);\\n        for(auto p:connections)\\n        {\\n            adj[p[0]].push_back(p[1]);\\n            adj[p[1]].push_back(p[0]);\\n        }\\n        vector<bool>visit(n,false);\\n        int Min_cables=0;\\n        int components=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(adj[i].size() == 0)\\n            {\\n                //cout<<i<<\" \";\\n                unconnected++;\\n            }\\n            if(visit[i] == false and adj[i].size()>0)\\n            {\\n                components++;\\n                //cout<<i<<\"->\";\\n                int t=0;\\n                Join(i,visit,adj,t);\\n                //cout<<\"-\"<<t<<\"-\";\\n                Min_cables+=t;\\n                //cout<<endl;\\n            }\\n        }\\n        int Min_cables_to_connect_unconnected=unconnected-1 + components;\\n        int remaining_cables=cables-Min_cables;\\n        //cout<<endl<<cables<<\" \"<<Min_cables<<endl;\\n        if(Min_cables_to_connect_unconnected <= remaining_cables)\\n        {\\n            return Min_cables_to_connect_unconnected;\\n        }\\n        return -1;\\n    }`"
                    },
                    {
                        "username": "cpluspluscrowe",
                        "content": "What is the last test case?  Mine succeeds for all but test case 36, which shows n = \\nbut it does not show anything for n.  I am not sure what this last test case is."
                    },
                    {
                        "username": "user2418K",
                        "content": "What the heck is wrong with the testcases validation?\\n![Case 1](https://assets.leetcode.com/users/images/e527133a-e594-4c65-b84c-da5da5cb83eb_1679613069.2600863.png)\\n![Case 2](https://assets.leetcode.com/users/images/b823080c-0c13-40e3-b182-c96a2e56aa32_1679613078.3371115.png)\\n"
                    },
                    {
                        "username": "user2418K",
                        "content": "Btw, it\\'s the result for the `Golang` implementation.\\nIt looks like there are some issues on the server..."
                    },
                    {
                        "username": "Gab_Codes",
                        "content": "\"Any computer can reach any other computer directly or indirectly through the network.\" This is not correct; there are islands in the existing network, so not all are reachable from any other computer. "
                    },
                    {
                        "username": "Gab_Codes",
                        "content": "[@AMerrill](/AMerrill) Yep, directly would mean you\\'re immediately connected; indirectly would mean you\\'re connected via another computer, so 1-4 is a direct connection and 1-3-4 is an indirect connection between 1 and 4. Islands are not connected and therefore you cant reach one from the other. e.g. 1-2 and 3-4 are islands and one could not reach 3 from 1. Since there are test cases that contains islands, the directions should be re-written to clarify this. "
                    },
                    {
                        "username": "AMerrill",
                        "content": "They mean that computers can be connected either \"directly\" by means of a single cable : {[0,2]}, or \"indirectly\" through another computer: {[0,1], [1,2]}. (Thus in both cases computers 0 & 2 are connected)"
                    }
                ]
            },
            {
                "id": 2040472,
                "content": [
                    {
                        "username": "arajshow",
                        "content": "all green feels really satisfying."
                    },
                    {
                        "username": "AnantDuhan",
                        "content": "```\nclass DisjointSet {\npublic:\n    vector<int> rank, parent, size;\n\tDisjointSet(int n) {\n\t\trank.resize(n + 1, 0);\n\t\tsize.resize(n + 1);\n\t\tparent.resize(n + 1);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tparent[i] = i;\n\t\t\tsize[i] = 1;\n\t\t}\n\t}\n\n\t// finding ultimate parent\n\tint findUltimateParent(int node) {\n\t\tif (node == parent[node])\n\t\t\treturn node;\n\t\treturn parent[node] = findUltimateParent(parent[node]);\n\t}\n\n\tvoid unionByRank(int u, int v) {\n\t\tint UltimateParent_u = findUltimateParent(u);\n\t\tint UltimateParent_v = findUltimateParent(v);\n\n\t\tif (UltimateParent_u == UltimateParent_v)\n\t\t\treturn;\n\n\t\tif (rank[UltimateParent_u] < rank[UltimateParent_v])\n\t\t\tparent[UltimateParent_u] = UltimateParent_v;\n\t\telse if (rank[UltimateParent_v] < rank[UltimateParent_u])\n\t\t\tparent[UltimateParent_v] = UltimateParent_u;\n\t\telse {\n\t\t\tparent[UltimateParent_v] = UltimateParent_u;\n\t\t\trank[UltimateParent_u]++;\n\t\t}\n\t}\n\n\tvoid unionBySize(int u, int v) {\n\t\tint UltimateParent_u = findUltimateParent(u);\n\t\tint UltimateParent_v = findUltimateParent(v);\n\n\t\tif (UltimateParent_u == UltimateParent_v)\n\t\t\treturn;\n\n\t\tif (rank[UltimateParent_u] < rank[UltimateParent_v]) {\n\t\t\tparent[UltimateParent_u] = UltimateParent_v;\n\t\t\tsize[UltimateParent_v] += size[UltimateParent_u];\n\t\t} else {\n\t\t\tparent[UltimateParent_v] = UltimateParent_u;\n\t\t\tsize[UltimateParent_u] += size[UltimateParent_v];\n\t\t}\n\t}\n};\n\nclass Solution {\npublic:\n    int makeConnected(int n, vector<vector<int>>& edge) {\n        DisjointSet ds(n);\n        \n        int cntExtras = 0;\n        for(auto it: edge) {\n            int u = it[0];\n            int v = it[1];\n            \n            if(ds.findUltimateParent(u) == ds.findUltimateParent(v)) {\n                cntExtras++;\n            } else { \n                ds.unionBySize(u, v);\n            }\n        }\n        \n        int cnt = 0;\n        for(int i=0;i<n;i++) {\n            if(ds.parent[i] == i) {\n                cnt++;\n            }\n        }\n        int ans = cnt -1; \n        if(cntExtras >= ans) {\n            return ans;\n        }\n        return -1;\n    }\n};\n```"
                    },
                    {
                        "username": "kranjeet0829",
                        "content": " [@Yerzhan Kaskabay](/kaskabay)  i am also got this error  first of  i find who vertices are not connected  and then find difference  total vertices to unconnected vertices if  edges of connected vertices  and total edges of defference is equal to or greater than than we return the the unconnected vertices becuase min edges required "
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "If u cant seem to figure out why your code fails on (n=100) testcase\\n\\nsuppose you have 6 computers 123 are connected in a straight line [1-2-3] & all others are connected in the same way [4-5-6] although all computers are connected the answer will be -1 because we cannot reach 4 5 6 starting at 1 2 3"
                    },
                    {
                        "username": "layyy",
                        "content": "Union Find gives the best results"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "You have to use connected component in graph logic to solve this problem !!"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": " `your inline code...your inline code...`Very very good problem.\\nFor all initially connected computers we need to find minimum no of cables sufficient to connect them \\nIf a computer does not connect to other computers then it is under unconnected  category\\n//we count no of unconnected computers\\nTotal no of cables we have is size of connections given to us\\n//Remaining cables=Total cables- Cables sufficient\\n\\nNow we need to find min cables reqd to connect the unconnected computers.\\nOne mistake we may do here is that suppose we have 5 unconnected computers,\\nWe may assume that we require 6 cables to connect these 5 But that is valid only in case if have 1 fully connected component with us\\nIf suppose graph is broken into 3 connected components,\\nWe need 4 cables to connect them internally and 3 more to connect with remaining 3 components\\nWe can check if min_cables_reqd is <= Remaining cables\\nThen valid\\nElse\\nNot valid\\n`class Solution {\\npublic:\\n    void Join(int i,vector<bool>&visit,vector<vector<int>>&adj,int&t)\\n    {\\n        visit[i]=true;\\n\\n        for(auto p:adj[i])\\n        {\\n            if(visit[p]==false)\\n            {\\n                t++;\\n                //cout<<p<<\"->\";\\n                Join(p,visit,adj,t);\\n            }\\n        }\\n        return;\\n    }\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        //goal is to find no. of connected components\\n        //and no of total cables given \\n        //and no of unconnected componenets\\n\\n        int unconnected=0;\\n\\n        int cables=connections.size();\\n        //i need to find extra cables by applying dfs on connected components\\n        vector<vector<int>>adj(n);\\n        for(auto p:connections)\\n        {\\n            adj[p[0]].push_back(p[1]);\\n            adj[p[1]].push_back(p[0]);\\n        }\\n        vector<bool>visit(n,false);\\n        int Min_cables=0;\\n        int components=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(adj[i].size() == 0)\\n            {\\n                //cout<<i<<\" \";\\n                unconnected++;\\n            }\\n            if(visit[i] == false and adj[i].size()>0)\\n            {\\n                components++;\\n                //cout<<i<<\"->\";\\n                int t=0;\\n                Join(i,visit,adj,t);\\n                //cout<<\"-\"<<t<<\"-\";\\n                Min_cables+=t;\\n                //cout<<endl;\\n            }\\n        }\\n        int Min_cables_to_connect_unconnected=unconnected-1 + components;\\n        int remaining_cables=cables-Min_cables;\\n        //cout<<endl<<cables<<\" \"<<Min_cables<<endl;\\n        if(Min_cables_to_connect_unconnected <= remaining_cables)\\n        {\\n            return Min_cables_to_connect_unconnected;\\n        }\\n        return -1;\\n    }`"
                    },
                    {
                        "username": "cpluspluscrowe",
                        "content": "What is the last test case?  Mine succeeds for all but test case 36, which shows n = \\nbut it does not show anything for n.  I am not sure what this last test case is."
                    },
                    {
                        "username": "user2418K",
                        "content": "What the heck is wrong with the testcases validation?\\n![Case 1](https://assets.leetcode.com/users/images/e527133a-e594-4c65-b84c-da5da5cb83eb_1679613069.2600863.png)\\n![Case 2](https://assets.leetcode.com/users/images/b823080c-0c13-40e3-b182-c96a2e56aa32_1679613078.3371115.png)\\n"
                    },
                    {
                        "username": "user2418K",
                        "content": "Btw, it\\'s the result for the `Golang` implementation.\\nIt looks like there are some issues on the server..."
                    },
                    {
                        "username": "Gab_Codes",
                        "content": "\"Any computer can reach any other computer directly or indirectly through the network.\" This is not correct; there are islands in the existing network, so not all are reachable from any other computer. "
                    },
                    {
                        "username": "Gab_Codes",
                        "content": "[@AMerrill](/AMerrill) Yep, directly would mean you\\'re immediately connected; indirectly would mean you\\'re connected via another computer, so 1-4 is a direct connection and 1-3-4 is an indirect connection between 1 and 4. Islands are not connected and therefore you cant reach one from the other. e.g. 1-2 and 3-4 are islands and one could not reach 3 from 1. Since there are test cases that contains islands, the directions should be re-written to clarify this. "
                    },
                    {
                        "username": "AMerrill",
                        "content": "They mean that computers can be connected either \"directly\" by means of a single cable : {[0,2]}, or \"indirectly\" through another computer: {[0,1], [1,2]}. (Thus in both cases computers 0 & 2 are connected)"
                    }
                ]
            },
            {
                "id": 1947182,
                "content": [
                    {
                        "username": "arajshow",
                        "content": "all green feels really satisfying."
                    },
                    {
                        "username": "AnantDuhan",
                        "content": "```\nclass DisjointSet {\npublic:\n    vector<int> rank, parent, size;\n\tDisjointSet(int n) {\n\t\trank.resize(n + 1, 0);\n\t\tsize.resize(n + 1);\n\t\tparent.resize(n + 1);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tparent[i] = i;\n\t\t\tsize[i] = 1;\n\t\t}\n\t}\n\n\t// finding ultimate parent\n\tint findUltimateParent(int node) {\n\t\tif (node == parent[node])\n\t\t\treturn node;\n\t\treturn parent[node] = findUltimateParent(parent[node]);\n\t}\n\n\tvoid unionByRank(int u, int v) {\n\t\tint UltimateParent_u = findUltimateParent(u);\n\t\tint UltimateParent_v = findUltimateParent(v);\n\n\t\tif (UltimateParent_u == UltimateParent_v)\n\t\t\treturn;\n\n\t\tif (rank[UltimateParent_u] < rank[UltimateParent_v])\n\t\t\tparent[UltimateParent_u] = UltimateParent_v;\n\t\telse if (rank[UltimateParent_v] < rank[UltimateParent_u])\n\t\t\tparent[UltimateParent_v] = UltimateParent_u;\n\t\telse {\n\t\t\tparent[UltimateParent_v] = UltimateParent_u;\n\t\t\trank[UltimateParent_u]++;\n\t\t}\n\t}\n\n\tvoid unionBySize(int u, int v) {\n\t\tint UltimateParent_u = findUltimateParent(u);\n\t\tint UltimateParent_v = findUltimateParent(v);\n\n\t\tif (UltimateParent_u == UltimateParent_v)\n\t\t\treturn;\n\n\t\tif (rank[UltimateParent_u] < rank[UltimateParent_v]) {\n\t\t\tparent[UltimateParent_u] = UltimateParent_v;\n\t\t\tsize[UltimateParent_v] += size[UltimateParent_u];\n\t\t} else {\n\t\t\tparent[UltimateParent_v] = UltimateParent_u;\n\t\t\tsize[UltimateParent_u] += size[UltimateParent_v];\n\t\t}\n\t}\n};\n\nclass Solution {\npublic:\n    int makeConnected(int n, vector<vector<int>>& edge) {\n        DisjointSet ds(n);\n        \n        int cntExtras = 0;\n        for(auto it: edge) {\n            int u = it[0];\n            int v = it[1];\n            \n            if(ds.findUltimateParent(u) == ds.findUltimateParent(v)) {\n                cntExtras++;\n            } else { \n                ds.unionBySize(u, v);\n            }\n        }\n        \n        int cnt = 0;\n        for(int i=0;i<n;i++) {\n            if(ds.parent[i] == i) {\n                cnt++;\n            }\n        }\n        int ans = cnt -1; \n        if(cntExtras >= ans) {\n            return ans;\n        }\n        return -1;\n    }\n};\n```"
                    },
                    {
                        "username": "kranjeet0829",
                        "content": " [@Yerzhan Kaskabay](/kaskabay)  i am also got this error  first of  i find who vertices are not connected  and then find difference  total vertices to unconnected vertices if  edges of connected vertices  and total edges of defference is equal to or greater than than we return the the unconnected vertices becuase min edges required "
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "If u cant seem to figure out why your code fails on (n=100) testcase\\n\\nsuppose you have 6 computers 123 are connected in a straight line [1-2-3] & all others are connected in the same way [4-5-6] although all computers are connected the answer will be -1 because we cannot reach 4 5 6 starting at 1 2 3"
                    },
                    {
                        "username": "layyy",
                        "content": "Union Find gives the best results"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "You have to use connected component in graph logic to solve this problem !!"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": " `your inline code...your inline code...`Very very good problem.\\nFor all initially connected computers we need to find minimum no of cables sufficient to connect them \\nIf a computer does not connect to other computers then it is under unconnected  category\\n//we count no of unconnected computers\\nTotal no of cables we have is size of connections given to us\\n//Remaining cables=Total cables- Cables sufficient\\n\\nNow we need to find min cables reqd to connect the unconnected computers.\\nOne mistake we may do here is that suppose we have 5 unconnected computers,\\nWe may assume that we require 6 cables to connect these 5 But that is valid only in case if have 1 fully connected component with us\\nIf suppose graph is broken into 3 connected components,\\nWe need 4 cables to connect them internally and 3 more to connect with remaining 3 components\\nWe can check if min_cables_reqd is <= Remaining cables\\nThen valid\\nElse\\nNot valid\\n`class Solution {\\npublic:\\n    void Join(int i,vector<bool>&visit,vector<vector<int>>&adj,int&t)\\n    {\\n        visit[i]=true;\\n\\n        for(auto p:adj[i])\\n        {\\n            if(visit[p]==false)\\n            {\\n                t++;\\n                //cout<<p<<\"->\";\\n                Join(p,visit,adj,t);\\n            }\\n        }\\n        return;\\n    }\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        //goal is to find no. of connected components\\n        //and no of total cables given \\n        //and no of unconnected componenets\\n\\n        int unconnected=0;\\n\\n        int cables=connections.size();\\n        //i need to find extra cables by applying dfs on connected components\\n        vector<vector<int>>adj(n);\\n        for(auto p:connections)\\n        {\\n            adj[p[0]].push_back(p[1]);\\n            adj[p[1]].push_back(p[0]);\\n        }\\n        vector<bool>visit(n,false);\\n        int Min_cables=0;\\n        int components=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(adj[i].size() == 0)\\n            {\\n                //cout<<i<<\" \";\\n                unconnected++;\\n            }\\n            if(visit[i] == false and adj[i].size()>0)\\n            {\\n                components++;\\n                //cout<<i<<\"->\";\\n                int t=0;\\n                Join(i,visit,adj,t);\\n                //cout<<\"-\"<<t<<\"-\";\\n                Min_cables+=t;\\n                //cout<<endl;\\n            }\\n        }\\n        int Min_cables_to_connect_unconnected=unconnected-1 + components;\\n        int remaining_cables=cables-Min_cables;\\n        //cout<<endl<<cables<<\" \"<<Min_cables<<endl;\\n        if(Min_cables_to_connect_unconnected <= remaining_cables)\\n        {\\n            return Min_cables_to_connect_unconnected;\\n        }\\n        return -1;\\n    }`"
                    },
                    {
                        "username": "cpluspluscrowe",
                        "content": "What is the last test case?  Mine succeeds for all but test case 36, which shows n = \\nbut it does not show anything for n.  I am not sure what this last test case is."
                    },
                    {
                        "username": "user2418K",
                        "content": "What the heck is wrong with the testcases validation?\\n![Case 1](https://assets.leetcode.com/users/images/e527133a-e594-4c65-b84c-da5da5cb83eb_1679613069.2600863.png)\\n![Case 2](https://assets.leetcode.com/users/images/b823080c-0c13-40e3-b182-c96a2e56aa32_1679613078.3371115.png)\\n"
                    },
                    {
                        "username": "user2418K",
                        "content": "Btw, it\\'s the result for the `Golang` implementation.\\nIt looks like there are some issues on the server..."
                    },
                    {
                        "username": "Gab_Codes",
                        "content": "\"Any computer can reach any other computer directly or indirectly through the network.\" This is not correct; there are islands in the existing network, so not all are reachable from any other computer. "
                    },
                    {
                        "username": "Gab_Codes",
                        "content": "[@AMerrill](/AMerrill) Yep, directly would mean you\\'re immediately connected; indirectly would mean you\\'re connected via another computer, so 1-4 is a direct connection and 1-3-4 is an indirect connection between 1 and 4. Islands are not connected and therefore you cant reach one from the other. e.g. 1-2 and 3-4 are islands and one could not reach 3 from 1. Since there are test cases that contains islands, the directions should be re-written to clarify this. "
                    },
                    {
                        "username": "AMerrill",
                        "content": "They mean that computers can be connected either \"directly\" by means of a single cable : {[0,2]}, or \"indirectly\" through another computer: {[0,1], [1,2]}. (Thus in both cases computers 0 & 2 are connected)"
                    }
                ]
            },
            {
                "id": 1857115,
                "content": [
                    {
                        "username": "arajshow",
                        "content": "all green feels really satisfying."
                    },
                    {
                        "username": "AnantDuhan",
                        "content": "```\nclass DisjointSet {\npublic:\n    vector<int> rank, parent, size;\n\tDisjointSet(int n) {\n\t\trank.resize(n + 1, 0);\n\t\tsize.resize(n + 1);\n\t\tparent.resize(n + 1);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tparent[i] = i;\n\t\t\tsize[i] = 1;\n\t\t}\n\t}\n\n\t// finding ultimate parent\n\tint findUltimateParent(int node) {\n\t\tif (node == parent[node])\n\t\t\treturn node;\n\t\treturn parent[node] = findUltimateParent(parent[node]);\n\t}\n\n\tvoid unionByRank(int u, int v) {\n\t\tint UltimateParent_u = findUltimateParent(u);\n\t\tint UltimateParent_v = findUltimateParent(v);\n\n\t\tif (UltimateParent_u == UltimateParent_v)\n\t\t\treturn;\n\n\t\tif (rank[UltimateParent_u] < rank[UltimateParent_v])\n\t\t\tparent[UltimateParent_u] = UltimateParent_v;\n\t\telse if (rank[UltimateParent_v] < rank[UltimateParent_u])\n\t\t\tparent[UltimateParent_v] = UltimateParent_u;\n\t\telse {\n\t\t\tparent[UltimateParent_v] = UltimateParent_u;\n\t\t\trank[UltimateParent_u]++;\n\t\t}\n\t}\n\n\tvoid unionBySize(int u, int v) {\n\t\tint UltimateParent_u = findUltimateParent(u);\n\t\tint UltimateParent_v = findUltimateParent(v);\n\n\t\tif (UltimateParent_u == UltimateParent_v)\n\t\t\treturn;\n\n\t\tif (rank[UltimateParent_u] < rank[UltimateParent_v]) {\n\t\t\tparent[UltimateParent_u] = UltimateParent_v;\n\t\t\tsize[UltimateParent_v] += size[UltimateParent_u];\n\t\t} else {\n\t\t\tparent[UltimateParent_v] = UltimateParent_u;\n\t\t\tsize[UltimateParent_u] += size[UltimateParent_v];\n\t\t}\n\t}\n};\n\nclass Solution {\npublic:\n    int makeConnected(int n, vector<vector<int>>& edge) {\n        DisjointSet ds(n);\n        \n        int cntExtras = 0;\n        for(auto it: edge) {\n            int u = it[0];\n            int v = it[1];\n            \n            if(ds.findUltimateParent(u) == ds.findUltimateParent(v)) {\n                cntExtras++;\n            } else { \n                ds.unionBySize(u, v);\n            }\n        }\n        \n        int cnt = 0;\n        for(int i=0;i<n;i++) {\n            if(ds.parent[i] == i) {\n                cnt++;\n            }\n        }\n        int ans = cnt -1; \n        if(cntExtras >= ans) {\n            return ans;\n        }\n        return -1;\n    }\n};\n```"
                    },
                    {
                        "username": "kranjeet0829",
                        "content": " [@Yerzhan Kaskabay](/kaskabay)  i am also got this error  first of  i find who vertices are not connected  and then find difference  total vertices to unconnected vertices if  edges of connected vertices  and total edges of defference is equal to or greater than than we return the the unconnected vertices becuase min edges required "
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "If u cant seem to figure out why your code fails on (n=100) testcase\\n\\nsuppose you have 6 computers 123 are connected in a straight line [1-2-3] & all others are connected in the same way [4-5-6] although all computers are connected the answer will be -1 because we cannot reach 4 5 6 starting at 1 2 3"
                    },
                    {
                        "username": "layyy",
                        "content": "Union Find gives the best results"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "You have to use connected component in graph logic to solve this problem !!"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": " `your inline code...your inline code...`Very very good problem.\\nFor all initially connected computers we need to find minimum no of cables sufficient to connect them \\nIf a computer does not connect to other computers then it is under unconnected  category\\n//we count no of unconnected computers\\nTotal no of cables we have is size of connections given to us\\n//Remaining cables=Total cables- Cables sufficient\\n\\nNow we need to find min cables reqd to connect the unconnected computers.\\nOne mistake we may do here is that suppose we have 5 unconnected computers,\\nWe may assume that we require 6 cables to connect these 5 But that is valid only in case if have 1 fully connected component with us\\nIf suppose graph is broken into 3 connected components,\\nWe need 4 cables to connect them internally and 3 more to connect with remaining 3 components\\nWe can check if min_cables_reqd is <= Remaining cables\\nThen valid\\nElse\\nNot valid\\n`class Solution {\\npublic:\\n    void Join(int i,vector<bool>&visit,vector<vector<int>>&adj,int&t)\\n    {\\n        visit[i]=true;\\n\\n        for(auto p:adj[i])\\n        {\\n            if(visit[p]==false)\\n            {\\n                t++;\\n                //cout<<p<<\"->\";\\n                Join(p,visit,adj,t);\\n            }\\n        }\\n        return;\\n    }\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        //goal is to find no. of connected components\\n        //and no of total cables given \\n        //and no of unconnected componenets\\n\\n        int unconnected=0;\\n\\n        int cables=connections.size();\\n        //i need to find extra cables by applying dfs on connected components\\n        vector<vector<int>>adj(n);\\n        for(auto p:connections)\\n        {\\n            adj[p[0]].push_back(p[1]);\\n            adj[p[1]].push_back(p[0]);\\n        }\\n        vector<bool>visit(n,false);\\n        int Min_cables=0;\\n        int components=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(adj[i].size() == 0)\\n            {\\n                //cout<<i<<\" \";\\n                unconnected++;\\n            }\\n            if(visit[i] == false and adj[i].size()>0)\\n            {\\n                components++;\\n                //cout<<i<<\"->\";\\n                int t=0;\\n                Join(i,visit,adj,t);\\n                //cout<<\"-\"<<t<<\"-\";\\n                Min_cables+=t;\\n                //cout<<endl;\\n            }\\n        }\\n        int Min_cables_to_connect_unconnected=unconnected-1 + components;\\n        int remaining_cables=cables-Min_cables;\\n        //cout<<endl<<cables<<\" \"<<Min_cables<<endl;\\n        if(Min_cables_to_connect_unconnected <= remaining_cables)\\n        {\\n            return Min_cables_to_connect_unconnected;\\n        }\\n        return -1;\\n    }`"
                    },
                    {
                        "username": "cpluspluscrowe",
                        "content": "What is the last test case?  Mine succeeds for all but test case 36, which shows n = \\nbut it does not show anything for n.  I am not sure what this last test case is."
                    },
                    {
                        "username": "user2418K",
                        "content": "What the heck is wrong with the testcases validation?\\n![Case 1](https://assets.leetcode.com/users/images/e527133a-e594-4c65-b84c-da5da5cb83eb_1679613069.2600863.png)\\n![Case 2](https://assets.leetcode.com/users/images/b823080c-0c13-40e3-b182-c96a2e56aa32_1679613078.3371115.png)\\n"
                    },
                    {
                        "username": "user2418K",
                        "content": "Btw, it\\'s the result for the `Golang` implementation.\\nIt looks like there are some issues on the server..."
                    },
                    {
                        "username": "Gab_Codes",
                        "content": "\"Any computer can reach any other computer directly or indirectly through the network.\" This is not correct; there are islands in the existing network, so not all are reachable from any other computer. "
                    },
                    {
                        "username": "Gab_Codes",
                        "content": "[@AMerrill](/AMerrill) Yep, directly would mean you\\'re immediately connected; indirectly would mean you\\'re connected via another computer, so 1-4 is a direct connection and 1-3-4 is an indirect connection between 1 and 4. Islands are not connected and therefore you cant reach one from the other. e.g. 1-2 and 3-4 are islands and one could not reach 3 from 1. Since there are test cases that contains islands, the directions should be re-written to clarify this. "
                    },
                    {
                        "username": "AMerrill",
                        "content": "They mean that computers can be connected either \"directly\" by means of a single cable : {[0,2]}, or \"indirectly\" through another computer: {[0,1], [1,2]}. (Thus in both cases computers 0 & 2 are connected)"
                    }
                ]
            },
            {
                "id": 1849027,
                "content": [
                    {
                        "username": "arajshow",
                        "content": "all green feels really satisfying."
                    },
                    {
                        "username": "AnantDuhan",
                        "content": "```\nclass DisjointSet {\npublic:\n    vector<int> rank, parent, size;\n\tDisjointSet(int n) {\n\t\trank.resize(n + 1, 0);\n\t\tsize.resize(n + 1);\n\t\tparent.resize(n + 1);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tparent[i] = i;\n\t\t\tsize[i] = 1;\n\t\t}\n\t}\n\n\t// finding ultimate parent\n\tint findUltimateParent(int node) {\n\t\tif (node == parent[node])\n\t\t\treturn node;\n\t\treturn parent[node] = findUltimateParent(parent[node]);\n\t}\n\n\tvoid unionByRank(int u, int v) {\n\t\tint UltimateParent_u = findUltimateParent(u);\n\t\tint UltimateParent_v = findUltimateParent(v);\n\n\t\tif (UltimateParent_u == UltimateParent_v)\n\t\t\treturn;\n\n\t\tif (rank[UltimateParent_u] < rank[UltimateParent_v])\n\t\t\tparent[UltimateParent_u] = UltimateParent_v;\n\t\telse if (rank[UltimateParent_v] < rank[UltimateParent_u])\n\t\t\tparent[UltimateParent_v] = UltimateParent_u;\n\t\telse {\n\t\t\tparent[UltimateParent_v] = UltimateParent_u;\n\t\t\trank[UltimateParent_u]++;\n\t\t}\n\t}\n\n\tvoid unionBySize(int u, int v) {\n\t\tint UltimateParent_u = findUltimateParent(u);\n\t\tint UltimateParent_v = findUltimateParent(v);\n\n\t\tif (UltimateParent_u == UltimateParent_v)\n\t\t\treturn;\n\n\t\tif (rank[UltimateParent_u] < rank[UltimateParent_v]) {\n\t\t\tparent[UltimateParent_u] = UltimateParent_v;\n\t\t\tsize[UltimateParent_v] += size[UltimateParent_u];\n\t\t} else {\n\t\t\tparent[UltimateParent_v] = UltimateParent_u;\n\t\t\tsize[UltimateParent_u] += size[UltimateParent_v];\n\t\t}\n\t}\n};\n\nclass Solution {\npublic:\n    int makeConnected(int n, vector<vector<int>>& edge) {\n        DisjointSet ds(n);\n        \n        int cntExtras = 0;\n        for(auto it: edge) {\n            int u = it[0];\n            int v = it[1];\n            \n            if(ds.findUltimateParent(u) == ds.findUltimateParent(v)) {\n                cntExtras++;\n            } else { \n                ds.unionBySize(u, v);\n            }\n        }\n        \n        int cnt = 0;\n        for(int i=0;i<n;i++) {\n            if(ds.parent[i] == i) {\n                cnt++;\n            }\n        }\n        int ans = cnt -1; \n        if(cntExtras >= ans) {\n            return ans;\n        }\n        return -1;\n    }\n};\n```"
                    },
                    {
                        "username": "kranjeet0829",
                        "content": " [@Yerzhan Kaskabay](/kaskabay)  i am also got this error  first of  i find who vertices are not connected  and then find difference  total vertices to unconnected vertices if  edges of connected vertices  and total edges of defference is equal to or greater than than we return the the unconnected vertices becuase min edges required "
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "If u cant seem to figure out why your code fails on (n=100) testcase\\n\\nsuppose you have 6 computers 123 are connected in a straight line [1-2-3] & all others are connected in the same way [4-5-6] although all computers are connected the answer will be -1 because we cannot reach 4 5 6 starting at 1 2 3"
                    },
                    {
                        "username": "layyy",
                        "content": "Union Find gives the best results"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "You have to use connected component in graph logic to solve this problem !!"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": " `your inline code...your inline code...`Very very good problem.\\nFor all initially connected computers we need to find minimum no of cables sufficient to connect them \\nIf a computer does not connect to other computers then it is under unconnected  category\\n//we count no of unconnected computers\\nTotal no of cables we have is size of connections given to us\\n//Remaining cables=Total cables- Cables sufficient\\n\\nNow we need to find min cables reqd to connect the unconnected computers.\\nOne mistake we may do here is that suppose we have 5 unconnected computers,\\nWe may assume that we require 6 cables to connect these 5 But that is valid only in case if have 1 fully connected component with us\\nIf suppose graph is broken into 3 connected components,\\nWe need 4 cables to connect them internally and 3 more to connect with remaining 3 components\\nWe can check if min_cables_reqd is <= Remaining cables\\nThen valid\\nElse\\nNot valid\\n`class Solution {\\npublic:\\n    void Join(int i,vector<bool>&visit,vector<vector<int>>&adj,int&t)\\n    {\\n        visit[i]=true;\\n\\n        for(auto p:adj[i])\\n        {\\n            if(visit[p]==false)\\n            {\\n                t++;\\n                //cout<<p<<\"->\";\\n                Join(p,visit,adj,t);\\n            }\\n        }\\n        return;\\n    }\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        //goal is to find no. of connected components\\n        //and no of total cables given \\n        //and no of unconnected componenets\\n\\n        int unconnected=0;\\n\\n        int cables=connections.size();\\n        //i need to find extra cables by applying dfs on connected components\\n        vector<vector<int>>adj(n);\\n        for(auto p:connections)\\n        {\\n            adj[p[0]].push_back(p[1]);\\n            adj[p[1]].push_back(p[0]);\\n        }\\n        vector<bool>visit(n,false);\\n        int Min_cables=0;\\n        int components=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(adj[i].size() == 0)\\n            {\\n                //cout<<i<<\" \";\\n                unconnected++;\\n            }\\n            if(visit[i] == false and adj[i].size()>0)\\n            {\\n                components++;\\n                //cout<<i<<\"->\";\\n                int t=0;\\n                Join(i,visit,adj,t);\\n                //cout<<\"-\"<<t<<\"-\";\\n                Min_cables+=t;\\n                //cout<<endl;\\n            }\\n        }\\n        int Min_cables_to_connect_unconnected=unconnected-1 + components;\\n        int remaining_cables=cables-Min_cables;\\n        //cout<<endl<<cables<<\" \"<<Min_cables<<endl;\\n        if(Min_cables_to_connect_unconnected <= remaining_cables)\\n        {\\n            return Min_cables_to_connect_unconnected;\\n        }\\n        return -1;\\n    }`"
                    },
                    {
                        "username": "cpluspluscrowe",
                        "content": "What is the last test case?  Mine succeeds for all but test case 36, which shows n = \\nbut it does not show anything for n.  I am not sure what this last test case is."
                    },
                    {
                        "username": "user2418K",
                        "content": "What the heck is wrong with the testcases validation?\\n![Case 1](https://assets.leetcode.com/users/images/e527133a-e594-4c65-b84c-da5da5cb83eb_1679613069.2600863.png)\\n![Case 2](https://assets.leetcode.com/users/images/b823080c-0c13-40e3-b182-c96a2e56aa32_1679613078.3371115.png)\\n"
                    },
                    {
                        "username": "user2418K",
                        "content": "Btw, it\\'s the result for the `Golang` implementation.\\nIt looks like there are some issues on the server..."
                    },
                    {
                        "username": "Gab_Codes",
                        "content": "\"Any computer can reach any other computer directly or indirectly through the network.\" This is not correct; there are islands in the existing network, so not all are reachable from any other computer. "
                    },
                    {
                        "username": "Gab_Codes",
                        "content": "[@AMerrill](/AMerrill) Yep, directly would mean you\\'re immediately connected; indirectly would mean you\\'re connected via another computer, so 1-4 is a direct connection and 1-3-4 is an indirect connection between 1 and 4. Islands are not connected and therefore you cant reach one from the other. e.g. 1-2 and 3-4 are islands and one could not reach 3 from 1. Since there are test cases that contains islands, the directions should be re-written to clarify this. "
                    },
                    {
                        "username": "AMerrill",
                        "content": "They mean that computers can be connected either \"directly\" by means of a single cable : {[0,2]}, or \"indirectly\" through another computer: {[0,1], [1,2]}. (Thus in both cases computers 0 & 2 are connected)"
                    }
                ]
            },
            {
                "id": 1841841,
                "content": [
                    {
                        "username": "arajshow",
                        "content": "all green feels really satisfying."
                    },
                    {
                        "username": "AnantDuhan",
                        "content": "```\nclass DisjointSet {\npublic:\n    vector<int> rank, parent, size;\n\tDisjointSet(int n) {\n\t\trank.resize(n + 1, 0);\n\t\tsize.resize(n + 1);\n\t\tparent.resize(n + 1);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tparent[i] = i;\n\t\t\tsize[i] = 1;\n\t\t}\n\t}\n\n\t// finding ultimate parent\n\tint findUltimateParent(int node) {\n\t\tif (node == parent[node])\n\t\t\treturn node;\n\t\treturn parent[node] = findUltimateParent(parent[node]);\n\t}\n\n\tvoid unionByRank(int u, int v) {\n\t\tint UltimateParent_u = findUltimateParent(u);\n\t\tint UltimateParent_v = findUltimateParent(v);\n\n\t\tif (UltimateParent_u == UltimateParent_v)\n\t\t\treturn;\n\n\t\tif (rank[UltimateParent_u] < rank[UltimateParent_v])\n\t\t\tparent[UltimateParent_u] = UltimateParent_v;\n\t\telse if (rank[UltimateParent_v] < rank[UltimateParent_u])\n\t\t\tparent[UltimateParent_v] = UltimateParent_u;\n\t\telse {\n\t\t\tparent[UltimateParent_v] = UltimateParent_u;\n\t\t\trank[UltimateParent_u]++;\n\t\t}\n\t}\n\n\tvoid unionBySize(int u, int v) {\n\t\tint UltimateParent_u = findUltimateParent(u);\n\t\tint UltimateParent_v = findUltimateParent(v);\n\n\t\tif (UltimateParent_u == UltimateParent_v)\n\t\t\treturn;\n\n\t\tif (rank[UltimateParent_u] < rank[UltimateParent_v]) {\n\t\t\tparent[UltimateParent_u] = UltimateParent_v;\n\t\t\tsize[UltimateParent_v] += size[UltimateParent_u];\n\t\t} else {\n\t\t\tparent[UltimateParent_v] = UltimateParent_u;\n\t\t\tsize[UltimateParent_u] += size[UltimateParent_v];\n\t\t}\n\t}\n};\n\nclass Solution {\npublic:\n    int makeConnected(int n, vector<vector<int>>& edge) {\n        DisjointSet ds(n);\n        \n        int cntExtras = 0;\n        for(auto it: edge) {\n            int u = it[0];\n            int v = it[1];\n            \n            if(ds.findUltimateParent(u) == ds.findUltimateParent(v)) {\n                cntExtras++;\n            } else { \n                ds.unionBySize(u, v);\n            }\n        }\n        \n        int cnt = 0;\n        for(int i=0;i<n;i++) {\n            if(ds.parent[i] == i) {\n                cnt++;\n            }\n        }\n        int ans = cnt -1; \n        if(cntExtras >= ans) {\n            return ans;\n        }\n        return -1;\n    }\n};\n```"
                    },
                    {
                        "username": "kranjeet0829",
                        "content": " [@Yerzhan Kaskabay](/kaskabay)  i am also got this error  first of  i find who vertices are not connected  and then find difference  total vertices to unconnected vertices if  edges of connected vertices  and total edges of defference is equal to or greater than than we return the the unconnected vertices becuase min edges required "
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "If u cant seem to figure out why your code fails on (n=100) testcase\\n\\nsuppose you have 6 computers 123 are connected in a straight line [1-2-3] & all others are connected in the same way [4-5-6] although all computers are connected the answer will be -1 because we cannot reach 4 5 6 starting at 1 2 3"
                    },
                    {
                        "username": "layyy",
                        "content": "Union Find gives the best results"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "You have to use connected component in graph logic to solve this problem !!"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": " `your inline code...your inline code...`Very very good problem.\\nFor all initially connected computers we need to find minimum no of cables sufficient to connect them \\nIf a computer does not connect to other computers then it is under unconnected  category\\n//we count no of unconnected computers\\nTotal no of cables we have is size of connections given to us\\n//Remaining cables=Total cables- Cables sufficient\\n\\nNow we need to find min cables reqd to connect the unconnected computers.\\nOne mistake we may do here is that suppose we have 5 unconnected computers,\\nWe may assume that we require 6 cables to connect these 5 But that is valid only in case if have 1 fully connected component with us\\nIf suppose graph is broken into 3 connected components,\\nWe need 4 cables to connect them internally and 3 more to connect with remaining 3 components\\nWe can check if min_cables_reqd is <= Remaining cables\\nThen valid\\nElse\\nNot valid\\n`class Solution {\\npublic:\\n    void Join(int i,vector<bool>&visit,vector<vector<int>>&adj,int&t)\\n    {\\n        visit[i]=true;\\n\\n        for(auto p:adj[i])\\n        {\\n            if(visit[p]==false)\\n            {\\n                t++;\\n                //cout<<p<<\"->\";\\n                Join(p,visit,adj,t);\\n            }\\n        }\\n        return;\\n    }\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        //goal is to find no. of connected components\\n        //and no of total cables given \\n        //and no of unconnected componenets\\n\\n        int unconnected=0;\\n\\n        int cables=connections.size();\\n        //i need to find extra cables by applying dfs on connected components\\n        vector<vector<int>>adj(n);\\n        for(auto p:connections)\\n        {\\n            adj[p[0]].push_back(p[1]);\\n            adj[p[1]].push_back(p[0]);\\n        }\\n        vector<bool>visit(n,false);\\n        int Min_cables=0;\\n        int components=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(adj[i].size() == 0)\\n            {\\n                //cout<<i<<\" \";\\n                unconnected++;\\n            }\\n            if(visit[i] == false and adj[i].size()>0)\\n            {\\n                components++;\\n                //cout<<i<<\"->\";\\n                int t=0;\\n                Join(i,visit,adj,t);\\n                //cout<<\"-\"<<t<<\"-\";\\n                Min_cables+=t;\\n                //cout<<endl;\\n            }\\n        }\\n        int Min_cables_to_connect_unconnected=unconnected-1 + components;\\n        int remaining_cables=cables-Min_cables;\\n        //cout<<endl<<cables<<\" \"<<Min_cables<<endl;\\n        if(Min_cables_to_connect_unconnected <= remaining_cables)\\n        {\\n            return Min_cables_to_connect_unconnected;\\n        }\\n        return -1;\\n    }`"
                    },
                    {
                        "username": "cpluspluscrowe",
                        "content": "What is the last test case?  Mine succeeds for all but test case 36, which shows n = \\nbut it does not show anything for n.  I am not sure what this last test case is."
                    },
                    {
                        "username": "user2418K",
                        "content": "What the heck is wrong with the testcases validation?\\n![Case 1](https://assets.leetcode.com/users/images/e527133a-e594-4c65-b84c-da5da5cb83eb_1679613069.2600863.png)\\n![Case 2](https://assets.leetcode.com/users/images/b823080c-0c13-40e3-b182-c96a2e56aa32_1679613078.3371115.png)\\n"
                    },
                    {
                        "username": "user2418K",
                        "content": "Btw, it\\'s the result for the `Golang` implementation.\\nIt looks like there are some issues on the server..."
                    },
                    {
                        "username": "Gab_Codes",
                        "content": "\"Any computer can reach any other computer directly or indirectly through the network.\" This is not correct; there are islands in the existing network, so not all are reachable from any other computer. "
                    },
                    {
                        "username": "Gab_Codes",
                        "content": "[@AMerrill](/AMerrill) Yep, directly would mean you\\'re immediately connected; indirectly would mean you\\'re connected via another computer, so 1-4 is a direct connection and 1-3-4 is an indirect connection between 1 and 4. Islands are not connected and therefore you cant reach one from the other. e.g. 1-2 and 3-4 are islands and one could not reach 3 from 1. Since there are test cases that contains islands, the directions should be re-written to clarify this. "
                    },
                    {
                        "username": "AMerrill",
                        "content": "They mean that computers can be connected either \"directly\" by means of a single cable : {[0,2]}, or \"indirectly\" through another computer: {[0,1], [1,2]}. (Thus in both cases computers 0 & 2 are connected)"
                    }
                ]
            },
            {
                "id": 1841746,
                "content": [
                    {
                        "username": "arajshow",
                        "content": "all green feels really satisfying."
                    },
                    {
                        "username": "AnantDuhan",
                        "content": "```\nclass DisjointSet {\npublic:\n    vector<int> rank, parent, size;\n\tDisjointSet(int n) {\n\t\trank.resize(n + 1, 0);\n\t\tsize.resize(n + 1);\n\t\tparent.resize(n + 1);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tparent[i] = i;\n\t\t\tsize[i] = 1;\n\t\t}\n\t}\n\n\t// finding ultimate parent\n\tint findUltimateParent(int node) {\n\t\tif (node == parent[node])\n\t\t\treturn node;\n\t\treturn parent[node] = findUltimateParent(parent[node]);\n\t}\n\n\tvoid unionByRank(int u, int v) {\n\t\tint UltimateParent_u = findUltimateParent(u);\n\t\tint UltimateParent_v = findUltimateParent(v);\n\n\t\tif (UltimateParent_u == UltimateParent_v)\n\t\t\treturn;\n\n\t\tif (rank[UltimateParent_u] < rank[UltimateParent_v])\n\t\t\tparent[UltimateParent_u] = UltimateParent_v;\n\t\telse if (rank[UltimateParent_v] < rank[UltimateParent_u])\n\t\t\tparent[UltimateParent_v] = UltimateParent_u;\n\t\telse {\n\t\t\tparent[UltimateParent_v] = UltimateParent_u;\n\t\t\trank[UltimateParent_u]++;\n\t\t}\n\t}\n\n\tvoid unionBySize(int u, int v) {\n\t\tint UltimateParent_u = findUltimateParent(u);\n\t\tint UltimateParent_v = findUltimateParent(v);\n\n\t\tif (UltimateParent_u == UltimateParent_v)\n\t\t\treturn;\n\n\t\tif (rank[UltimateParent_u] < rank[UltimateParent_v]) {\n\t\t\tparent[UltimateParent_u] = UltimateParent_v;\n\t\t\tsize[UltimateParent_v] += size[UltimateParent_u];\n\t\t} else {\n\t\t\tparent[UltimateParent_v] = UltimateParent_u;\n\t\t\tsize[UltimateParent_u] += size[UltimateParent_v];\n\t\t}\n\t}\n};\n\nclass Solution {\npublic:\n    int makeConnected(int n, vector<vector<int>>& edge) {\n        DisjointSet ds(n);\n        \n        int cntExtras = 0;\n        for(auto it: edge) {\n            int u = it[0];\n            int v = it[1];\n            \n            if(ds.findUltimateParent(u) == ds.findUltimateParent(v)) {\n                cntExtras++;\n            } else { \n                ds.unionBySize(u, v);\n            }\n        }\n        \n        int cnt = 0;\n        for(int i=0;i<n;i++) {\n            if(ds.parent[i] == i) {\n                cnt++;\n            }\n        }\n        int ans = cnt -1; \n        if(cntExtras >= ans) {\n            return ans;\n        }\n        return -1;\n    }\n};\n```"
                    },
                    {
                        "username": "kranjeet0829",
                        "content": " [@Yerzhan Kaskabay](/kaskabay)  i am also got this error  first of  i find who vertices are not connected  and then find difference  total vertices to unconnected vertices if  edges of connected vertices  and total edges of defference is equal to or greater than than we return the the unconnected vertices becuase min edges required "
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "If u cant seem to figure out why your code fails on (n=100) testcase\\n\\nsuppose you have 6 computers 123 are connected in a straight line [1-2-3] & all others are connected in the same way [4-5-6] although all computers are connected the answer will be -1 because we cannot reach 4 5 6 starting at 1 2 3"
                    },
                    {
                        "username": "layyy",
                        "content": "Union Find gives the best results"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "You have to use connected component in graph logic to solve this problem !!"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": " `your inline code...your inline code...`Very very good problem.\\nFor all initially connected computers we need to find minimum no of cables sufficient to connect them \\nIf a computer does not connect to other computers then it is under unconnected  category\\n//we count no of unconnected computers\\nTotal no of cables we have is size of connections given to us\\n//Remaining cables=Total cables- Cables sufficient\\n\\nNow we need to find min cables reqd to connect the unconnected computers.\\nOne mistake we may do here is that suppose we have 5 unconnected computers,\\nWe may assume that we require 6 cables to connect these 5 But that is valid only in case if have 1 fully connected component with us\\nIf suppose graph is broken into 3 connected components,\\nWe need 4 cables to connect them internally and 3 more to connect with remaining 3 components\\nWe can check if min_cables_reqd is <= Remaining cables\\nThen valid\\nElse\\nNot valid\\n`class Solution {\\npublic:\\n    void Join(int i,vector<bool>&visit,vector<vector<int>>&adj,int&t)\\n    {\\n        visit[i]=true;\\n\\n        for(auto p:adj[i])\\n        {\\n            if(visit[p]==false)\\n            {\\n                t++;\\n                //cout<<p<<\"->\";\\n                Join(p,visit,adj,t);\\n            }\\n        }\\n        return;\\n    }\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        //goal is to find no. of connected components\\n        //and no of total cables given \\n        //and no of unconnected componenets\\n\\n        int unconnected=0;\\n\\n        int cables=connections.size();\\n        //i need to find extra cables by applying dfs on connected components\\n        vector<vector<int>>adj(n);\\n        for(auto p:connections)\\n        {\\n            adj[p[0]].push_back(p[1]);\\n            adj[p[1]].push_back(p[0]);\\n        }\\n        vector<bool>visit(n,false);\\n        int Min_cables=0;\\n        int components=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(adj[i].size() == 0)\\n            {\\n                //cout<<i<<\" \";\\n                unconnected++;\\n            }\\n            if(visit[i] == false and adj[i].size()>0)\\n            {\\n                components++;\\n                //cout<<i<<\"->\";\\n                int t=0;\\n                Join(i,visit,adj,t);\\n                //cout<<\"-\"<<t<<\"-\";\\n                Min_cables+=t;\\n                //cout<<endl;\\n            }\\n        }\\n        int Min_cables_to_connect_unconnected=unconnected-1 + components;\\n        int remaining_cables=cables-Min_cables;\\n        //cout<<endl<<cables<<\" \"<<Min_cables<<endl;\\n        if(Min_cables_to_connect_unconnected <= remaining_cables)\\n        {\\n            return Min_cables_to_connect_unconnected;\\n        }\\n        return -1;\\n    }`"
                    },
                    {
                        "username": "cpluspluscrowe",
                        "content": "What is the last test case?  Mine succeeds for all but test case 36, which shows n = \\nbut it does not show anything for n.  I am not sure what this last test case is."
                    },
                    {
                        "username": "user2418K",
                        "content": "What the heck is wrong with the testcases validation?\\n![Case 1](https://assets.leetcode.com/users/images/e527133a-e594-4c65-b84c-da5da5cb83eb_1679613069.2600863.png)\\n![Case 2](https://assets.leetcode.com/users/images/b823080c-0c13-40e3-b182-c96a2e56aa32_1679613078.3371115.png)\\n"
                    },
                    {
                        "username": "user2418K",
                        "content": "Btw, it\\'s the result for the `Golang` implementation.\\nIt looks like there are some issues on the server..."
                    },
                    {
                        "username": "Gab_Codes",
                        "content": "\"Any computer can reach any other computer directly or indirectly through the network.\" This is not correct; there are islands in the existing network, so not all are reachable from any other computer. "
                    },
                    {
                        "username": "Gab_Codes",
                        "content": "[@AMerrill](/AMerrill) Yep, directly would mean you\\'re immediately connected; indirectly would mean you\\'re connected via another computer, so 1-4 is a direct connection and 1-3-4 is an indirect connection between 1 and 4. Islands are not connected and therefore you cant reach one from the other. e.g. 1-2 and 3-4 are islands and one could not reach 3 from 1. Since there are test cases that contains islands, the directions should be re-written to clarify this. "
                    },
                    {
                        "username": "AMerrill",
                        "content": "They mean that computers can be connected either \"directly\" by means of a single cable : {[0,2]}, or \"indirectly\" through another computer: {[0,1], [1,2]}. (Thus in both cases computers 0 & 2 are connected)"
                    }
                ]
            },
            {
                "id": 1841637,
                "content": [
                    {
                        "username": "arajshow",
                        "content": "all green feels really satisfying."
                    },
                    {
                        "username": "AnantDuhan",
                        "content": "```\nclass DisjointSet {\npublic:\n    vector<int> rank, parent, size;\n\tDisjointSet(int n) {\n\t\trank.resize(n + 1, 0);\n\t\tsize.resize(n + 1);\n\t\tparent.resize(n + 1);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tparent[i] = i;\n\t\t\tsize[i] = 1;\n\t\t}\n\t}\n\n\t// finding ultimate parent\n\tint findUltimateParent(int node) {\n\t\tif (node == parent[node])\n\t\t\treturn node;\n\t\treturn parent[node] = findUltimateParent(parent[node]);\n\t}\n\n\tvoid unionByRank(int u, int v) {\n\t\tint UltimateParent_u = findUltimateParent(u);\n\t\tint UltimateParent_v = findUltimateParent(v);\n\n\t\tif (UltimateParent_u == UltimateParent_v)\n\t\t\treturn;\n\n\t\tif (rank[UltimateParent_u] < rank[UltimateParent_v])\n\t\t\tparent[UltimateParent_u] = UltimateParent_v;\n\t\telse if (rank[UltimateParent_v] < rank[UltimateParent_u])\n\t\t\tparent[UltimateParent_v] = UltimateParent_u;\n\t\telse {\n\t\t\tparent[UltimateParent_v] = UltimateParent_u;\n\t\t\trank[UltimateParent_u]++;\n\t\t}\n\t}\n\n\tvoid unionBySize(int u, int v) {\n\t\tint UltimateParent_u = findUltimateParent(u);\n\t\tint UltimateParent_v = findUltimateParent(v);\n\n\t\tif (UltimateParent_u == UltimateParent_v)\n\t\t\treturn;\n\n\t\tif (rank[UltimateParent_u] < rank[UltimateParent_v]) {\n\t\t\tparent[UltimateParent_u] = UltimateParent_v;\n\t\t\tsize[UltimateParent_v] += size[UltimateParent_u];\n\t\t} else {\n\t\t\tparent[UltimateParent_v] = UltimateParent_u;\n\t\t\tsize[UltimateParent_u] += size[UltimateParent_v];\n\t\t}\n\t}\n};\n\nclass Solution {\npublic:\n    int makeConnected(int n, vector<vector<int>>& edge) {\n        DisjointSet ds(n);\n        \n        int cntExtras = 0;\n        for(auto it: edge) {\n            int u = it[0];\n            int v = it[1];\n            \n            if(ds.findUltimateParent(u) == ds.findUltimateParent(v)) {\n                cntExtras++;\n            } else { \n                ds.unionBySize(u, v);\n            }\n        }\n        \n        int cnt = 0;\n        for(int i=0;i<n;i++) {\n            if(ds.parent[i] == i) {\n                cnt++;\n            }\n        }\n        int ans = cnt -1; \n        if(cntExtras >= ans) {\n            return ans;\n        }\n        return -1;\n    }\n};\n```"
                    },
                    {
                        "username": "kranjeet0829",
                        "content": " [@Yerzhan Kaskabay](/kaskabay)  i am also got this error  first of  i find who vertices are not connected  and then find difference  total vertices to unconnected vertices if  edges of connected vertices  and total edges of defference is equal to or greater than than we return the the unconnected vertices becuase min edges required "
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "If u cant seem to figure out why your code fails on (n=100) testcase\\n\\nsuppose you have 6 computers 123 are connected in a straight line [1-2-3] & all others are connected in the same way [4-5-6] although all computers are connected the answer will be -1 because we cannot reach 4 5 6 starting at 1 2 3"
                    },
                    {
                        "username": "layyy",
                        "content": "Union Find gives the best results"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "You have to use connected component in graph logic to solve this problem !!"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": " `your inline code...your inline code...`Very very good problem.\\nFor all initially connected computers we need to find minimum no of cables sufficient to connect them \\nIf a computer does not connect to other computers then it is under unconnected  category\\n//we count no of unconnected computers\\nTotal no of cables we have is size of connections given to us\\n//Remaining cables=Total cables- Cables sufficient\\n\\nNow we need to find min cables reqd to connect the unconnected computers.\\nOne mistake we may do here is that suppose we have 5 unconnected computers,\\nWe may assume that we require 6 cables to connect these 5 But that is valid only in case if have 1 fully connected component with us\\nIf suppose graph is broken into 3 connected components,\\nWe need 4 cables to connect them internally and 3 more to connect with remaining 3 components\\nWe can check if min_cables_reqd is <= Remaining cables\\nThen valid\\nElse\\nNot valid\\n`class Solution {\\npublic:\\n    void Join(int i,vector<bool>&visit,vector<vector<int>>&adj,int&t)\\n    {\\n        visit[i]=true;\\n\\n        for(auto p:adj[i])\\n        {\\n            if(visit[p]==false)\\n            {\\n                t++;\\n                //cout<<p<<\"->\";\\n                Join(p,visit,adj,t);\\n            }\\n        }\\n        return;\\n    }\\n    int makeConnected(int n, vector<vector<int>>& connections) {\\n        //goal is to find no. of connected components\\n        //and no of total cables given \\n        //and no of unconnected componenets\\n\\n        int unconnected=0;\\n\\n        int cables=connections.size();\\n        //i need to find extra cables by applying dfs on connected components\\n        vector<vector<int>>adj(n);\\n        for(auto p:connections)\\n        {\\n            adj[p[0]].push_back(p[1]);\\n            adj[p[1]].push_back(p[0]);\\n        }\\n        vector<bool>visit(n,false);\\n        int Min_cables=0;\\n        int components=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(adj[i].size() == 0)\\n            {\\n                //cout<<i<<\" \";\\n                unconnected++;\\n            }\\n            if(visit[i] == false and adj[i].size()>0)\\n            {\\n                components++;\\n                //cout<<i<<\"->\";\\n                int t=0;\\n                Join(i,visit,adj,t);\\n                //cout<<\"-\"<<t<<\"-\";\\n                Min_cables+=t;\\n                //cout<<endl;\\n            }\\n        }\\n        int Min_cables_to_connect_unconnected=unconnected-1 + components;\\n        int remaining_cables=cables-Min_cables;\\n        //cout<<endl<<cables<<\" \"<<Min_cables<<endl;\\n        if(Min_cables_to_connect_unconnected <= remaining_cables)\\n        {\\n            return Min_cables_to_connect_unconnected;\\n        }\\n        return -1;\\n    }`"
                    },
                    {
                        "username": "cpluspluscrowe",
                        "content": "What is the last test case?  Mine succeeds for all but test case 36, which shows n = \\nbut it does not show anything for n.  I am not sure what this last test case is."
                    },
                    {
                        "username": "user2418K",
                        "content": "What the heck is wrong with the testcases validation?\\n![Case 1](https://assets.leetcode.com/users/images/e527133a-e594-4c65-b84c-da5da5cb83eb_1679613069.2600863.png)\\n![Case 2](https://assets.leetcode.com/users/images/b823080c-0c13-40e3-b182-c96a2e56aa32_1679613078.3371115.png)\\n"
                    },
                    {
                        "username": "user2418K",
                        "content": "Btw, it\\'s the result for the `Golang` implementation.\\nIt looks like there are some issues on the server..."
                    },
                    {
                        "username": "Gab_Codes",
                        "content": "\"Any computer can reach any other computer directly or indirectly through the network.\" This is not correct; there are islands in the existing network, so not all are reachable from any other computer. "
                    },
                    {
                        "username": "Gab_Codes",
                        "content": "[@AMerrill](/AMerrill) Yep, directly would mean you\\'re immediately connected; indirectly would mean you\\'re connected via another computer, so 1-4 is a direct connection and 1-3-4 is an indirect connection between 1 and 4. Islands are not connected and therefore you cant reach one from the other. e.g. 1-2 and 3-4 are islands and one could not reach 3 from 1. Since there are test cases that contains islands, the directions should be re-written to clarify this. "
                    },
                    {
                        "username": "AMerrill",
                        "content": "They mean that computers can be connected either \"directly\" by means of a single cable : {[0,2]}, or \"indirectly\" through another computer: {[0,1], [1,2]}. (Thus in both cases computers 0 & 2 are connected)"
                    }
                ]
            },
            {
                "id": 1841585,
                "content": [
                    {
                        "username": "divyarajparmar_",
                        "content": "there is no code difference in my code and editorial code still when i submitted code written by me it was giving me TLE when i submitted the editorial code it was accepted. any idea why?\\n"
                    },
                    {
                        "username": "GitG0",
                        "content": "Make sure your program works for the test case\\n\\nn = 5\\nconnections = [[0,1],[0,2],[1,2],[3,4]]"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "If you're running on python and  implementing BFS, just  use this if-case so that one testcase doesnt fk you up. \n `return 20700 if n==21000`\nMy implementation was similar to some BFSes i found for c++ but still TLE. i think pop(0) takes n operations idk."
                    },
                    {
                        "username": "deep-bytes",
                        "content": "Seems like the constrain on n is incorrect for n = 1; it should be 1 < n <= 10^5;\\nbecause at n = 1; \\nthe other constrain becomes 1 <= connections.length <= 0"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I\\'ve been enjoying the Union-Find practice!"
                    },
                    {
                        "username": "smenendez",
                        "content": "Some here can answer me why a recursive DFS works in this exercise and a DFS with stack and loops cannot (TLE) in Python??"
                    },
                    {
                        "username": "IsaKons",
                        "content": "I have TLE on 34 test case with n= 49600... in recursive and interactive DFS.. idk what to do... may be need to change function what creates a two sided graph..."
                    },
                    {
                        "username": "_srahul_",
                        "content": "Even if I struggle, but I still love graph problems."
                    },
                    {
                        "username": "akeempositive",
                        "content": "I could not pass last test-case on this task... When I checked, the two inputs are empty, can someone help?"
                    },
                    {
                        "username": "Volarvolt",
                        "content": "Check if it really fails *on* the last test case or *after* the last test case.\\nI think you can get a TLE (Time Limit Exceeded) even after all the test cases has passed.\\n\\n(Which makes it hard to test without submitting, since you don\\'t get a test case for it.)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**TIP:** A connected graph with the fewest edges is a tree with n - 1 edges connecting n nodes. So, in order for a graph with n nodes to be connected, the graph must have at least n - 1 edges. It is impossible to connect a graph that has fewer than n - 1 edges. Otherwise, it is always possible to connect the graph.\\nWe return -1 if the number of edges in the graph (as determined by the size of connections) is less than n - 1."
                    },
                    {
                        "username": "shubhi_115",
                        "content": "Now leetcode sticks to Graphs question after tree questions, adhoc questions"
                    }
                ]
            },
            {
                "id": 1841531,
                "content": [
                    {
                        "username": "divyarajparmar_",
                        "content": "there is no code difference in my code and editorial code still when i submitted code written by me it was giving me TLE when i submitted the editorial code it was accepted. any idea why?\\n"
                    },
                    {
                        "username": "GitG0",
                        "content": "Make sure your program works for the test case\\n\\nn = 5\\nconnections = [[0,1],[0,2],[1,2],[3,4]]"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "If you're running on python and  implementing BFS, just  use this if-case so that one testcase doesnt fk you up. \n `return 20700 if n==21000`\nMy implementation was similar to some BFSes i found for c++ but still TLE. i think pop(0) takes n operations idk."
                    },
                    {
                        "username": "deep-bytes",
                        "content": "Seems like the constrain on n is incorrect for n = 1; it should be 1 < n <= 10^5;\\nbecause at n = 1; \\nthe other constrain becomes 1 <= connections.length <= 0"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I\\'ve been enjoying the Union-Find practice!"
                    },
                    {
                        "username": "smenendez",
                        "content": "Some here can answer me why a recursive DFS works in this exercise and a DFS with stack and loops cannot (TLE) in Python??"
                    },
                    {
                        "username": "IsaKons",
                        "content": "I have TLE on 34 test case with n= 49600... in recursive and interactive DFS.. idk what to do... may be need to change function what creates a two sided graph..."
                    },
                    {
                        "username": "_srahul_",
                        "content": "Even if I struggle, but I still love graph problems."
                    },
                    {
                        "username": "akeempositive",
                        "content": "I could not pass last test-case on this task... When I checked, the two inputs are empty, can someone help?"
                    },
                    {
                        "username": "Volarvolt",
                        "content": "Check if it really fails *on* the last test case or *after* the last test case.\\nI think you can get a TLE (Time Limit Exceeded) even after all the test cases has passed.\\n\\n(Which makes it hard to test without submitting, since you don\\'t get a test case for it.)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**TIP:** A connected graph with the fewest edges is a tree with n - 1 edges connecting n nodes. So, in order for a graph with n nodes to be connected, the graph must have at least n - 1 edges. It is impossible to connect a graph that has fewer than n - 1 edges. Otherwise, it is always possible to connect the graph.\\nWe return -1 if the number of edges in the graph (as determined by the size of connections) is less than n - 1."
                    },
                    {
                        "username": "shubhi_115",
                        "content": "Now leetcode sticks to Graphs question after tree questions, adhoc questions"
                    }
                ]
            },
            {
                "id": 1841528,
                "content": [
                    {
                        "username": "divyarajparmar_",
                        "content": "there is no code difference in my code and editorial code still when i submitted code written by me it was giving me TLE when i submitted the editorial code it was accepted. any idea why?\\n"
                    },
                    {
                        "username": "GitG0",
                        "content": "Make sure your program works for the test case\\n\\nn = 5\\nconnections = [[0,1],[0,2],[1,2],[3,4]]"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "If you're running on python and  implementing BFS, just  use this if-case so that one testcase doesnt fk you up. \n `return 20700 if n==21000`\nMy implementation was similar to some BFSes i found for c++ but still TLE. i think pop(0) takes n operations idk."
                    },
                    {
                        "username": "deep-bytes",
                        "content": "Seems like the constrain on n is incorrect for n = 1; it should be 1 < n <= 10^5;\\nbecause at n = 1; \\nthe other constrain becomes 1 <= connections.length <= 0"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I\\'ve been enjoying the Union-Find practice!"
                    },
                    {
                        "username": "smenendez",
                        "content": "Some here can answer me why a recursive DFS works in this exercise and a DFS with stack and loops cannot (TLE) in Python??"
                    },
                    {
                        "username": "IsaKons",
                        "content": "I have TLE on 34 test case with n= 49600... in recursive and interactive DFS.. idk what to do... may be need to change function what creates a two sided graph..."
                    },
                    {
                        "username": "_srahul_",
                        "content": "Even if I struggle, but I still love graph problems."
                    },
                    {
                        "username": "akeempositive",
                        "content": "I could not pass last test-case on this task... When I checked, the two inputs are empty, can someone help?"
                    },
                    {
                        "username": "Volarvolt",
                        "content": "Check if it really fails *on* the last test case or *after* the last test case.\\nI think you can get a TLE (Time Limit Exceeded) even after all the test cases has passed.\\n\\n(Which makes it hard to test without submitting, since you don\\'t get a test case for it.)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**TIP:** A connected graph with the fewest edges is a tree with n - 1 edges connecting n nodes. So, in order for a graph with n nodes to be connected, the graph must have at least n - 1 edges. It is impossible to connect a graph that has fewer than n - 1 edges. Otherwise, it is always possible to connect the graph.\\nWe return -1 if the number of edges in the graph (as determined by the size of connections) is less than n - 1."
                    },
                    {
                        "username": "shubhi_115",
                        "content": "Now leetcode sticks to Graphs question after tree questions, adhoc questions"
                    }
                ]
            },
            {
                "id": 1841518,
                "content": [
                    {
                        "username": "divyarajparmar_",
                        "content": "there is no code difference in my code and editorial code still when i submitted code written by me it was giving me TLE when i submitted the editorial code it was accepted. any idea why?\\n"
                    },
                    {
                        "username": "GitG0",
                        "content": "Make sure your program works for the test case\\n\\nn = 5\\nconnections = [[0,1],[0,2],[1,2],[3,4]]"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "If you're running on python and  implementing BFS, just  use this if-case so that one testcase doesnt fk you up. \n `return 20700 if n==21000`\nMy implementation was similar to some BFSes i found for c++ but still TLE. i think pop(0) takes n operations idk."
                    },
                    {
                        "username": "deep-bytes",
                        "content": "Seems like the constrain on n is incorrect for n = 1; it should be 1 < n <= 10^5;\\nbecause at n = 1; \\nthe other constrain becomes 1 <= connections.length <= 0"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I\\'ve been enjoying the Union-Find practice!"
                    },
                    {
                        "username": "smenendez",
                        "content": "Some here can answer me why a recursive DFS works in this exercise and a DFS with stack and loops cannot (TLE) in Python??"
                    },
                    {
                        "username": "IsaKons",
                        "content": "I have TLE on 34 test case with n= 49600... in recursive and interactive DFS.. idk what to do... may be need to change function what creates a two sided graph..."
                    },
                    {
                        "username": "_srahul_",
                        "content": "Even if I struggle, but I still love graph problems."
                    },
                    {
                        "username": "akeempositive",
                        "content": "I could not pass last test-case on this task... When I checked, the two inputs are empty, can someone help?"
                    },
                    {
                        "username": "Volarvolt",
                        "content": "Check if it really fails *on* the last test case or *after* the last test case.\\nI think you can get a TLE (Time Limit Exceeded) even after all the test cases has passed.\\n\\n(Which makes it hard to test without submitting, since you don\\'t get a test case for it.)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**TIP:** A connected graph with the fewest edges is a tree with n - 1 edges connecting n nodes. So, in order for a graph with n nodes to be connected, the graph must have at least n - 1 edges. It is impossible to connect a graph that has fewer than n - 1 edges. Otherwise, it is always possible to connect the graph.\\nWe return -1 if the number of edges in the graph (as determined by the size of connections) is less than n - 1."
                    },
                    {
                        "username": "shubhi_115",
                        "content": "Now leetcode sticks to Graphs question after tree questions, adhoc questions"
                    }
                ]
            },
            {
                "id": 1841497,
                "content": [
                    {
                        "username": "divyarajparmar_",
                        "content": "there is no code difference in my code and editorial code still when i submitted code written by me it was giving me TLE when i submitted the editorial code it was accepted. any idea why?\\n"
                    },
                    {
                        "username": "GitG0",
                        "content": "Make sure your program works for the test case\\n\\nn = 5\\nconnections = [[0,1],[0,2],[1,2],[3,4]]"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "If you're running on python and  implementing BFS, just  use this if-case so that one testcase doesnt fk you up. \n `return 20700 if n==21000`\nMy implementation was similar to some BFSes i found for c++ but still TLE. i think pop(0) takes n operations idk."
                    },
                    {
                        "username": "deep-bytes",
                        "content": "Seems like the constrain on n is incorrect for n = 1; it should be 1 < n <= 10^5;\\nbecause at n = 1; \\nthe other constrain becomes 1 <= connections.length <= 0"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I\\'ve been enjoying the Union-Find practice!"
                    },
                    {
                        "username": "smenendez",
                        "content": "Some here can answer me why a recursive DFS works in this exercise and a DFS with stack and loops cannot (TLE) in Python??"
                    },
                    {
                        "username": "IsaKons",
                        "content": "I have TLE on 34 test case with n= 49600... in recursive and interactive DFS.. idk what to do... may be need to change function what creates a two sided graph..."
                    },
                    {
                        "username": "_srahul_",
                        "content": "Even if I struggle, but I still love graph problems."
                    },
                    {
                        "username": "akeempositive",
                        "content": "I could not pass last test-case on this task... When I checked, the two inputs are empty, can someone help?"
                    },
                    {
                        "username": "Volarvolt",
                        "content": "Check if it really fails *on* the last test case or *after* the last test case.\\nI think you can get a TLE (Time Limit Exceeded) even after all the test cases has passed.\\n\\n(Which makes it hard to test without submitting, since you don\\'t get a test case for it.)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**TIP:** A connected graph with the fewest edges is a tree with n - 1 edges connecting n nodes. So, in order for a graph with n nodes to be connected, the graph must have at least n - 1 edges. It is impossible to connect a graph that has fewer than n - 1 edges. Otherwise, it is always possible to connect the graph.\\nWe return -1 if the number of edges in the graph (as determined by the size of connections) is less than n - 1."
                    },
                    {
                        "username": "shubhi_115",
                        "content": "Now leetcode sticks to Graphs question after tree questions, adhoc questions"
                    }
                ]
            },
            {
                "id": 1841463,
                "content": [
                    {
                        "username": "divyarajparmar_",
                        "content": "there is no code difference in my code and editorial code still when i submitted code written by me it was giving me TLE when i submitted the editorial code it was accepted. any idea why?\\n"
                    },
                    {
                        "username": "GitG0",
                        "content": "Make sure your program works for the test case\\n\\nn = 5\\nconnections = [[0,1],[0,2],[1,2],[3,4]]"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "If you're running on python and  implementing BFS, just  use this if-case so that one testcase doesnt fk you up. \n `return 20700 if n==21000`\nMy implementation was similar to some BFSes i found for c++ but still TLE. i think pop(0) takes n operations idk."
                    },
                    {
                        "username": "deep-bytes",
                        "content": "Seems like the constrain on n is incorrect for n = 1; it should be 1 < n <= 10^5;\\nbecause at n = 1; \\nthe other constrain becomes 1 <= connections.length <= 0"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I\\'ve been enjoying the Union-Find practice!"
                    },
                    {
                        "username": "smenendez",
                        "content": "Some here can answer me why a recursive DFS works in this exercise and a DFS with stack and loops cannot (TLE) in Python??"
                    },
                    {
                        "username": "IsaKons",
                        "content": "I have TLE on 34 test case with n= 49600... in recursive and interactive DFS.. idk what to do... may be need to change function what creates a two sided graph..."
                    },
                    {
                        "username": "_srahul_",
                        "content": "Even if I struggle, but I still love graph problems."
                    },
                    {
                        "username": "akeempositive",
                        "content": "I could not pass last test-case on this task... When I checked, the two inputs are empty, can someone help?"
                    },
                    {
                        "username": "Volarvolt",
                        "content": "Check if it really fails *on* the last test case or *after* the last test case.\\nI think you can get a TLE (Time Limit Exceeded) even after all the test cases has passed.\\n\\n(Which makes it hard to test without submitting, since you don\\'t get a test case for it.)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**TIP:** A connected graph with the fewest edges is a tree with n - 1 edges connecting n nodes. So, in order for a graph with n nodes to be connected, the graph must have at least n - 1 edges. It is impossible to connect a graph that has fewer than n - 1 edges. Otherwise, it is always possible to connect the graph.\\nWe return -1 if the number of edges in the graph (as determined by the size of connections) is less than n - 1."
                    },
                    {
                        "username": "shubhi_115",
                        "content": "Now leetcode sticks to Graphs question after tree questions, adhoc questions"
                    }
                ]
            },
            {
                "id": 1841291,
                "content": [
                    {
                        "username": "divyarajparmar_",
                        "content": "there is no code difference in my code and editorial code still when i submitted code written by me it was giving me TLE when i submitted the editorial code it was accepted. any idea why?\\n"
                    },
                    {
                        "username": "GitG0",
                        "content": "Make sure your program works for the test case\\n\\nn = 5\\nconnections = [[0,1],[0,2],[1,2],[3,4]]"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "If you're running on python and  implementing BFS, just  use this if-case so that one testcase doesnt fk you up. \n `return 20700 if n==21000`\nMy implementation was similar to some BFSes i found for c++ but still TLE. i think pop(0) takes n operations idk."
                    },
                    {
                        "username": "deep-bytes",
                        "content": "Seems like the constrain on n is incorrect for n = 1; it should be 1 < n <= 10^5;\\nbecause at n = 1; \\nthe other constrain becomes 1 <= connections.length <= 0"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I\\'ve been enjoying the Union-Find practice!"
                    },
                    {
                        "username": "smenendez",
                        "content": "Some here can answer me why a recursive DFS works in this exercise and a DFS with stack and loops cannot (TLE) in Python??"
                    },
                    {
                        "username": "IsaKons",
                        "content": "I have TLE on 34 test case with n= 49600... in recursive and interactive DFS.. idk what to do... may be need to change function what creates a two sided graph..."
                    },
                    {
                        "username": "_srahul_",
                        "content": "Even if I struggle, but I still love graph problems."
                    },
                    {
                        "username": "akeempositive",
                        "content": "I could not pass last test-case on this task... When I checked, the two inputs are empty, can someone help?"
                    },
                    {
                        "username": "Volarvolt",
                        "content": "Check if it really fails *on* the last test case or *after* the last test case.\\nI think you can get a TLE (Time Limit Exceeded) even after all the test cases has passed.\\n\\n(Which makes it hard to test without submitting, since you don\\'t get a test case for it.)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**TIP:** A connected graph with the fewest edges is a tree with n - 1 edges connecting n nodes. So, in order for a graph with n nodes to be connected, the graph must have at least n - 1 edges. It is impossible to connect a graph that has fewer than n - 1 edges. Otherwise, it is always possible to connect the graph.\\nWe return -1 if the number of edges in the graph (as determined by the size of connections) is less than n - 1."
                    },
                    {
                        "username": "shubhi_115",
                        "content": "Now leetcode sticks to Graphs question after tree questions, adhoc questions"
                    }
                ]
            },
            {
                "id": 1841227,
                "content": [
                    {
                        "username": "divyarajparmar_",
                        "content": "there is no code difference in my code and editorial code still when i submitted code written by me it was giving me TLE when i submitted the editorial code it was accepted. any idea why?\\n"
                    },
                    {
                        "username": "GitG0",
                        "content": "Make sure your program works for the test case\\n\\nn = 5\\nconnections = [[0,1],[0,2],[1,2],[3,4]]"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "If you're running on python and  implementing BFS, just  use this if-case so that one testcase doesnt fk you up. \n `return 20700 if n==21000`\nMy implementation was similar to some BFSes i found for c++ but still TLE. i think pop(0) takes n operations idk."
                    },
                    {
                        "username": "deep-bytes",
                        "content": "Seems like the constrain on n is incorrect for n = 1; it should be 1 < n <= 10^5;\\nbecause at n = 1; \\nthe other constrain becomes 1 <= connections.length <= 0"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I\\'ve been enjoying the Union-Find practice!"
                    },
                    {
                        "username": "smenendez",
                        "content": "Some here can answer me why a recursive DFS works in this exercise and a DFS with stack and loops cannot (TLE) in Python??"
                    },
                    {
                        "username": "IsaKons",
                        "content": "I have TLE on 34 test case with n= 49600... in recursive and interactive DFS.. idk what to do... may be need to change function what creates a two sided graph..."
                    },
                    {
                        "username": "_srahul_",
                        "content": "Even if I struggle, but I still love graph problems."
                    },
                    {
                        "username": "akeempositive",
                        "content": "I could not pass last test-case on this task... When I checked, the two inputs are empty, can someone help?"
                    },
                    {
                        "username": "Volarvolt",
                        "content": "Check if it really fails *on* the last test case or *after* the last test case.\\nI think you can get a TLE (Time Limit Exceeded) even after all the test cases has passed.\\n\\n(Which makes it hard to test without submitting, since you don\\'t get a test case for it.)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**TIP:** A connected graph with the fewest edges is a tree with n - 1 edges connecting n nodes. So, in order for a graph with n nodes to be connected, the graph must have at least n - 1 edges. It is impossible to connect a graph that has fewer than n - 1 edges. Otherwise, it is always possible to connect the graph.\\nWe return -1 if the number of edges in the graph (as determined by the size of connections) is less than n - 1."
                    },
                    {
                        "username": "shubhi_115",
                        "content": "Now leetcode sticks to Graphs question after tree questions, adhoc questions"
                    }
                ]
            },
            {
                "id": 1841150,
                "content": [
                    {
                        "username": "divyarajparmar_",
                        "content": "there is no code difference in my code and editorial code still when i submitted code written by me it was giving me TLE when i submitted the editorial code it was accepted. any idea why?\\n"
                    },
                    {
                        "username": "GitG0",
                        "content": "Make sure your program works for the test case\\n\\nn = 5\\nconnections = [[0,1],[0,2],[1,2],[3,4]]"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "If you're running on python and  implementing BFS, just  use this if-case so that one testcase doesnt fk you up. \n `return 20700 if n==21000`\nMy implementation was similar to some BFSes i found for c++ but still TLE. i think pop(0) takes n operations idk."
                    },
                    {
                        "username": "deep-bytes",
                        "content": "Seems like the constrain on n is incorrect for n = 1; it should be 1 < n <= 10^5;\\nbecause at n = 1; \\nthe other constrain becomes 1 <= connections.length <= 0"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I\\'ve been enjoying the Union-Find practice!"
                    },
                    {
                        "username": "smenendez",
                        "content": "Some here can answer me why a recursive DFS works in this exercise and a DFS with stack and loops cannot (TLE) in Python??"
                    },
                    {
                        "username": "IsaKons",
                        "content": "I have TLE on 34 test case with n= 49600... in recursive and interactive DFS.. idk what to do... may be need to change function what creates a two sided graph..."
                    },
                    {
                        "username": "_srahul_",
                        "content": "Even if I struggle, but I still love graph problems."
                    },
                    {
                        "username": "akeempositive",
                        "content": "I could not pass last test-case on this task... When I checked, the two inputs are empty, can someone help?"
                    },
                    {
                        "username": "Volarvolt",
                        "content": "Check if it really fails *on* the last test case or *after* the last test case.\\nI think you can get a TLE (Time Limit Exceeded) even after all the test cases has passed.\\n\\n(Which makes it hard to test without submitting, since you don\\'t get a test case for it.)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**TIP:** A connected graph with the fewest edges is a tree with n - 1 edges connecting n nodes. So, in order for a graph with n nodes to be connected, the graph must have at least n - 1 edges. It is impossible to connect a graph that has fewer than n - 1 edges. Otherwise, it is always possible to connect the graph.\\nWe return -1 if the number of edges in the graph (as determined by the size of connections) is less than n - 1."
                    },
                    {
                        "username": "shubhi_115",
                        "content": "Now leetcode sticks to Graphs question after tree questions, adhoc questions"
                    }
                ]
            },
            {
                "id": 1841110,
                "content": [
                    {
                        "username": "divyarajparmar_",
                        "content": "there is no code difference in my code and editorial code still when i submitted code written by me it was giving me TLE when i submitted the editorial code it was accepted. any idea why?\\n"
                    },
                    {
                        "username": "GitG0",
                        "content": "Make sure your program works for the test case\\n\\nn = 5\\nconnections = [[0,1],[0,2],[1,2],[3,4]]"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "If you're running on python and  implementing BFS, just  use this if-case so that one testcase doesnt fk you up. \n `return 20700 if n==21000`\nMy implementation was similar to some BFSes i found for c++ but still TLE. i think pop(0) takes n operations idk."
                    },
                    {
                        "username": "deep-bytes",
                        "content": "Seems like the constrain on n is incorrect for n = 1; it should be 1 < n <= 10^5;\\nbecause at n = 1; \\nthe other constrain becomes 1 <= connections.length <= 0"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I\\'ve been enjoying the Union-Find practice!"
                    },
                    {
                        "username": "smenendez",
                        "content": "Some here can answer me why a recursive DFS works in this exercise and a DFS with stack and loops cannot (TLE) in Python??"
                    },
                    {
                        "username": "IsaKons",
                        "content": "I have TLE on 34 test case with n= 49600... in recursive and interactive DFS.. idk what to do... may be need to change function what creates a two sided graph..."
                    },
                    {
                        "username": "_srahul_",
                        "content": "Even if I struggle, but I still love graph problems."
                    },
                    {
                        "username": "akeempositive",
                        "content": "I could not pass last test-case on this task... When I checked, the two inputs are empty, can someone help?"
                    },
                    {
                        "username": "Volarvolt",
                        "content": "Check if it really fails *on* the last test case or *after* the last test case.\\nI think you can get a TLE (Time Limit Exceeded) even after all the test cases has passed.\\n\\n(Which makes it hard to test without submitting, since you don\\'t get a test case for it.)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**TIP:** A connected graph with the fewest edges is a tree with n - 1 edges connecting n nodes. So, in order for a graph with n nodes to be connected, the graph must have at least n - 1 edges. It is impossible to connect a graph that has fewer than n - 1 edges. Otherwise, it is always possible to connect the graph.\\nWe return -1 if the number of edges in the graph (as determined by the size of connections) is less than n - 1."
                    },
                    {
                        "username": "shubhi_115",
                        "content": "Now leetcode sticks to Graphs question after tree questions, adhoc questions"
                    }
                ]
            },
            {
                "id": 1841079,
                "content": [
                    {
                        "username": "Saitima",
                        "content": "Leet\\'s love for graph is back"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n1. Check if it is possible to connect all the computers in the network:\\n     - We need at least n-1 wires to connect all n computers in the network.\\n     - If the number of wires given is less than n-1, it is impossible to connect all the computers. In this case, we can return -1.\\n\\n2. Create a graph to represent the network:\\n    - Each computer is a node in the graph.\\n    - Each wire is an edge between two nodes.\\n    - We can use an adjacency list to represent the edges of each node.\\n\\n3. Use DFS to count the number of connected components:\\n    - A connected component is a group of nodes that are connected to each other by some path.\\n    - We can start the DFS algorithm from each unvisited node in the graph.\\n    - We visit all its neighbors, mark them as visited, and then recursively visit all the neighbors of the visited neighbors until we have visited all the nodes in the connected component.\\n    - We keep track of the number of connected components we have visited, which is equal to the minimum number of wires we need to add to connect all the computers in the network.\\n\\n4. Return the minimum number of wires we need to add:\\n    - The minimum number of wires we need to add is equal to the number of connected components minus one.\\n    - We subtract one because we can connect all the connected components with just one wire."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link:-)***\\nhttps://leetcode.com/problems/number-of-operations-to-make-network-connected/solutions/3330899/easiest-solution/"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Approach is so simple you will laugh on yourself after finding out\\n\\nTip: just run dfs without checking anything except visited."
                    },
                    {
                        "username": "ayush_verma_007",
                        "content": "Hii to Graphs Again. this week\\'s gonna be good"
                    },
                    {
                        "username": "lavanyapareek",
                        "content": "Merge > Make components > return number of components - 1."
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "Graph week, here we go :))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "What I understand is to remove the cables from a network G (G should be disconnected)   and connect them to a connected network. If the number of cables is e, and the total number of computers is n, such as e<n-1, there must be no solution, because the cables are not enough. \n\nSuppose that G consists of  several connected components G_i.  Each connected components G_i has a spanning tree, say T_i. The removable cables are in some of G_i\\T_i.\n\nIf wrong, please correct me."
                    },
                    {
                        "username": "manifold1985",
                        "content": "[@anwendeng](/anwendeng) Exactly. Reference to the three examples below the problem statement: all of them are disconnected."
                    },
                    {
                        "username": "manifold1985",
                        "content": "\"You can extract certain cables between two directly connected computers, and place them between any pair of disconnected computers to make them directly connected.\"\\n\\n\"Return the minimum number of times you need to do this in order to make all the computers connected. \"\\n\\nAccording to the description above, it doesn\\'t have to do with the spanning tree; instead, you need to determine how little you need to reconnect the computers to make the entire network connected. \\n\\nFor instance, if the entire network is separated into two connected components, and there is at least one more extra cable in either of the components, then what you need to do is to connect one end of that cable to the other component. Does it make sense to you? "
                    },
                    {
                        "username": "ihowaonaro",
                        "content": "Can someone explain why my solution exceeds the time limit even though it is basically the same as most of the expected solutions only that it is a stack based solution and not recursion based\n\n `\ndef makeConnected(self, n: int, connections: List[List[int]]) -> int:\n        if len(connections) < n - 1:\n            return -1\n\n        noOfComponents = 0\n        visited = [False for _ in range(n)]\n        edgeMap = defaultdict(set)\n        \n        for node1, node2 in connections:\n            edgeMap[node1].add(node2)\n            edgeMap[node2].add(node1)\n\n        for i in range(n):\n            if not visited[i]:\n                noOfComponents += 1\n            \n                stack = deque([i])\n                while stack:\n                    node = stack.popleft()\n                    visited[node] = True\n\n                    for neighbour in edgeMap[node]:\n                        if not visited[neighbour]:\n                            stack.append(neighbour)\n\n        return noOfComponents - 1\n`"
                    },
                    {
                        "username": "Deep74",
                        "content": "class Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connection) {\\n\\n           if(connection.size()<n-1){\\n               return -1;\\n           }\\n        vector<vector<int>>v(n,vector<int>(n));\\n        \\n        for(int i=0;i<connection.size();i++){\\n            int a=connection[i][0];\\n            int b=connection[i][1];\\n            v[a].push_back(b);\\n           v[b].push_back(a);\\n             \\n        }\\n     int ans=0;\\n            vector<int>mp(n,0);     queue<int>q;\\n     for(int i=0;i<n;i++){\\n\\n     \\n         if(mp[i]==0){\\n             ans++;\\n         q.push(i);\\n\\n         while(!q.empty()){\\n                          mp[q.front()]++;\\n            \\n             for(int j=0;j<v[q.front()].size();j++){\\n                 if(mp[v[q.front()][j]]==0){\\n                  \\n\\n                     //mp[q.front()]++;\\n                     // mp[j]++;\\n                      q.push(v[q.front()][j]);\\n\\n                 }\\n             \\n             \\n              }\\n              \\n                  q.pop();\\n         }\\n\\n         }\\n\\n         \\n     } return ans-1;\\n\\n    }\\n};       \\n\\ncan anyone explain why this code is giving tle  on larger testcase (n=10000)"
                    },
                    {
                        "username": "iw33209jfdcifidfj93",
                        "content": "Bhaiyo easy hai bs itna jaan lo .... no. of disconnected networks nikal lo ....no. of cycles count kr lo fir in dono ke relation se ans bna daalo aur LIKE thoko"
                    }
                ]
            },
            {
                "id": 1841077,
                "content": [
                    {
                        "username": "Saitima",
                        "content": "Leet\\'s love for graph is back"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n1. Check if it is possible to connect all the computers in the network:\\n     - We need at least n-1 wires to connect all n computers in the network.\\n     - If the number of wires given is less than n-1, it is impossible to connect all the computers. In this case, we can return -1.\\n\\n2. Create a graph to represent the network:\\n    - Each computer is a node in the graph.\\n    - Each wire is an edge between two nodes.\\n    - We can use an adjacency list to represent the edges of each node.\\n\\n3. Use DFS to count the number of connected components:\\n    - A connected component is a group of nodes that are connected to each other by some path.\\n    - We can start the DFS algorithm from each unvisited node in the graph.\\n    - We visit all its neighbors, mark them as visited, and then recursively visit all the neighbors of the visited neighbors until we have visited all the nodes in the connected component.\\n    - We keep track of the number of connected components we have visited, which is equal to the minimum number of wires we need to add to connect all the computers in the network.\\n\\n4. Return the minimum number of wires we need to add:\\n    - The minimum number of wires we need to add is equal to the number of connected components minus one.\\n    - We subtract one because we can connect all the connected components with just one wire."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link:-)***\\nhttps://leetcode.com/problems/number-of-operations-to-make-network-connected/solutions/3330899/easiest-solution/"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Approach is so simple you will laugh on yourself after finding out\\n\\nTip: just run dfs without checking anything except visited."
                    },
                    {
                        "username": "ayush_verma_007",
                        "content": "Hii to Graphs Again. this week\\'s gonna be good"
                    },
                    {
                        "username": "lavanyapareek",
                        "content": "Merge > Make components > return number of components - 1."
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "Graph week, here we go :))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "What I understand is to remove the cables from a network G (G should be disconnected)   and connect them to a connected network. If the number of cables is e, and the total number of computers is n, such as e<n-1, there must be no solution, because the cables are not enough. \n\nSuppose that G consists of  several connected components G_i.  Each connected components G_i has a spanning tree, say T_i. The removable cables are in some of G_i\\T_i.\n\nIf wrong, please correct me."
                    },
                    {
                        "username": "manifold1985",
                        "content": "[@anwendeng](/anwendeng) Exactly. Reference to the three examples below the problem statement: all of them are disconnected."
                    },
                    {
                        "username": "manifold1985",
                        "content": "\"You can extract certain cables between two directly connected computers, and place them between any pair of disconnected computers to make them directly connected.\"\\n\\n\"Return the minimum number of times you need to do this in order to make all the computers connected. \"\\n\\nAccording to the description above, it doesn\\'t have to do with the spanning tree; instead, you need to determine how little you need to reconnect the computers to make the entire network connected. \\n\\nFor instance, if the entire network is separated into two connected components, and there is at least one more extra cable in either of the components, then what you need to do is to connect one end of that cable to the other component. Does it make sense to you? "
                    },
                    {
                        "username": "ihowaonaro",
                        "content": "Can someone explain why my solution exceeds the time limit even though it is basically the same as most of the expected solutions only that it is a stack based solution and not recursion based\n\n `\ndef makeConnected(self, n: int, connections: List[List[int]]) -> int:\n        if len(connections) < n - 1:\n            return -1\n\n        noOfComponents = 0\n        visited = [False for _ in range(n)]\n        edgeMap = defaultdict(set)\n        \n        for node1, node2 in connections:\n            edgeMap[node1].add(node2)\n            edgeMap[node2].add(node1)\n\n        for i in range(n):\n            if not visited[i]:\n                noOfComponents += 1\n            \n                stack = deque([i])\n                while stack:\n                    node = stack.popleft()\n                    visited[node] = True\n\n                    for neighbour in edgeMap[node]:\n                        if not visited[neighbour]:\n                            stack.append(neighbour)\n\n        return noOfComponents - 1\n`"
                    },
                    {
                        "username": "Deep74",
                        "content": "class Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connection) {\\n\\n           if(connection.size()<n-1){\\n               return -1;\\n           }\\n        vector<vector<int>>v(n,vector<int>(n));\\n        \\n        for(int i=0;i<connection.size();i++){\\n            int a=connection[i][0];\\n            int b=connection[i][1];\\n            v[a].push_back(b);\\n           v[b].push_back(a);\\n             \\n        }\\n     int ans=0;\\n            vector<int>mp(n,0);     queue<int>q;\\n     for(int i=0;i<n;i++){\\n\\n     \\n         if(mp[i]==0){\\n             ans++;\\n         q.push(i);\\n\\n         while(!q.empty()){\\n                          mp[q.front()]++;\\n            \\n             for(int j=0;j<v[q.front()].size();j++){\\n                 if(mp[v[q.front()][j]]==0){\\n                  \\n\\n                     //mp[q.front()]++;\\n                     // mp[j]++;\\n                      q.push(v[q.front()][j]);\\n\\n                 }\\n             \\n             \\n              }\\n              \\n                  q.pop();\\n         }\\n\\n         }\\n\\n         \\n     } return ans-1;\\n\\n    }\\n};       \\n\\ncan anyone explain why this code is giving tle  on larger testcase (n=10000)"
                    },
                    {
                        "username": "iw33209jfdcifidfj93",
                        "content": "Bhaiyo easy hai bs itna jaan lo .... no. of disconnected networks nikal lo ....no. of cycles count kr lo fir in dono ke relation se ans bna daalo aur LIKE thoko"
                    }
                ]
            },
            {
                "id": 1841036,
                "content": [
                    {
                        "username": "Saitima",
                        "content": "Leet\\'s love for graph is back"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n1. Check if it is possible to connect all the computers in the network:\\n     - We need at least n-1 wires to connect all n computers in the network.\\n     - If the number of wires given is less than n-1, it is impossible to connect all the computers. In this case, we can return -1.\\n\\n2. Create a graph to represent the network:\\n    - Each computer is a node in the graph.\\n    - Each wire is an edge between two nodes.\\n    - We can use an adjacency list to represent the edges of each node.\\n\\n3. Use DFS to count the number of connected components:\\n    - A connected component is a group of nodes that are connected to each other by some path.\\n    - We can start the DFS algorithm from each unvisited node in the graph.\\n    - We visit all its neighbors, mark them as visited, and then recursively visit all the neighbors of the visited neighbors until we have visited all the nodes in the connected component.\\n    - We keep track of the number of connected components we have visited, which is equal to the minimum number of wires we need to add to connect all the computers in the network.\\n\\n4. Return the minimum number of wires we need to add:\\n    - The minimum number of wires we need to add is equal to the number of connected components minus one.\\n    - We subtract one because we can connect all the connected components with just one wire."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link:-)***\\nhttps://leetcode.com/problems/number-of-operations-to-make-network-connected/solutions/3330899/easiest-solution/"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Approach is so simple you will laugh on yourself after finding out\\n\\nTip: just run dfs without checking anything except visited."
                    },
                    {
                        "username": "ayush_verma_007",
                        "content": "Hii to Graphs Again. this week\\'s gonna be good"
                    },
                    {
                        "username": "lavanyapareek",
                        "content": "Merge > Make components > return number of components - 1."
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "Graph week, here we go :))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "What I understand is to remove the cables from a network G (G should be disconnected)   and connect them to a connected network. If the number of cables is e, and the total number of computers is n, such as e<n-1, there must be no solution, because the cables are not enough. \n\nSuppose that G consists of  several connected components G_i.  Each connected components G_i has a spanning tree, say T_i. The removable cables are in some of G_i\\T_i.\n\nIf wrong, please correct me."
                    },
                    {
                        "username": "manifold1985",
                        "content": "[@anwendeng](/anwendeng) Exactly. Reference to the three examples below the problem statement: all of them are disconnected."
                    },
                    {
                        "username": "manifold1985",
                        "content": "\"You can extract certain cables between two directly connected computers, and place them between any pair of disconnected computers to make them directly connected.\"\\n\\n\"Return the minimum number of times you need to do this in order to make all the computers connected. \"\\n\\nAccording to the description above, it doesn\\'t have to do with the spanning tree; instead, you need to determine how little you need to reconnect the computers to make the entire network connected. \\n\\nFor instance, if the entire network is separated into two connected components, and there is at least one more extra cable in either of the components, then what you need to do is to connect one end of that cable to the other component. Does it make sense to you? "
                    },
                    {
                        "username": "ihowaonaro",
                        "content": "Can someone explain why my solution exceeds the time limit even though it is basically the same as most of the expected solutions only that it is a stack based solution and not recursion based\n\n `\ndef makeConnected(self, n: int, connections: List[List[int]]) -> int:\n        if len(connections) < n - 1:\n            return -1\n\n        noOfComponents = 0\n        visited = [False for _ in range(n)]\n        edgeMap = defaultdict(set)\n        \n        for node1, node2 in connections:\n            edgeMap[node1].add(node2)\n            edgeMap[node2].add(node1)\n\n        for i in range(n):\n            if not visited[i]:\n                noOfComponents += 1\n            \n                stack = deque([i])\n                while stack:\n                    node = stack.popleft()\n                    visited[node] = True\n\n                    for neighbour in edgeMap[node]:\n                        if not visited[neighbour]:\n                            stack.append(neighbour)\n\n        return noOfComponents - 1\n`"
                    },
                    {
                        "username": "Deep74",
                        "content": "class Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connection) {\\n\\n           if(connection.size()<n-1){\\n               return -1;\\n           }\\n        vector<vector<int>>v(n,vector<int>(n));\\n        \\n        for(int i=0;i<connection.size();i++){\\n            int a=connection[i][0];\\n            int b=connection[i][1];\\n            v[a].push_back(b);\\n           v[b].push_back(a);\\n             \\n        }\\n     int ans=0;\\n            vector<int>mp(n,0);     queue<int>q;\\n     for(int i=0;i<n;i++){\\n\\n     \\n         if(mp[i]==0){\\n             ans++;\\n         q.push(i);\\n\\n         while(!q.empty()){\\n                          mp[q.front()]++;\\n            \\n             for(int j=0;j<v[q.front()].size();j++){\\n                 if(mp[v[q.front()][j]]==0){\\n                  \\n\\n                     //mp[q.front()]++;\\n                     // mp[j]++;\\n                      q.push(v[q.front()][j]);\\n\\n                 }\\n             \\n             \\n              }\\n              \\n                  q.pop();\\n         }\\n\\n         }\\n\\n         \\n     } return ans-1;\\n\\n    }\\n};       \\n\\ncan anyone explain why this code is giving tle  on larger testcase (n=10000)"
                    },
                    {
                        "username": "iw33209jfdcifidfj93",
                        "content": "Bhaiyo easy hai bs itna jaan lo .... no. of disconnected networks nikal lo ....no. of cycles count kr lo fir in dono ke relation se ans bna daalo aur LIKE thoko"
                    }
                ]
            },
            {
                "id": 1841035,
                "content": [
                    {
                        "username": "Saitima",
                        "content": "Leet\\'s love for graph is back"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n1. Check if it is possible to connect all the computers in the network:\\n     - We need at least n-1 wires to connect all n computers in the network.\\n     - If the number of wires given is less than n-1, it is impossible to connect all the computers. In this case, we can return -1.\\n\\n2. Create a graph to represent the network:\\n    - Each computer is a node in the graph.\\n    - Each wire is an edge between two nodes.\\n    - We can use an adjacency list to represent the edges of each node.\\n\\n3. Use DFS to count the number of connected components:\\n    - A connected component is a group of nodes that are connected to each other by some path.\\n    - We can start the DFS algorithm from each unvisited node in the graph.\\n    - We visit all its neighbors, mark them as visited, and then recursively visit all the neighbors of the visited neighbors until we have visited all the nodes in the connected component.\\n    - We keep track of the number of connected components we have visited, which is equal to the minimum number of wires we need to add to connect all the computers in the network.\\n\\n4. Return the minimum number of wires we need to add:\\n    - The minimum number of wires we need to add is equal to the number of connected components minus one.\\n    - We subtract one because we can connect all the connected components with just one wire."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link:-)***\\nhttps://leetcode.com/problems/number-of-operations-to-make-network-connected/solutions/3330899/easiest-solution/"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Approach is so simple you will laugh on yourself after finding out\\n\\nTip: just run dfs without checking anything except visited."
                    },
                    {
                        "username": "ayush_verma_007",
                        "content": "Hii to Graphs Again. this week\\'s gonna be good"
                    },
                    {
                        "username": "lavanyapareek",
                        "content": "Merge > Make components > return number of components - 1."
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "Graph week, here we go :))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "What I understand is to remove the cables from a network G (G should be disconnected)   and connect them to a connected network. If the number of cables is e, and the total number of computers is n, such as e<n-1, there must be no solution, because the cables are not enough. \n\nSuppose that G consists of  several connected components G_i.  Each connected components G_i has a spanning tree, say T_i. The removable cables are in some of G_i\\T_i.\n\nIf wrong, please correct me."
                    },
                    {
                        "username": "manifold1985",
                        "content": "[@anwendeng](/anwendeng) Exactly. Reference to the three examples below the problem statement: all of them are disconnected."
                    },
                    {
                        "username": "manifold1985",
                        "content": "\"You can extract certain cables between two directly connected computers, and place them between any pair of disconnected computers to make them directly connected.\"\\n\\n\"Return the minimum number of times you need to do this in order to make all the computers connected. \"\\n\\nAccording to the description above, it doesn\\'t have to do with the spanning tree; instead, you need to determine how little you need to reconnect the computers to make the entire network connected. \\n\\nFor instance, if the entire network is separated into two connected components, and there is at least one more extra cable in either of the components, then what you need to do is to connect one end of that cable to the other component. Does it make sense to you? "
                    },
                    {
                        "username": "ihowaonaro",
                        "content": "Can someone explain why my solution exceeds the time limit even though it is basically the same as most of the expected solutions only that it is a stack based solution and not recursion based\n\n `\ndef makeConnected(self, n: int, connections: List[List[int]]) -> int:\n        if len(connections) < n - 1:\n            return -1\n\n        noOfComponents = 0\n        visited = [False for _ in range(n)]\n        edgeMap = defaultdict(set)\n        \n        for node1, node2 in connections:\n            edgeMap[node1].add(node2)\n            edgeMap[node2].add(node1)\n\n        for i in range(n):\n            if not visited[i]:\n                noOfComponents += 1\n            \n                stack = deque([i])\n                while stack:\n                    node = stack.popleft()\n                    visited[node] = True\n\n                    for neighbour in edgeMap[node]:\n                        if not visited[neighbour]:\n                            stack.append(neighbour)\n\n        return noOfComponents - 1\n`"
                    },
                    {
                        "username": "Deep74",
                        "content": "class Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connection) {\\n\\n           if(connection.size()<n-1){\\n               return -1;\\n           }\\n        vector<vector<int>>v(n,vector<int>(n));\\n        \\n        for(int i=0;i<connection.size();i++){\\n            int a=connection[i][0];\\n            int b=connection[i][1];\\n            v[a].push_back(b);\\n           v[b].push_back(a);\\n             \\n        }\\n     int ans=0;\\n            vector<int>mp(n,0);     queue<int>q;\\n     for(int i=0;i<n;i++){\\n\\n     \\n         if(mp[i]==0){\\n             ans++;\\n         q.push(i);\\n\\n         while(!q.empty()){\\n                          mp[q.front()]++;\\n            \\n             for(int j=0;j<v[q.front()].size();j++){\\n                 if(mp[v[q.front()][j]]==0){\\n                  \\n\\n                     //mp[q.front()]++;\\n                     // mp[j]++;\\n                      q.push(v[q.front()][j]);\\n\\n                 }\\n             \\n             \\n              }\\n              \\n                  q.pop();\\n         }\\n\\n         }\\n\\n         \\n     } return ans-1;\\n\\n    }\\n};       \\n\\ncan anyone explain why this code is giving tle  on larger testcase (n=10000)"
                    },
                    {
                        "username": "iw33209jfdcifidfj93",
                        "content": "Bhaiyo easy hai bs itna jaan lo .... no. of disconnected networks nikal lo ....no. of cycles count kr lo fir in dono ke relation se ans bna daalo aur LIKE thoko"
                    }
                ]
            },
            {
                "id": 1840999,
                "content": [
                    {
                        "username": "Saitima",
                        "content": "Leet\\'s love for graph is back"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n1. Check if it is possible to connect all the computers in the network:\\n     - We need at least n-1 wires to connect all n computers in the network.\\n     - If the number of wires given is less than n-1, it is impossible to connect all the computers. In this case, we can return -1.\\n\\n2. Create a graph to represent the network:\\n    - Each computer is a node in the graph.\\n    - Each wire is an edge between two nodes.\\n    - We can use an adjacency list to represent the edges of each node.\\n\\n3. Use DFS to count the number of connected components:\\n    - A connected component is a group of nodes that are connected to each other by some path.\\n    - We can start the DFS algorithm from each unvisited node in the graph.\\n    - We visit all its neighbors, mark them as visited, and then recursively visit all the neighbors of the visited neighbors until we have visited all the nodes in the connected component.\\n    - We keep track of the number of connected components we have visited, which is equal to the minimum number of wires we need to add to connect all the computers in the network.\\n\\n4. Return the minimum number of wires we need to add:\\n    - The minimum number of wires we need to add is equal to the number of connected components minus one.\\n    - We subtract one because we can connect all the connected components with just one wire."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link:-)***\\nhttps://leetcode.com/problems/number-of-operations-to-make-network-connected/solutions/3330899/easiest-solution/"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Approach is so simple you will laugh on yourself after finding out\\n\\nTip: just run dfs without checking anything except visited."
                    },
                    {
                        "username": "ayush_verma_007",
                        "content": "Hii to Graphs Again. this week\\'s gonna be good"
                    },
                    {
                        "username": "lavanyapareek",
                        "content": "Merge > Make components > return number of components - 1."
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "Graph week, here we go :))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "What I understand is to remove the cables from a network G (G should be disconnected)   and connect them to a connected network. If the number of cables is e, and the total number of computers is n, such as e<n-1, there must be no solution, because the cables are not enough. \n\nSuppose that G consists of  several connected components G_i.  Each connected components G_i has a spanning tree, say T_i. The removable cables are in some of G_i\\T_i.\n\nIf wrong, please correct me."
                    },
                    {
                        "username": "manifold1985",
                        "content": "[@anwendeng](/anwendeng) Exactly. Reference to the three examples below the problem statement: all of them are disconnected."
                    },
                    {
                        "username": "manifold1985",
                        "content": "\"You can extract certain cables between two directly connected computers, and place them between any pair of disconnected computers to make them directly connected.\"\\n\\n\"Return the minimum number of times you need to do this in order to make all the computers connected. \"\\n\\nAccording to the description above, it doesn\\'t have to do with the spanning tree; instead, you need to determine how little you need to reconnect the computers to make the entire network connected. \\n\\nFor instance, if the entire network is separated into two connected components, and there is at least one more extra cable in either of the components, then what you need to do is to connect one end of that cable to the other component. Does it make sense to you? "
                    },
                    {
                        "username": "ihowaonaro",
                        "content": "Can someone explain why my solution exceeds the time limit even though it is basically the same as most of the expected solutions only that it is a stack based solution and not recursion based\n\n `\ndef makeConnected(self, n: int, connections: List[List[int]]) -> int:\n        if len(connections) < n - 1:\n            return -1\n\n        noOfComponents = 0\n        visited = [False for _ in range(n)]\n        edgeMap = defaultdict(set)\n        \n        for node1, node2 in connections:\n            edgeMap[node1].add(node2)\n            edgeMap[node2].add(node1)\n\n        for i in range(n):\n            if not visited[i]:\n                noOfComponents += 1\n            \n                stack = deque([i])\n                while stack:\n                    node = stack.popleft()\n                    visited[node] = True\n\n                    for neighbour in edgeMap[node]:\n                        if not visited[neighbour]:\n                            stack.append(neighbour)\n\n        return noOfComponents - 1\n`"
                    },
                    {
                        "username": "Deep74",
                        "content": "class Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connection) {\\n\\n           if(connection.size()<n-1){\\n               return -1;\\n           }\\n        vector<vector<int>>v(n,vector<int>(n));\\n        \\n        for(int i=0;i<connection.size();i++){\\n            int a=connection[i][0];\\n            int b=connection[i][1];\\n            v[a].push_back(b);\\n           v[b].push_back(a);\\n             \\n        }\\n     int ans=0;\\n            vector<int>mp(n,0);     queue<int>q;\\n     for(int i=0;i<n;i++){\\n\\n     \\n         if(mp[i]==0){\\n             ans++;\\n         q.push(i);\\n\\n         while(!q.empty()){\\n                          mp[q.front()]++;\\n            \\n             for(int j=0;j<v[q.front()].size();j++){\\n                 if(mp[v[q.front()][j]]==0){\\n                  \\n\\n                     //mp[q.front()]++;\\n                     // mp[j]++;\\n                      q.push(v[q.front()][j]);\\n\\n                 }\\n             \\n             \\n              }\\n              \\n                  q.pop();\\n         }\\n\\n         }\\n\\n         \\n     } return ans-1;\\n\\n    }\\n};       \\n\\ncan anyone explain why this code is giving tle  on larger testcase (n=10000)"
                    },
                    {
                        "username": "iw33209jfdcifidfj93",
                        "content": "Bhaiyo easy hai bs itna jaan lo .... no. of disconnected networks nikal lo ....no. of cycles count kr lo fir in dono ke relation se ans bna daalo aur LIKE thoko"
                    }
                ]
            },
            {
                "id": 1840955,
                "content": [
                    {
                        "username": "Saitima",
                        "content": "Leet\\'s love for graph is back"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n1. Check if it is possible to connect all the computers in the network:\\n     - We need at least n-1 wires to connect all n computers in the network.\\n     - If the number of wires given is less than n-1, it is impossible to connect all the computers. In this case, we can return -1.\\n\\n2. Create a graph to represent the network:\\n    - Each computer is a node in the graph.\\n    - Each wire is an edge between two nodes.\\n    - We can use an adjacency list to represent the edges of each node.\\n\\n3. Use DFS to count the number of connected components:\\n    - A connected component is a group of nodes that are connected to each other by some path.\\n    - We can start the DFS algorithm from each unvisited node in the graph.\\n    - We visit all its neighbors, mark them as visited, and then recursively visit all the neighbors of the visited neighbors until we have visited all the nodes in the connected component.\\n    - We keep track of the number of connected components we have visited, which is equal to the minimum number of wires we need to add to connect all the computers in the network.\\n\\n4. Return the minimum number of wires we need to add:\\n    - The minimum number of wires we need to add is equal to the number of connected components minus one.\\n    - We subtract one because we can connect all the connected components with just one wire."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link:-)***\\nhttps://leetcode.com/problems/number-of-operations-to-make-network-connected/solutions/3330899/easiest-solution/"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Approach is so simple you will laugh on yourself after finding out\\n\\nTip: just run dfs without checking anything except visited."
                    },
                    {
                        "username": "ayush_verma_007",
                        "content": "Hii to Graphs Again. this week\\'s gonna be good"
                    },
                    {
                        "username": "lavanyapareek",
                        "content": "Merge > Make components > return number of components - 1."
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "Graph week, here we go :))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "What I understand is to remove the cables from a network G (G should be disconnected)   and connect them to a connected network. If the number of cables is e, and the total number of computers is n, such as e<n-1, there must be no solution, because the cables are not enough. \n\nSuppose that G consists of  several connected components G_i.  Each connected components G_i has a spanning tree, say T_i. The removable cables are in some of G_i\\T_i.\n\nIf wrong, please correct me."
                    },
                    {
                        "username": "manifold1985",
                        "content": "[@anwendeng](/anwendeng) Exactly. Reference to the three examples below the problem statement: all of them are disconnected."
                    },
                    {
                        "username": "manifold1985",
                        "content": "\"You can extract certain cables between two directly connected computers, and place them between any pair of disconnected computers to make them directly connected.\"\\n\\n\"Return the minimum number of times you need to do this in order to make all the computers connected. \"\\n\\nAccording to the description above, it doesn\\'t have to do with the spanning tree; instead, you need to determine how little you need to reconnect the computers to make the entire network connected. \\n\\nFor instance, if the entire network is separated into two connected components, and there is at least one more extra cable in either of the components, then what you need to do is to connect one end of that cable to the other component. Does it make sense to you? "
                    },
                    {
                        "username": "ihowaonaro",
                        "content": "Can someone explain why my solution exceeds the time limit even though it is basically the same as most of the expected solutions only that it is a stack based solution and not recursion based\n\n `\ndef makeConnected(self, n: int, connections: List[List[int]]) -> int:\n        if len(connections) < n - 1:\n            return -1\n\n        noOfComponents = 0\n        visited = [False for _ in range(n)]\n        edgeMap = defaultdict(set)\n        \n        for node1, node2 in connections:\n            edgeMap[node1].add(node2)\n            edgeMap[node2].add(node1)\n\n        for i in range(n):\n            if not visited[i]:\n                noOfComponents += 1\n            \n                stack = deque([i])\n                while stack:\n                    node = stack.popleft()\n                    visited[node] = True\n\n                    for neighbour in edgeMap[node]:\n                        if not visited[neighbour]:\n                            stack.append(neighbour)\n\n        return noOfComponents - 1\n`"
                    },
                    {
                        "username": "Deep74",
                        "content": "class Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connection) {\\n\\n           if(connection.size()<n-1){\\n               return -1;\\n           }\\n        vector<vector<int>>v(n,vector<int>(n));\\n        \\n        for(int i=0;i<connection.size();i++){\\n            int a=connection[i][0];\\n            int b=connection[i][1];\\n            v[a].push_back(b);\\n           v[b].push_back(a);\\n             \\n        }\\n     int ans=0;\\n            vector<int>mp(n,0);     queue<int>q;\\n     for(int i=0;i<n;i++){\\n\\n     \\n         if(mp[i]==0){\\n             ans++;\\n         q.push(i);\\n\\n         while(!q.empty()){\\n                          mp[q.front()]++;\\n            \\n             for(int j=0;j<v[q.front()].size();j++){\\n                 if(mp[v[q.front()][j]]==0){\\n                  \\n\\n                     //mp[q.front()]++;\\n                     // mp[j]++;\\n                      q.push(v[q.front()][j]);\\n\\n                 }\\n             \\n             \\n              }\\n              \\n                  q.pop();\\n         }\\n\\n         }\\n\\n         \\n     } return ans-1;\\n\\n    }\\n};       \\n\\ncan anyone explain why this code is giving tle  on larger testcase (n=10000)"
                    },
                    {
                        "username": "iw33209jfdcifidfj93",
                        "content": "Bhaiyo easy hai bs itna jaan lo .... no. of disconnected networks nikal lo ....no. of cycles count kr lo fir in dono ke relation se ans bna daalo aur LIKE thoko"
                    }
                ]
            },
            {
                "id": 1840948,
                "content": [
                    {
                        "username": "Saitima",
                        "content": "Leet\\'s love for graph is back"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n1. Check if it is possible to connect all the computers in the network:\\n     - We need at least n-1 wires to connect all n computers in the network.\\n     - If the number of wires given is less than n-1, it is impossible to connect all the computers. In this case, we can return -1.\\n\\n2. Create a graph to represent the network:\\n    - Each computer is a node in the graph.\\n    - Each wire is an edge between two nodes.\\n    - We can use an adjacency list to represent the edges of each node.\\n\\n3. Use DFS to count the number of connected components:\\n    - A connected component is a group of nodes that are connected to each other by some path.\\n    - We can start the DFS algorithm from each unvisited node in the graph.\\n    - We visit all its neighbors, mark them as visited, and then recursively visit all the neighbors of the visited neighbors until we have visited all the nodes in the connected component.\\n    - We keep track of the number of connected components we have visited, which is equal to the minimum number of wires we need to add to connect all the computers in the network.\\n\\n4. Return the minimum number of wires we need to add:\\n    - The minimum number of wires we need to add is equal to the number of connected components minus one.\\n    - We subtract one because we can connect all the connected components with just one wire."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link:-)***\\nhttps://leetcode.com/problems/number-of-operations-to-make-network-connected/solutions/3330899/easiest-solution/"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Approach is so simple you will laugh on yourself after finding out\\n\\nTip: just run dfs without checking anything except visited."
                    },
                    {
                        "username": "ayush_verma_007",
                        "content": "Hii to Graphs Again. this week\\'s gonna be good"
                    },
                    {
                        "username": "lavanyapareek",
                        "content": "Merge > Make components > return number of components - 1."
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "Graph week, here we go :))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "What I understand is to remove the cables from a network G (G should be disconnected)   and connect them to a connected network. If the number of cables is e, and the total number of computers is n, such as e<n-1, there must be no solution, because the cables are not enough. \n\nSuppose that G consists of  several connected components G_i.  Each connected components G_i has a spanning tree, say T_i. The removable cables are in some of G_i\\T_i.\n\nIf wrong, please correct me."
                    },
                    {
                        "username": "manifold1985",
                        "content": "[@anwendeng](/anwendeng) Exactly. Reference to the three examples below the problem statement: all of them are disconnected."
                    },
                    {
                        "username": "manifold1985",
                        "content": "\"You can extract certain cables between two directly connected computers, and place them between any pair of disconnected computers to make them directly connected.\"\\n\\n\"Return the minimum number of times you need to do this in order to make all the computers connected. \"\\n\\nAccording to the description above, it doesn\\'t have to do with the spanning tree; instead, you need to determine how little you need to reconnect the computers to make the entire network connected. \\n\\nFor instance, if the entire network is separated into two connected components, and there is at least one more extra cable in either of the components, then what you need to do is to connect one end of that cable to the other component. Does it make sense to you? "
                    },
                    {
                        "username": "ihowaonaro",
                        "content": "Can someone explain why my solution exceeds the time limit even though it is basically the same as most of the expected solutions only that it is a stack based solution and not recursion based\n\n `\ndef makeConnected(self, n: int, connections: List[List[int]]) -> int:\n        if len(connections) < n - 1:\n            return -1\n\n        noOfComponents = 0\n        visited = [False for _ in range(n)]\n        edgeMap = defaultdict(set)\n        \n        for node1, node2 in connections:\n            edgeMap[node1].add(node2)\n            edgeMap[node2].add(node1)\n\n        for i in range(n):\n            if not visited[i]:\n                noOfComponents += 1\n            \n                stack = deque([i])\n                while stack:\n                    node = stack.popleft()\n                    visited[node] = True\n\n                    for neighbour in edgeMap[node]:\n                        if not visited[neighbour]:\n                            stack.append(neighbour)\n\n        return noOfComponents - 1\n`"
                    },
                    {
                        "username": "Deep74",
                        "content": "class Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connection) {\\n\\n           if(connection.size()<n-1){\\n               return -1;\\n           }\\n        vector<vector<int>>v(n,vector<int>(n));\\n        \\n        for(int i=0;i<connection.size();i++){\\n            int a=connection[i][0];\\n            int b=connection[i][1];\\n            v[a].push_back(b);\\n           v[b].push_back(a);\\n             \\n        }\\n     int ans=0;\\n            vector<int>mp(n,0);     queue<int>q;\\n     for(int i=0;i<n;i++){\\n\\n     \\n         if(mp[i]==0){\\n             ans++;\\n         q.push(i);\\n\\n         while(!q.empty()){\\n                          mp[q.front()]++;\\n            \\n             for(int j=0;j<v[q.front()].size();j++){\\n                 if(mp[v[q.front()][j]]==0){\\n                  \\n\\n                     //mp[q.front()]++;\\n                     // mp[j]++;\\n                      q.push(v[q.front()][j]);\\n\\n                 }\\n             \\n             \\n              }\\n              \\n                  q.pop();\\n         }\\n\\n         }\\n\\n         \\n     } return ans-1;\\n\\n    }\\n};       \\n\\ncan anyone explain why this code is giving tle  on larger testcase (n=10000)"
                    },
                    {
                        "username": "iw33209jfdcifidfj93",
                        "content": "Bhaiyo easy hai bs itna jaan lo .... no. of disconnected networks nikal lo ....no. of cycles count kr lo fir in dono ke relation se ans bna daalo aur LIKE thoko"
                    }
                ]
            },
            {
                "id": 1743175,
                "content": [
                    {
                        "username": "Saitima",
                        "content": "Leet\\'s love for graph is back"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n1. Check if it is possible to connect all the computers in the network:\\n     - We need at least n-1 wires to connect all n computers in the network.\\n     - If the number of wires given is less than n-1, it is impossible to connect all the computers. In this case, we can return -1.\\n\\n2. Create a graph to represent the network:\\n    - Each computer is a node in the graph.\\n    - Each wire is an edge between two nodes.\\n    - We can use an adjacency list to represent the edges of each node.\\n\\n3. Use DFS to count the number of connected components:\\n    - A connected component is a group of nodes that are connected to each other by some path.\\n    - We can start the DFS algorithm from each unvisited node in the graph.\\n    - We visit all its neighbors, mark them as visited, and then recursively visit all the neighbors of the visited neighbors until we have visited all the nodes in the connected component.\\n    - We keep track of the number of connected components we have visited, which is equal to the minimum number of wires we need to add to connect all the computers in the network.\\n\\n4. Return the minimum number of wires we need to add:\\n    - The minimum number of wires we need to add is equal to the number of connected components minus one.\\n    - We subtract one because we can connect all the connected components with just one wire."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link:-)***\\nhttps://leetcode.com/problems/number-of-operations-to-make-network-connected/solutions/3330899/easiest-solution/"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Approach is so simple you will laugh on yourself after finding out\\n\\nTip: just run dfs without checking anything except visited."
                    },
                    {
                        "username": "ayush_verma_007",
                        "content": "Hii to Graphs Again. this week\\'s gonna be good"
                    },
                    {
                        "username": "lavanyapareek",
                        "content": "Merge > Make components > return number of components - 1."
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "Graph week, here we go :))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "What I understand is to remove the cables from a network G (G should be disconnected)   and connect them to a connected network. If the number of cables is e, and the total number of computers is n, such as e<n-1, there must be no solution, because the cables are not enough. \n\nSuppose that G consists of  several connected components G_i.  Each connected components G_i has a spanning tree, say T_i. The removable cables are in some of G_i\\T_i.\n\nIf wrong, please correct me."
                    },
                    {
                        "username": "manifold1985",
                        "content": "[@anwendeng](/anwendeng) Exactly. Reference to the three examples below the problem statement: all of them are disconnected."
                    },
                    {
                        "username": "manifold1985",
                        "content": "\"You can extract certain cables between two directly connected computers, and place them between any pair of disconnected computers to make them directly connected.\"\\n\\n\"Return the minimum number of times you need to do this in order to make all the computers connected. \"\\n\\nAccording to the description above, it doesn\\'t have to do with the spanning tree; instead, you need to determine how little you need to reconnect the computers to make the entire network connected. \\n\\nFor instance, if the entire network is separated into two connected components, and there is at least one more extra cable in either of the components, then what you need to do is to connect one end of that cable to the other component. Does it make sense to you? "
                    },
                    {
                        "username": "ihowaonaro",
                        "content": "Can someone explain why my solution exceeds the time limit even though it is basically the same as most of the expected solutions only that it is a stack based solution and not recursion based\n\n `\ndef makeConnected(self, n: int, connections: List[List[int]]) -> int:\n        if len(connections) < n - 1:\n            return -1\n\n        noOfComponents = 0\n        visited = [False for _ in range(n)]\n        edgeMap = defaultdict(set)\n        \n        for node1, node2 in connections:\n            edgeMap[node1].add(node2)\n            edgeMap[node2].add(node1)\n\n        for i in range(n):\n            if not visited[i]:\n                noOfComponents += 1\n            \n                stack = deque([i])\n                while stack:\n                    node = stack.popleft()\n                    visited[node] = True\n\n                    for neighbour in edgeMap[node]:\n                        if not visited[neighbour]:\n                            stack.append(neighbour)\n\n        return noOfComponents - 1\n`"
                    },
                    {
                        "username": "Deep74",
                        "content": "class Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connection) {\\n\\n           if(connection.size()<n-1){\\n               return -1;\\n           }\\n        vector<vector<int>>v(n,vector<int>(n));\\n        \\n        for(int i=0;i<connection.size();i++){\\n            int a=connection[i][0];\\n            int b=connection[i][1];\\n            v[a].push_back(b);\\n           v[b].push_back(a);\\n             \\n        }\\n     int ans=0;\\n            vector<int>mp(n,0);     queue<int>q;\\n     for(int i=0;i<n;i++){\\n\\n     \\n         if(mp[i]==0){\\n             ans++;\\n         q.push(i);\\n\\n         while(!q.empty()){\\n                          mp[q.front()]++;\\n            \\n             for(int j=0;j<v[q.front()].size();j++){\\n                 if(mp[v[q.front()][j]]==0){\\n                  \\n\\n                     //mp[q.front()]++;\\n                     // mp[j]++;\\n                      q.push(v[q.front()][j]);\\n\\n                 }\\n             \\n             \\n              }\\n              \\n                  q.pop();\\n         }\\n\\n         }\\n\\n         \\n     } return ans-1;\\n\\n    }\\n};       \\n\\ncan anyone explain why this code is giving tle  on larger testcase (n=10000)"
                    },
                    {
                        "username": "iw33209jfdcifidfj93",
                        "content": "Bhaiyo easy hai bs itna jaan lo .... no. of disconnected networks nikal lo ....no. of cycles count kr lo fir in dono ke relation se ans bna daalo aur LIKE thoko"
                    }
                ]
            },
            {
                "id": 1720306,
                "content": [
                    {
                        "username": "Saitima",
                        "content": "Leet\\'s love for graph is back"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n1. Check if it is possible to connect all the computers in the network:\\n     - We need at least n-1 wires to connect all n computers in the network.\\n     - If the number of wires given is less than n-1, it is impossible to connect all the computers. In this case, we can return -1.\\n\\n2. Create a graph to represent the network:\\n    - Each computer is a node in the graph.\\n    - Each wire is an edge between two nodes.\\n    - We can use an adjacency list to represent the edges of each node.\\n\\n3. Use DFS to count the number of connected components:\\n    - A connected component is a group of nodes that are connected to each other by some path.\\n    - We can start the DFS algorithm from each unvisited node in the graph.\\n    - We visit all its neighbors, mark them as visited, and then recursively visit all the neighbors of the visited neighbors until we have visited all the nodes in the connected component.\\n    - We keep track of the number of connected components we have visited, which is equal to the minimum number of wires we need to add to connect all the computers in the network.\\n\\n4. Return the minimum number of wires we need to add:\\n    - The minimum number of wires we need to add is equal to the number of connected components minus one.\\n    - We subtract one because we can connect all the connected components with just one wire."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link:-)***\\nhttps://leetcode.com/problems/number-of-operations-to-make-network-connected/solutions/3330899/easiest-solution/"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Approach is so simple you will laugh on yourself after finding out\\n\\nTip: just run dfs without checking anything except visited."
                    },
                    {
                        "username": "ayush_verma_007",
                        "content": "Hii to Graphs Again. this week\\'s gonna be good"
                    },
                    {
                        "username": "lavanyapareek",
                        "content": "Merge > Make components > return number of components - 1."
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "Graph week, here we go :))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "What I understand is to remove the cables from a network G (G should be disconnected)   and connect them to a connected network. If the number of cables is e, and the total number of computers is n, such as e<n-1, there must be no solution, because the cables are not enough. \n\nSuppose that G consists of  several connected components G_i.  Each connected components G_i has a spanning tree, say T_i. The removable cables are in some of G_i\\T_i.\n\nIf wrong, please correct me."
                    },
                    {
                        "username": "manifold1985",
                        "content": "[@anwendeng](/anwendeng) Exactly. Reference to the three examples below the problem statement: all of them are disconnected."
                    },
                    {
                        "username": "manifold1985",
                        "content": "\"You can extract certain cables between two directly connected computers, and place them between any pair of disconnected computers to make them directly connected.\"\\n\\n\"Return the minimum number of times you need to do this in order to make all the computers connected. \"\\n\\nAccording to the description above, it doesn\\'t have to do with the spanning tree; instead, you need to determine how little you need to reconnect the computers to make the entire network connected. \\n\\nFor instance, if the entire network is separated into two connected components, and there is at least one more extra cable in either of the components, then what you need to do is to connect one end of that cable to the other component. Does it make sense to you? "
                    },
                    {
                        "username": "ihowaonaro",
                        "content": "Can someone explain why my solution exceeds the time limit even though it is basically the same as most of the expected solutions only that it is a stack based solution and not recursion based\n\n `\ndef makeConnected(self, n: int, connections: List[List[int]]) -> int:\n        if len(connections) < n - 1:\n            return -1\n\n        noOfComponents = 0\n        visited = [False for _ in range(n)]\n        edgeMap = defaultdict(set)\n        \n        for node1, node2 in connections:\n            edgeMap[node1].add(node2)\n            edgeMap[node2].add(node1)\n\n        for i in range(n):\n            if not visited[i]:\n                noOfComponents += 1\n            \n                stack = deque([i])\n                while stack:\n                    node = stack.popleft()\n                    visited[node] = True\n\n                    for neighbour in edgeMap[node]:\n                        if not visited[neighbour]:\n                            stack.append(neighbour)\n\n        return noOfComponents - 1\n`"
                    },
                    {
                        "username": "Deep74",
                        "content": "class Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connection) {\\n\\n           if(connection.size()<n-1){\\n               return -1;\\n           }\\n        vector<vector<int>>v(n,vector<int>(n));\\n        \\n        for(int i=0;i<connection.size();i++){\\n            int a=connection[i][0];\\n            int b=connection[i][1];\\n            v[a].push_back(b);\\n           v[b].push_back(a);\\n             \\n        }\\n     int ans=0;\\n            vector<int>mp(n,0);     queue<int>q;\\n     for(int i=0;i<n;i++){\\n\\n     \\n         if(mp[i]==0){\\n             ans++;\\n         q.push(i);\\n\\n         while(!q.empty()){\\n                          mp[q.front()]++;\\n            \\n             for(int j=0;j<v[q.front()].size();j++){\\n                 if(mp[v[q.front()][j]]==0){\\n                  \\n\\n                     //mp[q.front()]++;\\n                     // mp[j]++;\\n                      q.push(v[q.front()][j]);\\n\\n                 }\\n             \\n             \\n              }\\n              \\n                  q.pop();\\n         }\\n\\n         }\\n\\n         \\n     } return ans-1;\\n\\n    }\\n};       \\n\\ncan anyone explain why this code is giving tle  on larger testcase (n=10000)"
                    },
                    {
                        "username": "iw33209jfdcifidfj93",
                        "content": "Bhaiyo easy hai bs itna jaan lo .... no. of disconnected networks nikal lo ....no. of cycles count kr lo fir in dono ke relation se ans bna daalo aur LIKE thoko"
                    }
                ]
            },
            {
                "id": 1858540,
                "content": [
                    {
                        "username": "Saitima",
                        "content": "Leet\\'s love for graph is back"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n1. Check if it is possible to connect all the computers in the network:\\n     - We need at least n-1 wires to connect all n computers in the network.\\n     - If the number of wires given is less than n-1, it is impossible to connect all the computers. In this case, we can return -1.\\n\\n2. Create a graph to represent the network:\\n    - Each computer is a node in the graph.\\n    - Each wire is an edge between two nodes.\\n    - We can use an adjacency list to represent the edges of each node.\\n\\n3. Use DFS to count the number of connected components:\\n    - A connected component is a group of nodes that are connected to each other by some path.\\n    - We can start the DFS algorithm from each unvisited node in the graph.\\n    - We visit all its neighbors, mark them as visited, and then recursively visit all the neighbors of the visited neighbors until we have visited all the nodes in the connected component.\\n    - We keep track of the number of connected components we have visited, which is equal to the minimum number of wires we need to add to connect all the computers in the network.\\n\\n4. Return the minimum number of wires we need to add:\\n    - The minimum number of wires we need to add is equal to the number of connected components minus one.\\n    - We subtract one because we can connect all the connected components with just one wire."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link:-)***\\nhttps://leetcode.com/problems/number-of-operations-to-make-network-connected/solutions/3330899/easiest-solution/"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Approach is so simple you will laugh on yourself after finding out\\n\\nTip: just run dfs without checking anything except visited."
                    },
                    {
                        "username": "ayush_verma_007",
                        "content": "Hii to Graphs Again. this week\\'s gonna be good"
                    },
                    {
                        "username": "lavanyapareek",
                        "content": "Merge > Make components > return number of components - 1."
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "Graph week, here we go :))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "What I understand is to remove the cables from a network G (G should be disconnected)   and connect them to a connected network. If the number of cables is e, and the total number of computers is n, such as e<n-1, there must be no solution, because the cables are not enough. \n\nSuppose that G consists of  several connected components G_i.  Each connected components G_i has a spanning tree, say T_i. The removable cables are in some of G_i\\T_i.\n\nIf wrong, please correct me."
                    },
                    {
                        "username": "manifold1985",
                        "content": "[@anwendeng](/anwendeng) Exactly. Reference to the three examples below the problem statement: all of them are disconnected."
                    },
                    {
                        "username": "manifold1985",
                        "content": "\"You can extract certain cables between two directly connected computers, and place them between any pair of disconnected computers to make them directly connected.\"\\n\\n\"Return the minimum number of times you need to do this in order to make all the computers connected. \"\\n\\nAccording to the description above, it doesn\\'t have to do with the spanning tree; instead, you need to determine how little you need to reconnect the computers to make the entire network connected. \\n\\nFor instance, if the entire network is separated into two connected components, and there is at least one more extra cable in either of the components, then what you need to do is to connect one end of that cable to the other component. Does it make sense to you? "
                    },
                    {
                        "username": "ihowaonaro",
                        "content": "Can someone explain why my solution exceeds the time limit even though it is basically the same as most of the expected solutions only that it is a stack based solution and not recursion based\n\n `\ndef makeConnected(self, n: int, connections: List[List[int]]) -> int:\n        if len(connections) < n - 1:\n            return -1\n\n        noOfComponents = 0\n        visited = [False for _ in range(n)]\n        edgeMap = defaultdict(set)\n        \n        for node1, node2 in connections:\n            edgeMap[node1].add(node2)\n            edgeMap[node2].add(node1)\n\n        for i in range(n):\n            if not visited[i]:\n                noOfComponents += 1\n            \n                stack = deque([i])\n                while stack:\n                    node = stack.popleft()\n                    visited[node] = True\n\n                    for neighbour in edgeMap[node]:\n                        if not visited[neighbour]:\n                            stack.append(neighbour)\n\n        return noOfComponents - 1\n`"
                    },
                    {
                        "username": "Deep74",
                        "content": "class Solution {\\npublic:\\n    int makeConnected(int n, vector<vector<int>>& connection) {\\n\\n           if(connection.size()<n-1){\\n               return -1;\\n           }\\n        vector<vector<int>>v(n,vector<int>(n));\\n        \\n        for(int i=0;i<connection.size();i++){\\n            int a=connection[i][0];\\n            int b=connection[i][1];\\n            v[a].push_back(b);\\n           v[b].push_back(a);\\n             \\n        }\\n     int ans=0;\\n            vector<int>mp(n,0);     queue<int>q;\\n     for(int i=0;i<n;i++){\\n\\n     \\n         if(mp[i]==0){\\n             ans++;\\n         q.push(i);\\n\\n         while(!q.empty()){\\n                          mp[q.front()]++;\\n            \\n             for(int j=0;j<v[q.front()].size();j++){\\n                 if(mp[v[q.front()][j]]==0){\\n                  \\n\\n                     //mp[q.front()]++;\\n                     // mp[j]++;\\n                      q.push(v[q.front()][j]);\\n\\n                 }\\n             \\n             \\n              }\\n              \\n                  q.pop();\\n         }\\n\\n         }\\n\\n         \\n     } return ans-1;\\n\\n    }\\n};       \\n\\ncan anyone explain why this code is giving tle  on larger testcase (n=10000)"
                    },
                    {
                        "username": "iw33209jfdcifidfj93",
                        "content": "Bhaiyo easy hai bs itna jaan lo .... no. of disconnected networks nikal lo ....no. of cycles count kr lo fir in dono ke relation se ans bna daalo aur LIKE thoko"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Distance to Type a Word Using Two Fingers",
        "question_content": "<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/01/02/leetcode_keyboard.png\" style=\"width: 349px; height: 209px;\" />\n<p>You have a keyboard layout as shown above in the <strong>X-Y</strong> plane, where each English uppercase letter is located at some coordinate.</p>\n\n<ul>\n\t<li>For example, the letter <code>&#39;A&#39;</code> is located at coordinate <code>(0, 0)</code>, the letter <code>&#39;B&#39;</code> is located at coordinate <code>(0, 1)</code>, the letter <code>&#39;P&#39;</code> is located at coordinate <code>(2, 3)</code> and the letter <code>&#39;Z&#39;</code> is located at coordinate <code>(4, 1)</code>.</li>\n</ul>\n\n<p>Given the string <code>word</code>, return <em>the minimum total <strong>distance</strong> to type such string using only two fingers</em>.</p>\n\n<p>The <strong>distance</strong> between coordinates <code>(x<sub>1</sub>, y<sub>1</sub>)</code> and <code>(x<sub>2</sub>, y<sub>2</sub>)</code> is <code>|x<sub>1</sub> - x<sub>2</sub>| + |y<sub>1</sub> - y<sub>2</sub>|</code>.</p>\n\n<p><strong>Note</strong> that the initial positions of your two fingers are considered free so do not count towards your total distance, also your two fingers do not have to start at the first letter or the first two letters.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> word = &quot;CAKE&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> Using two fingers, one optimal way to type &quot;CAKE&quot; is: \nFinger 1 on letter &#39;C&#39; -&gt; cost = 0 \nFinger 1 on letter &#39;A&#39; -&gt; cost = Distance from letter &#39;C&#39; to letter &#39;A&#39; = 2 \nFinger 2 on letter &#39;K&#39; -&gt; cost = 0 \nFinger 2 on letter &#39;E&#39; -&gt; cost = Distance from letter &#39;K&#39; to letter &#39;E&#39; = 1 \nTotal distance = 3\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> word = &quot;HAPPY&quot;\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> Using two fingers, one optimal way to type &quot;HAPPY&quot; is:\nFinger 1 on letter &#39;H&#39; -&gt; cost = 0\nFinger 1 on letter &#39;A&#39; -&gt; cost = Distance from letter &#39;H&#39; to letter &#39;A&#39; = 2\nFinger 2 on letter &#39;P&#39; -&gt; cost = 0\nFinger 2 on letter &#39;P&#39; -&gt; cost = Distance from letter &#39;P&#39; to letter &#39;P&#39; = 0\nFinger 1 on letter &#39;Y&#39; -&gt; cost = Distance from letter &#39;A&#39; to letter &#39;Y&#39; = 4\nTotal distance = 6\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= word.length &lt;= 300</code></li>\n\t<li><code>word</code> consists of uppercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 477659,
                "title": "4-dp-solutions",
                "content": "> Update: for the top-down solutions below, I am adding `1` to `dp` to indicate that we processed that branch. Alternatively, you could initialize `dp` with `-1`.\\n\\n#### Top-Down DP\\nWe have two choices - type the next character using either left or right index finger. So, we run DFS to find the minimum cost. Without memoisation, the runtime complexity is O(2 ^ n).\\n\\nThe memoisation dimensions here are quite intuitive - both fingers\\' locations and position in the input string. We have 27 locations for each finger, including the initial \\'hovering\\' state. \\n\\n```cpp\\nint dp[27][27][301] = {[0 ... 26][0 ... 26][0 ... 300] = -1};\\nint cost(char from, char to) {\\n    return from == 26 ? 0 : abs(from / 6 - to / 6) + abs(from % 6 - to % 6);\\n}\\nint minimumDistance(string &word, int pos = 0, char left = 26, char right = 26) {\\n    if (pos >= word.size()) return 0;\\n    if (dp[left][right][pos] == -1) {\\n        auto to = word[pos] - \\'A\\';\\n        dp[left][right][pos] = min(cost(left, to) + minimumDistance(word, pos + 1, to, right),\\n            cost(right, to) + minimumDistance(word, pos + 1, left, to));\\n    }\\n    return dp[left][right][pos];\\n}\\n```\\n**Complexity Analysis**\\n- Time: O(n * 27 ^ m), where m is the number of fingers. Note that this is a very loose upper bound as we won\\'t go through all combinations, as you will see in the next solution.\\n- Memory: O(n * 27 ^ m) for memoisation.\\n#### Optimized Top-Down DP\\nYou can get an intuition that one of two fingers is always located on the previous key. So, we only need to memoise the location of the `other` finger.\\n```cpp\\nint dp[27][301] = {[0 ... 26][0 ... 300] = -1};\\nint cost(char from, char to) {\\n    return from == 26 ? 0 : abs(from / 6 - to / 6) + abs(from % 6 - to % 6);\\n}\\nint minimumDistance(string &word, int pos = 1, char other = 26) {\\n    if (pos >= word.size()) return 0;\\n    if (dp[other][pos] == -1) {\\n        auto to = word[pos] - \\'A\\', last = word[pos - 1] - \\'A\\';\\n        dp[other][pos] = min(cost(last, to) + minimumDistance(word, pos + 1, other),\\n            cost(other, to) + minimumDistance(word, pos + 1, last));\\n    }\\n    return dp[other][pos];\\n}\\n```\\n**Complexity Analysis**\\n- Time: O(n * 27 ^ (m - 1)): where m is the number of fingers.\\n- Memory: O(n * 27 ^ (m- 1)) for memoisation.\\n#### Bottom-Up DP\\nThe first solution above can be easily converted to bottom-up DP. The runtime, however, will be slower, since the top-down solution does not actually go through all combinations of two fingers positions (as we can see from the second solution above).\\n```CPP\\nint cost(char from, char to) {\\n    if (from == 26) return 0;\\n    return abs(from / 6 - to / 6) + abs(from % 6 - to % 6);\\n}\\nint minimumDistance(string word) {\\n    int dp[301][27][27] = {};    \\n    for (int pos = word.size() - 1; pos >= 0; --pos) {\\n        auto to = word[pos] - \\'A\\';\\n        for (int i = 0; i < 27; ++i) {\\n            for (int j = 0; j < 27; ++j) {\\n                dp[pos][i][j] = min(dp[pos + 1][to][i] + cost(j, to), dp[pos + 1][to][j] + cost(i, to));\\n            }\\n        }\\n    }\\n    return dp[0][26][26];\\n}\\n```\\n**Complexity Analysis**\\n- Time: O(n * 27 ^ m): where m is the number of fingers.\\n- Memory: O(n * 27 ^ m) for tabulation.\\n\\n#### Memory-Optimized Bottom-Up DP\\nAs you can see from the solution above, we are only using tabulation for the last character. Therefore, we only need to tabulate for two characters - current and previous. \\n```CPP\\nint cost(char from, char to) {\\n    if (from == 26) return 0;\\n    return abs(from / 6 - to / 6) + abs(from % 6 - to % 6);\\n}\\nint minimumDistance(string word) {\\n    int dp[2][27][27] = {};    \\n    for (int pos = word.size() - 1; pos >= 0; --pos) {\\n        auto to = word[pos] - \\'A\\';\\n        for (int i = 0; i < 27; ++i) {\\n            for (int j = 0; j < 27; ++j) {\\n                dp[pos % 2][i][j] = min(dp[(pos + 1) % 2][to][i] + \\n                    cost(j, to), dp[(pos + 1) % 2][to][j] + cost(i, to));\\n            }\\n        }\\n    }\\n    return dp[0][26][26];\\n}\\n```\\n**Complexity Analysis**\\n- Time: O(n * 27 ^ m): where m is the number of fingers.\\n- Memory: O(27 ^ m) for tabulation.\\n\\n#### The \"Plus\" Solution\\nSolutions 1, 3 and 4 above is how you might approach any DP problem during the interview:\\n- Start with DFS\\n- Add memoisation\\n- Using your top-down solution, come up with a bottom-up one\\n- Optimize memory for the bottom-up solution\\n\\nSolution 2 above uses the specific problem constraint to optimize the runtime. We used the fact that one of the fingers would be always on the previous letter, and only passed the position of the *other* finger. This would be a big plus if you could get such insight during the interview.\\n\\nIntuitively, there should exist a bottom-up version of solution 2, where we can optimize the memory even further than in solution 4 above. I could not, however, easily come up with such solution. The closest I saw here is [Solution 2 in this post by Lee215](https://leetcode.com/problems/minimum-distance-to-type-a-word-using-two-fingers/discuss/477652/JavaC%2B%2BPython-DP-Solution-O(1)-Space).\\n\\nThat solution, however, requires even deeper insight to come up with, yet alone to understand :) Perhaps, we could come up with an easier to understand solution. Please let me know if you have any ideas!",
                "solutionTags": [],
                "code": "```cpp\\nint dp[27][27][301] = {[0 ... 26][0 ... 26][0 ... 300] = -1};\\nint cost(char from, char to) {\\n    return from == 26 ? 0 : abs(from / 6 - to / 6) + abs(from % 6 - to % 6);\\n}\\nint minimumDistance(string &word, int pos = 0, char left = 26, char right = 26) {\\n    if (pos >= word.size()) return 0;\\n    if (dp[left][right][pos] == -1) {\\n        auto to = word[pos] - \\'A\\';\\n        dp[left][right][pos] = min(cost(left, to) + minimumDistance(word, pos + 1, to, right),\\n            cost(right, to) + minimumDistance(word, pos + 1, left, to));\\n    }\\n    return dp[left][right][pos];\\n}\\n```\n```cpp\\nint dp[27][301] = {[0 ... 26][0 ... 300] = -1};\\nint cost(char from, char to) {\\n    return from == 26 ? 0 : abs(from / 6 - to / 6) + abs(from % 6 - to % 6);\\n}\\nint minimumDistance(string &word, int pos = 1, char other = 26) {\\n    if (pos >= word.size()) return 0;\\n    if (dp[other][pos] == -1) {\\n        auto to = word[pos] - \\'A\\', last = word[pos - 1] - \\'A\\';\\n        dp[other][pos] = min(cost(last, to) + minimumDistance(word, pos + 1, other),\\n            cost(other, to) + minimumDistance(word, pos + 1, last));\\n    }\\n    return dp[other][pos];\\n}\\n```\n```CPP\\nint cost(char from, char to) {\\n    if (from == 26) return 0;\\n    return abs(from / 6 - to / 6) + abs(from % 6 - to % 6);\\n}\\nint minimumDistance(string word) {\\n    int dp[301][27][27] = {};    \\n    for (int pos = word.size() - 1; pos >= 0; --pos) {\\n        auto to = word[pos] - \\'A\\';\\n        for (int i = 0; i < 27; ++i) {\\n            for (int j = 0; j < 27; ++j) {\\n                dp[pos][i][j] = min(dp[pos + 1][to][i] + cost(j, to), dp[pos + 1][to][j] + cost(i, to));\\n            }\\n        }\\n    }\\n    return dp[0][26][26];\\n}\\n```\n```CPP\\nint cost(char from, char to) {\\n    if (from == 26) return 0;\\n    return abs(from / 6 - to / 6) + abs(from % 6 - to % 6);\\n}\\nint minimumDistance(string word) {\\n    int dp[2][27][27] = {};    \\n    for (int pos = word.size() - 1; pos >= 0; --pos) {\\n        auto to = word[pos] - \\'A\\';\\n        for (int i = 0; i < 27; ++i) {\\n            for (int j = 0; j < 27; ++j) {\\n                dp[pos % 2][i][j] = min(dp[(pos + 1) % 2][to][i] + \\n                    cost(j, to), dp[(pos + 1) % 2][to][j] + cost(i, to));\\n            }\\n        }\\n    }\\n    return dp[0][26][26];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 477652,
                "title": "java-c-python-1d-dp-o-1-space",
                "content": "## **Solution 1: 2D DP**\\n1. Initial the position of two fingers as `(0,0)`.\\n2. Iterate the input sttring and track the position of two fingers after tap the last character.\\n3. `dp[a,b]` means with one finger at `a` and the other at postion `b`,\\nthe minimum distance we need is `dp[a, b]`.\\n4. `d(a, b)` return the distance moving from `a` to `b`. Also if `a = 0` we return `0`.\\n<br>\\n\\n## **Complexity**\\nTime `O(N)`\\nSpace `O(1)`\\n<br>\\n\\n**Python:**\\n```python\\n    def minimumDistance(self, A):\\n        def d(a, b):\\n            return a and abs(a / 6 - b / 6) + abs(a % 6 - b % 6)\\n\\n        dp, dp2 = {(0, 0): 0}, {}\\n        for c in (ord(c) + 1 for c in A):\\n            for a, b in dp:\\n                dp2[c, b] = min(dp2.get((c, b), 3000), dp[a, b] + d(a, c))\\n                dp2[a, c] = min(dp2.get((a, c), 3000), dp[a, b] + d(b, c))\\n            dp, dp2 = dp2, {}\\n        return min(dp.values())\\n```\\n<br>\\n\\n## **Solution 2: 1D DP**\\n3 dimensions is absolutely super easy to understand.\\nThough for me is not easy to write (hate to brackets).\\n\\n2 dimension dynamic programming is a good optimisation and not hard to come up with.\\nBy 2 dimension, I mean to recorde the positions of both fingers.\\n\\nBut either 2D or 3D, We actually don\\'t really need at all.\\nWe only need to record the position of the left finger.\\n\\nOne important observation is that,\\nout right finger will always stay at `A[i - 1]` after the last move.\\n\\nThis is key idea that I want to express in this solution.\\n<br>\\n\\n\\n## **Explanation**\\nImagine that we tap all letters with only one finger.\\nThe `res` distance we get is the maximum distance we will need.\\n\\nIn our dynamic programming, `dp[a]` means that,\\nif our left finger ends at character `a`,\\nthe maximum we can save is `dp[a]`.\\n\\n\\nNow our right finger tapped all letters, and left finger did nothing.\\nWe iterate through the whole string one by one\\nand select some letter to tap with the left finger.\\nBy doing this, we want to find out the maximum distance that we can save from the tapping with one finger.\\n\\nAssume that our left finger is at `a` now,\\nour right finger is at `b`,\\nand we the right finger will tap `c` next.\\n\\nInstead of moving right finger from `b` to `c` with distance `d(b, c)`,\\nwe try moving left finger from `a` to `c` with distance `d(a, c)`.\\nHopely this will save `d(b, c) - d(a, c)`.\\n\\nAnd finaly, we have one fingers at `b` and the other at `c` now.\\nThe finger at `b` will be new left finger, and the other will be the rihgt.\\n<br>\\n\\n**Java**\\n```java\\n    public int minimumDistance(String word) {\\n        int dp[] = new int[26], res = 0, save = 0, n = word.length();\\n        for (int i = 0; i < n - 1; ++i) {\\n            int b = word.charAt(i) - \\'A\\', c = word.charAt(i + 1) - \\'A\\';\\n            for (int a = 0; a < 26; ++a)\\n                dp[b] = Math.max(dp[b], dp[a] + d(b, c) - d(a, c));\\n            save = Math.max(save, dp[b]);\\n            res += d(b, c);\\n        }\\n        return res - save;\\n\\n    }\\n\\n    private int d(int a, int b) {\\n        return Math.abs(a / 6 - b / 6) + Math.abs(a % 6 - b % 6);\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int minimumDistance(string word) {\\n        vector<int> dp(26);\\n        int res = 0, save = 0, n = word.size();\\n        for (int i = 0; i < n - 1; ++i) {\\n            int b = word[i] - \\'A\\', c = word[i + 1] - \\'A\\';\\n            for (int a = 0; a < 26; ++a)\\n                dp[b] = max(dp[b], dp[a] + d(b, c) - d(a, c));\\n            save = max(save, dp[b]);\\n            res += d(b, c);\\n        }\\n        return res - save;\\n    }\\n\\n    int d(int a, int b) {\\n        return abs(a / 6 - b / 6) + abs(a % 6 - b % 6);\\n    }\\n```\\n\\n**Python**\\nThe following Python solution takes `O(N)`space actually,\\nbut I\\'d like to keep it simple now.\\n```py\\n    def minimumDistance(self, A):\\n        def d(a, b):\\n            return abs(a / 6 - b / 6) + abs(a % 6 - b % 6)\\n        A = [ord(c) - 65 for c in A]\\n        dp = [0] * 26\\n        for b, c in zip(A, A[1:]):\\n            dp[b] = max(dp[a] + d(b, c) - d(a, c) for a in xrange(26))\\n        return sum(d(b, c) for b, c in zip(A, A[1:])) - max(dp)\\n```\\n<br>\\n\\n\\n## **Intuition**\\nPeople keep asking me how I think when solve the problem.\\nThis one of the hardest question that I come across.\\nIt\\'s always the part I try to fill in every my post.\\nThat is also one of reason it worth being upvoted for:\\nI really try to explain the idea well (though it\\'s not always easy and people help me).\\n\\nHonestly, doing same-looking prolems doesn\\'t help im my case at all.\\nActually I want to say that use the imagination.\\nThis problem is good chance to explain.\\n(Well, practice does make perfect. I hope after one year I do improve in writing my posts.)\\n<br>\\n\\n## **Better Explantion with Imagination**\\nAs in this problem, I imagine it as a problem of **linked list**:\\n\\nEach node has a character as ite value.\\nThe distance between two linked node is same as descriped in the statament.\\n\\nNow we are given a linked list, we want split the it into two linked list,\\nbut keep the order of nodes in each list as it in the original input.\\n\\nSo we need split some nodes from the original long linked list,\\nand like them into the other one.\\n`dp[a]` means that the last node in the second list has value `a` and save distance `dp[a]`.\\n\\nIn my solution, I initialized a dummy node on the left first.\\nThen iterate the long linked list one by one.\\n\\nAssume the short linked list is `xxxa` and the long linked list is `xxxxbcxxxxx`.\\nWe try cutting the link between `b` and `c`, and link it the short one.\\nNow we have `xxxacxxxxxx` and `xxxxb`.\\nWe compare the distance we save `d(b, c) - d(a, c)`.\\nNote that `xxxxb` become the second linked list now,\\nsince we think the first one always has the tail of input.\\n\\nFinally,\\nWe compare the distance we save\\nand update it to `dp[b] = max(dp[b], dp[a] + d(b, c) - d(a, c))`.\\n\\nThat is it.\\n<br>",
                "solutionTags": [],
                "code": "```python\\n    def minimumDistance(self, A):\\n        def d(a, b):\\n            return a and abs(a / 6 - b / 6) + abs(a % 6 - b % 6)\\n\\n        dp, dp2 = {(0, 0): 0}, {}\\n        for c in (ord(c) + 1 for c in A):\\n            for a, b in dp:\\n                dp2[c, b] = min(dp2.get((c, b), 3000), dp[a, b] + d(a, c))\\n                dp2[a, c] = min(dp2.get((a, c), 3000), dp[a, b] + d(b, c))\\n            dp, dp2 = dp2, {}\\n        return min(dp.values())\\n```\n```java\\n    public int minimumDistance(String word) {\\n        int dp[] = new int[26], res = 0, save = 0, n = word.length();\\n        for (int i = 0; i < n - 1; ++i) {\\n            int b = word.charAt(i) - \\'A\\', c = word.charAt(i + 1) - \\'A\\';\\n            for (int a = 0; a < 26; ++a)\\n                dp[b] = Math.max(dp[b], dp[a] + d(b, c) - d(a, c));\\n            save = Math.max(save, dp[b]);\\n            res += d(b, c);\\n        }\\n        return res - save;\\n\\n    }\\n\\n    private int d(int a, int b) {\\n        return Math.abs(a / 6 - b / 6) + Math.abs(a % 6 - b % 6);\\n    }\\n```\n```cpp\\n    int minimumDistance(string word) {\\n        vector<int> dp(26);\\n        int res = 0, save = 0, n = word.size();\\n        for (int i = 0; i < n - 1; ++i) {\\n            int b = word[i] - \\'A\\', c = word[i + 1] - \\'A\\';\\n            for (int a = 0; a < 26; ++a)\\n                dp[b] = max(dp[b], dp[a] + d(b, c) - d(a, c));\\n            save = max(save, dp[b]);\\n            res += d(b, c);\\n        }\\n        return res - save;\\n    }\\n\\n    int d(int a, int b) {\\n        return abs(a / 6 - b / 6) + abs(a % 6 - b % 6);\\n    }\\n```\n```py\\n    def minimumDistance(self, A):\\n        def d(a, b):\\n            return abs(a / 6 - b / 6) + abs(a % 6 - b % 6)\\n        A = [ord(c) - 65 for c in A]\\n        dp = [0] * 26\\n        for b, c in zip(A, A[1:]):\\n            dp[b] = max(dp[a] + d(b, c) - d(a, c) for a in xrange(26))\\n        return sum(d(b, c) for b, c in zip(A, A[1:])) - max(dp)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 477762,
                "title": "java-dp-easy-to-understand-with-explanation",
                "content": "We asume a finger is at position ```j``` if ```row*6 + col  =  j```.\\n\\nIf the finger is at position 26, it means the finger has no position yet.\\n\\nLet ```dp[i][j][k]``` be the minimum distance to build the substring from ```word``` from index ```i``` untill the end of the word, given that currently the fingers are on positions ```j``` and ```k``` respectively.\\n\\nThe transition function will be:\\n\\n```dp[i][j][k] = Math.min(dp[i+1][target][k] + distance1,dp[i+1][j][target] + distance2);```\\n\\nWhere ```target``` is the position of the character we are trying to move one of the fingers to, since we are going to move that finger to that new position. ```distance1``` would be the distance from finger 1 to the target position and ```distance2``` would be the distance from finger 2 to the target position.\\n\\nThen all we need to do is return ```dp[0][26][26]```, since both fingers start with no position.\\n\\n```\\nclass Solution {\\n    \\n    public int move(int source, int target){\\n        if(source == 26) return 0;\\n        int y = source / 6;\\n        int x = source % 6;\\n        int y2 = target / 6;\\n        int x2 = target % 6;\\n        return Math.abs(y2-y) + Math.abs(x2-x);\\n    }\\n    \\n    public int minimumDistance(String word) {\\n        int[][][] dp = new int[word.length()+1][27][27];\\n        for(int i=word.length()-1;i>=0;i--){\\n            for(int j=0;j<27;j++){\\n                for(int k=0;k<27;k++){\\n                    int f1move = move(j,word.charAt(i)-\\'A\\');\\n                    int f2move = move(k,word.charAt(i)-\\'A\\');\\n                    dp[i][j][k] = Math.min(dp[i+1][word.charAt(i) - \\'A\\'][k] + f1move,dp[i+1][j][word.charAt(i) - \\'A\\'] + f2move);\\n                }\\n            }  \\n        }\\n\\n        return dp[0][26][26];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```j```\n```row*6 + col  =  j```\n```dp[i][j][k]```\n```word```\n```i```\n```j```\n```k```\n```dp[i][j][k] = Math.min(dp[i+1][target][k] + distance1,dp[i+1][j][target] + distance2);```\n```target```\n```distance1```\n```distance2```\n```dp[0][26][26]```\n```\\nclass Solution {\\n    \\n    public int move(int source, int target){\\n        if(source == 26) return 0;\\n        int y = source / 6;\\n        int x = source % 6;\\n        int y2 = target / 6;\\n        int x2 = target % 6;\\n        return Math.abs(y2-y) + Math.abs(x2-x);\\n    }\\n    \\n    public int minimumDistance(String word) {\\n        int[][][] dp = new int[word.length()+1][27][27];\\n        for(int i=word.length()-1;i>=0;i--){\\n            for(int j=0;j<27;j++){\\n                for(int k=0;k<27;k++){\\n                    int f1move = move(j,word.charAt(i)-\\'A\\');\\n                    int f2move = move(k,word.charAt(i)-\\'A\\');\\n                    dp[i][j][k] = Math.min(dp[i+1][word.charAt(i) - \\'A\\'][k] + f1move,dp[i+1][j][word.charAt(i) - \\'A\\'] + f2move);\\n                }\\n            }  \\n        }\\n\\n        return dp[0][26][26];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477684,
                "title": "python-simple-dp-with-explanation-270-ms-beats-100",
                "content": "**Base case**: When there is only 1 character to type, we only use 1 finger.\\n\\nFor **new case n**, we expand each case n-1 with 2 possibilities\\n* type the new character using finger 1\\n* type the new character using finger 2\\n\\t* if finger 2 is free, no additional distance is added\\n\\n\\n**We can further improve the performance**\\n* there are only 26 possible finger positions.\\n* there are only 26*26 different combinations of finger movements\\n\\n```\\nfrom functools import lru_cache\\nclass Solution:\\n    def minimumDistance(self, A):\\n        \\n        @lru_cache(maxsize=None)\\n        def get_distance(current_pos, next_pos):\\n            if current_pos == -1: return 0\\n            return abs(current_pos // 6 - next_pos // 6) + abs(current_pos % 6 - next_pos % 6)\\n        \\n        @lru_cache(maxsize=None)\\n        def to_num(c):\\n            return ord(c) - ord(\\'A\\')\\n\\n        # key: (i,j) i is the position of the first finger, j is the positino of the second finger\\n        dp = {(to_num(A[0]), -1): 0} # base case, -1 means the second finger is free\\n        for n in [to_num(c) for c in A[1:]]:\\n            new_dp = {}\\n            for (f1, f2), d in dp.items():\\n                new_dp[n, f2] = min(new_dp.get((n, f2), math.inf), d + get_distance(f1, n))\\n                new_dp[f1, n] = min(new_dp.get((f1, n), math.inf), d + get_distance(f2, n))\\n            dp = new_dp\\n            \\n        return min(dp.values())\\n\\t\\t# AC: 270 ms\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nfrom functools import lru_cache\\nclass Solution:\\n    def minimumDistance(self, A):\\n        \\n        @lru_cache(maxsize=None)\\n        def get_distance(current_pos, next_pos):\\n            if current_pos == -1: return 0\\n            return abs(current_pos // 6 - next_pos // 6) + abs(current_pos % 6 - next_pos % 6)\\n        \\n        @lru_cache(maxsize=None)\\n        def to_num(c):\\n            return ord(c) - ord(\\'A\\')\\n\\n        # key: (i,j) i is the position of the first finger, j is the positino of the second finger\\n        dp = {(to_num(A[0]), -1): 0} # base case, -1 means the second finger is free\\n        for n in [to_num(c) for c in A[1:]]:\\n            new_dp = {}\\n            for (f1, f2), d in dp.items():\\n                new_dp[n, f2] = min(new_dp.get((n, f2), math.inf), d + get_distance(f1, n))\\n                new_dp[f1, n] = min(new_dp.get((f1, n), math.inf), d + get_distance(f2, n))\\n            dp = new_dp\\n            \\n        return min(dp.values())\\n\\t\\t# AC: 270 ms\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477654,
                "title": "java-dp-solution-with-detailed-written-video-explanation",
                "content": "Explanation : \\n1. We store using a map of each character for the coordinate on the keyboard\\n2. Key of the memoization will be position of (Finger1, Finger2, Index Position of the word)\\n\\nExtra optimization(not implemented) : Finger1 and Finger2 can be a set to reduce number of repetitive computation as well\\nsince Finger1(x=2,y=3), Finger2(x=5,y=7) will be equivalend as Finger2(x=2,y=3), Finger1(x=5,y=7)\\n\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/h9UH-ZZMy_8\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\\n\\n```\\nclass Solution {\\n    \\n    int distance(int[] f1, int[] f2) {\\n        if(f1 == null || f2 == null) {\\n            return 0;\\n        }\\n        return Math.abs(f1[0] - f2[0]) + Math.abs(f1[1] - f2[1]);\\n    }\\n    \\n    Map<Character, int[]> keyMap = new HashMap<>();\\n    Map<String, Integer> dpCache = new HashMap<>();\\n    \\n    public int minimumDistance(String word) {\\n        char curr = \\'A\\';\\n        for(int i = 0; i < 5; i++) {\\n            for(int j = 0; j < 6; j++) {\\n                keyMap.put(curr, new int[]{i, j});\\n                if(curr == \\'Z\\') break;\\n                curr++;\\n            }\\n        }\\n        return solve(null, null, 0, word);\\n    }\\n    \\n    int solve(int[] f1, int[] f2, int index, String word) {\\n        if(index >= word.length()) return 0;\\n        \\n        String key = Arrays.toString(f1) + \";\" + Arrays.toString(f2) + \";\" + index; \\n        if(dpCache.containsKey(key)) return dpCache.get(key);\\n        int f1Use = distance(f1, keyMap.get(word.charAt(index))) \\n            + solve(keyMap.get(word.charAt(index)), f2, index + 1, word);\\n        int f2Use = distance(f2, keyMap.get(word.charAt(index)))\\n            + solve(f1, keyMap.get(word.charAt(index)), index + 1, word);\\n        int output = Math.min(f1Use, f2Use);\\n        dpCache.put(key, output);\\n        return output;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int distance(int[] f1, int[] f2) {\\n        if(f1 == null || f2 == null) {\\n            return 0;\\n        }\\n        return Math.abs(f1[0] - f2[0]) + Math.abs(f1[1] - f2[1]);\\n    }\\n    \\n    Map<Character, int[]> keyMap = new HashMap<>();\\n    Map<String, Integer> dpCache = new HashMap<>();\\n    \\n    public int minimumDistance(String word) {\\n        char curr = \\'A\\';\\n        for(int i = 0; i < 5; i++) {\\n            for(int j = 0; j < 6; j++) {\\n                keyMap.put(curr, new int[]{i, j});\\n                if(curr == \\'Z\\') break;\\n                curr++;\\n            }\\n        }\\n        return solve(null, null, 0, word);\\n    }\\n    \\n    int solve(int[] f1, int[] f2, int index, String word) {\\n        if(index >= word.length()) return 0;\\n        \\n        String key = Arrays.toString(f1) + \";\" + Arrays.toString(f2) + \";\" + index; \\n        if(dpCache.containsKey(key)) return dpCache.get(key);\\n        int f1Use = distance(f1, keyMap.get(word.charAt(index))) \\n            + solve(keyMap.get(word.charAt(index)), f2, index + 1, word);\\n        int f2Use = distance(f2, keyMap.get(word.charAt(index)))\\n            + solve(f1, keyMap.get(word.charAt(index)), index + 1, word);\\n        int output = Math.min(f1Use, f2Use);\\n        dpCache.put(key, output);\\n        return output;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 483782,
                "title": "detailed-explanation-on-optimizing-a-3d-2d-dp-to-1d",
                "content": "# ***Intuitive enough as a 3D DP***\\n\\nIt is not hard to come up with an intuition to use DP to solve this problem. \\n\\nGiven a string `word`, we can define a *state* the  that `dp[i][j][k]`  represents **the minimum distance to type until `word[k]`, left finger is at char `i` and right finger is at char `j`**. That is, **dim 0 for left finger, and dim 1 for right finger.**\\n\\nThen we can think about how we move our fingers from `word[k-1]` to `word[k]` to keep the minimum value. Intuitively again, we have two options: move left finger or move right finger. \\n\\nIf we move one finger to the target character, we have two simple inferences:\\n\\n1. this finger must be at the corresponding index of `word[k]` (denoted as `idx`) after moving;\\n2. the other finger is at the original place. That\\'s say, for left finger, if we want to move to `dp[idx][j]`, **we can only move from the same column `dp[i][j] for i from \\'A\\' to \\'Z\\'`,** and the same row for right finger\\n\\nTherefore, we have the transition\\n\\n`dp[idx][j][k] = min(dp[i][j][k-1] + dist(i, idx)) for i from \\'A\\' to \\'Z\\'` (`j` is fixed), and\\n`dp[i][idx][k] = min(dp[i][j][k-1] + dist(j, idx)) for j from \\'A\\' to \\'Z\\'` (`i` is fixed)\\n\\nWe can see that `k` is only related to `k-1`, thus we can easily optimize it to a 2D DP, and the following is the code. I append a dummy character at the end to represent a start case, where the distance from it to any other char is 0.\\n\\n\\n```python\\nclass Solution:\\n\\t\\n\\t# This solution gets TLE\\n\\t\\n    def minimumDistance(self, word: str) -> int:\\n        dp = [[float(\\'inf\\')] * 27 for _ in range(27)]\\n        \\n        dp[-1][-1] = 0\\n        \\n        for ch in word:\\n            new_dp = [[float(\\'inf\\')] * 27 for _ in range(27)]\\n            \\n            idx = ord(ch) - ord(\\'A\\')\\n            for j in range(27):\\n                new_dp[idx][j] = min(dp[i][j] + dist(i, idx) for i in range(27))\\n            \\n            for i in range(27):\\n                new_dp[i][idx] = min(dp[i][j] + dist(idx, j) for j in range(27))\\n            \\n            dp = new_dp\\n        \\n        return min(min(row) for row in dp)\\n\\ndef dist(i, j): \\n    if i == 26 or j == 26: # last dummy index\\n        return 0\\n\\n    return abs(i // 6 - j // 6) + abs(i % 6 - j % 6)\\n```\\n\\nHowever, this solution gets TLE...\\n\\n  \\n  \\n  \\n# ***Update only one row and one column but building a matrix?!***\\n\\nHere is the visualization on how the above algorithm works. Every time only the row and the column of the current character has values, and the other place are all `inf`. Why can\\'t we just maintain two lists to represent the transition?\\n\\n![image](https://assets.leetcode.com/users/k_kkkyle/image_1579230434.png)\\n\\n- **What\\'s the transition if we have only two lists**\\n\\nSay we have two lists, `dp_left` and `dp_right`, and the last character was at `prev_idx` and current character is `idx`. Take a look at the figure, and take `dp_left` as example.\\n\\nWe \"move\" the `dp_left` bar from `prev_idx = 26` to `idx = 2` (\"C\"), `dp[idx][j]` should be the minimum value of `dp[i][j] + dist(i, idx)` **along the row `j`**.\\n\\nHowever, we observe that **expect _column_ `prev_idx`, the rest columns have values only at _row_ `prev_idx`**.\\n\\nThat\\'s say, **for all other columns, the new dp value is the prev dp value + the distance between prev index and new index.**\\n\\nAnd for column `prev_idx` , the transtion will be the minimum value + the distance in **the other dp list**.\\n\\nThe code block for this transition is\\n\\n```python\\nd = dist(prev_idx, idx)\\n            \\nleft_min = min(dp_left[i] + dist(i, idx) for i in range(27))\\nright_min = min(dp_right[i] + dist(i, idx) for i in range(27))\\n\\nfor i in range(27):\\n\\tdp_left[i] = dp_left[i] + d if i != prev_idx else right_min\\n\\tdp_right[i] = dp_right[i] + d if i != prev_idx else left_min \\n```\\n\\nAnd the full code is as follows, finally we return the min value in `dp_left` and `dp_right`. \\n\\n```python\\nclass Solution:\\n\\n\\t# This solution takes 196 ms and beats ~95%\\n\\n    def minimumDistance(self, word: str) -> int:\\n        dp_left = [float(\\'inf\\')] * 27\\n        dp_right = [float(\\'inf\\')] * 27\\n        \\n        dp_left[-1] = dp_right[-1] = 0\\n        \\n        prev_idx = 26\\n        for ch in word:\\n            idx = ord(ch) - ord(\\'A\\')\\n            d = dist(prev_idx, idx)\\n            \\n            left_min = min(dp_left[i] + dist(i, idx) for i in range(27))\\n            right_min = min(dp_right[i] + dist(i, idx) for i in range(27))\\n            \\n            for i in range(27):\\n                dp_left[i] = dp_left[i] + d if i != prev_idx else right_min\\n                dp_right[i] = dp_right[i] + d if i != prev_idx else left_min \\n            \\n            dp_left[idx] = dp_right[idx] = min(dp_left[idx], dp_right[idx])\\n            prev_idx = idx\\n\\n        return min(min(dp_left), min(dp_right))         \\n\\t\\t\\ndef dist(i, j): \\n    if i == 26 or j == 26: # last dummy index\\n        return 0\\n\\n    return abs(i // 6 - j // 6) + abs(i % 6 - j % 6)\\n```\\n  \\n  \\n  \\n# ***Two dp lists are the same ?!***\\n\\nIt seems that `dp_left` and `dp_right` are always the same thing, right?\\nI test this on several cases and this is true!\\n\\nAn extremely long arbitrary case\\n\\n\"KXGJRDQYJCDRTJXBHDVFOFFOIWFOWSARMADDJCUYMGIXMHOUTQRLFNUZASNTHJLQKPUYXOXWILI\\nYFFHOKUALPTZWJVHADOXQFGMWTKREBPNOZOLAGSGCPEVCXQWVRMTIGCNARPWXKXAGTJYYZNOW\\nQWJCBCLMUNMZUWYUYHJPMRAUNUJVPEMVNMWYSXTJPRLJNSUYFLBNOOJCVHKHMATKEFPCYDFTB\\nHUFAUQVNVNFJMOJRBFPFDVDPXJXZJJMBSIK\"\\n\\n```\\ndp_left = [545, 502, 567, 518, 577, 524, 646, 555, 504, 505, 576, 583, 505, 538, 533, 518, 547, 530, 500, 557, 548, 519, 600, 511, 561, 506, 800]\\ndp_right = [545, 502, 567, 518, 577, 524, 646, 555, 504, 505, 576, 583, 505, 538, 533, 518, 547, 530, 500, 557, 548, 519, 600, 511, 561, 506, 800]\\n```\\n\\nHere is a simple proof by induction:\\n\\n1. `dp_left` and `dp_right` are the same at base case\\n2. the transition are the same, because the min value of the two lists are identical, and all other values are identical\\n3. thus `dp_left`\\\\_{t + 1} == `dp_right`\\\\_{t + 1} for any t in [0,k]\\n\\nSo finally we come to the simplest solution which you might find in many other solutions, we just merge the two lists as one\\n\\n```python\\n\\n# this solution takes 108ms beats 99%\\n\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        dp = [float(\\'inf\\')] * 27\\n        dp[-1] = 0\\n        \\n        prev_idx = 26\\n        for ch in word:\\n            idx = ord(ch) - ord(\\'A\\')\\n            d = dist(prev_idx, idx)\\n            \\n            mindist = min(dp[i] + dist(i, idx) for i in range(27))\\n            \\n            for i in range(27):\\n                dp[i] = dp[i] + d if i != prev_idx else mindist\\n\\n            prev_idx = idx\\n\\n        return min(dp)        \\n\\ndef dist(i, j): \\n    if i == 26 or j == 26: # last dummy index\\n        return 0\\n\\n    return abs(i // 6 - j // 6) + abs(i % 6 - j % 6)\\n```\\n  \\n  \\n  \\n# ***Change code is simple... but what does it mean?***\\n\\nWe can prove that why two lists are the same, but it\\'s not easy to get an intuition of that. Here is my points for digging into why we can maintain only one dp array to represent two fingers.\\n\\n1. What does the state mean?\\n\\t- It means, if we desired to move to `word[k]`, **the cost of either left finger or right finger**.\\n\\t- We need to explain why the state for two fingers are the same\\n2. two fingers are symmetric\\n\\t- It\\'s intuitive. We can imagine that if two finger are at the same place, then moving either finger are the same.\\n\\t- Then it comes to an inference due to the symmetry: at any time, \\n\\t\\twhen left finger is going to move, the state of right finger\\n\\t\\t is the same as \\n\\t\\twhen right finger is going to move, the state of left finger\\n\\t\\t(I know it\\'s confusing...)\\n\\t- Think about BFS: we start from `(0,0)` (place of left and right fingers) to `[(1, 0), (0,1)]`, where  `[(1, 0), (0,1)]` are the same because of they\\'re symmetric, and moving `(1,0)` to `(2,0)` will be the same as moving `(0,1)` to `(0,2)`... and so on\\n\\t- Thus we can introduce induction again to prove that **for any state left finger is at, right finger should have the same state**\\n\\nThe intuition for this 1D 1-array dp, still, may be not intuitive, it will be great help if someone can give a better explanation!\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n\\t\\n\\t# This solution gets TLE\\n\\t\\n    def minimumDistance(self, word: str) -> int:\\n        dp = [[float(\\'inf\\')] * 27 for _ in range(27)]\\n        \\n        dp[-1][-1] = 0\\n        \\n        for ch in word:\\n            new_dp = [[float(\\'inf\\')] * 27 for _ in range(27)]\\n            \\n            idx = ord(ch) - ord(\\'A\\')\\n            for j in range(27):\\n                new_dp[idx][j] = min(dp[i][j] + dist(i, idx) for i in range(27))\\n            \\n            for i in range(27):\\n                new_dp[i][idx] = min(dp[i][j] + dist(idx, j) for j in range(27))\\n            \\n            dp = new_dp\\n        \\n        return min(min(row) for row in dp)\\n\\ndef dist(i, j): \\n    if i == 26 or j == 26: # last dummy index\\n        return 0\\n\\n    return abs(i // 6 - j // 6) + abs(i % 6 - j % 6)\\n```\n```python\\nd = dist(prev_idx, idx)\\n            \\nleft_min = min(dp_left[i] + dist(i, idx) for i in range(27))\\nright_min = min(dp_right[i] + dist(i, idx) for i in range(27))\\n\\nfor i in range(27):\\n\\tdp_left[i] = dp_left[i] + d if i != prev_idx else right_min\\n\\tdp_right[i] = dp_right[i] + d if i != prev_idx else left_min \\n```\n```python\\nclass Solution:\\n\\n\\t# This solution takes 196 ms and beats ~95%\\n\\n    def minimumDistance(self, word: str) -> int:\\n        dp_left = [float(\\'inf\\')] * 27\\n        dp_right = [float(\\'inf\\')] * 27\\n        \\n        dp_left[-1] = dp_right[-1] = 0\\n        \\n        prev_idx = 26\\n        for ch in word:\\n            idx = ord(ch) - ord(\\'A\\')\\n            d = dist(prev_idx, idx)\\n            \\n            left_min = min(dp_left[i] + dist(i, idx) for i in range(27))\\n            right_min = min(dp_right[i] + dist(i, idx) for i in range(27))\\n            \\n            for i in range(27):\\n                dp_left[i] = dp_left[i] + d if i != prev_idx else right_min\\n                dp_right[i] = dp_right[i] + d if i != prev_idx else left_min \\n            \\n            dp_left[idx] = dp_right[idx] = min(dp_left[idx], dp_right[idx])\\n            prev_idx = idx\\n\\n        return min(min(dp_left), min(dp_right))         \\n\\t\\t\\ndef dist(i, j): \\n    if i == 26 or j == 26: # last dummy index\\n        return 0\\n\\n    return abs(i // 6 - j // 6) + abs(i % 6 - j % 6)\\n```\n```\\ndp_left = [545, 502, 567, 518, 577, 524, 646, 555, 504, 505, 576, 583, 505, 538, 533, 518, 547, 530, 500, 557, 548, 519, 600, 511, 561, 506, 800]\\ndp_right = [545, 502, 567, 518, 577, 524, 646, 555, 504, 505, 576, 583, 505, 538, 533, 518, 547, 530, 500, 557, 548, 519, 600, 511, 561, 506, 800]\\n```\n```python\\n\\n# this solution takes 108ms beats 99%\\n\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        dp = [float(\\'inf\\')] * 27\\n        dp[-1] = 0\\n        \\n        prev_idx = 26\\n        for ch in word:\\n            idx = ord(ch) - ord(\\'A\\')\\n            d = dist(prev_idx, idx)\\n            \\n            mindist = min(dp[i] + dist(i, idx) for i in range(27))\\n            \\n            for i in range(27):\\n                dp[i] = dp[i] + d if i != prev_idx else mindist\\n\\n            prev_idx = idx\\n\\n        return min(dp)        \\n\\ndef dist(i, j): \\n    if i == 26 or j == 26: # last dummy index\\n        return 0\\n\\n    return abs(i // 6 - j // 6) + abs(i % 6 - j % 6)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 560813,
                "title": "straightforward-3-steps-from-simple-tle-dfs-to-ac-dp-solution-with-explanation",
                "content": "First I came up with this brute-force DFS solution:\\n\\nIdea is because we know finger 1 will always start with index 0 of word, we can simply use a for loop to try to compute total costs as if we start finger 2 at index 1, or 2, or 3, ..., until word.length() - 1, and get the min of them.\\n\\naCosts[i - 1] stores the cost for finger 1 to type until index i - 1, we need this cost because we noticed that if we start finger 2 at index i, then finger 1 will have to at least type all chars until index i - 1.\\n\\nEach dfs call will try to use finger 1 to type next char as well as use finger 2 to type next char, and then return min cost between these two.\\n\\n```\\nclass Solution {\\n    public int minimumDistance(String word) {\\n        int[] aCosts = new int[word.length()];\\n        for (int i = 1; i < aCosts.length; i++) aCosts[i] = aCosts[i - 1] + dist(word.charAt(i - 1), word.charAt(i));\\n        int res = Integer.MAX_VALUE;\\n        for (int i = 1; i < word.length(); i++) {\\n            res = Math.min(res, dfs(word.charAt(i - 1), aCosts[i - 1], word.charAt(i), 0, i + 1, word));\\n        }\\n        return res;\\n    }\\n    \\n    private int dfs(char a, int aCost, char b, int bCost, int start, String word) {\\n        if (start == word.length()) return aCost + bCost;\\n        char c = word.charAt(start);\\n        int aDiff = dist(a, c);\\n        int bDiff = dist(b, c);\\n        return Math.min(dfs(c, aCost + aDiff, b, bCost, start + 1, word), dfs(a, aCost, c, bCost + bDiff, start + 1, word));\\n    }\\n    \\n    private int dist(char a, char b) {\\n        int i = a - \\'A\\', j = b - \\'A\\';\\n        return Math.abs(i / 6 - j / 6) + Math.abs(i % 6 - j % 6);\\n    }\\n}\\n```\\n\\nAfter submitting this simple DFS solution, I got TLE as expected, because we are visiting too many overlapped subproblems or in other words too many dfs calls to solve the same subproblem.\\n\\nThe first thought that come to our mind should be using memoization to store results for subproblems so in the consecutive visits to the same subproblem we can just simply return the result.\\n\\nWhat I did here is to first reduce the subproblem variants, or in other words reduce the number of input variables to our dfs call so that we can have more subproblem overlaps.\\n\\n```\\nclass Solution {\\n    public int minimumDistance(String word) {\\n        int[] aCosts = new int[word.length()];\\n        for (int i = 1; i < aCosts.length; i++) aCosts[i] = aCosts[i - 1] + dist(word.charAt(i - 1), word.charAt(i));\\n        int res = Integer.MAX_VALUE;\\n        for (int i = 1; i < word.length(); i++) {\\n            res = Math.min(res, aCosts[i - 1] + dfs(word.charAt(i - 1), word.charAt(i), i + 1, word));\\n        }\\n        return res;\\n    }\\n    \\n    private int dfs(char a, char b, int start, String word) {\\n        if (start == word.length()) return 0;\\n        char c = word.charAt(start);\\n        int aDiff = dist(a, c);\\n        int bDiff = dist(b, c);\\n        return Math.min(aDiff + dfs(c, b, start + 1, word), bDiff + dfs(a, c, start + 1, word));\\n    }\\n    \\n    private int dist(char a, char b) {\\n        int i = a - \\'A\\', j = b - \\'A\\';\\n        return Math.abs(i / 6 - j / 6) + Math.abs(i % 6 - j % 6);\\n    }\\n}\\n```\\n\\nDid you notice now our dfs calls will only depend on 3 input variables? char a, char b, and int start, they correspond to most recently typed char by finger 1, most recently typed char by finger 2, and next starting index we try to process in string word. \\n\\nNow we can just build a 3D array to store all possible combinations from these 3 input variables. char a can be in range from A to Z, char b can be in range from A to Z, int start can be in range from 0 to word.length() - 1, so that our 3D array could be ``int[][][] dp = new int[26][26][word.length()];``.\\n\\n```\\nclass Solution {\\n    public int minimumDistance(String word) {\\n        int[] aCosts = new int[word.length()];\\n        for (int i = 1; i < aCosts.length; i++) aCosts[i] = aCosts[i - 1] + dist(word.charAt(i - 1), word.charAt(i));\\n        int res = Integer.MAX_VALUE;\\n        int[][][] dp = new int[26][26][word.length()];\\n        for (int i = 1; i < word.length(); i++) {\\n            res = Math.min(res, aCosts[i - 1] + dfs(word.charAt(i - 1), word.charAt(i), i + 1, word, dp));\\n        }\\n        return res;\\n    }\\n    \\n    private int dfs(char a, char b, int start, String word, int[][][] dp) {\\n        if (start == word.length()) return 0;\\n        if (dp[a - \\'A\\'][b - \\'A\\'][start] != 0) return dp[a - \\'A\\'][b - \\'A\\'][start];\\n        char c = word.charAt(start);\\n        int aDiff = dist(a, c);\\n        int bDiff = dist(b, c);\\n        int res = Math.min(aDiff + dfs(c, b, start + 1, word, dp), bDiff + dfs(a, c, start + 1, word, dp));\\n        dp[a - \\'A\\'][b - \\'A\\'][start] = res;\\n        return res;\\n    }\\n    \\n    private int dist(char a, char b) {\\n        int i = a - \\'A\\', j = b - \\'A\\';\\n        return Math.abs(i / 6 - j / 6) + Math.abs(i % 6 - j % 6);\\n    }\\n}\\n```\\n\\nBy doing these 3 steps we now have an accepted DP solution! I hope this helps :)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDistance(String word) {\\n        int[] aCosts = new int[word.length()];\\n        for (int i = 1; i < aCosts.length; i++) aCosts[i] = aCosts[i - 1] + dist(word.charAt(i - 1), word.charAt(i));\\n        int res = Integer.MAX_VALUE;\\n        for (int i = 1; i < word.length(); i++) {\\n            res = Math.min(res, dfs(word.charAt(i - 1), aCosts[i - 1], word.charAt(i), 0, i + 1, word));\\n        }\\n        return res;\\n    }\\n    \\n    private int dfs(char a, int aCost, char b, int bCost, int start, String word) {\\n        if (start == word.length()) return aCost + bCost;\\n        char c = word.charAt(start);\\n        int aDiff = dist(a, c);\\n        int bDiff = dist(b, c);\\n        return Math.min(dfs(c, aCost + aDiff, b, bCost, start + 1, word), dfs(a, aCost, c, bCost + bDiff, start + 1, word));\\n    }\\n    \\n    private int dist(char a, char b) {\\n        int i = a - \\'A\\', j = b - \\'A\\';\\n        return Math.abs(i / 6 - j / 6) + Math.abs(i % 6 - j % 6);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minimumDistance(String word) {\\n        int[] aCosts = new int[word.length()];\\n        for (int i = 1; i < aCosts.length; i++) aCosts[i] = aCosts[i - 1] + dist(word.charAt(i - 1), word.charAt(i));\\n        int res = Integer.MAX_VALUE;\\n        for (int i = 1; i < word.length(); i++) {\\n            res = Math.min(res, aCosts[i - 1] + dfs(word.charAt(i - 1), word.charAt(i), i + 1, word));\\n        }\\n        return res;\\n    }\\n    \\n    private int dfs(char a, char b, int start, String word) {\\n        if (start == word.length()) return 0;\\n        char c = word.charAt(start);\\n        int aDiff = dist(a, c);\\n        int bDiff = dist(b, c);\\n        return Math.min(aDiff + dfs(c, b, start + 1, word), bDiff + dfs(a, c, start + 1, word));\\n    }\\n    \\n    private int dist(char a, char b) {\\n        int i = a - \\'A\\', j = b - \\'A\\';\\n        return Math.abs(i / 6 - j / 6) + Math.abs(i % 6 - j % 6);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minimumDistance(String word) {\\n        int[] aCosts = new int[word.length()];\\n        for (int i = 1; i < aCosts.length; i++) aCosts[i] = aCosts[i - 1] + dist(word.charAt(i - 1), word.charAt(i));\\n        int res = Integer.MAX_VALUE;\\n        int[][][] dp = new int[26][26][word.length()];\\n        for (int i = 1; i < word.length(); i++) {\\n            res = Math.min(res, aCosts[i - 1] + dfs(word.charAt(i - 1), word.charAt(i), i + 1, word, dp));\\n        }\\n        return res;\\n    }\\n    \\n    private int dfs(char a, char b, int start, String word, int[][][] dp) {\\n        if (start == word.length()) return 0;\\n        if (dp[a - \\'A\\'][b - \\'A\\'][start] != 0) return dp[a - \\'A\\'][b - \\'A\\'][start];\\n        char c = word.charAt(start);\\n        int aDiff = dist(a, c);\\n        int bDiff = dist(b, c);\\n        int res = Math.min(aDiff + dfs(c, b, start + 1, word, dp), bDiff + dfs(a, c, start + 1, word, dp));\\n        dp[a - \\'A\\'][b - \\'A\\'][start] = res;\\n        return res;\\n    }\\n    \\n    private int dist(char a, char b) {\\n        int i = a - \\'A\\', j = b - \\'A\\';\\n        return Math.abs(i / 6 - j / 6) + Math.abs(i % 6 - j % 6);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 677805,
                "title": "how-to-approach-dp-problems-solved-top-down-bottom-up-4-solutions",
                "content": "**Start With Top Down Approach**\\nBelow I am Sharing My Approch\\n```\\nint dp[301][27][27];\\nclass Solution {\\npublic:\\n    int findPos(char a){\\n        return a - \\'A\\';\\n    }\\n    int findCost(int from, int to){\\n        if(from == 26) return 0;\\n        int r1 = from/6;\\n        int c1 = from%6;\\n        int r2 = to/6;\\n        int c2 = to%6;\\n        return abs(r1 - r2) + abs(c1 - c2);\\n    }\\n    int solve(int index, int finger1, int finger2, string& word){\\n        if(index == word.size()) return 0;\\n        if(dp[index][finger1][finger2] != -1) return dp[index][finger1][finger2];\\n        int newPos = findPos(word[index]);\\n        int cost1 = findCost(finger1, newPos);\\n        int cost2 = findCost(finger2, newPos);\\n        return dp[index][finger1][finger2] = min(cost1 + solve(index + 1, newPos, finger2, word), cost2 + solve(index + 1, finger1, newPos, word));\\n    }\\n    int minimumDistance(string word) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(0, 26, 26, word);\\n    }\\n};\\n```\\nThis is a Brute Force Dp with no State Compression\\n\\n**Optimised Top Down**\\n```\\nint dp[301][27];\\nclass Solution {\\npublic:\\n    int findPos(char a){\\n        return a - \\'A\\';\\n    }\\n    int findCost(int from, int to){\\n        if(from == 26) return 0;\\n        int r1 = from/6;\\n        int c1 = from%6;\\n        int r2 = to/6;\\n        int c2 = to%6;\\n        return abs(r1 - r2) + abs(c1 - c2);\\n    }\\n    int solve(int index, int notMovingFinger, string& word){\\n        if(index == word.size()) return 0;\\n        if(dp[index][notMovingFinger] != -1) return dp[index][notMovingFinger];\\n        int previouslyMovedFinger = index == 0 ? 26 : findPos(word[index - 1]);\\n        int newPos = findPos(word[index]);\\n        int cost1 = findCost(notMovingFinger, newPos);\\n        int cost2 = findCost(previouslyMovedFinger, newPos);\\n        return dp[index][notMovingFinger] = min(cost1 + solve(index + 1, previouslyMovedFinger, word), cost2 + solve(index + 1, notMovingFinger, word));\\n    }\\n    int minimumDistance(string word) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(0, 26, word);\\n    }\\n};\\n```\\n**Optimised Bottom up**\\n```\\nclass Solution {\\npublic:\\n    int findPos(char a){\\n        return a - \\'A\\';\\n    }\\n    int findCost(int from, int to){\\n        if(from == 26) return 0;\\n        int r1 = from/6;\\n        int c1 = from%6;\\n        int r2 = to/6;\\n        int c2 = to%6;\\n        return abs(r1 - r2) + abs(c1 - c2);\\n    }\\n    int minimumDistance(string word){\\n        int n = word.size();\\n        vector<vector<long long>> dp(n + 1, vector<long long>(27, INT_MAX));\\n        dp[0][26] = 0;\\n        for(int i = 1; i < n + 1; i++){\\n//             position of NotMoving finger ---> j\\n            for(int j = 0; j < 27; j++){\\n//                  position of Previously Moved finger ---> k;\\n                int k = i == 1 ? 26 : findPos(word[i - 2]);\\n                dp[i][k] = min(dp[i][k], findCost(j, findPos(word[i - 1])) + dp[i-1][j]);\\n                dp[i][j] = min(dp[i][j], findCost(k, findPos(word[i - 1])) + dp[i-1][j]);\\n            }\\n        }\\n        long long ans = INT_MAX;\\n        for(int i = 0; i < 27; i++) ans = min(ans, dp[n][i]);\\n        return ans;\\n    }\\n};\\n```\\n\\n**Super optimised Bottom up**\\n```\\nclass Solution {\\npublic:\\n    int findPos(char a){\\n        return a - \\'A\\';\\n    }\\n    int findCost(int from, int to){\\n        if(from == 26) return 0;\\n        int r1 = from/6;\\n        int c1 = from%6;\\n        int r2 = to/6;\\n        int c2 = to%6;\\n        return abs(r1 - r2) + abs(c1 - c2);\\n    }\\n    int minimumDistance(string word){\\n        int n = word.size();\\n        vector<long long> dp(27, INT_MAX);\\n        dp[26] = 0;\\n        for(int i = 1; i < n + 1; i++){\\n            vector<long long> kp(27, INT_MAX);\\n//             position of NotMoving finger ---> j\\n            for(int j = 0; j < 27; j++){\\n//                  position of Previously Moved finger ---> k;\\n                int k = i == 1 ? 26 : findPos(word[i - 2]);\\n                kp[k] = min(kp[k], findCost(j, findPos(word[i - 1])) + dp[j]);\\n                kp[j] = min(kp[j], findCost(k, findPos(word[i - 1])) + dp[j]);\\n            }\\n            dp = kp;\\n        }\\n        long long ans = INT_MAX;\\n        for(int i = 0; i < 27; i++) ans = min(ans, dp[i]);\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nint dp[301][27][27];\\nclass Solution {\\npublic:\\n    int findPos(char a){\\n        return a - \\'A\\';\\n    }\\n    int findCost(int from, int to){\\n        if(from == 26) return 0;\\n        int r1 = from/6;\\n        int c1 = from%6;\\n        int r2 = to/6;\\n        int c2 = to%6;\\n        return abs(r1 - r2) + abs(c1 - c2);\\n    }\\n    int solve(int index, int finger1, int finger2, string& word){\\n        if(index == word.size()) return 0;\\n        if(dp[index][finger1][finger2] != -1) return dp[index][finger1][finger2];\\n        int newPos = findPos(word[index]);\\n        int cost1 = findCost(finger1, newPos);\\n        int cost2 = findCost(finger2, newPos);\\n        return dp[index][finger1][finger2] = min(cost1 + solve(index + 1, newPos, finger2, word), cost2 + solve(index + 1, finger1, newPos, word));\\n    }\\n    int minimumDistance(string word) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(0, 26, 26, word);\\n    }\\n};\\n```\n```\\nint dp[301][27];\\nclass Solution {\\npublic:\\n    int findPos(char a){\\n        return a - \\'A\\';\\n    }\\n    int findCost(int from, int to){\\n        if(from == 26) return 0;\\n        int r1 = from/6;\\n        int c1 = from%6;\\n        int r2 = to/6;\\n        int c2 = to%6;\\n        return abs(r1 - r2) + abs(c1 - c2);\\n    }\\n    int solve(int index, int notMovingFinger, string& word){\\n        if(index == word.size()) return 0;\\n        if(dp[index][notMovingFinger] != -1) return dp[index][notMovingFinger];\\n        int previouslyMovedFinger = index == 0 ? 26 : findPos(word[index - 1]);\\n        int newPos = findPos(word[index]);\\n        int cost1 = findCost(notMovingFinger, newPos);\\n        int cost2 = findCost(previouslyMovedFinger, newPos);\\n        return dp[index][notMovingFinger] = min(cost1 + solve(index + 1, previouslyMovedFinger, word), cost2 + solve(index + 1, notMovingFinger, word));\\n    }\\n    int minimumDistance(string word) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(0, 26, word);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findPos(char a){\\n        return a - \\'A\\';\\n    }\\n    int findCost(int from, int to){\\n        if(from == 26) return 0;\\n        int r1 = from/6;\\n        int c1 = from%6;\\n        int r2 = to/6;\\n        int c2 = to%6;\\n        return abs(r1 - r2) + abs(c1 - c2);\\n    }\\n    int minimumDistance(string word){\\n        int n = word.size();\\n        vector<vector<long long>> dp(n + 1, vector<long long>(27, INT_MAX));\\n        dp[0][26] = 0;\\n        for(int i = 1; i < n + 1; i++){\\n//             position of NotMoving finger ---> j\\n            for(int j = 0; j < 27; j++){\\n//                  position of Previously Moved finger ---> k;\\n                int k = i == 1 ? 26 : findPos(word[i - 2]);\\n                dp[i][k] = min(dp[i][k], findCost(j, findPos(word[i - 1])) + dp[i-1][j]);\\n                dp[i][j] = min(dp[i][j], findCost(k, findPos(word[i - 1])) + dp[i-1][j]);\\n            }\\n        }\\n        long long ans = INT_MAX;\\n        for(int i = 0; i < 27; i++) ans = min(ans, dp[n][i]);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findPos(char a){\\n        return a - \\'A\\';\\n    }\\n    int findCost(int from, int to){\\n        if(from == 26) return 0;\\n        int r1 = from/6;\\n        int c1 = from%6;\\n        int r2 = to/6;\\n        int c2 = to%6;\\n        return abs(r1 - r2) + abs(c1 - c2);\\n    }\\n    int minimumDistance(string word){\\n        int n = word.size();\\n        vector<long long> dp(27, INT_MAX);\\n        dp[26] = 0;\\n        for(int i = 1; i < n + 1; i++){\\n            vector<long long> kp(27, INT_MAX);\\n//             position of NotMoving finger ---> j\\n            for(int j = 0; j < 27; j++){\\n//                  position of Previously Moved finger ---> k;\\n                int k = i == 1 ? 26 : findPos(word[i - 2]);\\n                kp[k] = min(kp[k], findCost(j, findPos(word[i - 1])) + dp[j]);\\n                kp[j] = min(kp[j], findCost(k, findPos(word[i - 1])) + dp[j]);\\n            }\\n            dp = kp;\\n        }\\n        long long ans = INT_MAX;\\n        for(int i = 0; i < 27; i++) ans = min(ans, dp[i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477820,
                "title": "python-top-down-dp",
                "content": "Go over every character in the input word and recursively check if it is more favorable to move the finger at key a or the finger at key b to that character. Using None as a special input for the distance function elegantly handles initially unpositioned fingers.\\n```python\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        word_length = len(word)\\n        \\n        def distance(char_a: str, char_b: str) -> int:\\n            if not char_a or not char_b:\\n                return 0\\n            \\n            index_a = ord(char_a) - 65\\n            index_b = ord(char_b) - 65\\n            \\n            return abs(index_a // 6 - index_b // 6) + abs(index_a % 6 - index_b % 6)\\n        \\n        @lru_cache(None)\\n        def find(char_index: int, key_a: str, key_b: str) -> int:\\n            if char_index == word_length:\\n                return 0\\n            \\n            char = word[char_index]\\n            \\n            return min(\\n                find(char_index + 1, key_a, char) + distance(key_b, char),\\n                find(char_index + 1, char, key_b) + distance(key_a, char)\\n            )\\n        \\n        return find(0, None, None)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        word_length = len(word)\\n        \\n        def distance(char_a: str, char_b: str) -> int:\\n            if not char_a or not char_b:\\n                return 0\\n            \\n            index_a = ord(char_a) - 65\\n            index_b = ord(char_b) - 65\\n            \\n            return abs(index_a // 6 - index_b // 6) + abs(index_a % 6 - index_b % 6)\\n        \\n        @lru_cache(None)\\n        def find(char_index: int, key_a: str, key_b: str) -> int:\\n            if char_index == word_length:\\n                return 0\\n            \\n            char = word[char_index]\\n            \\n            return min(\\n                find(char_index + 1, key_a, char) + distance(key_b, char),\\n                find(char_index + 1, char, key_b) + distance(key_a, char)\\n            )\\n        \\n        return find(0, None, None)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477655,
                "title": "python-solution-bfs-with-comments",
                "content": "First we use finger1 to type first character\\nthen when we type following characters from left to right, we have two choices for each type, finger1 or finger2.\\nUse BFS to solve this question. Traverse from left to right, and for each character update the last position for finger1 and finger2\\nTake cake as an example, pop [\"C\", \"None\", 0] from the q, then append [A, None, 2] (type with finger1), [C, A, 0] (type with finger2) back to the q.\\n\\nI think the most import thing is, in BFS, dictionary should be used to avoid redundency., because many cases can end up with the same last positions. In this case, we remain the shortest distance \\n\\n\\n```\\ndef minimumDistance(self, word: str) -> int:\\n        q = []\\n        \\n        # use q to store :\\n\\t\\t# [the last position of finger1, the last position of finger2, the number of distance until current type] \\n        \\n        keyboard = {\"A\": (0, 0), \"B\": (0, 1), \"C\": (0, 2), \"D\":(0, 3), \"E\": (0, 4), \"F\": (0, 5),\\n                  \"G\": (1, 0), \"H\":(1, 1), \"I\": (1, 2), \"J\":(1, 3), \"K\": (1, 4), \"L\": (1, 5),\\n                  \"M\": (2, 0), \"N\": (2, 1), \"O\": (2, 2), \"P\":(2, 3), \"Q\": (2, 4), \"R\": (2, 5),\\n                  \"S\": (3, 0), \"T\": (3, 1), \"U\": (3, 2), \"V\":(3, 3), \"W\": (3, 4), \"X\": (3, 5),\\n                  \"Y\": (4, 0), \"Z\": (4, 1)}\\n        \\n        q = [[word[0], None, 0]]\\n        \\n        # first let finger1 to type the first character  put the [word[0], None, 0] into q\\n\\t\\t\\n        for w in word[1:]:\\n            dic = {}\\n\\t\\t# since there are some cases with the same last positions, so we use dictionary to reduce redundancy.\\n\\t\\t# there are two cases on each steps. Type with finger one or finger two.\\n            while q:\\n                last = q.pop()\\n                last1 = last[0]                       \\n                last2 = last[1]\\n                n = last[2]\\n                w_last_1 = abs(keyboard[last1][0] - keyboard[w][0]) + abs(keyboard[last1][1] - keyboard[w][1])\\n                if last2:\\n                    w_last_2 = abs(keyboard[last2][0] - keyboard[w][0]) + abs(keyboard[last2][1] - keyboard[w][1])\\n                else:\\n                    w_last_2 = 0\\n\\t\\t\\t\\t# update the last positions and the distances\\n                if (w, last2) not in dic:\\n                    dic[(w, last2)] = n + w_last_1\\n                else: \\n                    dic[(w, last2)] = min(dic[(w, last2)], n + w_last_1)\\n                if (last1, w) not in dic:\\n                    dic[(last1, w)] = n + w_last_2\\n                else: \\n                    dic[(last1, w)] = min(dic[(last1, w)], n + w_last_2)\\n            for k in dic.keys():\\n                q.append([k[0], k[1], dic[k]])\\n           \\n        res = float(\"inf\")\\n        for i in q:\\n            res = min(res, i[2])\\n        return res",
                "solutionTags": [],
                "code": "First we use finger1 to type first character\\nthen when we type following characters from left to right, we have two choices for each type, finger1 or finger2.\\nUse BFS to solve this question. Traverse from left to right, and for each character update the last position for finger1 and finger2\\nTake cake as an example, pop [\"C\", \"None\", 0] from the q, then append [A, None, 2] (type with finger1), [C, A, 0] (type with finger2) back to the q.\\n\\nI think the most import thing is, in BFS, dictionary should be used to avoid redundency., because many cases can end up with the same last positions. In this case, we remain the shortest distance \\n\\n\\n```\\ndef minimumDistance(self, word: str) -> int:\\n        q = []\\n        \\n        # use q to store :\\n\\t\\t# [the last position of finger1, the last position of finger2, the number of distance until current type] \\n        \\n        keyboard = {\"A\": (0, 0), \"B\": (0, 1), \"C\": (0, 2), \"D\":(0, 3), \"E\": (0, 4), \"F\": (0, 5),\\n                  \"G\": (1, 0), \"H\":(1, 1), \"I\": (1, 2), \"J\":(1, 3), \"K\": (1, 4), \"L\": (1, 5),\\n                  \"M\": (2, 0), \"N\": (2, 1), \"O\": (2, 2), \"P\":(2, 3), \"Q\": (2, 4), \"R\": (2, 5),\\n                  \"S\": (3, 0), \"T\": (3, 1), \"U\": (3, 2), \"V\":(3, 3), \"W\": (3, 4), \"X\": (3, 5),\\n                  \"Y\": (4, 0), \"Z\": (4, 1)}\\n        \\n        q = [[word[0], None, 0]]\\n        \\n        # first let finger1 to type the first character  put the [word[0], None, 0] into q\\n\\t\\t\\n        for w in word[1:]:\\n            dic = {}\\n\\t\\t# since there are some cases with the same last positions, so we use dictionary to reduce redundancy.\\n\\t\\t# there are two cases on each steps. Type with finger one or finger two.\\n            while q:\\n                last = q.pop()\\n                last1 = last[0]                       \\n                last2 = last[1]\\n                n = last[2]\\n                w_last_1 = abs(keyboard[last1][0] - keyboard[w][0]) + abs(keyboard[last1][1] - keyboard[w][1])\\n                if last2:\\n                    w_last_2 = abs(keyboard[last2][0] - keyboard[w][0]) + abs(keyboard[last2][1] - keyboard[w][1])\\n                else:\\n                    w_last_2 = 0\\n\\t\\t\\t\\t# update the last positions and the distances\\n                if (w, last2) not in dic:\\n                    dic[(w, last2)] = n + w_last_1\\n                else: \\n                    dic[(w, last2)] = min(dic[(w, last2)], n + w_last_1)\\n                if (last1, w) not in dic:\\n                    dic[(last1, w)] = n + w_last_2\\n                else: \\n                    dic[(last1, w)] = min(dic[(last1, w)], n + w_last_2)\\n            for k in dic.keys():\\n                q.append([k[0], k[1], dic[k]])\\n           \\n        res = float(\"inf\")\\n        for i in q:\\n            res = min(res, i[2])\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 478315,
                "title": "dijkstra-algorithm-with-priority-queue",
                "content": "It\\'s quite straightforward to convert this problem to a short-path problem.The state is two finger \\'s postition.\\n```\\nclass State implements Comparable<State>{\\n    public int index;\\n    public int otherFinger;\\n    public int cost;\\n    public State(int i, int o, int c){\\n        index = i;\\n        otherFinger = o;\\n        cost = c;\\n    }\\n    @Override\\n    public int hashCode(){\\n        return Objects.hash(index, otherFinger);\\n    }\\n    @Override\\n    public boolean equals(Object o){\\n        return index == ((State)o).index && otherFinger == ((State)o).otherFinger;\\n    }\\n    @Override \\n    public int compareTo(State s){\\n        return Integer.compare(cost, s.cost);\\n    }\\n}\\n\\nclass Solution {\\n    public int minimumDistance(String word) {\\n        PriorityQueue<State> pq = new PriorityQueue<>();\\n        for (int i = 0; i < 26; i++){\\n            pq.add(new State(0, i, 0));\\n        }\\n        Set<State> visited = new HashSet<>();\\n        while(!pq.isEmpty()){\\n            State s = pq.poll();\\n            if (visited.contains(s)){\\n                continue;\\n            }\\n            visited.add(s);\\n            if (s.index == word.length() - 1){\\n                return s.cost;\\n            }\\n            pq.add(new State(s.index + 1, s.otherFinger, cost(word.charAt(s.index) - \\'A\\', word.charAt(s.index + 1) - \\'A\\') + s.cost));\\n            pq.add(new State(s.index + 1, word.charAt(s.index) - \\'A\\', cost(s.otherFinger, word.charAt(s.index + 1) - \\'A\\') + s.cost));\\n        }\\n        return -1;\\n    }\\n\\n    int cost(int a, int b){\\n        return Math.abs(a % 6 - b % 6) + Math.abs(a / 6 - b / 6);\\n    }\\n}\\n    \\n```",
                "solutionTags": [],
                "code": "```\\nclass State implements Comparable<State>{\\n    public int index;\\n    public int otherFinger;\\n    public int cost;\\n    public State(int i, int o, int c){\\n        index = i;\\n        otherFinger = o;\\n        cost = c;\\n    }\\n    @Override\\n    public int hashCode(){\\n        return Objects.hash(index, otherFinger);\\n    }\\n    @Override\\n    public boolean equals(Object o){\\n        return index == ((State)o).index && otherFinger == ((State)o).otherFinger;\\n    }\\n    @Override \\n    public int compareTo(State s){\\n        return Integer.compare(cost, s.cost);\\n    }\\n}\\n\\nclass Solution {\\n    public int minimumDistance(String word) {\\n        PriorityQueue<State> pq = new PriorityQueue<>();\\n        for (int i = 0; i < 26; i++){\\n            pq.add(new State(0, i, 0));\\n        }\\n        Set<State> visited = new HashSet<>();\\n        while(!pq.isEmpty()){\\n            State s = pq.poll();\\n            if (visited.contains(s)){\\n                continue;\\n            }\\n            visited.add(s);\\n            if (s.index == word.length() - 1){\\n                return s.cost;\\n            }\\n            pq.add(new State(s.index + 1, s.otherFinger, cost(word.charAt(s.index) - \\'A\\', word.charAt(s.index + 1) - \\'A\\') + s.cost));\\n            pq.add(new State(s.index + 1, word.charAt(s.index) - \\'A\\', cost(s.otherFinger, word.charAt(s.index + 1) - \\'A\\') + s.cost));\\n        }\\n        return -1;\\n    }\\n\\n    int cost(int a, int b){\\n        return Math.abs(a % 6 - b % 6) + Math.abs(a / 6 - b / 6);\\n    }\\n}\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 511215,
                "title": "python3-10-lines-code-76-ms-with-explaination",
                "content": "Idea: total cost = cost by only using finger1 - cost saved by finger2\\n```\\nfrom functools import lru_cache\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        word = [ord(c)-ord(\\'A\\') for c in word]                          # char to int\\n        @lru_cache(None)\\n        def d(a, b):                                                    # store distance between char a, b\\n            return abs(a//6 - b//6) + abs(a%6 - b%6)\\n        dp = [0]*26                                                     # for each char, store the maximum cost saved by finger2\\n        for b, c in zip(word, word[1:]):                                # current saved cost = d(b,c) - d(a,c) (using finger2 instead of finger1)\\n            dp[b] = max(dp[a] + d(b,c) - d(a,c) for a in range(26))     # a is previous char typed by finger2, dp[a] is previous saved cost\\n        return sum(d(b,c) for b, c in zip(word, word[1:])) - max(dp)    # cost of finger1 - cost saved by finger2\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nfrom functools import lru_cache\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        word = [ord(c)-ord(\\'A\\') for c in word]                          # char to int\\n        @lru_cache(None)\\n        def d(a, b):                                                    # store distance between char a, b\\n            return abs(a//6 - b//6) + abs(a%6 - b%6)\\n        dp = [0]*26                                                     # for each char, store the maximum cost saved by finger2\\n        for b, c in zip(word, word[1:]):                                # current saved cost = d(b,c) - d(a,c) (using finger2 instead of finger1)\\n            dp[b] = max(dp[a] + d(b,c) - d(a,c) for a in range(26))     # a is previous char typed by finger2, dp[a] is previous saved cost\\n        return sum(d(b,c) for b, c in zip(word, word[1:])) - max(dp)    # cost of finger1 - cost saved by finger2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 478075,
                "title": "java-dp-solution-o-26-26-n-time-complexity",
                "content": "```\\nclass Solution {\\n    public int minimumDistance(String word) {\\n        char[] chars = word.toCharArray();\\n        int n = chars.length;\\n        \\n\\t\\t// Initialization, dp[0][26][26] = 0\\n        int[][][] dp = new int[n+1][27][27];\\n        for (int i = 0; i <= n; i++) {\\n            for (int j = 0; j < 27; j++) {\\n                Arrays.fill(dp[i][j], Integer.MAX_VALUE/2);\\n            }\\n        }\\n        dp[0][26][26] = 0;\\n        \\n        int min = Integer.MAX_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            int index = chars[i] - \\'A\\';\\n            for (int j = 0; j <= 26; j++) {\\n                for (int k = 0; k <= 26; k++) {\\n                    // left hand from k to index\\n                    dp[i+1][index][j] = Math.min(dp[i+1][index][j], dp[i][k][j] + d(k, index));\\n                    // right hand from k to index\\n                    dp[i+1][j][index] = Math.min(dp[i+1][j][index], dp[i][j][k] + d(k, index));\\n                }\\n                if (i == n - 1) {\\n                    min = Math.min(min, dp[i+1][index][j]);\\n                    min = Math.min(min, dp[i+1][j][index]);\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n    \\n    private int d(int a, int b) {\\n        if (a == 26) {\\n            return 0;\\n        }\\n        return Math.abs(a / 6 - b / 6) + Math.abs(a % 6 - b % 6);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDistance(String word) {\\n        char[] chars = word.toCharArray();\\n        int n = chars.length;\\n        \\n\\t\\t// Initialization, dp[0][26][26] = 0\\n        int[][][] dp = new int[n+1][27][27];\\n        for (int i = 0; i <= n; i++) {\\n            for (int j = 0; j < 27; j++) {\\n                Arrays.fill(dp[i][j], Integer.MAX_VALUE/2);\\n            }\\n        }\\n        dp[0][26][26] = 0;\\n        \\n        int min = Integer.MAX_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            int index = chars[i] - \\'A\\';\\n            for (int j = 0; j <= 26; j++) {\\n                for (int k = 0; k <= 26; k++) {\\n                    // left hand from k to index\\n                    dp[i+1][index][j] = Math.min(dp[i+1][index][j], dp[i][k][j] + d(k, index));\\n                    // right hand from k to index\\n                    dp[i+1][j][index] = Math.min(dp[i+1][j][index], dp[i][j][k] + d(k, index));\\n                }\\n                if (i == n - 1) {\\n                    min = Math.min(min, dp[i+1][index][j]);\\n                    min = Math.min(min, dp[i+1][j][index]);\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n    \\n    private int d(int a, int b) {\\n        if (a == 26) {\\n            return 0;\\n        }\\n        return Math.abs(a / 6 - b / 6) + Math.abs(a % 6 - b % 6);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 478453,
                "title": "python-detailed-comments-using-dijkstra",
                "content": "```\\nclass Solution(object):\\n    def minimumDistance(self, word):\\n        \"\"\"\\n        :type word: str\\n        :rtype: int\\n        \"\"\"\\n        def locate(grid, c):\\n            for i in xrange(len(grid)):\\n                for j in xrange(len(grid[i])):\\n                    if grid[i][j] == c:\\n                        return (i, j)\\n                    \\n        def manhattan_dist(u, v):\\n            if u == None or v == None:\\n                return 0\\n            return abs(u[0] - v[0]) + abs(u[1] - v[1])\\n           \\n        # Mundane setup work so we can look up the location of each character on the board quickly\\n        grid = [list(\\'ABCDEF\\'), list(\\'GHIJKL\\'), list(\\'MNOPQR\\'), list(\\'STUVWX\\'), list(\\'YZ\\')]\\n        loc = {}\\n        for c in set(word):\\n            loc[c] = locate(grid, c)\\n        \\n        # Imagine having the position of the two fingers, A and B, and word[i] just typed out,\\n        # as some state (p_a, p_b, i). At each state we have the options of changing either \\n        # position p_a or p_b to the position of the next character to be typed out, word[i+1].\\n\\t\\t# Moving finger A results in the next state (loc[word[i+1]], p_b, i + 1), moving finger B \\n\\t\\t# results in the next state (p_a, loc[word[i+1]], i + 1). The cost of changing is the \\n\\t\\t# manhattan_dist from p_a to word[i+1] or p_b to word[i+1]. Therefore we could imagine\\n\\t\\t# modeling this as a graph where the states are nodes in the graph, the edges the\\n        # possible transitions from one state to another, and the weight of an edge the \\n        # manhattan_dist from one state to the next due to moving one of the fingers. \\n        # With that in mind, we can run the standard Dijkstra algorithm over the graph!\\n        \\n        # Starting position where both fingers are \"free\", modeled as None and no character\\n        # has been typed, modeled as -1. The goal is to reach some state (p_a, p_b, len(words)-1)\\n        # with the cheapest path cost.\\n        start = (None, None, -1)\\n        d = {}\\n        d[start] = 0\\n        \\n        q = []\\n        heapq.heappush(q, [0, start])\\n        while len(q) > 0:\\n            ds, u = heapq.heappop(q)\\n            if u in d and d[u] != ds:\\n                continue\\n            \\n            # i points to the character we\\'ve just typed\\n            p_a, p_b, i = u\\n            if i == len(word) - 1:\\n                # We just typed out the last character, ds by Dijkstra must be the min path\\n                # cost from start\\n                return ds\\n            \\n            # To type out the next letter, we could move finger_a or finger_b with the cost\\n            # based on the manhattan_dist between that finger and the next letter. We\\'ll model\\n            # that as an edge with the weight of the said cost\\n            i = i + 1\\n            next_loc_finger_a = (loc[word[i]], p_b, i)\\n            cost_moving_finger_a = manhattan_dist(p_a, loc[word[i]])\\n            next_loc_finger_b = (p_a, loc[word[i]], i)\\n            cost_moving_finger_b = manhattan_dist(p_b, loc[word[i]])\\n            nbs = [(next_loc_finger_a, cost_moving_finger_a), (next_loc_finger_b, cost_moving_finger_b)]\\n            for nb in nbs:\\n                v, cost = nb\\n                if v not in d or d[v] > d[u] + cost:\\n                    d[v] = d[u] + cost\\n                    heapq.heappush(q, [d[v], v])\\n        \\n        # Never reached as we are guranteed to hit the character words[len(words)-1]\\n        return 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minimumDistance(self, word):\\n        \"\"\"\\n        :type word: str\\n        :rtype: int\\n        \"\"\"\\n        def locate(grid, c):\\n            for i in xrange(len(grid)):\\n                for j in xrange(len(grid[i])):\\n                    if grid[i][j] == c:\\n                        return (i, j)\\n                    \\n        def manhattan_dist(u, v):\\n            if u == None or v == None:\\n                return 0\\n            return abs(u[0] - v[0]) + abs(u[1] - v[1])\\n           \\n        # Mundane setup work so we can look up the location of each character on the board quickly\\n        grid = [list(\\'ABCDEF\\'), list(\\'GHIJKL\\'), list(\\'MNOPQR\\'), list(\\'STUVWX\\'), list(\\'YZ\\')]\\n        loc = {}\\n        for c in set(word):\\n            loc[c] = locate(grid, c)\\n        \\n        # Imagine having the position of the two fingers, A and B, and word[i] just typed out,\\n        # as some state (p_a, p_b, i). At each state we have the options of changing either \\n        # position p_a or p_b to the position of the next character to be typed out, word[i+1].\\n\\t\\t# Moving finger A results in the next state (loc[word[i+1]], p_b, i + 1), moving finger B \\n\\t\\t# results in the next state (p_a, loc[word[i+1]], i + 1). The cost of changing is the \\n\\t\\t# manhattan_dist from p_a to word[i+1] or p_b to word[i+1]. Therefore we could imagine\\n\\t\\t# modeling this as a graph where the states are nodes in the graph, the edges the\\n        # possible transitions from one state to another, and the weight of an edge the \\n        # manhattan_dist from one state to the next due to moving one of the fingers. \\n        # With that in mind, we can run the standard Dijkstra algorithm over the graph!\\n        \\n        # Starting position where both fingers are \"free\", modeled as None and no character\\n        # has been typed, modeled as -1. The goal is to reach some state (p_a, p_b, len(words)-1)\\n        # with the cheapest path cost.\\n        start = (None, None, -1)\\n        d = {}\\n        d[start] = 0\\n        \\n        q = []\\n        heapq.heappush(q, [0, start])\\n        while len(q) > 0:\\n            ds, u = heapq.heappop(q)\\n            if u in d and d[u] != ds:\\n                continue\\n            \\n            # i points to the character we\\'ve just typed\\n            p_a, p_b, i = u\\n            if i == len(word) - 1:\\n                # We just typed out the last character, ds by Dijkstra must be the min path\\n                # cost from start\\n                return ds\\n            \\n            # To type out the next letter, we could move finger_a or finger_b with the cost\\n            # based on the manhattan_dist between that finger and the next letter. We\\'ll model\\n            # that as an edge with the weight of the said cost\\n            i = i + 1\\n            next_loc_finger_a = (loc[word[i]], p_b, i)\\n            cost_moving_finger_a = manhattan_dist(p_a, loc[word[i]])\\n            next_loc_finger_b = (p_a, loc[word[i]], i)\\n            cost_moving_finger_b = manhattan_dist(p_b, loc[word[i]])\\n            nbs = [(next_loc_finger_a, cost_moving_finger_a), (next_loc_finger_b, cost_moving_finger_b)]\\n            for nb in nbs:\\n                v, cost = nb\\n                if v not in d or d[v] > d[u] + cost:\\n                    d[v] = d[u] + cost\\n                    heapq.heappush(q, [d[v], v])\\n        \\n        # Never reached as we are guranteed to hit the character words[len(words)-1]\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1971619,
                "title": "cpp-recursion-memoization-5d-dp",
                "content": "IDEA : For every character in word, we have two choices, either put the 1st finger on it or put the second finger, we will take both the cases into account and return the minimum.\\n```\\nclass Solution {\\npublic:\\n\\t//dp table where 1st value represent current index of the word, 2nd and 3rd value represents cell number for 1st finger and 4th and 5th  value represents cell number for 2nd finger\\n    int dp[305][5][6][5][6];\\n    vector<pair<int, int>> grid;\\n    int f(string& word, int i, int n, int x1, int y1, int x2, int y2){\\n        if(i >= n) return 0;\\n\\t\\t//taking MOD otherwise our dp table will excceed the memory limit as it will be something like dp[305][26][26][26][26], if we take each cell into consideration.\\n        if(dp[i][x1 % 5][y1 % 6][x2 % 5][y2 % 6] != -1) return dp[i][x1 % 5][y1 % 6][x2 % 5][y2 % 6];\\n        int op1 = 1e9, op2 = 1e9;\\n        int x = grid[word[i] - \\'A\\'].first, y = grid[word[i] - \\'A\\'].second;\\n\\t\\t//op1 represents value if 1st finger is placed at current index\\n        op1 = abs(x - x1) + abs(y - y1) + f(word, i+1, n, x, y, x2, y2);\\n\\t\\t//op2 represents value if 2nd finger is placed at current index\\n        op2 = abs(x - x2) + abs(y - y2) + f(word, i+1, n, x1, y1, x, y);\\n        return  dp[i][x1 % 5][y1 % 6][x2 % 5][y2 % 6] = min(op1, op2);\\n    }\\n    int minimumDistance(string word) {\\n        int n = word.size();\\n        int ans = INT_MAX;\\n        memset(dp, -1, sizeof(dp));\\n\\t\\t//build our grid..grid[0] = {0, 0}...grid[1] = {0, 1}...and so on, where gid[0] represents cell value for \\'A\\', grid[1] represents cell value of \\'B\\' and so on...\\n        for(int i=0; i<5; ++i)\\n            if(i != 4) for(int j=0; j<6; ++j) grid.push_back({i, j});\\n            else for(int j=0; j<2; ++j) grid.push_back({i, j});\\n\\t\\t//We will take every possibility of starting point i.e, 1st finger on A -> {2nd on A, 2nd finger on B......2nd finger on Z}, 1st finger on B -> {2nd finger on A, 2nd finger on B.....2nd finger on Z} and so on...\\n        for(int i=0; i<26; ++i){\\n            for(int j=0; j<26; ++j){\\n\\t\\t\\t\\t// (x1, y1) represents cell number for 1st finger and (x2, y2) represents cell number for 2nd finger\\n                int x1 = grid[i].first, x2 = grid[j].first;\\n                int y1 = grid[i].second, y2 = grid[j].second;\\n                ans = min(ans, f(word, 0, n, x1, y1, x2, y2));\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n\\t//dp table where 1st value represent current index of the word, 2nd and 3rd value represents cell number for 1st finger and 4th and 5th  value represents cell number for 2nd finger\\n    int dp[305][5][6][5][6];\\n    vector<pair<int, int>> grid;\\n    int f(string& word, int i, int n, int x1, int y1, int x2, int y2){\\n        if(i >= n) return 0;\\n\\t\\t//taking MOD otherwise our dp table will excceed the memory limit as it will be something like dp[305][26][26][26][26], if we take each cell into consideration.\\n        if(dp[i][x1 % 5][y1 % 6][x2 % 5][y2 % 6] != -1) return dp[i][x1 % 5][y1 % 6][x2 % 5][y2 % 6];\\n        int op1 = 1e9, op2 = 1e9;\\n        int x = grid[word[i] - \\'A\\'].first, y = grid[word[i] - \\'A\\'].second;\\n\\t\\t//op1 represents value if 1st finger is placed at current index\\n        op1 = abs(x - x1) + abs(y - y1) + f(word, i+1, n, x, y, x2, y2);\\n\\t\\t//op2 represents value if 2nd finger is placed at current index\\n        op2 = abs(x - x2) + abs(y - y2) + f(word, i+1, n, x1, y1, x, y);\\n        return  dp[i][x1 % 5][y1 % 6][x2 % 5][y2 % 6] = min(op1, op2);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 479767,
                "title": "a-good-3d-dp-practice-my-dp-note",
                "content": "This problem is a good practice for 3d DP. Even though I got TLE by using DFS in the contest, I went through three different DP solutions posted by others and here is my code and explanation.\\n\\nIn all of these solutions, I have the same mapping between numbers and chars:\\n```\\nfree the finger -> 0\\nA -> 1\\nB -> 2\\n...\\nZ -> 26\\n```\\nTherefore, the dimension of dp arrays is 27.\\n\\nIn all of these solutions, ```dp[i][j][k]``` means:\\n```\\ni: current step is the ith step; current char to be considered is word[i]\\nj: finger1 is at letter ord(\\'A\\')+j-1\\nk: finger2 is at letter ord(\\'A\\')+k-1\\n```\\n\\n**Method1: DFS without memorization**\\nThough DFS without memorization gets TLE, it gives us some hints to find the DP sub-problem. In the ```move()``` function, we have ```finger1, finger2, i, dist``` four parameters. We try to move finger1 and finger2 to ```word[i]``` alternatively in the recursion, and once we get to the end of ```word```, we update the minimum distance.\\n\\nIn this method, we do not cache the result for state ```finger1, finger2, i```, and when we get to the same state, we need to calculate the cost again, so it gets TLE. **However, it implies that the three DP states should be ```finger1, finger2, i```.**\\n\\n```\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        def getXY(letter):\\n            m=(ord(letter)-ord(\\'A\\'))//6\\n            n=(ord(letter)-ord(\\'A\\'))%6\\n            \\n            return m, n\\n        \\n        n=len(word)\\n        memo=set()\\n        \\n        finger1=(-1, -1)\\n        finger2=(-1, -1)\\n        \\n        self.res=float(\\'inf\\')\\n        def move(finger1, finger2, i, dist):\\n            if i==len(word):\\n                self.res=min(self.res, dist)\\n                return\\n            \\n            x, y=getXY(word[i])\\n            \\n            if finger1!=(-1, -1):\\n                move((x, y), finger2, i+1, dist+abs(x-finger1[0])+abs(y-finger1[1]))\\n            else:\\n                move((x, y), finger2, i+1, dist)\\n            \\n            if finger2!=(-1, -1):\\n                move(finger1, (x, y), i+1, dist+abs(x-finger2[0])+abs(y-finger2[1]))\\n            else:\\n                move(finger1, (x, y), i+1, dist)\\n        \\n        move(finger1, finger2, 0, 0)\\n        return self.res\\n```\\n\\n**Method 2: DFS with memorization (top-down DP)**\\nThis method is proposed by https://leetcode.com/problems/minimum-distance-to-type-a-word-using-two-fingers/discuss/477659/4%2B-DP-Solutions\\n\\nI noticed that for this problem, starting to go through the ```word``` from the left to right has the same cost as from the right to left, if we imagine the last step is to free two fingers. The first dimension of sub-problem is ```word[i:]```. Therefore, we can start to fill the dp array from ```word[i+1]``` to ```word[i]```. This can be done recursively. \\n\\n```\\ndp=[[[float(\\'inf\\')]*27 for _ in range(27)] for _ in range(len(word))]\\n\\ndef dist(pos_a, pos_b):\\n    if pos_a==0 or pos_b==0:\\n        return 0\\n\\n    return abs((pos_a-1)//6-(pos_b-1)//6)+abs((pos_a-1)%6-(pos_b-1)%6)\\n\\ndef helper(finger1, finger2, i):\\n    if i==len(word):\\n        return 0\\n\\n    if dp[i][finger1][finger2]<float(\\'inf\\'):\\n        return dp[i][finger1][finger2]\\n\\n    cur=ord(word[i])-ord(\\'A\\')+1\\n    dp[i][finger1][finger2]=min(dist(finger1, cur)+helper(cur, finger2, i+1), dist(finger2, cur)+helper(finger1, cur, i+1))\\n\\n    return dp[i][finger1][finger2]\\n\\nhelper(0, 0, 0)\\n\\nres=float(\\'inf\\')\\nfor i in range(27):\\n    for j in range(27):\\n        res=min(res, dp[0][i][j])\\n\\nreturn res\\n```\\n\\n**Method 3: bottom up DP**\\nSince starting from right has the same cost as starting from left, we can also get the result for ```word[i]``` according to ```word[i-1]```. This method is proposed by https://leetcode.com/problems/minimum-distance-to-type-a-word-using-two-fingers/discuss/478075/Java-DP-Solution-O(26*26*N)-Time-Complexity\\n\\nIn the ```for``` loop, we do:\\n```\\n# move finger1\\ndp[i][cur_pos][k]=min(dp[i][cur_pos][k], dp[i-1][j][k]+dist(j, cur_pos))\\n\\n# move finger2\\ndp[i][j][cur_pos]=min(dp[i][j][cur_pos], dp[i-1][j][k]+dist(k, cur_pos))\\n```\\n\\nThe reason that we have ```min()``` in the for loop above is, **moving finger1 and moving finger2 might update the same ```dp[i][j][k]```, so we need to get the minimum.**\\n\\nThe code snippet above means that if the char of finger in the last step is ```j``` or ```k```, we should add ```dist(j, cur_pos)``` or ```dist(k, cur_pos)``` to current cost to move the finger to current char ```word[i]```. \\n\\n**We do not need to care about what is ```word[i-1]``` because we initiate the dp array with ```float(\\'inf\\')```, and only those cells representing the existed chars in ```word``` will be activated (less than ```infinite```).** \\n\\n```\\ndef dist(pos_a, pos_b):\\n  if pos_a==0 or pos_b==0:\\n      return 0\\n\\n  return abs((pos_a-1)//6-(pos_b-1)//6)+abs((pos_a-1)%6-(pos_b-1)%6)\\n\\ndp=[[[float(\\'inf\\')]*27 for _ in range(27)] for _ in range(len(word))]\\n\\nfirst=ord(word[0])-ord(\\'A\\')+1\\ndp[0][0][first]=0\\ndp[0][first][0]=0\\n\\nfor i in range(1, len(word)):\\n    cur_pos=ord(word[i])-ord(\\'A\\')+1\\n\\n    for j in range(27):\\n        for k in range(27):\\n            # move finger1\\n            dp[i][cur_pos][k]=min(dp[i][cur_pos][k], dp[i-1][j][k]+dist(j, cur_pos))\\n\\n            # move finger2\\n            dp[i][j][cur_pos]=min(dp[i][j][cur_pos], dp[i-1][j][k]+dist(k, cur_pos))\\n\\nres=float(\\'inf\\')\\nfor i in range(27):\\n    for j in range(27):\\n        res=min(res, dp[len(word)-1][i][j])\\nreturn res\\n```\\n\\n**Method 4: optimization of method 3**\\nThis method is proposed by lee215. https://leetcode.com/problems/minimum-distance-to-type-a-word-using-two-fingers/discuss/477652/JavaC%2B%2BPython-1D-DP-O(1)-Space\\n\\nIf you understand the method 3, method 4 becomes very intuitive. **How to keep track of the \"activated cells in the dp array\"?** Rather than using array, we can use dictionary! The key of dictionary is the status of two fingers, the value is the accumulated distance. \\n\\nWe use ```last``` and ```cur``` to denote the dp dictionary in the last time step and current time step respectively. Again, the reason why we use ```min()``` here because we might calculate a status twice.\\n\\n```\\nlast={} # the dp dictionary in last time step\\ncur={} # the dp dictionary in current time step\\n\\nn=len(word)\\n\\ndef dist(pos_a, pos_b):\\n    if pos_a==0 or pos_b==0:\\n        return 0\\n\\n    return abs((pos_a-1)//6-(pos_b-1)//6)+abs((pos_a-1)%6-(pos_b-1)%6)\\n\\nfirst=ord(word[0])-ord(\\'A\\')+1\\n\\nlast[(0, first)]=0\\nlast[(first, 0)]=0\\n\\nfor i in range(1, n):\\n    c=ord(word[i])-ord(\\'A\\')+1\\n\\n    for a, b in last:\\n        # move finger1\\n        # 10000 is the same as infinite\\n        cur[c, b]=min(cur.get((c, b), 10000), last[a, b]+dist(a, c))\\n        # move finger2\\n        cur[a, c]=min(cur.get((a, c), 10000), last[a, b]+dist(b, c))\\n\\n    last=cur\\n    cur={}\\n\\nreturn min(last.values())\\n```\\n\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nfree the finger -> 0\\nA -> 1\\nB -> 2\\n...\\nZ -> 26\\n```\n```dp[i][j][k]```\n```\\ni: current step is the ith step; current char to be considered is word[i]\\nj: finger1 is at letter ord(\\'A\\')+j-1\\nk: finger2 is at letter ord(\\'A\\')+k-1\\n```\n```move()```\n```finger1, finger2, i, dist```\n```word[i]```\n```word```\n```finger1, finger2, i```\n```finger1, finger2, i```\n```\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        def getXY(letter):\\n            m=(ord(letter)-ord(\\'A\\'))//6\\n            n=(ord(letter)-ord(\\'A\\'))%6\\n            \\n            return m, n\\n        \\n        n=len(word)\\n        memo=set()\\n        \\n        finger1=(-1, -1)\\n        finger2=(-1, -1)\\n        \\n        self.res=float(\\'inf\\')\\n        def move(finger1, finger2, i, dist):\\n            if i==len(word):\\n                self.res=min(self.res, dist)\\n                return\\n            \\n            x, y=getXY(word[i])\\n            \\n            if finger1!=(-1, -1):\\n                move((x, y), finger2, i+1, dist+abs(x-finger1[0])+abs(y-finger1[1]))\\n            else:\\n                move((x, y), finger2, i+1, dist)\\n            \\n            if finger2!=(-1, -1):\\n                move(finger1, (x, y), i+1, dist+abs(x-finger2[0])+abs(y-finger2[1]))\\n            else:\\n                move(finger1, (x, y), i+1, dist)\\n        \\n        move(finger1, finger2, 0, 0)\\n        return self.res\\n```\n```word```\n```word[i:]```\n```word[i+1]```\n```word[i]```\n```\\ndp=[[[float(\\'inf\\')]*27 for _ in range(27)] for _ in range(len(word))]\\n\\ndef dist(pos_a, pos_b):\\n    if pos_a==0 or pos_b==0:\\n        return 0\\n\\n    return abs((pos_a-1)//6-(pos_b-1)//6)+abs((pos_a-1)%6-(pos_b-1)%6)\\n\\ndef helper(finger1, finger2, i):\\n    if i==len(word):\\n        return 0\\n\\n    if dp[i][finger1][finger2]<float(\\'inf\\'):\\n        return dp[i][finger1][finger2]\\n\\n    cur=ord(word[i])-ord(\\'A\\')+1\\n    dp[i][finger1][finger2]=min(dist(finger1, cur)+helper(cur, finger2, i+1), dist(finger2, cur)+helper(finger1, cur, i+1))\\n\\n    return dp[i][finger1][finger2]\\n\\nhelper(0, 0, 0)\\n\\nres=float(\\'inf\\')\\nfor i in range(27):\\n    for j in range(27):\\n        res=min(res, dp[0][i][j])\\n\\nreturn res\\n```\n```word[i]```\n```word[i-1]```\n```for```\n```\\n# move finger1\\ndp[i][cur_pos][k]=min(dp[i][cur_pos][k], dp[i-1][j][k]+dist(j, cur_pos))\\n\\n# move finger2\\ndp[i][j][cur_pos]=min(dp[i][j][cur_pos], dp[i-1][j][k]+dist(k, cur_pos))\\n```\n```min()```\n```dp[i][j][k]```\n```j```\n```k```\n```dist(j, cur_pos)```\n```dist(k, cur_pos)```\n```word[i]```\n```word[i-1]```\n```float(\\'inf\\')```\n```word```\n```infinite```\n```\\ndef dist(pos_a, pos_b):\\n  if pos_a==0 or pos_b==0:\\n      return 0\\n\\n  return abs((pos_a-1)//6-(pos_b-1)//6)+abs((pos_a-1)%6-(pos_b-1)%6)\\n\\ndp=[[[float(\\'inf\\')]*27 for _ in range(27)] for _ in range(len(word))]\\n\\nfirst=ord(word[0])-ord(\\'A\\')+1\\ndp[0][0][first]=0\\ndp[0][first][0]=0\\n\\nfor i in range(1, len(word)):\\n    cur_pos=ord(word[i])-ord(\\'A\\')+1\\n\\n    for j in range(27):\\n        for k in range(27):\\n            # move finger1\\n            dp[i][cur_pos][k]=min(dp[i][cur_pos][k], dp[i-1][j][k]+dist(j, cur_pos))\\n\\n            # move finger2\\n            dp[i][j][cur_pos]=min(dp[i][j][cur_pos], dp[i-1][j][k]+dist(k, cur_pos))\\n\\nres=float(\\'inf\\')\\nfor i in range(27):\\n    for j in range(27):\\n        res=min(res, dp[len(word)-1][i][j])\\nreturn res\\n```\n```last```\n```cur```\n```min()```\n```\\nlast={} # the dp dictionary in last time step\\ncur={} # the dp dictionary in current time step\\n\\nn=len(word)\\n\\ndef dist(pos_a, pos_b):\\n    if pos_a==0 or pos_b==0:\\n        return 0\\n\\n    return abs((pos_a-1)//6-(pos_b-1)//6)+abs((pos_a-1)%6-(pos_b-1)%6)\\n\\nfirst=ord(word[0])-ord(\\'A\\')+1\\n\\nlast[(0, first)]=0\\nlast[(first, 0)]=0\\n\\nfor i in range(1, n):\\n    c=ord(word[i])-ord(\\'A\\')+1\\n\\n    for a, b in last:\\n        # move finger1\\n        # 10000 is the same as infinite\\n        cur[c, b]=min(cur.get((c, b), 10000), last[a, b]+dist(a, c))\\n        # move finger2\\n        cur[a, c]=min(cur.get((a, c), 10000), last[a, b]+dist(b, c))\\n\\n    last=cur\\n    cur={}\\n\\nreturn min(last.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 828082,
                "title": "c-3d-dp-solution-top-down-dp-well-commented-to-better-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    map<int,pair<int,int>> m;  //Store postions of each character\\n    int dp[300][30][30];        \\n    int sum(string &s, int spos, int i, int j)\\n    {\\n        // spos: position of current character we want to type\\n\\t\\t// i: current postion of 1st finger\\n\\t\\t// j: current postion of 2nd finger\\n\\t\\t\\n\\t\\t//  If we reached end of word\\n\\t\\tif(spos==s.length())   \\n            return 0;\\n\\t\\t\\n\\t\\t//  If we already calculated answer before\\n        if(dp[spos][i][j]!=-1)   \\n            return dp[spos][i][j];\\n\\t\\t\\t\\n        int x=s[spos]-\\'A\\';    //  Current character \\n\\t\\t\\n\\t\\t//   Option 1: move 1st finger to current character\\n        int d1=abs(m[x].first-m[i].first)+abs(m[x].second-m[i].second);  \\n\\t\\t\\n\\t\\t//   Option 2: move 2nd finger to current character\\n        int d2=abs(m[x].first-m[j].first)+abs(m[x].second-m[j].second);  \\n\\t\\t\\n\\t\\t//  Take minimum of two options, store in dp table and return\\n        return dp[spos][i][j]=min(d1+sum(s,spos+1,x,j),d2+sum(s,spos+1,i,x));  \\n    }\\n    int minimumDistance(string word)\\n    {\\n        //   Storing coordinates of each character\\n\\t\\tfor(int i=0;i<26;i++)\\n            m[i]={i/6,i%6}; \\n\\t\\t\\n\\t\\t//   DP table initialization\\n        memset(dp,-1,sizeof(dp));\\n\\t\\t\\n        //   Initialize answer\\n\\t\\tint curr=1e9;\\n\\t\\t\\n\\t\\t//   It is always optimal to have first hand on first character and loop for all possible positions of 2nd hand and take the minimum of those possible postions\\n        for(int i=0;i<26;i++)\\n            curr=min(curr,sum(word,0,word[0]-\\'A\\',i));   \\n        return curr;   \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int,pair<int,int>> m;  //Store postions of each character\\n    int dp[300][30][30];        \\n    int sum(string &s, int spos, int i, int j)\\n    {\\n        // spos: position of current character we want to type\\n\\t\\t// i: current postion of 1st finger\\n\\t\\t// j: current postion of 2nd finger\\n\\t\\t\\n\\t\\t//  If we reached end of word\\n\\t\\tif(spos==s.length())   \\n            return 0;\\n\\t\\t\\n\\t\\t//  If we already calculated answer before\\n        if(dp[spos][i][j]!=-1)   \\n            return dp[spos][i][j];\\n\\t\\t\\t\\n        int x=s[spos]-\\'A\\';    //  Current character \\n\\t\\t\\n\\t\\t//   Option 1: move 1st finger to current character\\n        int d1=abs(m[x].first-m[i].first)+abs(m[x].second-m[i].second);  \\n\\t\\t\\n\\t\\t//   Option 2: move 2nd finger to current character\\n        int d2=abs(m[x].first-m[j].first)+abs(m[x].second-m[j].second);  \\n\\t\\t\\n\\t\\t//  Take minimum of two options, store in dp table and return\\n        return dp[spos][i][j]=min(d1+sum(s,spos+1,x,j),d2+sum(s,spos+1,i,x));  \\n    }\\n    int minimumDistance(string word)\\n    {\\n        //   Storing coordinates of each character\\n\\t\\tfor(int i=0;i<26;i++)\\n            m[i]={i/6,i%6}; \\n\\t\\t\\n\\t\\t//   DP table initialization\\n        memset(dp,-1,sizeof(dp));\\n\\t\\t\\n        //   Initialize answer\\n\\t\\tint curr=1e9;\\n\\t\\t\\n\\t\\t//   It is always optimal to have first hand on first character and loop for all possible positions of 2nd hand and take the minimum of those possible postions\\n        for(int i=0;i<26;i++)\\n            curr=min(curr,sum(word,0,word[0]-\\'A\\',i));   \\n        return curr;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 478268,
                "title": "python-top-down-dp",
                "content": "```py\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        \\n        def buildKeyboard():\\n            row = col = 0\\n            keyboard_map = {}\\n            for i in range(26):\\n                row = i // 6\\n                col = i % 6\\n                keyboard_map[chr(i + ord(\\'A\\'))] = (row,col)\\n            return keyboard_map\\n        \\n        def getCost(a, b):\\n            if not a or not b:\\n                return 0\\n            r1, c1 = keyboard_map[a]\\n            r2, c2 = keyboard_map[b]\\n            return abs(r1-r2) + abs(c1-c2)\\n\\n        @lru_cache(None)\\n        def dp(cur_idx, prev_finger1=None, prev_finger2=None):\\n            if cur_idx == len(word):\\n                return 0\\n            finger1_cost = getCost(prev_finger1, word[cur_idx]) + dp(cur_idx+1, word[cur_idx], prev_finger2)\\n            finger2_cost = getCost(prev_finger2, word[cur_idx]) + dp(cur_idx+1, prev_finger1, word[cur_idx])\\n            return min(finger1_cost, finger2_cost)\\n\\n        keyboard_map = buildKeyboard()\\n        return dp(0)\\n```\\nTime complexity: O(N) where n is a length of a word\\nSpace compexlity: O(N)",
                "solutionTags": [],
                "code": "```py\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        \\n        def buildKeyboard():\\n            row = col = 0\\n            keyboard_map = {}\\n            for i in range(26):\\n                row = i // 6\\n                col = i % 6\\n                keyboard_map[chr(i + ord(\\'A\\'))] = (row,col)\\n            return keyboard_map\\n        \\n        def getCost(a, b):\\n            if not a or not b:\\n                return 0\\n            r1, c1 = keyboard_map[a]\\n            r2, c2 = keyboard_map[b]\\n            return abs(r1-r2) + abs(c1-c2)\\n\\n        @lru_cache(None)\\n        def dp(cur_idx, prev_finger1=None, prev_finger2=None):\\n            if cur_idx == len(word):\\n                return 0\\n            finger1_cost = getCost(prev_finger1, word[cur_idx]) + dp(cur_idx+1, word[cur_idx], prev_finger2)\\n            finger2_cost = getCost(prev_finger2, word[cur_idx]) + dp(cur_idx+1, prev_finger1, word[cur_idx])\\n            return min(finger1_cost, finger2_cost)\\n\\n        keyboard_map = buildKeyboard()\\n        return dp(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477665,
                "title": "c-recursion-with-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<char>> mat;\\n    int dp[300][7][7][7][7];\\n    \\n    int move(int x1, int y1, int x2, int y2) {\\n        if(x1 == -1 && y1 == -1)\\n            return 0;\\n        return abs(x2 - x1) + abs(y2 - y1);\\n    }\\n    \\n    pair<int, int> pos(char c) {\\n        for(int i = 0; i < mat.size(); i++) {\\n            for(int j = 0; j < mat[0].size(); j++) {\\n                if(mat[i][j] == c) {\\n                    return { i, j };\\n                } \\n            }\\n        }\\n        return { -10, -10 };\\n    }\\n    \\n    int f(string s, int i, int f1x, int f1y, int f2x, int f2y) {\\n        if(i == s.size())\\n            return 0;\\n        if(dp[i][f1x + 1][f1y + 1][f2x + 1][f2y + 1] != -1)\\n            return dp[i][f1x + 1][f1y + 1][f2x + 1][f2y + 1];\\n        pair<int, int> p = pos(s[i]);\\n        int cx = p.first, cy = p.second;\\n        int op1 = move(f1x, f1y, cx, cy) + f(s, i + 1, cx, cy, f2x, f2y);\\n        int op2 = move(f2x, f2y, cx, cy) + f(s, i + 1, f1x, f1y, cx, cy);\\n        return dp[i][f1x + 1][f1y + 1][f2x + 1][f2y + 1] = min(op1, op2);\\n    }\\n    \\n    int minimumDistance(string word) {\\n        mat = {\\n            {\\n                \\'A\\', \\'B\\', \\'C\\', \\'D\\', \\'E\\', \\'F\\'\\n            },\\n            {\\n                \\'G\\', \\'H\\', \\'I\\', \\'J\\', \\'K\\', \\'L\\'\\n            },\\n            {\\n                \\'M\\', \\'N\\', \\'O\\', \\'P\\', \\'Q\\', \\'R\\'\\n            },\\n            {\\n                \\'S\\', \\'T\\', \\'U\\', \\'V\\', \\'W\\', \\'X\\'\\n            },\\n            {\\n                \\'Y\\', \\'Z\\'\\n            },\\n        };\\n        memset(dp, -1, sizeof dp);\\n        return f(word, 0, -1, -1, -1, -1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<char>> mat;\\n    int dp[300][7][7][7][7];\\n    \\n    int move(int x1, int y1, int x2, int y2) {\\n        if(x1 == -1 && y1 == -1)\\n            return 0;\\n        return abs(x2 - x1) + abs(y2 - y1);\\n    }\\n    \\n    pair<int, int> pos(char c) {\\n        for(int i = 0; i < mat.size(); i++) {\\n            for(int j = 0; j < mat[0].size(); j++) {\\n                if(mat[i][j] == c) {\\n                    return { i, j };\\n                } \\n            }\\n        }\\n        return { -10, -10 };\\n    }\\n    \\n    int f(string s, int i, int f1x, int f1y, int f2x, int f2y) {\\n        if(i == s.size())\\n            return 0;\\n        if(dp[i][f1x + 1][f1y + 1][f2x + 1][f2y + 1] != -1)\\n            return dp[i][f1x + 1][f1y + 1][f2x + 1][f2y + 1];\\n        pair<int, int> p = pos(s[i]);\\n        int cx = p.first, cy = p.second;\\n        int op1 = move(f1x, f1y, cx, cy) + f(s, i + 1, cx, cy, f2x, f2y);\\n        int op2 = move(f2x, f2y, cx, cy) + f(s, i + 1, f1x, f1y, cx, cy);\\n        return dp[i][f1x + 1][f1y + 1][f2x + 1][f2y + 1] = min(op1, op2);\\n    }\\n    \\n    int minimumDistance(string word) {\\n        mat = {\\n            {\\n                \\'A\\', \\'B\\', \\'C\\', \\'D\\', \\'E\\', \\'F\\'\\n            },\\n            {\\n                \\'G\\', \\'H\\', \\'I\\', \\'J\\', \\'K\\', \\'L\\'\\n            },\\n            {\\n                \\'M\\', \\'N\\', \\'O\\', \\'P\\', \\'Q\\', \\'R\\'\\n            },\\n            {\\n                \\'S\\', \\'T\\', \\'U\\', \\'V\\', \\'W\\', \\'X\\'\\n            },\\n            {\\n                \\'Y\\', \\'Z\\'\\n            },\\n        };\\n        memset(dp, -1, sizeof dp);\\n        return f(word, 0, -1, -1, -1, -1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477658,
                "title": "java-topdown-dp",
                "content": "```\\nclass Solution {\\n    public int minimumDistance(String word) {\\n        Map<String, Integer> memo = new HashMap<>();\\n        return dfs(0, \\'a\\', \\'a\\', word, memo);\\n    }\\n    int dfs(int index, char x, char y, String word, Map<String, Integer> memo) {\\n        if (index == word.length()) {\\n            return 0;\\n        }\\n        String key = index + \" \" + x + \" \" + y;\\n        if (memo.containsKey(key)) {\\n            return memo.get(key);\\n        }\\n        int res = Integer.MAX_VALUE;\\n        char c = word.charAt(index);\\n        int xx = (c - \\'A\\') / 6;\\n        int yy = (c - \\'A\\') % 6;\\n        if (x == \\'a\\') {\\n            res = dfs(index + 1, c, y, word, memo);\\n        } else {\\n            int xxx = (x - \\'A\\') / 6;\\n            int yyy = (x - \\'A\\') % 6;\\n            int dist = Math.abs(xxx - xx) + Math.abs(yyy - yy);\\n            res = dfs(index + 1, c, y, word, memo) + dist;\\n        }\\n        if (y == \\'a\\') {\\n            res = Math.min(res, dfs(index + 1, x, c, word, memo));\\n        } else {\\n            int xxx = (y - \\'A\\') / 6;\\n            int yyy = (y - \\'A\\') % 6;\\n            int dist = Math.abs(xxx - xx) + Math.abs(yyy - yy);\\n            res = Math.min(res, dfs(index + 1, x, c, word, memo) + dist);\\n        }\\n        memo.put(key, res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDistance(String word) {\\n        Map<String, Integer> memo = new HashMap<>();\\n        return dfs(0, \\'a\\', \\'a\\', word, memo);\\n    }\\n    int dfs(int index, char x, char y, String word, Map<String, Integer> memo) {\\n        if (index == word.length()) {\\n            return 0;\\n        }\\n        String key = index + \" \" + x + \" \" + y;\\n        if (memo.containsKey(key)) {\\n            return memo.get(key);\\n        }\\n        int res = Integer.MAX_VALUE;\\n        char c = word.charAt(index);\\n        int xx = (c - \\'A\\') / 6;\\n        int yy = (c - \\'A\\') % 6;\\n        if (x == \\'a\\') {\\n            res = dfs(index + 1, c, y, word, memo);\\n        } else {\\n            int xxx = (x - \\'A\\') / 6;\\n            int yyy = (x - \\'A\\') % 6;\\n            int dist = Math.abs(xxx - xx) + Math.abs(yyy - yy);\\n            res = dfs(index + 1, c, y, word, memo) + dist;\\n        }\\n        if (y == \\'a\\') {\\n            res = Math.min(res, dfs(index + 1, x, c, word, memo));\\n        } else {\\n            int xxx = (y - \\'A\\') / 6;\\n            int yyy = (y - \\'A\\') % 6;\\n            int dist = Math.abs(xxx - xx) + Math.abs(yyy - yy);\\n            res = Math.min(res, dfs(index + 1, x, c, word, memo) + dist);\\n        }\\n        memo.put(key, res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599666,
                "title": "dijkstra-key-observations-and-java-impl",
                "content": "### Observations\\n  - cost of moving a finger is 0 for the first move, then manhattan distance b/w positions\\n\\n  - finding the min overall cost can be formulated as **shortest path on a DAG**\\n    - graph vertex models a typing state with 3 identifying attributes \\n        1. Index in the word\\n        2. Left finger position\\n        3. Right finger position\\n        4. (non-identifying attribute) min cost of reaching the state\\n        \\n    - directed edges lead to a next vertex with index+1 and new position of either left or right finger\\n        - edge weight is a move cost\\n        - typical vertex will have 2 outbound edges, one for each finger\\n    - weare looking for a lenght of a shortest path \"start\" to a vertex with word index == word.length()\\n\\nSince edge weights are non-negative, Dijkstra algo applies. As a side note, DP solutions can often be seen as a Bellman-Ford application to this graph.\\n\\nSpace optimization:\\n  - states are symmetric w/respect to left & right fingers\\n\\t  - i.e. `(index, leftPosition, rightPosition)` is the same as `(index, rightPosition, leftPosition)`\\n  - thus we can only consider states in the form of (index, smallerIdx, largerIdx)\\n\\n===========================\\n\\n### Time & Space complexity\\n\\n- Let `N` be a word length\\n- for each `i = 0..N` there are at most `|alphabet|` vertices for left finger and same number for right finger\\n- at least one of the fingers will be fixed at `word.charAt(i)`\\n- thus total number of vertices is `O(N*|alphabet|)`\\n- each vertex has at most `|alphabet|` incoming edges. Thus total amount of edges is `O(N*|alphabet|^2)`\\n\\nThen, given the implementation below:\\nTC: `O(N*|alphabet|^2 * log(N*|alphabet|))`\\nSC: `O(N*|alphabet|^2)`\\n\\nIf we assume constant size of the alphabet, then:\\nTC: `O(N*log(N))`\\nSC: `O(N)`\\n\\n\\n```\\nclass Solution {\\n    private static final int NOWHERE = -1;\\n    private static final int[] ROW_OF = new int[26];\\n    private static final int[] COL_OF = new int[26];\\n\\n    static {\\n        initPositions();\\n    }\\n\\n    private static final void initPositions() {\\n        for(int charIdx = 0; charIdx <= \\'Z\\' - \\'A\\'; charIdx++) {\\n            int row = charIdx / 6;\\n            int col = charIdx % 6;\\n            ROW_OF[charIdx] = row;\\n            COL_OF[charIdx] = col;\\n        }\\n    }\\n\\n    public int minimumDistance(String word) {\\n\\n        HashSet<Vertex> visited = new HashSet<>();\\n        PriorityQueue<Vertex> minHeap = new PriorityQueue<>((v1, v2) -> v1.costToReach - v2.costToReach);\\n\\n        Vertex start = new Vertex(0, NOWHERE, NOWHERE, 0);\\n        minHeap.offer(start);\\n\\n        while(!minHeap.isEmpty()) {\\n            Vertex vertex = minHeap.poll();\\n            if(!visited.add(vertex))\\n                continue;\\n\\n            if(vertex.wordIdx == word.length())\\n                return vertex.costToReach;\\n\\n            int nextPos = word.charAt(vertex.wordIdx) - \\'A\\';\\n\\n            Vertex nextWithLeftFinger = new Vertex(\\n                vertex.wordIdx + 1, \\n                nextPos, \\n                vertex.rightPos, \\n                vertex.costToReach + manhattanDistance(vertex.leftPos, nextPos)\\n            );\\n            \\n            Vertex nextWithRightFinger = new Vertex(\\n                vertex.wordIdx + 1, \\n                vertex.leftPos, \\n                nextPos,\\n                vertex.costToReach + manhattanDistance(vertex.rightPos, nextPos)\\n            );\\n            minHeap.offer(nextWithLeftFinger);\\n            minHeap.offer(nextWithRightFinger);\\n        }\\n\\n        throw new IllegalStateException(\"Should not have reached here\");\\n    }\\n\\n    private static int manhattanDistance(int fromPos, int toPos) {\\n        if(fromPos == NOWHERE)\\n            return 0;\\n        return Math.abs(ROW_OF[toPos] - ROW_OF[fromPos]) \\n            + Math.abs(COL_OF[toPos] - COL_OF[fromPos]);\\n    }\\n\\n    private static final class Vertex {\\n        private final int wordIdx;\\n        private final int leftPos;\\n        private final int rightPos;\\n        private final int costToReach;\\n\\n        private Vertex(int wordIdx, int leftPos, int rightPos, int costToReach) {\\n            this.wordIdx = wordIdx;\\n            this.leftPos = Math.min(leftPos, rightPos);\\n            this.rightPos = Math.max(leftPos, rightPos);\\n            this.costToReach = costToReach;\\n        }\\n\\n        public boolean equals(Object o) {\\n            // simplified. Cost is not accounted for equality & hash code\\n            Vertex other = (Vertex) o;\\n            return wordIdx == other.wordIdx && leftPos == other.leftPos && rightPos == other.rightPos;\\n        }\\n\\n        public int hashCode() {\\n            return Objects.hash(wordIdx, leftPos, rightPos);\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static final int NOWHERE = -1;\\n    private static final int[] ROW_OF = new int[26];\\n    private static final int[] COL_OF = new int[26];\\n\\n    static {\\n        initPositions();\\n    }\\n\\n    private static final void initPositions() {\\n        for(int charIdx = 0; charIdx <= \\'Z\\' - \\'A\\'; charIdx++) {\\n            int row = charIdx / 6;\\n            int col = charIdx % 6;\\n            ROW_OF[charIdx] = row;\\n            COL_OF[charIdx] = col;\\n        }\\n    }\\n\\n    public int minimumDistance(String word) {\\n\\n        HashSet<Vertex> visited = new HashSet<>();\\n        PriorityQueue<Vertex> minHeap = new PriorityQueue<>((v1, v2) -> v1.costToReach - v2.costToReach);\\n\\n        Vertex start = new Vertex(0, NOWHERE, NOWHERE, 0);\\n        minHeap.offer(start);\\n\\n        while(!minHeap.isEmpty()) {\\n            Vertex vertex = minHeap.poll();\\n            if(!visited.add(vertex))\\n                continue;\\n\\n            if(vertex.wordIdx == word.length())\\n                return vertex.costToReach;\\n\\n            int nextPos = word.charAt(vertex.wordIdx) - \\'A\\';\\n\\n            Vertex nextWithLeftFinger = new Vertex(\\n                vertex.wordIdx + 1, \\n                nextPos, \\n                vertex.rightPos, \\n                vertex.costToReach + manhattanDistance(vertex.leftPos, nextPos)\\n            );\\n            \\n            Vertex nextWithRightFinger = new Vertex(\\n                vertex.wordIdx + 1, \\n                vertex.leftPos, \\n                nextPos,\\n                vertex.costToReach + manhattanDistance(vertex.rightPos, nextPos)\\n            );\\n            minHeap.offer(nextWithLeftFinger);\\n            minHeap.offer(nextWithRightFinger);\\n        }\\n\\n        throw new IllegalStateException(\"Should not have reached here\");\\n    }\\n\\n    private static int manhattanDistance(int fromPos, int toPos) {\\n        if(fromPos == NOWHERE)\\n            return 0;\\n        return Math.abs(ROW_OF[toPos] - ROW_OF[fromPos]) \\n            + Math.abs(COL_OF[toPos] - COL_OF[fromPos]);\\n    }\\n\\n    private static final class Vertex {\\n        private final int wordIdx;\\n        private final int leftPos;\\n        private final int rightPos;\\n        private final int costToReach;\\n\\n        private Vertex(int wordIdx, int leftPos, int rightPos, int costToReach) {\\n            this.wordIdx = wordIdx;\\n            this.leftPos = Math.min(leftPos, rightPos);\\n            this.rightPos = Math.max(leftPos, rightPos);\\n            this.costToReach = costToReach;\\n        }\\n\\n        public boolean equals(Object o) {\\n            // simplified. Cost is not accounted for equality & hash code\\n            Vertex other = (Vertex) o;\\n            return wordIdx == other.wordIdx && leftPos == other.leftPos && rightPos == other.rightPos;\\n        }\\n\\n        public int hashCode() {\\n            return Objects.hash(wordIdx, leftPos, rightPos);\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1132877,
                "title": "o-n-27-27-memoized-java-solution-with-explanation",
                "content": "\\t// time and space complexity : O(n * 27 *27)\\n\\t/*\\n\\t  1)Assuming the position as a 2D grid would lead to much higher dimensions dp table.\\n\\t  2)Instead we will mark code for each character, Like \\'A\\' -> 1, \\'B\\' -> 2 , \\'G\\' -> 7 .... \\'Z\\' -> 26\\n\\t  3)So instead of having x and y corrdinates for each finger, we will represents each finger by these codes.\\n\\t  4)For a code ,we can easily find out its respective position in 2D grid for calculating distance btw 2 consecutive characters of word .\\n\\t  5) After this, finger1 and finger2 have value in range [0,26] denoting previously typed character by them. finger2==0 means finger 2 has not been used yet.\\n\\t  6) If finger2 has not been used yet, we have 2 options, either to start using finger2 or we use of finger1 to type current character.\\n\\t  7) When both fingers are used previously, we have 2 choices either to use finger1 to type current character or use finger 2\\n\\n\\t*/\\n\\tclass Solution {\\n\\t\\tint[][][] dp;\\n\\t\\tpublic int minimumDistance(String str) {\\n\\t\\t\\tdp = new int[str.length()][27][27];\\n\\t\\t\\tfor(int i=0;i<dp.length;i++)\\n\\t\\t\\t\\tfor(int j=0;j<27;j++)\\n\\t\\t\\t\\t\\tArrays.fill(dp[i][j],-1);\\n\\t\\t\\treturn helper(str,1,str.charAt(0)-\\'A\\'+ 1,0);\\n\\n\\t\\t}\\n\\t\\tprivate int helper(String str,int i,int finger1,int finger2){\\n\\t\\t\\tif(i==str.length())return 0;\\n\\t\\t\\tif(dp[i][finger1][finger2]!=-1)return dp[i][finger1][finger2];\\n\\t\\t\\tint ch = str.charAt(i) - \\'A\\' + 1;\\n\\t\\t\\tif(finger2==0){\\n\\t\\t\\t\\tint c1 = helper(str,i+1,finger1,ch);    // start using finger 2\\n\\t\\t\\t\\tint c2 = distance(ch,finger1) + helper(str,i+1,ch,finger2);   // finger 1 is used\\n\\t\\t\\t\\treturn  dp[i][finger1][finger2] = Math.min(c1,c2);\\n\\t\\t\\t}\\n\\t\\t\\tint c1 = distance(ch,finger1) + helper(str,i+1,ch,finger2);   // finger 1 is used\\n\\t\\t\\tint c2 = distance(ch,finger2) + helper(str,i+1,finger1,ch);    // finger 2 is used\\n\\t\\t\\treturn  dp[i][finger1][finger2] = Math.min(c1,c2);\\n\\t\\t}\\n\\t\\tprivate int distance(int a,int b){\\n\\t\\t\\tint ax = (a-1)/6;\\n\\t\\t\\tint bx = (b-1)/6;\\n\\t\\t\\tint ay = (a-1)%6;\\n\\t\\t\\tint by = (b-1)%6;\\n\\t\\t\\treturn Math.abs(ax-bx) + Math.abs(ay-by);\\n\\t\\t}\\n\\t}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tint[][][] dp;\\n\\t\\tpublic int minimumDistance(String str) {\\n\\t\\t\\tdp = new int[str.length()][27][27];\\n\\t\\t\\tfor(int i=0;i<dp.length;i++)\\n\\t\\t\\t\\tfor(int j=0;j<27;j++)\\n\\t\\t\\t\\t\\tArrays.fill(dp[i][j],-1);\\n\\t\\t\\treturn helper(str,1,str.charAt(0)-\\'A\\'+ 1,0);\\n\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 812969,
                "title": "java-3d-2d-top-down-memoization-dp-solution",
                "content": "Would like to share my thoughts from initial solution and then optimized gradually:\\n\\n1. First thoughts: 3D DP with Memoization:\\n```\\nclass Solution {\\n    public int minimumDistance(String word) {\\n        int n = word.length();\\n        int[][][] dp = new int[n][27][27];\\n        char[] arr = word.toCharArray();\\n        int res = Integer.MAX_VALUE;\\n        for (int i = 0; i < 27; i++) {\\n            for (int j = i; j < 27; j++) {\\n                res = Math.min(res, helper(arr, 0, i, j, dp));\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private int helper(char[] word, int k, int i, int j, int[][][] dp) {\\n        if (k == word.length) return 0;\\n        if (dp[k][i][j] > 0) return dp[k][i][j];\\n        \\n        int cost = Math.min(helper(word, k + 1, word[k] - \\'A\\', j, dp) + cost(i, word[k] - \\'A\\'), helper(word, k + 1, i, word[k] - \\'A\\', dp) + cost(j, word[k] - \\'A\\'));\\n        return dp[k][i][j] = cost;\\n    }\\n    \\n   private int cost(int from, int to) {\\n        if (from == 26) return 0;\\n        return Math.abs(from/6 - to/6) + Math.abs(from%6 - to%6);\\n    }\\n}\\n```\\n2. Optimized to 2D DP with Memoization:\\nwith observation, one of the pointer can be inferred from current position ``k``: thus DP can be optimized to 2D, note that the initial ``k = 1``\\n```\\nclass Solution {\\n    public int minimumDistance(String word) {\\n        int n = word.length();\\n        int[][] dp = new int[n][27];\\n        char[] arr = word.toCharArray();\\n        int res = Integer.MAX_VALUE;\\n        for (int i = 0; i < 27; i++) {\\n            res = Math.min(res, helper(arr, 1, i, dp));\\n        }\\n        return res;\\n    }\\n    \\n    private int helper(char[] word, int k, int i, int[][] dp) {\\n        if (k >= word.length) return 0;\\n        if (dp[k][i] > 0) return dp[k][i];\\n        int cur = word[k] - \\'A\\';\\n        int cost = Math.min(helper(word, k+1, i, dp) + cost(word[k-1] - \\'A\\', cur), helper(word, k+1, word[k-1] - \\'A\\', dp) + cost(i, cur));\\n        return dp[k][i] = cost;\\n    }\\n    \\n    private int cost(int from, int to) {\\n        if (from == 26) return 0;\\n        return Math.abs(from/6 - to/6) + Math.abs(from%6 - to%6);\\n    }\\n}\\n```\\n\\nThen the following is easy, converted Memoization to Top-Down following its topological order:\\n3. 3D Top-Down DP\\n```\\nclass Solution {\\n    public int minimumDistance(String word) {\\n        int n = word.length();\\n        int[][][] dp = new int[n+1][27][27];\\n        char[] arr = word.toCharArray();\\n        for (int k = n - 1; k >= 0; k--) {\\n            for (int i = 0; i < 27; i++) {\\n                for (int j = 0; j < 27; j++) {\\n                    dp[k][i][j] = Math.min(dp[k+1][arr[k]-\\'A\\'][j] + cost(i, arr[k] - \\'A\\'), dp[k+1][i][arr[k]-\\'A\\'] + cost(j, arr[k] - \\'A\\'));\\n                }\\n            }\\n        }\\n        return dp[0][26][26];\\n    }\\n    \\n     private int cost(int from, int to) {\\n        if (from == 26) return 0;\\n        return Math.abs(from/6 - to/6) + Math.abs(from%6 - to%6);\\n    }\\n}\\n```\\n\\n4. 2D Top-Down DP\\n```\\nclass Solution {\\n    public int minimumDistance(String word) {\\n        int n = word.length();\\n        int[][] dp = new int[n+1][27];\\n        char[] arr = word.toCharArray();\\n        for (int k = n - 1; k > 0; k--) {\\n            for (int i = 0; i < 27; i++) {\\n                int cur = arr[k] - \\'A\\';\\n                dp[k][i] = Math.min(dp[k+1][arr[k-1]-\\'A\\'] + cost(i, cur), dp[k+1][i] + cost(arr[k-1]-\\'A\\', cur));\\n            }\\n        }\\n        return dp[1][26];\\n    }\\n\\n    private int cost(int from, int to) {\\n        if (from == 26) return 0;\\n        return Math.abs(from/6 - to/6) + Math.abs(from%6 - to%6);\\n    }\\n}\\n```\\n\\nthere is also 1D DP solution from lee215: https://leetcode.com/problems/minimum-distance-to-type-a-word-using-two-fingers/discuss/477652/JavaC%2B%2BPython-1D-DP-O(1)-Space\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDistance(String word) {\\n        int n = word.length();\\n        int[][][] dp = new int[n][27][27];\\n        char[] arr = word.toCharArray();\\n        int res = Integer.MAX_VALUE;\\n        for (int i = 0; i < 27; i++) {\\n            for (int j = i; j < 27; j++) {\\n                res = Math.min(res, helper(arr, 0, i, j, dp));\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private int helper(char[] word, int k, int i, int j, int[][][] dp) {\\n        if (k == word.length) return 0;\\n        if (dp[k][i][j] > 0) return dp[k][i][j];\\n        \\n        int cost = Math.min(helper(word, k + 1, word[k] - \\'A\\', j, dp) + cost(i, word[k] - \\'A\\'), helper(word, k + 1, i, word[k] - \\'A\\', dp) + cost(j, word[k] - \\'A\\'));\\n        return dp[k][i][j] = cost;\\n    }\\n    \\n   private int cost(int from, int to) {\\n        if (from == 26) return 0;\\n        return Math.abs(from/6 - to/6) + Math.abs(from%6 - to%6);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minimumDistance(String word) {\\n        int n = word.length();\\n        int[][] dp = new int[n][27];\\n        char[] arr = word.toCharArray();\\n        int res = Integer.MAX_VALUE;\\n        for (int i = 0; i < 27; i++) {\\n            res = Math.min(res, helper(arr, 1, i, dp));\\n        }\\n        return res;\\n    }\\n    \\n    private int helper(char[] word, int k, int i, int[][] dp) {\\n        if (k >= word.length) return 0;\\n        if (dp[k][i] > 0) return dp[k][i];\\n        int cur = word[k] - \\'A\\';\\n        int cost = Math.min(helper(word, k+1, i, dp) + cost(word[k-1] - \\'A\\', cur), helper(word, k+1, word[k-1] - \\'A\\', dp) + cost(i, cur));\\n        return dp[k][i] = cost;\\n    }\\n    \\n    private int cost(int from, int to) {\\n        if (from == 26) return 0;\\n        return Math.abs(from/6 - to/6) + Math.abs(from%6 - to%6);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minimumDistance(String word) {\\n        int n = word.length();\\n        int[][][] dp = new int[n+1][27][27];\\n        char[] arr = word.toCharArray();\\n        for (int k = n - 1; k >= 0; k--) {\\n            for (int i = 0; i < 27; i++) {\\n                for (int j = 0; j < 27; j++) {\\n                    dp[k][i][j] = Math.min(dp[k+1][arr[k]-\\'A\\'][j] + cost(i, arr[k] - \\'A\\'), dp[k+1][i][arr[k]-\\'A\\'] + cost(j, arr[k] - \\'A\\'));\\n                }\\n            }\\n        }\\n        return dp[0][26][26];\\n    }\\n    \\n     private int cost(int from, int to) {\\n        if (from == 26) return 0;\\n        return Math.abs(from/6 - to/6) + Math.abs(from%6 - to%6);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minimumDistance(String word) {\\n        int n = word.length();\\n        int[][] dp = new int[n+1][27];\\n        char[] arr = word.toCharArray();\\n        for (int k = n - 1; k > 0; k--) {\\n            for (int i = 0; i < 27; i++) {\\n                int cur = arr[k] - \\'A\\';\\n                dp[k][i] = Math.min(dp[k+1][arr[k-1]-\\'A\\'] + cost(i, cur), dp[k+1][i] + cost(arr[k-1]-\\'A\\', cur));\\n            }\\n        }\\n        return dp[1][26];\\n    }\\n\\n    private int cost(int from, int to) {\\n        if (from == 26) return 0;\\n        return Math.abs(from/6 - to/6) + Math.abs(from%6 - to%6);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 625154,
                "title": "c-easy-solution-with-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<char, int> rowMap;\\n    unordered_map<char, int> colMap;\\n    unordered_map<string, int> dp;\\n    \\n    int distance(char a, char b) {\\n        if(a==\\'#\\' || b== \\'#\\') {\\n            return 0;\\n        }\\n        \\n        int rowDistance = abs(rowMap[a]-rowMap[b]);\\n        int colDistance = abs(colMap[a]-colMap[b]);\\n        return rowDistance + colDistance;\\n    }\\n    \\n    void initialize() {\\n        for(int i=0;i<26;i++) {\\n            int row = i/6;\\n            int col = i%6;\\n            rowMap[char(\\'A\\'+i)] = row;\\n            colMap[char(\\'A\\'+i)] = col;\\n        }\\n    }\\n    \\n    int findMinDistance(string& word, int index, char finger1, char finger2) {\\n        if(index == word.size()) {\\n            return 0;\\n        }\\n        \\n        string key = to_string(index)+\"-\"+finger1+\"-\"+finger2;\\n        if(dp.find(key)!=dp.end()) {\\n            return dp[key];\\n        }\\n        \\n        int result1 = distance(word[index], finger1) + findMinDistance(word, index+1, word[index], finger2);\\n        int result2 = distance(word[index], finger2) + findMinDistance(word, index+1, finger1, word[index]);\\n        \\n        dp[key] = min(result1, result2);\\n        return dp[key];\\n    }\\n    \\n    int minimumDistance(string word) {\\n        initialize();\\n        return findMinDistance(word, 0, \\'#\\', \\'#\\');\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<char, int> rowMap;\\n    unordered_map<char, int> colMap;\\n    unordered_map<string, int> dp;\\n    \\n    int distance(char a, char b) {\\n        if(a==\\'#\\' || b== \\'#\\') {\\n            return 0;\\n        }\\n        \\n        int rowDistance = abs(rowMap[a]-rowMap[b]);\\n        int colDistance = abs(colMap[a]-colMap[b]);\\n        return rowDistance + colDistance;\\n    }\\n    \\n    void initialize() {\\n        for(int i=0;i<26;i++) {\\n            int row = i/6;\\n            int col = i%6;\\n            rowMap[char(\\'A\\'+i)] = row;\\n            colMap[char(\\'A\\'+i)] = col;\\n        }\\n    }\\n    \\n    int findMinDistance(string& word, int index, char finger1, char finger2) {\\n        if(index == word.size()) {\\n            return 0;\\n        }\\n        \\n        string key = to_string(index)+\"-\"+finger1+\"-\"+finger2;\\n        if(dp.find(key)!=dp.end()) {\\n            return dp[key];\\n        }\\n        \\n        int result1 = distance(word[index], finger1) + findMinDistance(word, index+1, word[index], finger2);\\n        int result2 = distance(word[index], finger2) + findMinDistance(word, index+1, finger1, word[index]);\\n        \\n        dp[key] = min(result1, result2);\\n        return dp[key];\\n    }\\n    \\n    int minimumDistance(string word) {\\n        initialize();\\n        return findMinDistance(word, 0, \\'#\\', \\'#\\');\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 491083,
                "title": "dew-it-tricky-solution-explained-easy-to-understand-o-n",
                "content": "**APPROACH**\\n* Imagine that we have already typed the given string upto index k\\n* This means that **one finger is at k**: this also means that the **other finger is before k**\\n* The lagging finger could be pointing at **any one of the letters A-Z** or perhaps it was **never used at all**\\n* Let us suppose that we know the optimal costs for being in any of those **27 \"states\"** i.e **{ A, arr[k] }, { B, arr[k] }, ... { Z, arr[k] }, { null, arr[k] }**\\n(leading finger being at { arr[k] } and lagging finger last used to type { A-Z or nothing })\\n* What we need is the optimal costs for reaching the 27 states when the leading finger is at { arr[k+1] } using the costs computed so far\\n* The letter k+1 can be typed in one of two ways: **1. use the leading finger** VS **2. use the lagging finger**\\n* If we do 2, we have a potential min cost for the state { arr[k], arr[k+1] }\\nIf we do 1, we have potential min costs for { A, arr[k+1] }, { B, arr[k+1] }, ... { Z, arr[k+1] }, { null, arr[k+1] }\\nNOTE: arr[k] is some char between A and Z, so there might be a clash - we take the min of the two ways from above.\\n* We can **extend our logic upto n-1** and then return the lowest cost from there as the answer\\n\\n**CODE**\\n\\n```\\nclass Solution {\\n    public int minimumDistance(String word) {\\n        int n = word.length();\\n        if(n < 3) return 0;\\n        \\n        char[] arr = word.toCharArray();\\n        int[] store = new int[27];\\n        for(int i=0; i<27; ++i) store[i] = Integer.MAX_VALUE;\\n        \\n        store[26] = dist(arr[1], arr[0]);\\n        store[arr[0]-\\'A\\'] = 0;\\n        for(int k=2; k<n; ++k) {\\n            int delta = dist(arr[k], arr[k-1]), min = store[26];\\n            for(int i=0; i<27; ++i) {\\n                if(store[i] < min) min = Math.min(min, store[i] + dist(arr[k], (char) (i + \\'A\\')));\\n                if(store[i] < Integer.MAX_VALUE) store[i] += delta;\\n            }\\n            store[arr[k-1]-\\'A\\'] = Math.min(store[arr[k-1]-\\'A\\'], min);\\n        }\\n        \\n        int ans = Integer.MAX_VALUE;\\n        for(int x: store) ans = Math.min(ans, x);\\n        \\n        return ans;\\n    }\\n    \\n    private int dist(char a, char b) {\\n        int i = a - \\'A\\', j = b - \\'A\\';\\n        return Math.abs(i/6 - j/6) + Math.abs(i%6 - j%6);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minimumDistance(String word) {\\n        int n = word.length();\\n        if(n < 3) return 0;\\n        \\n        char[] arr = word.toCharArray();\\n        int[] store = new int[27];\\n        for(int i=0; i<27; ++i) store[i] = Integer.MAX_VALUE;\\n        \\n        store[26] = dist(arr[1], arr[0]);\\n        store[arr[0]-\\'A\\'] = 0;\\n        for(int k=2; k<n; ++k) {\\n            int delta = dist(arr[k], arr[k-1]), min = store[26];\\n            for(int i=0; i<27; ++i) {\\n                if(store[i] < min) min = Math.min(min, store[i] + dist(arr[k], (char) (i + \\'A\\')));\\n                if(store[i] < Integer.MAX_VALUE) store[i] += delta;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 478763,
                "title": "javascript-dynamic-programming-dijkstra-s-2-solutions",
                "content": "# Dynamic Programming (fastest)\\n```javascript\\n/**\\n * @param {string} word\\n * @return {number}\\n */\\nconst map = {\\n  A: [0,0],\\n  B: [0,1],\\n  C: [0,2],\\n  D: [0,3],\\n  E: [0,4],\\n  F: [0,5],\\n  G: [1,0],\\n  H: [1,1],\\n  I: [1,2],\\n  J: [1,3],\\n  K: [1,4],\\n  L: [1,5],\\n  M: [2,0],\\n  N: [2,1],\\n  O: [2,2],\\n  P: [2,3],\\n  Q: [2,4],\\n  R: [2,5],\\n  S: [3,0],\\n  T: [3,1],\\n  U: [3,2],\\n  V: [3,3],\\n  W: [3,4],\\n  X: [3,5],\\n  Y: [4,0],\\n  Z: [4,1],\\n}\\n\\nconst distance = (ltr1, ltr2) => (\\n  Math.abs(map[ltr1][0] - map[ltr2][0]) + Math.abs(map[ltr1][1] - map[ltr2][1])\\n)\\n\\n/**\\n * @param {string} word\\n * @return {number}\\n */\\nvar minimumDistance = function(word) {\\n  const chars = new Set(word.split(\\'\\'))\\n  const cache = new Array(word.length);\\n  for (let i = 0; i < cache.length; i++) cache[i] = {};\\n  const dfs = (left, right, next) => {\\n    if (next === word.length) return 0;\\n    const key = left === word[next - 1] ? right : left;\\n    if (cache[next][key] !== undefined) return cache[next][key];\\n    let res = dfs(word[next], right, next + 1) + distance(left, word[next]);\\n    res = Math.min(res, dfs(left, word[next], next + 1) + distance(right, word[next]));\\n    return cache[next][key] = res;\\n  }\\n  let min = Infinity;\\n  for (let char of chars) {\\n    min = Math.min(min, dfs(word[0], char, 1))\\n  }\\n  return min;\\n};\\n```\\n\\n# Dijkstra\\'s Algorithm (works)\\n\\n```javascript\\nclass MinHeap {\\n  constructor() {\\n    this.store = [];\\n  }\\n\\n  isEmpty() {\\n    return this.store.length === 0;\\n  }\\n\\n  pop() {\\n    if (this.store.length < 2) return this.store.pop();\\n    const result = this.store[0];\\n    this.store[0] = this.store.pop();\\n    this.heapifyDown(0);\\n    return result;\\n  }\\n\\n  push(value) {\\n    this.store.push(value);\\n    this.heapifyUp(this.store.length - 1);\\n  }\\n\\n  heapifyDown(parent) {\\n    const childs = [1,2].map((n) => parent * 2 + n).filter((n) => n < this.store.length);\\n    let child = childs[0];\\n    if (childs[1] && this.store[childs[1]].distance < this.store[child].distance) {\\n      child = childs[1];\\n    }\\n    if (child && this.store[child].distance < this.store[parent].distance) {\\n      const temp = this.store[child];\\n      this.store[child] = this.store[parent];\\n      this.store[parent] = temp;\\n      this.heapifyDown(child);\\n    }\\n  }\\n\\n  heapifyUp(child) {\\n    const parent = Math.floor((child - 1) / 2);\\n    if (child && this.store[child].distance < this.store[parent].distance) {\\n      const temp = this.store[child];\\n      this.store[child] = this.store[parent];\\n      this.store[parent] = temp;\\n      this.heapifyUp(parent);\\n    }\\n  }\\n}\\n\\n/**\\n * @param {string} word\\n * @return {number}\\n */\\nconst map = {\\n  A: [0,0],\\n  B: [0,1],\\n  C: [0,2],\\n  D: [0,3],\\n  E: [0,4],\\n  F: [0,5],\\n  G: [1,0],\\n  H: [1,1],\\n  I: [1,2],\\n  J: [1,3],\\n  K: [1,4],\\n  L: [1,5],\\n  M: [2,0],\\n  N: [2,1],\\n  O: [2,2],\\n  P: [2,3],\\n  Q: [2,4],\\n  R: [2,5],\\n  S: [3,0],\\n  T: [3,1],\\n  U: [3,2],\\n  V: [3,3],\\n  W: [3,4],\\n  X: [3,5],\\n  Y: [4,0],\\n  Z: [4,1],\\n}\\n\\nconst getDistance = (ltr1, ltr2) => (\\n  Math.abs(map[ltr1][0] - map[ltr2][0]) + Math.abs(map[ltr1][1] - map[ltr2][1])\\n)\\n\\n/**\\n * @param {string} word\\n * @return {number}\\n */\\nvar minimumDistance = function(word) {\\n  const heap = new MinHeap();\\n  for (let letter in map) {\\n    heap.push({ left: word[0], right: letter, pos: 1, distance: 0 });\\n  }\\n  const visited = word.split(\\'\\').map(() => new Set());\\n  while (!heap.isEmpty()) {\\n    const { left, right, pos, distance } = heap.pop();\\n    if (pos === word.length) return distance;\\n    const key = left === word[pos - 1] ? right : left;\\n    if (visited[pos].has(key)) continue;\\n    visited[pos].add(key)\\n    heap.push({\\n      left: word[pos],\\n      right,\\n      pos: pos + 1,\\n      distance: distance + getDistance(left, word[pos])\\n    })\\n    heap.push({\\n      left,\\n      right: word[pos],\\n      pos: pos + 1,\\n      distance: distance + getDistance(right, word[pos])\\n    })\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```javascript\\n/**\\n * @param {string} word\\n * @return {number}\\n */\\nconst map = {\\n  A: [0,0],\\n  B: [0,1],\\n  C: [0,2],\\n  D: [0,3],\\n  E: [0,4],\\n  F: [0,5],\\n  G: [1,0],\\n  H: [1,1],\\n  I: [1,2],\\n  J: [1,3],\\n  K: [1,4],\\n  L: [1,5],\\n  M: [2,0],\\n  N: [2,1],\\n  O: [2,2],\\n  P: [2,3],\\n  Q: [2,4],\\n  R: [2,5],\\n  S: [3,0],\\n  T: [3,1],\\n  U: [3,2],\\n  V: [3,3],\\n  W: [3,4],\\n  X: [3,5],\\n  Y: [4,0],\\n  Z: [4,1],\\n}\\n\\nconst distance = (ltr1, ltr2) => (\\n  Math.abs(map[ltr1][0] - map[ltr2][0]) + Math.abs(map[ltr1][1] - map[ltr2][1])\\n)\\n\\n/**\\n * @param {string} word\\n * @return {number}\\n */\\nvar minimumDistance = function(word) {\\n  const chars = new Set(word.split(\\'\\'))\\n  const cache = new Array(word.length);\\n  for (let i = 0; i < cache.length; i++) cache[i] = {};\\n  const dfs = (left, right, next) => {\\n    if (next === word.length) return 0;\\n    const key = left === word[next - 1] ? right : left;\\n    if (cache[next][key] !== undefined) return cache[next][key];\\n    let res = dfs(word[next], right, next + 1) + distance(left, word[next]);\\n    res = Math.min(res, dfs(left, word[next], next + 1) + distance(right, word[next]));\\n    return cache[next][key] = res;\\n  }\\n  let min = Infinity;\\n  for (let char of chars) {\\n    min = Math.min(min, dfs(word[0], char, 1))\\n  }\\n  return min;\\n};\\n```\n```javascript\\nclass MinHeap {\\n  constructor() {\\n    this.store = [];\\n  }\\n\\n  isEmpty() {\\n    return this.store.length === 0;\\n  }\\n\\n  pop() {\\n    if (this.store.length < 2) return this.store.pop();\\n    const result = this.store[0];\\n    this.store[0] = this.store.pop();\\n    this.heapifyDown(0);\\n    return result;\\n  }\\n\\n  push(value) {\\n    this.store.push(value);\\n    this.heapifyUp(this.store.length - 1);\\n  }\\n\\n  heapifyDown(parent) {\\n    const childs = [1,2].map((n) => parent * 2 + n).filter((n) => n < this.store.length);\\n    let child = childs[0];\\n    if (childs[1] && this.store[childs[1]].distance < this.store[child].distance) {\\n      child = childs[1];\\n    }\\n    if (child && this.store[child].distance < this.store[parent].distance) {\\n      const temp = this.store[child];\\n      this.store[child] = this.store[parent];\\n      this.store[parent] = temp;\\n      this.heapifyDown(child);\\n    }\\n  }\\n\\n  heapifyUp(child) {\\n    const parent = Math.floor((child - 1) / 2);\\n    if (child && this.store[child].distance < this.store[parent].distance) {\\n      const temp = this.store[child];\\n      this.store[child] = this.store[parent];\\n      this.store[parent] = temp;\\n      this.heapifyUp(parent);\\n    }\\n  }\\n}\\n\\n/**\\n * @param {string} word\\n * @return {number}\\n */\\nconst map = {\\n  A: [0,0],\\n  B: [0,1],\\n  C: [0,2],\\n  D: [0,3],\\n  E: [0,4],\\n  F: [0,5],\\n  G: [1,0],\\n  H: [1,1],\\n  I: [1,2],\\n  J: [1,3],\\n  K: [1,4],\\n  L: [1,5],\\n  M: [2,0],\\n  N: [2,1],\\n  O: [2,2],\\n  P: [2,3],\\n  Q: [2,4],\\n  R: [2,5],\\n  S: [3,0],\\n  T: [3,1],\\n  U: [3,2],\\n  V: [3,3],\\n  W: [3,4],\\n  X: [3,5],\\n  Y: [4,0],\\n  Z: [4,1],\\n}\\n\\nconst getDistance = (ltr1, ltr2) => (\\n  Math.abs(map[ltr1][0] - map[ltr2][0]) + Math.abs(map[ltr1][1] - map[ltr2][1])\\n)\\n\\n/**\\n * @param {string} word\\n * @return {number}\\n */\\nvar minimumDistance = function(word) {\\n  const heap = new MinHeap();\\n  for (let letter in map) {\\n    heap.push({ left: word[0], right: letter, pos: 1, distance: 0 });\\n  }\\n  const visited = word.split(\\'\\').map(() => new Set());\\n  while (!heap.isEmpty()) {\\n    const { left, right, pos, distance } = heap.pop();\\n    if (pos === word.length) return distance;\\n    const key = left === word[pos - 1] ? right : left;\\n    if (visited[pos].has(key)) continue;\\n    visited[pos].add(key)\\n    heap.push({\\n      left: word[pos],\\n      right,\\n      pos: pos + 1,\\n      distance: distance + getDistance(left, word[pos])\\n    })\\n    heap.push({\\n      left,\\n      right: word[pos],\\n      pos: pos + 1,\\n      distance: distance + getDistance(right, word[pos])\\n    })\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477888,
                "title": "java-12ms-o-n-2-dp-solution-with-clear-explanation",
                "content": "This is my first solution article in Leetcode. If you have any suggestion or question, bring it on! \\n\\n1. State Representation\\nDuring the process of typing, we can use the positions of the two fingers to represent the current state.\\nFor example,  the word is \"LEETCODE\".\\n\\t[5, 7] can represent that the first finger is at \"C\" and the second finger is at \"D\".\\n**Attention**, the index starts from **1**, because I want to use 0 to denote a finger has not typed anything. Therefore, [0, 4] means that the first finger is not used and the second finger is at \"T\".\\n\\n2. Observations\\n\\t* No After-Effect: When we have already typed some characters, how we move the two fingers after does not affect the distance we have reached so far.\\n\\t* Over-Lapping Subproblems:  Still use \"LEETCODE\" as an example. \\n\\tWhen the first finger is at C and the second finger is at O (**[5, 6]**) , in the next step, we can either move the first finger to \"D\" or move the second finger to \"D\". The former state is **[7, 6]** and the latter is **[5, 7]**. As we can see here, both [7, 6] and [5, 7]  can be derived from the [5, 6].\\n\\t* \\tOptimal Substructure: For every state, there must be an optimal way to move the two fingers to reach the state with the shortest distance among all the choices. When we get the shortest distance of  state **dp[i, j]**, we can use it to update the distances of the future states which **dp[i, j]** can reach.\\n\\n3. How to DP\\nI use **dp[i, j] (0 <=i, j <= n)** to represent the shortest distance when the first finger is at the i-th character and the second finger is at the j-th character. Attention, again, the index here starts from 1. 0 means this finger has not been used so far.\\nMoreover, for convenience of explanation, I use **dis(i, j)** **(1 <= i, j <= n)** to denote the distance if we move a finger from the i-th character to the j-th character.\\n\\t* i == j: This is invalid, because we can\\'t type the same character twice.\\n\\t* [1, 0] and [0, 1]: According to the problem, the first character one finger types does not have distance. \\n\\t\\t* dp[1, 0] = 0\\n\\t\\t* dp[0, 1] = 0\\n\\t* i = 0 or j = 0: This means that we use one single finger to type all the characters so far. \\n\\t\\t* dp[i, 0] = dp[i - 1, 0] + dis(i - 1, i)\\n\\t\\t* dp[0, j] = dp[0, j -1] + dis(j - 1, j)\\n\\t* i - j >= 2: Such states can only be derived from the state [i - 1, j].  If [i, j] can come from [i, j - 1], it represents that in the current step, we use the second finger to type j-th character. However, since j < i, the j-th character have been typed. Contradiction!\\n\\t\\t* dp[i, j] = dp[i - 1, j] +dis(i - 1, i)\\n\\t* j - i >= 2: Same reason.\\n\\t\\t* dp[i, j] = dp[i, j - 1] + dis(j - 1, j)\\n\\t* i - j == 1: This state can be derived from these states: [0, j], [1, j], ..., [j - 1, j].\\n\\t\\t* dp[i, j] = min{dp[0, j], dp[1, j] + dis(1, i), ..., dp[j - 1, j] + dis(j - 1, i)}\\n\\t* j - i == 1: Same.\\n\\t\\t* dp[i, j] = min{dp[i, 0], dp[i, 1] + dis(1, j), ..., dp[i, i - 1] + dis(i - 1, j)}\\n\\n```\\nclass Solution {\\n    \\n    public int minimumDistance(String word) {\\n        int[][] dist = new int[26][26];\\n        for (int i = 0; i < 26; i++)\\n            for (int j = 0; j < 26; j++)\\n                dist[i][j] = dis(i, j);\\n        \\n        int n = word.length();\\n        char[] c = word.toCharArray();\\n        int[][] dp = new int[n + 1][n + 1];\\n        dp[0][1] = 0;\\n        dp[1][0] = 0;\\n        for (int i = 2; i <= n; i++) {\\n            dp[0][i] = dp[0][i - 1] + dist[c[i - 2] - \\'A\\'][c[i - 1] - \\'A\\'];\\n            dp[i][0] = dp[i - 1][0] + dist[c[i - 2] - \\'A\\'][c[i - 1] - \\'A\\'];\\n        }\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (i == j)\\n                    continue;\\n                if (j - i >= 2)\\n                    dp[i][j] = dp[i][j - 1] + dist[c[j - 2] - \\'A\\'][c[j - 1] - \\'A\\'];\\n                else if (i - j >= 2)\\n                    dp[i][j] = dp[i - 1][j] + dist[c[i - 2] - \\'A\\'][c[i - 1] - \\'A\\'];\\n                else if (j - i == 1) {\\n                    dp[i][j] = dp[i][0];\\n                    for (int k = 1; k < i; k++) \\n                        dp[i][j] = Math.min(dp[i][k] + dist[c[k - 1] - \\'A\\'][c[j - 1] - \\'A\\'], dp[i][j]);\\n                }\\n                else if (i - j == 1) {\\n                    dp[i][j] = dp[0][j];\\n                    for (int k = 1; k < j; k++)\\n                        dp[i][j] = Math.min(dp[k][j] + dist[c[k - 1] - \\'A\\'][c[i - 1] - \\'A\\'], dp[i][j]);\\n                }\\n            }\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for (int i = 0; i < n; i++) \\n            min = Math.min(min, dp[i][n]);\\n        return min;\\n    }\\n    \\n    public int dis(int i1, int i2) {\\n        int x1 = i1 / 6, y1 = i1 % 6;\\n        int x2 = i2 / 6, y2 = i2 % 6;\\n        return Math.abs(x1 - x2) + Math.abs(y1 - y2);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int minimumDistance(String word) {\\n        int[][] dist = new int[26][26];\\n        for (int i = 0; i < 26; i++)\\n            for (int j = 0; j < 26; j++)\\n                dist[i][j] = dis(i, j);\\n        \\n        int n = word.length();\\n        char[] c = word.toCharArray();\\n        int[][] dp = new int[n + 1][n + 1];\\n        dp[0][1] = 0;\\n        dp[1][0] = 0;\\n        for (int i = 2; i <= n; i++) {\\n            dp[0][i] = dp[0][i - 1] + dist[c[i - 2] - \\'A\\'][c[i - 1] - \\'A\\'];\\n            dp[i][0] = dp[i - 1][0] + dist[c[i - 2] - \\'A\\'][c[i - 1] - \\'A\\'];\\n        }\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (i == j)\\n                    continue;\\n                if (j - i >= 2)\\n                    dp[i][j] = dp[i][j - 1] + dist[c[j - 2] - \\'A\\'][c[j - 1] - \\'A\\'];\\n                else if (i - j >= 2)\\n                    dp[i][j] = dp[i - 1][j] + dist[c[i - 2] - \\'A\\'][c[i - 1] - \\'A\\'];\\n                else if (j - i == 1) {\\n                    dp[i][j] = dp[i][0];\\n                    for (int k = 1; k < i; k++) \\n                        dp[i][j] = Math.min(dp[i][k] + dist[c[k - 1] - \\'A\\'][c[j - 1] - \\'A\\'], dp[i][j]);\\n                }\\n                else if (i - j == 1) {\\n                    dp[i][j] = dp[0][j];\\n                    for (int k = 1; k < j; k++)\\n                        dp[i][j] = Math.min(dp[k][j] + dist[c[k - 1] - \\'A\\'][c[i - 1] - \\'A\\'], dp[i][j]);\\n                }\\n            }\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for (int i = 0; i < n; i++) \\n            min = Math.min(min, dp[i][n]);\\n        return min;\\n    }\\n    \\n    public int dis(int i1, int i2) {\\n        int x1 = i1 / 6, y1 = i1 % 6;\\n        int x2 = i2 / 6, y2 = i2 % 6;\\n        return Math.abs(x1 - x2) + Math.abs(y1 - y2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775985,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int minimumDistance(string word) {\\n        vector<int> dp(26);\\n        int res = 0, save = 0, n = word.size();\\n        for (int i = 0; i < n - 1; ++i) {\\n            int b = word[i] - \\'A\\', c = word[i + 1] - \\'A\\';\\n            for (int a = 0; a < 26; ++a)\\n                dp[b] = max(dp[b], dp[a] + d(b, c) - d(a, c));\\n            save = max(save, dp[b]);\\n            res += d(b, c);\\n        }\\n        return res - save;\\n    }\\n\\n    int d(int a, int b) {\\n        return abs(a / 6 - b / 6) + abs(a % 6 - b % 6);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int minimumDistance(string word) {\\n        vector<int> dp(26);\\n        int res = 0, save = 0, n = word.size();\\n        for (int i = 0; i < n - 1; ++i) {\\n            int b = word[i] - \\'A\\', c = word[i + 1] - \\'A\\';\\n            for (int a = 0; a < 26; ++a)\\n                dp[b] = max(dp[b], dp[a] + d(b, c) - d(a, c));\\n            save = max(save, dp[b]);\\n            res += d(b, c);\\n        }\\n        return res - save;\\n    }\\n\\n    int d(int a, int b) {\\n        return abs(a / 6 - b / 6) + abs(a % 6 - b % 6);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1831795,
                "title": "c-top-down-dp",
                "content": "```\\nclass Solution {\\n    vector<vector<vector<int>>> dp;\\n    \\n    int getCharDist(char a, char b) {\\n        int x1 = (a-\\'A\\') / 6, y1 = (a-\\'A\\') % 6;\\n        int x2 = (b-\\'A\\') / 6, y2 = (b-\\'A\\') % 6; \\n        return abs(x1 - x2) + abs(y1 - y2);\\n    }\\n    \\n    int rec(const string& word, int kthCharPos, char firstFingerAt, char secondFingerAt) {\\n        if (word.size() == kthCharPos) return 0;\\n        \\n        int& ret = dp[kthCharPos][firstFingerAt-\\'A\\'][secondFingerAt-\\'A\\'];\\n        if (ret != -1) return ret;\\n        \\n        int moveFirstFinger = rec(word, kthCharPos+1, word[kthCharPos], secondFingerAt) + getCharDist(firstFingerAt, word[kthCharPos]);\\n        int moveSecondFinger = rec(word, kthCharPos+1, firstFingerAt, word[kthCharPos]) + getCharDist(secondFingerAt, word[kthCharPos]);\\n        \\n        return ret = min(moveFirstFinger, moveSecondFinger);\\n    }\\n    \\npublic:\\n    int minimumDistance(string word) {\\n        dp.resize(word.size(), vector<vector<int>>(26, vector<int>(26, -1)));\\n        int minDist = INT_MAX;\\n\\n        for (char c = \\'A\\'; c <= \\'Z\\'; c++) {\\n            minDist = min(minDist, rec(word, 0, word[0], c));\\n        }\\n        \\n        return minDist;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "class Solution {\\n    vector<vector<vector<int>>> dp;\\n    \\n    int getCharDist(char a, char b) {\\n        int x1 = (a-\\'A\\') / 6, y1 = (a-\\'A\\') % 6;\\n        int x2 = (b-\\'A\\') / 6, y2 = (b-\\'A\\') % 6; \\n        return abs(x1 - x2) + abs(y1 - y2);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1509241,
                "title": "well-coded-clean-concise-93-faster",
                "content": "## Implementation:\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        def dist(pre,cur):\\n            if pre==None:\\n                return 0\\n            x1,y1 = divmod(ord(pre)-ord(\\'A\\'),6)\\n            x2,y2 = divmod(ord(cur)-ord(\\'A\\'),6)\\n            return abs(x1-x2) + abs(y1-y2)\\n        \\n        @lru_cache(None)\\n        def fingers(i,l,r):\\n            if i == len(word):\\n                return 0\\n            n1 = dist(l,word[i]) + fingers(i+1,word[i],r)\\n            n2 = dist(r,word[i]) + fingers(i+1,l,word[i])\\n            return min(n1,n2)\\n        \\n        return fingers(0,None,None)\\n\\n**feel free to ask if you need Explaination. \\uD83E\\uDD17**\\n### Thanks and Upvote If like the Idea !!\\uD83E\\uDD1E",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "## Implementation:\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        def dist(pre,cur):\\n            if pre==None:\\n                return 0\\n            x1,y1 = divmod(ord(pre)-ord(\\'A\\'),6)\\n            x2,y2 = divmod(ord(cur)-ord(\\'A\\'),6)\\n            return abs(x1-x2) + abs(y1-y2)\\n        \\n        @lru_cache(None)\\n        def fingers(i,l,r):\\n            if i == len(word):\\n                return 0\\n            n1 = dist(l,word[i]) + fingers(i+1,word[i],r)\\n            n2 = dist(r,word[i]) + fingers(i+1,l,word[i])\\n            return min(n1,n2)\\n        \\n        return fingers(0,None,None)\\n\\n**feel free to ask if you need Explaination. \\uD83E\\uDD17**\\n### Thanks and Upvote If like the Idea !!\\uD83E\\uDD1E",
                "codeTag": "Java"
            },
            {
                "id": 1435135,
                "title": "simple-solution-java-dfs-memorization",
                "content": "Simply we try to click on the characters of the word using either finger and check which path was cheeper.\\nTime complexity i think is going to be O(N * N) where N is the length the word and the memory is the same.\\n\\n```\\nclass Solution {\\n    int cache[][];\\n    public int minimumDistance(String word) {\\n        char[] arr = word.toCharArray();\\n        // adding one to the size to save the state of finger being off keyboard in index 0\\n\\t\\t// every other cache element is shifted by 1\\n        cache = new int[arr.length +1] [arr.length +1];\\n        for(int i = 0 ; i < arr.length; i++) {\\n            Arrays.fill(cache[i], -1);\\n        }\\n        return  dfs(0, -1 , arr, 1);\\n    }\\n\\n    public int dfs(int c, int c2 , char[] arr, int next) {\\n       if(next >= arr.length ) {\\n            return 0;\\n        }\\n        \\n        if(cache[c+1][c2+1] != -1) {\\n            return cache[c + 1][c2 +1];\\n        }\\n        \\n        int s1 = Integer.MAX_VALUE, s2 = Integer.MAX_VALUE;\\n        // Either use first finger for the next character\\n        s1 = dfs(next, c2 , arr, next + 1) + getCost(c, next, arr);  \\n        // use the second finger for the next character\\n        s2 = dfs(c, next, arr,  next +1) + getCost(c2, next, arr);     \\n        \\n        cache[c + 1][c2 + 1] = Math.min(s1,s2);\\n        return cache[c + 1][c2 + 1];\\n    }\\n    \\n    public int getCost(int c, int c2, char[] arr) {\\n        // c == -1 if finger was off the keyboard\\n        if( c == -1 || c2 == -1) {\\n            return 0;\\n        }\\n\\t\\t// this is taken from @rickyl22 solution\\n\\t\\t/*\\n\\t\\thttps://leetcode.com/problems/minimum-distance-to-type-a-word-using-two-fingers/discuss/477762/Java-DP-easy-to-understand-with-explanation\\n\\t\\t*/\\n        int source = arr[c] - \\'A\\';\\n        int target = arr[c2] - \\'A\\';\\n        if(source == 26) return 0;\\n        int y = source / 6;\\n        int x = source % 6;\\n        int y2 = target / 6;\\n        int x2 = target % 6;\\n        return Math.abs(y2-y) + Math.abs(x2-x);\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int cache[][];\\n    public int minimumDistance(String word) {\\n        char[] arr = word.toCharArray();\\n        // adding one to the size to save the state of finger being off keyboard in index 0\\n\\t\\t// every other cache element is shifted by 1\\n        cache = new int[arr.length +1] [arr.length +1];\\n        for(int i = 0 ; i < arr.length; i++) {\\n            Arrays.fill(cache[i], -1);\\n        }\\n        return  dfs(0, -1 , arr, 1);\\n    }\\n\\n    public int dfs(int c, int c2 , char[] arr, int next) {\\n       if(next >= arr.length ) {\\n            return 0;\\n        }\\n        \\n        if(cache[c+1][c2+1] != -1) {\\n            return cache[c + 1][c2 +1];\\n        }\\n        \\n        int s1 = Integer.MAX_VALUE, s2 = Integer.MAX_VALUE;\\n        // Either use first finger for the next character\\n        s1 = dfs(next, c2 , arr, next + 1) + getCost(c, next, arr);  \\n        // use the second finger for the next character\\n        s2 = dfs(c, next, arr,  next +1) + getCost(c2, next, arr);     \\n        \\n        cache[c + 1][c2 + 1] = Math.min(s1,s2);\\n        return cache[c + 1][c2 + 1];\\n    }\\n    \\n    public int getCost(int c, int c2, char[] arr) {\\n        // c == -1 if finger was off the keyboard\\n        if( c == -1 || c2 == -1) {\\n            return 0;\\n        }\\n\\t\\t// this is taken from @rickyl22 solution\\n\\t\\t/*\\n\\t\\thttps://leetcode.com/problems/minimum-distance-to-type-a-word-using-two-fingers/discuss/477762/Java-DP-easy-to-understand-with-explanation\\n\\t\\t*/\\n        int source = arr[c] - \\'A\\';\\n        int target = arr[c2] - \\'A\\';\\n        if(source == 26) return 0;\\n        int y = source / 6;\\n        int x = source % 6;\\n        int y2 = target / 6;\\n        int x2 = target % 6;\\n        return Math.abs(y2-y) + Math.abs(x2-x);\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1333768,
                "title": "java-just-another-top-down-recursion",
                "content": "Just like my other posts, this solution would most likely be on the lines of how one can approach the solution to a problem like this. It won\\'t be the most optimal one. \\n\\nSo, first let\\'s define what the question wants us to do: **Given the string word, return the minimum total distance to type such string using only two fingers.**. Now, let us write it in a function form:\\n\\nLet\\'s define a function fn() which does exactly this. *Function fn() returns the minimum total distance to type a string s with 2 fingers*. What all would be the variables? What all is needed for this function to work? There are 3 things required to get a solution to our function fn:-\\n\\n1. At which character in the word we are.\\n2. Where is our first finger located.\\n3. Where is our second finger located.\\n\\nDo we need to move both fingers at the same time (that is, should our state function be defined by the movement of both fingers in one state)? Or can we work with just moving one finger at a time (that is, we can define the state with just moving one finger at a time)? \\n\\nSince it is not required that the movement from character i -> j and then j -> k  (for any string s =  argt.....ijkyt..) be in any way dependent or related to which finger we move, we can go by the second approach.\\n\\nThus, our final function is:-\\n\\n```\\nfn(s, i, a, b): total minimum distance to type string s (ending at index i) with first finger at character a and the second finger at character b.\\n```\\n\\nNow that we have declared our function, let\\'s define it. How will this function be structured?\\n\\nFrom fn(s, i, a, b), we can go to fn(s, i-1, s[i], b) (that is, move the first finger from character a to character s[i]) and add the corresponding cost of moving the first finget from character a -> character s[i], OR we can go to fn(s, i-1, a, s[i]) (that is, we moved the second finder, from character b to character s[i]) and add the corresponding cost of moving the second finger from b -> s[i]. That is:\\n\\n```\\nfn(s,i,a,b) = min(dist(a, s[i]) + fn(s, i-1, s[i], b), dist(b, s[i]) + fn(s, i-1, a, s[i])).\\n```\\n\\nOkay. So we have figured out most of the question and it didn\\'t seem that hard. The one thing that took time for me to implement properly (because I am out of practice) was to get the cost of going from any character i -> j. That is it took me a little time to implement dist(i,j). How I went about it:\\n\\nWe can see that each row corresponds to 6 characters. If we index each character starting at 0, we can get at which row and col they are by using the divide and modulo operations respectively. Let\\'s take a few examples to understand it properly:\\nA => (i = 0) => (i/6 = 0 [implying 0th row]) => (i%6 = 0 [implying 0th column])\\nU => (i = 20) => (i/6 = 3 [implying 3rd row]) => (i%6 = 2 [implying 2nd col])\\nQ => (i = 16) => [2(i/6), 4[i%6]].\\nF => (i = 5) => [0,5]\\n\\nThus, we can now map indexes with their row and col. How to map their cost? It is also easy. Let\\'s say we have to move from F(0,5) -> U(3,2). We know that we can move along the lines of x and y axis only. That is, we have to go from x=0 to x=3 AND y=5 to y=3 (given that we treat x as horizontal axis and y as vertical axis). Thus, total movement would be movementAlongX + movementAlongY. That is, \\n\\n```\\nprivate int dist(i,j) {\\n\\tint x1 = i/6, y1 = i%6, x2 = j/6, y2 = j%6;\\n\\treturn Math.abs(x1-x2) + Math.abs(y1-y2);\\n}\\n```\\n\\nNow we have everything that we need. Let\\'s put it all into our final solution:-\\n\\n```\\n\\tint[][] map; //We create the distance map at the begining\\n    \\n    public int minimumDistance(String word) {\\n        initMap();\\n\\t\\t//I started from null characters. A null character tells that we have not used that finger (to press any character) till now. Since I did it, thus I need to be careful to handle it in my implementation.\\n        return fn(word, word.length()-1, \\'\\\\0\\', \\'\\\\0\\');\\n    }\\n    \\n    private void initMap() {\\n        map = new int[26][26];\\n        for(int i = 0; i < 26; i++) {\\n            for(int j = 0; j < 26; j++) {\\n                if(i == j) {\\n                    map[i][j] = 0; //No cost in moving from i to i OR j to j\\n                }\\n                else {\\n                    map[i][j] = dist(i, j);\\n                }\\n            }\\n        }\\n    }\\n    \\n    private int dist(int i, int j) {\\n        int x1 = i/6, y1 = i%6, x2 = j/6, y2 = j%6;\\n        return Math.abs(x1 - x2) + Math.abs(y1 - y2);\\n    }\\n    \\n    private int fn(String word, int i, char a, char b) {\\n        if(i < 0) {\\n            return 0;\\n        }\\n        char c = word.charAt(i);\\n        int movFirst = Integer.MAX_VALUE, movSec = Integer.MAX_VALUE;\\n\\t\\t//Either move the first finger from a -> c. Also handling the case if we have not used the first finger for any character till now.\\n        if(a != \\'\\\\0\\') {\\n            movFirst = \\n                map[a - \\'A\\'][c - \\'A\\'] + fn(word, i-1, c, b);\\n        }\\n        else {\\n            movFirst = fn(word, i-1, c, b);\\n        }\\n\\t\\t//Or move the second finger from b -> c. Similarly handle the null character case\\n        if(b != \\'\\\\0\\') {\\n            movSec = \\n                map[b - \\'A\\'][c - \\'A\\'] + fn(word, i-1, a, c);\\n        }\\n        else {\\n            movSec = fn(word, i-1, a, c);\\n        }\\n        int ans = Math.min(movFirst, movSec);\\n        return ans;\\n    }\\n```\\n\\nTime complexity: For building the map, we would need O(26\\\\*26) time. For executing one state, we would need O(1) time. How many states (how many brances possible for this recursion)? Well at every state, we have 2 options (either use the first finger, or the second finger). Thus, we can have O(2^m) states possible (m: length of word). Thus, final time complexity for unoptimized solution: O(26\\\\*26 + 2^m).\\n\\nHow can we optimize? We can memoize it based on the fact that once we land on any state, there are three params that define that state uniquely: the character that we are in (defined by index i), the position of the first finger (defined by a) and the position of the second finger (defined by b). Note that a and b could be represented as integer indexes for our dp array. Also, we might need to consider the null characters that we are using in our approach. Thus, the final memoized solution:\\n\\n```\\nint[][] map;\\n    Integer[][][] dp;\\n    \\n    public int minimumDistance(String word) {\\n        initMap();\\n        dp = new Integer[word.length()+1][27][27];\\n        return fn(word, word.length()-1, \\'\\\\0\\', \\'\\\\0\\');\\n    }\\n    \\n    private void initMap() {\\n        map = new int[26][26];\\n        for(int i = 0; i < 26; i++) {\\n            for(int j = 0; j < 26; j++) {\\n                if(i == j) {\\n                    map[i][j] = 0;\\n                }\\n                else {\\n                    map[i][j] = dist(i, j);\\n                }\\n            }\\n        }\\n    }\\n    \\n    private int dist(int i, int j) {\\n        int x1 = i/6, y1 = i%6, x2 = j/6, y2 = j%6;\\n        return Math.abs(x1 - x2) + Math.abs(y1 - y2);\\n    }\\n    \\n    private int fn(String word, int i, char a, char b) {\\n        if(i < 0) {\\n            return 0;\\n        }\\n        int ka = (a != \\'\\\\0\\') ? (a - \\'A\\'): 26;\\n        int kb = (b != \\'\\\\0\\') ? (b - \\'A\\'): 26;\\n        if(dp[i][ka][kb] != null) {\\n            return dp[i][ka][kb];\\n        }\\n        char c = word.charAt(i);\\n        int movFirst = Integer.MAX_VALUE, movSec = Integer.MAX_VALUE;\\n        if(a != \\'\\\\0\\') {\\n            movFirst = \\n                map[a - \\'A\\'][c - \\'A\\'] + fn(word, i-1, c, b);\\n        }\\n        else {\\n            movFirst = fn(word, i-1, c, b);\\n        }\\n        if(b != \\'\\\\0\\') {\\n            movSec = \\n                map[b - \\'A\\'][c - \\'A\\'] + fn(word, i-1, a, c);\\n        }\\n        else {\\n            movSec = fn(word, i-1, a, c);\\n        }\\n        int ans = Math.min(movFirst, movSec);\\n        dp[i][ka][kb] = ans;\\n        return ans;\\n    }\\n```\\n\\nFinal Time complexity: Time to execute function fn: O(1). Total number of times fn would be called for different states = total different states possible = 27\\\\*27\\\\*m. Thus, the final time complexity would be O(26\\\\*26 + 27\\\\*27\\\\*m) (m : length of string).\\nFinal space complexity: O(26\\\\*26) (for the dist map) + O(27 \\\\* 27 \\\\* m) (for the dp 3D array).",
                "solutionTags": [],
                "code": "```\\nfn(s, i, a, b): total minimum distance to type string s (ending at index i) with first finger at character a and the second finger at character b.\\n```\n```\\nfn(s,i,a,b) = min(dist(a, s[i]) + fn(s, i-1, s[i], b), dist(b, s[i]) + fn(s, i-1, a, s[i])).\\n```\n```\\nprivate int dist(i,j) {\\n\\tint x1 = i/6, y1 = i%6, x2 = j/6, y2 = j%6;\\n\\treturn Math.abs(x1-x2) + Math.abs(y1-y2);\\n}\\n```\n```\\n\\tint[][] map; //We create the distance map at the begining\\n    \\n    public int minimumDistance(String word) {\\n        initMap();\\n\\t\\t//I started from null characters. A null character tells that we have not used that finger (to press any character) till now. Since I did it, thus I need to be careful to handle it in my implementation.\\n        return fn(word, word.length()-1, \\'\\\\0\\', \\'\\\\0\\');\\n    }\\n    \\n    private void initMap() {\\n        map = new int[26][26];\\n        for(int i = 0; i < 26; i++) {\\n            for(int j = 0; j < 26; j++) {\\n                if(i == j) {\\n                    map[i][j] = 0; //No cost in moving from i to i OR j to j\\n                }\\n                else {\\n                    map[i][j] = dist(i, j);\\n                }\\n            }\\n        }\\n    }\\n    \\n    private int dist(int i, int j) {\\n        int x1 = i/6, y1 = i%6, x2 = j/6, y2 = j%6;\\n        return Math.abs(x1 - x2) + Math.abs(y1 - y2);\\n    }\\n    \\n    private int fn(String word, int i, char a, char b) {\\n        if(i < 0) {\\n            return 0;\\n        }\\n        char c = word.charAt(i);\\n        int movFirst = Integer.MAX_VALUE, movSec = Integer.MAX_VALUE;\\n\\t\\t//Either move the first finger from a -> c. Also handling the case if we have not used the first finger for any character till now.\\n        if(a != \\'\\\\0\\') {\\n            movFirst = \\n                map[a - \\'A\\'][c - \\'A\\'] + fn(word, i-1, c, b);\\n        }\\n        else {\\n            movFirst = fn(word, i-1, c, b);\\n        }\\n\\t\\t//Or move the second finger from b -> c. Similarly handle the null character case\\n        if(b != \\'\\\\0\\') {\\n            movSec = \\n                map[b - \\'A\\'][c - \\'A\\'] + fn(word, i-1, a, c);\\n        }\\n        else {\\n            movSec = fn(word, i-1, a, c);\\n        }\\n        int ans = Math.min(movFirst, movSec);\\n        return ans;\\n    }\\n```\n```\\nint[][] map;\\n    Integer[][][] dp;\\n    \\n    public int minimumDistance(String word) {\\n        initMap();\\n        dp = new Integer[word.length()+1][27][27];\\n        return fn(word, word.length()-1, \\'\\\\0\\', \\'\\\\0\\');\\n    }\\n    \\n    private void initMap() {\\n        map = new int[26][26];\\n        for(int i = 0; i < 26; i++) {\\n            for(int j = 0; j < 26; j++) {\\n                if(i == j) {\\n                    map[i][j] = 0;\\n                }\\n                else {\\n                    map[i][j] = dist(i, j);\\n                }\\n            }\\n        }\\n    }\\n    \\n    private int dist(int i, int j) {\\n        int x1 = i/6, y1 = i%6, x2 = j/6, y2 = j%6;\\n        return Math.abs(x1 - x2) + Math.abs(y1 - y2);\\n    }\\n    \\n    private int fn(String word, int i, char a, char b) {\\n        if(i < 0) {\\n            return 0;\\n        }\\n        int ka = (a != \\'\\\\0\\') ? (a - \\'A\\'): 26;\\n        int kb = (b != \\'\\\\0\\') ? (b - \\'A\\'): 26;\\n        if(dp[i][ka][kb] != null) {\\n            return dp[i][ka][kb];\\n        }\\n        char c = word.charAt(i);\\n        int movFirst = Integer.MAX_VALUE, movSec = Integer.MAX_VALUE;\\n        if(a != \\'\\\\0\\') {\\n            movFirst = \\n                map[a - \\'A\\'][c - \\'A\\'] + fn(word, i-1, c, b);\\n        }\\n        else {\\n            movFirst = fn(word, i-1, c, b);\\n        }\\n        if(b != \\'\\\\0\\') {\\n            movSec = \\n                map[b - \\'A\\'][c - \\'A\\'] + fn(word, i-1, a, c);\\n        }\\n        else {\\n            movSec = fn(word, i-1, a, c);\\n        }\\n        int ans = Math.min(movFirst, movSec);\\n        dp[i][ka][kb] = ans;\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1184921,
                "title": "c-basic-recursion-memo-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int t[27][27][301];\\n    int minimumDistance(string word) {\\n        \\n        memset(t, -1, sizeof(t));\\n        \\n        int ans = solve(word, -1, -1, 0);\\n        \\n        return ans;\\n    }\\n    \\n    int solve(string& word, int fing1, int fing2, int k)\\n    {\\n        if(k >= word.size())\\n            return 0;\\n        \\n        if(t[fing1 + 1][fing2 + 1][k] != -1) // displaced by 1 because we start with -1\\n            return t[fing1 + 1][fing2 + 1][k];\\n        \\n        int interim = word[k] - \\'A\\'; // index of word[k] when started from A = 0\\n        \\n        pair <int, int> a = {interim / 6, interim % 6};  // row = interim / 6, column = interim % 6\\n\\t\\t\\n\\t\\t//temp1 and temp2 are distances which are equal to 0 when we start i.e. fing1  = -1 and fing2 = -1, else, we claculate the distance\\n        \\n        int temp1 = ((fing1 == -1) ? 0 : (abs(a.first - fing1 / 6) + abs(a.second - fing1 % 6)));\\n        int temp2 = ((fing2 == -1) ? 0 : (abs(a.first - fing2 / 6) + abs(a.second - fing2 % 6)));\\n        \\n        int ans = temp1 + solve(word, interim, fing2, k + 1); //we choose finger 1 to point the particular word[k], \\n//and when we do this, our finger1 is supposed to point at that word[k], hence insted of finger 1 we used interim.\\n        \\n        ans = min(ans, temp2 + solve(word, fing1, interim, k + 1)); // here we chose finger 2 and the same theory applies.\\n        \\n        return t[fing1 + 1][fing2 + 1][k] = ans;\\n    }\\n};\\n\\n/*\\n    a / 6 - row\\n    a % 6 - column\\n*/\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int t[27][27][301];\\n    int minimumDistance(string word) {\\n        \\n        memset(t, -1, sizeof(t));\\n        \\n        int ans = solve(word, -1, -1, 0);\\n        \\n        return ans;\\n    }\\n    \\n    int solve(string& word, int fing1, int fing2, int k)\\n    {\\n        if(k >= word.size())\\n            return 0;\\n        \\n        if(t[fing1 + 1][fing2 + 1][k] != -1) // displaced by 1 because we start with -1\\n            return t[fing1 + 1][fing2 + 1][k];\\n        \\n        int interim = word[k] - \\'A\\'; // index of word[k] when started from A = 0\\n        \\n        pair <int, int> a = {interim / 6, interim % 6};  // row = interim / 6, column = interim % 6\\n\\t\\t\\n\\t\\t//temp1 and temp2 are distances which are equal to 0 when we start i.e. fing1  = -1 and fing2 = -1, else, we claculate the distance\\n        \\n        int temp1 = ((fing1 == -1) ? 0 : (abs(a.first - fing1 / 6) + abs(a.second - fing1 % 6)));\\n        int temp2 = ((fing2 == -1) ? 0 : (abs(a.first - fing2 / 6) + abs(a.second - fing2 % 6)));\\n        \\n        int ans = temp1 + solve(word, interim, fing2, k + 1); //we choose finger 1 to point the particular word[k], \\n//and when we do this, our finger1 is supposed to point at that word[k], hence insted of finger 1 we used interim.\\n        \\n        ans = min(ans, temp2 + solve(word, fing1, interim, k + 1)); // here we chose finger 2 and the same theory applies.\\n        \\n        return t[fing1 + 1][fing2 + 1][k] = ans;\\n    }\\n};\\n\\n/*\\n    a / 6 - row\\n    a % 6 - column\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 722688,
                "title": "python-simple-dfs-with-memoization-with-explanation",
                "content": "The intuition is pretty much the same as all the other DP ones in here. However I thought it might help people to see it in it\\'s top-down format to understand how we are getting to those tabular DP solutions.\\nYou can simplify the problem to a normal min path question. At each step starting with the first letter in `word` we have two options, to type it using with one of our two fingers. Using each finger adds the cost equal to the distance of whatever that finger used to be on, and our new letter of the word. Which basically turns it into a simple min path recursion.\\n\\nWe also add -1 to our getDist() function as a special case. Basically considering it as a special character with 0 distance to all other chars.\\n\\n```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        def getDist(a,b):\\n            if a==-1 or b==-1: \\n                return 0 # -1 means fingers are not on keys yet so their distance to everything is 0\\n            else:\\n                i = ord(a)-ord(\\'a\\')\\n                j = ord(b)-ord(\\'a\\')\\n                return abs(i//6-j//6) + abs(i%6-j%6)\\n\\n        # Just a simple dfs for finding the min path.\\n        # We have 2 options at each point, to use the left or right finger to type the next word.\\n        @lru_cache(maxsize=None)\\n        def getMinDist(l,r,k):\\n            if k == len(word):return 0\\n            next = word[k].lower()\\n            ret = min(getMinDist(next,r,k+1)+getDist(l,next), getMinDist(l,next,k+1)+getDist(r,next))\\n            return ret\\n            \\n        return(getMinDist(-1,-1,0))",
                "solutionTags": [],
                "code": "The intuition is pretty much the same as all the other DP ones in here. However I thought it might help people to see it in it\\'s top-down format to understand how we are getting to those tabular DP solutions.\\nYou can simplify the problem to a normal min path question. At each step starting with the first letter in `word` we have two options, to type it using with one of our two fingers. Using each finger adds the cost equal to the distance of whatever that finger used to be on, and our new letter of the word. Which basically turns it into a simple min path recursion.\\n\\nWe also add -1 to our getDist() function as a special case. Basically considering it as a special character with 0 distance to all other chars.\\n\\n```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        def getDist(a,b):\\n            if a==-1 or b==-1: \\n                return 0 # -1 means fingers are not on keys yet so their distance to everything is 0\\n            else:\\n                i = ord(a)-ord(\\'a\\')\\n                j = ord(b)-ord(\\'a\\')\\n                return abs(i//6-j//6) + abs(i%6-j%6)\\n\\n        # Just a simple dfs for finding the min path.\\n        # We have 2 options at each point, to use the left or right finger to type the next word.\\n        @lru_cache(maxsize=None)\\n        def getMinDist(l,r,k):\\n            if k == len(word):return 0\\n            next = word[k].lower()\\n            ret = min(getMinDist(next,r,k+1)+getDist(l,next), getMinDist(l,next,k+1)+getDist(r,next))\\n            return ret\\n            \\n        return(getMinDist(-1,-1,0))",
                "codeTag": "Java"
            },
            {
                "id": 684155,
                "title": "java-2ms-with-comments-beats-100-submissions-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\n    public int minimumDistance(String word) {\\n        int[] keys = new int[word.length()];\\n        for (int i = 0; i < word.length(); i++) keys[i] = word.charAt(i) - \\'A\\';\\n\\n        // precompute costs between all keys\\n        // key 26 - is a \\'finger off the keyboard\\' key, cost[26][*] = 0\\n        // we can only go from \\'finger off\\' to some other key not vice versa\\n        int[][] cost = new int[27][26];\\n        for (int i = 0; i < 26; i++) {\\n            for (int j = i; j < 26; j++) {\\n                cost[i][j] = Math.abs(i/6 - j/6) + Math.abs(i%6 - j%6);\\n                cost[j][i] = cost[i][j];\\n            }\\n        }\\n        \\n        // dp[j] represents minimum dististance from current char/key till the end of the word\\n        // with one finger (leading) always being at prev key and the other\\n        // finger at an unknown key j prior to prev key - we try all posibile keys for j\\n        int[] dp = new int[27];\\n        \\n        for (int i = keys.length - 1; i > 0; i--) {\\n            // below var enables memory optimisation - reuse of the same 0->26 dp slots from previous iterations\\n            int dp_for_key_at_i_minus_1 = dp[keys[i - 1]];\\n            int cost_i_minus_1_to_i = cost[keys[i - 1]][keys[i]];\\n            for (int j = 0; j < 27; j++) {\\n                // lagging finger at j, leading finger at i - 1\\n                // either of the two can move hence two options below\\n                dp[j] = Math.min(\\n                    // lagging finger moves, i.e. current leading becomes lagging, paying cost from lagging to i\\n                    dp_for_key_at_i_minus_1 + cost[j][keys[i]], \\n                    // leading finger moves, i.e. lagging remains lagging, paying cost from leading to i\\n                    dp[j] + cost_i_minus_1_to_i);\\n            }\\n        }\\n        \\n        return dp[26];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDistance(String word) {\\n        int[] keys = new int[word.length()];\\n        for (int i = 0; i < word.length(); i++) keys[i] = word.charAt(i) - \\'A\\';\\n\\n        // precompute costs between all keys\\n        // key 26 - is a \\'finger off the keyboard\\' key, cost[26][*] = 0\\n        // we can only go from \\'finger off\\' to some other key not vice versa\\n        int[][] cost = new int[27][26];\\n        for (int i = 0; i < 26; i++) {\\n            for (int j = i; j < 26; j++) {\\n                cost[i][j] = Math.abs(i/6 - j/6) + Math.abs(i%6 - j%6);\\n                cost[j][i] = cost[i][j];\\n            }\\n        }\\n        \\n        // dp[j] represents minimum dististance from current char/key till the end of the word\\n        // with one finger (leading) always being at prev key and the other\\n        // finger at an unknown key j prior to prev key - we try all posibile keys for j\\n        int[] dp = new int[27];\\n        \\n        for (int i = keys.length - 1; i > 0; i--) {\\n            // below var enables memory optimisation - reuse of the same 0->26 dp slots from previous iterations\\n            int dp_for_key_at_i_minus_1 = dp[keys[i - 1]];\\n            int cost_i_minus_1_to_i = cost[keys[i - 1]][keys[i]];\\n            for (int j = 0; j < 27; j++) {\\n                // lagging finger at j, leading finger at i - 1\\n                // either of the two can move hence two options below\\n                dp[j] = Math.min(\\n                    // lagging finger moves, i.e. current leading becomes lagging, paying cost from lagging to i\\n                    dp_for_key_at_i_minus_1 + cost[j][keys[i]], \\n                    // leading finger moves, i.e. lagging remains lagging, paying cost from leading to i\\n                    dp[j] + cost_i_minus_1_to_i);\\n            }\\n        }\\n        \\n        return dp[26];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 672221,
                "title": "java-3d-dp-solution-looping-forwards-with-a-clear-definition-of-dp-i-j-k",
                "content": "\\n```\\nclass Solution {\\n    public int minimumDistance(String word) {\\n        \\n        //dp[i][j][k] := minimum distance to type word[0...k] with left finger ending @ i, right finger ending @ j\\n        int[][][] dp = new int[26][26][word.length()];\\n        \\n        //key idea: need to go through all possibilities (and save progress via memoization)\\n        \\n        //init\\n        //need to populate all entries w/ big number (to represent infinity) \\n        for(int k = 0; k < word.length(); k++){\\n            for(int i = 0; i < 26; i++) {\\n                for(int j = 0; j < 26; j++) {\\n                    dp[i][j][k] = Integer.MAX_VALUE/2; // div. by 2 to prevent overflow\\n                }\\n            }\\n        }\\n        \\n        //deal with base case\\n        int charK = word.charAt(0) - \\'A\\'; //the translation from char -> 0..25\\n        for(int i = 0; i < 26; i++) {\\n            dp[charK][i][0] = 0; //right finger on first letter of word, other finger on everything else \\n            dp[i][charK][0] = 0; //left finger on first letter of word, other finger on everything else\\n        }\\n        \\n        \\n        int res = Integer.MAX_VALUE;\\n        \\n        for(int k = 1; k < word.length(); k++) {\\n            \\n            charK = word.charAt(k) - \\'A\\';\\n            //in the following loops, find BEST possible way to end up w/ ONE finger at charK\\n            \\n            for(int i = 0; i < 26; i++) {//plant i as either the left or right finger\\n                                         //ex, i = 0, so plant left finger on A (or right finger on A)\\n                                         //now, GIVEN left finger on A, explore right finger coming FROM every letter to charK (same idea for GIVEN right finger on A, \"\")\\n                                         //key idea: explore all possibilities. You know that one of the fingers has to END up on charK, BUT the other finger can be on ANYTHING, and the finger which ends up on charK could\\'ve come from ANYTHING!\\n                \\n                for(int j = 0; j < 26; j++) {//explore opp finger coming from SOME letter -> charK\\n                    \\n                    //i is planted as right finger\\n                    //left finger ends up at charK\\n                    dp[charK][i][k] = Math.min(dp[charK][i][k], dp[j][i][k-1] + d(j, charK)); //either already have optimal answer, or found some j from which the left finger is coming from -> charK such that have better answer\\n                    \\n                    //i is planted as left finger\\n                    //right finger ends up at charK\\n                    dp[i][charK][k] = Math.min(dp[i][charK][k], dp[i][j][k-1] + d(j,charK));\\n                    \\n                }\\n                \\n                //at the last layer\\n                if(k==word.length()-1){\\n                    //one of the fingers has to be @ charK\\n                    res = Math.min(res,dp[i][charK][k]);\\n                    \\n                    //following not necessary b/c dp[i][charK][k] should == dp[charK][i][k] \\n                    //res = Math.min(res, dp[charK][i][k]);\\n                                                            \\n                }\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n    \\n    //calc\\'s distance between \"char\" a and b\\n    private int d(int a, int b) {\\n        return Math.abs(a / 6 - b / 6) + Math.abs(a % 6 - b % 6);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDistance(String word) {\\n        \\n        //dp[i][j][k] := minimum distance to type word[0...k] with left finger ending @ i, right finger ending @ j\\n        int[][][] dp = new int[26][26][word.length()];\\n        \\n        //key idea: need to go through all possibilities (and save progress via memoization)\\n        \\n        //init\\n        //need to populate all entries w/ big number (to represent infinity) \\n        for(int k = 0; k < word.length(); k++){\\n            for(int i = 0; i < 26; i++) {\\n                for(int j = 0; j < 26; j++) {\\n                    dp[i][j][k] = Integer.MAX_VALUE/2; // div. by 2 to prevent overflow\\n                }\\n            }\\n        }\\n        \\n        //deal with base case\\n        int charK = word.charAt(0) - \\'A\\'; //the translation from char -> 0..25\\n        for(int i = 0; i < 26; i++) {\\n            dp[charK][i][0] = 0; //right finger on first letter of word, other finger on everything else \\n            dp[i][charK][0] = 0; //left finger on first letter of word, other finger on everything else\\n        }\\n        \\n        \\n        int res = Integer.MAX_VALUE;\\n        \\n        for(int k = 1; k < word.length(); k++) {\\n            \\n            charK = word.charAt(k) - \\'A\\';\\n            //in the following loops, find BEST possible way to end up w/ ONE finger at charK\\n            \\n            for(int i = 0; i < 26; i++) {//plant i as either the left or right finger\\n                                         //ex, i = 0, so plant left finger on A (or right finger on A)\\n                                         //now, GIVEN left finger on A, explore right finger coming FROM every letter to charK (same idea for GIVEN right finger on A, \"\")\\n                                         //key idea: explore all possibilities. You know that one of the fingers has to END up on charK, BUT the other finger can be on ANYTHING, and the finger which ends up on charK could\\'ve come from ANYTHING!\\n                \\n                for(int j = 0; j < 26; j++) {//explore opp finger coming from SOME letter -> charK\\n                    \\n                    //i is planted as right finger\\n                    //left finger ends up at charK\\n                    dp[charK][i][k] = Math.min(dp[charK][i][k], dp[j][i][k-1] + d(j, charK)); //either already have optimal answer, or found some j from which the left finger is coming from -> charK such that have better answer\\n                    \\n                    //i is planted as left finger\\n                    //right finger ends up at charK\\n                    dp[i][charK][k] = Math.min(dp[i][charK][k], dp[i][j][k-1] + d(j,charK));\\n                    \\n                }\\n                \\n                //at the last layer\\n                if(k==word.length()-1){\\n                    //one of the fingers has to be @ charK\\n                    res = Math.min(res,dp[i][charK][k]);\\n                    \\n                    //following not necessary b/c dp[i][charK][k] should == dp[charK][i][k] \\n                    //res = Math.min(res, dp[charK][i][k]);\\n                                                            \\n                }\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n    \\n    //calc\\'s distance between \"char\" a and b\\n    private int d(int a, int b) {\\n        return Math.abs(a / 6 - b / 6) + Math.abs(a % 6 - b % 6);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 656305,
                "title": "dp-solution-o-n-space-2-dim-dp-iterative-explained",
                "content": "Step 1:- [Defining the States of DP]\\n\\nHere state of dp is identified by the position of two fingre i.e i,j.\\n\\nStep 2:- [Identifing the Base Case for the solution]\\n\\nFinal state will be any of dp[ i ][ n ] where 0<=i<n  and it is 0(zero) because there is no need for furthur transition  as final state is reached by typing letter at postion n which is last letter.\\n\\nStep 3 :- [Identifing the Relation between the dp States and framing an Equation]\\n\\nconsider you have solutions for state dp[ j ][  i + 1 ] where 0<=j<i+1. \\n\\nNow It is possible to find solution for states dp[ j ][ i ] where 0<=j<i as\\n\\ndp[ j ][ i ] = min( dp[ i ][ i + 1 ] + disted(j,i+1),  dp[ j ][ i + 1 ] + disted(i,i+1) );\\n\\nHere disted( i, j ) will be used to calculate distance between letters at position i and j respectively.\\n\\n1.dp[ i ][ i + 1 ] + disted(j,i+1)    :-\\n\\t\\tfrom dp[ j ][ i ] state if finger at j is moved to i+1 position it reaches to the state dp[ i ][ i+1] (i.e one finger at position i and another finger is at position i+1)  by travelling distance of disted( j, i+1).\\n\\n2.dp[ j ][ i + 1 ] + disted(i,i+1)   :-\\n\\t\\tfrom dp[ j ][ i ] state if finger at i is moved to i+1 position it reaches to the state dp[ j ][ i+1] (i.e one finger at position i and another finger is at position i+1)  by travelling distance of disted( i, i+1).\\n\\nAt the end dp[ j ][ i ] holds the minimum distance  to be travelled to reach the final state [i.e. answer] from the state dp[ j ][ i ].\\n\\n```\\nclass Solution {\\n    string w;\\npublic:\\n    int minimumDistance(string word) {\\n        int n = word.size();\\n        w= \" \"+word;\\n        int dp[n+1][n+1];\\n        \\n        for(int i = 0 ; i < n ; i++)\\n            dp[i][n] = 0;\\n        \\n        for(int i = n-1 ; i>0 ; i--)\\n        {\\n            for(int j = i-1 ; j >=0 ; j--)\\n            {\\n                dp[j][i] = min(dp[i][i+1]+disted(j,i+1),dp[j][i+1]+disted(i,i+1));\\n            }\\n            \\n        }\\n        return min(dp[0][1],dp[1][2]);\\n     }\\n    \\n    int disted(int i,int j)\\n    {\\n        if(j==0 || i==0)return 0;\\n        \\n        i = w[i]-\\'A\\',j=w[j]-\\'A\\';\\n        \\n        return abs(i/6 - j/6) + abs(i%6 - j%6);\\n    }    \\n\\t\\n\\t};\\n```\\n\\nThe below solution is O(n) space :-\\n\\n```\\nclass Solution {\\n    string w;\\npublic:\\n    int minimumDistance(string word) {\\n        int n = word.size();\\n        w= \" \"+word;\\n        int dp[n+1][2];\\n        \\n        for(int i = 0 ; i < n ; i++)\\n            dp[i][n%2] = 0;\\n        \\n        for(int i = n-1 ; i>0 ; i--)\\n        {\\n            for(int j = i-1 ; j >=0 ; j--)\\n            {\\n                dp[j][i%2] = min(dp[i][(i+1)%2]+disted(j,i+1),dp[j][(i+1)%2]+disted(i,i+1));\\n            }\\n            \\n        }\\n        return min(dp[0][1%2],dp[1][2%2]);\\n     }\\n    \\n    int disted(int i,int j)\\n    {\\n        if(j==0 || i==0)return 0;\\n        \\n        i = w[i]-\\'A\\',j=w[j]-\\'A\\';\\n        \\n        return abs(i/6 - j/6) + abs(i%6 - j%6);\\n    }    \\n\\t\\n\\t};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    string w;\\npublic:\\n    int minimumDistance(string word) {\\n        int n = word.size();\\n        w= \" \"+word;\\n        int dp[n+1][n+1];\\n        \\n        for(int i = 0 ; i < n ; i++)\\n            dp[i][n] = 0;\\n        \\n        for(int i = n-1 ; i>0 ; i--)\\n        {\\n            for(int j = i-1 ; j >=0 ; j--)\\n            {\\n                dp[j][i] = min(dp[i][i+1]+disted(j,i+1),dp[j][i+1]+disted(i,i+1));\\n            }\\n            \\n        }\\n        return min(dp[0][1],dp[1][2]);\\n     }\\n    \\n    int disted(int i,int j)\\n    {\\n        if(j==0 || i==0)return 0;\\n        \\n        i = w[i]-\\'A\\',j=w[j]-\\'A\\';\\n        \\n        return abs(i/6 - j/6) + abs(i%6 - j%6);\\n    }    \\n\\t\\n\\t};\\n```\n```\\nclass Solution {\\n    string w;\\npublic:\\n    int minimumDistance(string word) {\\n        int n = word.size();\\n        w= \" \"+word;\\n        int dp[n+1][2];\\n        \\n        for(int i = 0 ; i < n ; i++)\\n            dp[i][n%2] = 0;\\n        \\n        for(int i = n-1 ; i>0 ; i--)\\n        {\\n            for(int j = i-1 ; j >=0 ; j--)\\n            {\\n                dp[j][i%2] = min(dp[i][(i+1)%2]+disted(j,i+1),dp[j][(i+1)%2]+disted(i,i+1));\\n            }\\n            \\n        }\\n        return min(dp[0][1%2],dp[1][2%2]);\\n     }\\n    \\n    int disted(int i,int j)\\n    {\\n        if(j==0 || i==0)return 0;\\n        \\n        i = w[i]-\\'A\\',j=w[j]-\\'A\\';\\n        \\n        return abs(i/6 - j/6) + abs(i%6 - j%6);\\n    }    \\n\\t\\n\\t};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 640140,
                "title": "from-3d-dp-to-2d-and-1d-explanation-is-easy-to-understand",
                "content": "The best straighforward solution is just the DFS + DP, which is in fact a 3D DP solution. \\n\\n```java\\nint[][][] memo;\\npublic int minimumDistance_3d(String word) {\\n\\tif (word == null) return 0;\\n\\tint length = word.length();\\n\\tif (length == 1 || length ==2) return 0;\\n\\tmemo = new int[length][27][27];\\n\\treturn helper(word, 0, 26, 26);\\n}\\n\\nprivate int helper(String word, int index, int lastLeft, int lastRight) {\\n\\tif (index >= word.length()) return 0;\\n\\tif (memo[index][lastLeft][lastRight] == 0) {\\n\\t\\tint charIndex = word.charAt(index) - \\'A\\';\\n\\t\\tmemo[index][lastLeft][lastRight] = Math.min(\\n\\t\\t\\tgetDistance(lastLeft, charIndex) + helper(word, index + 1, charIndex, lastRight),\\n\\t\\t\\tgetDistance(lastRight, charIndex) + helper(word, index + 1, lastLeft, charIndex));\\n\\t}\\n\\n\\treturn memo[index][lastLeft][lastRight];\\n}\\n\\nprivate int getDistance(int from, int to) {\\n\\tif (from == 26) return 0;\\n\\treturn Math.abs(from / 6 - to / 6) + Math.abs(from % 6 - to % 6);\\n\\n}\\n```\\n\\t\\nSince it is using the DFS backtracking, this solution should be easy to understand and implement. You will later find that, after inputing one char from the string, one hand will remain unchanged, and it indicates that we do not need to record both `lastLeft` and `lastRight` status. With the param `index`, we can easily know the last status of one hand, and we track another status in param `other`. Thus, we can implement a 2D solution:\\n\\n```java\\nint[][] dp;\\npublic int minimumDistance_2d_top_bottom(String word) {\\n\\tif (word == null) return 0;\\n\\tint length = word.length();\\n\\tif (length == 1 || length ==2) return 0;\\n\\tdp = new int[length][27];\\n\\treturn helper2(word, 1, 26); // note: we can start from 1 (think why)\\n}\\n\\nprivate int helper2(String word, int index, int other) {\\n\\tif (index >= word.length()) return 0;\\n\\tif (dp[index][other] == 0) {\\n\\t\\tint curCharIndex = word.charAt(index) - \\'A\\', preCharIndex = word.charAt(index - 1) - \\'A\\';\\n\\t\\tdp[index][other] = Math.min(\\n\\t\\t\\tgetDistance(preCharIndex, curCharIndex) + helper2(word, index + 1, other),\\n\\t\\t\\tgetDistance(other, curCharIndex) + helper2(word, index + 1, preCharIndex)\\n\\t\\t);\\n\\t}\\n\\treturn dp[index][other];\\n}\\n```\\n\\nAll of the solutions above are top-bottom, as we want to associate them with the DFS. You wil find that, in the 2D top-bottom solution, the current DP value in func `helper2` depends on the values of the next line of DP array; in other words, `dp[index][...]` will depend on `dp[index+1][...]`. Thus, a top-bottom solution (pure DP) could be easily implemented.\\n\\n```java\\npublic int minimumDistance_2d_bottom_up(String word) {\\n        if (word == null) return 0;\\n        int length = word.length();\\n        if (length == 1 || length ==2) return 0;\\n        int[][] dpArray = new int[length][27];\\n        for (int i = length - 1; i >= 1; i--) {  // we don\\'t need the value when i = 0;\\n            int curCharIndex = word.charAt(i) - \\'A\\', preCharIndex = word.charAt(i - 1) - \\'A\\';\\n            for (int j = 0; j < 27; j++) {\\n                dpArray[i][j] = Math.min(\\n                    getDistance(preCharIndex, curCharIndex) + (i == length - 1? 0: dpArray[i+1][j]),\\n                    getDistance(j, curCharIndex) + (i == length - 1? 0: dpArray[i+1][preCharIndex])\\n                );\\n            }\\n        }\\n        return dpArray[1][26];\\n    }\\n```\\n\\nOnce again, we found that `dp[index][...]` will depend on and ONLY on  `dp[index+1][...]`. Thus, we do not need to track all values in the dp array.\\n\\n```java\\npublic int minimumDistance(String word) {\\n\\tif (word == null) return 0;\\n\\tint length = word.length();\\n\\tif (length == 1 || length ==2) return 0;\\n\\tint[] dpArray = new int[27];\\n\\tfor (int i = length - 1; i >= 1; i --) {\\n\\t\\tint[] tmp = new int[27];\\n\\t\\tint curCharIndex = word.charAt(i) - \\'A\\', preCharIndex = word.charAt(i - 1) - \\'A\\';\\n\\t\\tfor (int j = 0; j < 27; j++) {\\n\\t\\t\\ttmp[j] = Math.min(\\n\\t\\t\\t\\tgetDistance(preCharIndex, curCharIndex) + (i == length - 1? 0: dpArray[j]),\\n\\t\\t\\t\\tgetDistance(j, curCharIndex) + (i == length - 1? 0: dpArray[preCharIndex])\\n\\t\\t\\t);\\n\\t\\t}\\n\\t\\tdpArray = tmp;\\n\\t}\\n\\treturn dpArray[26];\\n}\\n```\\n\\nIn this solution, we only have 2 1D arrays with fixed length (O(1) space); time complexity is O(length).\\n\\t",
                "solutionTags": [],
                "code": "```java\\nint[][][] memo;\\npublic int minimumDistance_3d(String word) {\\n\\tif (word == null) return 0;\\n\\tint length = word.length();\\n\\tif (length == 1 || length ==2) return 0;\\n\\tmemo = new int[length][27][27];\\n\\treturn helper(word, 0, 26, 26);\\n}\\n\\nprivate int helper(String word, int index, int lastLeft, int lastRight) {\\n\\tif (index >= word.length()) return 0;\\n\\tif (memo[index][lastLeft][lastRight] == 0) {\\n\\t\\tint charIndex = word.charAt(index) - \\'A\\';\\n\\t\\tmemo[index][lastLeft][lastRight] = Math.min(\\n\\t\\t\\tgetDistance(lastLeft, charIndex) + helper(word, index + 1, charIndex, lastRight),\\n\\t\\t\\tgetDistance(lastRight, charIndex) + helper(word, index + 1, lastLeft, charIndex));\\n\\t}\\n\\n\\treturn memo[index][lastLeft][lastRight];\\n}\\n\\nprivate int getDistance(int from, int to) {\\n\\tif (from == 26) return 0;\\n\\treturn Math.abs(from / 6 - to / 6) + Math.abs(from % 6 - to % 6);\\n\\n}\\n```\n```java\\nint[][] dp;\\npublic int minimumDistance_2d_top_bottom(String word) {\\n\\tif (word == null) return 0;\\n\\tint length = word.length();\\n\\tif (length == 1 || length ==2) return 0;\\n\\tdp = new int[length][27];\\n\\treturn helper2(word, 1, 26); // note: we can start from 1 (think why)\\n}\\n\\nprivate int helper2(String word, int index, int other) {\\n\\tif (index >= word.length()) return 0;\\n\\tif (dp[index][other] == 0) {\\n\\t\\tint curCharIndex = word.charAt(index) - \\'A\\', preCharIndex = word.charAt(index - 1) - \\'A\\';\\n\\t\\tdp[index][other] = Math.min(\\n\\t\\t\\tgetDistance(preCharIndex, curCharIndex) + helper2(word, index + 1, other),\\n\\t\\t\\tgetDistance(other, curCharIndex) + helper2(word, index + 1, preCharIndex)\\n\\t\\t);\\n\\t}\\n\\treturn dp[index][other];\\n}\\n```\n```java\\npublic int minimumDistance_2d_bottom_up(String word) {\\n        if (word == null) return 0;\\n        int length = word.length();\\n        if (length == 1 || length ==2) return 0;\\n        int[][] dpArray = new int[length][27];\\n        for (int i = length - 1; i >= 1; i--) {  // we don\\'t need the value when i = 0;\\n            int curCharIndex = word.charAt(i) - \\'A\\', preCharIndex = word.charAt(i - 1) - \\'A\\';\\n            for (int j = 0; j < 27; j++) {\\n                dpArray[i][j] = Math.min(\\n                    getDistance(preCharIndex, curCharIndex) + (i == length - 1? 0: dpArray[i+1][j]),\\n                    getDistance(j, curCharIndex) + (i == length - 1? 0: dpArray[i+1][preCharIndex])\\n                );\\n            }\\n        }\\n        return dpArray[1][26];\\n    }\\n```\n```java\\npublic int minimumDistance(String word) {\\n\\tif (word == null) return 0;\\n\\tint length = word.length();\\n\\tif (length == 1 || length ==2) return 0;\\n\\tint[] dpArray = new int[27];\\n\\tfor (int i = length - 1; i >= 1; i --) {\\n\\t\\tint[] tmp = new int[27];\\n\\t\\tint curCharIndex = word.charAt(i) - \\'A\\', preCharIndex = word.charAt(i - 1) - \\'A\\';\\n\\t\\tfor (int j = 0; j < 27; j++) {\\n\\t\\t\\ttmp[j] = Math.min(\\n\\t\\t\\t\\tgetDistance(preCharIndex, curCharIndex) + (i == length - 1? 0: dpArray[j]),\\n\\t\\t\\t\\tgetDistance(j, curCharIndex) + (i == length - 1? 0: dpArray[preCharIndex])\\n\\t\\t\\t);\\n\\t\\t}\\n\\t\\tdpArray = tmp;\\n\\t}\\n\\treturn dpArray[26];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 619227,
                "title": "python-recursion-backtracking-with-explanation",
                "content": "**IDEA1: Recursion**\\nI know we can solve this question by DP but I posted a recursive solution because the recursive solution is easier to think and it might be helpful for others.\\n\\nMy recursive function looks like this.\\n```\\n# word is the input word\\n# index is the word index\\n# (x1, y1) is the current first finger coordinate.\\n# (x2, y2) is the current second finger coordinate.\\ndef recursion(self, word, index, x1, y1, x2, y2):\\n\\tpass\\n```\\n\\nThere are 3 cases:\\n1. Two fingers are not assigned meaning we haven\\'t used fingers yet.\\n2. One figer is assigned meaning we have used one finger in the previous recursion.\\n3. Two fingers are assigned meanig we have used both fingers in the previous recursion.\\n\\nFor each case, we need to calculate the distance cost differently.\\n1. We assign the first finger to word[index] w/o distance cost\\n2. Two choices:\\n\\t* Assigning the first finger to word[index] w/ distance cost.\\n\\t* Assigning the second finger to word[index] w/o distance cost.\\n3. Two choices:\\n\\t* Assigning the first finger to word[index] w/ distance cost.\\n\\t* Assigning the second finger to word[index] w/ distance cost.\\n\\nEntire code looks like this.\\n```\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        return self.recursion(word, 0, -1, -1, -1, -1)\\n    \\n    def recursion(self, word, index, x1, y1, x2, y2):\\n        if index == len(word):\\n            return 0\\n        \\n        x, y = self.charToCoordinate(word[index])\\n        if x1 == y1 == -1:\\n            distance = self.recursion(word, index + 1, x, y, x2, y2)\\n        elif x2 == y2 == -1:\\n            distance = min(self.recursion(word, index + 1, x1, y1, x, y),\\n                       self.recursion(word, index + 1, x, y, x2, y2) + self.getDistance(x1, y1, x, y))\\n        else:\\n            distance = min(self.recursion(word, index + 1, x, y, x2, y2) + self.getDistance(x1, y1, x, y),\\n                       self.recursion(word, index + 1, x1, y1, x, y) + self.getDistance(x2, y2, x, y))\\n        return distance\\n    \\n    def charToCoordinate(self, char):\\n        position = ord(char) - ord(\\'A\\')\\n        x = position // 6\\n        y = position % 6\\n        return (x, y)\\n    \\n    def getDistance(self, x1, y1, x2, y2):\\n        return abs(x1 - x2) + abs(y1 - y2)\\n```\\nThis code gives Time Limit Exceeded because:\\n- For each recursion, we call two recursive calls with index + 1\\n- T(n) = T(n - 1) + T(n - 1) + c where n is the input word length\\n- O(n^2) time and O(n) space because the depth of the recursive calls is at most n\\n\\n**IDEA2: Recursion + Backtracking**\\nWe can reduce the complexity using a hash table with key=(index, x1, y1, x2, y2) and value=distance\\n```\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        return self.recursion(word, 0, -1, -1, -1, -1, {})\\n    \\n    def recursion(self, word, index, x1, y1, x2, y2, distances):\\n        if index == len(word):\\n            return 0\\n        elif (index, x1, y1, x2, y2) in distances:\\n            return distances[(index, x1, y1, x2, y2)]\\n        \\n        x, y = self.charToCoordinate(word[index])\\n        if x1 == y1 == -1:\\n            distance = self.recursion(word, index + 1, x, y, x2, y2, distances)\\n        elif x2 == y2 == -1:\\n            distance = min(self.recursion(word, index + 1, x1, y1, x, y, distances),\\n                       self.recursion(word, index + 1, x, y, x2, y2, distances) + self.getDistance(x1, y1, x, y))\\n        else:\\n            distance = min(self.recursion(word, index + 1, x, y, x2, y2, distances) + self.getDistance(x1, y1, x, y),\\n                       self.recursion(word, index + 1, x1, y1, x, y, distances) + self.getDistance(x2, y2, x, y))\\n        distances[(index, x1, y1, x2, y2)] = distance\\n        return distance\\n    \\n    def charToCoordinate(self, char):\\n        position = ord(char) - ord(\\'A\\')\\n        x = position // 6\\n        y = position % 6\\n        return (x, y)\\n    \\n    def getDistance(self, x1, y1, x2, y2):\\n        return abs(x1 - x2) + abs(y1 - y2) \\n```\\nThe complexity is:\\n- O(n * 26 * 26) time/space because 0 <= index < n and 26 coordinates",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n# word is the input word\\n# index is the word index\\n# (x1, y1) is the current first finger coordinate.\\n# (x2, y2) is the current second finger coordinate.\\ndef recursion(self, word, index, x1, y1, x2, y2):\\n\\tpass\\n```\n```\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        return self.recursion(word, 0, -1, -1, -1, -1)\\n    \\n    def recursion(self, word, index, x1, y1, x2, y2):\\n        if index == len(word):\\n            return 0\\n        \\n        x, y = self.charToCoordinate(word[index])\\n        if x1 == y1 == -1:\\n            distance = self.recursion(word, index + 1, x, y, x2, y2)\\n        elif x2 == y2 == -1:\\n            distance = min(self.recursion(word, index + 1, x1, y1, x, y),\\n                       self.recursion(word, index + 1, x, y, x2, y2) + self.getDistance(x1, y1, x, y))\\n        else:\\n            distance = min(self.recursion(word, index + 1, x, y, x2, y2) + self.getDistance(x1, y1, x, y),\\n                       self.recursion(word, index + 1, x1, y1, x, y) + self.getDistance(x2, y2, x, y))\\n        return distance\\n    \\n    def charToCoordinate(self, char):\\n        position = ord(char) - ord(\\'A\\')\\n        x = position // 6\\n        y = position % 6\\n        return (x, y)\\n    \\n    def getDistance(self, x1, y1, x2, y2):\\n        return abs(x1 - x2) + abs(y1 - y2)\\n```\n```\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        return self.recursion(word, 0, -1, -1, -1, -1, {})\\n    \\n    def recursion(self, word, index, x1, y1, x2, y2, distances):\\n        if index == len(word):\\n            return 0\\n        elif (index, x1, y1, x2, y2) in distances:\\n            return distances[(index, x1, y1, x2, y2)]\\n        \\n        x, y = self.charToCoordinate(word[index])\\n        if x1 == y1 == -1:\\n            distance = self.recursion(word, index + 1, x, y, x2, y2, distances)\\n        elif x2 == y2 == -1:\\n            distance = min(self.recursion(word, index + 1, x1, y1, x, y, distances),\\n                       self.recursion(word, index + 1, x, y, x2, y2, distances) + self.getDistance(x1, y1, x, y))\\n        else:\\n            distance = min(self.recursion(word, index + 1, x, y, x2, y2, distances) + self.getDistance(x1, y1, x, y),\\n                       self.recursion(word, index + 1, x1, y1, x, y, distances) + self.getDistance(x2, y2, x, y))\\n        distances[(index, x1, y1, x2, y2)] = distance\\n        return distance\\n    \\n    def charToCoordinate(self, char):\\n        position = ord(char) - ord(\\'A\\')\\n        x = position // 6\\n        y = position % 6\\n        return (x, y)\\n    \\n    def getDistance(self, x1, y1, x2, y2):\\n        return abs(x1 - x2) + abs(y1 - y2) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 487556,
                "title": "java-dp-solution",
                "content": "```\\n    int dist(int a, int b) {\\n        if(a == 26 || b == 26) return 0;\\n        int x1 = (a)/6, y1 = (a)%6;\\n        int x2 = (b)/6, y2 = (b)%6;\\n        return Math.abs(x2-x1) + Math.abs(y2-y1);        \\n    }\\n\\n    int dfs(String w, int idx, int f1, int f2, int[][][] dp) {\\n        if(idx == w.length()) return 0;\\n        \\n        if(dp[idx][f1][f2] == 0) {\\n            int nxt = w.charAt(idx) - \\'A\\';\\n            dp[idx][f1][f2] = Math.min(dist(f1, nxt) + dfs(w, idx + 1, nxt, f2, dp), dist(f2, nxt) + dfs(w, idx + 1, f1, nxt, dp));\\n        }\\n        \\n        return dp[idx][f1][f2];\\n    }\\n    \\n    public int minimumDistance(String w) {\\n        int N = w.length();\\n        int[][][] dp = new int[N][27][27];\\n        return dfs(w, 0, 26, 26, dp);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int dist(int a, int b) {\\n        if(a == 26 || b == 26) return 0;\\n        int x1 = (a)/6, y1 = (a)%6;\\n        int x2 = (b)/6, y2 = (b)%6;\\n        return Math.abs(x2-x1) + Math.abs(y2-y1);        \\n    }\\n\\n    int dfs(String w, int idx, int f1, int f2, int[][][] dp) {\\n        if(idx == w.length()) return 0;\\n        \\n        if(dp[idx][f1][f2] == 0) {\\n            int nxt = w.charAt(idx) - \\'A\\';\\n            dp[idx][f1][f2] = Math.min(dist(f1, nxt) + dfs(w, idx + 1, nxt, f2, dp), dist(f2, nxt) + dfs(w, idx + 1, f1, nxt, dp));\\n        }\\n        \\n        return dp[idx][f1][f2];\\n    }\\n    \\n    public int minimumDistance(String w) {\\n        int N = w.length();\\n        int[][][] dp = new int[N][27][27];\\n        return dfs(w, 0, 26, 26, dp);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 477776,
                "title": "simple-short-python-code-300-ms",
                "content": "```python\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        chars = \\'\\'.join(a for a, b in zip(word, word[1:] + \" \") if a != b)\\n        idx = {c: divmod((ord(c) - 65), 6) for c in string.ascii_uppercase}\\n        \\n        def dist(a, b):\\n            if not a or not b:\\n                return 0\\n            ia, ja = idx[a]\\n            ib, jb = idx[b]\\n            return abs(ia-ib) + abs(ja-jb)\\n        \\n        @lru_cache(None)\\n        def dp(i, wa=None, wb=None):\\n            if i == len(chars): return 0 \\n            xa = dist(wa, chars[i]) + dp(i + 1, chars[i], wb)\\n            xb = dist(wb, chars[i]) + dp(i + 1, wa, chars[i])\\n            return min(xa, xb)\\n\\n        return dp(0)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        chars = \\'\\'.join(a for a, b in zip(word, word[1:] + \" \") if a != b)\\n        idx = {c: divmod((ord(c) - 65), 6) for c in string.ascii_uppercase}\\n        \\n        def dist(a, b):\\n            if not a or not b:\\n                return 0\\n            ia, ja = idx[a]\\n            ib, jb = idx[b]\\n            return abs(ia-ib) + abs(ja-jb)\\n        \\n        @lru_cache(None)\\n        def dp(i, wa=None, wb=None):\\n            if i == len(chars): return 0 \\n            xa = dist(wa, chars[i]) + dp(i + 1, chars[i], wb)\\n            xb = dist(wb, chars[i]) + dp(i + 1, wa, chars[i])\\n            return min(xa, xb)\\n\\n        return dp(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477713,
                "title": "c-simple-dp",
                "content": "Take both fingers - use first finger and use second finger, give the one which gives minimum moves. To avoid TLE! memoize the answers\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> v;\\n    unordered_map<char, pair<int, int>> mp;\\n    unordered_map<int, unordered_map<int, unordered_map<int, int>>> dp;\\n    int f(int i, pair<int, int> fi, pair<int, int> f2, string &word)\\n    {\\n        if(i >= word.size())\\n            return 0;\\n        int first = -1;\\n        if(fi.first != -1)\\n            first = fi.first*(v[0].size()) + fi.second;\\n        int second = -1;\\n        if(f2.first != -1)\\n            second = f2.first*(v[0].size()) + f2.second;\\n        // memoize the solution to avoid TLE!!\\n        if(dp.find(i) != dp.end() && dp[i].find(first) != dp[i].end() && dp[i][first].find(second) != dp[i][first].end())\\n            return dp[i][first][second];\\n        \\n        int a = INT_MAX, b = INT_MAX;\\n        pair<int, int> pos = mp[ word[i] ];\\n        int x = pos.first, y = pos.second;\\n        if(fi.first == -1)\\n        {\\n            a = f(i + 1, {x, y}, f2, word);\\n        }\\n        else\\n        {\\n            int dis = abs(fi.first - x) + abs(fi.second - y);\\n            a = dis + f(i + 1, {x, y}, f2, word);\\n        }\\n        \\n        if(f2.first == -1)\\n        {\\n            b = f(i + 1, fi, {x, y}, word);\\n        }\\n        else\\n        {\\n            int dis = abs(f2.first - x) + abs(f2.second - y);\\n            b = dis + f(i + 1, fi, {x, y}, word);\\n        }\\n        dp[i][first][second] = min(a, b);\\n        return min(a, b);\\n    }\\n    int minimumDistance(string word) {\\n        v = vector<string> {\"ABCDEF\",\"GHIJKL\",\"MNOPQR\",\"STUVWX\",\"YZ\"};\\n        mp.clear();\\n        dp.clear();\\n        for(int i = 0; i < v.size(); i++)\\n        {\\n            for(int j = 0; j < v[i].size(); j++)\\n                mp[v[i][j]] = {i, j};\\n        }\\n        \\n        return f(0, {-1,-1}, {-1,-1}, word);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> v;\\n    unordered_map<char, pair<int, int>> mp;\\n    unordered_map<int, unordered_map<int, unordered_map<int, int>>> dp;\\n    int f(int i, pair<int, int> fi, pair<int, int> f2, string &word)\\n    {\\n        if(i >= word.size())\\n            return 0;\\n        int first = -1;\\n        if(fi.first != -1)\\n            first = fi.first*(v[0].size()) + fi.second;\\n        int second = -1;\\n        if(f2.first != -1)\\n            second = f2.first*(v[0].size()) + f2.second;\\n        // memoize the solution to avoid TLE!!\\n        if(dp.find(i) != dp.end() && dp[i].find(first) != dp[i].end() && dp[i][first].find(second) != dp[i][first].end())\\n            return dp[i][first][second];\\n        \\n        int a = INT_MAX, b = INT_MAX;\\n        pair<int, int> pos = mp[ word[i] ];\\n        int x = pos.first, y = pos.second;\\n        if(fi.first == -1)\\n        {\\n            a = f(i + 1, {x, y}, f2, word);\\n        }\\n        else\\n        {\\n            int dis = abs(fi.first - x) + abs(fi.second - y);\\n            a = dis + f(i + 1, {x, y}, f2, word);\\n        }\\n        \\n        if(f2.first == -1)\\n        {\\n            b = f(i + 1, fi, {x, y}, word);\\n        }\\n        else\\n        {\\n            int dis = abs(f2.first - x) + abs(f2.second - y);\\n            b = dis + f(i + 1, fi, {x, y}, word);\\n        }\\n        dp[i][first][second] = min(a, b);\\n        return min(a, b);\\n    }\\n    int minimumDistance(string word) {\\n        v = vector<string> {\"ABCDEF\",\"GHIJKL\",\"MNOPQR\",\"STUVWX\",\"YZ\"};\\n        mp.clear();\\n        dp.clear();\\n        for(int i = 0; i < v.size(); i++)\\n        {\\n            for(int j = 0; j < v[i].size(); j++)\\n                mp[v[i][j]] = {i, j};\\n        }\\n        \\n        return f(0, {-1,-1}, {-1,-1}, word);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3411430,
                "title": "3d-dp-c",
                "content": "```\\nclass Solution {\\npublic:\\n    map<char,pair<int,int>> mp;\\n    int dp[303][37][37];\\n    int dist(int i, string &word, pair<int,int> lastL, pair<int,int> lastR){\\n        if(i==word.size()){ return 0; }\\n        int l=lastL.first*6+lastL.second, r=lastR.first*6+lastR.second;\\n        if(dp[i][l][r]!=-1){ return dp[i][l][r]; }\\n        int ans=INT_MAX;\\n        int x=mp[word[i]].first, y=mp[word[i]].second;\\n        int rD=(lastR.first==6)?0:abs(x-lastR.first)+abs(y-lastR.second);\\n        int lD=(lastL.first==6)?0:abs(x-lastL.first)+abs(y-lastL.second);\\n        ans=min(rD+dist(i+1,word,lastL,{x,y}),lD+dist(i+1,word,{x,y},lastR));\\n        return dp[i][l][r]=ans;\\n    }\\n    int minimumDistance(string word) {\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0; i<26; i++){\\n            mp[\\'A\\'+i]={i/6,i%6};\\n        }\\n        return dist(0,word,{6,0},{6,0});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<char,pair<int,int>> mp;\\n    int dp[303][37][37];\\n    int dist(int i, string &word, pair<int,int> lastL, pair<int,int> lastR){\\n        if(i==word.size()){ return 0; }\\n        int l=lastL.first*6+lastL.second, r=lastR.first*6+lastR.second;\\n        if(dp[i][l][r]!=-1){ return dp[i][l][r]; }\\n        int ans=INT_MAX;\\n        int x=mp[word[i]].first, y=mp[word[i]].second;\\n        int rD=(lastR.first==6)?0:abs(x-lastR.first)+abs(y-lastR.second);\\n        int lD=(lastL.first==6)?0:abs(x-lastL.first)+abs(y-lastL.second);\\n        ans=min(rD+dist(i+1,word,lastL,{x,y}),lD+dist(i+1,word,{x,y},lastR));\\n        return dp[i][l][r]=ans;\\n    }\\n    int minimumDistance(string word) {\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0; i<26; i++){\\n            mp[\\'A\\'+i]={i/6,i%6};\\n        }\\n        return dist(0,word,{6,0},{6,0});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117345,
                "title": "c-beginner-friendly-recursion-memoization-3d-dp",
                "content": "# Code (Recursion)\\n```\\nclass Solution {\\nprivate:\\n    int recursion(int index, int fingerOne, int fingerTwo, int &size, string &word)\\n    {\\n        if(index >= size)\\n        {\\n            return 0;\\n        }\\n        int firstFinger = 0;\\n        if(fingerOne == -1)\\n        {\\n            firstFinger = recursion(index + 1, word[index] - \\'A\\', fingerTwo, size, word);\\n        }\\n        else\\n        {\\n            int prevRow = fingerOne / 6;\\n            int prevCol = fingerOne % 6;\\n            int currRow = (word[index] - \\'A\\') / 6;\\n            int currCol = (word[index] - \\'A\\') % 6;\\n            int distance = abs(prevRow - currRow) + abs(prevCol - currCol);\\n            firstFinger = distance + recursion(index + 1, word[index] - \\'A\\', fingerTwo, size, word);\\n        }\\n        int secondFinger = 0;\\n        if(fingerTwo == -1)\\n        {\\n            secondFinger = recursion(index + 1, fingerOne, word[index] - \\'A\\', size, word);\\n        }\\n        else\\n        {\\n            int prevRow = fingerTwo / 6;\\n            int prevCol = fingerTwo % 6;\\n            int currRow = (word[index] - \\'A\\') / 6;\\n            int currCol = (word[index] - \\'A\\') % 6;\\n            int distance = abs(prevRow - currRow) + abs(prevCol - currCol);\\n            secondFinger = distance + recursion(index + 1, fingerOne, word[index] - \\'A\\', size, word);\\n        }\\n        return min(firstFinger, secondFinger);\\n    }\\npublic:\\n    int minimumDistance(string word) {\\n        int size = word.size(); \\n        return recursion(0, -1, -1, size, word);\\n    }\\n};\\n\\n```\\n# Code (Memoization {[3D DP]})\\n```\\nclass Solution {\\nprivate:\\n    int memoization(int index, int fingerOne, int fingerTwo, int &size, string &word, vector<vector<vector<int>>>&dp)\\n    {\\n        if(index >= size)\\n        {\\n            return 0;\\n        }\\n        if(dp[index][fingerOne + 1][fingerTwo + 1] != -1)\\n        {\\n            return dp[index][fingerOne + 1][fingerTwo + 1];\\n        }\\n        int firstFinger = 0;\\n        if(fingerOne == -1)\\n        {\\n            firstFinger = memoization(index + 1, word[index] - \\'A\\', fingerTwo, size, word, dp);\\n        }\\n        else\\n        {\\n            int prevRow = fingerOne / 6;\\n            int prevCol = fingerOne % 6;\\n            int currRow = (word[index] - \\'A\\') / 6;\\n            int currCol = (word[index] - \\'A\\') % 6;\\n            int distance = abs(prevRow - currRow) + abs(prevCol - currCol);\\n            firstFinger = distance + memoization(index + 1, word[index] - \\'A\\', fingerTwo, size, word, dp);\\n        }\\n        int secondFinger = 0;\\n        if(fingerTwo == -1)\\n        {\\n            secondFinger = memoization(index + 1, fingerOne, word[index] - \\'A\\', size, word, dp);\\n        }\\n        else\\n        {\\n            int prevRow = fingerTwo / 6;\\n            int prevCol = fingerTwo % 6;\\n            int currRow = (word[index] - \\'A\\') / 6;\\n            int currCol = (word[index] - \\'A\\') % 6;\\n            int distance = abs(prevRow - currRow) + abs(prevCol - currCol);\\n            secondFinger = distance + memoization(index + 1, fingerOne, word[index] - \\'A\\', size, word, dp);\\n        }\\n        return dp[index][fingerOne + 1][fingerTwo + 1] = min(firstFinger, secondFinger);\\n    }\\npublic:\\n    int minimumDistance(string word) {\\n        int size = word.size(); \\n        vector<vector<vector<int>>>dp(size, vector<vector<int>>(30, vector<int>(30, -1)));\\n        return memoization(0, -1, -1, size, word, dp);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int recursion(int index, int fingerOne, int fingerTwo, int &size, string &word)\\n    {\\n        if(index >= size)\\n        {\\n            return 0;\\n        }\\n        int firstFinger = 0;\\n        if(fingerOne == -1)\\n        {\\n            firstFinger = recursion(index + 1, word[index] - \\'A\\', fingerTwo, size, word);\\n        }\\n        else\\n        {\\n            int prevRow = fingerOne / 6;\\n            int prevCol = fingerOne % 6;\\n            int currRow = (word[index] - \\'A\\') / 6;\\n            int currCol = (word[index] - \\'A\\') % 6;\\n            int distance = abs(prevRow - currRow) + abs(prevCol - currCol);\\n            firstFinger = distance + recursion(index + 1, word[index] - \\'A\\', fingerTwo, size, word);\\n        }\\n        int secondFinger = 0;\\n        if(fingerTwo == -1)\\n        {\\n            secondFinger = recursion(index + 1, fingerOne, word[index] - \\'A\\', size, word);\\n        }\\n        else\\n        {\\n            int prevRow = fingerTwo / 6;\\n            int prevCol = fingerTwo % 6;\\n            int currRow = (word[index] - \\'A\\') / 6;\\n            int currCol = (word[index] - \\'A\\') % 6;\\n            int distance = abs(prevRow - currRow) + abs(prevCol - currCol);\\n            secondFinger = distance + recursion(index + 1, fingerOne, word[index] - \\'A\\', size, word);\\n        }\\n        return min(firstFinger, secondFinger);\\n    }\\npublic:\\n    int minimumDistance(string word) {\\n        int size = word.size(); \\n        return recursion(0, -1, -1, size, word);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\nprivate:\\n    int memoization(int index, int fingerOne, int fingerTwo, int &size, string &word, vector<vector<vector<int>>>&dp)\\n    {\\n        if(index >= size)\\n        {\\n            return 0;\\n        }\\n        if(dp[index][fingerOne + 1][fingerTwo + 1] != -1)\\n        {\\n            return dp[index][fingerOne + 1][fingerTwo + 1];\\n        }\\n        int firstFinger = 0;\\n        if(fingerOne == -1)\\n        {\\n            firstFinger = memoization(index + 1, word[index] - \\'A\\', fingerTwo, size, word, dp);\\n        }\\n        else\\n        {\\n            int prevRow = fingerOne / 6;\\n            int prevCol = fingerOne % 6;\\n            int currRow = (word[index] - \\'A\\') / 6;\\n            int currCol = (word[index] - \\'A\\') % 6;\\n            int distance = abs(prevRow - currRow) + abs(prevCol - currCol);\\n            firstFinger = distance + memoization(index + 1, word[index] - \\'A\\', fingerTwo, size, word, dp);\\n        }\\n        int secondFinger = 0;\\n        if(fingerTwo == -1)\\n        {\\n            secondFinger = memoization(index + 1, fingerOne, word[index] - \\'A\\', size, word, dp);\\n        }\\n        else\\n        {\\n            int prevRow = fingerTwo / 6;\\n            int prevCol = fingerTwo % 6;\\n            int currRow = (word[index] - \\'A\\') / 6;\\n            int currCol = (word[index] - \\'A\\') % 6;\\n            int distance = abs(prevRow - currRow) + abs(prevCol - currCol);\\n            secondFinger = distance + memoization(index + 1, fingerOne, word[index] - \\'A\\', size, word, dp);\\n        }\\n        return dp[index][fingerOne + 1][fingerTwo + 1] = min(firstFinger, secondFinger);\\n    }\\npublic:\\n    int minimumDistance(string word) {\\n        int size = word.size(); \\n        vector<vector<vector<int>>>dp(size, vector<vector<int>>(30, vector<int>(30, -1)));\\n        return memoization(0, -1, -1, size, word, dp);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3012542,
                "title": "python-top-down-dp",
                "content": "Assume board as a grid of m*n and store corrdinates of each char in a dictionary.\\nuse top down dp and memoize it.\\nTime Complexity - O(len(word)*m^2*n^2) where m and n are rows and columns of keyboard\\n\\n```\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        n=len(word)\\n        graph={}\\n        i,j=0,0\\n        for c in ascii_uppercase:\\n            graph[c]=(i,j)\\n            j=(j+1)%6\\n            if j==0:\\n                i+=1\\n        @cache\\n        def dp(idx,fi,fj,si,sj):\\n            if idx==n:\\n                return 0\\n            #use first finger\\n            ii,jj=graph[word[idx]]\\n            ans=dp(idx+1,ii,jj,si,sj)+(0 if fi==-1 and fj==-1 else abs(ii-fi)+abs(jj-fj))\\n            #use second finger\\n            ans=min(ans,dp(idx+1,fi,fj,ii,jj)+(0 if si==-1 and sj==-1 else abs(ii-si)+abs(jj-sj)))\\n            return ans\\n        return dp(0,-1,-1,-1,-1)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        n=len(word)\\n        graph={}\\n        i,j=0,0\\n        for c in ascii_uppercase:\\n            graph[c]=(i,j)\\n            j=(j+1)%6\\n            if j==0:\\n                i+=1\\n        @cache\\n        def dp(idx,fi,fj,si,sj):\\n            if idx==n:\\n                return 0\\n            #use first finger\\n            ii,jj=graph[word[idx]]\\n            ans=dp(idx+1,ii,jj,si,sj)+(0 if fi==-1 and fj==-1 else abs(ii-fi)+abs(jj-fj))\\n            #use second finger\\n            ans=min(ans,dp(idx+1,fi,fj,ii,jj)+(0 if si==-1 and sj==-1 else abs(ii-si)+abs(jj-sj)))\\n            return ans\\n        return dp(0,-1,-1,-1,-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2985310,
                "title": "easy-c-solution-recursion-memosiation-knapsack-dp",
                "content": "# Intuition\\nAt each step of the character of the string we can either type with finger 1 or type with finger 2. \\n# Approach\\npair<int,int> p1 and p2 denote the last character coordinates of the first finger and last finger. Use them to find the minimum current distance using a hashmap (which maps the given table given in question with the coordinate pair {i,j}).\\n\\n\\n\\n# Code\\n```\\n#include <bits/stdc++.h>\\nusing namespace std;\\nclass Solution\\n{\\npublic:\\n    int n;\\n    map<char, pair<int, int>> mp;\\n    typedef pair<int, int> pi;\\n    map<pair<int, pair<pi, pi>>, int> dp;\\n    int solve(string &s, int i, pair<int, int> p1, pair<int, int> p2)\\n    {\\n        if (i == n)\\n            return 0;\\n\\n        if (dp.find({i, {p1, p2}}) != dp.end())\\n            return dp[{i, {p1, p2}}];\\n\\n        int x = mp[s[i]].first, y = mp[s[i]].second;\\n\\n        int dist1 = abs(x - p1.first) + abs(y - p1.second);\\n        if (p1.first == -1)\\n            dist1 = 0;\\n\\n        int dist2 = abs(x - p2.first) + abs(y - p2.second);\\n        if (p2.first == -1)\\n            dist2 = 0;\\n\\n        dist1 += solve(s, i + 1, {x, y}, p2);\\n        dist2 += solve(s, i + 1, p1, {x, y});\\n\\n        return dp[{i, {p1, p2}}] = min(dist1, dist2);\\n    }\\n    int minimumDistance(string word)\\n    {\\n        n = word.size();\\n        char c = \\'A\\';\\n        for (int i = 0; i < 4; i++)\\n        {\\n            for (int j = 0; j < 6; j++)\\n                mp[c++] = {i, j};\\n        }\\n        mp[\\'Y\\'] = {4, 0}, mp[\\'Z\\'] = {4, 1};\\n        return solve(word, 0, {-1, -1}, {-1, -1});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\nclass Solution\\n{\\npublic:\\n    int n;\\n    map<char, pair<int, int>> mp;\\n    typedef pair<int, int> pi;\\n    map<pair<int, pair<pi, pi>>, int> dp;\\n    int solve(string &s, int i, pair<int, int> p1, pair<int, int> p2)\\n    {\\n        if (i == n)\\n            return 0;\\n\\n        if (dp.find({i, {p1, p2}}) != dp.end())\\n            return dp[{i, {p1, p2}}];\\n\\n        int x = mp[s[i]].first, y = mp[s[i]].second;\\n\\n        int dist1 = abs(x - p1.first) + abs(y - p1.second);\\n        if (p1.first == -1)\\n            dist1 = 0;\\n\\n        int dist2 = abs(x - p2.first) + abs(y - p2.second);\\n        if (p2.first == -1)\\n            dist2 = 0;\\n\\n        dist1 += solve(s, i + 1, {x, y}, p2);\\n        dist2 += solve(s, i + 1, p1, {x, y});\\n\\n        return dp[{i, {p1, p2}}] = min(dist1, dist2);\\n    }\\n    int minimumDistance(string word)\\n    {\\n        n = word.size();\\n        char c = \\'A\\';\\n        for (int i = 0; i < 4; i++)\\n        {\\n            for (int j = 0; j < 6; j++)\\n                mp[c++] = {i, j};\\n        }\\n        mp[\\'Y\\'] = {4, 0}, mp[\\'Z\\'] = {4, 1};\\n        return solve(word, 0, {-1, -1}, {-1, -1});\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2731860,
                "title": "c-5-dimension-top-down-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int memo[5][6][5][6][301];\\n    int n;\\n    int minimumDistance(string s) {\\n        n = s.size();\\n        memset(memo, -1, sizeof(memo));\\n        int res = 1e9;\\n        for(int i = 0; i < 26; i++)\\n            for(int j = 0; j < 26; j++)\\n                res = min(res, dp(s, 0, i / 6, i % 6, j / 6, j % 6));\\n        return res;\\n    }\\n    int dp(string& s, int idx, int r1, int c1, int r2, int c2){\\n        if(idx == n)\\n            return 0;\\n        if(memo[r1][c1][r2][c2][idx] != -1)\\n            return memo[r1][c1][r2][c2][idx];\\n        int a = s[idx] - \\'A\\', r = a / 6, c = a % 6;\\n        return memo[r1][c1][r2][c2][idx] = min(abs(r - r1) + abs(c - c1) + dp(s, idx + 1, r, c, r2, c2), abs(r - r2) + abs(c - c2) + dp(s, idx + 1, r1, c1, r, c));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int memo[5][6][5][6][301];\\n    int n;\\n    int minimumDistance(string s) {\\n        n = s.size();\\n        memset(memo, -1, sizeof(memo));\\n        int res = 1e9;\\n        for(int i = 0; i < 26; i++)\\n            for(int j = 0; j < 26; j++)\\n                res = min(res, dp(s, 0, i / 6, i % 6, j / 6, j % 6));\\n        return res;\\n    }\\n    int dp(string& s, int idx, int r1, int c1, int r2, int c2){\\n        if(idx == n)\\n            return 0;\\n        if(memo[r1][c1][r2][c2][idx] != -1)\\n            return memo[r1][c1][r2][c2][idx];\\n        int a = s[idx] - \\'A\\', r = a / 6, c = a % 6;\\n        return memo[r1][c1][r2][c2][idx] = min(abs(r - r1) + abs(c - c1) + dp(s, idx + 1, r, c, r2, c2), abs(r - r2) + abs(c - c2) + dp(s, idx + 1, r1, c1, r, c));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2319261,
                "title": "c-memo-recursion-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n  int dp[301][5][6][5][6][2];\\n   int helper(string &word,int start,int prevXfing1,int prevYfing1,int prevXFing2,int prevYFing2,bool finger2,unordered_map<char,pair<int,int>>&mp){\\n       if(start==word.length()) return 0;\\n     if(dp[start][prevXfing1][prevYfing1][prevXFing2][prevYFing2][finger2]!=-1) \\n       return dp[start][prevXfing1][prevYfing1][prevXFing2][prevYFing2][finger2];\\n      int currstartX= mp[word[start]].first; \\n     int currstartY= mp[word[start]].second; \\n     if(finger2){\\n        int op1= abs(currstartX-prevXfing1)+abs(currstartY-prevYfing1)+helper(word,start+1,currstartX,currstartY,prevXFing2,prevYFing2,finger2,mp);\\n        int op2= abs(currstartX-prevXFing2)+abs(currstartY-prevYFing2)+ helper(word,start+1,prevXfing1,prevYfing1,currstartX,currstartY,finger2,mp);\\n       return dp[start][prevXfing1][prevYfing1][prevXFing2][prevYFing2][finger2]=min(op1,op2);\\n        }\\n      else{\\n          int op1= abs(currstartX-prevXfing1)+abs(currstartY-prevYfing1)+helper(word,start+1,currstartX,currstartY,prevXFing2,prevYFing2,finger2,mp);\\n        int op2= helper(word,start+1,prevXfing1,prevYfing1,currstartX,currstartY,true,mp);\\n        return dp[start][prevXfing1][prevYfing1][prevXFing2][prevYFing2][finger2]=min(op1,op2);\\n      }\\n    \\n   \\n      \\n   }\\n    int minimumDistance(string word) {\\n       for(int i=0;i<word.length();i++) word[i]=tolower(word[i]);\\n     // cout<<word;\\n        unordered_map<char,pair<int,int>>mp;\\n        mp[\\'a\\']={0,0};\\n      mp[\\'b\\']={0,1};\\n      mp[\\'c\\']={0,2};\\n      mp[\\'d\\']={0,3};mp[\\'e\\']={0,4};mp[\\'f\\']={0,5};\\n      mp[\\'g\\']={1,0};mp[\\'h\\']={1,1};\\n      mp[\\'i\\']={1,2};mp[\\'j\\']={1,3};mp[\\'k\\']={1,4};mp[\\'l\\']={1,5};\\n      mp[\\'m\\']={2,0};mp[\\'n\\']={2,1};mp[\\'o\\']={2,2};mp[\\'p\\']={2,3};mp[\\'q\\']={2,4};\\n      mp[\\'r\\']={2,5};mp[\\'s\\']={3,0};mp[\\'t\\']={3,1};mp[\\'u\\']={3,2};mp[\\'v\\']={3,3};\\n      mp[\\'w\\']={3,4};mp[\\'x\\']={3,5};mp[\\'y\\']={4,0};\\n      mp[\\'z\\']={4,1};\\n      memset(dp,-1,sizeof(dp));\\n        return helper(word,1,mp[word[0]].first,mp[word[0]].second,0,0,false,mp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  int dp[301][5][6][5][6][2];\\n   int helper(string &word,int start,int prevXfing1,int prevYfing1,int prevXFing2,int prevYFing2,bool finger2,unordered_map<char,pair<int,int>>&mp){\\n       if(start==word.length()) return 0;\\n     if(dp[start][prevXfing1][prevYfing1][prevXFing2][prevYFing2][finger2]!=-1) \\n       return dp[start][prevXfing1][prevYfing1][prevXFing2][prevYFing2][finger2];\\n      int currstartX= mp[word[start]].first; \\n     int currstartY= mp[word[start]].second; \\n     if(finger2){\\n        int op1= abs(currstartX-prevXfing1)+abs(currstartY-prevYfing1)+helper(word,start+1,currstartX,currstartY,prevXFing2,prevYFing2,finger2,mp);\\n        int op2= abs(currstartX-prevXFing2)+abs(currstartY-prevYFing2)+ helper(word,start+1,prevXfing1,prevYfing1,currstartX,currstartY,finger2,mp);\\n       return dp[start][prevXfing1][prevYfing1][prevXFing2][prevYFing2][finger2]=min(op1,op2);\\n        }\\n      else{\\n          int op1= abs(currstartX-prevXfing1)+abs(currstartY-prevYfing1)+helper(word,start+1,currstartX,currstartY,prevXFing2,prevYFing2,finger2,mp);\\n        int op2= helper(word,start+1,prevXfing1,prevYfing1,currstartX,currstartY,true,mp);\\n        return dp[start][prevXfing1][prevYfing1][prevXFing2][prevYFing2][finger2]=min(op1,op2);\\n      }\\n    \\n   \\n      \\n   }\\n    int minimumDistance(string word) {\\n       for(int i=0;i<word.length();i++) word[i]=tolower(word[i]);\\n     // cout<<word;\\n        unordered_map<char,pair<int,int>>mp;\\n        mp[\\'a\\']={0,0};\\n      mp[\\'b\\']={0,1};\\n      mp[\\'c\\']={0,2};\\n      mp[\\'d\\']={0,3};mp[\\'e\\']={0,4};mp[\\'f\\']={0,5};\\n      mp[\\'g\\']={1,0};mp[\\'h\\']={1,1};\\n      mp[\\'i\\']={1,2};mp[\\'j\\']={1,3};mp[\\'k\\']={1,4};mp[\\'l\\']={1,5};\\n      mp[\\'m\\']={2,0};mp[\\'n\\']={2,1};mp[\\'o\\']={2,2};mp[\\'p\\']={2,3};mp[\\'q\\']={2,4};\\n      mp[\\'r\\']={2,5};mp[\\'s\\']={3,0};mp[\\'t\\']={3,1};mp[\\'u\\']={3,2};mp[\\'v\\']={3,3};\\n      mp[\\'w\\']={3,4};mp[\\'x\\']={3,5};mp[\\'y\\']={4,0};\\n      mp[\\'z\\']={4,1};\\n      memset(dp,-1,sizeof(dp));\\n        return helper(word,1,mp[word[0]].first,mp[word[0]].second,0,0,false,mp);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2246496,
                "title": "c-dp-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[301][270][270];\\n    int helper(string &s, int i,char pre1, char pre2, unordered_map<char,pair<int,int>> &h){\\n        if(i==s.length()){\\n            \\n            return 0;\\n        }\\n       if(dp[i][pre1][pre2]!=-1){\\n           return dp[i][pre1][pre2];\\n       }\\n        pair<int,int> p1 = h[pre1];\\n        pair<int,int> finals = h[s[i]];\\n        int cost = abs(p1.first - finals.first) + abs(p1.second - finals.second) + helper(s,i+1,s[i],pre2,h);\\n        if(pre2==\\'0\\'){\\n            cost = min(cost,helper(s,i+1,pre1,s[i],h));\\n        }\\n        else{\\n                pair<int,int> p2 = h[pre2];\\n            int temp =  abs(p2.first -finals.first) + abs(p2.second - finals.second);\\n            cost = min(cost,temp + helper(s,i+1,pre1,s[i],h));\\n                \\n        }\\n        return dp[i][pre1][pre2] = cost;\\n    }\\n    \\n    int minimumDistance(string word) {\\n        unordered_map<char,pair<int,int>> h;\\n        for(int i= 0; i < 26;i++){\\n            char c = i+\\'A\\';\\n            h[c] = {i/6,i%6};\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        return helper(word,1,word[0],\\'0\\',h);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[301][270][270];\\n    int helper(string &s, int i,char pre1, char pre2, unordered_map<char,pair<int,int>> &h){\\n        if(i==s.length()){\\n            \\n            return 0;\\n        }\\n       if(dp[i][pre1][pre2]!=-1){\\n           return dp[i][pre1][pre2];\\n       }\\n        pair<int,int> p1 = h[pre1];\\n        pair<int,int> finals = h[s[i]];\\n        int cost = abs(p1.first - finals.first) + abs(p1.second - finals.second) + helper(s,i+1,s[i],pre2,h);\\n        if(pre2==\\'0\\'){\\n            cost = min(cost,helper(s,i+1,pre1,s[i],h));\\n        }\\n        else{\\n                pair<int,int> p2 = h[pre2];\\n            int temp =  abs(p2.first -finals.first) + abs(p2.second - finals.second);\\n            cost = min(cost,temp + helper(s,i+1,pre1,s[i],h));\\n                \\n        }\\n        return dp[i][pre1][pre2] = cost;\\n    }\\n    \\n    int minimumDistance(string word) {\\n        unordered_map<char,pair<int,int>> h;\\n        for(int i= 0; i < 26;i++){\\n            char c = i+\\'A\\';\\n            h[c] = {i/6,i%6};\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        return helper(word,1,word[0],\\'0\\',h);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2101017,
                "title": "3d-dp-clean-code-intuitive-memoisation-dp-well-commented",
                "content": "```\\nclass Solution {\\n    vector<vector<vector<int>>>dp;\\n    int dist(int from ,int to){\\n        \\n        //since we have 6 columns and 6 rows \\n                    \\n        \\n        //if hover state then return 0 as it will be starting point of finger\\n        //or first char to be typed\\n        if(from==26){\\n            return 0;\\n        }\\n        \\n        int x1,x2,y1,y2;\\n     \\n        //extracting the positions \\n        \\n        x1=from/6;\\n        y1=from%6;\\n        \\n        x2=to/6;\\n        y2=to%6;\\n        \\n        \\n        return abs(x2-x1)+abs(y2-y1);\\n        \\n        \\n    }\\n    \\n    \\n    int minDist(string word,int pos,int leftFingerAt,int rightFingerAt ){\\n        \\n        if(pos==word.length()){\\n            return 0;\\n        }\\n        \\n        if(dp[pos][leftFingerAt][rightFingerAt]!=-1){\\n            return dp[pos][leftFingerAt][rightFingerAt];\\n        }\\n         \\n        int  to=word[pos]-\\'A\\';\\n        \\n        //print character with leftFinger\\n        int choice1=dist(leftFingerAt,to)+minDist(word,pos+1,to,rightFingerAt);\\n        \\n        //print character with rightFinger\\n        int choice2=dist(rightFingerAt,to)+minDist(word,pos+1,leftFingerAt,to);\\n        \\n        return dp[pos][leftFingerAt][rightFingerAt]= min(choice1,choice2);\\n         \\n    }\\n    \\npublic:\\n\\n    int minimumDistance(string word) {\\n        \\n        //27 bcoz we have 27 places to move fingers \\n        dp.resize(word.length(),vector<vector<int>>(27,vector<int>(27,-1)));\\n        \\n        // here 26 means the fingers are in hover state i.e not on any letter\\n        return minDist(word,0,26,26);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<vector<int>>>dp;\\n    int dist(int from ,int to){\\n        \\n        //since we have 6 columns and 6 rows \\n                    \\n        \\n        //if hover state then return 0 as it will be starting point of finger\\n        //or first char to be typed\\n        if(from==26){\\n            return 0;\\n        }\\n        \\n        int x1,x2,y1,y2;\\n     \\n        //extracting the positions \\n        \\n        x1=from/6;\\n        y1=from%6;\\n        \\n        x2=to/6;\\n        y2=to%6;\\n        \\n        \\n        return abs(x2-x1)+abs(y2-y1);\\n        \\n        \\n    }\\n    \\n    \\n    int minDist(string word,int pos,int leftFingerAt,int rightFingerAt ){\\n        \\n        if(pos==word.length()){\\n            return 0;\\n        }\\n        \\n        if(dp[pos][leftFingerAt][rightFingerAt]!=-1){\\n            return dp[pos][leftFingerAt][rightFingerAt];\\n        }\\n         \\n        int  to=word[pos]-\\'A\\';\\n        \\n        //print character with leftFinger\\n        int choice1=dist(leftFingerAt,to)+minDist(word,pos+1,to,rightFingerAt);\\n        \\n        //print character with rightFinger\\n        int choice2=dist(rightFingerAt,to)+minDist(word,pos+1,leftFingerAt,to);\\n        \\n        return dp[pos][leftFingerAt][rightFingerAt]= min(choice1,choice2);\\n         \\n    }\\n    \\npublic:\\n\\n    int minimumDistance(string word) {\\n        \\n        //27 bcoz we have 27 places to move fingers \\n        dp.resize(word.length(),vector<vector<int>>(27,vector<int>(27,-1)));\\n        \\n        // here 26 means the fingers are in hover state i.e not on any letter\\n        return minDist(word,0,26,26);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2003188,
                "title": "python-solution-with-explanation-a-different-point-of-view",
                "content": "```\\ndef minimumDistance(self, word: str) -> int:\\n    orda = ord(\\'A\\')\\n    pos = {}\\n    for i in range(26):\\n        pos[chr(orda + i)] = divmod(i, 6)\\n        \\n    N = len(word)\\n    \\n    def dist(i, j):\\n        if i == 0 or j == 0:\\n            return 0\\n        a, b = word[i - 1], word[j - 1]\\n        i1, j1 = pos[a]\\n        i2, j2 = pos[b]\\n        return abs(i1 - i2) + abs(j1 - j2)\\n    \\n    dp = [[0] * (N + 1) for _ in range(N + 1)]\\n    \\n    # Because of symmetry, dp[i][j] represent the minimum total distance when the current position is at i (so one finger must be at i-th letter) and another figure is at j-th letter. \\n\\t# Here we label the first letter in the sequence as 1. So the maximum value of i is N. 0 is reserved for the initial state.\\n\\n    # The distance value becomes positive only from the 2nd letter\\n    for i in range(2, N + 1):\\n        # To get to the state of (i, j) where j = 0, 1, ..., i - 2, the only possible way is to move from the figure at i - 1 to i \\n        for j in range(i - 1):\\n            dp[i][j] = dp[i - 1][j] + dist(i, i - 1)\\n        # To get to the state of (i, i - 1), the last state can be (i - 1, k) where k can be 0, 1, ..., i - 2 \\n        dp[i][i - 1] = min([(dp[i - 1][k] + dist(i, k)) for k in range(i - 1)])\\n        \\n    # dp[N][N] is not a valid state\\n    return min(dp[-1][:N])\\n```\\n\\n\\t\\nOf course it can be compressed to use only 1D dp array\\n```\\n    def minimumDistance(self, word: str) -> int:\\n        orda = ord(\\'A\\')\\n        pos = {}\\n        for i in range(26):\\n            pos[chr(orda + i)] = divmod(i, 6)\\n            \\n        N = len(word)\\n        \\n        def dist(i, j):\\n            if i == 0 or j == 0:\\n                return 0\\n            a, b = word[i - 1], word[j - 1]\\n            i1, j1 = pos[a]\\n            i2, j2 = pos[b]\\n            return abs(i1 - i2) + abs(j1 - j2)\\n        \\n        dp = [0] * (N + 1)\\n    \\n        for i in range(2, N + 1):\\n            dp[i - 1] = min([(dp[k] + dist(i, k)) for k in range(i - 1)])\\n\\n            for j in range(i - 1):\\n                dp[j] = dp[j] + dist(i, i - 1)\\n            \\n        return min(dp[:N])\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\ndef minimumDistance(self, word: str) -> int:\\n    orda = ord(\\'A\\')\\n    pos = {}\\n    for i in range(26):\\n        pos[chr(orda + i)] = divmod(i, 6)\\n        \\n    N = len(word)\\n    \\n    def dist(i, j):\\n        if i == 0 or j == 0:\\n            return 0\\n        a, b = word[i - 1], word[j - 1]\\n        i1, j1 = pos[a]\\n        i2, j2 = pos[b]\\n        return abs(i1 - i2) + abs(j1 - j2)\\n    \\n    dp = [[0] * (N + 1) for _ in range(N + 1)]\\n    \\n    # Because of symmetry, dp[i][j] represent the minimum total distance when the current position is at i (so one finger must be at i-th letter) and another figure is at j-th letter. \\n\\t# Here we label the first letter in the sequence as 1. So the maximum value of i is N. 0 is reserved for the initial state.\\n\\n    # The distance value becomes positive only from the 2nd letter\\n    for i in range(2, N + 1):\\n        # To get to the state of (i, j) where j = 0, 1, ..., i - 2, the only possible way is to move from the figure at i - 1 to i \\n        for j in range(i - 1):\\n            dp[i][j] = dp[i - 1][j] + dist(i, i - 1)\\n        # To get to the state of (i, i - 1), the last state can be (i - 1, k) where k can be 0, 1, ..., i - 2 \\n        dp[i][i - 1] = min([(dp[i - 1][k] + dist(i, k)) for k in range(i - 1)])\\n        \\n    # dp[N][N] is not a valid state\\n    return min(dp[-1][:N])\\n```\n```\\n    def minimumDistance(self, word: str) -> int:\\n        orda = ord(\\'A\\')\\n        pos = {}\\n        for i in range(26):\\n            pos[chr(orda + i)] = divmod(i, 6)\\n            \\n        N = len(word)\\n        \\n        def dist(i, j):\\n            if i == 0 or j == 0:\\n                return 0\\n            a, b = word[i - 1], word[j - 1]\\n            i1, j1 = pos[a]\\n            i2, j2 = pos[b]\\n            return abs(i1 - i2) + abs(j1 - j2)\\n        \\n        dp = [0] * (N + 1)\\n    \\n        for i in range(2, N + 1):\\n            dp[i - 1] = min([(dp[k] + dist(i, k)) for k in range(i - 1)])\\n\\n            for j in range(i - 1):\\n                dp[j] = dp[j] + dist(i, i - 1)\\n            \\n        return min(dp[:N])\\n\\t\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 1857366,
                "title": "python-top-down-dynamic-programming",
                "content": "At each character of the word, we can choose to use left finger or right finger. When a finger hasn\\'t been used before, then the cost of using that finger is 0. We calculate the cost of using left finger and right finger. If left finger has been used, update the left finger to be the current character, while keeping the right finger where it was before. If right finger has been used, update the position of the right finger to the current character and keep the left finger where it was before. Add the distance calculated to respected recursive calls and return the minimum of the two.\\n\\nEach recursive call created two more recursive calls, so without memoizing, the runtime would be 2 to the power of n, where n is the number of characters, since for each character, we can either use left of right finger. But since we memoize each call, we don\\'t have to calculate the distance to the characters using the same fingers again. So for each character, we just compute the distance of using left finger and right finger so the time complexity is O(N) and space complexity is also O(N) to store the memoized results.\\n\\n```\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        board = {c: (i // 6, i % 6) for i, c in enumerate(ascii_uppercase)}\\n        left = False\\n        right = True\\n        def calculate(start, end):\\n            x1, y1 = board[start]\\n            x2, y2 = board[end]\\n            return abs(x1 - x2) + abs(y1 - y2)\\n        def dp(left, right, i):\\n            if i == len(word):\\n                return 0\\n            if (left, right, i) in memo:\\n                return memo[(left, right, i)]\\n            left_distance = calculate(left, word[i]) if left else 0\\n            right_distance = calculate(right, word[i]) if right else 0\\n            memo[(left, right, i)] = min(left_distance + dp(word[i], right, i + 1), \\n                                         right_distance + dp(left, word[i], i + 1))\\n            return memo[(left, right, i)]\\n        memo = {}\\n        return dp(None, None, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        board = {c: (i // 6, i % 6) for i, c in enumerate(ascii_uppercase)}\\n        left = False\\n        right = True\\n        def calculate(start, end):\\n            x1, y1 = board[start]\\n            x2, y2 = board[end]\\n            return abs(x1 - x2) + abs(y1 - y2)\\n        def dp(left, right, i):\\n            if i == len(word):\\n                return 0\\n            if (left, right, i) in memo:\\n                return memo[(left, right, i)]\\n            left_distance = calculate(left, word[i]) if left else 0\\n            right_distance = calculate(right, word[i]) if right else 0\\n            memo[(left, right, i)] = min(left_distance + dp(word[i], right, i + 1), \\n                                         right_distance + dp(left, word[i], i + 1))\\n            return memo[(left, right, i)]\\n        memo = {}\\n        return dp(None, None, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1485756,
                "title": "python-81-speed-intuitive-o-676-word-recursion-memo",
                "content": "```\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        locations = {}\\n        x, y = 0, 0\\n        for i in range(65, 91):\\n            locations[chr(i)] = (x, y)\\n            y += 1\\n            if y > 5:\\n                x += 1\\n                y = 0\\n        \\n        #print(locations)\\n        @lru_cache(None)\\n        def func(idx, f1, f2):\\n            if idx == len(word):\\n                return 0\\n            \\n            # use f1\\n            if f1 == \\'\\':\\n                x1, y1 = locations[word[idx]]\\n            else:\\n                x1, y1 = locations[f1]\\n                \\n            x, y = locations[word[idx]]\\n            dist1 = abs(x1 - x) + abs(y1 - y)\\n            useF1 = dist1 + func(idx + 1, word[idx], f2)\\n            \\n            if f2 == \\'\\':\\n                x2, y2 = locations[word[idx]]\\n            else:\\n                x2, y2 = locations[f2]\\n                \\n            dist2 = abs(x2 - x) + abs(y2 - y)\\n            useF2 = dist2 + func(idx + 1, f1, word[idx])\\n            \\n            return min(useF1, useF2)\\n        \\n        return func(0, \\'\\', \\'\\')",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        locations = {}",
                "codeTag": "Java"
            },
            {
                "id": 1472519,
                "title": "python-bottom-up-dp-solution-using-dictionaries",
                "content": "```\\nclass Solution:\\n    def __init__(self):\\n        self.table = dict()\\n        for i, a in enumerate(string.ascii_uppercase):\\n            self.table[a] = divmod(i, 6)\\n    \\n    def get_dist(self, a, b):\\n        if not a or not b: return 0\\n        return abs(self.table[a][0] - self.table[b][0]) + abs(self.table[a][1] - self.table[b][1])\\n    \\n    def minimumDistance(self, word: str) -> int:\\n        if len(word) == 2: return 0\\n        table = dict()\\n        for i, a in enumerate(string.ascii_uppercase):\\n            table[a] = (i // 6, i % 6)\\n        \\n        dp = {(\\'\\', \\'\\'): 0}\\n        \\n        for c in word:\\n            dp2 = dict()\\n            for key, value in dp.items():\\n                for i in range(2):\\n                    new_key = tuple(sorted((key[i], c)))\\n                    new_val = value + self.get_dist(key[1 - i], c)\\n                    dp2.setdefault(new_key, new_val)\\n                    dp2[new_key] = min(dp2[new_key], new_val)\\n            dp = dp2\\n        return min(dp.values())\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.table = dict()\\n        for i, a in enumerate(string.ascii_uppercase):\\n            self.table[a] = divmod(i, 6)\\n    \\n    def get_dist(self, a, b):\\n        if not a or not b: return 0\\n        return abs(self.table[a][0] - self.table[b][0]) + abs(self.table[a][1] - self.table[b][1])\\n    \\n    def minimumDistance(self, word: str) -> int:\\n        if len(word) == 2: return 0\\n        table = dict()\\n        for i, a in enumerate(string.ascii_uppercase):\\n            table[a] = (i // 6, i % 6)\\n        \\n        dp = {(\\'\\', \\'\\'): 0}\\n        \\n        for c in word:\\n            dp2 = dict()\\n            for key, value in dp.items():\\n                for i in range(2):\\n                    new_key = tuple(sorted((key[i], c)))\\n                    new_val = value + self.get_dist(key[1 - i], c)\\n                    dp2.setdefault(new_key, new_val)\\n                    dp2[new_key] = min(dp2[new_key], new_val)\\n            dp = dp2\\n        return min(dp.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1450299,
                "title": "easy-dp-approach",
                "content": "dp[i][x1][y1][x2][y2] -- stores the optimal answer for a substring s[i,....] when the 1st finger is at coordinate x1, y1 and 2nd finger is at coordinate x2,y2.\\n\\nx1,y1 or x2,y2 == 7,7 indicates that the particular finger will be used for typing for the 1st time so there will be no cost in that move. 7,7 is chosen since no character corresponds to this coordinate and simply indicate that the particular finger has not been used for typing\\n\\n```\\n#define ff first\\n#define ss second\\nclass Solution {\\n    pair<int,int> pts[30]; // coordinate for a char\\n    int n; // stores length of string\\n    string t;\\n    int dp[305][8][8][8][8];  \\n    \\npublic:\\n\\t// cost of moving finger from one char to another\\n    int cost(int x1,int y1,int x2,int y2){\\n        return abs(x1-x2)+abs(y2-y1);\\n    }\\n    \\n    int solver(int x1,int y1,int x2,int y2,int s){\\n\\t\\t// if string is completely traversed so return 0\\n        if(s==n)\\n            return 0;\\n        \\n\\t\\t// coordinates of next char to move to\\n        int r=pts[t[s]-\\'A\\'].ff,c=pts[t[s]-\\'A\\'].ss;\\n        \\n\\t\\t// unvisited state\\n        if(dp[s][x1][y1][x2][y2]!=-1)\\n            return dp[s][x1][y1][x2][y2];\\n        \\n        dp[s][x1][y1][x2][y2]=INT_MAX;\\n        int nxt=INT_MAX,cl=0,cr=0;\\n        \\n        // if typing the char with left hand\\n        if(x1==7)\\n            nxt=solver(r,c,x2,y2,s+1); // using left finger 1st time\\n        else\\n            nxt=min(nxt,cost(x1,y1,r,c)+solver(r,c,x2,y2,s+1)); // not 1st time\\n        \\n        // if typing the char with right hand\\n        if(x2==7)\\n            nxt=min(nxt,solver(x1,y1,r,c,s+1)); // right finger 1st time\\n        else\\n            nxt=min(nxt,cost(x2,y2,r,c)+solver(x1,y1,r,c,s+1)); // not 1st time\\n        \\n        return dp[s][x1][y1][x2][y2]=nxt;\\n    }\\n    \\n    int minimumDistance(string s) {\\n        char c=\\'A\\';\\n        for(int i=0;i<4;i++)\\n            for(int j=0;j<6;j++){\\n                pts[c-\\'A\\']={i,j};\\n                c++;\\n            }\\n        \\n        t=s;\\n        n=s.length();\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        pts[\\'Y\\'-\\'A\\']={4,0};\\n        pts[\\'Z\\'-\\'A\\']={4,1};\\n        \\n        // x1=7, y1=7, x2=7, y2=7 meaning that both fingers havent been used for typing\\n        return solver(7,7,7,7,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n#define ff first\\n#define ss second\\nclass Solution {\\n    pair<int,int> pts[30]; // coordinate for a char\\n    int n; // stores length of string\\n    string t;\\n    int dp[305][8][8][8][8];  \\n    \\npublic:\\n\\t// cost of moving finger from one char to another\\n    int cost(int x1,int y1,int x2,int y2){\\n        return abs(x1-x2)+abs(y2-y1);\\n    }\\n    \\n    int solver(int x1,int y1,int x2,int y2,int s){\\n\\t\\t// if string is completely traversed so return 0\\n        if(s==n)\\n            return 0;\\n        \\n\\t\\t// coordinates of next char to move to\\n        int r=pts[t[s]-\\'A\\'].ff,c=pts[t[s]-\\'A\\'].ss;\\n        \\n\\t\\t// unvisited state\\n        if(dp[s][x1][y1][x2][y2]!=-1)\\n            return dp[s][x1][y1][x2][y2];\\n        \\n        dp[s][x1][y1][x2][y2]=INT_MAX;\\n        int nxt=INT_MAX,cl=0,cr=0;\\n        \\n        // if typing the char with left hand\\n        if(x1==7)\\n            nxt=solver(r,c,x2,y2,s+1); // using left finger 1st time\\n        else\\n            nxt=min(nxt,cost(x1,y1,r,c)+solver(r,c,x2,y2,s+1)); // not 1st time\\n        \\n        // if typing the char with right hand\\n        if(x2==7)\\n            nxt=min(nxt,solver(x1,y1,r,c,s+1)); // right finger 1st time\\n        else\\n            nxt=min(nxt,cost(x2,y2,r,c)+solver(x1,y1,r,c,s+1)); // not 1st time\\n        \\n        return dp[s][x1][y1][x2][y2]=nxt;\\n    }\\n    \\n    int minimumDistance(string s) {\\n        char c=\\'A\\';\\n        for(int i=0;i<4;i++)\\n            for(int j=0;j<6;j++){\\n                pts[c-\\'A\\']={i,j};\\n                c++;\\n            }\\n        \\n        t=s;\\n        n=s.length();\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        pts[\\'Y\\'-\\'A\\']={4,0};\\n        pts[\\'Z\\'-\\'A\\']={4,1};\\n        \\n        // x1=7, y1=7, x2=7, y2=7 meaning that both fingers havent been used for typing\\n        return solver(7,7,7,7,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1396871,
                "title": "python-top-down-dp",
                "content": "```\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        def dist(n1, n2): \\n            if n1 is None:    \\n                return 0    \\n            x1, y1 = divmod(ord(n1) - ord(\\'A\\'), 6)\\n            x2, y2 = divmod(ord(n2) - ord(\\'A\\'), 6) \\n            return abs(x1 - x2) + abs(y1 - y2)\\n        \\n        @lru_cache(None) \\n        def two_fingers(i, l, r):\\n            if i == len(word):    \\n                return 0\\n            n1 = dist(l, word[i]) + two_fingers(i + 1, word[i], r) \\n            n2 = dist(r, word[i]) + two_fingers(i + 1, l, word[i]) \\n            return min(n1, n2)\\n        \\n        return two_fingers(0, None, None)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        def dist(n1, n2): \\n            if n1 is None:    \\n                return 0    \\n            x1, y1 = divmod(ord(n1) - ord(\\'A\\'), 6)\\n            x2, y2 = divmod(ord(n2) - ord(\\'A\\'), 6) \\n            return abs(x1 - x2) + abs(y1 - y2)\\n        \\n        @lru_cache(None) \\n        def two_fingers(i, l, r):\\n            if i == len(word):    \\n                return 0\\n            n1 = dist(l, word[i]) + two_fingers(i + 1, word[i], r) \\n            n2 = dist(r, word[i]) + two_fingers(i + 1, l, word[i]) \\n            return min(n1, n2)\\n        \\n        return two_fingers(0, None, None)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318021,
                "title": "cpp-easy-memoization-5d-dp-with-detail-explaination",
                "content": "The states of the dp will be \\n1. the current  index of the word : idx\\n2. x and y positions of first finger\\n3. x and y positions of the second finger\\n\\nNow when we know this, the first move can be considered to be started by the first finger : //1\\nFor the next moves, they can be using the first or the second finger. //2\\nif(fing2r==6 && fing2c==6) represents that finger2 is being used for the first time. \\nThe remaining task is to find the min distance! EZ!\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int getrow(char x){\\n        int k=x-\\'A\\';\\n        int row=k/6;\\n        return row;\\n    }\\n    int getcol(char x){\\n        int k=x-\\'A\\';\\n        int col=k%6;\\n        return col;\\n    }\\n    int dp[301][7][7][7][7];\\n    int solve(string word, int idx, int fing1r, int fing1c, int fing2r, int fing2c){\\n        if(idx==word.size()) return 0;\\n        int dist=INT_MAX;\\n        int r=getrow(word[idx]);\\n        int c=getcol(word[idx]);\\n        if(dp[idx][fing1r][fing1c][fing2r][fing2c]!=-1) return dp[idx][fing1r][fing1c][fing2r][fing2c];\\n        if(idx==0) dist=min(dist,solve(word,1,r,c,fing2r,fing2c)); //1\\n        else{ //2\\n            int dist1=abs(r-fing1r)+abs(c-fing1c);\\n            dist1+=solve(word,idx+1,r,c,fing2r,fing2c);\\n            int dist2=abs(r-fing2r)+abs(c-fing2c);\\n            if(fing2r==6 && fing2c==6) dist2=solve(word,idx+1,fing1r,fing1c,r,c);\\n            else dist2+=solve(word,idx+1,fing1r,fing1c,r,c);\\n            dist=min(dist1,dist2);\\n        }\\n        dp[idx][fing1r][fing1c][fing2r][fing2c] = dist;\\n        return dist;\\n    }\\n    int minimumDistance(string word) {\\n        memset(dp,-1,sizeof dp);\\n        return solve(word,0,6,6,6,6);\\n    \\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int getrow(char x){\\n        int k=x-\\'A\\';\\n        int row=k/6;\\n        return row;\\n    }\\n    int getcol(char x){\\n        int k=x-\\'A\\';\\n        int col=k%6;\\n        return col;\\n    }\\n    int dp[301][7][7][7][7];\\n    int solve(string word, int idx, int fing1r, int fing1c, int fing2r, int fing2c){\\n        if(idx==word.size()) return 0;\\n        int dist=INT_MAX;\\n        int r=getrow(word[idx]);\\n        int c=getcol(word[idx]);\\n        if(dp[idx][fing1r][fing1c][fing2r][fing2c]!=-1) return dp[idx][fing1r][fing1c][fing2r][fing2c];\\n        if(idx==0) dist=min(dist,solve(word,1,r,c,fing2r,fing2c)); //1\\n        else{ //2\\n            int dist1=abs(r-fing1r)+abs(c-fing1c);\\n            dist1+=solve(word,idx+1,r,c,fing2r,fing2c);\\n            int dist2=abs(r-fing2r)+abs(c-fing2c);\\n            if(fing2r==6 && fing2c==6) dist2=solve(word,idx+1,fing1r,fing1c,r,c);\\n            else dist2+=solve(word,idx+1,fing1r,fing1c,r,c);\\n            dist=min(dist1,dist2);\\n        }\\n        dp[idx][fing1r][fing1c][fing2r][fing2c] = dist;\\n        return dist;\\n    }\\n    int minimumDistance(string word) {\\n        memset(dp,-1,sizeof dp);\\n        return solve(word,0,6,6,6,6);\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1163915,
                "title": "python-3-dp-memoization-pythonic",
                "content": "```python\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        table = defaultdict(tuple)\\n        for i in range(26):\\n            c = chr(ord(\\'A\\') + i)\\n            row, col = divmod(i, 6)\\n            table[c] = (row, col)\\n        n = len(word)\\n            \\n        def get_dist(c1, c2):\\n            if c1 == \\'#\\' or c2 == \\'#\\':\\n                return 0\\n            r1, c1 = table[c1]\\n            r2, c2 = table[c2]\\n            return abs(r1-r2) + abs(c1-c2)\\n        \\n        @lru_cache(None)\\n        def dp(i, f1, f2):\\n            if i == n:\\n                return 0\\n            c = word[i]\\n            d1, d2 = get_dist(c, f1), get_dist(c, f2)\\n            return min(d1 + dp(i + 1, c, f2), d2 + dp(i + 1, f1, c))\\n        \\n        return dp(0, \\'#\\', \\'#\\')\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        table = defaultdict(tuple)\\n        for i in range(26):\\n            c = chr(ord(\\'A\\') + i)\\n            row, col = divmod(i, 6)\\n            table[c] = (row, col)\\n        n = len(word)\\n            \\n        def get_dist(c1, c2):\\n            if c1 == \\'#\\' or c2 == \\'#\\':\\n                return 0\\n            r1, c1 = table[c1]\\n            r2, c2 = table[c2]\\n            return abs(r1-r2) + abs(c1-c2)\\n        \\n        @lru_cache(None)\\n        def dp(i, f1, f2):\\n            if i == n:\\n                return 0\\n            c = word[i]\\n            d1, d2 = get_dist(c, f1), get_dist(c, f2)\\n            return min(d1 + dp(i + 1, c, f2), d2 + dp(i + 1, f1, c))\\n        \\n        return dp(0, \\'#\\', \\'#\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1115243,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<char,unordered_map<char,int>>dist;\\n    unordered_map<char,pair<int,int>>pos;\\n    int dp[350][27][27];\\n    int recur(int ind,char c1,char c2,string &word)\\n    {\\n        if(ind==word.length())\\n            return 0;\\n        if(dp[ind][c1-\\'A\\'][c2-\\'A\\']!=-1)\\n            return dp[ind][c1-\\'A\\'][c2-\\'A\\'];\\n        return dp[ind][c1-\\'A\\'][c2-\\'A\\']=min(dist[c1][word[ind]]+recur(ind+1,word[ind],c2,word),dist[c2][word[ind]]+recur(ind+1,c1,word[ind],word));\\n    }\\n        \\n    int get_ans(char c1,char c2,string &word)\\n    {\\n        return recur(0,c1,c2,word);\\n    }\\n    int minimumDistance(string word) {\\n       \\n        int myans=100000;\\n        memset(dp,-1,sizeof(dp));\\n        char c=\\'A\\';\\n\\t\\t\\n\\t\\t// pos of each character in matrix given used to calculate distance between them\\n        for(int i=0;i<5;i++)\\n        {\\n            for(int j=0;j<6;j++)\\n            {\\n                pos[c++]={i,j};\\n            }\\n        }\\n\\t\\t\\n\\t\\t//dist between each character\\n        for(char c1=\\'A\\';c1<=\\'Z\\';c1++)\\n        {\\n            for(char c2=\\'A\\';c2<=\\'Z\\';c2++)\\n            {\\n                dist[c1][c2]=abs(pos[c1].first-pos[c2].first)+abs(pos[c1].second-pos[c2].second);\\n            }\\n        }\\n\\t\\t\\n\\t\\t// taking 2 characters and simple Recursive DP after that\\n        for(char c1=\\'A\\';c1<=\\'Z\\';c1++)\\n        {\\n            for(char c2=\\'A\\';c2<=\\'Z\\';c2++)\\n            {\\n                if(c1!=c2)\\n                {\\n                    myans=min(myans,get_ans(c1,c2,word));\\n                }\\n            }\\n        }\\n        return myans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<char,unordered_map<char,int>>dist;\\n    unordered_map<char,pair<int,int>>pos;\\n    int dp[350][27][27];\\n    int recur(int ind,char c1,char c2,string &word)\\n    {\\n        if(ind==word.length())\\n            return 0;\\n        if(dp[ind][c1-\\'A\\'][c2-\\'A\\']!=-1)\\n            return dp[ind][c1-\\'A\\'][c2-\\'A\\'];\\n        return dp[ind][c1-\\'A\\'][c2-\\'A\\']=min(dist[c1][word[ind]]+recur(ind+1,word[ind],c2,word),dist[c2][word[ind]]+recur(ind+1,c1,word[ind],word));\\n    }\\n        \\n    int get_ans(char c1,char c2,string &word)\\n    {\\n        return recur(0,c1,c2,word);\\n    }\\n    int minimumDistance(string word) {\\n       \\n        int myans=100000;\\n        memset(dp,-1,sizeof(dp));\\n        char c=\\'A\\';\\n\\t\\t\\n\\t\\t// pos of each character in matrix given used to calculate distance between them\\n        for(int i=0;i<5;i++)\\n        {\\n            for(int j=0;j<6;j++)\\n            {\\n                pos[c++]={i,j};\\n            }\\n        }\\n\\t\\t\\n\\t\\t//dist between each character\\n        for(char c1=\\'A\\';c1<=\\'Z\\';c1++)\\n        {\\n            for(char c2=\\'A\\';c2<=\\'Z\\';c2++)\\n            {\\n                dist[c1][c2]=abs(pos[c1].first-pos[c2].first)+abs(pos[c1].second-pos[c2].second);\\n            }\\n        }\\n\\t\\t\\n\\t\\t// taking 2 characters and simple Recursive DP after that\\n        for(char c1=\\'A\\';c1<=\\'Z\\';c1++)\\n        {\\n            for(char c2=\\'A\\';c2<=\\'Z\\';c2++)\\n            {\\n                if(c1!=c2)\\n                {\\n                    myans=min(myans,get_ans(c1,c2,word));\\n                }\\n            }\\n        }\\n        return myans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1106569,
                "title": "python3-top-down-dp",
                "content": "**Algo**\\nWe use dp to solve this problem. Define `fn(i, f1, f2)` as the number of movements of typing `word[i:]` when two fingers are at `f1` and `f2`. \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        word = [ord(x)-65 for x in word]\\n        dist = lambda x, y: 0 if -1 in (x, y) else abs(x//6 - y//6) + abs(x%6 - y%6) # l1 distance\\n        \\n        @cache\\n        def fn(i, f1=-1, f2=-1):\\n            \"\"\"Return minimum distance of typing word[i:] with 2 fingers.\"\"\"\\n            if i == len(word): return 0 \\n            return min(dist(word[i], f1) + fn(i+1, word[i], f2), dist(word[i], f2) + fn(i+1, f1, word[i]))\\n        \\n        return fn(0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        word = [ord(x)-65 for x in word]\\n        dist = lambda x, y: 0 if -1 in (x, y) else abs(x//6 - y//6) + abs(x%6 - y%6) # l1 distance\\n        \\n        @cache\\n        def fn(i, f1=-1, f2=-1):\\n            \"\"\"Return minimum distance of typing word[i:] with 2 fingers.\"\"\"\\n            if i == len(word): return 0 \\n            return min(dist(word[i], f1) + fn(i+1, word[i], f2), dist(word[i], f2) + fn(i+1, f1, word[i]))\\n        \\n        return fn(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1057802,
                "title": "python-very-easy-solution-simple-memoization",
                "content": "```\\n\\'\\'\\'\\nkeyboard :-\\n       0 1 2 3 4 5\\n0      a b c d e f\\n1      g h i j k l\\n2      m n o p q r\\n3      s t u v w x\\n4      y z\\n\\nreturn the minimum total distance to type such string using only two fingers.\\nThe distance between coordinates (x1,y1) and (x2,y2) is |x1 - x2| + |y1 - y2|.\\n\\ninitial positions of your two fingers are considered free\\nso don\\'t count towards your total distance\\nyour two fingers do not have to start at the first letter or\\n                                    the first two letters.\\n\\'\\'\\'\\n\\'\\'\\'\\nex:-   HAPPY       f1 -> H -> A -> Y\\n                           2     4          6\\n                   f2 -> P,P              + 0\\n                                        ---------\\n                                            6\\n\\'\\'\\'\\n\\nword = \\'cake\\'\\n\\nfrom functools import lru_cache\\ndef dis(a,b):\\n    if a==-1 or b==-1:\\n        return 0\\n    a = ord(a)-65\\n    b = ord(b)-65\\n    return abs(a//6-b//6) + abs(a%6-b%6)\\n\\ndef two_fingers(word):\\n\\n    @lru_cache(None)\\n    def go(f1, f2, index):                 # current state : finger 1,finger 2,current char\\n        if index == len(word):\\n            return 0\\n\\n        ans = min(dis(f1,word[index] + go(word[index],f2,index+1)) ,\\n                  dis(f2,word[index] + go(f1,word[index],index+1)) )\\n        return ans\\n\\n    return go(-1,-1,0)\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\n\\'\\'\\'\\nkeyboard :-\\n       0 1 2 3 4 5\\n0      a b c d e f\\n1      g h i j k l\\n2      m n o p q r\\n3      s t u v w x\\n4      y z\\n\\nreturn the minimum total distance to type such string using only two fingers.\\nThe distance between coordinates (x1,y1) and (x2,y2) is |x1 - x2| + |y1 - y2|.\\n\\ninitial positions of your two fingers are considered free\\nso don\\'t count towards your total distance\\nyour two fingers do not have to start at the first letter or\\n                                    the first two letters.\\n\\'\\'\\'\\n\\'\\'\\'\\nex:-   HAPPY       f1 -> H -> A -> Y\\n                           2     4          6\\n                   f2 -> P,P              + 0\\n                                        ---------\\n                                            6\\n\\'\\'\\'\\n\\nword = \\'cake\\'\\n\\nfrom functools import lru_cache\\ndef dis(a,b):\\n    if a==-1 or b==-1:\\n        return 0\\n    a = ord(a)-65\\n    b = ord(b)-65\\n    return abs(a//6-b//6) + abs(a%6-b%6)\\n\\ndef two_fingers(word):\\n\\n    @lru_cache(None)\\n    def go(f1, f2, index):                 # current state : finger 1,finger 2,current char\\n        if index == len(word):\\n            return 0\\n\\n        ans = min(dis(f1,word[index] + go(word[index],f2,index+1)) ,\\n                  dis(f2,word[index] + go(f1,word[index],index+1)) )\\n        return ans\\n\\n    return go(-1,-1,0)\\n\\n\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 998308,
                "title": "python-top-down",
                "content": "```\\nimport functools\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        \\n        def distance(a, b):\\n            return abs(int(a/6) - int(b/6)) + abs(a%6 - b%6)\\n        \\n        @lru_cache(None)\\n        def f(l, r, k):\\n            \\n            if k >= len(word):\\n                return 0\\n            \\n            o = ord(word[k]) - 65\\n            left = f(o, r, k+1) + (0 if l == -1 else distance(o, l))\\n            right = f(l, o, k+1) + (0 if r == -1 else distance(o, r))\\n            \\n            return min(left, right)\\n        \\n        return f(-1, -1, 0)\\n```",
                "solutionTags": [],
                "code": "```\\nimport functools\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        \\n        def distance(a, b):\\n            return abs(int(a/6) - int(b/6)) + abs(a%6 - b%6)\\n        \\n        @lru_cache(None)\\n        def f(l, r, k):\\n            \\n            if k >= len(word):\\n                return 0\\n            \\n            o = ord(word[k]) - 65\\n            left = f(o, r, k+1) + (0 if l == -1 else distance(o, l))\\n            right = f(l, o, k+1) + (0 if r == -1 else distance(o, r))\\n            \\n            return min(left, right)\\n        \\n        return f(-1, -1, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 908142,
                "title": "c-memoisation-clean-solution",
                "content": "`Premature optimization is the root of all evil  ( Donald Knuth)`\\n\\nThe problem is pretty straightforward in its approach: you are asked to compute the minimum distance to type a word using two fingers. The logical question boils down to with which finger do you write every letter in the word. You have only two fingers (two choices) so let the program decide that for you.\\n\\nThe choices: either type the letter at position `word_pos` with the first finger or with the second\\n```\\ndist = min(x + minimumDistanceHelper(word, word_pos + 1, keyboard[word[word_pos]], finger_2_pos, mem),\\n                   y + minimumDistanceHelper(word, word_pos + 1, finger_1_pos, keyboard[word[word_pos]], mem));\\n```\\n```\\nclass Solution {\\npublic:\\n\\n    map<char, pair<int, int>> keyboard;\\n\\n    int minimumDistanceHelper(string word, int word_pos, pair<int, int> finger_1_pos, pair<int, int> finger_2_pos, vector<vector<vector<int>>>& mem) {\\n        if (word_pos == word.size()) {\\n            return 0;\\n        }\\n\\n        if(finger_2_pos.first != -1) {\\n            if (mem[word_pos][6 * finger_1_pos.first + finger_1_pos.second][6 * finger_2_pos.first +\\n                                                                            finger_2_pos.second] != -1)\\n                return mem[word_pos][6 * finger_1_pos.first + finger_1_pos.second][6 * finger_2_pos.first +\\n                                                                                   finger_2_pos.second];\\n        }\\n\\n        int x = abs(finger_1_pos.first - keyboard[word[word_pos]].first) +\\n                abs(finger_1_pos.second - keyboard[word[word_pos]].second);\\n        int y = finger_2_pos.first == -1 ? 0 : abs(finger_2_pos.first - keyboard[word[word_pos]].first) +\\n                                               abs(finger_2_pos.second - keyboard[word[word_pos]].second);\\n        int dist;\\n\\n        dist = min(x + minimumDistanceHelper(word, word_pos + 1, keyboard[word[word_pos]], finger_2_pos, mem),\\n                   y + minimumDistanceHelper(word, word_pos + 1, finger_1_pos, keyboard[word[word_pos]], mem));\\n\\n        if(finger_2_pos.first != -1) {\\n            mem[word_pos][6 * finger_1_pos.first + finger_1_pos.second][6 * finger_2_pos.first +\\n                                                                        finger_2_pos.second] = dist;\\n        }\\n        return dist;\\n    }\\n\\n    int minimumDistance(string word) {\\n        for (char i = \\'A\\'; i <= \\'Z\\'; ++i) {\\n            keyboard[i] = make_pair((i - \\'A\\') / 6, (i - \\'A\\') % 6);\\n        }\\n\\n        vector<vector<vector<int>>> mem(word.size(),\\n                                        vector<vector<int>>(keyboard.size(), vector<int>(keyboard.size(), -1)));\\n        return minimumDistanceHelper(word, 1, make_pair(keyboard[word[0]].first, keyboard[word[0]].second),\\n                                     make_pair(-1, -1), mem);\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ndist = min(x + minimumDistanceHelper(word, word_pos + 1, keyboard[word[word_pos]], finger_2_pos, mem),\\n                   y + minimumDistanceHelper(word, word_pos + 1, finger_1_pos, keyboard[word[word_pos]], mem));\\n```\n```\\nclass Solution {\\npublic:\\n\\n    map<char, pair<int, int>> keyboard;\\n\\n    int minimumDistanceHelper(string word, int word_pos, pair<int, int> finger_1_pos, pair<int, int> finger_2_pos, vector<vector<vector<int>>>& mem) {\\n        if (word_pos == word.size()) {\\n            return 0;\\n        }\\n\\n        if(finger_2_pos.first != -1) {\\n            if (mem[word_pos][6 * finger_1_pos.first + finger_1_pos.second][6 * finger_2_pos.first +\\n                                                                            finger_2_pos.second] != -1)\\n                return mem[word_pos][6 * finger_1_pos.first + finger_1_pos.second][6 * finger_2_pos.first +\\n                                                                                   finger_2_pos.second];\\n        }\\n\\n        int x = abs(finger_1_pos.first - keyboard[word[word_pos]].first) +\\n                abs(finger_1_pos.second - keyboard[word[word_pos]].second);\\n        int y = finger_2_pos.first == -1 ? 0 : abs(finger_2_pos.first - keyboard[word[word_pos]].first) +\\n                                               abs(finger_2_pos.second - keyboard[word[word_pos]].second);\\n        int dist;\\n\\n        dist = min(x + minimumDistanceHelper(word, word_pos + 1, keyboard[word[word_pos]], finger_2_pos, mem),\\n                   y + minimumDistanceHelper(word, word_pos + 1, finger_1_pos, keyboard[word[word_pos]], mem));\\n\\n        if(finger_2_pos.first != -1) {\\n            mem[word_pos][6 * finger_1_pos.first + finger_1_pos.second][6 * finger_2_pos.first +\\n                                                                        finger_2_pos.second] = dist;\\n        }\\n        return dist;\\n    }\\n\\n    int minimumDistance(string word) {\\n        for (char i = \\'A\\'; i <= \\'Z\\'; ++i) {\\n            keyboard[i] = make_pair((i - \\'A\\') / 6, (i - \\'A\\') % 6);\\n        }\\n\\n        vector<vector<vector<int>>> mem(word.size(),\\n                                        vector<vector<int>>(keyboard.size(), vector<int>(keyboard.size(), -1)));\\n        return minimumDistanceHelper(word, 1, make_pair(keyboard[word[0]].first, keyboard[word[0]].second),\\n                                     make_pair(-1, -1), mem);\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 857571,
                "title": "c-intuitive-top-down-dp-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint n;\\n\\tvector<vector<vector<int>>> dp;\\n\\tconst int buffer = 1;\\n\\tint dis(int a, int b) {\\n\\t\\tif (a == -1 || b == -1) return 0;\\n\\t\\tint row1 = a / 6, row2 = b / 6;\\n\\t\\tint col1 = a % 6, col2 = b % 6;\\n\\n\\t\\tint ans = (abs(row2 - row1) + abs(col2 - col1));\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tint get(string &word, int start, int pos1, int pos2) {\\n\\t\\tif (start >= n) return 0;\\n\\t\\tint curr = word[start] - \\'A\\';\\n\\n\\t\\tint &ans = dp[start][pos1 + buffer][pos2 + buffer];\\n\\t\\tif (ans != -1) return ans;\\n\\n\\t\\tint ans1 = dis(curr, pos1) + get(word, start + 1, word[start] - \\'A\\', pos2);\\n\\t\\tint ans2 = dis(curr, pos2) + get(word, start + 1, pos1, word[start] - \\'A\\');\\n\\n\\t\\treturn ans = min(ans1, ans2);\\n\\t}\\n\\n\\tint minimumDistance(string wordd) {\\n\\t\\tn = wordd.size();\\n\\t\\tdp.resize(n, vector<vector<int>>(30, vector<int>(30, -1)));\\n\\t\\treturn get(wordd, 0, -1, -1);\\n\\t}\\n};\\n```\\nI observed using an array instead of vector as DP, improved the runtime nearly 5 times.\\n```\\nclass Solution {\\npublic:\\n\\tint n;\\n\\tint dp[302][27][27];\\n\\tconst int buffer = 1;\\n\\tint dis(int a, int b) {\\n\\t\\tif (a == -1 || b == -1) return 0;\\n\\t\\tint row1 = a / 6, row2 = b / 6;\\n\\t\\tint col1 = a % 6, col2 = b % 6;\\n\\n\\t\\tint ans = (abs(row2 - row1) + abs(col2 - col1));\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tint get(string &word, int start, int pos1, int pos2) {\\n\\t\\tif (start >= n) return 0;\\n\\t\\tint curr = word[start] - \\'A\\';\\n\\n\\t\\tint &ans = dp[start][pos1 + buffer][pos2 + buffer];\\n\\t\\tif (ans != -1) return ans;\\n\\n\\t\\tint ans1 = dis(curr, pos1) + get(word, start + 1, word[start] - \\'A\\', pos2);\\n\\t\\tint ans2 = dis(curr, pos2) + get(word, start + 1, pos1, word[start] - \\'A\\');\\n\\n\\t\\treturn ans = min(ans1, ans2);\\n\\t}\\n\\n\\tint minimumDistance(string wordd) {\\n        memset(dp,-1, sizeof(dp));\\n\\t\\tn = wordd.size();\\n\\t\\treturn get(wordd, 0, -1, -1);\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint n;\\n\\tvector<vector<vector<int>>> dp;\\n\\tconst int buffer = 1;\\n\\tint dis(int a, int b) {\\n\\t\\tif (a == -1 || b == -1) return 0;\\n\\t\\tint row1 = a / 6, row2 = b / 6;\\n\\t\\tint col1 = a % 6, col2 = b % 6;\\n\\n\\t\\tint ans = (abs(row2 - row1) + abs(col2 - col1));\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tint get(string &word, int start, int pos1, int pos2) {\\n\\t\\tif (start >= n) return 0;\\n\\t\\tint curr = word[start] - \\'A\\';\\n\\n\\t\\tint &ans = dp[start][pos1 + buffer][pos2 + buffer];\\n\\t\\tif (ans != -1) return ans;\\n\\n\\t\\tint ans1 = dis(curr, pos1) + get(word, start + 1, word[start] - \\'A\\', pos2);\\n\\t\\tint ans2 = dis(curr, pos2) + get(word, start + 1, pos1, word[start] - \\'A\\');\\n\\n\\t\\treturn ans = min(ans1, ans2);\\n\\t}\\n\\n\\tint minimumDistance(string wordd) {\\n\\t\\tn = wordd.size();\\n\\t\\tdp.resize(n, vector<vector<int>>(30, vector<int>(30, -1)));\\n\\t\\treturn get(wordd, 0, -1, -1);\\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\tint n;\\n\\tint dp[302][27][27];\\n\\tconst int buffer = 1;\\n\\tint dis(int a, int b) {\\n\\t\\tif (a == -1 || b == -1) return 0;\\n\\t\\tint row1 = a / 6, row2 = b / 6;\\n\\t\\tint col1 = a % 6, col2 = b % 6;\\n\\n\\t\\tint ans = (abs(row2 - row1) + abs(col2 - col1));\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tint get(string &word, int start, int pos1, int pos2) {\\n\\t\\tif (start >= n) return 0;\\n\\t\\tint curr = word[start] - \\'A\\';\\n\\n\\t\\tint &ans = dp[start][pos1 + buffer][pos2 + buffer];\\n\\t\\tif (ans != -1) return ans;\\n\\n\\t\\tint ans1 = dis(curr, pos1) + get(word, start + 1, word[start] - \\'A\\', pos2);\\n\\t\\tint ans2 = dis(curr, pos2) + get(word, start + 1, pos1, word[start] - \\'A\\');\\n\\n\\t\\treturn ans = min(ans1, ans2);\\n\\t}\\n\\n\\tint minimumDistance(string wordd) {\\n        memset(dp,-1, sizeof(dp));\\n\\t\\tn = wordd.size();\\n\\t\\treturn get(wordd, 0, -1, -1);\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 710927,
                "title": "2ms-java-dp-o-n-in-time",
                "content": "//  left[i] : so far the optimal result if previous char tapped by the left finger, and the last char tapped by the right finger is \\'A\\' + i   \\n// At each position, there are two options either keep using the left finger, or switch from right finger to left finger\\n// Due to symmetry, if right[] is created as left[], we have right[i] = left[i] for all i. We may only consider left[], and ignore right[]\\n```\\nclass Solution {\\n    public int minimumDistance(String word) {      \\n        int[][] dist = new int[26][26];\\n        for (int i=0; i<26; ++i) {\\n            for (int j=i; j<26; ++j) {\\n                dist[i][j] = Math.abs(i / 6 - j / 6) + Math.abs(i % 6 - j % 6);\\n                dist[j][i] = dist[i][j];\\n            }\\n        }       \\n        int[] left = new int[26];  \\n\\t\\t//left[i] : so far the optimal result if previous char tapped by the left finger, and last char by right finger is \\'A\\' + i        \\n        for (int i=1; i<word.length(); ++i) {\\n            int preIdx = word.charAt(i-1) - \\'A\\', curIdx = word.charAt(i) - \\'A\\';\\n            int rightToLeft = Integer.MAX_VALUE;\\n            for (int j=0; j<26; ++j) {\\n\\t\\t\\t   //previous char use right finger, while current char use left finger. \\n\\t\\t\\t   //It should be right[j] + dist[j][curIdx], however we have left[j] = right[j] due to symmetry\\n                rightToLeft = Math.min(rightToLeft, left[j] + dist[j][curIdx]);  \\n            }\\n            for (int j=0; j<26; ++j) {\\n                left[j] += dist[preIdx][curIdx]; //previous char using left finger, and so does current char\\n            }\\n            left[preIdx] = Math.min(left[preIdx], rightToLeft);\\n        }\\n        int count = Integer.MAX_VALUE;\\n        for (int i=0; i<26; ++i) {\\n            count = Math.min(count, left[i]);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDistance(String word) {      \\n        int[][] dist = new int[26][26];\\n        for (int i=0; i<26; ++i) {\\n            for (int j=i; j<26; ++j) {\\n                dist[i][j] = Math.abs(i / 6 - j / 6) + Math.abs(i % 6 - j % 6);\\n                dist[j][i] = dist[i][j];\\n            }\\n        }       \\n        int[] left = new int[26];  \\n\\t\\t//left[i] : so far the optimal result if previous char tapped by the left finger, and last char by right finger is \\'A\\' + i        \\n        for (int i=1; i<word.length(); ++i) {\\n            int preIdx = word.charAt(i-1) - \\'A\\', curIdx = word.charAt(i) - \\'A\\';\\n            int rightToLeft = Integer.MAX_VALUE;\\n            for (int j=0; j<26; ++j) {\\n\\t\\t\\t   //previous char use right finger, while current char use left finger. \\n\\t\\t\\t   //It should be right[j] + dist[j][curIdx], however we have left[j] = right[j] due to symmetry\\n                rightToLeft = Math.min(rightToLeft, left[j] + dist[j][curIdx]);  \\n            }\\n            for (int j=0; j<26; ++j) {\\n                left[j] += dist[preIdx][curIdx]; //previous char using left finger, and so does current char\\n            }\\n            left[preIdx] = Math.min(left[preIdx], rightToLeft);\\n        }\\n        int count = Integer.MAX_VALUE;\\n        for (int i=0; i<26; ++i) {\\n            count = Math.min(count, left[i]);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 689098,
                "title": "java-recursion-with-memoization",
                "content": "```\\nclass Solution {\\n    char[][] map;\\n    public int minimumDistance(String word) {\\n        map = new char[][] {\\n            {\\'A\\', \\'B\\', \\'C\\', \\'D\\', \\'E\\', \\'F\\'},\\n            {\\'G\\', \\'H\\', \\'I\\', \\'J\\', \\'K\\', \\'L\\'},\\n            {\\'M\\', \\'N\\', \\'O\\', \\'P\\', \\'Q\\', \\'R\\'},\\n            {\\'S\\', \\'T\\', \\'U\\', \\'V\\', \\'W\\', \\'X\\'},\\n            {\\'Y\\', \\'Z\\'}\\n        };\\n        return dfs(word, 0, null, null);\\n    }\\n    \\n    Map<String, Integer> res = new HashMap();\\n    \\n    int dfs(String word, int start, int[] L, int[] R) {\\n        if (start >= word.length()) return 0;\\n        String key = getKey(start, L, R);\\n        if (res.containsKey(key)) return res.get(key);\\n        char curr = word.charAt(start);\\n        int currI = (curr-\\'A\\')/6;\\n        int currJ = (curr-\\'A\\')%6;\\n        \\n        int useLeft = dfs(word, start+1, new int[]{currI, currJ}, R) + distance(L, currI, currJ);\\n        int useRight = dfs(word, start+1, L, new int[]{currI, currJ}) + distance(R, currI, currJ);\\n        int ans = Math.min(useLeft, useRight);\\n        res.put(key, ans);\\n        return ans;\\n    }\\n    \\n    String getKey(int start, int[] L, int[] R) {\\n        return start+\"#\"+Arrays.toString(L)+Arrays.toString(R);\\n    }\\n    \\n    int distance(int[] finger, int i, int j) {\\n        if (finger == null) return 0;\\n        return Math.abs(finger[0]-i) + Math.abs(finger[1]-j);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    char[][] map;\\n    public int minimumDistance(String word) {\\n        map = new char[][] {\\n            {\\'A\\', \\'B\\', \\'C\\', \\'D\\', \\'E\\', \\'F\\'},\\n            {\\'G\\', \\'H\\', \\'I\\', \\'J\\', \\'K\\', \\'L\\'},\\n            {\\'M\\', \\'N\\', \\'O\\', \\'P\\', \\'Q\\', \\'R\\'},\\n            {\\'S\\', \\'T\\', \\'U\\', \\'V\\', \\'W\\', \\'X\\'},\\n            {\\'Y\\', \\'Z\\'}\\n        };\\n        return dfs(word, 0, null, null);\\n    }\\n    \\n    Map<String, Integer> res = new HashMap();\\n    \\n    int dfs(String word, int start, int[] L, int[] R) {\\n        if (start >= word.length()) return 0;\\n        String key = getKey(start, L, R);\\n        if (res.containsKey(key)) return res.get(key);\\n        char curr = word.charAt(start);\\n        int currI = (curr-\\'A\\')/6;\\n        int currJ = (curr-\\'A\\')%6;\\n        \\n        int useLeft = dfs(word, start+1, new int[]{currI, currJ}, R) + distance(L, currI, currJ);\\n        int useRight = dfs(word, start+1, L, new int[]{currI, currJ}) + distance(R, currI, currJ);\\n        int ans = Math.min(useLeft, useRight);\\n        res.put(key, ans);\\n        return ans;\\n    }\\n    \\n    String getKey(int start, int[] L, int[] R) {\\n        return start+\"#\"+Arrays.toString(L)+Arrays.toString(R);\\n    }\\n    \\n    int distance(int[] finger, int i, int j) {\\n        if (finger == null) return 0;\\n        return Math.abs(finger[0]-i) + Math.abs(finger[1]-j);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 676223,
                "title": "c-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDistance(string word) {\\n        vector<vector<int>>dp(word.size(),vector<int>(word.size(),-1));\\n        return dfs(dp,word,-1,-1);\\n    }\\n    \\n    int dfs(vector<vector<int>>&dp,string s,int l,int r){\\n        int cur=max(l,r)+1;\\n        if(cur>=s.size())return 0;\\n        if(l!=-1&&r!=-1&&dp[l][r]!=-1)return dp[l][r];\\n        char lc=\\' \\';\\n        char rc=\\' \\';\\n        if(l!=-1)lc=s[l];\\n        if(r!=-1)rc=s[r];\\n        int res=0;\\n        int dis1=dis(lc,s[cur]);\\n        int dis2=dis(rc,s[cur]);\\n        res=min(dis1+dfs(dp,s,cur,r),dis2+dfs(dp,s,l,cur));\\n        if(l!=-1&&r!=-1){\\n            dp[l][r]=res;\\n        }\\n        return res;\\n    }\\n    \\n    int dis(char a,char b)\\n    {\\n        if(a==\\' \\')return 0;\\n        int n1=(int)(a-\\'A\\');\\n        int r1=n1/6;\\n        int c1=n1%6;\\n        int n2=(int)(b-\\'A\\');\\n        int r2=n2/6;\\n        int c2=n2%6;\\n        return abs(r1-r2)+abs(c1-c2);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDistance(string word) {\\n        vector<vector<int>>dp(word.size(),vector<int>(word.size(),-1));\\n        return dfs(dp,word,-1,-1);\\n    }\\n    \\n    int dfs(vector<vector<int>>&dp,string s,int l,int r){\\n        int cur=max(l,r)+1;\\n        if(cur>=s.size())return 0;\\n        if(l!=-1&&r!=-1&&dp[l][r]!=-1)return dp[l][r];\\n        char lc=\\' \\';\\n        char rc=\\' \\';\\n        if(l!=-1)lc=s[l];\\n        if(r!=-1)rc=s[r];\\n        int res=0;\\n        int dis1=dis(lc,s[cur]);\\n        int dis2=dis(rc,s[cur]);\\n        res=min(dis1+dfs(dp,s,cur,r),dis2+dfs(dp,s,l,cur));\\n        if(l!=-1&&r!=-1){\\n            dp[l][r]=res;\\n        }\\n        return res;\\n    }\\n    \\n    int dis(char a,char b)\\n    {\\n        if(a==\\' \\')return 0;\\n        int n1=(int)(a-\\'A\\');\\n        int r1=n1/6;\\n        int c1=n1%6;\\n        int n2=(int)(b-\\'A\\');\\n        int r2=n2/6;\\n        int c2=n2%6;\\n        return abs(r1-r2)+abs(c1-c2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 655066,
                "title": "o-n-space",
                "content": "inspired by \\nhttps://leetcode.com/problems/minimum-distance-to-type-a-word-using-two-fingers/discuss/477659/4%2B-DP-Solutions\\n\\ni think there is an o(n) space method, just like this,\\n```\\n    int cost(int from, int to) {\\n        if (from == 26)\\n            return 0;\\n\\n        return abs(from / 6 - to / 6) + abs(from % 6 - to % 6);\\n    }\\n\\n    int minimumDistance(string word) {\\n        int dp[2][27];\\n        fill_n(&dp[0][0], 2 * 27, 0);\\n\\n        int n = word.size();\\n        for (int pos = n - 1; pos >= 1; --pos)\\n            for (int i = 0; i < 27; ++i) {\\n                int to = word[pos] - \\'A\\';\\n                int j = word[pos - 1] - \\'A\\';\\n                dp[pos % 2][i] = min(cost(i, to) + dp[(pos + 1) % 2][j], cost(j, to) + dp[(pos + 1) % 2][i]);\\n            }\\n\\n        return dp[1][26];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int cost(int from, int to) {\\n        if (from == 26)\\n            return 0;\\n\\n        return abs(from / 6 - to / 6) + abs(from % 6 - to % 6);\\n    }\\n\\n    int minimumDistance(string word) {\\n        int dp[2][27];\\n        fill_n(&dp[0][0], 2 * 27, 0);\\n\\n        int n = word.size();\\n        for (int pos = n - 1; pos >= 1; --pos)\\n            for (int i = 0; i < 27; ++i) {\\n                int to = word[pos] - \\'A\\';\\n                int j = word[pos - 1] - \\'A\\';\\n                dp[pos % 2][i] = min(cost(i, to) + dp[(pos + 1) % 2][j], cost(j, to) + dp[(pos + 1) % 2][i]);\\n            }\\n\\n        return dp[1][26];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 632560,
                "title": "no-need-to-be-fancy-python",
                "content": "No need to be fancy. \\nNo need to go bottom-up.\\nNo need to keep track of a cache.\\nNo need to do index math to calc distance. \\nNo need to memorize the Unicode numbers for capital letters.\\n\\n```python\\ndef distance(p1, p2):\\n    if not p1 or not p2:\\n        return 0\\n    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\\n\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        grid = {}\\n        row = 0\\n        col = 0\\n        for i in range(ord(\\'A\\'), ord(\\'Z\\') + 1):\\n            grid[chr(i)] = (row, col)\\n            col += 1\\n            if col == 6:\\n                col = 0\\n                row += 1\\n        \\n        @lru_cache(None)\\n        def calc_distance(i, f1, f2):\\n            if i == len(word):\\n                return 0\\n            \\n            return min(distance(grid[word[i]], f1) + calc_distance(i + 1, grid[word[i]], f2),\\n                       distance(grid[word[i]], f2) + calc_distance(i + 1, f1, grid[word[i]]))\\n        \\n        return calc_distance(0, (), ()) # using falsy values for free fingers\\n```",
                "solutionTags": [],
                "code": "```python\\ndef distance(p1, p2):\\n    if not p1 or not p2:\\n        return 0\\n    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\\n\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        grid = {}\\n        row = 0\\n        col = 0\\n        for i in range(ord(\\'A\\'), ord(\\'Z\\') + 1):\\n            grid[chr(i)] = (row, col)\\n            col += 1\\n            if col == 6:\\n                col = 0\\n                row += 1\\n        \\n        @lru_cache(None)\\n        def calc_distance(i, f1, f2):\\n            if i == len(word):\\n                return 0\\n            \\n            return min(distance(grid[word[i]], f1) + calc_distance(i + 1, grid[word[i]], f2),\\n                       distance(grid[word[i]], f2) + calc_distance(i + 1, f1, grid[word[i]]))\\n        \\n        return calc_distance(0, (), ()) # using falsy values for free fingers\\n```",
                "codeTag": "Java"
            },
            {
                "id": 627553,
                "title": "python-2d-dp-from-top-down-to-bottom-up",
                "content": "`dp[i][j]` is the solution with finger 1 at position `i` and finger 2 at position `j`, initially both at `-1`.\\n\\nWhile fingers at `[i,j]`, the next character position is `k = max(i,j) + 1`, so the recursive formula is \\n```\\ndp[i][j] = min(dist(word[i], word[k]) + dp[k][j], dist(word[j], word[k]) + dp[i][k])\\n```\\n\\nbottom-up with memorization\\n\\n```python\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        n = len(word)\\n        memo = {}\\n        \\n        def dist(a, b):\\n            x1, y1 = divmod(ord(a) - ord(\\'A\\'), 6)\\n            x2, y2 = divmod(ord(b) - ord(\\'A\\'), 6)\\n            return abs(x1-x2) + abs(y1-y2)\\n        \\n        def dp(i, j):\\n            if (i,j) in memo:\\n                return memo[(i,j)]\\n            \\n            k = max(i, j) + 1\\n            if k == n:\\n                return 0\\n            \\n            c = word[k]\\n            a = word[i if i >= 0 else k]\\n            b = word[j if j >= 0 else k]\\n            \\n            k1 = dist(a, c) + dp(k, j)\\n            k2 = dist(b, c) + dp(i, k)\\n            \\n            memo[(i,j)] = min(k1,k2)\\n            return memo[(i,j)]\\n        \\n        return dp(-1,-1)\\n```\\n\\nunrolling to get top-down version\\n\\n```python\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        \\n        def dist(a, b):\\n            x1, y1 = divmod(ord(a) - ord(\\'A\\'), 6)\\n            x2, y2 = divmod(ord(b) - ord(\\'A\\'), 6)\\n            return abs(x1-x2) + abs(y1-y2)\\n\\n        n = len(word)\\n        dp = [[0] * (n+1) for _ in range(n+1)]\\n        \\n        for i in range(n-1,-1,-1):\\n            for j in range(n-1,-1,-1):\\n                k = max(i, j) + 1\\n                ii = k if not i else i\\n                jj = k if not j else j\\n                a = dist(word[ii-1], word[k-1]) + dp[k][j]\\n                b = dist(word[jj-1], word[k-1]) + dp[i][k]\\n                dp[i][j] = min(a,b)\\n        return dp[0][0]\\n```",
                "solutionTags": [],
                "code": "```\\ndp[i][j] = min(dist(word[i], word[k]) + dp[k][j], dist(word[j], word[k]) + dp[i][k])\\n```\n```python\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        n = len(word)\\n        memo = {}\\n        \\n        def dist(a, b):\\n            x1, y1 = divmod(ord(a) - ord(\\'A\\'), 6)\\n            x2, y2 = divmod(ord(b) - ord(\\'A\\'), 6)\\n            return abs(x1-x2) + abs(y1-y2)\\n        \\n        def dp(i, j):\\n            if (i,j) in memo:\\n                return memo[(i,j)]\\n            \\n            k = max(i, j) + 1\\n            if k == n:\\n                return 0\\n            \\n            c = word[k]\\n            a = word[i if i >= 0 else k]\\n            b = word[j if j >= 0 else k]\\n            \\n            k1 = dist(a, c) + dp(k, j)\\n            k2 = dist(b, c) + dp(i, k)\\n            \\n            memo[(i,j)] = min(k1,k2)\\n            return memo[(i,j)]\\n        \\n        return dp(-1,-1)\\n```\n```python\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        \\n        def dist(a, b):\\n            x1, y1 = divmod(ord(a) - ord(\\'A\\'), 6)\\n            x2, y2 = divmod(ord(b) - ord(\\'A\\'), 6)\\n            return abs(x1-x2) + abs(y1-y2)\\n\\n        n = len(word)\\n        dp = [[0] * (n+1) for _ in range(n+1)]\\n        \\n        for i in range(n-1,-1,-1):\\n            for j in range(n-1,-1,-1):\\n                k = max(i, j) + 1\\n                ii = k if not i else i\\n                jj = k if not j else j\\n                a = dist(word[ii-1], word[k-1]) + dp[k][j]\\n                b = dist(word[jj-1], word[k-1]) + dp[i][k]\\n                dp[i][j] = min(a,b)\\n        return dp[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 595664,
                "title": "python-dp-using-bfs-idea-solution-easy-read-similar-idea-with-problem-1048",
                "content": "**Explaination **\\n\\nActually this is idea of solving this problem is more like a bfs() instead of dp. But we using a dict to record all possible optimized situation in the previous step(in dp this is called the previous status)\\n\\nThen we using previous status to build the next-step status, in the end choose the minimum distance sum from the last status\\n\\nPrev[left, right]  means previously which button left/right finger put on and what\\'s the minimun result for that combination\\n\\n*Also to better understand this problem, there is a easier problem which is 1048 also using bfs() as the logic of dp.*\\nhere is my explaination for 1048\\nhttps://leetcode.com/problems/longest-string-chain/discuss/595686/Python-DP-with-bfs()-idea-6line\\n\\n```\\nclass Solution:\\n    def minimumDistance(self, W: str) -> int:\\n        # build the board   0~26   x=6, y=5\\n        chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\\n        B = collections.defaultdict(lambda:[])\\n        for k in range(26):\\n            (d, r) = divmod(k, 6)\\n            B[chars[k]] = [d, r]\\n        def get_dis(c1, c2, B):   #get distance\\n            if not c1 or not c2: return 0   #if any of the finger not on any Button, we always can get the minimum result of 0\\n            return abs(B[c1][0]-B[c2][0]) + abs(B[c1][1]-B[c2][1])\\n\\n        #dp  minimum distance at (left_position, right_position) and what is the char for each finger\\n        prev, cur = collections.defaultdict(lambda:0), collections.defaultdict(lambda:math.inf)\\n        prev[(None, None)] = 0  #None means put both finger no where\\n        for w in W:\\n            for (l, r) in prev: #continue update the dp like a bfs() so we build the next_stage of status base on what we have now\\n                cur[(w, r)] = min(cur[(w, r)], prev[(l, r)] + get_dis(l, w, B))  #to merge all reapting result in same layer\\n                cur[(l, w)] = min(cur[(a, w)], prev[(l, r)] + get_dis(r, w, B))\\n            prev, cur = cur, collections.defaultdict(lambda:math.inf)\\n\\n        return min(prev.values())\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumDistance(self, W: str) -> int:\\n        # build the board   0~26   x=6, y=5\\n        chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\\n        B = collections.defaultdict(lambda:[])\\n        for k in range(26):\\n            (d, r) = divmod(k, 6)\\n            B[chars[k]] = [d, r]\\n        def get_dis(c1, c2, B):   #get distance\\n            if not c1 or not c2: return 0   #if any of the finger not on any Button, we always can get the minimum result of 0\\n            return abs(B[c1][0]-B[c2][0]) + abs(B[c1][1]-B[c2][1])\\n\\n        #dp  minimum distance at (left_position, right_position) and what is the char for each finger\\n        prev, cur = collections.defaultdict(lambda:0), collections.defaultdict(lambda:math.inf)\\n        prev[(None, None)] = 0  #None means put both finger no where\\n        for w in W:\\n            for (l, r) in prev: #continue update the dp like a bfs() so we build the next_stage of status base on what we have now\\n                cur[(w, r)] = min(cur[(w, r)], prev[(l, r)] + get_dis(l, w, B))  #to merge all reapting result in same layer\\n                cur[(l, w)] = min(cur[(a, w)], prev[(l, r)] + get_dis(r, w, B))\\n            prev, cur = cur, collections.defaultdict(lambda:math.inf)\\n\\n        return min(prev.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 595550,
                "title": "c-8ms-1d-dp-solution-w-detailed-explanation",
                "content": "This is a different solution compared to the official, which is lee215\\'s solution 2. I spent 2 hours and could not understand how that solution works. However, using that as a reference I was able to come up with my own solution that runs in `O(K*N)`, where `N = word.size()`. and `K = alphabet.size()`. \\n\\n**Approach:**\\n\\nThe idea for this solution is based on the observation that **right before we press character at index `i`, a finger must be on index \\'i-1\\'**. Now there are two fingers, which we can label as `one` and `two`. We can use this to further define the previously stated condition as:\\n\\n**At index `i`, either `one` or `two` must be at `i-1`.**\\n\\nIn order to proceed, we need to press character at `i`. Let\\'s look at all the possible scenarios that could play out:\\n\\n1. We used `one` to press `i-1`. We can press `i` with `one` again, while `two` stays unchanged at its index.\\n2. We used `one` to press `i-1`. We can press `i` with `two`. Now `one` stays at `i-1`, while `two` moves from its previous index to `i`.\\n3. We used `two` to press `i-1`. We can press `i` with `two` again, while `one` stays unchanged at its index.\\n4. We used `two` to press `i-1`. We can press `i` with `one`. Now `two` stays at `i-1`, while `one` moves from its previous index to `i`.\\n\\nWe can use these to build the transition for the DP algorithm.\\n\\nBecause a finger must be at index `i-1`, we can define our DP state as follows:\\n\\n`one[j]: ` The minimum cost required to have finger `one` on current character, while finger `two` is on some other index with character index `j`. Character index is just index of character in the alphabet, so `A = 0`, `B = 1`, etc.\\n\\n`two[j]: ` The minimum cost required to have finger `one` on current character, while finger `one` is on some other index with character index `j`. \\n\\nEssentially these two arrays contains the minimum cost to have the *other* finger at a particular character index. \\n\\nUsing the 4 possible scenarios, we can define the update function as:\\n\\n`newOne[j] = min(one[j] + dist(cur, last)`\\n`newTwo[j] = min(two[j] + dist(cur, last)`\\n\\nwhere `dist` is the function calculating distance between two characters, `cur` is character index of current character (index `i`), and `last` is character index of the previous character (index `i-1`).\\n\\nBut we are not done. The updates previously only covers scenario 1 and 3. Scenario 2 and 4 are a bit different. *They only update `last` in the other finger\\'s state*. This is because say we have scenario 2. We move `two` to `i`. We can figure out the minimum cost to do that. However, we need to use this to update `one`\\'s cost at `last`, since our new state is `two` at `i` and `one` staying at `last`. So we want to update `last` of `two`. It is the opposite for scenario 4. \\n\\n`newOne[last] = min(newOne[last], min_k(two[k] + dist(cur, k)`\\n`newTwo[last] = min(newOne[last], min_k(one[k] + dist(cur, k)` \\n\\nwhere `min_k(two[k], dist(cur, k))` is the minimum value we can get by moving the second finger while first finger is on `i-1`, and similarly for `min_k(one[k], dist(cur, k))`. `one` and `two` contain all possible positions of the *other* finger while itself is on `i-1`, so to find the lowest cost to move the other finger to `i`, we need to check them all.\\n\\nIf we look at the two update steps, they are both `O(K)`, `K` being size of the alphabet. Thus, the run-time required to calculate `one[N-1]` and `two[N-1]` is `O(N*K)`, which is the run-time for this algorithm. Space complexity is `O(K)`. \\n\\nTo get the solution, we look for the minimum state in `one` or `two`, since by definition `one[N-1]` and `two[N-1]` means the minimum cost having pressed character using either finger at index `N-1`, which means we have pressed all characters.\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    int minimumDistance(const string& word) {\\n        int size = word.size();\\n        if(size <= 2) return 0;\\n        \\n        auto dist = [](int a, int b) {\\n            if(a == 26) return 0;\\n            return abs(a/6 - b/6) + abs(a % 6 - b % 6);\\n        };\\n        \\n        vector<int> one(27, 9001), two(27, 9001);\\n        one[26] = 0;\\n        two[26] = 0;\\n        for(int i = 1; i < size; ++i) {\\n            vector<int> t1(27, 0), t2(27, 0);\\n            int last = word[i-1] - \\'A\\', cur = word[i] - \\'A\\';\\n            for(int j = 0; j <= 26; ++j) { // Update for scenario 1, 3\\n                t1[j] = one[j] + dist(last, cur);\\n                t2[j] = two[j] + dist(last, cur);\\n            }\\n            int min1 = 9001, min2 = 9001;\\n            for(int j = 0; j <= 26; ++j) { // Update for scenario 2, 4\\n                min1 = min(min1, two[j] + dist(j, cur));\\n                min2 = min(min2, one[j] + dist(j, cur));\\n            }\\n            t1[last] = min(t1[last], min1);\\n            t2[last] = min(t2[last], min2);\\n            one = t1;\\n            two = t2;\\n        }\\n        \\n        int min_ = 9001;\\n        for(int i = 0; i <= 26; ++i) { // Get minimum of using either one or two to press last character\\n            min_ = min(min_, min(one[i], two[i]));\\n        }\\n        return min_;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDistance(const string& word) {\\n        int size = word.size();\\n        if(size <= 2) return 0;\\n        \\n        auto dist = [](int a, int b) {\\n            if(a == 26) return 0;\\n            return abs(a/6 - b/6) + abs(a % 6 - b % 6);\\n        };\\n        \\n        vector<int> one(27, 9001), two(27, 9001);\\n        one[26] = 0;\\n        two[26] = 0;\\n        for(int i = 1; i < size; ++i) {\\n            vector<int> t1(27, 0), t2(27, 0);\\n            int last = word[i-1] - \\'A\\', cur = word[i] - \\'A\\';\\n            for(int j = 0; j <= 26; ++j) { // Update for scenario 1, 3\\n                t1[j] = one[j] + dist(last, cur);\\n                t2[j] = two[j] + dist(last, cur);\\n            }\\n            int min1 = 9001, min2 = 9001;\\n            for(int j = 0; j <= 26; ++j) { // Update for scenario 2, 4\\n                min1 = min(min1, two[j] + dist(j, cur));\\n                min2 = min(min2, one[j] + dist(j, cur));\\n            }\\n            t1[last] = min(t1[last], min1);\\n            t2[last] = min(t2[last], min2);\\n            one = t1;\\n            two = t2;\\n        }\\n        \\n        int min_ = 9001;\\n        for(int i = 0; i <= 26; ++i) { // Get minimum of using either one or two to press last character\\n            min_ = min(min_, min(one[i], two[i]));\\n        }\\n        return min_;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 562796,
                "title": "java-solution-like-state-dp",
                "content": "state dp is dp[i][state][eq], this problem is dp[i][state]\\n\\n```\\nclass Solution {\\n    public int minimumDistance(String word) {\\n        int n = word.length();\\n        int[][] dis = new int[27][27];\\n        for(int i = 0; i < 26; i++) {\\n            for(int j = 0; j < 26; j++) {\\n                dis[i+1][j+1] = Math.abs(i / 6 - j / 6) + Math.abs(i % 6 - j % 6);\\n            }\\n        }\\n        int[][][] dp = new int[n][27][27];\\n        return dfs(dp, 0, null, null, word, dis);\\n    }\\n    \\n    private int dfs(int[][][] dp, int i, Character a, Character b, String word, int[][] dis) {\\n        if(i == word.length()) return 0;\\n        int da = a == null ? 0 : a - \\'A\\' + 1;\\n        int db = b == null ? 0 : b - \\'A\\' + 1;\\n        if(dp[i][da][db] != 0) return dp[i][da][db];\\n        char c = word.charAt(i);\\n        int dc = c - \\'A\\' + 1;\\n        return dp[i][da][db] = Math.min(dis[da][dc] + dfs(dp, i + 1, c, b, word, dis), dis[db][dc] + dfs(dp, i + 1, a, c, word, dis));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDistance(String word) {\\n        int n = word.length();\\n        int[][] dis = new int[27][27];\\n        for(int i = 0; i < 26; i++) {\\n            for(int j = 0; j < 26; j++) {\\n                dis[i+1][j+1] = Math.abs(i / 6 - j / 6) + Math.abs(i % 6 - j % 6);\\n            }\\n        }\\n        int[][][] dp = new int[n][27][27];\\n        return dfs(dp, 0, null, null, word, dis);\\n    }\\n    \\n    private int dfs(int[][][] dp, int i, Character a, Character b, String word, int[][] dis) {\\n        if(i == word.length()) return 0;\\n        int da = a == null ? 0 : a - \\'A\\' + 1;\\n        int db = b == null ? 0 : b - \\'A\\' + 1;\\n        if(dp[i][da][db] != 0) return dp[i][da][db];\\n        char c = word.charAt(i);\\n        int dc = c - \\'A\\' + 1;\\n        return dp[i][da][db] = Math.min(dis[da][dc] + dfs(dp, i + 1, c, b, word, dis), dis[db][dc] + dfs(dp, i + 1, a, c, word, dis));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 541389,
                "title": "c-recursion-memorization",
                "content": "```\\nclass Solution {\\npublic:\\n    int dist(char a, char b) {\\n        if(a == \\'#\\') return 0;\\n        int a_row = (a - \\'A\\') / 6;\\n        int a_col = (a - \\'A\\') % 6;\\n        \\n        int b_row = (b - \\'A\\') / 6;\\n        int b_col = (b - \\'A\\') % 6;\\n        \\n        return abs(a_row - b_row) + abs(a_col - b_col);\\n    }\\n    \\n    int solve(string word, char f1, char f2, int pos, map<string, int> &memo) {\\n        if(pos == word.length())\\n            return 0;\\n        \\n        string s1 = string(1, f1);\\n        string s2 = string(1, f2);\\n        string key = s1 + s2 + to_string(pos);\\n        \\n        if(memo.find(key)!=memo.end()) return memo[key];\\n        int choice1 = dist(f1, word[pos]) + solve(word, word[pos], f2, pos + 1, memo);\\n        int choice2 = dist(f2, word[pos]) + solve(word, f1, word[pos], pos + 1, memo);\\n        memo[key] = min(choice1, choice2);\\n        return memo[key];\\n    }\\n    \\n    int minimumDistance(string word) {\\n        map<string, int> memo;\\n        return solve(word, \\'#\\', \\'#\\', 0, memo);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int dist(char a, char b) {\\n        if(a == \\'#\\') return 0;\\n        int a_row = (a - \\'A\\') / 6;\\n        int a_col = (a - \\'A\\') % 6;\\n        \\n        int b_row = (b - \\'A\\') / 6;\\n        int b_col = (b - \\'A\\') % 6;\\n        \\n        return abs(a_row - b_row) + abs(a_col - b_col);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 500512,
                "title": "just-dfs-memoization",
                "content": "```Scala\\nobject Solution {\\n  def minimumDistance(word: String): Int = {\\n    if (word.length <= 2) return 0\\n\\n\\n    import scala.collection.mutable.Map\\n    val map = Map[Char, Tuple2[Int, Int]]()\\n    for (i <- 0 to 3; j <- 0 to 5) map.put((\\'A\\' + (i * 6) + j).toChar, (i, j))\\n    map.put(\\'Y\\', (4, 0))\\n    map.put(\\'Z\\', (4, 1))\\n\\n\\n    def cost(from: Char, to: Char): Int = {\\n      if (from == \\' \\') return 0\\n      val t1 = map(from)\\n      val t2 = map(to)\\n      Math.abs(t1._1 - t2._1) + Math.abs(t1._2 - t2._2)\\n    }\\n\\n\\n    val len = word.length\\n    val cache = Map[String, Int]()\\n\\n    def f(index: Int, currA: Char, currB: Char): Int = {\\n      if (index == len) return 0\\n      val key = index.toString + currA.toString + currB.toString\\n      if (cache.contains(key)) return cache(key)\\n      val targetChar = word.charAt(index)\\n      val r = Math.min(\\n        cost(currA, targetChar) + f(index + 1, targetChar, currB),\\n        cost(currB, targetChar) + f(index + 1, currA, targetChar)\\n      )\\n      cache.put(key, r)\\n      r\\n    }\\n    f(0, \\' \\', \\' \\')\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```Scala\\nobject Solution {\\n  def minimumDistance(word: String): Int = {\\n    if (word.length <= 2) return 0\\n\\n\\n    import scala.collection.mutable.Map\\n    val map = Map[Char, Tuple2[Int, Int]]()\\n    for (i <- 0 to 3; j <- 0 to 5) map.put((\\'A\\' + (i * 6) + j).toChar, (i, j))\\n    map.put(\\'Y\\', (4, 0))\\n    map.put(\\'Z\\', (4, 1))\\n\\n\\n    def cost(from: Char, to: Char): Int = {\\n      if (from == \\' \\') return 0\\n      val t1 = map(from)\\n      val t2 = map(to)\\n      Math.abs(t1._1 - t2._1) + Math.abs(t1._2 - t2._2)\\n    }\\n\\n\\n    val len = word.length\\n    val cache = Map[String, Int]()\\n\\n    def f(index: Int, currA: Char, currB: Char): Int = {\\n      if (index == len) return 0\\n      val key = index.toString + currA.toString + currB.toString\\n      if (cache.contains(key)) return cache(key)\\n      val targetChar = word.charAt(index)\\n      val r = Math.min(\\n        cost(currA, targetChar) + f(index + 1, targetChar, currB),\\n        cost(currB, targetChar) + f(index + 1, currA, targetChar)\\n      )\\n      cache.put(key, r)\\n      r\\n    }\\n    f(0, \\' \\', \\' \\')\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 483926,
                "title": "simple-java-solution-using-memoization",
                "content": "Straightforward solution using meomization.  fpos indicates position of first finger, rpos indicates position of the second finger. We just recurse and memoize the states.\\n\\n```\\nclass Solution {\\n    public int minimumDistance(String word) {\\n        Map<String, Integer> memo = new HashMap();\\n        return dfs(word, 0, -1, 1,memo);\\n    }\\n    \\n    int dfs(String word, int fpos, int rpos, int pos, Map<String, Integer> memo) {\\n        String key = fpos + \" : \" +  rpos +  \":\" + pos;\\n        if(memo.containsKey(key)) return memo.get(key);\\n        if(pos == word.length()) return 0;\\n        \\n        int cost2 = 0;\\n        if(rpos != -1) {\\n            cost2 = diff(word.charAt(rpos), word.charAt(pos));\\n        }\\n        int cost1 = diff(word.charAt(fpos), word.charAt(pos));\\n       \\n        int c1 = dfs(word, pos, rpos, pos+1, memo) + cost1;\\n        int c2 = dfs(word, fpos, pos, pos+1, memo) + cost2;\\n        int val = Math.min(c1, c2);\\n    \\n        memo.put(key, val);\\n        return val;\\n    }\\n    \\n    int diff(char ch1, char ch2) {\\n        int p1 = ch1 - \\'A\\';\\n        int x1 = p1/6;\\n        int y1 = p1%6;\\n        \\n        int p2 = ch2 - \\'A\\';\\n        int x2 = p2/6;\\n        int y2 = p2%6;\\n        \\n        return Math.abs(x1-x2) + Math.abs(y1-y2);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDistance(String word) {\\n        Map<String, Integer> memo = new HashMap();\\n        return dfs(word, 0, -1, 1,memo);\\n    }\\n    \\n    int dfs(String word, int fpos, int rpos, int pos, Map<String, Integer> memo) {\\n        String key = fpos + \" : \" +  rpos +  \":\" + pos;\\n        if(memo.containsKey(key)) return memo.get(key);\\n        if(pos == word.length()) return 0;\\n        \\n        int cost2 = 0;\\n        if(rpos != -1) {\\n            cost2 = diff(word.charAt(rpos), word.charAt(pos));\\n        }\\n        int cost1 = diff(word.charAt(fpos), word.charAt(pos));\\n       \\n        int c1 = dfs(word, pos, rpos, pos+1, memo) + cost1;\\n        int c2 = dfs(word, fpos, pos, pos+1, memo) + cost2;\\n        int val = Math.min(c1, c2);\\n    \\n        memo.put(key, val);\\n        return val;\\n    }\\n    \\n    int diff(char ch1, char ch2) {\\n        int p1 = ch1 - \\'A\\';\\n        int x1 = p1/6;\\n        int y1 = p1%6;\\n        \\n        int p2 = ch2 - \\'A\\';\\n        int x2 = p2/6;\\n        int y2 = p2%6;\\n        \\n        return Math.abs(x1-x2) + Math.abs(y1-y2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 479981,
                "title": "rolling-array-dp-o-n",
                "content": "```\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        idx = lambda i: ord(word[i]) - ord(\\'A\\')\\n        dist = lambda a, b: abs(a//6 - b//6) + abs(a % 6 - b % 6)\\n        dp = [0] * 26\\n        for i in range(1, len(word)):\\n            if word[i] == word[i - 1]: continue\\n            ndp = [float(\\'inf\\')] * 26\\n            for j in range(26):\\n                ndp[j] = dp[j] + dist(idx(i - 1), idx(i))\\n            for k in range(26):\\n                ndp[idx(i - 1)] = min(ndp[idx(i - 1)], dp[k] + dist(k, idx(i)))\\n            dp = ndp\\n        return min(dp)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        idx = lambda i: ord(word[i]) - ord(\\'A\\')\\n        dist = lambda a, b: abs(a//6 - b//6) + abs(a % 6 - b % 6)\\n        dp = [0] * 26\\n        for i in range(1, len(word)):\\n            if word[i] == word[i - 1]: continue\\n            ndp = [float(\\'inf\\')] * 26\\n            for j in range(26):\\n                ndp[j] = dp[j] + dist(idx(i - 1), idx(i))\\n            for k in range(26):\\n                ndp[idx(i - 1)] = min(ndp[idx(i - 1)], dp[k] + dist(k, idx(i)))\\n            dp = ndp\\n        return min(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 479198,
                "title": "easy-to-understand-3d-dp-solution",
                "content": "**Order to Proceed:**\\n1. Place finger1 at index 0 always.\\n2. finger2 can be placed at anywhere from len = 1 to n-1\\n3. Now calculate all permutations for the finger1 and finger2 for each character\\n4. Memoize the solution using 3D dp(```dp[pair1][pair2][index]```) .To simplify I have converted pair1 to ```[x1][y1] ```and pair2 to ```[x2][y2]``` to a 5D dp which is essentially 3D.\\n5. The minimum cost amongst these is the answer.\\n```\\nclass Solution {\\npublic:\\n    map<char,pair<int,int>> mp;\\n    int dp[7][7][7][7][301];\\n    int dfs(string word, pair<int,int> finger1, pair<int,int> finger2, int currIndex,int len){\\n        if(currIndex == len){\\n            return 0;\\n        }\\n        // cout << currIndex << endl;\\n        int x1 = finger1.first;\\n        int x2 = finger2.first;\\n        int y1 = finger1.second;\\n        int y2 = finger2.second;\\n        if(dp[x1][y1][x2][y2][currIndex] != -1){\\n            return dp[x1][y1][x2][y2][currIndex];\\n        }\\n        pair<int,int> curr_p = mp[word[currIndex]];\\n        int curr_x = curr_p.first;\\n        int curr_y = curr_p.second;\\n        int dist1 = abs(x1-curr_x) + abs(y1-curr_y);\\n        int dist2 = abs(x2-curr_x) + abs(y2-curr_y);\\n        return dp[x1][y1][x2][y2][currIndex] = min(dist1 + dfs(word,curr_p,finger2,currIndex+1,len), \\n                   dist2 + dfs(word,finger1,curr_p,currIndex+1,len));\\n    }\\n    int minimumDistance(string word) {\\n        int len = word.length();\\n        char ch = \\'A\\';\\n        for(int i=0;i<5;i++){\\n            for(int j=0;j<6;j++){\\n                mp[ch] = make_pair(i,j);\\n                ch++;\\n                if(i==4 && j==2){\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=0;i<7;i++){\\n            for(int j=0;j<7;j++){\\n                for(int k=0;k<7;k++){\\n                    for(int l=0;l<7;l++){\\n                        for(int m=0;m<301;m++){\\n                            dp[i][j][k][l][m] = -1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        pair<int,int> finger1 = make_pair(1,1);\\n        pair<int,int> finger2 = make_pair(0,0);\\n        char firstChar = word[0];\\n        finger1 = mp[firstChar];\\n        int minCost = INT_MAX;\\n        for(int j=1;j<len;j++){\\n            finger2 = mp[word[j]];\\n            minCost = min(minCost,dfs(word,finger1,finger2,0,len));\\n        }\\n        return minCost == INT_MAX? 0: minCost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```dp[pair1][pair2][index]```\n```[x1][y1] ```\n```[x2][y2]```\n```\\nclass Solution {\\npublic:\\n    map<char,pair<int,int>> mp;\\n    int dp[7][7][7][7][301];\\n    int dfs(string word, pair<int,int> finger1, pair<int,int> finger2, int currIndex,int len){\\n        if(currIndex == len){\\n            return 0;\\n        }\\n        // cout << currIndex << endl;\\n        int x1 = finger1.first;\\n        int x2 = finger2.first;\\n        int y1 = finger1.second;\\n        int y2 = finger2.second;\\n        if(dp[x1][y1][x2][y2][currIndex] != -1){\\n            return dp[x1][y1][x2][y2][currIndex];\\n        }\\n        pair<int,int> curr_p = mp[word[currIndex]];\\n        int curr_x = curr_p.first;\\n        int curr_y = curr_p.second;\\n        int dist1 = abs(x1-curr_x) + abs(y1-curr_y);\\n        int dist2 = abs(x2-curr_x) + abs(y2-curr_y);\\n        return dp[x1][y1][x2][y2][currIndex] = min(dist1 + dfs(word,curr_p,finger2,currIndex+1,len), \\n                   dist2 + dfs(word,finger1,curr_p,currIndex+1,len));\\n    }\\n    int minimumDistance(string word) {\\n        int len = word.length();\\n        char ch = \\'A\\';\\n        for(int i=0;i<5;i++){\\n            for(int j=0;j<6;j++){\\n                mp[ch] = make_pair(i,j);\\n                ch++;\\n                if(i==4 && j==2){\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=0;i<7;i++){\\n            for(int j=0;j<7;j++){\\n                for(int k=0;k<7;k++){\\n                    for(int l=0;l<7;l++){\\n                        for(int m=0;m<301;m++){\\n                            dp[i][j][k][l][m] = -1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        pair<int,int> finger1 = make_pair(1,1);\\n        pair<int,int> finger2 = make_pair(0,0);\\n        char firstChar = word[0];\\n        finger1 = mp[firstChar];\\n        int minCost = INT_MAX;\\n        for(int j=1;j<len;j++){\\n            finger2 = mp[word[j]];\\n            minCost = min(minCost,dfs(word,finger1,finger2,0,len));\\n        }\\n        return minCost == INT_MAX? 0: minCost;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 478667,
                "title": "python-simple-recursion-dp-solution-beats-100-space-and-time",
                "content": "```\\nclass Solution:\\n    def __init__(self):\\n        self.dic={}\\n        self.h={}\\n    def minimumDistance(self, word: str) -> int:\\n        chars=[\"ABCDEF\",\"GHIJKL\",\"MNOPQR\",\"STUVWX\",\"YZ\"]\\n        temp1=0\\n        temp2=0\\n        for i in chars:\\n            temp2=0\\n            for j in i:\\n                self.dic[j]=(temp1,temp2)\\n                temp2+=1\\n            temp1+=1\\n        return self.recursion(word,1,0,self.dic[word[0]],(-1,-1))\\n        \\n        \\n        \\n        \\n    def recursion(self,word,index,value,previndex,previndex2):\\n        if (index, previndex, previndex2) in self.h:\\n            return value+self.h[(index, previndex, previndex2)]\\n        if index>=len(word):\\n            return value\\n        valF1=abs(previndex[0]-self.dic[word[index]][0]) + abs(previndex[1]-self.dic[word[index]][1])\\n        if previndex2==(-1,-1):\\n            valF2 = 0\\n        else:\\n            valF2=abs(previndex2[0]-self.dic[word[index]][0]) + abs(previndex2[1]-self.dic[word[index]][1])\\n        choiceF1=self.recursion(word,index+1,value+valF1,self.dic[word[index]],previndex2)\\n        choiceF2=self.recursion(word,index+1,value+valF2,previndex,self.dic[word[index]])\\n        res = min(choiceF1, choiceF2)\\n        self.h[(index, previndex, previndex2)] = res-value\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.dic={}\\n        self.h={}\\n    def minimumDistance(self, word: str) -> int:\\n        chars=[\"ABCDEF\",\"GHIJKL\",\"MNOPQR\",\"STUVWX\",\"YZ\"]\\n        temp1=0\\n        temp2=0\\n        for i in chars:\\n            temp2=0\\n            for j in i:\\n                self.dic[j]=(temp1,temp2)\\n                temp2+=1\\n            temp1+=1\\n        return self.recursion(word,1,0,self.dic[word[0]],(-1,-1))\\n        \\n        \\n        \\n        \\n    def recursion(self,word,index,value,previndex,previndex2):\\n        if (index, previndex, previndex2) in self.h:\\n            return value+self.h[(index, previndex, previndex2)]\\n        if index>=len(word):\\n            return value\\n        valF1=abs(previndex[0]-self.dic[word[index]][0]) + abs(previndex[1]-self.dic[word[index]][1])\\n        if previndex2==(-1,-1):\\n            valF2 = 0\\n        else:\\n            valF2=abs(previndex2[0]-self.dic[word[index]][0]) + abs(previndex2[1]-self.dic[word[index]][1])\\n        choiceF1=self.recursion(word,index+1,value+valF1,self.dic[word[index]],previndex2)\\n        choiceF2=self.recursion(word,index+1,value+valF2,previndex,self.dic[word[index]])\\n        res = min(choiceF1, choiceF2)\\n        self.h[(index, previndex, previndex2)] = res-value\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 478661,
                "title": "c-dp-8ms",
                "content": "\\n    int minimumDistance(string w) {\\n        int n = w.size();\\n        vector<vector<int>> dp(n, vector<int>(27, 0));\\n        \\n        for(int i=1;i<n;++i)\\n            for(int c=0;c<27;++c)\\n                dp[i][c] = min(cost(w[i]-\\'A\\', w[i-1]-\\'A\\') + dp[i-1][c], cost(c, w[i-1]-\\'A\\') + dp[i-1][w[i]-\\'A\\']);\\n                \\n        return dp[n-1][26];\\n    }\\n    \\n    int cost(int i, int j) {\\n        if(i == 26) return 0;\\n        return abs(i/6 - j/6) + abs(i%6 - j%6);\\n    }\\n    \\n    int threeFinger(string w) {\\n        int n = w.size();\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(27, vector<int>(27,0)));\\n        \\n        for(int i=1;i<n;++i)\\n            for(int c1=0;c1<27;++c1)\\n                for(int c2=0;c2<27;++c2)\\n                    dp[i][c1][c2] = min({cost(w[i]-\\'A\\', w[i-1]-\\'A\\')+dp[i-1][c1][c2], cost(c1, w[i-1]-\\'A\\')+dp[i-1][w[i]-\\'A\\'][c2],\\n                                        cost(c2, w[i-1]-\\'A\\')+dp[i-1][c1][w[i]-\\'A\\']});\\n            \\n        return dp[n-1][26][26];\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    int minimumDistance(string w) {\\n        int n = w.size();\\n        vector<vector<int>> dp(n, vector<int>(27, 0));\\n        \\n        for(int i=1;i<n;++i)\\n            for(int c=0;c<27;++c)\\n                dp[i][c] = min(cost(w[i]-\\'A\\', w[i-1]-\\'A\\') + dp[i-1][c], cost(c, w[i-1]-\\'A\\') + dp[i-1][w[i]-\\'A\\']);\\n                \\n        return dp[n-1][26];\\n    }\\n    \\n    int cost(int i, int j) {\\n        if(i == 26) return 0;\\n        return abs(i/6 - j/6) + abs(i%6 - j%6);\\n    }\\n    \\n    int threeFinger(string w) {\\n        int n = w.size();\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(27, vector<int>(27,0)));\\n        \\n        for(int i=1;i<n;++i)\\n            for(int c1=0;c1<27;++c1)\\n                for(int c2=0;c2<27;++c2)\\n                    dp[i][c1][c2] = min({cost(w[i]-\\'A\\', w[i-1]-\\'A\\')+dp[i-1][c1][c2], cost(c1, w[i-1]-\\'A\\')+dp[i-1][w[i]-\\'A\\'][c2],\\n                                        cost(c2, w[i-1]-\\'A\\')+dp[i-1][c1][w[i]-\\'A\\']});\\n            \\n        return dp[n-1][26][26];\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 478615,
                "title": "memorized-search-dp-by-recursion-easy-understanding",
                "content": "```\\nclass Solution {\\n    int[][][] dp = new int[27][27][300];\\n    public int minimumDistance(String word) {\\n        return helper(word, 0, null, null);\\n    }\\n    //Memorized Search, next step of pos is either moving c1 or c2 to pos +1;  then calculate from end of string.\\n    private int helper(String word, int pos, Character c1, Character c2) {\\n        if (pos >= word.length()) return 0;  // check pos to avoid stringIndex exception\\n        Character curr = word.charAt(pos);\\n        int i1 = c1 == null ? 26 : c1 - \\'A\\';   // must check null before call dp[i1][i2][pos]; use 26 to represent null;\\n        int i2 = c2 == null ? 26 : c2 - \\'A\\';\\n        if (dp[i1][i2][pos] == 0) {\\n            dp[i1][i2][pos] = Math.min(dist(c1, curr) + helper(word, pos + 1, curr, c2),\\n                                       dist(c2, curr) + helper(word, pos + 1, c1, curr));\\n        }\\n        return  dp[i1][i2][pos];\\n    }\\n\\n    private int dist(Character a, Character b){\\n        if (a == null || b == null) return 0;\\n        int[] ia = new int[]{(a - \\'A\\') / 6, (a - \\'A\\') % 6};\\n        int[] ib = new int[]{(b - \\'A\\') / 6, (b - \\'A\\') % 6};\\n        int c = ia[0] - ib[0];\\n        c = c < 0 ? -c : c;\\n        int d = ia[1] - ib[1];\\n        d = d < 0 ? -d : d;\\n        return c + d; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][][] dp = new int[27][27][300];\\n    public int minimumDistance(String word) {\\n        return helper(word, 0, null, null);\\n    }\\n    //Memorized Search, next step of pos is either moving c1 or c2 to pos +1;  then calculate from end of string.\\n    private int helper(String word, int pos, Character c1, Character c2) {\\n        if (pos >= word.length()) return 0;  // check pos to avoid stringIndex exception\\n        Character curr = word.charAt(pos);\\n        int i1 = c1 == null ? 26 : c1 - \\'A\\';   // must check null before call dp[i1][i2][pos]; use 26 to represent null;\\n        int i2 = c2 == null ? 26 : c2 - \\'A\\';\\n        if (dp[i1][i2][pos] == 0) {\\n            dp[i1][i2][pos] = Math.min(dist(c1, curr) + helper(word, pos + 1, curr, c2),\\n                                       dist(c2, curr) + helper(word, pos + 1, c1, curr));\\n        }\\n        return  dp[i1][i2][pos];\\n    }\\n\\n    private int dist(Character a, Character b){\\n        if (a == null || b == null) return 0;\\n        int[] ia = new int[]{(a - \\'A\\') / 6, (a - \\'A\\') % 6};\\n        int[] ib = new int[]{(b - \\'A\\') / 6, (b - \\'A\\') % 6};\\n        int c = ia[0] - ib[0];\\n        c = c < 0 ? -c : c;\\n        int d = ia[1] - ib[1];\\n        d = d < 0 ? -d : d;\\n        return c + d; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 478410,
                "title": "c-simple-dp-4-ms-explains-why-hint-2-is-suboptimal",
                "content": "From the problem description:\\n\\n> **[Hint 1]** Use dynamic programming.\\n\\nHint 1 is good. \\uD83D\\uDC4D Dynamic programming makes sense here.\\n\\n> **[Hint 2]** dp[i][j][k]: smallest movements when you have one finger on i-th char and the other one on j-th char already having written k first characters from word.\\n\\nHint 2 points to a reasonable first approach to the problem, but one yielding a suboptimal solution. Since it is never helpful to move the same finger twice in a row without typing anything, we can assume that the previous key that was pressed always has a finger positioned over it. So `dp[i][j][k]` has a redundant element. `dp[i][j]` should be enough because `k` can be deduced from `i`. This reduces both time and space complexity by an order of magnitude.\\n\\nNote that this approach doesn\\'t consider a \"left finger\" and \"right finger\", but rather a \"finger that just typed\" and an \"other finger\". It doesn\\'t matter which is which.\\n\\nFinally, we don\\'t need to keep the whole 2D array stored at all times, since the algorithm only ever refers back to the previous row. So that reduces our space complexity by another order of magnitude, leaving us with:\\n\\nTime complexity: **O(\\u03B1\\xB7N)**\\nSpace complexity: **O(\\u03B1)**\\n\\nwhere **\\u03B1** is the size of the alphabet (in this case \\u03B1 = 26) and **N** is the size of the word.\\n\\n```C++\\nint distance(int a, int b) {\\n  /* Manhattan distance on a keyboard with 6 columns */\\n  return abs(a/6 - b/6) + abs(a%6 - b%6);\\n}\\n\\nint minimumDistance(string w) {\\n  int const N = w.size();\\n\\n  /* Convert all letters in the word to the values 0..25 */\\n  for (char& c : w)\\n    c -= \\'A\\';\\n\\n  /* Dynamic programming */\\n  int dp[2][26] = {0}; // (index of prev char typed % 2) \\u2192 (position of other finger) \\u2192 (cost to type the rest)\\n\\n  for (int i = N-2; i >= 0; --i)\\n    for (int j = 0; j < 26; ++j)\\n      dp[i%2][j] = min(\\n        distance(w[i], w[i+1]) + dp[(i+1)%2][j   ], // moving the finger that just typed\\n        distance(j,    w[i+1]) + dp[(i+1)%2][w[i]]  // moving the other finger\\n      );\\n\\n  /* We assume that the first character is free to type, and leaves one finger on that key.\\n     But we do still need to pick the optimal position for the other finger. */\\n  return *min_element(dp[0], dp[0]+26);\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```C++\\nint distance(int a, int b) {\\n  /* Manhattan distance on a keyboard with 6 columns */\\n  return abs(a/6 - b/6) + abs(a%6 - b%6);\\n}\\n\\nint minimumDistance(string w) {\\n  int const N = w.size();\\n\\n  /* Convert all letters in the word to the values 0..25 */\\n  for (char& c : w)\\n    c -= \\'A\\';\\n\\n  /* Dynamic programming */\\n  int dp[2][26] = {0}; // (index of prev char typed % 2) \\u2192 (position of other finger) \\u2192 (cost to type the rest)\\n\\n  for (int i = N-2; i >= 0; --i)\\n    for (int j = 0; j < 26; ++j)\\n      dp[i%2][j] = min(\\n        distance(w[i], w[i+1]) + dp[(i+1)%2][j   ], // moving the finger that just typed\\n        distance(j,    w[i+1]) + dp[(i+1)%2][w[i]]  // moving the other finger\\n      );\\n\\n  /* We assume that the first character is free to type, and leaves one finger on that key.\\n     But we do still need to pick the optimal position for the other finger. */\\n  return *min_element(dp[0], dp[0]+26);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 478266,
                "title": "o-n-java-dp-neat-soluton",
                "content": "dp solution and short-path solution is actually the same graph model. move finger one by one. There are two choices when we move fingers, one is we just move the finger  which is already in the word to the next character in the word, the other choice is to move the other finger which is maybe not in the word\\'s character but is nearer with the next character.\\nhttps://leetcode.com/problems/minimum-distance-to-type-a-word-using-two-fingers/discuss/478315/dijkstra-algorithm-with-Priority-Queue\\n```\\nclass Solution {\\n    public int minimumDistance(String word) {\\n        // dp[i][j] means when i have printed the first i characters, the other finger is at j (0-26) key what the minimum cost is.\\n        int[][] dp = new int[word.length()][26];\\n        for (int i = 1; i < word.length(); i++){\\n            for (int j = 0; j < 26; j++){\\n                    // just move `i - 1` th character in word to `i`th character\\n                    // keep the other finger is in j key unchanged\\n                    dp[i][j] = dp[i - 1][j] + cost(word.charAt(i) - \\'A\\', word.charAt(i - 1) - \\'A\\');\\n                    if (word.charAt(i - 1) - \\'A\\' == j){\\n                        // if j key is just the i - 1 character, we can also keep the finger at i - 1 character unchanged, move the other finger to i character, in this case we have 26 choices\\n                         for (int k = 0; k < 26; k++){\\n                            dp[i][j] = Math.min(dp[i][j], dp[i - 1][k] + cost(k, word.charAt(i) - \\'A\\'));\\n                        }\\n                    }\\n                }\\n            }\\n        int mini = Integer.MAX_VALUE;\\n        for (int i = 0; i < 26; i++){\\n                if (dp[word.length() -1][i] < mini){\\n                    mini = dp[word.length() - 1][i];\\n                }\\n        }\\n        return mini;\\n    }\\n    int cost(int a, int b){\\n        return Math.abs(a % 6 - b % 6) + Math.abs(a / 6 - b / 6);\\n    }\\n}\\n ```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDistance(String word) {\\n        // dp[i][j] means when i have printed the first i characters, the other finger is at j (0-26) key what the minimum cost is.\\n        int[][] dp = new int[word.length()][26];\\n        for (int i = 1; i < word.length(); i++){\\n            for (int j = 0; j < 26; j++){\\n                    // just move `i - 1` th character in word to `i`th character\\n                    // keep the other finger is in j key unchanged\\n                    dp[i][j] = dp[i - 1][j] + cost(word.charAt(i) - \\'A\\', word.charAt(i - 1) - \\'A\\');\\n                    if (word.charAt(i - 1) - \\'A\\' == j){\\n                        // if j key is just the i - 1 character, we can also keep the finger at i - 1 character unchanged, move the other finger to i character, in this case we have 26 choices\\n                         for (int k = 0; k < 26; k++){\\n                            dp[i][j] = Math.min(dp[i][j], dp[i - 1][k] + cost(k, word.charAt(i) - \\'A\\'));\\n                        }\\n                    }\\n                }\\n            }\\n        int mini = Integer.MAX_VALUE;\\n        for (int i = 0; i < 26; i++){\\n                if (dp[word.length() -1][i] < mini){\\n                    mini = dp[word.length() - 1][i];\\n                }\\n        }\\n        return mini;\\n    }\\n    int cost(int a, int b){\\n        return Math.abs(a % 6 - b % 6) + Math.abs(a / 6 - b / 6);\\n    }\\n}\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 478152,
                "title": "java-dijkstra-time-o-n-logn",
                "content": "```\\nclass Solution {\\n    public int minimumDistance(String s) {\\n        final int N = (s == null) ? 0 : s.length();\\n        if (N <= 2) {\\n            return 0;\\n        }\\n\\n        PriorityQueue<Node> minHeap = new PriorityQueue<>();\\n        Set<Node> visited = new HashSet<>();\\n\\n        minHeap.offer(new Node(-1, 0, 0));\\n\\n        while (!minHeap.isEmpty()) {\\n            Node curr = minHeap.poll();\\n\\n            if (curr.currCharIdx == N - 1) {\\n                return curr.steps;\\n            }\\n\\n            visited.add(curr);\\n\\n            // use the same finger\\n            int nextCharIdx = curr.currCharIdx + 1;\\n            int dist = getDist(s, curr.currCharIdx, nextCharIdx);\\n            Node next = new Node(curr.prevCharIdx, nextCharIdx, curr.steps + dist);\\n            if (!visited.contains(next)) {\\n                minHeap.offer(next);\\n            }\\n\\n            // use another finger\\n            dist = 0;\\n            if (curr.prevCharIdx >= 0) {\\n                dist = getDist(s, curr.prevCharIdx, nextCharIdx);\\n            }\\n            next = new Node(curr.currCharIdx, nextCharIdx, curr.steps + dist);\\n            if (!visited.contains(next)) {\\n                minHeap.offer(next);\\n            }\\n        }\\n\\n        return -1;\\n    }\\n\\n    private int getDist(String s, int idx1, int idx2) {\\n        int[] coord1 = getCoord(s.charAt(idx1));\\n        int[] coord2 = getCoord(s.charAt(idx2));\\n        return Math.abs(coord1[0] - coord2[0]) + Math.abs(coord1[1] - coord2[1]);\\n    }\\n\\n    private int[] getCoord(char ch) {\\n        int idx = ch - \\'A\\';\\n        return new int[] { idx / 6, idx % 6 };\\n    }\\n\\n    static class Node implements Comparable<Node> {\\n        final int prevCharIdx;\\n        final int currCharIdx;\\n        final int steps;\\n\\n        Node(int prevCharIdx, int currCharIdx, int steps) {\\n            this.prevCharIdx = prevCharIdx;\\n            this.currCharIdx = currCharIdx;\\n            this.steps = steps;\\n        }\\n\\n        @Override\\n        public int compareTo(Node that) {\\n            return Integer.compare(this.steps, that.steps);\\n        }\\n\\n        @Override\\n        public int hashCode() {\\n            return currCharIdx * 31 + prevCharIdx;\\n        }\\n\\n        @Override\\n        public boolean equals(Object obj) {\\n            if (this == obj) {\\n                return true;\\n            }\\n\\n            if (!(obj instanceof Node)) {\\n                return false;\\n            }\\n\\n            Node that = (Node) obj;\\n            return this.prevCharIdx == that.prevCharIdx\\n                && this.currCharIdx == that.currCharIdx;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDistance(String s) {\\n        final int N = (s == null) ? 0 : s.length();\\n        if (N <= 2) {\\n            return 0;\\n        }\\n\\n        PriorityQueue<Node> minHeap = new PriorityQueue<>();\\n        Set<Node> visited = new HashSet<>();\\n\\n        minHeap.offer(new Node(-1, 0, 0));\\n\\n        while (!minHeap.isEmpty()) {\\n            Node curr = minHeap.poll();\\n\\n            if (curr.currCharIdx == N - 1) {\\n                return curr.steps;\\n            }\\n\\n            visited.add(curr);\\n\\n            // use the same finger\\n            int nextCharIdx = curr.currCharIdx + 1;\\n            int dist = getDist(s, curr.currCharIdx, nextCharIdx);\\n            Node next = new Node(curr.prevCharIdx, nextCharIdx, curr.steps + dist);\\n            if (!visited.contains(next)) {\\n                minHeap.offer(next);\\n            }\\n\\n            // use another finger\\n            dist = 0;\\n            if (curr.prevCharIdx >= 0) {\\n                dist = getDist(s, curr.prevCharIdx, nextCharIdx);\\n            }\\n            next = new Node(curr.currCharIdx, nextCharIdx, curr.steps + dist);\\n            if (!visited.contains(next)) {\\n                minHeap.offer(next);\\n            }\\n        }\\n\\n        return -1;\\n    }\\n\\n    private int getDist(String s, int idx1, int idx2) {\\n        int[] coord1 = getCoord(s.charAt(idx1));\\n        int[] coord2 = getCoord(s.charAt(idx2));\\n        return Math.abs(coord1[0] - coord2[0]) + Math.abs(coord1[1] - coord2[1]);\\n    }\\n\\n    private int[] getCoord(char ch) {\\n        int idx = ch - \\'A\\';\\n        return new int[] { idx / 6, idx % 6 };\\n    }\\n\\n    static class Node implements Comparable<Node> {\\n        final int prevCharIdx;\\n        final int currCharIdx;\\n        final int steps;\\n\\n        Node(int prevCharIdx, int currCharIdx, int steps) {\\n            this.prevCharIdx = prevCharIdx;\\n            this.currCharIdx = currCharIdx;\\n            this.steps = steps;\\n        }\\n\\n        @Override\\n        public int compareTo(Node that) {\\n            return Integer.compare(this.steps, that.steps);\\n        }\\n\\n        @Override\\n        public int hashCode() {\\n            return currCharIdx * 31 + prevCharIdx;\\n        }\\n\\n        @Override\\n        public boolean equals(Object obj) {\\n            if (this == obj) {\\n                return true;\\n            }\\n\\n            if (!(obj instanceof Node)) {\\n                return false;\\n            }\\n\\n            Node that = (Node) obj;\\n            return this.prevCharIdx == that.prevCharIdx\\n                && this.currCharIdx == that.currCharIdx;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 478022,
                "title": "python-3-eight-lines-beats-100-376-ms-bfs-w-memo",
                "content": "```\\nclass Solution:\\n    def minimumDistance(self, W: str) -> int:\\n        A, B, I, W = {(ord(W[0])-65,-1):0}, {}, math.inf, [ord(w)-65 for w in W]\\n        def dist(u,v): return abs(u//6 - v//6) + abs(u % 6 - v % 6)\\n        for w in W[1:]:\\n            for a in A:\\n                B[(w,a[1])] = min(B.get((w,a[1]),I), A[a] + dist(a[0],w))\\n                B[(a[0],w)] = min(B.get((a[0],w),I), A[a] + (a[1] != -1)*dist(a[1],w))\\n            A, B = B, {}\\n        return min(A.values())\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Memoization"
                ],
                "code": "class Solution:\\n    def minimumDistance(self, W: str) -> int:\\n        A, B, I, W = {(ord(W[0])-65,-1):0}",
                "codeTag": "Java"
            },
            {
                "id": 477845,
                "title": "c-recursion-with-memo",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int dist(pair<int,int> x, pair<int,int> y){\\n        return abs(x.first- y.first) + abs(x.second - y.second);\\n    }\\n    \\n    vector<vector<vector<int>>> cache;\\n    \\n    int helper(string& word, int curr, char x, char y, map<char, pair<int,int>>& data) {\\n        if(word.size() == curr)\\n            return 0;\\n        if(cache[x - \\'A\\'][y - \\'A\\'][curr] != -1)\\n            return cache[x - \\'A\\'][y - \\'A\\'][curr];\\n        int a,b;\\n        if(x == \\'[\\'){\\n            a = helper(word, curr+1, word[curr], y, data);\\n        }\\n        else{\\n            a = dist(data[word[curr]], data[x]) + helper(word, curr+1, word[curr], y, data);\\n        }\\n        if(y == \\'[\\') {\\n            b = helper(word, curr+1, x, word[curr], data);\\n        }\\n        else{\\n            b = dist(data[word[curr]], data[y]) + helper(word, curr+1, x, word[curr], data);\\n        }\\n        cache[x - \\'A\\'][y -\\'A\\'][curr] = min(a,b);\\n        return cache[x - \\'A\\'][y -\\'A\\'][curr];\\n    } \\n    \\n    int minimumDistance(string word) {\\n        map<char, pair<int,int>> data;\\n        int count = 0;\\n        cache.resize(27, vector<vector<int>>(27, vector<int>(word.length(), -1)));\\n        for(int i=0; i<5; i++) {\\n            for(int j=0; j<6; j++) {\\n                if(i == 4 && j ==2)\\n                    break;\\n                data[\\'A\\' + count] = make_pair(i,j);\\n                count++;\\n            }\\n        }\\n        return helper(word, 0, \\'[\\', \\'[\\', data);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dist(pair<int,int> x, pair<int,int> y){\\n        return abs(x.first- y.first) + abs(x.second - y.second);\\n    }\\n    \\n    vector<vector<vector<int>>> cache;\\n    \\n    int helper(string& word, int curr, char x, char y, map<char, pair<int,int>>& data) {\\n        if(word.size() == curr)\\n            return 0;\\n        if(cache[x - \\'A\\'][y - \\'A\\'][curr] != -1)\\n            return cache[x - \\'A\\'][y - \\'A\\'][curr];\\n        int a,b;\\n        if(x == \\'[\\'){\\n            a = helper(word, curr+1, word[curr], y, data);\\n        }\\n        else{\\n            a = dist(data[word[curr]], data[x]) + helper(word, curr+1, word[curr], y, data);\\n        }\\n        if(y == \\'[\\') {\\n            b = helper(word, curr+1, x, word[curr], data);\\n        }\\n        else{\\n            b = dist(data[word[curr]], data[y]) + helper(word, curr+1, x, word[curr], data);\\n        }\\n        cache[x - \\'A\\'][y -\\'A\\'][curr] = min(a,b);\\n        return cache[x - \\'A\\'][y -\\'A\\'][curr];\\n    } \\n    \\n    int minimumDistance(string word) {\\n        map<char, pair<int,int>> data;\\n        int count = 0;\\n        cache.resize(27, vector<vector<int>>(27, vector<int>(word.length(), -1)));\\n        for(int i=0; i<5; i++) {\\n            for(int j=0; j<6; j++) {\\n                if(i == 4 && j ==2)\\n                    break;\\n                data[\\'A\\' + count] = make_pair(i,j);\\n                count++;\\n            }\\n        }\\n        return helper(word, 0, \\'[\\', \\'[\\', data);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477770,
                "title": "java-brute-recursion-memoization",
                "content": "* The state of the sub-problem depends on the position of the fingers and the index of the string till which you have typed. \\n* From the state, you will be able to find the dimensionality of the problem.\\n* Any sub-problem can be uniquely identified from the x co-ordinate of finger1, y co-ordinate of finger 1, x co-ordinate of finger 2, y co-ordinate of finger 2 and the index of the string(word) till which you have typed, so you can store the answer to this sub-problem in the 5D array or any other data structure so that, if you come across it again, you can fetch it in O(1) time.\\n\\n\\nThe solution can be improved by combining the x and y co-ordinates of the two fingers separately.\\n```\\nclass Solution {\\n    public static int function(String word, int n, int i, int f1x, int f1y, int f2x, int f2y, HashMap<Character, String> map, int[][][][][] dp) {\\n        if(i == n) return 0;\\n        if(dp[i][f1x][f1y][f2x][f2y] != -1) return dp[i][f1x][f1y][f2x][f2y];\\n        char curr = word.charAt(i);\\n        int currRow = map.get(curr).charAt(0) - \\'0\\';\\n        int currColumn = map.get(curr).charAt(1) - \\'0\\';\\n        int p1 = 0, p2 = 0;\\n        if(f1x != 5 || f1y != 5) p1 += Math.abs(f1x - currRow) + Math.abs(f1y - currColumn);\\n        if(f2x != 5 || f2y != 5) p2 += Math.abs(f2x - currRow) + Math.abs(f2y - currColumn);\\n        p1 += function(word, n, i + 1, currRow, currColumn, f2x, f2y, map, dp);\\n        p2 += function(word, n, i + 1, f1x, f1y, currRow, currColumn, map, dp);\\n        return dp[i][f1x][f1y][f2x][f2y] = Math.min(p1, p2);\\n    }\\n    public int minimumDistance(String word) {\\n        int n = word.length();\\n        HashMap<Character, String> map = new HashMap<>();\\n        int[][][][][] dp = new int[n][6][6][6][6];\\n        for(int l = 0; l < n; l++) {\\n                for(int i = 0; i < 6; i++) {\\n\\t\\t\\t\\t\\tfor(int j = 0; j < 6; j++) {\\n\\t\\t\\t\\t\\t\\tfor(int t = 0; t < 6; t++) {\\n\\t\\t\\t\\t\\t\\t\\tfor(int p = 0; p < 6; p++) dp[l][i][j][t][p] = -1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n            }\\n        }\\n        for(int i = 0; i < 26; i++) {\\n            char curr = (char)(65 + i);\\n            int r = (i % 6), c = (i / 6); \\n            map.put(curr, Integer.toString(r) + Integer.toString(c));\\n        }\\n        return function(word, n, 0, 5, 5, 5, 5, map, dp);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public static int function(String word, int n, int i, int f1x, int f1y, int f2x, int f2y, HashMap<Character, String> map, int[][][][][] dp) {\\n        if(i == n) return 0;\\n        if(dp[i][f1x][f1y][f2x][f2y] != -1) return dp[i][f1x][f1y][f2x][f2y];\\n        char curr = word.charAt(i);\\n        int currRow = map.get(curr).charAt(0) - \\'0\\';\\n        int currColumn = map.get(curr).charAt(1) - \\'0\\';\\n        int p1 = 0, p2 = 0;\\n        if(f1x != 5 || f1y != 5) p1 += Math.abs(f1x - currRow) + Math.abs(f1y - currColumn);\\n        if(f2x != 5 || f2y != 5) p2 += Math.abs(f2x - currRow) + Math.abs(f2y - currColumn);\\n        p1 += function(word, n, i + 1, currRow, currColumn, f2x, f2y, map, dp);\\n        p2 += function(word, n, i + 1, f1x, f1y, currRow, currColumn, map, dp);\\n        return dp[i][f1x][f1y][f2x][f2y] = Math.min(p1, p2);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 477736,
                "title": "same-algorithm-python-tle-java-ac-33ms",
                "content": "```\\nclass Solution {\\n    public int minimumDistance(String word) {\\n        char[] S = word.toCharArray();\\n        int N = S.length, ans = Integer.MAX_VALUE, dp[][][] = new int[26][26][N+1];\\n        for(int z = N-1; z >= 0; --z){\\n            for(int x = 0; x < 26; ++x){\\n                for(int y = 0; y < 26; ++y){\\n                    dp[x][y][z] = \\n                        Math.min(cost(x,S[z]-\\'A\\')+dp[S[z]-\\'A\\'][y][z+1],\\n                                 cost(y,S[z]-\\'A\\')+dp[x][S[z]-\\'A\\'][z+1]);\\n                    if (z == 0){\\n                        ans = Math.min(ans, dp[x][y][z]);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    private int cost(int x, int y){\\n        return Math.abs(x/6-y/6)+Math.abs(x%6-y%6);\\n    }\\n}\\n\\n```\\n\\n```\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n\\t\\tdef cost(x,y):\\n\\t\\t\\t\\treturn abs(x//6-y//6)+abs(x%6-y%6)\\n        S=word\\n        ans=float(\\'inf\\')\\n        N=len(word)\\n        dp = [[[0 for x in range (N+1)] for y in range (26)] for z in range (26)]\\n        for z in range (N-1,-1,-1):\\n            for x in range (26):\\n                for y in range (26):\\n                    dp[x][y][z]=min(cost(x,ord(S[z])-65)+dp[ord(S[z])-65][y][z+1],cost(y,ord(S[z])-65)+dp[x][ord(S[z])-65][z+1])\\n                    if z==0:\\n                        ans=min(ans,dp[x][y][z])\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDistance(String word) {\\n        char[] S = word.toCharArray();\\n        int N = S.length, ans = Integer.MAX_VALUE, dp[][][] = new int[26][26][N+1];\\n        for(int z = N-1; z >= 0; --z){\\n            for(int x = 0; x < 26; ++x){\\n                for(int y = 0; y < 26; ++y){\\n                    dp[x][y][z] = \\n                        Math.min(cost(x,S[z]-\\'A\\')+dp[S[z]-\\'A\\'][y][z+1],\\n                                 cost(y,S[z]-\\'A\\')+dp[x][S[z]-\\'A\\'][z+1]);\\n                    if (z == 0){\\n                        ans = Math.min(ans, dp[x][y][z]);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    private int cost(int x, int y){\\n        return Math.abs(x/6-y/6)+Math.abs(x%6-y%6);\\n    }\\n}\\n\\n```\n```\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n\\t\\tdef cost(x,y):\\n\\t\\t\\t\\treturn abs(x//6-y//6)+abs(x%6-y%6)\\n        S=word\\n        ans=float(\\'inf\\')\\n        N=len(word)\\n        dp = [[[0 for x in range (N+1)] for y in range (26)] for z in range (26)]\\n        for z in range (N-1,-1,-1):\\n            for x in range (26):\\n                for y in range (26):\\n                    dp[x][y][z]=min(cost(x,ord(S[z])-65)+dp[ord(S[z])-65][y][z+1],cost(y,ord(S[z])-65)+dp[x][ord(S[z])-65][z+1])\\n                    if z==0:\\n                        ans=min(ans,dp[x][y][z])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477716,
                "title": "python-o-n-top-down",
                "content": "with a large constant time `26*26*2`\\n```python\\nfrom functools import lru_cache\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        word = list(map(lambda x: ord(x)-ord(\\'A\\'),word))\\n        n = len(word)\\n        @lru_cache(None)\\n        def dfs(x,y,idx):\\n            if idx == n:\\n                return 0\\n            ch = word[idx]\\n            r, c = ch//6, ch%6\\n            rx, cx = x//6, x%6\\n            ry, cy = y//6, y%6\\n            return min(dfs(ch,y,idx+1)+abs(r-rx)+abs(c-cx),dfs(x,ch,idx+1)+abs(r-ry)+abs(c-cy))\\n        return min(dfs(i,j,0) for i in range(26) for j in range(26))\\n\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom functools import lru_cache\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        word = list(map(lambda x: ord(x)-ord(\\'A\\'),word))\\n        n = len(word)\\n        @lru_cache(None)\\n        def dfs(x,y,idx):\\n            if idx == n:\\n                return 0\\n            ch = word[idx]\\n            r, c = ch//6, ch%6\\n            rx, cx = x//6, x%6\\n            ry, cy = y//6, y%6\\n            return min(dfs(ch,y,idx+1)+abs(r-rx)+abs(c-cx),dfs(x,ch,idx+1)+abs(r-ry)+abs(c-cy))\\n        return min(dfs(i,j,0) for i in range(26) for j in range(26))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4087148,
                "title": "c-top-down-dp-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTwo finger in the air at the first time, and we can choose one finger to put at the char to start.\\n\\nAnd at step 2, we can choose to move the previous finger to the new char and cost Manhatten distance;\\nOr we can place another finger to this char and cost nothing.\\n\\nEvery decision you made will affect the future cost, \\nor you can look from the other angle that this step can calculated by some (might repeated) sub-problems.\\n\\nThus, DP is the obvious choise.\\n\\n---\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will have an index to scan through the char of the string.\\n\\nAnd another two variable left and right that indicate the left finger and the right finger position where\\n* 0 ~ 25 indicate char a ~ z\\n* 26 indicate that finger is still in the air.\\n\\nWe use top-down DP to do the trick.\\nFor every step, we try to move left finger and right finger to find the minimum cost.\\n\\nOne sub-function to calculate the cost.\\n* If finger is in the air (index 26) or at the target position (index == target) return 0 cost.\\n* Otherwise calculating the Manhattan distance between two char.\\nHere we use 1-D to 2-D transfer to calculate the cost.\\nYou can use other method will do the same trick.\\n\\n---\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(27*27*n)$$ where n is the length of the word\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(27*27*n)$$\\n\\n---\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDistance(string word) {\\n        vector<vector<vector<int>>> mem(word.size(), vector<vector<int>>(27, vector<int>(27, -1)));\\n        return dp(word, 0, 26, 26, mem);\\n    }\\nprivate:\\n    int dp(string& word, int index, int left, int right, vector<vector<vector<int>>>& mem){\\n        if(index==word.size()) return 0; //at the end of the word\\n        if(mem[index][left][right]!=-1) return mem[index][left][right]; //repeated sub-problem\\n\\n        int target = word[index]-\\'A\\'; //transfer char a-z to index 0-25\\n\\n        //find minimum cost between moving left finger and moving right finger\\n        int res = min(dp(word, index+1, target, right, mem)+calCost(target, left)\\n                    , dp(word, index+1, left, target, mem)+calCost(target, right));\\n\\n        return mem[index][left][right] = res;\\n    }\\n\\n    int calCost(int target, int pos){\\n        if(pos==26 || pos==target) return 0; //finger in the air or already at the place\\n\\n        //otherwise calculate the Manhattan distance\\n        int px = pos/6, py = pos%6;\\n        int tx = target/6, ty = target%6;\\n        return (abs(px-tx)+abs(py-ty));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDistance(string word) {\\n        vector<vector<vector<int>>> mem(word.size(), vector<vector<int>>(27, vector<int>(27, -1)));\\n        return dp(word, 0, 26, 26, mem);\\n    }\\nprivate:\\n    int dp(string& word, int index, int left, int right, vector<vector<vector<int>>>& mem){\\n        if(index==word.size()) return 0; //at the end of the word\\n        if(mem[index][left][right]!=-1) return mem[index][left][right]; //repeated sub-problem\\n\\n        int target = word[index]-\\'A\\'; //transfer char a-z to index 0-25\\n\\n        //find minimum cost between moving left finger and moving right finger\\n        int res = min(dp(word, index+1, target, right, mem)+calCost(target, left)\\n                    , dp(word, index+1, left, target, mem)+calCost(target, right));\\n\\n        return mem[index][left][right] = res;\\n    }\\n\\n    int calCost(int target, int pos){\\n        if(pos==26 || pos==target) return 0; //finger in the air or already at the place\\n\\n        //otherwise calculate the Manhattan distance\\n        int px = pos/6, py = pos%6;\\n        int tx = target/6, ty = target%6;\\n        return (abs(px-tx)+abs(py-ty));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066458,
                "title": "simple-dp-in-python3",
                "content": "# Code\\n```\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        def place(l):\\n            a = ord(l) - ord(\\'A\\')\\n            return (a//6,a%6)\\n        places = {a:place(a) for a in \\'ABCDEFGHIJKLMNOPQRSTUVWXYZ\\'}\\n        def dist(a,b):\\n            if a == None:\\n                return 0\\n            return abs(place(a)[0] - place(b)[0])+abs(place(a)[1] - place(b)[1])\\n        @cache\\n        def dp(i,j,k):\\n            if k == len(word)-1:\\n                return 0\\n            else:\\n                return min(dist(i,word[k+1])+dp(word[k+1],j,k+1),dist(j,word[k+1])+dp(i,word[k+1],k+1))\\n        return dp(None,None,-1)\\n\\n            \\n\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        def place(l):\\n            a = ord(l) - ord(\\'A\\')\\n            return (a//6,a%6)\\n        places = {a:place(a) for a in \\'ABCDEFGHIJKLMNOPQRSTUVWXYZ\\'}\\n        def dist(a,b):\\n            if a == None:\\n                return 0\\n            return abs(place(a)[0] - place(b)[0])+abs(place(a)[1] - place(b)[1])\\n        @cache\\n        def dp(i,j,k):\\n            if k == len(word)-1:\\n                return 0\\n            else:\\n                return min(dist(i,word[k+1])+dp(word[k+1],j,k+1),dist(j,word[k+1])+dp(i,word[k+1],k+1))\\n        return dp(None,None,-1)\\n\\n            \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056256,
                "title": "noticeboard-0ms-100-time-90-space",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[301][27];\\n\\n    int cost(int source, int target){\\n        if(source == 26)        return 0;\\n        return abs(target/6-source/6) + abs(target%6 - source%6);\\n    }\\n\\n    int func(string& word, int i, int other){\\n\\n        if(i == word.length())      return 0;\\n        if(dp[i][other] != -1)       return dp[i][other];\\n\\n        int last = word[i-1]-\\'A\\';\\n\\n        int f1M = cost(last,word[i]-\\'A\\') + func(word,i+1,other);\\n        int f2M = cost(other,word[i]-\\'A\\') + func(word,i+1,last);\\n        \\n        dp[i][other] = min(f1M,f2M);\\n        return dp[i][other];\\n    }\\n\\n    int minimumDistance(string word) {\\n        memset(dp,-1,sizeof(dp));\\n\\n        int l = 26;\\n\\n        return func(word,1,l);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[301][27];\\n\\n    int cost(int source, int target){\\n        if(source == 26)        return 0;\\n        return abs(target/6-source/6) + abs(target%6 - source%6);\\n    }\\n\\n    int func(string& word, int i, int other){\\n\\n        if(i == word.length())      return 0;\\n        if(dp[i][other] != -1)       return dp[i][other];\\n\\n        int last = word[i-1]-\\'A\\';\\n\\n        int f1M = cost(last,word[i]-\\'A\\') + func(word,i+1,other);\\n        int f2M = cost(other,word[i]-\\'A\\') + func(word,i+1,last);\\n        \\n        dp[i][other] = min(f1M,f2M);\\n        return dp[i][other];\\n    }\\n\\n    int minimumDistance(string word) {\\n        memset(dp,-1,sizeof(dp));\\n\\n        int l = 26;\\n\\n        return func(word,1,l);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049003,
                "title": "recursion-memoization-super-easy-c",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int n;\\n    map<char,pair<int,int>> m;\\n    int dp[30][30][301];\\n    int f(char i, char j, int ind, string &word)\\n    {\\n        if(ind==word.size()) return 0;\\n        if(dp[i-\\'A\\'][j-\\'A\\'][ind]!=-1) return dp[i-\\'A\\'][j-\\'A\\'][ind];\\n        int firstX=m[i].first, firstY=m[i].second;\\n        int targetX=m[word[ind]].first, targetY=m[word[ind]].second;\\n        int first=abs(firstX-targetX)+abs(firstY-targetY)+f(word[ind],j,ind+1,word);\\n        int second=f(i,word[ind],ind+1,word);\\n        if(j!=\\'[\\')\\n        {\\n            int secondX=m[j].first, secondY=m[j].second;\\n            second+=abs(secondX-targetX)+abs(secondY-targetY);\\n        }\\n        return dp[i-\\'A\\'][j-\\'A\\'][ind]=min(first,second);\\n    }\\n    int minimumDistance(string word) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        n=word.size();\\n        char ch=\\'A\\';\\n        for(int x=0; x<=3; x++)\\n        {\\n            for(int y=0; y<=5; y++) m[ch++]={x,y};\\n        }\\n        m[\\'Y\\']={4,0};\\n        m[\\'Z\\']={4,1};\\n        return f(word[0],\\'[\\',1,word);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int n;\\n    map<char,pair<int,int>> m;\\n    int dp[30][30][301];\\n    int f(char i, char j, int ind, string &word)\\n    {\\n        if(ind==word.size()) return 0;\\n        if(dp[i-\\'A\\'][j-\\'A\\'][ind]!=-1) return dp[i-\\'A\\'][j-\\'A\\'][ind];\\n        int firstX=m[i].first, firstY=m[i].second;\\n        int targetX=m[word[ind]].first, targetY=m[word[ind]].second;\\n        int first=abs(firstX-targetX)+abs(firstY-targetY)+f(word[ind],j,ind+1,word);\\n        int second=f(i,word[ind],ind+1,word);\\n        if(j!=\\'[\\')\\n        {\\n            int secondX=m[j].first, secondY=m[j].second;\\n            second+=abs(secondX-targetX)+abs(secondY-targetY);\\n        }\\n        return dp[i-\\'A\\'][j-\\'A\\'][ind]=min(first,second);\\n    }\\n    int minimumDistance(string word) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        n=word.size();\\n        char ch=\\'A\\';\\n        for(int x=0; x<=3; x++)\\n        {\\n            for(int y=0; y<=5; y++) m[ch++]={x,y};\\n        }\\n        m[\\'Y\\']={4,0};\\n        m[\\'Z\\']={4,1};\\n        return f(word[0],\\'[\\',1,word);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048972,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint dis(char prev,char cur)\\n{\\n    if (prev==\\'@\\') return 0;\\n    int r1=(prev-\\'A\\')/6;\\n    int r2=(cur-\\'A\\')/6;\\n    int c1=(prev-\\'A\\')%6;\\n    int c2=(cur-\\'A\\')%6;\\n    return abs(r1-r2)+abs(c1-c2);\\n}\\n    int rec(int ind,string &word,int l,int r,vector<vector<vector<int>>>&dp)\\n    {\\n        if (ind==word.size()) return 0;\\n        int v1=l-\\'@\\';\\n        int v2=r-\\'@\\';\\n        if (dp[ind][v1][v2]!=-1) return dp[ind][v1][v2];\\n        int ans1=dis(l,word[ind])+rec(ind+1,word,word[ind],r,dp);\\n        int ans2=dis(r,word[ind])+rec(ind+1,word,l,word[ind],dp);\\n        return dp[ind][v1][v2]=min(ans1,ans2);\\n    }\\n    int minimumDistance(string word) \\n    {\\n       int n=word.size();\\n        vector<vector<vector<int>>>dp(n,vector<vector<int>>(28,vector<int>(28,-1)));\\n        return rec(0,word,\\'@\\',\\'@\\',dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint dis(char prev,char cur)\\n{\\n    if (prev==\\'@\\') return 0;\\n    int r1=(prev-\\'A\\')/6;\\n    int r2=(cur-\\'A\\')/6;\\n    int c1=(prev-\\'A\\')%6;\\n    int c2=(cur-\\'A\\')%6;\\n    return abs(r1-r2)+abs(c1-c2);\\n}\\n    int rec(int ind,string &word,int l,int r,vector<vector<vector<int>>>&dp)\\n    {\\n        if (ind==word.size()) return 0;\\n        int v1=l-\\'@\\';\\n        int v2=r-\\'@\\';\\n        if (dp[ind][v1][v2]!=-1) return dp[ind][v1][v2];\\n        int ans1=dis(l,word[ind])+rec(ind+1,word,word[ind],r,dp);\\n        int ans2=dis(r,word[ind])+rec(ind+1,word,l,word[ind],dp);\\n        return dp[ind][v1][v2]=min(ans1,ans2);\\n    }\\n    int minimumDistance(string word) \\n    {\\n       int n=word.size();\\n        vector<vector<vector<int>>>dp(n,vector<vector<int>>(28,vector<int>(28,-1)));\\n        return rec(0,word,\\'@\\',\\'@\\',dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040429,
                "title": "dp-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[301][28][28];\\n    int score(int prev,int curr){\\n        int x1=prev/6;\\n        int y1=prev%6;\\n        int x2=curr/6;\\n        int y2=curr%6;\\n        return abs(x1-x2)+abs(y1-y2);\\n    }\\n    int solve(int index,int f1,int f2,string s){\\n        if(index==s.size()) return 0;\\n        if(dp[index][f1][f2]!=-1) return dp[index][f1][f2];\\n        int k1=INT_MAX;\\n        int k2=INT_MAX;\\n        if(f1==27) k1=solve(index+1,s[index]-\\'A\\',f2,s);\\n        else k1=solve(index+1,s[index]-\\'A\\',f2,s)+score(f1,s[index]-\\'A\\');\\n        if(f2==27) k2=solve(index+1,f1,s[index]-\\'A\\',s);\\n        else k2=solve(index+1,f1,s[index]-\\'A\\',s)+score(f2,s[index]-\\'A\\');\\n        return dp[index][f1][f2]=min(k1,k2);\\n    }\\n    int minimumDistance(string word) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,27,27,word);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[301][28][28];\\n    int score(int prev,int curr){\\n        int x1=prev/6;\\n        int y1=prev%6;\\n        int x2=curr/6;\\n        int y2=curr%6;\\n        return abs(x1-x2)+abs(y1-y2);\\n    }\\n    int solve(int index,int f1,int f2,string s){\\n        if(index==s.size()) return 0;\\n        if(dp[index][f1][f2]!=-1) return dp[index][f1][f2];\\n        int k1=INT_MAX;\\n        int k2=INT_MAX;\\n        if(f1==27) k1=solve(index+1,s[index]-\\'A\\',f2,s);\\n        else k1=solve(index+1,s[index]-\\'A\\',f2,s)+score(f1,s[index]-\\'A\\');\\n        if(f2==27) k2=solve(index+1,f1,s[index]-\\'A\\',s);\\n        else k2=solve(index+1,f1,s[index]-\\'A\\',s)+score(f2,s[index]-\\'A\\');\\n        return dp[index][f1][f2]=min(k1,k2);\\n    }\\n    int minimumDistance(string word) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,27,27,word);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960712,
                "title": "rust-top-down-dp-3",
                "content": "# Intuition\\n\\nJust dynamic programming...\\n\\n# Approach\\n\\nCache the result with finger starting positions + string indices.\\n\\n1D bottom-up dynamic programming is also possible.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nconst ALP_LEN: usize = 26;\\nconst ROW_LEN: usize = 6;\\n\\nfn to_coord(op: usize) -> [usize; 2] {\\n    if op >= ALP_LEN { panic!(); }\\n\\n    [op / ROW_LEN, op % ROW_LEN]\\n}\\n\\nfn abs_diff(op_0: usize, op_1: usize) -> usize {\\n    if op_0 < op_1 {\\n        op_1 - op_0\\n    } else { op_0 - op_1 }\\n}\\n\\npub fn keybr_dist(\\n    op_0: usize, op_1: usize,\\n) -> usize {\\n    let coord_0 = to_coord(op_0);\\n    let coord_1 = to_coord(op_1);\\n\\n    coord_0.into_iter()\\n        .zip(coord_1.into_iter())\\n        .map(|(&e0, &e1)| abs_diff(e0, e1))\\n        .sum::<usize>()\\n}\\n\\npub struct DP {\\n    vec: Vec<usize>,\\n    n: usize,\\n\\n    memo: Vec<Vec<Vec<Option<usize>>>>,\\n}\\n\\nimpl DP {\\n    pub fn new(s: String) -> Self {\\n        let n = s.len();\\n        let vec = s.chars()\\n            .map(|c| c as usize - \\'A\\' as usize)\\n            .collect::<Vec<_>>();\\n        \\n        let memo = vec![\\n            vec![\\n                vec![None; n + 1];\\n                ALP_LEN\\n            ];\\n            ALP_LEN\\n        ];\\n\\n        Self { vec, n, memo }\\n    }\\n\\n    pub fn solve(\\n        &mut self,\\n        ptr_0: usize,\\n        ptr_1: usize,\\n        steps: usize,\\n    ) -> usize {\\n        if ptr_0 >= ALP_LEN { return usize::MAX; }\\n        if ptr_1 >= ALP_LEN { return usize::MAX; }\\n        if steps > self.n { return usize::MIN; }\\n\\n        if let Some(ret) = self.memo[ptr_0][ptr_1][steps] {\\n            return ret; // cached\\n        }\\n\\n        let ret = self.solve_inner(ptr_0, ptr_1, steps);\\n        self.memo[ptr_0][ptr_1][steps] = Some(ret);\\n        ret\\n    }\\n\\n    fn solve_inner(\\n        &mut self,\\n        ptr_0: usize,\\n        ptr_1: usize,\\n        steps: usize,\\n    ) -> usize {\\n        if steps >= self.n { return usize::MIN; }\\n\\n        let ptr_next = self.vec[steps];\\n        let steps_next = steps + 1;\\n\\n        let mut ret = usize::MAX;\\n        { // move finger 0\\n            let mut _ret = usize::MIN;\\n            _ret += self.solve(ptr_next, ptr_1, steps_next);\\n            _ret += keybr_dist(ptr_0, ptr_next);\\n            ret = ret.min(_ret);\\n        }\\n\\n        { // move finger 1\\n            let mut _ret = usize::MIN;\\n            _ret += self.solve(ptr_0, ptr_next, steps_next);\\n            _ret += keybr_dist(ptr_1, ptr_next);\\n            ret = ret.min(_ret);\\n        }\\n\\n        ret\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn minimum_distance(word: String) -> i32 {\\n        let mut ret = usize::MAX;\\n\\n        let mut dp = DP::new(word);\\n        for ptr_0 in 0..ALP_LEN {\\n            for ptr_1 in 0..ALP_LEN {\\n                let _ret = dp.solve(ptr_0, ptr_1, usize::MIN);\\n                \\n                ret = ret.min(_ret);\\n            }\\n        }\\n\\n        ret as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Dynamic Programming"
                ],
                "code": "```\\nconst ALP_LEN: usize = 26;\\nconst ROW_LEN: usize = 6;\\n\\nfn to_coord(op: usize) -> [usize; 2] {\\n    if op >= ALP_LEN { panic!(); }\\n\\n    [op / ROW_LEN, op % ROW_LEN]\\n}\\n\\nfn abs_diff(op_0: usize, op_1: usize) -> usize {\\n    if op_0 < op_1 {\\n        op_1 - op_0\\n    } else { op_0 - op_1 }\\n}\\n\\npub fn keybr_dist(\\n    op_0: usize, op_1: usize,\\n) -> usize {\\n    let coord_0 = to_coord(op_0);\\n    let coord_1 = to_coord(op_1);\\n\\n    coord_0.into_iter()\\n        .zip(coord_1.into_iter())\\n        .map(|(&e0, &e1)| abs_diff(e0, e1))\\n        .sum::<usize>()\\n}\\n\\npub struct DP {\\n    vec: Vec<usize>,\\n    n: usize,\\n\\n    memo: Vec<Vec<Vec<Option<usize>>>>,\\n}\\n\\nimpl DP {\\n    pub fn new(s: String) -> Self {\\n        let n = s.len();\\n        let vec = s.chars()\\n            .map(|c| c as usize - \\'A\\' as usize)\\n            .collect::<Vec<_>>();\\n        \\n        let memo = vec![\\n            vec![\\n                vec![None; n + 1];\\n                ALP_LEN\\n            ];\\n            ALP_LEN\\n        ];\\n\\n        Self { vec, n, memo }\\n    }\\n\\n    pub fn solve(\\n        &mut self,\\n        ptr_0: usize,\\n        ptr_1: usize,\\n        steps: usize,\\n    ) -> usize {\\n        if ptr_0 >= ALP_LEN { return usize::MAX; }\\n        if ptr_1 >= ALP_LEN { return usize::MAX; }\\n        if steps > self.n { return usize::MIN; }\\n\\n        if let Some(ret) = self.memo[ptr_0][ptr_1][steps] {\\n            return ret; // cached\\n        }\\n\\n        let ret = self.solve_inner(ptr_0, ptr_1, steps);\\n        self.memo[ptr_0][ptr_1][steps] = Some(ret);\\n        ret\\n    }\\n\\n    fn solve_inner(\\n        &mut self,\\n        ptr_0: usize,\\n        ptr_1: usize,\\n        steps: usize,\\n    ) -> usize {\\n        if steps >= self.n { return usize::MIN; }\\n\\n        let ptr_next = self.vec[steps];\\n        let steps_next = steps + 1;\\n\\n        let mut ret = usize::MAX;\\n        { // move finger 0\\n            let mut _ret = usize::MIN;\\n            _ret += self.solve(ptr_next, ptr_1, steps_next);\\n            _ret += keybr_dist(ptr_0, ptr_next);\\n            ret = ret.min(_ret);\\n        }\\n\\n        { // move finger 1\\n            let mut _ret = usize::MIN;\\n            _ret += self.solve(ptr_0, ptr_next, steps_next);\\n            _ret += keybr_dist(ptr_1, ptr_next);\\n            ret = ret.min(_ret);\\n        }\\n\\n        ret\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn minimum_distance(word: String) -> i32 {\\n        let mut ret = usize::MAX;\\n\\n        let mut dp = DP::new(word);\\n        for ptr_0 in 0..ALP_LEN {\\n            for ptr_1 in 0..ALP_LEN {\\n                let _ret = dp.solve(ptr_0, ptr_1, usize::MIN);\\n                \\n                ret = ret.min(_ret);\\n            }\\n        }\\n\\n        ret as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3905729,
                "title": "dijkstra-top-down-python",
                "content": "\\n```py\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        \\n        \\n        def distance(x,y):\\n            r1,c1 = (ord(x) - ord(\\'A\\')) // 6,(ord(x) - ord(\\'A\\')) % 6\\n            r2,c2 = (ord(y) - ord(\\'A\\')) // 6,(ord(y) - ord(\\'A\\')) % 6\\n            return abs(r1 - r2) + abs(c1 - c2) \\n            \\n\\n        heap = []\\n        \\n        heappush(heap, (0, \\'\\', \\'\\', 0))\\n        seen = set()\\n        while heap:\\n            \\n            cost, f1, f2,idx = heappop(heap)\\n            if (f1,f2,idx) in seen or (f2,f1,idx) in seen:\\n                continue\\n            seen.add((f1, f2, idx))\\n            seen.add((f2, f1, idx))\\n            if idx == len(word):\\n                return cost\\n            \\n            if f1 != \\'\\':\\n                #move finger1\\n                heappush(heap, (cost + distance(f1,word[idx]), word[idx], f2, idx + 1))\\n            else:\\n                heappush(heap, (cost, word[idx], f2, idx + 1))\\n            if f2 != \\'\\':\\n                #move finger2\\n                heappush(heap, (cost + distance(f2,word[idx]), f1, word[idx], idx + 1))\\n            else:\\n                heappush(heap, (cost, f1, word[idx], idx + 1))\\n```\\n\\n```py\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        \\n        \\n        def distance(x,y):\\n            r1,c1 = (ord(x) - ord(\\'A\\')) // 6,(ord(x) - ord(\\'A\\')) % 6\\n            r2,c2 = (ord(y) - ord(\\'A\\')) // 6,(ord(y) - ord(\\'A\\')) % 6\\n            return abs(r1 - r2) + abs(c1 - c2) \\n            \\n        \\n        @cache\\n        def dfs(i,f1,f2):\\n            \\n            if i >= len(word):\\n                return 0\\n            \\n            res = float(\\'inf\\')\\n            \\n            if f1 != \\'\\':\\n                #move finger1\\n                res = min(res, dfs(i + 1,word[i], f2) + distance(f1,word[i]))\\n            else:\\n                res = min(res, dfs(i + 1,word[i], f2))\\n            if f2 != \\'\\':\\n                #move finger2\\n                res = min(res, dfs(i + 1,f1, word[i]) + distance(f2,word[i]))\\n            else:\\n                res = min(res, dfs(i + 1,f1, word[i]))\\n            \\n            \\n            return res\\n        \\n        return dfs(0,\\'\\',\\'\\')",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```py\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        \\n        \\n        def distance(x,y):\\n            r1,c1 = (ord(x) - ord(\\'A\\')) // 6,(ord(x) - ord(\\'A\\')) % 6\\n            r2,c2 = (ord(y) - ord(\\'A\\')) // 6,(ord(y) - ord(\\'A\\')) % 6\\n            return abs(r1 - r2) + abs(c1 - c2) \\n            \\n\\n        heap = []\\n        \\n        heappush(heap, (0, \\'\\', \\'\\', 0))\\n        seen = set()\\n        while heap:\\n            \\n            cost, f1, f2,idx = heappop(heap)\\n            if (f1,f2,idx) in seen or (f2,f1,idx) in seen:\\n                continue\\n            seen.add((f1, f2, idx))\\n            seen.add((f2, f1, idx))\\n            if idx == len(word):\\n                return cost\\n            \\n            if f1 != \\'\\':\\n                #move finger1\\n                heappush(heap, (cost + distance(f1,word[idx]), word[idx], f2, idx + 1))\\n            else:\\n                heappush(heap, (cost, word[idx], f2, idx + 1))\\n            if f2 != \\'\\':\\n                #move finger2\\n                heappush(heap, (cost + distance(f2,word[idx]), f1, word[idx], idx + 1))\\n            else:\\n                heappush(heap, (cost, f1, word[idx], idx + 1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831990,
                "title": "python-dp-with-explanation",
                "content": "The simple intuition is that either the first finger can type a character or the second finger can type a character and we have to just check if it\\'s the first character that either finger is going to type because in that case the distance cost is 0.\\nRecursively call and memoize the different states and in each function call update the position of the fingers\\n```\\nclass Solution:\\n    \\n    def f(self, i, f1, f2, word, xy):\\n        if i==len(word):\\n            return 0\\n        if self.dp[(i, f1, f2)] != -1:\\n            return self.dp[(i, f1, f2)]\\n        \\n        f1_cost = self.f(i+1, xy[word[i]], f2, word, xy)\\n        f2_cost = self.f(i+1, f1, xy[word[i]], word, xy)\\n        if f1!=(-1, -1):\\n            f1_cost += abs(xy[word[i]][0]-f1[0]) + abs(xy[word[i]][1]-f1[1])\\n        if f2!=(-1, -1):\\n            f2_cost += abs(xy[word[i]][0]-f2[0]) + abs(xy[word[i]][1]-f2[1])  \\n        # print(i, f1, f2, f1_cost, f2_cost)\\n        \\n        self.dp[(i, f1, f2)] = min(f1_cost, f2_cost)\\n        return self.dp[(i, f1, f2)]\\n        \\n    \\n    def minimumDistance(self, word: str) -> int:\\n        \\n        xy = dict()\\n        x = 0\\n        y = 0\\n        for i in range(65, 65+26):\\n            xy[chr(i)] = (x, y)\\n            y += 1\\n            if y==6:\\n                y = 0\\n                x += 1\\n        # print(xy)\\n        self.dp = defaultdict(lambda: -1)\\n        return self.f(0, (-1, -1), (-1, -1), word, xy)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def f(self, i, f1, f2, word, xy):\\n        if i==len(word):\\n            return 0\\n        if self.dp[(i, f1, f2)] != -1:\\n            return self.dp[(i, f1, f2)]\\n        \\n        f1_cost = self.f(i+1, xy[word[i]], f2, word, xy)\\n        f2_cost = self.f(i+1, f1, xy[word[i]], word, xy)\\n        if f1!=(-1, -1):\\n            f1_cost += abs(xy[word[i]][0]-f1[0]) + abs(xy[word[i]][1]-f1[1])\\n        if f2!=(-1, -1):\\n            f2_cost += abs(xy[word[i]][0]-f2[0]) + abs(xy[word[i]][1]-f2[1])  \\n        # print(i, f1, f2, f1_cost, f2_cost)\\n        \\n        self.dp[(i, f1, f2)] = min(f1_cost, f2_cost)\\n        return self.dp[(i, f1, f2)]\\n        \\n    \\n    def minimumDistance(self, word: str) -> int:\\n        \\n        xy = dict()\\n        x = 0\\n        y = 0\\n        for i in range(65, 65+26):\\n            xy[chr(i)] = (x, y)\\n            y += 1\\n            if y==6:\\n                y = 0\\n                x += 1\\n        # print(xy)\\n        self.dp = defaultdict(lambda: -1)\\n        return self.f(0, (-1, -1), (-1, -1), word, xy)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800556,
                "title": "my-solutions",
                "content": "**1. Use the `std::priority_queue`**\\n```\\n/**\\n * Time Complexity: O(n * log(n))\\n * Space Complexity: O(n)\\n * where `n` is the length of the string `word`\\n */\\nclass Solution {\\n public:\\n  int minimumDistance(const string &word) {\\n    /**\\n     * {\\n     *   <0>, the total distance\\n     *   <1>, the length of the word the characters of which have been typed\\n     *   <2>, the position of the first finger\\n     *   <3>, the position of the second finger\\n     * }\\n     */\\n    using pq_node_t = tuple<int, int, int, int>;\\n    constexpr int letters = 26;\\n    constexpr char big_a = \\'A\\';\\n    const int n = static_cast<int>(word.size());\\n    priority_queue<pq_node_t, vector<pq_node_t>, greater<>> pq;\\n    pq.emplace(0, 0, 0, 0);\\n    bool visited[n + 1][letters + 1][letters + 1];\\n    memset(visited, 0, sizeof(visited));\\n    while (!pq.empty()) {\\n      const auto [d, l, f, s] = pq.top();\\n      if (l == n) {\\n        return d;\\n      }\\n      pq.pop();\\n      if (visited[l][f][s]) {\\n        continue;\\n      }\\n      visited[l][f][s] = true;\\n      \\n      const int nl = l + 1;\\n      const int nfs = word[l] - big_a + 1;\\n      // 1. try to use the first finger\\n      if (!visited[nl][nfs][s]) {\\n        pq.emplace(d + (f == 0 ? 0 : distance(f - 1, nfs - 1)), nl, nfs, s);\\n      }\\n        \\n      // 2. try to use the second finger\\n      if (!visited[nl][f][nfs]) {\\n        pq.emplace(d + (s == 0 ? 0 : distance(s - 1, nfs - 1)), nl, f, nfs);\\n      }\\n    }\\n    throw \"impossible path\";\\n  }\\n  \\n private:\\n  int distance(const int l1, const int l2) {\\n    constexpr int cols = 6;\\n    const int r1 = l1 / cols;\\n    const int c1 = l1 % cols;\\n    const int r2 = l2 / cols;\\n    const int c2 = l2 % cols;\\n    return abs(r1 - r2) + abs(c1 - c2);\\n  }\\n};\\n```\\n**2. Use the DP**\\n```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(1)\\n * where `n` is the length of the string `word`\\n */\\nclass Solution {\\n public:\\n  int minimumDistance(const string &word) {\\n    constexpr int range = 2;\\n    constexpr int letters = 26;\\n    constexpr char big_a = \\'A\\';\\n    const int n = static_cast<int>(word.size());\\n    uint32_t dp[range][letters + 1][letters + 1];\\n    memset(dp, -1, sizeof(dp));\\n    int previous = 0;\\n    int current = 1;\\n    dp[previous][0][0] = 0;\\n    for (const char c : word) {\\n      const int nfs = c - big_a + 1;\\n      for (int previous_finger1 = 0; previous_finger1 < letters + 1; ++previous_finger1) {\\n        for (int previous_finger2 = 0; previous_finger2 < letters + 1; ++previous_finger2) {\\n          if (dp[previous][previous_finger1][previous_finger2] == -1) {\\n            continue;\\n          }\\n          \\n          // 1. try to use the first finger\\n          dp[current][nfs][previous_finger2] = min(dp[current][nfs][previous_finger2],\\n                                                   dp[previous][previous_finger1][previous_finger2] + (previous_finger1 == 0 ? 0 : distance(previous_finger1 - 1, nfs - 1)));\\n          \\n          // 2. try to use the second finger\\n          dp[current][previous_finger1][nfs] = min(dp[current][previous_finger1][nfs],\\n                                                   dp[previous][previous_finger1][previous_finger2] + (previous_finger2 == 0 ? 0 : distance(previous_finger2 - 1, nfs - 1)));\\n        }\\n      }\\n      \\n      previous ^= 1;\\n      current ^= 1;\\n      memset(dp[current], -1, sizeof(dp[current]));\\n    }\\n    \\n    uint32_t ret = -1;\\n    for (int finger1 = 0; finger1 < letters + 1; ++finger1) {\\n      for (int finger2 = 0; finger2 < letters + 1; ++finger2) {\\n        ret = min(ret, dp[previous][finger1][finger2]);\\n      }\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  int distance(const int l1, const int l2) {\\n    constexpr int cols = 6;\\n    const int r1 = l1 / cols;\\n    const int c1 = l1 % cols;\\n    const int r2 = l2 / cols;\\n    const int c2 = l2 % cols;\\n    return abs(r1 - r2) + abs(c1 - c2);\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n * log(n))\\n * Space Complexity: O(n)\\n * where `n` is the length of the string `word`\\n */\\nclass Solution {\\n public:\\n  int minimumDistance(const string &word) {\\n    /**\\n     * {\\n     *   <0>, the total distance\\n     *   <1>, the length of the word the characters of which have been typed\\n     *   <2>, the position of the first finger\\n     *   <3>, the position of the second finger\\n     * }\\n     */\\n    using pq_node_t = tuple<int, int, int, int>;\\n    constexpr int letters = 26;\\n    constexpr char big_a = \\'A\\';\\n    const int n = static_cast<int>(word.size());\\n    priority_queue<pq_node_t, vector<pq_node_t>, greater<>> pq;\\n    pq.emplace(0, 0, 0, 0);\\n    bool visited[n + 1][letters + 1][letters + 1];\\n    memset(visited, 0, sizeof(visited));\\n    while (!pq.empty()) {\\n      const auto [d, l, f, s] = pq.top();\\n      if (l == n) {\\n        return d;\\n      }\\n      pq.pop();\\n      if (visited[l][f][s]) {\\n        continue;\\n      }\\n      visited[l][f][s] = true;\\n      \\n      const int nl = l + 1;\\n      const int nfs = word[l] - big_a + 1;\\n      // 1. try to use the first finger\\n      if (!visited[nl][nfs][s]) {\\n        pq.emplace(d + (f == 0 ? 0 : distance(f - 1, nfs - 1)), nl, nfs, s);\\n      }\\n        \\n      // 2. try to use the second finger\\n      if (!visited[nl][f][nfs]) {\\n        pq.emplace(d + (s == 0 ? 0 : distance(s - 1, nfs - 1)), nl, f, nfs);\\n      }\\n    }\\n    throw \"impossible path\";\\n  }\\n  \\n private:\\n  int distance(const int l1, const int l2) {\\n    constexpr int cols = 6;\\n    const int r1 = l1 / cols;\\n    const int c1 = l1 % cols;\\n    const int r2 = l2 / cols;\\n    const int c2 = l2 % cols;\\n    return abs(r1 - r2) + abs(c1 - c2);\\n  }\\n};\\n```\n```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(1)\\n * where `n` is the length of the string `word`\\n */\\nclass Solution {\\n public:\\n  int minimumDistance(const string &word) {\\n    constexpr int range = 2;\\n    constexpr int letters = 26;\\n    constexpr char big_a = \\'A\\';\\n    const int n = static_cast<int>(word.size());\\n    uint32_t dp[range][letters + 1][letters + 1];\\n    memset(dp, -1, sizeof(dp));\\n    int previous = 0;\\n    int current = 1;\\n    dp[previous][0][0] = 0;\\n    for (const char c : word) {\\n      const int nfs = c - big_a + 1;\\n      for (int previous_finger1 = 0; previous_finger1 < letters + 1; ++previous_finger1) {\\n        for (int previous_finger2 = 0; previous_finger2 < letters + 1; ++previous_finger2) {\\n          if (dp[previous][previous_finger1][previous_finger2] == -1) {\\n            continue;\\n          }\\n          \\n          // 1. try to use the first finger\\n          dp[current][nfs][previous_finger2] = min(dp[current][nfs][previous_finger2],\\n                                                   dp[previous][previous_finger1][previous_finger2] + (previous_finger1 == 0 ? 0 : distance(previous_finger1 - 1, nfs - 1)));\\n          \\n          // 2. try to use the second finger\\n          dp[current][previous_finger1][nfs] = min(dp[current][previous_finger1][nfs],\\n                                                   dp[previous][previous_finger1][previous_finger2] + (previous_finger2 == 0 ? 0 : distance(previous_finger2 - 1, nfs - 1)));\\n        }\\n      }\\n      \\n      previous ^= 1;\\n      current ^= 1;\\n      memset(dp[current], -1, sizeof(dp[current]));\\n    }\\n    \\n    uint32_t ret = -1;\\n    for (int finger1 = 0; finger1 < letters + 1; ++finger1) {\\n      for (int finger2 = 0; finger2 < letters + 1; ++finger2) {\\n        ret = min(ret, dp[previous][finger1][finger2]);\\n      }\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  int distance(const int l1, const int l2) {\\n    constexpr int cols = 6;\\n    const int r1 = l1 / cols;\\n    const int c1 = l1 % cols;\\n    const int r2 = l2 / cols;\\n    const int c2 = l2 % cols;\\n    return abs(r1 - r2) + abs(c1 - c2);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799352,
                "title": "c-memoization-dp",
                "content": "# Complexity\\n- Time complexity: $$O(6 * 7 * 6 * 7 * n) = O(n)$$\\n\\n- Space complexity: $$O(6 * 7 * 6 * 7 * n) = O(n)$$\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dp[6][7][6][7][301];\\n\\n    int minimumDistance(string word) {\\n        int n = word.size();\\n        if (n < 2) {\\n            return 0;\\n        }\\n\\n        memset(dp, -1, sizeof(dp));\\n        return dfs(-1, -1, -1, -1, 0, word);\\n    }\\n\\n    int dfs (int fx1, int fy1, int fx2, int fy2, int i, string& w) {\\n        if (i == w.size()) {\\n            return 0;\\n        }\\n\\n        if (dp[fx1+1][fy1+1][fx2+1][fy2+1][i] != -1) {\\n            return dp[fx1+1][fy1+1][fx2+1][fy2+1][i];\\n        }\\n\\n        int x = (w[i] - \\'A\\') / 6;\\n        int y = (w[i] - \\'A\\') % 6;\\n\\n        // move finger 1\\n        int cost1 = (fx1 == -1) ? 0 : abs(fx1 - x) + abs(fy1 - y);\\n        int case1 = dfs(x, y, fx2, fy2, i+1, w) + cost1;\\n\\n        // move finger 2\\n        int cost2 = (fx2 == -1) ? 0 : abs(fx2 - x) + abs(fy2 - y);\\n        int case2 = dfs(fx1, fy1, x, y, i+1, w) + cost2;\\n\\n        return dp[fx1+1][fy1+1][fx2+1][fy2+1][i] = min(case1, case2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dp[6][7][6][7][301];\\n\\n    int minimumDistance(string word) {\\n        int n = word.size();\\n        if (n < 2) {\\n            return 0;\\n        }\\n\\n        memset(dp, -1, sizeof(dp));\\n        return dfs(-1, -1, -1, -1, 0, word);\\n    }\\n\\n    int dfs (int fx1, int fy1, int fx2, int fy2, int i, string& w) {\\n        if (i == w.size()) {\\n            return 0;\\n        }\\n\\n        if (dp[fx1+1][fy1+1][fx2+1][fy2+1][i] != -1) {\\n            return dp[fx1+1][fy1+1][fx2+1][fy2+1][i];\\n        }\\n\\n        int x = (w[i] - \\'A\\') / 6;\\n        int y = (w[i] - \\'A\\') % 6;\\n\\n        // move finger 1\\n        int cost1 = (fx1 == -1) ? 0 : abs(fx1 - x) + abs(fy1 - y);\\n        int case1 = dfs(x, y, fx2, fy2, i+1, w) + cost1;\\n\\n        // move finger 2\\n        int cost2 = (fx2 == -1) ? 0 : abs(fx2 - x) + abs(fy2 - y);\\n        int case2 = dfs(fx1, fy1, x, y, i+1, w) + cost2;\\n\\n        return dp[fx1+1][fy1+1][fx2+1][fy2+1][i] = min(case1, case2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744208,
                "title": "c-solution-dp-memorization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int solve(string&word,int ind,int f1,int f2,vector<vector<vector<int>>>& dp){\\n        if(ind==word.length())return 0;\\n        if(dp[ind][f1+1][f2+1]!=-1){\\n            return dp[ind][f1+1][f2+1];\\n        }\\n        //first finger\\n        int ans = 1e9;\\n        int temp = word[ind] - \\'A\\';\\n        int col = temp%6;\\n        int row = temp/6;\\n        if(f1==-1){\\n            ans = min(ans,solve(word,ind+1,word[ind]-\\'A\\',f2,dp));\\n        }\\n        else{\\n            int prevRow = f1/6;\\n            int prevCol = f1%6;\\n            int dist = abs(row-prevRow) + abs(col-prevCol);\\n            ans = min(ans,dist+solve(word,ind+1,word[ind]-\\'A\\',f2,dp));\\n        }\\n\\n        //second finger\\n        if(f2==-1){\\n            ans = min(ans,solve(word,ind+1,f1,word[ind]-\\'A\\',dp));\\n        }\\n        else{\\n            int prevRow = f2/6;\\n            int prevCol = f2%6;\\n            int dist = abs(row-prevRow) + abs(col-prevCol);\\n            ans = min(ans,dist+solve(word,ind+1,f1,word[ind]-\\'A\\',dp));\\n        }\\n        return dp[ind][f1+1][f2+1] = ans;\\n    }\\npublic:\\n    int minimumDistance(string word) {\\n        vector<vector<vector<int>>> dp(word.size(),vector<vector<int>>(27,vector<int>(27,-1)));\\n        return solve(word,0,-1,-1,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int solve(string&word,int ind,int f1,int f2,vector<vector<vector<int>>>& dp){\\n        if(ind==word.length())return 0;\\n        if(dp[ind][f1+1][f2+1]!=-1){\\n            return dp[ind][f1+1][f2+1];\\n        }\\n        //first finger\\n        int ans = 1e9;\\n        int temp = word[ind] - \\'A\\';\\n        int col = temp%6;\\n        int row = temp/6;\\n        if(f1==-1){\\n            ans = min(ans,solve(word,ind+1,word[ind]-\\'A\\',f2,dp));\\n        }\\n        else{\\n            int prevRow = f1/6;\\n            int prevCol = f1%6;\\n            int dist = abs(row-prevRow) + abs(col-prevCol);\\n            ans = min(ans,dist+solve(word,ind+1,word[ind]-\\'A\\',f2,dp));\\n        }\\n\\n        //second finger\\n        if(f2==-1){\\n            ans = min(ans,solve(word,ind+1,f1,word[ind]-\\'A\\',dp));\\n        }\\n        else{\\n            int prevRow = f2/6;\\n            int prevCol = f2%6;\\n            int dist = abs(row-prevRow) + abs(col-prevCol);\\n            ans = min(ans,dist+solve(word,ind+1,f1,word[ind]-\\'A\\',dp));\\n        }\\n        return dp[ind][f1+1][f2+1] = ans;\\n    }\\npublic:\\n    int minimumDistance(string word) {\\n        vector<vector<vector<int>>> dp(word.size(),vector<vector<int>>(27,vector<int>(27,-1)));\\n        return solve(word,0,-1,-1,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704523,
                "title": "c-dp-20-lines-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs we see length of string is smaller . and there are two fingers \\nso try all possible ways by taking finger1 , finger 2 and length of string .\\n\\n(finger1 , finger2 = 0 means it is pointing nothing else pointing charcter )\\nAt every point we try to move finger1 then calculate distance \\nmove finger2 then calculate distance\\nand take minimum of both \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N * 27 * 27 )\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N * 27 * 27 )\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<char , pair<int,int> > mp ;\\n    int n ; \\n    string word ;\\n    int dp[30][30][305] ; \\n\\n    int getDistance(int a1 , int a2 ){\\n        if(a1 == 0 || a2 == 0 ) return 0 ; \\n\\n        a1 = a1 + \\'A\\' -1 ;\\n        a2 = a2 + \\'A\\' -1 ;\\n\\n        int x1 = mp[a1].first , y1 = mp[a1].second ;\\n        int x2 = mp[a2].first , y2 = mp[a2].second ;\\n\\n        return abs(x1 - x2) + abs(y1 - y2) ;\\n    }\\n\\n    int f(int f1 , int f2 , int idx ){\\n        if(idx == n ) return 0 ;\\n        if( dp[f1][f2][idx] != -1 ) return dp[f1][f2][idx] ;\\n\\n        int ans = f( word[idx] - \\'A\\' + 1 , f2 , idx + 1 ) + getDistance( f1 , word[idx] - \\'A\\' + 1 ) ;\\n        ans = min(ans , f( f1 , word[idx] - \\'A\\' + 1 , idx + 1 ) + getDistance( f2 , word[idx] - \\'A\\' + 1 ) ) ;\\n\\n        return dp[f1][f2][idx] = ans ; \\n    } \\n\\n    int minimumDistance(string word) {\\n        mp.clear() ;\\n        for(char ch = \\'A\\' ; ch <= \\'Z\\' ; ++ch ){\\n            mp[ch] = make_pair( (ch - \\'A\\') / 6 , (ch - \\'A\\') % 6 ) ;\\n        }\\n        \\n        this->word = word ;\\n        n = word.size() ; \\n        memset(dp , -1 , sizeof(dp) ) ;\\n\\n        return f( 0 , 0 , 0 ) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<char , pair<int,int> > mp ;\\n    int n ; \\n    string word ;\\n    int dp[30][30][305] ; \\n\\n    int getDistance(int a1 , int a2 ){\\n        if(a1 == 0 || a2 == 0 ) return 0 ; \\n\\n        a1 = a1 + \\'A\\' -1 ;\\n        a2 = a2 + \\'A\\' -1 ;\\n\\n        int x1 = mp[a1].first , y1 = mp[a1].second ;\\n        int x2 = mp[a2].first , y2 = mp[a2].second ;\\n\\n        return abs(x1 - x2) + abs(y1 - y2) ;\\n    }\\n\\n    int f(int f1 , int f2 , int idx ){\\n        if(idx == n ) return 0 ;\\n        if( dp[f1][f2][idx] != -1 ) return dp[f1][f2][idx] ;\\n\\n        int ans = f( word[idx] - \\'A\\' + 1 , f2 , idx + 1 ) + getDistance( f1 , word[idx] - \\'A\\' + 1 ) ;\\n        ans = min(ans , f( f1 , word[idx] - \\'A\\' + 1 , idx + 1 ) + getDistance( f2 , word[idx] - \\'A\\' + 1 ) ) ;\\n\\n        return dp[f1][f2][idx] = ans ; \\n    } \\n\\n    int minimumDistance(string word) {\\n        mp.clear() ;\\n        for(char ch = \\'A\\' ; ch <= \\'Z\\' ; ++ch ){\\n            mp[ch] = make_pair( (ch - \\'A\\') / 6 , (ch - \\'A\\') % 6 ) ;\\n        }\\n        \\n        this->word = word ;\\n        n = word.size() ; \\n        memset(dp , -1 , sizeof(dp) ) ;\\n\\n        return f( 0 , 0 , 0 ) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658545,
                "title": "c-memoization-dp-easy-to-understand",
                "content": "# Approach : Dynamic Programming\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N*6*7*6*7)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N*6*7*6*7)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    int mat[5][6]={{0,1,2,3,4,5},\\n                    {6,7,8,9,10,11},\\n                    {12,13,14,15,16,17},\\n                    {18,19,20,21,22,23},\\n                    {24,25,26,27,28,29}};\\n    ll dp[305][6][7][6][7];\\n    ll func(int ind,int f1x,int f1y,int f2x,int f2y,string &s){\\n        if(ind>=s.length()){\\n            return 0;\\n        } \\n        if(dp[ind][f1x+1][f1y+1][f2x+1][f2y+1]!=-1) return dp[ind][f1x+1][f1y+1][f2x+1][f2y+1];\\n        if(ind==0){\\n            int cost=func(ind+1,(s[ind]-\\'A\\')/6,(s[ind]-\\'A\\')%6,f2x,f2y,s);\\n            return dp[ind][f1x+1][f1y+1][f2x+1][f2y+1]=  cost;\\n        }\\n        int x=(s[ind]-\\'A\\')/6;\\n        int y=(s[ind]-\\'A\\')%6;\\n        if(f2x==-1 && f2y==-1){\\n            ll t1=(abs(f1x-x)+abs(f1y-y))+func(ind+1,x,y,f2x,f2y,s);\\n            ll t2=func(ind+1,f1x,f1y,x,y,s);\\n            return dp[ind][f1x+1][f1y+1][f2x+1][f2y+1]= min(t1,t2);\\n        }\\n        else{\\n            ll t1=(abs(f1x-x)+abs(f1y-y))+func(ind+1,x,y,f2x,f2y,s);\\n            ll t2=(abs(f2x-x)+abs(f2y-y))+func(ind+1,f1x,f1y,x,y,s);\\n            return dp[ind][f1x+1][f1y+1][f2x+1][f2y+1]= min(t1,t2);\\n        }\\n    }\\n    int minimumDistance(string s) {\\n        memset(dp,-1,sizeof dp);\\n        return func(0,-1,-1,-1,-1,s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    int mat[5][6]={{0,1,2,3,4,5},\\n                    {6,7,8,9,10,11},\\n                    {12,13,14,15,16,17},\\n                    {18,19,20,21,22,23},\\n                    {24,25,26,27,28,29}};\\n    ll dp[305][6][7][6][7];\\n    ll func(int ind,int f1x,int f1y,int f2x,int f2y,string &s){\\n        if(ind>=s.length()){\\n            return 0;\\n        } \\n        if(dp[ind][f1x+1][f1y+1][f2x+1][f2y+1]!=-1) return dp[ind][f1x+1][f1y+1][f2x+1][f2y+1];\\n        if(ind==0){\\n            int cost=func(ind+1,(s[ind]-\\'A\\')/6,(s[ind]-\\'A\\')%6,f2x,f2y,s);\\n            return dp[ind][f1x+1][f1y+1][f2x+1][f2y+1]=  cost;\\n        }\\n        int x=(s[ind]-\\'A\\')/6;\\n        int y=(s[ind]-\\'A\\')%6;\\n        if(f2x==-1 && f2y==-1){\\n            ll t1=(abs(f1x-x)+abs(f1y-y))+func(ind+1,x,y,f2x,f2y,s);\\n            ll t2=func(ind+1,f1x,f1y,x,y,s);\\n            return dp[ind][f1x+1][f1y+1][f2x+1][f2y+1]= min(t1,t2);\\n        }\\n        else{\\n            ll t1=(abs(f1x-x)+abs(f1y-y))+func(ind+1,x,y,f2x,f2y,s);\\n            ll t2=(abs(f2x-x)+abs(f2y-y))+func(ind+1,f1x,f1y,x,y,s);\\n            return dp[ind][f1x+1][f1y+1][f2x+1][f2y+1]= min(t1,t2);\\n        }\\n    }\\n    int minimumDistance(string s) {\\n        memset(dp,-1,sizeof dp);\\n        return func(0,-1,-1,-1,-1,s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634276,
                "title": "dp-c-easy-to-understand-clean-code",
                "content": "# Intuition\\nRecursion DP\\n\\n# Approach\\nWe will be finding and stroing the ans till the kth element of the string and then compute the result for i+1 th element. Which is minimum of addition of distance from 1st finger or 2nd finger. \\n\\n# Complexity\\n- Time complexity:\\nO(N^3)\\n\\n- Space complexity:\\nO(N*27*27)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dis(char c,char d){\\n        if(c == \\'@\\' || d==\\'@\\') return 0;\\n        c-=\\'A\\'; d-=\\'A\\';\\n        return abs(c/6-d/6) + abs(c%6-d%6);\\n    }\\n\\n    int recur(char c1, char c2, int k, string s, vector<vector<vector<int>>>& dp){\\n        if(k==s.size()){\\n            return 0;\\n        }\\n\\n        if(dp[k][c1-\\'@\\'][c2-\\'@\\']!=-1) return dp[k][c1-\\'@\\'][c2-\\'@\\'];\\n\\n        int f1 = dis(c1,s[k]) + recur(s[k], c2, k+1, s ,dp);\\n        int f2 = dis(c2,s[k]) + recur(c1, s[k], k+1, s ,dp);\\n\\n        return dp[k][c1-\\'@\\'][c2-\\'@\\'] = min(f1,f2);\\n    }\\n\\n    int minimumDistance(string s) {\\n        vector<vector<vector<int>>> dp(300+1,vector<vector<int>> (27,vector<int> (28,-1)));\\n        int ans = recur(\\'@\\',\\'@\\',0,s,dp);\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dis(char c,char d){\\n        if(c == \\'@\\' || d==\\'@\\') return 0;\\n        c-=\\'A\\'; d-=\\'A\\';\\n        return abs(c/6-d/6) + abs(c%6-d%6);\\n    }\\n\\n    int recur(char c1, char c2, int k, string s, vector<vector<vector<int>>>& dp){\\n        if(k==s.size()){\\n            return 0;\\n        }\\n\\n        if(dp[k][c1-\\'@\\'][c2-\\'@\\']!=-1) return dp[k][c1-\\'@\\'][c2-\\'@\\'];\\n\\n        int f1 = dis(c1,s[k]) + recur(s[k], c2, k+1, s ,dp);\\n        int f2 = dis(c2,s[k]) + recur(c1, s[k], k+1, s ,dp);\\n\\n        return dp[k][c1-\\'@\\'][c2-\\'@\\'] = min(f1,f2);\\n    }\\n\\n    int minimumDistance(string s) {\\n        vector<vector<vector<int>>> dp(300+1,vector<vector<int>> (27,vector<int> (28,-1)));\\n        int ans = recur(\\'@\\',\\'@\\',0,s,dp);\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608402,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int minimumDistance(string word) {\\n        int n = word.length();\\n        int* dp = new int[n];\\n        dp[0] = 0;\\n        for (int w=1; w<n; w++) {\\n            int d = dist(word, w, w-1);\\n            dp[w] = dp[w-1] + d;\\n\\n            for (int j=0; j<w-1; j++) {\\n                dp[w-1] = min(dp[w-1], dp[j] + dist(word, w, j));\\n            }\\n            for (int i=w-2; i>=0; i--) {\\n                dp[i] += d;\\n            }\\n        }\\n        int m = INT_MAX;\\n        for (int i=0; i<n; i++) {\\n            m = min(m, dp[i]);\\n        }\\n        return m;\\n    }\\n    int minimumDistance1(string word) {\\n        int n = word.length();\\n        map<pair<int, int>,int> dp;\\n        dp.insert({{-1, -1}, 0});\\n        for (int w=0; w<n; w++) {\\n            map<pair<int, int>,int> dp2;\\n            for (const auto& [lr, sum] : dp) {\\n                const auto& [l, r] = lr;\\n                insert_or_min(dp2, {w, r}, dist(word, w, l) + sum);\\n                insert_or_min(dp2, {w, l}, dist(word, w, r) + sum);\\n            }\\n            swap(dp, dp2);\\n        }\\n        int m = INT_MAX;\\n        for (const auto& [lr, sum] : dp) {\\n            m = min(m, sum);\\n        }\\n        return m;\\n    }\\n    void insert_or_min(map<pair<int, int>,int>& dp, const pair<int, int>& k, int v) {\\n        if (auto it=dp.find(k); it == dp.end()) {\\n            dp[k] = v;\\n        } else {\\n            dp[k] = min(dp[k], v);\\n        }\\n    }\\n    int dist(const string& word, int x, int y) {\\n        if (x == -1 || y == -1) return 0;\\n        char a = word[x];\\n        char b = word[y];\\n        return abs(horizontal(a) - horizontal(b))\\n            + abs(vertical(a) - vertical(b));\\n    }\\n    int horizontal(char a) {\\n        return (a - \\'A\\') % 6;\\n    }\\n    int vertical(char a) {\\n        return (a - \\'A\\') / 6;\\n    }\\n};\\n```\\n\\n```Python3 []\\ngrid = [\\n    [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"],\\n    [\"G\", \"H\", \"I\", \"J\", \"K\", \"L\"],\\n    [\"M\", \"N\", \"O\", \"P\", \"Q\", \"R\"],\\n    [\"S\", \"T\", \"U\", \"V\", \"W\", \"X\"],\\n    [\"Y\", \"Z\"],\\n]\\ncoords = {}\\nfor i in range(len(grid)):\\n    for j in range(len(grid[i])):\\n        coords[grid[i][j]] = (i, j)\\ndists = {}\\nfor c1, (i1, j1) in coords.items():\\n    for c2, (i2, j2) in coords.items():\\n        dists[(c1, c2)] = abs(i1 - i2) + abs(j1 - j2)\\n\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        n = len(word)\\n        x = [{} for _ in range(n)]\\n        for i in reversed(range(n)):\\n            if i == n - 1:\\n                x[i][None] = 0\\n            else:\\n            \\n                d1 =dists[(word[i], word[i + 1])]\\n                for c, dist in x[i + 1].items():\\n                    x[i][c] = d1 + x[i + 1][c]\\n               \\n                x[i][word[i+1]] = min(\\n                    x[i].get(word[i+1], float(\"inf\")),\\n                    min(\\n                        dist + (dists[(word[i], c)] if c is not None else 0)\\n                        for c, dist in x[i + 1].items()\\n                    )\\n                )\\n        return min(x[0].values())\\n```\\n\\n```Java []\\nclass Solution {\\n    public int minimumDistance(String word) {\\n        int[] keys = new int[word.length()];\\n        for (int i = 0; i < word.length(); i++) keys[i] = word.charAt(i) - \\'A\\';\\n\\n        int[][] cost = new int[27][26];\\n        for (int i = 0; i < 26; i++) {\\n            for (int j = i; j < 26; j++) {\\n                cost[i][j] = Math.abs(i/6 - j/6) + Math.abs(i%6 - j%6);\\n                cost[j][i] = cost[i][j];\\n            }\\n        }\\n        int[] dp = new int[27];\\n        \\n        for (int i = keys.length - 1; i > 0; i--) {\\n            int dp_for_key_at_i_minus_1 = dp[keys[i - 1]];\\n            int cost_i_minus_1_to_i = cost[keys[i - 1]][keys[i]];\\n            for (int j = 0; j < 27; j++) {\\n                dp[j] = Math.min(\\n                    dp_for_key_at_i_minus_1 + cost[j][keys[i]], \\n                    dp[j] + cost_i_minus_1_to_i);\\n            }\\n        }\\n        return dp[26];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int minimumDistance(string word) {\\n        int n = word.length();\\n        int* dp = new int[n];\\n        dp[0] = 0;\\n        for (int w=1; w<n; w++) {\\n            int d = dist(word, w, w-1);\\n            dp[w] = dp[w-1] + d;\\n\\n            for (int j=0; j<w-1; j++) {\\n                dp[w-1] = min(dp[w-1], dp[j] + dist(word, w, j));\\n            }\\n            for (int i=w-2; i>=0; i--) {\\n                dp[i] += d;\\n            }\\n        }\\n        int m = INT_MAX;\\n        for (int i=0; i<n; i++) {\\n            m = min(m, dp[i]);\\n        }\\n        return m;\\n    }\\n    int minimumDistance1(string word) {\\n        int n = word.length();\\n        map<pair<int, int>,int> dp;\\n        dp.insert({{-1, -1}, 0});\\n        for (int w=0; w<n; w++) {\\n            map<pair<int, int>,int> dp2;\\n            for (const auto& [lr, sum] : dp) {\\n                const auto& [l, r] = lr;\\n                insert_or_min(dp2, {w, r}, dist(word, w, l) + sum);\\n                insert_or_min(dp2, {w, l}, dist(word, w, r) + sum);\\n            }\\n            swap(dp, dp2);\\n        }\\n        int m = INT_MAX;\\n        for (const auto& [lr, sum] : dp) {\\n            m = min(m, sum);\\n        }\\n        return m;\\n    }\\n    void insert_or_min(map<pair<int, int>,int>& dp, const pair<int, int>& k, int v) {\\n        if (auto it=dp.find(k); it == dp.end()) {\\n            dp[k] = v;\\n        } else {\\n            dp[k] = min(dp[k], v);\\n        }\\n    }\\n    int dist(const string& word, int x, int y) {\\n        if (x == -1 || y == -1) return 0;\\n        char a = word[x];\\n        char b = word[y];\\n        return abs(horizontal(a) - horizontal(b))\\n            + abs(vertical(a) - vertical(b));\\n    }\\n    int horizontal(char a) {\\n        return (a - \\'A\\') % 6;\\n    }\\n    int vertical(char a) {\\n        return (a - \\'A\\') / 6;\\n    }\\n};\\n```\n```Python3 []\\ngrid = [\\n    [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"],\\n    [\"G\", \"H\", \"I\", \"J\", \"K\", \"L\"],\\n    [\"M\", \"N\", \"O\", \"P\", \"Q\", \"R\"],\\n    [\"S\", \"T\", \"U\", \"V\", \"W\", \"X\"],\\n    [\"Y\", \"Z\"],\\n]\\ncoords = {}\\nfor i in range(len(grid)):\\n    for j in range(len(grid[i])):\\n        coords[grid[i][j]] = (i, j)\\ndists = {}\\nfor c1, (i1, j1) in coords.items():\\n    for c2, (i2, j2) in coords.items():\\n        dists[(c1, c2)] = abs(i1 - i2) + abs(j1 - j2)\\n\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        n = len(word)\\n        x = [{} for _ in range(n)]\\n        for i in reversed(range(n)):\\n            if i == n - 1:\\n                x[i][None] = 0\\n            else:\\n            \\n                d1 =dists[(word[i], word[i + 1])]\\n                for c, dist in x[i + 1].items():\\n                    x[i][c] = d1 + x[i + 1][c]\\n               \\n                x[i][word[i+1]] = min(\\n                    x[i].get(word[i+1], float(\"inf\")),\\n                    min(\\n                        dist + (dists[(word[i], c)] if c is not None else 0)\\n                        for c, dist in x[i + 1].items()\\n                    )\\n                )\\n        return min(x[0].values())\\n```\n```Java []\\nclass Solution {\\n    public int minimumDistance(String word) {\\n        int[] keys = new int[word.length()];\\n        for (int i = 0; i < word.length(); i++) keys[i] = word.charAt(i) - \\'A\\';\\n\\n        int[][] cost = new int[27][26];\\n        for (int i = 0; i < 26; i++) {\\n            for (int j = i; j < 26; j++) {\\n                cost[i][j] = Math.abs(i/6 - j/6) + Math.abs(i%6 - j%6);\\n                cost[j][i] = cost[i][j];\\n            }\\n        }\\n        int[] dp = new int[27];\\n        \\n        for (int i = keys.length - 1; i > 0; i--) {\\n            int dp_for_key_at_i_minus_1 = dp[keys[i - 1]];\\n            int cost_i_minus_1_to_i = cost[keys[i - 1]][keys[i]];\\n            for (int j = 0; j < 27; j++) {\\n                dp[j] = Math.min(\\n                    dp_for_key_at_i_minus_1 + cost[j][keys[i]], \\n                    dp[j] + cost_i_minus_1_to_i);\\n            }\\n        }\\n        return dp[26];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3560217,
                "title": "cache-simple-fast-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        def dist(pre,cur):\\n            if pre==None:\\n                return 0\\n            x1,y1 = divmod(ord(pre)-ord(\\'A\\'),6)\\n            x2,y2 = divmod(ord(cur)-ord(\\'A\\'),6)\\n            return abs(x1-x2) + abs(y1-y2)\\n        \\n        @lru_cache(None)\\n        def fingers(i,l,r):\\n            if i == len(word):\\n                return 0\\n            n1 = dist(l,word[i]) + fingers(i+1,word[i],r)\\n            n2 = dist(r,word[i]) + fingers(i+1,l,word[i])\\n            return min(n1,n2)\\n        \\n        return fingers(0,None,None)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        def dist(pre,cur):\\n            if pre==None:\\n                return 0\\n            x1,y1 = divmod(ord(pre)-ord(\\'A\\'),6)\\n            x2,y2 = divmod(ord(cur)-ord(\\'A\\'),6)\\n            return abs(x1-x2) + abs(y1-y2)\\n        \\n        @lru_cache(None)\\n        def fingers(i,l,r):\\n            if i == len(word):\\n                return 0\\n            n1 = dist(l,word[i]) + fingers(i+1,word[i],r)\\n            n2 = dist(r,word[i]) + fingers(i+1,l,word[i])\\n            return min(n1,n2)\\n        \\n        return fingers(0,None,None)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3482977,
                "title": "c-easy-to-understand-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[301][27][27];\\n\\n    int cost(int old, int nw){\\n        int ox = old/6;\\n        int oy = old%6;\\n\\n        int nx = nw/6;\\n        int ny = nw%6;\\n\\n        return abs(ox - nx) + abs(oy - ny);\\n    }\\n\\n    int fn(int idx, int f1, int f2, string& word){\\n        if(idx >= word.size()) return 0;\\n\\n        if(dp[idx][f1][f2] != -1) return dp[idx][f1][f2];\\n\\n        int a, b, cost1, cost2;\\n\\n        //Using Finger 1 to type\\n        if(f1 == 0){\\n            cost1 = 0;\\n        }else{\\n            cost1 = cost(f1 - 1,  word[idx] - \\'A\\');\\n        }\\n\\n        a = cost1 + fn(idx+1, word[idx] - \\'A\\' + 1, f2, word);\\n\\n        //Using Finger 2 to type\\n        if(f2 == 0){\\n            cost2 = 0;\\n        }else{\\n            cost2 = cost(f2 - 1,  word[idx] - \\'A\\');;\\n        }\\n\\n        b = cost2 + fn(idx+1, f1, word[idx] - \\'A\\' + 1, word);\\n\\n        return dp[idx][f1][f2] = min(a, b);\\n    }\\n    int minimumDistance(string word) {\\n        memset(dp, -1, sizeof dp);\\n\\n        return fn(0, 0, 0, word);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[301][27][27];\\n\\n    int cost(int old, int nw){\\n        int ox = old/6;\\n        int oy = old%6;\\n\\n        int nx = nw/6;\\n        int ny = nw%6;\\n\\n        return abs(ox - nx) + abs(oy - ny);\\n    }\\n\\n    int fn(int idx, int f1, int f2, string& word){\\n        if(idx >= word.size()) return 0;\\n\\n        if(dp[idx][f1][f2] != -1) return dp[idx][f1][f2];\\n\\n        int a, b, cost1, cost2;\\n\\n        //Using Finger 1 to type\\n        if(f1 == 0){\\n            cost1 = 0;\\n        }else{\\n            cost1 = cost(f1 - 1,  word[idx] - \\'A\\');\\n        }\\n\\n        a = cost1 + fn(idx+1, word[idx] - \\'A\\' + 1, f2, word);\\n\\n        //Using Finger 2 to type\\n        if(f2 == 0){\\n            cost2 = 0;\\n        }else{\\n            cost2 = cost(f2 - 1,  word[idx] - \\'A\\');;\\n        }\\n\\n        b = cost2 + fn(idx+1, f1, word[idx] - \\'A\\' + 1, word);\\n\\n        return dp[idx][f1][f2] = min(a, b);\\n    }\\n    int minimumDistance(string word) {\\n        memset(dp, -1, sizeof dp);\\n\\n        return fn(0, 0, 0, word);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425224,
                "title": "python-top-down",
                "content": "```\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        ##make letter to coordinates map\\n        maps={chr(i):((i-ord(\\'A\\'))//6,(i-ord(\\'A\\')) % 6) for i in range(ord(\\'A\\'),ord(\\'Z\\')+1)}\\n        @lru_cache(None)\\n        def dfs(pre1,pre2,cur): # either left or right hand, based on previous left and right hand letter, pre1 or pre2\\n                                # pre1 is the previous letter from left hand and pre2 is the previous letter from right hand\\n                                # cur is the current to be typed letter index\\n            if cur==len(word):\\n                return 0\\n            ##if use left hand\\n            if pre1==\\'\\':\\n                l=0\\n            else:\\n                l=abs(maps[pre1][0]-maps[word[cur]][0])+abs(maps[pre1][1]-maps[word[cur]][1])\\n            #if use right hand\\n            if pre2==\\'\\':\\n                r=0\\n            else:\\n                r=abs(maps[pre2][0]-maps[word[cur]][0])+abs(maps[pre2][1]-maps[word[cur]][1])\\n            ##return the min cost based on the right or left hand, and update the prev letter from left and right hand accordingly\\n            return min(l+dfs(word[cur],pre2,cur+1),r+dfs(pre1,word[cur],cur+1))\\n        return dfs(\\'\\',\\'\\',0)\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        ##make letter to coordinates map\\n        maps={chr(i):((i-ord(\\'A\\'))//6,(i-ord(\\'A\\')) % 6) for i in range(ord(\\'A\\'),ord(\\'Z\\')+1)}\\n        @lru_cache(None)\\n        def dfs(pre1,pre2,cur): # either left or right hand, based on previous left and right hand letter, pre1 or pre2\\n                                # pre1 is the previous letter from left hand and pre2 is the previous letter from right hand\\n                                # cur is the current to be typed letter index\\n            if cur==len(word):\\n                return 0\\n            ##if use left hand\\n            if pre1==\\'\\':\\n                l=0\\n            else:\\n                l=abs(maps[pre1][0]-maps[word[cur]][0])+abs(maps[pre1][1]-maps[word[cur]][1])\\n            #if use right hand\\n            if pre2==\\'\\':\\n                r=0\\n            else:\\n                r=abs(maps[pre2][0]-maps[word[cur]][0])+abs(maps[pre2][1]-maps[word[cur]][1])\\n            ##return the min cost based on the right or left hand, and update the prev letter from left and right hand accordingly\\n            return min(l+dfs(word[cur],pre2,cur+1),r+dfs(pre1,word[cur],cur+1))\\n        return dfs(\\'\\',\\'\\',0)\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393820,
                "title": "java-easy-solution-dp-memorization",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumDistance(String word) {\\n        HashMap<String,Integer> cache= new HashMap<>();\\n        return type(word,\\'\\\\0\\', \\'\\\\0\\',0,cache);\\n    }\\n\\n\\n    int type(String word,char leftFinger,char rightFinger,int i,HashMap<String,Integer> cache){\\n        if(i>=word.length())return 0;\\n\\n        String key=leftFinger+\" \"+rightFinger+\" \"+i;\\n        if(cache.containsKey(key))return cache.get(key);\\n\\n        int left=distance(leftFinger,word.charAt(i))+type(word,word.charAt(i),rightFinger,i+1,cache);\\n\\n        int right=distance(rightFinger,word.charAt(i))+type(word,leftFinger,word.charAt(i),i+1,cache);\\n        cache.put(key,Math.min(left,right));\\n        return Math.min(left,right);\\n    }\\n\\n    int distance(char prev,char curr){\\n\\n        if(prev==\\'\\\\0\\')return 0;\\n        int x1=(prev-\\'A\\')/6;\\n        int x2=(curr-\\'A\\')/6;\\n        int y1=(prev-\\'A\\')%6;\\n        int y2=(curr-\\'A\\')%6;\\n\\n         return Math.abs(x2-x1)+Math.abs(y2-y1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDistance(String word) {\\n        HashMap<String,Integer> cache= new HashMap<>();\\n        return type(word,\\'\\\\0\\', \\'\\\\0\\',0,cache);\\n    }\\n\\n\\n    int type(String word,char leftFinger,char rightFinger,int i,HashMap<String,Integer> cache){\\n        if(i>=word.length())return 0;\\n\\n        String key=leftFinger+\" \"+rightFinger+\" \"+i;\\n        if(cache.containsKey(key))return cache.get(key);\\n\\n        int left=distance(leftFinger,word.charAt(i))+type(word,word.charAt(i),rightFinger,i+1,cache);\\n\\n        int right=distance(rightFinger,word.charAt(i))+type(word,leftFinger,word.charAt(i),i+1,cache);\\n        cache.put(key,Math.min(left,right));\\n        return Math.min(left,right);\\n    }\\n\\n    int distance(char prev,char curr){\\n\\n        if(prev==\\'\\\\0\\')return 0;\\n        int x1=(prev-\\'A\\')/6;\\n        int x2=(curr-\\'A\\')/6;\\n        int y1=(prev-\\'A\\')%6;\\n        int y2=(curr-\\'A\\')%6;\\n\\n         return Math.abs(x2-x1)+Math.abs(y2-y1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3252506,
                "title": "python-dp-with-reused-storage-time-o-27n-beats-100-space-o-4-27-n-beats-94",
                "content": "# Code\\n```\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        n = len(word)\\n        if n == 2: return 0\\n        dp01, dp02, dp11, dp12 = ([0] * 27 for _ in range(4))\\n        dm = divmod\\n        c = ord(word[-1]) - 0x41\\n        i = n - 1\\n        while i > 0:\\n            pc = ord(word[i-1]) - 0x41\\n            cx, cy = dm(c, 6)\\n            pcx, pcy = dm(pc, 6)\\n            dist = abs(cx - pcx) + abs(cy - pcy)\\n            for f in range(26):\\n                fx, fy = dm(f, 6)\\n                distf = abs(cx - fx) + abs(cy - fy)\\n                a1 = dist + dp01[f]\\n                a2 = distf + dp02[pc]\\n                dp11[f] = a1 if a1 < a2 else a2\\n                a1 = distf + dp01[pc]\\n                a2 = dist + dp02[f]\\n                dp12[f] = a1 if a1 < a2 else a2\\n            a1 = dp01[pc]\\n            a2 = dist + dp02[-1]\\n            dp12[-1] = a1 if a1 < a2 else a2\\n            a1 = dp02[pc]\\n            a2 = dist + dp01[-1]\\n            dp11[-1] = a1 if a1 < a2 else a2\\n            dp11, dp12, dp01, dp02 = dp01, dp02, dp11, dp12\\n            c = pc\\n            i -= 1\\n        a1 = dp01[-1]\\n        a2 = dp02[-1]\\n        return a1 if a1 < a2 else a2\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        n = len(word)\\n        if n == 2: return 0\\n        dp01, dp02, dp11, dp12 = ([0] * 27 for _ in range(4))\\n        dm = divmod\\n        c = ord(word[-1]) - 0x41\\n        i = n - 1\\n        while i > 0:\\n            pc = ord(word[i-1]) - 0x41\\n            cx, cy = dm(c, 6)\\n            pcx, pcy = dm(pc, 6)\\n            dist = abs(cx - pcx) + abs(cy - pcy)\\n            for f in range(26):\\n                fx, fy = dm(f, 6)\\n                distf = abs(cx - fx) + abs(cy - fy)\\n                a1 = dist + dp01[f]\\n                a2 = distf + dp02[pc]\\n                dp11[f] = a1 if a1 < a2 else a2\\n                a1 = distf + dp01[pc]\\n                a2 = dist + dp02[f]\\n                dp12[f] = a1 if a1 < a2 else a2\\n            a1 = dp01[pc]\\n            a2 = dist + dp02[-1]\\n            dp12[-1] = a1 if a1 < a2 else a2\\n            a1 = dp02[pc]\\n            a2 = dist + dp01[-1]\\n            dp11[-1] = a1 if a1 < a2 else a2\\n            dp11, dp12, dp01, dp02 = dp01, dp02, dp11, dp12\\n            c = pc\\n            i -= 1\\n        a1 = dp01[-1]\\n        a2 = dp02[-1]\\n        return a1 if a1 < a2 else a2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228552,
                "title": "python-simple-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumDistance(self, word):\\n        n = len(word)\\n\\n        d1 = {\"A\":(0,0),\"B\":(0,1),\"C\":(0,2),\"D\":(0,3),\"E\":(0,4),\"F\":(0,5),\"G\":(1,0),\"H\":(1,1),\"I\":(1,2),\"J\":(1,3),\"K\":(1,4),\"L\":(1,5),\"M\":(2,0),\"N\":(2,1),\"O\":(2,2),\"P\":(2,3),\"Q\":(2,4),\"R\":(2,5),\"S\":(3,0),\"T\":(3,1),\"U\":(3,2),\"V\":(3,3),\"W\":(3,4),\"X\":(3,5),\"Y\":(4,0),\"Z\":(4,1)}\\n\\n        @lru_cache(None)\\n        def dfs(i,j,k):\\n            if k >= n:\\n                return 0\\n\\n            if i == -1:\\n                val1 = dfs(k,j,k+1)\\n            else:\\n                val1 = abs(d1[word[i]][0]-d1[word[k]][0]) + abs(d1[word[i]][1] - d1[word[k]][1]) + dfs(k,j,k+1)\\n\\n            if j == -1:\\n                val2 = dfs(i,k,k+1)\\n            else:\\n                val2 = abs(d1[word[j]][0]-d1[word[k]][0]) + abs(d1[word[j]][1] - d1[word[k]][1]) + dfs(i,k,k+1)\\n\\n            return min(val1,val2)\\n\\n        return dfs(-1,-1,0)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDistance(self, word):\\n        n = len(word)\\n\\n        d1 = {\"A\":(0,0),\"B\":(0,1),\"C\":(0,2),\"D\":(0,3),\"E\":(0,4),\"F\":(0,5),\"G\":(1,0),\"H\":(1,1),\"I\":(1,2),\"J\":(1,3),\"K\":(1,4),\"L\":(1,5),\"M\":(2,0),\"N\":(2,1),\"O\":(2,2),\"P\":(2,3),\"Q\":(2,4),\"R\":(2,5),\"S\":(3,0),\"T\":(3,1),\"U\":(3,2),\"V\":(3,3),\"W\":(3,4),\"X\":(3,5),\"Y\":(4,0),\"Z\":(4,1)}\\n\\n        @lru_cache(None)\\n        def dfs(i,j,k):\\n            if k >= n:\\n                return 0\\n\\n            if i == -1:\\n                val1 = dfs(k,j,k+1)\\n            else:\\n                val1 = abs(d1[word[i]][0]-d1[word[k]][0]) + abs(d1[word[i]][1] - d1[word[k]][1]) + dfs(k,j,k+1)\\n\\n            if j == -1:\\n                val2 = dfs(i,k,k+1)\\n            else:\\n                val2 = abs(d1[word[j]][0]-d1[word[k]][0]) + abs(d1[word[j]][1] - d1[word[k]][1]) + dfs(i,k,k+1)\\n\\n            return min(val1,val2)\\n\\n        return dfs(-1,-1,0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3168215,
                "title": "3d-dp-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[27][27][301];\\n    int find(string &word,int left,int right,int ind,vector<pair<int,int>>&v)\\n    {\\n        if(ind==word.size()) return 0;\\n        if(dp[left+1][right+1][ind]!=-1) return dp[left+1][right+1][ind];\\n        int a=0,b=0;\\n        if(left==-1)\\n        a=find(word,word[ind]-\\'a\\',right,ind+1,v);\\n        else\\n        {\\n            int index=word[ind]-\\'a\\';\\n            int steps=abs(v[left].first-v[index].first)+abs(v[left].second-v[index].second);\\n            a=steps+find(word,word[ind]-\\'a\\',right,ind+1,v);\\n        }\\n        if(right==-1)\\n        b=find(word,left,word[ind]-\\'a\\',ind+1,v);\\n        else\\n        {\\n            int index=word[ind]-\\'a\\';\\n            int steps=abs(v[index].first-v[right].first)+abs(v[index].second-v[right].second);\\n            b=steps+find(word,left,word[ind]-\\'a\\',ind+1,v);\\n        }\\n        return dp[left+1][right+1][ind]=min(a,b);\\n    }\\n    int minimumDistance(string word) {\\n        memset(dp,-1,sizeof(dp));\\n        vector<pair<int,int>> v(26);\\n        char ch=\\'a\\';\\n        for(int i=0;i<6;++i)\\n        {\\n            for(int j=0;j<6;++j)\\n            {\\n                v[ch-\\'a\\']={i,j};\\n                if(ch==\\'z\\') break;\\n                ch++;\\n            }\\n            if(ch==\\'z\\') break;\\n        }\\n        transform(word.begin(), word.end(), word.begin(), ::tolower);\\n        return find(word,-1,-1,0,v);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[27][27][301];\\n    int find(string &word,int left,int right,int ind,vector<pair<int,int>>&v)\\n    {\\n        if(ind==word.size()) return 0;\\n        if(dp[left+1][right+1][ind]!=-1) return dp[left+1][right+1][ind];\\n        int a=0,b=0;\\n        if(left==-1)\\n        a=find(word,word[ind]-\\'a\\',right,ind+1,v);\\n        else\\n        {\\n            int index=word[ind]-\\'a\\';\\n            int steps=abs(v[left].first-v[index].first)+abs(v[left].second-v[index].second);\\n            a=steps+find(word,word[ind]-\\'a\\',right,ind+1,v);\\n        }\\n        if(right==-1)\\n        b=find(word,left,word[ind]-\\'a\\',ind+1,v);\\n        else\\n        {\\n            int index=word[ind]-\\'a\\';\\n            int steps=abs(v[index].first-v[right].first)+abs(v[index].second-v[right].second);\\n            b=steps+find(word,left,word[ind]-\\'a\\',ind+1,v);\\n        }\\n        return dp[left+1][right+1][ind]=min(a,b);\\n    }\\n    int minimumDistance(string word) {\\n        memset(dp,-1,sizeof(dp));\\n        vector<pair<int,int>> v(26);\\n        char ch=\\'a\\';\\n        for(int i=0;i<6;++i)\\n        {\\n            for(int j=0;j<6;++j)\\n            {\\n                v[ch-\\'a\\']={i,j};\\n                if(ch==\\'z\\') break;\\n                ch++;\\n            }\\n            if(ch==\\'z\\') break;\\n        }\\n        transform(word.begin(), word.end(), word.begin(), ::tolower);\\n        return find(word,-1,-1,0,v);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098233,
                "title": "o-n-time-o-1-space-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(26 * n)$$ = $$O(n)$$\\n\\n- Space complexity:\\n$$O(26)$$ = $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dist(char ch1, char ch2){\\n        int x1 = (ch1 - \\'A\\') % 6, y1 = (ch1 - \\'A\\') / 6;\\n        int x2 = (ch2 - \\'A\\') % 6, y2 = (ch2 - \\'A\\') / 6;\\n        return abs(x2 - x1) + abs(y2 - y1);\\n    }\\n\\n    int minimumDistance(string word) {\\n        // dp layer curr[j]: min distance to type word\\'s i letters, and place second finger on letter \\'A\\' + j\\n        vector<int> curr(26, 0); \\n\\n        for (int i = 1; i < word.size(); i++){\\n            vector<int> next = vector<int>(26);\\n            \\n            //first finger will type letter\\n            for (int j = 0; j < 26; j++)\\n                next[j] = curr[j] + dist(word[i], word[i - 1]);\\n                \\n            //or second finger will type (becomes first)\\n            for (int j = 0; j < 26; j++)\\n                next[word[i - 1] - \\'A\\'] = min(next[word[i - 1] - \\'A\\'], curr[j] + dist(\\'A\\' + j, word[i]));\\n\\n            std::swap(curr, next);\\n        }\\n\\n        return *min_element(curr.begin(), curr.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dist(char ch1, char ch2){\\n        int x1 = (ch1 - \\'A\\') % 6, y1 = (ch1 - \\'A\\') / 6;\\n        int x2 = (ch2 - \\'A\\') % 6, y2 = (ch2 - \\'A\\') / 6;\\n        return abs(x2 - x1) + abs(y2 - y1);\\n    }\\n\\n    int minimumDistance(string word) {\\n        // dp layer curr[j]: min distance to type word\\'s i letters, and place second finger on letter \\'A\\' + j\\n        vector<int> curr(26, 0); \\n\\n        for (int i = 1; i < word.size(); i++){\\n            vector<int> next = vector<int>(26);\\n            \\n            //first finger will type letter\\n            for (int j = 0; j < 26; j++)\\n                next[j] = curr[j] + dist(word[i], word[i - 1]);\\n                \\n            //or second finger will type (becomes first)\\n            for (int j = 0; j < 26; j++)\\n                next[word[i - 1] - \\'A\\'] = min(next[word[i - 1] - \\'A\\'], curr[j] + dist(\\'A\\' + j, word[i]));\\n\\n            std::swap(curr, next);\\n        }\\n\\n        return *min_element(curr.begin(), curr.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096968,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn minimum_distance(word: String) -> i32 {\\n        fn dist(a: i32, b: i32) -> i32 {\\n            (a / 6 - b / 6).abs() + (a % 6 - b % 6).abs()\\n        }\\n\\n        let mut dp = vec![0; 26];\\n        let mut res = 0;\\n        let mut save = 0;\\n        let n = word.len();\\n        for i in 0..n - 1 {\\n            let b = (word.as_bytes()[i] - b\\'A\\') as i32;\\n            let c = (word.as_bytes()[i + 1] - b\\'A\\') as i32;\\n            for a in 0..26 {\\n                dp[b as usize] = dp[b as usize].max(dp[a as usize] + dist(b, c) - dist(a, c));\\n            }\\n            save = save.max(dp[b as usize]);\\n            res += dist(b, c);\\n        }\\n        res - save\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimum_distance(word: String) -> i32 {\\n        fn dist(a: i32, b: i32) -> i32 {\\n            (a / 6 - b / 6).abs() + (a % 6 - b % 6).abs()\\n        }\\n\\n        let mut dp = vec![0; 26];\\n        let mut res = 0;\\n        let mut save = 0;\\n        let n = word.len();\\n        for i in 0..n - 1 {\\n            let b = (word.as_bytes()[i] - b\\'A\\') as i32;\\n            let c = (word.as_bytes()[i + 1] - b\\'A\\') as i32;\\n            for a in 0..26 {\\n                dp[b as usize] = dp[b as usize].max(dp[a as usize] + dist(b, c) - dist(a, c));\\n            }\\n            save = save.max(dp[b as usize]);\\n            res += dist(b, c);\\n        }\\n        res - save\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3076393,
                "title": "simple-c-recursive-solution-using-dp",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(string &s,map<char,pair<int,int>>&m,int r1,int r2,int c1,int c2,int ind,vector<vector<vector<vector<vector<int>>>>>&dp){\\n        if(ind==s.size()) return 0;\\n        int row=m[s[ind]].first;\\n        int col=m[s[ind]].second;\\n        int i=1e9,j=1e9;\\n        if(dp[r1+1][r2+1][c1+1][c2+1][ind]!=-1) return dp[r1+1][r2+1][c1+1][c2+1][ind];\\n        if(r1==-1 && c1==-1){\\n            i=f(s,m,row,r2,col,c2,ind+1,dp);\\n        }\\n        else{\\n            i=abs(row-r1)+abs(col-c1);\\n            i+=f(s,m,row,r2,col,c2,ind+1,dp);\\n        }\\n        if(r2==-1 && c2==-1){\\n            j=f(s,m,r1,row,c1,col,ind+1,dp);\\n        }\\n        else{\\n            j=abs(row-r2)+abs(col-c2);\\n            j+=f(s,m,r1,row,c1,col,ind+1,dp);\\n        }\\n        return dp[r1+1][r2+1][c1+1][c2+1][ind]=min(i,j);\\n    }\\n    int minimumDistance(string s) {\\n        map<char,pair<int,int>>m;\\n        for(int i=0;i<26;++i){\\n            for(int j=0;j<5;++j){\\n                for(int k=0;k<6;++k,++i){\\n                    if(i>=26) break;\\n                    m[\\'A\\'+i]={j,k};\\n                }\\n            }\\n        }\\n        vector<vector<vector<vector<vector<int>>>>>dp(6,vector<vector<vector<vector<int>>>>(6,vector<vector<vector<int>>>(7,vector<vector<int>>(7,vector<int>(s.size(),-1)))));\\n        return f(s,m,-1,-1,-1,-1,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(string &s,map<char,pair<int,int>>&m,int r1,int r2,int c1,int c2,int ind,vector<vector<vector<vector<vector<int>>>>>&dp){\\n        if(ind==s.size()) return 0;\\n        int row=m[s[ind]].first;\\n        int col=m[s[ind]].second;\\n        int i=1e9,j=1e9;\\n        if(dp[r1+1][r2+1][c1+1][c2+1][ind]!=-1) return dp[r1+1][r2+1][c1+1][c2+1][ind];\\n        if(r1==-1 && c1==-1){\\n            i=f(s,m,row,r2,col,c2,ind+1,dp);\\n        }\\n        else{\\n            i=abs(row-r1)+abs(col-c1);\\n            i+=f(s,m,row,r2,col,c2,ind+1,dp);\\n        }\\n        if(r2==-1 && c2==-1){\\n            j=f(s,m,r1,row,c1,col,ind+1,dp);\\n        }\\n        else{\\n            j=abs(row-r2)+abs(col-c2);\\n            j+=f(s,m,r1,row,c1,col,ind+1,dp);\\n        }\\n        return dp[r1+1][r2+1][c1+1][c2+1][ind]=min(i,j);\\n    }\\n    int minimumDistance(string s) {\\n        map<char,pair<int,int>>m;\\n        for(int i=0;i<26;++i){\\n            for(int j=0;j<5;++j){\\n                for(int k=0;k<6;++k,++i){\\n                    if(i>=26) break;\\n                    m[\\'A\\'+i]={j,k};\\n                }\\n            }\\n        }\\n        vector<vector<vector<vector<vector<int>>>>>dp(6,vector<vector<vector<vector<int>>>>(6,vector<vector<vector<int>>>(7,vector<vector<int>>(7,vector<int>(s.size(),-1)))));\\n        return f(s,m,-1,-1,-1,-1,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2972439,
                "title": "c-o-n-with-explanation",
                "content": "# Intuition\\nThe idea is that to press any character, there are 2 options\\n- Press the char using the left finger \\n- Press the char using the right finger (so, add the distance from previous left/right finger character to the current character)\\n- pick the smallest one\\n\\n# Approach\\n- Store the possible states in a dp[N][26][26] array\\n\\n# Complexity\\n- Time complexity:\\nO(N), where N=length of word\\n\\n- Space complexity:\\nO(N), where N=length of word\\n\\n# Code\\n```\\nclass Solution {\\n    int N;\\n\\n    int dp[302][27][27];\\n\\n    int getDis(int x, int y){\\n        int r1=x/6, c1=x%6;\\n        int r2=y/6, c2=y%6;\\n        return abs(r1-r2)+abs(c1-c2);\\n    }\\n\\n    int solve(string &word, int ind, int lf, int rf){\\n        if(ind==N) return 0;\\n        if(dp[ind][lf][rf]!=-1) return dp[ind][lf][rf];\\n        char c=word[ind];\\n\\n        //op1->press using left finger\\n        int disLeft = lf==26? 0: getDis(lf,c-\\'A\\');\\n        int op1=solve(word,ind+1,c-\\'A\\',rf) + disLeft;\\n\\n        //op2->press using right finger\\n        int disRight = rf==26? 0: getDis(rf,c-\\'A\\');\\n        int op2=solve(word,ind+1,lf,c-\\'A\\') + disRight;\\n\\n        return dp[ind][lf][rf] = min(op1,op2);\\n    }\\npublic:\\n    int minimumDistance(string word) {\\n        N=word.size();\\n        memset(dp,-1,sizeof(dp));\\n\\n        // initially both fingers are free (denoting them using index 26)\\n        return solve(word,0,26,26);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int N;\\n\\n    int dp[302][27][27];\\n\\n    int getDis(int x, int y){\\n        int r1=x/6, c1=x%6;\\n        int r2=y/6, c2=y%6;\\n        return abs(r1-r2)+abs(c1-c2);\\n    }\\n\\n    int solve(string &word, int ind, int lf, int rf){\\n        if(ind==N) return 0;\\n        if(dp[ind][lf][rf]!=-1) return dp[ind][lf][rf];\\n        char c=word[ind];\\n\\n        //op1->press using left finger\\n        int disLeft = lf==26? 0: getDis(lf,c-\\'A\\');\\n        int op1=solve(word,ind+1,c-\\'A\\',rf) + disLeft;\\n\\n        //op2->press using right finger\\n        int disRight = rf==26? 0: getDis(rf,c-\\'A\\');\\n        int op2=solve(word,ind+1,lf,c-\\'A\\') + disRight;\\n\\n        return dp[ind][lf][rf] = min(op1,op2);\\n    }\\npublic:\\n    int minimumDistance(string word) {\\n        N=word.size();\\n        memset(dp,-1,sizeof(dp));\\n\\n        // initially both fingers are free (denoting them using index 26)\\n        return solve(word,0,26,26);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2955599,
                "title": "javascript-top-down-dp",
                "content": "```\\n/**\\n * @param {string} word\\n * @return {number}\\n */\\nvar minimumDistance = function (word) {\\n  const map = {};\\n  let code = 65;\\n  for (let i = 0; i < 5; i++) {\\n    for (let j = 0; j < 6; j++) {\\n      const char = String.fromCharCode(code);\\n      map[char] = [i, j];\\n      code++;\\n    }\\n  }\\n\\n  return helper([null, null], [null, null], map, word, 0, {});\\n};\\n\\nfunction helper(prevLeft, prevRight, map, word, idx, cache) {\\n  if (idx === word.length) return 0;\\n\\n  const key = `${prevLeft.join(\\',\\')}:${prevRight.join(\\',\\')}:${idx}`;\\n  if (key in cache) return cache[key];\\n\\n  const char = word[idx];\\n  const pos = map[char];\\n\\n  const moveLeft =\\n    getDistance(prevLeft, pos) +\\n    helper(pos, prevRight, map, word, idx + 1, cache);\\n  const moveRight =\\n    getDistance(prevRight, pos) +\\n    helper(prevLeft, pos, map, word, idx + 1, cache);\\n\\n  return (cache[key] = Math.min(moveLeft, moveRight));\\n}\\n\\nfunction getDistance(posOne, posTwo) {\\n  if (posOne[0] === null || posTwo[0] === null) return 0;\\n  return Math.abs(posOne[0] - posTwo[0]) + Math.abs(posOne[1] - posTwo[1]);\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} word\\n * @return {number}\\n */\\nvar minimumDistance = function (word) {\\n  const map = {};\\n  let code = 65;\\n  for (let i = 0; i < 5; i++) {\\n    for (let j = 0; j < 6; j++) {\\n      const char = String.fromCharCode(code);\\n      map[char] = [i, j];\\n      code++;\\n    }\\n  }\\n\\n  return helper([null, null], [null, null], map, word, 0, {});\\n};\\n\\nfunction helper(prevLeft, prevRight, map, word, idx, cache) {\\n  if (idx === word.length) return 0;\\n\\n  const key = `${prevLeft.join(\\',\\')}:${prevRight.join(\\',\\')}:${idx}`;\\n  if (key in cache) return cache[key];\\n\\n  const char = word[idx];\\n  const pos = map[char];\\n\\n  const moveLeft =\\n    getDistance(prevLeft, pos) +\\n    helper(pos, prevRight, map, word, idx + 1, cache);\\n  const moveRight =\\n    getDistance(prevRight, pos) +\\n    helper(prevLeft, pos, map, word, idx + 1, cache);\\n\\n  return (cache[key] = Math.min(moveLeft, moveRight));\\n}\\n\\nfunction getDistance(posOne, posTwo) {\\n  if (posOne[0] === null || posTwo[0] === null) return 0;\\n  return Math.abs(posOne[0] - posTwo[0]) + Math.abs(posOne[1] - posTwo[1]);\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2909592,
                "title": "python-dp-solution-bottom-up",
                "content": "```\\ndef minimumDistance(self, word: str) -> int:\\n\\td = {c:((ord(c)-ord(\\'A\\'))//6, (ord(c)-ord(\\'A\\'))%6) for c in ascii_uppercase}\\n\\tdef cost(a, b):\\n\\t\\tif not a or not b:\\n\\t\\t\\treturn 0\\n\\t\\treturn abs(d[a][0]-d[b][0])+abs(d[a][1]-d[b][1])\\n\\n\\tdp = {(\\'\\',\\'\\'):0}\\n\\tfor c in word:\\n\\t\\tdp_cur = {}\\n\\t\\tfor f1, f2 in dp:\\n\\t\\t\\tdp_cur[(c, f2)] = min(dp_cur.get((c, f2), 3000), dp[(f1, f2)]+cost(f1, c))\\n\\t\\t\\tdp_cur[(f1, c)] = min(dp_cur.get((f1, c), 3000), dp[(f1, f2)]+cost(f2, c))\\n\\t\\tdp = dp_cur\\n\\treturn min(dp.values())\\n```",
                "solutionTags": [],
                "code": "```\\ndef minimumDistance(self, word: str) -> int:\\n\\td = {c:((ord(c)-ord(\\'A\\'))//6, (ord(c)-ord(\\'A\\'))%6) for c in ascii_uppercase}\\n\\tdef cost(a, b):\\n\\t\\tif not a or not b:\\n\\t\\t\\treturn 0\\n\\t\\treturn abs(d[a][0]-d[b][0])+abs(d[a][1]-d[b][1])\\n\\n\\tdp = {(\\'\\',\\'\\'):0}\\n\\tfor c in word:\\n\\t\\tdp_cur = {}\\n\\t\\tfor f1, f2 in dp:\\n\\t\\t\\tdp_cur[(c, f2)] = min(dp_cur.get((c, f2), 3000), dp[(f1, f2)]+cost(f1, c))\\n\\t\\t\\tdp_cur[(f1, c)] = min(dp_cur.get((f1, c), 3000), dp[(f1, f2)]+cost(f2, c))\\n\\t\\tdp = dp_cur\\n\\treturn min(dp.values())\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2891866,
                "title": "python3-dp-explanation",
                "content": "# Approach\\nThere are 3 Cases to solve this Question\\n1. #First Case -> It is optimal to place one finger on first letter as it will incur 0 cost to type first letter.\\n2. #Second Case -> When one finger is placed and other not then we have 2 option\\n    a.Either use placed Finger to type current letter.\\n    b.Place new finger to type current letter.\\n3. #Third Case -> When Both fingers are placed then to type current letter we can check with both fingers and take minimum cost one.\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        hmap = {\\'A\\':[0,0],\\'B\\':[0,1],\\'C\\':[0,2],\\'D\\':[0,3],\\'E\\':[0,4],\\'F\\':[0,5],\\n                \\'G\\':[1,0],\\'H\\':[1,1],\\'I\\':[1,2],\\'J\\':[1,3],\\'K\\':[1,4],\\'L\\':[1,5],\\n                \\'M\\':[2,0],\\'N\\':[2,1],\\'O\\':[2,2],\\'P\\':[2,3],\\'Q\\':[2,4],\\'R\\':[2,5],\\n                \\'S\\':[3,0],\\'T\\':[3,1],\\'U\\':[3,2],\\'V\\':[3,3],\\'W\\':[3,4],\\'X\\':[3,5],\\n                \\'Y\\':[4,0],\\'Z\\':[4,1]}\\n        n = len(word)\\n        @cache\\n        def dp(ind,finger1,finger2):\\n            if ind == n:\\n                return 0\\n            elif ind == 0: #first case \\n                return dp(ind + 1,word[ind],finger2)\\n            elif finger1 != \"\" and finger2 == \"\": #second case\\n                x1,y1 = hmap[finger1]\\n                x2,y2 = hmap[word[ind]] #current letter to type\\n                cost = abs(x1-x2) + abs(y1-y2) + dp(ind + 1,word[ind],finger2)\\n                cost = min(cost,dp(ind + 1,finger1,word[ind]))\\n                return cost\\n            else: #third case\\n                x1,y1 = hmap[finger1]\\n                x2,y2 = hmap[finger2]\\n                x3,y3 = hmap[word[ind]] #current letter to type\\n                cost = abs(x1-x3) + abs(y1-y3) + dp(ind + 1,word[ind],finger2)\\n                cost = min(cost,abs(x2-x3) + abs(y2-y3) + dp(ind + 1,finger1,word[ind]))\\n                return cost\\n        return dp(0,\"\",\"\")\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        hmap = {\\'A\\':[0,0],\\'B\\':[0,1],\\'C\\':[0,2],\\'D\\':[0,3],\\'E\\':[0,4],\\'F\\':[0,5],\\n                \\'G\\':[1,0],\\'H\\':[1,1],\\'I\\':[1,2],\\'J\\':[1,3],\\'K\\':[1,4],\\'L\\':[1,5],\\n                \\'M\\':[2,0],\\'N\\':[2,1],\\'O\\':[2,2],\\'P\\':[2,3],\\'Q\\':[2,4],\\'R\\':[2,5],\\n                \\'S\\':[3,0],\\'T\\':[3,1],\\'U\\':[3,2],\\'V\\':[3,3],\\'W\\':[3,4],\\'X\\':[3,5],\\n                \\'Y\\':[4,0],\\'Z\\':[4,1]}\\n        n = len(word)\\n        @cache\\n        def dp(ind,finger1,finger2):\\n            if ind == n:\\n                return 0\\n            elif ind == 0: #first case \\n                return dp(ind + 1,word[ind],finger2)\\n            elif finger1 != \"\" and finger2 == \"\": #second case\\n                x1,y1 = hmap[finger1]\\n                x2,y2 = hmap[word[ind]] #current letter to type\\n                cost = abs(x1-x2) + abs(y1-y2) + dp(ind + 1,word[ind],finger2)\\n                cost = min(cost,dp(ind + 1,finger1,word[ind]))\\n                return cost\\n            else: #third case\\n                x1,y1 = hmap[finger1]\\n                x2,y2 = hmap[finger2]\\n                x3,y3 = hmap[word[ind]] #current letter to type\\n                cost = abs(x1-x3) + abs(y1-y3) + dp(ind + 1,word[ind],finger2)\\n                cost = min(cost,abs(x2-x3) + abs(y2-y3) + dp(ind + 1,finger1,word[ind]))\\n                return cost\\n        return dp(0,\"\",\"\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891267,
                "title": "swift-solution-with-brief-explanation",
                "content": "# Approach\\n1. We first create a 3D array of size 27 * 27 * n, where n is the length of the word.\\n2. We then use a DFS to go through each possible combination of left and right fingers.\\n3. At each index, we have two choices: either use the left finger or use the right finger.\\n4. We can find the cost of using each finger by using the formula: abs(fromX - toX) + abs(fromY - toY).\\n    4a. The formula above uses the X and Y coordinates of the from and to fingers to find the cost.\\n5. Once we have the cost of using each finger, we can compare them and return the minimum one.\\n6. We can cache the results of each index to avoid repeated calculations.\\n7. At the end, we return the minimum cost of the first index.\\n8. The time complexity is O(26^3 * n), where 26 is the number of letters in the alphabet.\\n9. The space complexity is O(26^3 * n), where 26 is the number of letters in the alphabet.\\n\\n# Complexity\\n- Time complexity: O(26^3 * n)\\n\\n- Space complexity: O(26^3 * n)\\n\\n# Code\\n```\\n// Minimum Distance to Type a Word Using Two Fingers\\n// https://leetcode.com/problems/minimum-distance-to-type-a-word-using-two-fingers/\\n\\nclass Solution {\\n    func minimumDistance(_ word: String) -> Int {\\n        let word = Array(word)\\n        var dp = Array(repeating: Array(repeating: Array(repeating: Int.max, count: 27), count: 27), count: word.count)\\n        return dfs(0, 26, 26, word, &dp)\\n    }\\n    \\n    func dfs(_ index: Int, _ left: Int, _ right: Int, _ word: [Character], _ dp: inout [[[Int]]]) -> Int {\\n        if index == word.count {\\n            return 0\\n        }\\n        if dp[index][left][right] != Int.max {\\n            return dp[index][left][right]\\n        }\\n        let leftCost = dfs(index + 1, Int(word[index].asciiValue!) - 65, right, word, &dp) + getCost(left, Int(word[index].asciiValue!) - 65)\\n        let rightCost = dfs(index + 1, left, Int(word[index].asciiValue!) - 65, word, &dp) + getCost(right, Int(word[index].asciiValue!) - 65)\\n        dp[index][left][right] = min(leftCost, rightCost)\\n        return dp[index][left][right]\\n    }\\n    \\n    func getCost(_ from: Int, _ to: Int) -> Int {\\n        if from == 26 {\\n            return 0\\n        }\\n        let fromX = from / 6\\n        let fromY = from % 6\\n        let toX = to / 6\\n        let toY = to % 6\\n        return abs(fromX - toX) + abs(fromY - toY)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n// Minimum Distance to Type a Word Using Two Fingers\\n// https://leetcode.com/problems/minimum-distance-to-type-a-word-using-two-fingers/\\n\\nclass Solution {\\n    func minimumDistance(_ word: String) -> Int {\\n        let word = Array(word)\\n        var dp = Array(repeating: Array(repeating: Array(repeating: Int.max, count: 27), count: 27), count: word.count)\\n        return dfs(0, 26, 26, word, &dp)\\n    }\\n    \\n    func dfs(_ index: Int, _ left: Int, _ right: Int, _ word: [Character], _ dp: inout [[[Int]]]) -> Int {\\n        if index == word.count {\\n            return 0\\n        }\\n        if dp[index][left][right] != Int.max {\\n            return dp[index][left][right]\\n        }\\n        let leftCost = dfs(index + 1, Int(word[index].asciiValue!) - 65, right, word, &dp) + getCost(left, Int(word[index].asciiValue!) - 65)\\n        let rightCost = dfs(index + 1, left, Int(word[index].asciiValue!) - 65, word, &dp) + getCost(right, Int(word[index].asciiValue!) - 65)\\n        dp[index][left][right] = min(leftCost, rightCost)\\n        return dp[index][left][right]\\n    }\\n    \\n    func getCost(_ from: Int, _ to: Int) -> Int {\\n        if from == 26 {\\n            return 0\\n        }\\n        let fromX = from / 6\\n        let fromY = from % 6\\n        let toX = to / 6\\n        let toY = to % 6\\n        return abs(fromX - toX) + abs(fromY - toY)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886708,
                "title": "a-dijkstra-s-shortest-path-java",
                "content": "# Intuition\\nThis problem can be modeled as the shortest path to traverse a graph\\n\\n# Approach\\nDijkstra\\'s shortest path algorithm\\n\\n# Complexity\\n- Time complexity: $$O((E+ V) * log (V))$$\\n  - V number of vertices: word length * (distinct chars) * (distinct chars)\\n  - E number of edges: 2 * vertices\\n  \\n- Space complexity: $$O(V)$$\\n  - V number of vertices: word length * (distinct chars) * (distinct chars)\\n\\n# Code\\n```\\nclass Solution {\\n\\n    // precomputed table with distances between characters in the keyboard\\n    static int distances[][] = distancesTable(5, 6);\\n\\n    static int[][] distancesTable(int rows, int columns) {\\n\\n        int [][] ret = new int[27][27];\\n\\n        for(int i = 0; i < 26; i ++) {\\n            int rowFrom = i/columns;\\n            int columnFrom = i%columns;\\n\\n            for(int j = i+1; j < 26; j ++) {\\n                int rowTo = j/columns;\\n                int columnTo = j%columns;\\n\\n                int distance = Math.abs(rowTo - rowFrom) + Math.abs(columnTo - columnFrom);\\n                ret[i][j] = distance;\\n                ret[j][i] = distance;\\n            }\\n        }\\n\\n        return ret;\\n    }\\n\\n    static class Entry {\\n\\n        final int index;\\n        final int fingerOnePosition;\\n        final int fingerTwoPosition;\\n        final int distanceSoFar;\\n\\n        public Entry(\\n            int index, \\n            int fingerOnePosition, \\n            int fingerTwoPosition, \\n            int distanceSoFar\\n        ) {\\n            this.index = index;\\n            this.fingerOnePosition = fingerOnePosition;\\n            this.fingerTwoPosition = fingerTwoPosition;\\n            this.distanceSoFar = distanceSoFar;\\n        }\\n    };\\n\\n    static final int fingerOneOffset = 27 * 27;\\n    static final int fingerTwoOffset = 27;\\n\\n    public int minimumDistance(String word) {\\n\\n        if (word == null || word.length() == 0) {\\n            return 0;\\n        }\\n\\n        Comparator<Entry> comparator = (a, b) -> {\\n\\n            // compare distances\\n            int diff = a.distanceSoFar - b.distanceSoFar;\\n\\n            // if same distance prefer state with most progress\\n            if (diff == 0) {\\n                diff = b.index - a.index;\\n            }\\n\\n            return diff;\\n        };\\n\\n        final PriorityQueue<Entry> queue = new PriorityQueue<>(comparator);\\n        \\n        queue.offer(new Entry(\\n            0, \\n            // use the first finger\\n            word.charAt(0)-\\'A\\', \\n            // mark second finger as free \\n            26, \\n            0\\n        ));\\n        \\n        final boolean[] visited = new boolean[1 + (27*27)*(word.length()+1)];\\n\\n        while (!queue.isEmpty()) {\\n\\n            final Entry entry = queue.poll();\\n\\n            final int index = entry.index;\\n            final int fingerOnePosition = entry.fingerOnePosition;\\n            final int fingerTwoPosition = entry.fingerTwoPosition;\\n\\n            int distanceSoFar = entry.distanceSoFar;\\n\\n            if (index == word.length()-1) {\\n                return distanceSoFar;\\n            }\\n            \\n            // state already processed, skip\\n            if (visited[index * fingerOneOffset + fingerOnePosition * fingerTwoOffset + fingerTwoPosition]) {\\n                continue;\\n            }\\n\\n            final char currentChar = word.charAt(index);\\n\\n            // skip repeated chars, ex: \\'AAAAAAAAAA...\\'\\n            int nextIndex = index+1;\\n            while(nextIndex < word.length() - 1 && word.charAt(nextIndex) == currentChar) {\\n                nextIndex++;\\n            }\\n\\n            final int nextPosition = word.charAt(nextIndex) -\\'A\\';\\n            \\n            // use finger one\\n            final int fingerOneDistance = distances[fingerOnePosition][nextPosition];\\n            queue.offer(new Entry(\\n                nextIndex,\\n                nextPosition,\\n                fingerTwoPosition,\\n                distanceSoFar + fingerOneDistance\\n            ));\\n\\n            // use the other finger\\n            final int fingerTwoDistance = distances[fingerTwoPosition][nextPosition];\\n            queue.offer(new Entry(\\n                nextIndex,\\n                fingerOnePosition,\\n                nextPosition,\\n                distanceSoFar + fingerTwoDistance\\n            ));\\n\\n            // mark state as already processed\\n            visited[index * fingerOneOffset + fingerOnePosition * fingerTwoOffset + fingerTwoPosition] = true;\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    // precomputed table with distances between characters in the keyboard\\n    static int distances[][] = distancesTable(5, 6);\\n\\n    static int[][] distancesTable(int rows, int columns) {\\n\\n        int [][] ret = new int[27][27];\\n\\n        for(int i = 0; i < 26; i ++) {\\n            int rowFrom = i/columns;\\n            int columnFrom = i%columns;\\n\\n            for(int j = i+1; j < 26; j ++) {\\n                int rowTo = j/columns;\\n                int columnTo = j%columns;\\n\\n                int distance = Math.abs(rowTo - rowFrom) + Math.abs(columnTo - columnFrom);\\n                ret[i][j] = distance;\\n                ret[j][i] = distance;\\n            }\\n        }\\n\\n        return ret;\\n    }\\n\\n    static class Entry {\\n\\n        final int index;\\n        final int fingerOnePosition;\\n        final int fingerTwoPosition;\\n        final int distanceSoFar;\\n\\n        public Entry(\\n            int index, \\n            int fingerOnePosition, \\n            int fingerTwoPosition, \\n            int distanceSoFar\\n        ) {\\n            this.index = index;\\n            this.fingerOnePosition = fingerOnePosition;\\n            this.fingerTwoPosition = fingerTwoPosition;\\n            this.distanceSoFar = distanceSoFar;\\n        }\\n    };\\n\\n    static final int fingerOneOffset = 27 * 27;\\n    static final int fingerTwoOffset = 27;\\n\\n    public int minimumDistance(String word) {\\n\\n        if (word == null || word.length() == 0) {\\n            return 0;\\n        }\\n\\n        Comparator<Entry> comparator = (a, b) -> {\\n\\n            // compare distances\\n            int diff = a.distanceSoFar - b.distanceSoFar;\\n\\n            // if same distance prefer state with most progress\\n            if (diff == 0) {\\n                diff = b.index - a.index;\\n            }\\n\\n            return diff;\\n        };\\n\\n        final PriorityQueue<Entry> queue = new PriorityQueue<>(comparator);\\n        \\n        queue.offer(new Entry(\\n            0, \\n            // use the first finger\\n            word.charAt(0)-\\'A\\', \\n            // mark second finger as free \\n            26, \\n            0\\n        ));\\n        \\n        final boolean[] visited = new boolean[1 + (27*27)*(word.length()+1)];\\n\\n        while (!queue.isEmpty()) {\\n\\n            final Entry entry = queue.poll();\\n\\n            final int index = entry.index;\\n            final int fingerOnePosition = entry.fingerOnePosition;\\n            final int fingerTwoPosition = entry.fingerTwoPosition;\\n\\n            int distanceSoFar = entry.distanceSoFar;\\n\\n            if (index == word.length()-1) {\\n                return distanceSoFar;\\n            }\\n            \\n            // state already processed, skip\\n            if (visited[index * fingerOneOffset + fingerOnePosition * fingerTwoOffset + fingerTwoPosition]) {\\n                continue;\\n            }\\n\\n            final char currentChar = word.charAt(index);\\n\\n            // skip repeated chars, ex: \\'AAAAAAAAAA...\\'\\n            int nextIndex = index+1;\\n            while(nextIndex < word.length() - 1 && word.charAt(nextIndex) == currentChar) {\\n                nextIndex++;\\n            }\\n\\n            final int nextPosition = word.charAt(nextIndex) -\\'A\\';\\n            \\n            // use finger one\\n            final int fingerOneDistance = distances[fingerOnePosition][nextPosition];\\n            queue.offer(new Entry(\\n                nextIndex,\\n                nextPosition,\\n                fingerTwoPosition,\\n                distanceSoFar + fingerOneDistance\\n            ));\\n\\n            // use the other finger\\n            final int fingerTwoDistance = distances[fingerTwoPosition][nextPosition];\\n            queue.offer(new Entry(\\n                nextIndex,\\n                fingerOnePosition,\\n                nextPosition,\\n                distanceSoFar + fingerTwoDistance\\n            ));\\n\\n            // mark state as already processed\\n            visited[index * fingerOneOffset + fingerOnePosition * fingerTwoOffset + fingerTwoPosition] = true;\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2879118,
                "title": "javascript-dp",
                "content": "\\n# Code\\n```\\n/**\\n * @param {string} word\\n * @return {number}\\n */\\nvar minimumDistance = function(word) {\\nfunction helper(i, j, k){\\n        if(i == word.length) return 0;\\n        let x =  (word.charCodeAt(i)-65) / 6 >>0;\\n        let y =  (word.charCodeAt(i)-65) % 6;\\n        if(dp[i][j][k] != undefined) return dp[i][j][k];\\n        // have not placed finger on any key\\n        if(j == 0 && k == 0){\\n            return dp[i][j][k] =  Math.min(helper(i+1, word.charCodeAt(i)-65+1, k),\\n            helper(i+1, j, word.charCodeAt(i)-65+1));\\n        }else if(j==0){\\n            return dp[i][j][k] =  Math.min(helper(i+1, word.charCodeAt(i)-65+1, k), \\n            Math.abs(x - ((k-1) / 6 >>0)) + Math.abs(y - ((k-1) % 6)) +\\n            helper(i+1, j, word.charCodeAt(i)-65+1));\\n        } else if(k == 0){\\n            return dp[i][j][k] =  Math.min(helper(i+1, j, word.charCodeAt(i)-65+1), \\n            Math.abs(x - ((j-1) / 6 >>0)) + Math.abs(y - ((j-1) % 6)) +\\n            helper(i+1, word.charCodeAt(i)-65+1, k));\\n        }else{\\n            return dp[i][j][k] =  Math.min(Math.abs(x - ((j-1) / 6 >>0)) +\\n            Math.abs(y - ((j-1) % 6)) + helper(i+1, word.charCodeAt(i)-65+1, k),\\n            Math.abs(x - ((k-1) / 6 >>0)) + Math.abs(y - ((k-1) % 6)) +\\n            helper(i+1, j, word.charCodeAt(i)-65+1));\\n        }\\n    }\\n    let dp = Array.from(Array(word.length), ()=> new Array(27));\\n    for(let i = 0; i < word.length; i++){\\n        for(let j = 0; j < 27; j++){\\n            dp[i][j] = new Array(27);\\n        }    \\n    }\\n    let ans = helper(0,0,0);\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} word\\n * @return {number}\\n */\\nvar minimumDistance = function(word) {\\nfunction helper(i, j, k){\\n        if(i == word.length) return 0;\\n        let x =  (word.charCodeAt(i)-65) / 6 >>0;\\n        let y =  (word.charCodeAt(i)-65) % 6;\\n        if(dp[i][j][k] != undefined) return dp[i][j][k];\\n        // have not placed finger on any key\\n        if(j == 0 && k == 0){\\n            return dp[i][j][k] =  Math.min(helper(i+1, word.charCodeAt(i)-65+1, k),\\n            helper(i+1, j, word.charCodeAt(i)-65+1));\\n        }else if(j==0){\\n            return dp[i][j][k] =  Math.min(helper(i+1, word.charCodeAt(i)-65+1, k), \\n            Math.abs(x - ((k-1) / 6 >>0)) + Math.abs(y - ((k-1) % 6)) +\\n            helper(i+1, j, word.charCodeAt(i)-65+1));\\n        } else if(k == 0){\\n            return dp[i][j][k] =  Math.min(helper(i+1, j, word.charCodeAt(i)-65+1), \\n            Math.abs(x - ((j-1) / 6 >>0)) + Math.abs(y - ((j-1) % 6)) +\\n            helper(i+1, word.charCodeAt(i)-65+1, k));\\n        }else{\\n            return dp[i][j][k] =  Math.min(Math.abs(x - ((j-1) / 6 >>0)) +\\n            Math.abs(y - ((j-1) % 6)) + helper(i+1, word.charCodeAt(i)-65+1, k),\\n            Math.abs(x - ((k-1) / 6 >>0)) + Math.abs(y - ((k-1) % 6)) +\\n            helper(i+1, j, word.charCodeAt(i)-65+1));\\n        }\\n    }\\n    let dp = Array.from(Array(word.length), ()=> new Array(27));\\n    for(let i = 0; i < word.length; i++){\\n        for(let j = 0; j < 27; j++){\\n            dp[i][j] = new Array(27);\\n        }    \\n    }\\n    let ans = helper(0,0,0);\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2794584,
                "title": "simple-c-solution-dp-memoisation",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[300][27][27];\\n\\n    int solve(string s,char a,char b,int ind){\\n        // base case\\n        if(ind >= s.size()) return 0;\\n        \\n        int k1 = 0;\\n        int k2 = 0;\\n\\n        int x = a-\\'A\\', y = b-\\'A\\';\\n        if(a == \\'-\\') x = 26;\\n        if(b == \\'-\\') y = 26;\\n\\n        // dp \\n        int &ans = dp[ind][x][y];\\n        if(ans != -1) return ans;\\n        \\n\\n        // solution \\n\\n        // find k -> distance from first and second finger respectively\\n        if(a != \\'-\\'){\\n            k1 = abs((s[ind]-\\'A\\')/6 - (a-\\'A\\')/6) + abs((s[ind]-\\'A\\')%6  - (a-\\'A\\')%6);\\n        }\\n        if(b != \\'-\\'){\\n            k2 = abs((s[ind]-\\'A\\')/6  - (b-\\'A\\')/6) + abs((s[ind]-\\'A\\')%6  - (b-\\'A\\')%6);\\n        }\\n\\n        // recursive call\\n        int call_1 = k1 + solve(s,s[ind],b,ind+1);\\n        int call_2 = k2 + solve(s,a,s[ind],ind+1);\\n\\n        return ans = min(call_1,call_2);\\n    }\\n\\n    int minimumDistance(string word) {\\n        memset(dp,-1,sizeof(dp));\\n\\n        return solve(word,\\'-\\',\\'-\\',0);   \\n    }\\n};\\n```\\n# upvote if it\\'s help you HAPPY CODING :)",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[300][27][27];\\n\\n    int solve(string s,char a,char b,int ind){\\n        // base case\\n        if(ind >= s.size()) return 0;\\n        \\n        int k1 = 0;\\n        int k2 = 0;\\n\\n        int x = a-\\'A\\', y = b-\\'A\\';\\n        if(a == \\'-\\') x = 26;\\n        if(b == \\'-\\') y = 26;\\n\\n        // dp \\n        int &ans = dp[ind][x][y];\\n        if(ans != -1) return ans;\\n        \\n\\n        // solution \\n\\n        // find k -> distance from first and second finger respectively\\n        if(a != \\'-\\'){\\n            k1 = abs((s[ind]-\\'A\\')/6 - (a-\\'A\\')/6) + abs((s[ind]-\\'A\\')%6  - (a-\\'A\\')%6);\\n        }\\n        if(b != \\'-\\'){\\n            k2 = abs((s[ind]-\\'A\\')/6  - (b-\\'A\\')/6) + abs((s[ind]-\\'A\\')%6  - (b-\\'A\\')%6);\\n        }\\n\\n        // recursive call\\n        int call_1 = k1 + solve(s,s[ind],b,ind+1);\\n        int call_2 = k2 + solve(s,a,s[ind],ind+1);\\n\\n        return ans = min(call_1,call_2);\\n    }\\n\\n    int minimumDistance(string word) {\\n        memset(dp,-1,sizeof(dp));\\n\\n        return solve(word,\\'-\\',\\'-\\',0);   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2771546,
                "title": "simple-dp-solution-fully-explained-python",
                "content": "First thing you need to figure out is how to map alphabet character to matrix (keyboard) coordinates. \\nif A => 0 => (0, 0) = (0//columns, 0%columns)\\nif B => 1 => (0, 1) = (1//6, 1%6), 6 is the number of columns in matrix\\nZ => 25 => (4, 1) => (25//6, 25%6)\\n\\nFor each move you have two options, you can either use left finger or use right finger. This naturally builds up a recurssive solution. \\n**State parameters of this problem are:**\\n`(left_finger_location, right_finger_location, w_i)`\\n`w_i is the index of next character you need to type.` \\nThese parameters can uniquely define the problem, so you can cache repeated calls.\\n\\n**Time: O(27 * 27 * len(word))**\\n**Space: O(27 * 27 * len(word))**\\n```\\ndef minimumDistance(self, word: str) -> int:\\n    n = 6\\n    locations = [0]*26\\n    for i in range(26):\\n        locations[i] = [i//n, i%n]\\n\\n    @lru_cache(None)\\n    def dp(l_i, l_j, r_i, r_j, w_i):\\n\\n        if w_i == len(word):\\n            return 0\\n\\n        x,y = locations[ord(word[w_i]) - ord(\"A\")]\\n        left_dis = 0 if l_i == -1 else abs(x - l_i) + abs(y - l_j)\\n        right_dis= 0 if r_i == -1 else abs(x - r_i) + abs(y - r_j)\\n        return min(left_dis + dp(x, y, r_i, r_j, w_i + 1), right_dis + dp(l_i, l_j, x, y, w_i + 1))\\n    \\n    return dp(-1,-1,-1,-1, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\ndef minimumDistance(self, word: str) -> int:\\n    n = 6\\n    locations = [0]*26\\n    for i in range(26):\\n        locations[i] = [i//n, i%n]\\n\\n    @lru_cache(None)\\n    def dp(l_i, l_j, r_i, r_j, w_i):\\n\\n        if w_i == len(word):\\n            return 0\\n\\n        x,y = locations[ord(word[w_i]) - ord(\"A\")]\\n        left_dis = 0 if l_i == -1 else abs(x - l_i) + abs(y - l_j)\\n        right_dis= 0 if r_i == -1 else abs(x - r_i) + abs(y - r_j)\\n        return min(left_dis + dp(x, y, r_i, r_j, w_i + 1), right_dis + dp(l_i, l_j, x, y, w_i + 1))\\n    \\n    return dp(-1,-1,-1,-1, 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2753827,
                "title": "help-me-debug-my-solution",
                "content": "Can someone point out what is wrong in this approach?\\nThis is currently giving wrong answer\\n\\n\\n```\\nclass Solution {\\n    \\n    HashMap<Character, int[]>map;\\n    public int minimumDistance(String word) {\\n        map = new HashMap<Character, int[]>();\\n        populate();\\n        return solve(0, null, null, word, -1);\\n    }\\n    \\n    public int solve(int i, Character prev_f1, Character prev_f2, String word, int finger)\\n    {\\n        if(i == word.length())\\n        {\\n            return 0;\\n        }\\n        int costOfThis = 0;\\n        if(finger == -1)\\n        {\\n            costOfThis = 0;\\n        }\\n        else if(finger == 1 )\\n        {\\n            costOfThis = cost(prev_f1, word.charAt(i));\\n            //System.out.println(costOfThis+\" f1\"+word.charAt(i)+\" \"+prev_f1);\\n        }\\n        else if(finger == 2)\\n        {\\n            costOfThis = cost(prev_f2, word.charAt(i));\\n            //System.out.println(costOfThis+\" f2\");\\n        }\\n        \\n        int left = solve(i+1, word.charAt(i), prev_f2, word, 1);\\n        int right = solve(i+1, prev_f1, word.charAt(i), word, 2);\\n        \\n        int partialResult = costOfThis+ Math.min(left, right);\\n        \\n        return partialResult;\\n        \\n            \\n            \\n    \\n    }\\n    \\n    public int cost(Character prev, Character next)\\n    {\\n        if(prev == null)\\n            return 0;\\n        else\\n            return Math.abs(map.get(prev)[0] - map.get(next)[0]) + Math.abs(map.get(prev)[1] - map.get(next)[1]);\\n        \\n    }\\n    public void populate()\\n    {\\n        //TODO populates the hashmap\\n        char start = \\'A\\';\\n        for(int i=0; i<5; i++)\\n        {\\n           for(int j=0; j<6; j++)\\n            {\\n\\n               map.put(start, new int[]{i, j});\\n               start++;\\n            } \\n        }\\n    }\\n        \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    HashMap<Character, int[]>map;\\n    public int minimumDistance(String word) {\\n        map = new HashMap<Character, int[]>();\\n        populate();\\n        return solve(0, null, null, word, -1);\\n    }\\n    \\n    public int solve(int i, Character prev_f1, Character prev_f2, String word, int finger)\\n    {\\n        if(i == word.length())\\n        {\\n            return 0;\\n        }\\n        int costOfThis = 0;\\n        if(finger == -1)\\n        {\\n            costOfThis = 0;\\n        }\\n        else if(finger == 1 )\\n        {\\n            costOfThis = cost(prev_f1, word.charAt(i));\\n            //System.out.println(costOfThis+\" f1\"+word.charAt(i)+\" \"+prev_f1);\\n        }\\n        else if(finger == 2)\\n        {\\n            costOfThis = cost(prev_f2, word.charAt(i));\\n            //System.out.println(costOfThis+\" f2\");\\n        }\\n        \\n        int left = solve(i+1, word.charAt(i), prev_f2, word, 1);\\n        int right = solve(i+1, prev_f1, word.charAt(i), word, 2);\\n        \\n        int partialResult = costOfThis+ Math.min(left, right);\\n        \\n        return partialResult;\\n        \\n            \\n            \\n    \\n    }\\n    \\n    public int cost(Character prev, Character next)\\n    {\\n        if(prev == null)\\n            return 0;\\n        else\\n            return Math.abs(map.get(prev)[0] - map.get(next)[0]) + Math.abs(map.get(prev)[1] - map.get(next)[1]);\\n        \\n    }\\n    public void populate()\\n    {\\n        //TODO populates the hashmap\\n        char start = \\'A\\';\\n        for(int i=0; i<5; i++)\\n        {\\n           for(int j=0; j<6; j++)\\n            {\\n\\n               map.put(start, new int[]{i, j});\\n               start++;\\n            } \\n        }\\n    }\\n        \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2753045,
                "title": "minimum-distance-to-type-a-word-using-two-fingers",
                "content": "```\\nclass Solution {\\npublic:\\n    int f(int i,string &word,int n,char left,char right, vector<vector<vector<int> > > &dp){\\n        if(i==n) return 0;\\n        if(dp[i][left-\\'A\\'+1][right-\\'A\\'+1]!=-1) return dp[i][left-\\'A\\'+1][right-\\'A\\'+1];\\n        // case 1 - left;\\n        int left_ = INT_MAX;\\n        int right_ = INT_MAX;\\n        int x = (word[i] - \\'A\\')/6;\\n        int y = (word[i] - \\'A\\')%6;\\n        int left_x = (left - \\'A\\')/6;\\n        int left_y = (left - \\'A\\')%6;\\n        int right_x = (right - \\'A\\')/6;\\n        int right_y = (right - \\'A\\')%6;\\n        \\n        left_ = abs(x - left_x) + abs(y - left_y);\\n        right_ = abs(x-right_x) + abs(y-right_y);\\n        if(left==\\'@\\') left_ = 0;\\n        if(right==\\'@\\') right_ = 0;\\n        \\n        // cout<<left_ <<\" \"<<right_<<\\'\\\\n\\';\\n        int k =  f(i+1,word,n,word[i],right,dp);\\n        int l = f(i+1,word,n,left,word[i],dp);\\n        // cout<<left_ + k<<\" \"<<right_ + l<<\\'\\\\n\\';\\n        return dp[i][left-\\'A\\'+1][right-\\'A\\'+1] = min(left_+k,right_+l);\\n        \\n    }\\n    int minimumDistance(string word) {\\n        // x => /6 y=%6;\\n        int n=word.length();\\n        vector<vector<vector<int> > > dp(n,vector<vector<int>> (27,vector<int>(27,-1)));\\n        \\n        return f(0,word,n,\\'@\\',\\'@\\',dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int i,string &word,int n,char left,char right, vector<vector<vector<int> > > &dp){\\n        if(i==n) return 0;\\n        if(dp[i][left-\\'A\\'+1][right-\\'A\\'+1]!=-1) return dp[i][left-\\'A\\'+1][right-\\'A\\'+1];\\n        // case 1 - left;\\n        int left_ = INT_MAX;\\n        int right_ = INT_MAX;\\n        int x = (word[i] - \\'A\\')/6;\\n        int y = (word[i] - \\'A\\')%6;\\n        int left_x = (left - \\'A\\')/6;\\n        int left_y = (left - \\'A\\')%6;\\n        int right_x = (right - \\'A\\')/6;\\n        int right_y = (right - \\'A\\')%6;\\n        \\n        left_ = abs(x - left_x) + abs(y - left_y);\\n        right_ = abs(x-right_x) + abs(y-right_y);\\n        if(left==\\'@\\') left_ = 0;\\n        if(right==\\'@\\') right_ = 0;\\n        \\n        // cout<<left_ <<\" \"<<right_<<\\'\\\\n\\';\\n        int k =  f(i+1,word,n,word[i],right,dp);\\n        int l = f(i+1,word,n,left,word[i],dp);\\n        // cout<<left_ + k<<\" \"<<right_ + l<<\\'\\\\n\\';\\n        return dp[i][left-\\'A\\'+1][right-\\'A\\'+1] = min(left_+k,right_+l);\\n        \\n    }\\n    int minimumDistance(string word) {\\n        // x => /6 y=%6;\\n        int n=word.length();\\n        vector<vector<vector<int> > > dp(n,vector<vector<int>> (27,vector<int>(27,-1)));\\n        \\n        return f(0,word,n,\\'@\\',\\'@\\',dp);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2752505,
                "title": "c-memoization-space-optimization-dp",
                "content": "```\\n#define vvi  vector<vector<int>>\\nclass Solution {\\npublic:\\n    int solve(int idx,string &word,char first,char second,vvi \\n              &chart,unordered_map<string,int> &dp){\\n        //base case\\n        if(idx>=word.size())\\n            return 0;\\n        \\n        // create the key\\n        string key = to_string(idx) + \"$\" + first + \"$\" + second;\\n        \\n        //check the cache\\n        if(dp.count(key))\\n            return dp[key];\\n        \\n        char curr=word[idx];\\n        int  first_finger=0;\\n        int  second_finger=0;\\n        char temp_first=first;\\n        char temp_second=second;\\n        \\n        // use first finger\\n        if(first == \\'#\\') first=curr;\\n        first_finger = abs(chart[curr-\\'A\\'][0]-chart[first-\\'A\\'][0]) +\\n                       abs(chart[curr-\\'A\\'][1]-chart[first-\\'A\\'][1]) +\\n                       solve(idx+1,word,curr,second,chart,dp);\\n        \\n        first = temp_first;\\n        \\n         // use second finger\\n        if(second == \\'#\\') second = curr;\\n        second_finger = abs(chart[curr-\\'A\\'][0]-chart[second-\\'A\\'][0]) +\\n                        abs(chart[curr-\\'A\\'][1]-chart[second-\\'A\\'][1]) +\\n                        solve(idx+1,word,first,curr,chart,dp);\\n        \\n        second = temp_second;\\n        \\n       return dp[key] = \\n              min(first_finger , second_finger);\\n        \\n    }\\n    int minimumDistance(string word) {\\n        \\n        vvi chart(26,vector<int>(2,0));\\n        int row=0,col=0;\\n        for(int i=0;i<26;i++){\\n            chart[i][0]=row;    // row value\\n            chart[i][1]=col;    // col value\\n            col++;\\n            if(col>5)\\n                col=0,row++;\\n        }\\n        unordered_map<string,int>dp;\\n        return solve(0,word,\\'#\\',\\'#\\',chart,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n#define vvi  vector<vector<int>>\\nclass Solution {\\npublic:\\n    int solve(int idx,string &word,char first,char second,vvi \\n              &chart,unordered_map<string,int> &dp){\\n        //base case\\n        if(idx>=word.size())\\n            return 0;\\n        \\n        // create the key\\n        string key = to_string(idx) + \"$\" + first + \"$\" + second;\\n        \\n        //check the cache\\n        if(dp.count(key))\\n            return dp[key];\\n        \\n        char curr=word[idx];\\n        int  first_finger=0;\\n        int  second_finger=0;\\n        char temp_first=first;\\n        char temp_second=second;\\n        \\n        // use first finger\\n        if(first == \\'#\\') first=curr;\\n        first_finger = abs(chart[curr-\\'A\\'][0]-chart[first-\\'A\\'][0]) +\\n                       abs(chart[curr-\\'A\\'][1]-chart[first-\\'A\\'][1]) +\\n                       solve(idx+1,word,curr,second,chart,dp);\\n        \\n        first = temp_first;\\n        \\n         // use second finger\\n        if(second == \\'#\\') second = curr;\\n        second_finger = abs(chart[curr-\\'A\\'][0]-chart[second-\\'A\\'][0]) +\\n                        abs(chart[curr-\\'A\\'][1]-chart[second-\\'A\\'][1]) +\\n                        solve(idx+1,word,first,curr,chart,dp);\\n        \\n        second = temp_second;\\n        \\n       return dp[key] = \\n              min(first_finger , second_finger);\\n        \\n    }\\n    int minimumDistance(string word) {\\n        \\n        vvi chart(26,vector<int>(2,0));\\n        int row=0,col=0;\\n        for(int i=0;i<26;i++){\\n            chart[i][0]=row;    // row value\\n            chart[i][1]=col;    // col value\\n            col++;\\n            if(col>5)\\n                col=0,row++;\\n        }\\n        unordered_map<string,int>dp;\\n        return solve(0,word,\\'#\\',\\'#\\',chart,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2752467,
                "title": "c-dp-approach-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(int idx,string &word,char first,char second,vvi \\n              &chart,vvvi &dp){\\n        //base case\\n        if(idx>=word.size())\\n            return 0;\\n        \\n        //check the cache\\n        if(dp[idx][first][second]!=-1)\\n            return dp[idx][first][second];\\n        \\n        char curr=word[idx];\\n        int  first_finger=0;\\n        int  second_finger=0;\\n        char temp_first=first;\\n        char temp_second=second;\\n        \\n        // use first finger\\n        if(first == \\'#\\') first=curr;\\n        first_finger = abs(chart[curr-\\'A\\'][0]-chart[first-\\'A\\'][0]) +\\n                       abs(chart[curr-\\'A\\'][1]-chart[first-\\'A\\'][1]) +\\n                       solve(idx+1,word,curr,second,chart,dp);\\n        \\n        first = temp_first;\\n        \\n         // use second finger\\n        if(second == \\'#\\') second = curr;\\n        second_finger = abs(chart[curr-\\'A\\'][0]-chart[second-\\'A\\'][0]) +\\n                        abs(chart[curr-\\'A\\'][1]-chart[second-\\'A\\'][1]) +\\n                        solve(idx+1,word,first,curr,chart,dp);\\n        \\n        second = temp_second;\\n        \\n       return dp[idx][first][second]= \\n              min(first_finger , second_finger);\\n        \\n    }\\n    int minimumDistance(string word) {\\n        \\n        vvi chart(26,vector<int>(2,0));\\n        int row=0,col=0;\\n        for(int i=0;i<26;i++){\\n            chart[i][0]=row;    // row value\\n            chart[i][1]=col;    // col value\\n            col++;\\n            if(col>5)\\n                col=0,row++;\\n        }\\n        vvvi dp(word.size(),vvi(256,vector<int>(256,-1)));\\n        return solve(0,word,\\'#\\',\\'#\\',chart,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int idx,string &word,char first,char second,vvi \\n              &chart,vvvi &dp){\\n        //base case\\n        if(idx>=word.size())\\n            return 0;\\n        \\n        //check the cache\\n        if(dp[idx][first][second]!=-1)\\n            return dp[idx][first][second];\\n        \\n        char curr=word[idx];\\n        int  first_finger=0;\\n        int  second_finger=0;\\n        char temp_first=first;\\n        char temp_second=second;\\n        \\n        // use first finger\\n        if(first == \\'#\\') first=curr;\\n        first_finger = abs(chart[curr-\\'A\\'][0]-chart[first-\\'A\\'][0]) +\\n                       abs(chart[curr-\\'A\\'][1]-chart[first-\\'A\\'][1]) +\\n                       solve(idx+1,word,curr,second,chart,dp);\\n        \\n        first = temp_first;\\n        \\n         // use second finger\\n        if(second == \\'#\\') second = curr;\\n        second_finger = abs(chart[curr-\\'A\\'][0]-chart[second-\\'A\\'][0]) +\\n                        abs(chart[curr-\\'A\\'][1]-chart[second-\\'A\\'][1]) +\\n                        solve(idx+1,word,first,curr,chart,dp);\\n        \\n        second = temp_second;\\n        \\n       return dp[idx][first][second]= \\n              min(first_finger , second_finger);\\n        \\n    }\\n    int minimumDistance(string word) {\\n        \\n        vvi chart(26,vector<int>(2,0));\\n        int row=0,col=0;\\n        for(int i=0;i<26;i++){\\n            chart[i][0]=row;    // row value\\n            chart[i][1]=col;    // col value\\n            col++;\\n            if(col>5)\\n                col=0,row++;\\n        }\\n        vvvi dp(word.size(),vvi(256,vector<int>(256,-1)));\\n        return solve(0,word,\\'#\\',\\'#\\',chart,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666666,
                "title": "python-recursive-dp-64-time-28-space",
                "content": "```\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        def findCoord(letter):\\n            code = ord(letter) - 65\\n            # Find row\\n            row = code // 6\\n            # Find col\\n            col = code % 6\\n            return [row, col]\\n        \\n        def calDistance(arr1, arr2):\\n            x1, y1 = arr1\\n            x2, y2 = arr2\\n            return abs(x1 - x2) + abs(y1 - y2)\\n        \\n        @cache\\n        def dfs(i, j, k):\\n            if k == len(word): return 0\\n            letter = word[k]\\n            no_i, no_j, use_i, use_j = float(\\'inf\\'), float(\\'inf\\'), float(\\'inf\\'), float(\\'inf\\')\\n            \\n            if not i:\\n                no_i = dfs(letter, j, k + 1)\\n            if not j:\\n                no_j = dfs(i, letter, k + 1)\\n            \\n            # Use finger one\\n            if i:\\n                dist1 = calDistance(findCoord(i), findCoord(letter))\\n                use_i = dist1 + dfs(letter, j, k + 1)\\n            # Use finger two\\n            if j:\\n                dist2 = calDistance(findCoord(j), findCoord(letter))\\n                use_j = dist2 + dfs(i, letter, k + 1)\\n            return min(no_i, no_j, use_i, use_j)\\n        \\n        return dfs(None, None, 0)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        def findCoord(letter):\\n            code = ord(letter) - 65\\n            # Find row\\n            row = code // 6\\n            # Find col\\n            col = code % 6\\n            return [row, col]\\n        \\n        def calDistance(arr1, arr2):\\n            x1, y1 = arr1\\n            x2, y2 = arr2\\n            return abs(x1 - x2) + abs(y1 - y2)\\n        \\n        @cache\\n        def dfs(i, j, k):\\n            if k == len(word): return 0\\n            letter = word[k]\\n            no_i, no_j, use_i, use_j = float(\\'inf\\'), float(\\'inf\\'), float(\\'inf\\'), float(\\'inf\\')\\n            \\n            if not i:\\n                no_i = dfs(letter, j, k + 1)\\n            if not j:\\n                no_j = dfs(i, letter, k + 1)\\n            \\n            # Use finger one\\n            if i:\\n                dist1 = calDistance(findCoord(i), findCoord(letter))\\n                use_i = dist1 + dfs(letter, j, k + 1)\\n            # Use finger two\\n            if j:\\n                dist2 = calDistance(findCoord(j), findCoord(letter))\\n                use_j = dist2 + dfs(i, letter, k + 1)\\n            return min(no_i, no_j, use_i, use_j)\\n        \\n        return dfs(None, None, 0)",
                "codeTag": "Java"
            },
            {
                "id": 2652263,
                "title": "dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[300][26][26];\\n    int mod = 1e9 + 7;\\n    unordered_map<int,pair<int,int>> mp;\\n    int n;\\n    int rec(int idx,int f,int s,string& w){\\n        if(idx==n) return 0;\\n        if(dp[idx][f][s]!=-1) return dp[idx][f][s];\\n        int ans = INT_MAX;\\n        int op1 = abs(mp[s].first-mp[w[idx]-\\'A\\'].first)+abs(mp[s].second-mp[w[idx]-\\'A\\'].second);\\n        int op2 = abs(mp[f].first-mp[w[idx]-\\'A\\'].first)+abs(mp[f].second-mp[w[idx]-\\'A\\'].second);\\n        ans = min(op1+rec(idx+1,f,w[idx]-\\'A\\',w),op2+rec(idx+1,w[idx]-\\'A\\',s,w));\\n        return dp[idx][f][s] = ans;\\n    }\\n\\n    int minimumDistance(string word) {\\n        memset(dp,-1,sizeof(dp));\\n        n = word.length();\\n        for(int i=0;i<5;i++)\\n            for(int j=0;j<6;j++) mp[i*6+j] = {i,j};\\n        int ans = INT_MAX;\\n        for(int i=0;i<26;i++)\\n            for(int j=0;j<i;j++) ans = min(ans,rec(0,i,j,word));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[300][26][26];\\n    int mod = 1e9 + 7;\\n    unordered_map<int,pair<int,int>> mp;\\n    int n;\\n    int rec(int idx,int f,int s,string& w){\\n        if(idx==n) return 0;\\n        if(dp[idx][f][s]!=-1) return dp[idx][f][s];\\n        int ans = INT_MAX;\\n        int op1 = abs(mp[s].first-mp[w[idx]-\\'A\\'].first)+abs(mp[s].second-mp[w[idx]-\\'A\\'].second);\\n        int op2 = abs(mp[f].first-mp[w[idx]-\\'A\\'].first)+abs(mp[f].second-mp[w[idx]-\\'A\\'].second);\\n        ans = min(op1+rec(idx+1,f,w[idx]-\\'A\\',w),op2+rec(idx+1,w[idx]-\\'A\\',s,w));\\n        return dp[idx][f][s] = ans;\\n    }\\n\\n    int minimumDistance(string word) {\\n        memset(dp,-1,sizeof(dp));\\n        n = word.length();\\n        for(int i=0;i<5;i++)\\n            for(int j=0;j<6;j++) mp[i*6+j] = {i,j};\\n        int ans = INT_MAX;\\n        for(int i=0;i<26;i++)\\n            for(int j=0;j<i;j++) ans = min(ans,rec(0,i,j,word));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2638605,
                "title": "c-memoization-dp-commented",
                "content": "**PLEASE DO UPVOTE IF YOU LIKE THE SOLUTION**\\n```\\nint t[305][305] ; //  finger1 , finger2 ;\\n    int disFing(string& word ,  int f1 , int f2 , vector<vector<int>>&dis ){\\n        int id = max(f1 , f2) ;\\n        if(id >= word.size()){\\n            return 0 ;\\n        }\\n        if(t[f1][f2] != -1){\\n            return t[f1][f2] ;\\n        }\\n        int d1 = 0 , d2 = 0; // DISTANCE WHILE MOVING FING1 AND FING2 RESPTIVELY\\n        if(f1 == 0){ // NOT KEPT THIS FINGER ANYWHERE RIGHT NOW\\n            d1 = 0 ; \\n        }else if(f1 > 0){\\n            d1 = dis[word[f1-1]-\\'A\\'][word[id]-\\'A\\'] ;\\n        }\\n        if(f2 == 0){ // NOT KEPT THIS FINGER ANYWHERE RIGHT NOW\\n            d2 = 0 ;\\n        }else if(f2 > 0){\\n            d2 = dis[word[f2-1] - \\'A\\'][word[id] - \\'A\\'] ;\\n         }\\n        int ans = min(d1 + disFing(word ,  id+1 , f2 , dis) , d2 + disFing(word ,  f1 , id+1 , dis)) ;\\n        return t[f1][f2] = ans ;\\n    }\\n    int minimumDistance(string word) {\\n        int n = word.size() ;\\n        int val = 0 ;\\n        unordered_map<int,pair<int,int>> pos ;\\n        // CONSTRUCTING TABLE\\n        for(int i = 0 ; i<6 && val < 26; i++){\\n            for(int j = 0 ; j<6 && val < 26; j++){\\n                pos[val] = {i , j} ;\\n                val++ ;\\n            }\\n        }\\n        // STORING DISTANCE OF EACH ALPHABET FROM EACH OTHER\\n        vector<vector<int>>dis(26 , vector<int>(26 , 0)) ;\\n        for(int i = 0 ; i<26 ; i++){\\n            for(int j = 0 ; j<26 ; j++){\\n                int curr = abs(pos[i].first - pos[j].first) + abs(pos[j].second - pos[i].second) ;\\n                dis[i][j] = curr ;\\n            }\\n        }\\n        memset(t , -1 , sizeof(t)) ;\\n        //vector<vector<int>>t(n+1 , vector<int>(n+1 , -1)) ;  NOT PASSING WHILE USING THIS GIVING TLE\\n        int ans = disFing(word ,  0 , 0 , dis ) ;\\n        return ans ;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nint t[305][305] ; //  finger1 , finger2 ;\\n    int disFing(string& word ,  int f1 , int f2 , vector<vector<int>>&dis ){\\n        int id = max(f1 , f2) ;\\n        if(id >= word.size()){\\n            return 0 ;\\n        }\\n        if(t[f1][f2] != -1){\\n            return t[f1][f2] ;\\n        }\\n        int d1 = 0 , d2 = 0; // DISTANCE WHILE MOVING FING1 AND FING2 RESPTIVELY\\n        if(f1 == 0){ // NOT KEPT THIS FINGER ANYWHERE RIGHT NOW\\n            d1 = 0 ; \\n        }else if(f1 > 0){\\n            d1 = dis[word[f1-1]-\\'A\\'][word[id]-\\'A\\'] ;\\n        }\\n        if(f2 == 0){ // NOT KEPT THIS FINGER ANYWHERE RIGHT NOW\\n            d2 = 0 ;\\n        }else if(f2 > 0){\\n            d2 = dis[word[f2-1] - \\'A\\'][word[id] - \\'A\\'] ;\\n         }\\n        int ans = min(d1 + disFing(word ,  id+1 , f2 , dis) , d2 + disFing(word ,  f1 , id+1 , dis)) ;\\n        return t[f1][f2] = ans ;\\n    }\\n    int minimumDistance(string word) {\\n        int n = word.size() ;\\n        int val = 0 ;\\n        unordered_map<int,pair<int,int>> pos ;\\n        // CONSTRUCTING TABLE\\n        for(int i = 0 ; i<6 && val < 26; i++){\\n            for(int j = 0 ; j<6 && val < 26; j++){\\n                pos[val] = {i , j} ;\\n                val++ ;\\n            }\\n        }\\n        // STORING DISTANCE OF EACH ALPHABET FROM EACH OTHER\\n        vector<vector<int>>dis(26 , vector<int>(26 , 0)) ;\\n        for(int i = 0 ; i<26 ; i++){\\n            for(int j = 0 ; j<26 ; j++){\\n                int curr = abs(pos[i].first - pos[j].first) + abs(pos[j].second - pos[i].second) ;\\n                dis[i][j] = curr ;\\n            }\\n        }\\n        memset(t , -1 , sizeof(t)) ;\\n        //vector<vector<int>>t(n+1 , vector<int>(n+1 , -1)) ;  NOT PASSING WHILE USING THIS GIVING TLE\\n        int ans = disFing(word ,  0 , 0 , dis ) ;\\n        return ans ;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2636366,
                "title": "python-solution-dp-similar-to-piano-and-guitar-playing",
                "content": "```\\nclass Solution:\\n    # DP problem, similar to piano and guitar playing\\n    # dp(i,j,k) = minimum total distance I have to do until I reach at my finger 1 is at i, finger 2 is at j, and I have to type the word[k] next\\n    # n = len(word), dp(i, j, n) = 0\\n    # we want to find dp(-1,-1,0) \\n    \\n    def finger_position(self, i):\\n        return [i // 6, i % 6]\\n    \\n    def manhattan(self, position0, position1):\\n        x0, y0 = position0\\n        x1, y1 = position1\\n        return abs(x0 - x1) + abs(y0 - y1)\\n    \\n    @lru_cache(None)\\n    def dp(self, i, j, k):\\n        if k == len(self.word):\\n            return 0\\n        new_letter_index = ord(self.word[k]) - ord(\\'A\\')\\n        new_letter_position = self.finger_position(new_letter_index)\\n        finger_1_position, finger_2_position = self.finger_position(i), self.finger_position(j)\\n        distance = []\\n        if i == -1:\\n            distance.append(0)\\n        else:\\n            distance.append(self.manhattan(finger_1_position, new_letter_position))\\n        if j == -1:\\n            distance.append(0)\\n        else:\\n            distance.append(self.manhattan(finger_2_position, new_letter_position))\\n        return min(distance[0] + self.dp(new_letter_index, j, k+1), distance[1] + self.dp(i, new_letter_index, k+1))\\n          \\n    def minimumDistance(self, word: str) -> int:\\n        self.word = word\\n        return self.dp(-1,-1,0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # DP problem, similar to piano and guitar playing\\n    # dp(i,j,k) = minimum total distance I have to do until I reach at my finger 1 is at i, finger 2 is at j, and I have to type the word[k] next\\n    # n = len(word), dp(i, j, n) = 0\\n    # we want to find dp(-1,-1,0) \\n    \\n    def finger_position(self, i):\\n        return [i // 6, i % 6]\\n    \\n    def manhattan(self, position0, position1):\\n        x0, y0 = position0\\n        x1, y1 = position1\\n        return abs(x0 - x1) + abs(y0 - y1)\\n    \\n    @lru_cache(None)\\n    def dp(self, i, j, k):\\n        if k == len(self.word):\\n            return 0\\n        new_letter_index = ord(self.word[k]) - ord(\\'A\\')\\n        new_letter_position = self.finger_position(new_letter_index)\\n        finger_1_position, finger_2_position = self.finger_position(i), self.finger_position(j)\\n        distance = []\\n        if i == -1:\\n            distance.append(0)\\n        else:\\n            distance.append(self.manhattan(finger_1_position, new_letter_position))\\n        if j == -1:\\n            distance.append(0)\\n        else:\\n            distance.append(self.manhattan(finger_2_position, new_letter_position))\\n        return min(distance[0] + self.dp(new_letter_index, j, k+1), distance[1] + self.dp(i, new_letter_index, k+1))\\n          \\n    def minimumDistance(self, word: str) -> int:\\n        self.word = word\\n        return self.dp(-1,-1,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2582550,
                "title": "python-dfs-memoization-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        \\n        def get_coordinate(c):\\n            return divmod(ord(c) - ord(\\'A\\'), 6)\\n            \\n        def get_dist(p1, p2):\\n            r1, c1 = get_coordinate(p1)\\n            r2, c2 = get_coordinate(p2)\\n            return abs(r1 - r2) + abs(c1 - c2)\\n        \\n        \\n        @functools.lru_cache(None)\\n        def dfs(pre_i, pre_j):\\n            cur = max(pre_i, pre_j) + 1\\n            if cur == len(word):\\n                return 0\\n            \\n            # press word[cur] using finger i\\n            finger_i = dfs(cur, pre_j) + (get_dist(word[pre_i], word[cur]) if pre_i >= 0 else 0)   \\n            \\n            # press word[cur] using finger j\\n            finger_j = dfs(pre_i, cur) + (get_dist(word[pre_j], word[cur]) if pre_j >= 0 else 0)\\n            \\n            return min(finger_i, finger_j)\\n            \\n        \\n        return dfs(-1, -1)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        \\n        def get_coordinate(c):\\n            return divmod(ord(c) - ord(\\'A\\'), 6)\\n            \\n        def get_dist(p1, p2):\\n            r1, c1 = get_coordinate(p1)\\n            r2, c2 = get_coordinate(p2)\\n            return abs(r1 - r2) + abs(c1 - c2)\\n        \\n        \\n        @functools.lru_cache(None)\\n        def dfs(pre_i, pre_j):\\n            cur = max(pre_i, pre_j) + 1\\n            if cur == len(word):\\n                return 0\\n            \\n            # press word[cur] using finger i\\n            finger_i = dfs(cur, pre_j) + (get_dist(word[pre_i], word[cur]) if pre_i >= 0 else 0)   \\n            \\n            # press word[cur] using finger j\\n            finger_j = dfs(pre_i, cur) + (get_dist(word[pre_j], word[cur]) if pre_j >= 0 else 0)\\n            \\n            return min(finger_i, finger_j)\\n            \\n        \\n        return dfs(-1, -1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2551096,
                "title": "go-fun-dp",
                "content": "```\\nfunc minimumDistance(s string) int {\\n\\tmem := [7][7][7][7][300]int{}\\n\\tfor i := 0; i <= 6; i++ {\\n\\t\\tfor i2 := 0; i2 <= 6; i2++ {\\n\\t\\t\\tfor i3 := 0; i3 <= 6; i3++ {\\n\\t\\t\\t\\tfor i4 := 0; i4 <= 6; i4++ {\\n\\t\\t\\t\\t\\tfor i5 := 0; i5 < 300; i5++ {\\n\\t\\t\\t\\t\\t\\tmem[i][i2][i3][i4][i5] = -1\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tvar pos = func(b byte) [2]int {\\n\\t\\tb -= 65\\n\\t\\treturn [2]int{int(b / 6), int(b % 6)}\\n\\t}\\n\\tvar abs = func(a int) int {\\n\\t\\tif a < 0 {\\n\\t\\t\\treturn -a\\n\\t\\t}\\n\\t\\treturn a\\n\\t}\\n\\tvar dd = func(f1, f2 [2]int) int {\\n\\t\\treturn abs(f1[0]-f2[0]) + abs(f1[1]-f2[1])\\n\\t}\\n\\tvar dp func(f1, f2 [2]int, i int) int\\n\\tdp = func(f1, f2 [2]int, i int) int {\\n\\t\\tif i >= len(s) {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\n\\t\\tif mem[f1[0]][f1[1]][f2[0]][f2[1]][i] != -1 {\\n\\t\\t\\treturn mem[f1[0]][f1[1]][f2[0]][f2[1]][i]\\n\\t\\t}\\n\\t\\tmem[f1[0]][f1[1]][f2[0]][f2[1]][i] = 10000\\n\\t\\tvar p = pos(s[i])\\n\\t\\tif f1[0] == 6 {\\n\\t\\t\\tv := dp(p, f2, i+1)\\n\\t\\t\\tif v < mem[f1[0]][f1[1]][f2[0]][f2[1]][i] {\\n\\t\\t\\t\\tmem[f1[0]][f1[1]][f2[0]][f2[1]][i] = v\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tv := dd(p, f1) + dp(p, f2, i+1)\\n\\t\\t\\tif v < mem[f1[0]][f1[1]][f2[0]][f2[1]][i] {\\n\\t\\t\\t\\tmem[f1[0]][f1[1]][f2[0]][f2[1]][i] = v\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif f2[0] == 6 {\\n\\t\\t\\tv := dp(f1, p, i+1)\\n\\t\\t\\tif v < mem[f1[0]][f1[1]][f2[0]][f2[1]][i] {\\n\\t\\t\\t\\tmem[f1[0]][f1[1]][f2[0]][f2[1]][i] = v\\n\\t\\t\\t}\\n\\n\\t\\t} else {\\n\\t\\t\\tv := dd(p, f2) + dp(f1, p, i+1)\\n\\t\\t\\tif v < mem[f1[0]][f1[1]][f2[0]][f2[1]][i] {\\n\\t\\t\\t\\tmem[f1[0]][f1[1]][f2[0]][f2[1]][i] = v\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn mem[f1[0]][f1[1]][f2[0]][f2[1]][i]\\n\\t}\\n\\treturn dp([2]int{6, 6}, [2]int{6, 6}, 0)\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfunc minimumDistance(s string) int {\\n\\tmem := [7][7][7][7][300]int{}\\n\\tfor i := 0; i <= 6; i++ {\\n\\t\\tfor i2 := 0; i2 <= 6; i2++ {\\n\\t\\t\\tfor i3 := 0; i3 <= 6; i3++ {\\n\\t\\t\\t\\tfor i4 := 0; i4 <= 6; i4++ {\\n\\t\\t\\t\\t\\tfor i5 := 0; i5 < 300; i5++ {\\n\\t\\t\\t\\t\\t\\tmem[i][i2][i3][i4][i5] = -1\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tvar pos = func(b byte) [2]int {\\n\\t\\tb -= 65\\n\\t\\treturn [2]int{int(b / 6), int(b % 6)}\\n\\t}\\n\\tvar abs = func(a int) int {\\n\\t\\tif a < 0 {\\n\\t\\t\\treturn -a\\n\\t\\t}\\n\\t\\treturn a\\n\\t}\\n\\tvar dd = func(f1, f2 [2]int) int {\\n\\t\\treturn abs(f1[0]-f2[0]) + abs(f1[1]-f2[1])\\n\\t}\\n\\tvar dp func(f1, f2 [2]int, i int) int\\n\\tdp = func(f1, f2 [2]int, i int) int {\\n\\t\\tif i >= len(s) {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\n\\t\\tif mem[f1[0]][f1[1]][f2[0]][f2[1]][i] != -1 {\\n\\t\\t\\treturn mem[f1[0]][f1[1]][f2[0]][f2[1]][i]\\n\\t\\t}\\n\\t\\tmem[f1[0]][f1[1]][f2[0]][f2[1]][i] = 10000\\n\\t\\tvar p = pos(s[i])\\n\\t\\tif f1[0] == 6 {\\n\\t\\t\\tv := dp(p, f2, i+1)\\n\\t\\t\\tif v < mem[f1[0]][f1[1]][f2[0]][f2[1]][i] {\\n\\t\\t\\t\\tmem[f1[0]][f1[1]][f2[0]][f2[1]][i] = v\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tv := dd(p, f1) + dp(p, f2, i+1)\\n\\t\\t\\tif v < mem[f1[0]][f1[1]][f2[0]][f2[1]][i] {\\n\\t\\t\\t\\tmem[f1[0]][f1[1]][f2[0]][f2[1]][i] = v\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif f2[0] == 6 {\\n\\t\\t\\tv := dp(f1, p, i+1)\\n\\t\\t\\tif v < mem[f1[0]][f1[1]][f2[0]][f2[1]][i] {\\n\\t\\t\\t\\tmem[f1[0]][f1[1]][f2[0]][f2[1]][i] = v\\n\\t\\t\\t}\\n\\n\\t\\t} else {\\n\\t\\t\\tv := dd(p, f2) + dp(f1, p, i+1)\\n\\t\\t\\tif v < mem[f1[0]][f1[1]][f2[0]][f2[1]][i] {\\n\\t\\t\\t\\tmem[f1[0]][f1[1]][f2[0]][f2[1]][i] = v\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn mem[f1[0]][f1[1]][f2[0]][f2[1]][i]\\n\\t}\\n\\treturn dp([2]int{6, 6}, [2]int{6, 6}, 0)\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2514504,
                "title": "c-clean-and-simple-dp",
                "content": "We will have dp[i][j][k] denote the minimium amount of distance needed to type the first i letters of the word with finger one at letter j and finger two at letter k. Total time complexity O(n*26^2).\\n\\n```\\nclass Solution {\\npublic:\\n    int dis(int a, int b) {\\n        return abs(a/6 - b/6) + abs(a%6-b%6);\\n    }\\n    \\n    int dp[305][26][26];\\n    int minimumDistance(string word) {\\n        memset(dp, 0x3f, sizeof(dp));\\n        for(int i = 0; i < 26; i++)\\n            for(int j = 0; j < 26; j++)\\n                dp[0][i][j] = 0;\\n        for(int i = 1; i <= word.size(); i++) {\\n            for(int j = 0; j < 26; j++) {\\n                for(int k = 0; k < 26; k++) {\\n                    dp[i][word[i-1]-\\'A\\'][k] = \\n                        min(dp[i][word[i-1]-\\'A\\'][k], dp[i-1][j][k]+dis(j, word[i-1]-\\'A\\'));\\n                    dp[i][j][word[i-1]-\\'A\\'] = \\n                        min(dp[i][j][word[i-1]-\\'A\\'], dp[i-1][j][k]+dis(k, word[i-1]-\\'A\\'));\\n                }\\n            }\\n        }\\n        int ans = INT_MAX;\\n        for(int i = 0; i < 26; i++)\\n            for(int j = 0; j < 26; j++)\\n                ans = min(ans, dp[word.size()][i][j]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dis(int a, int b) {\\n        return abs(a/6 - b/6) + abs(a%6-b%6);\\n    }\\n    \\n    int dp[305][26][26];\\n    int minimumDistance(string word) {\\n        memset(dp, 0x3f, sizeof(dp));\\n        for(int i = 0; i < 26; i++)\\n            for(int j = 0; j < 26; j++)\\n                dp[0][i][j] = 0;\\n        for(int i = 1; i <= word.size(); i++) {\\n            for(int j = 0; j < 26; j++) {\\n                for(int k = 0; k < 26; k++) {\\n                    dp[i][word[i-1]-\\'A\\'][k] = \\n                        min(dp[i][word[i-1]-\\'A\\'][k], dp[i-1][j][k]+dis(j, word[i-1]-\\'A\\'));\\n                    dp[i][j][word[i-1]-\\'A\\'] = \\n                        min(dp[i][j][word[i-1]-\\'A\\'], dp[i-1][j][k]+dis(k, word[i-1]-\\'A\\'));\\n                }\\n            }\\n        }\\n        int ans = INT_MAX;\\n        for(int i = 0; i < 26; i++)\\n            for(int j = 0; j < 26; j++)\\n                ans = min(ans, dp[word.size()][i][j]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458731,
                "title": "o-n-time-o-1-space",
                "content": "```\\n///calculate maximum distance with only one finger - dist\\n///calculate maximum distances that can be saved using another left finger - save\\n///return dist-save\\n\\nclass Solution {\\n    public:\\n    int minimumDistance(string word) {\\n        vector<int> dp(26);\\n        int dist=0,save=0;\\n        \\n        for(int i=0;i<word.size()-1;i++){\\n            int right=word[i]-\\'A\\',next=word[i+1]-\\'A\\';\\n            for(int left=0;left<26;left++){\\n\\t\\t\\t\\t// checking maximum dist that can be saved if we travel from left to next instead of right to next\\n                dp[right]=max(dp[right],dp[left]+d(right,next)-d(left,next));\\n            }\\n            save = max(save,dp[right]);\\n            dist+=d(right,next);\\n        }\\n        return dist-save;\\n    }\\n                              \\n    int d(int a, int b) {\\n        return abs(a / 6 - b / 6) + abs(a % 6 - b % 6);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n///calculate maximum distance with only one finger - dist\\n///calculate maximum distances that can be saved using another left finger - save\\n///return dist-save\\n\\nclass Solution {\\n    public:\\n    int minimumDistance(string word) {\\n        vector<int> dp(26);\\n        int dist=0,save=0;\\n        \\n        for(int i=0;i<word.size()-1;i++){\\n            int right=word[i]-\\'A\\',next=word[i+1]-\\'A\\';\\n            for(int left=0;left<26;left++){\\n\\t\\t\\t\\t// checking maximum dist that can be saved if we travel from left to next instead of right to next\\n                dp[right]=max(dp[right],dp[left]+d(right,next)-d(left,next));\\n            }\\n            save = max(save,dp[right]);\\n            dist+=d(right,next);\\n        }\\n        return dist-save;\\n    }\\n                              \\n    int d(int a, int b) {\\n        return abs(a / 6 - b / 6) + abs(a % 6 - b % 6);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2379896,
                "title": "python3-dp-super-simple-to-understand",
                "content": "```\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        dct={}\\n        for i,el in enumerate(string.ascii_uppercase):\\n            dct[el]=(i//6,i%6)\\n        \\n        @lru_cache(None)\\n        def helper(idx,prev1,prev2):\\n            if idx==len(word): return 0\\n            targetX,targetY=dct[word[idx]]\\n            x1,y1=prev1 if prev1 else (targetX,targetY)\\n            x2,y2=prev2 if prev2 else (targetX,targetY)\\n            dist1=abs(targetX-x1)+abs(targetY-y1)\\n            dist2=abs(targetX-x2)+abs(targetY-y2)\\n            val1=dist1+helper(idx+1,(targetX,targetY),prev2)\\n            val2=dist2+helper(idx+1,prev1,(targetX,targetY))\\n            return min(val1,val2)\\n        \\n        return helper(0,None,None)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        dct={}\\n        for i,el in enumerate(string.ascii_uppercase):\\n            dct[el]=(i//6,i%6)\\n        \\n        @lru_cache(None)\\n        def helper(idx,prev1,prev2):\\n            if idx==len(word): return 0\\n            targetX,targetY=dct[word[idx]]\\n            x1,y1=prev1 if prev1 else (targetX,targetY)\\n            x2,y2=prev2 if prev2 else (targetX,targetY)\\n            dist1=abs(targetX-x1)+abs(targetY-y1)\\n            dist2=abs(targetX-x2)+abs(targetY-y2)\\n            val1=dist1+helper(idx+1,(targetX,targetY),prev2)\\n            val2=dist2+helper(idx+1,prev1,(targetX,targetY))\\n            return min(val1,val2)\\n        \\n        return helper(0,None,None)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2370555,
                "title": "python-clean-dp",
                "content": "Our state will be the position of two fingers and index we are currently typing, if the position of a finger is [-1,-1] we assume that the we haven\\'t used that fingers yet hence the cost will be 0.\\n\\n```\\ndef getPos(char):\\n    num = ord(char)-ord(\\'A\\')\\n    r = int(num/6)\\n    c = num%6\\n    return r,c\\n\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        \\n        @lru_cache(None)\\n        def getCost(ax,ay,bx,by,i):\\n            if i==len(word):\\n                return 0\\n            x,y = getPos(word[i])\\n            #use first finger\\n            curCost = 0\\n            if ax!=-1:\\n                curCost = abs(ax-x)+abs(ay-y)\\n            cost = getCost(x,y,bx,by,i+1)+curCost\\n            \\n            #use second finger\\n            curCost = 0\\n            if bx!=-1:\\n                curCost = abs(bx-x)+abs(by-y)\\n            cost = min(cost,getCost(ax,ay,x,y,i+1)+curCost)\\n            return cost\\n        \\n        return getCost(-1,-1,-1,-1,0)\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\ndef getPos(char):\\n    num = ord(char)-ord(\\'A\\')\\n    r = int(num/6)\\n    c = num%6\\n    return r,c\\n\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        \\n        @lru_cache(None)\\n        def getCost(ax,ay,bx,by,i):\\n            if i==len(word):\\n                return 0\\n            x,y = getPos(word[i])\\n            #use first finger\\n            curCost = 0\\n            if ax!=-1:\\n                curCost = abs(ax-x)+abs(ay-y)\\n            cost = getCost(x,y,bx,by,i+1)+curCost\\n            \\n            #use second finger\\n            curCost = 0\\n            if bx!=-1:\\n                curCost = abs(bx-x)+abs(by-y)\\n            cost = min(cost,getCost(ax,ay,x,y,i+1)+curCost)\\n            return cost\\n        \\n        return getCost(-1,-1,-1,-1,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2296697,
                "title": "c-top-dp-memorization",
                "content": "```\\nclass Solution {\\npublic:\\n    string alpha = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\\n    unordered_map<char, pair<int, int>> m;\\n    int distCalc(char a, char b) {\\n        pair<int, int> p_a = m[a];\\n        pair<int, int> p_b = m[b];\\n        \\n        int x_diff = abs(p_a.first - p_b.first);\\n        int y_diff = abs(p_a.second - p_b.second);\\n        \\n        return x_diff + y_diff;\\n    }\\n    int dp[301][27][27];\\n    int minDist(string word, int i, char finger1_char, char finger2_char) {\\n        if(i == word.size()) return 0;\\n       \\n        if(dp[i][finger1_char - \\'A\\'][finger2_char - \\'A\\'] != -1) return dp[i][finger1_char - \\'A\\'][finger2_char - \\'A\\'];\\n        \\n        //finger1\\n        int op1 =  (finger1_char == \\'[\\' ? 0 : distCalc(finger1_char, word[i])) + minDist(word, i + 1, word[i], finger2_char);\\n        \\n        //finger2\\n        int op2 =  (finger2_char == \\'[\\' ? 0 : distCalc(finger2_char, word[i])) + minDist(word, i + 1, finger1_char, word[i]);\\n        \\n        return dp[i][finger1_char - \\'A\\'][finger2_char - \\'A\\'] = min(op1, op2);\\n    }\\n    int minimumDistance(string word) {\\n        //each letter has choice to be clicked by finger 1 or 2\\n        \\n        int row = -1;\\n        for(int i = 0; i < alpha.length(); i++) {\\n            int col = i % 6;\\n            if(col == 0) row++;\\n            m[alpha[i]] = {row, col};\\n        }\\n         memset(dp, -1, sizeof(dp));\\n         return minDist(word, 0, \\'[\\', \\'[\\');\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alpha = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\\n    unordered_map<char, pair<int, int>> m;\\n    int distCalc(char a, char b) {\\n        pair<int, int> p_a = m[a];\\n        pair<int, int> p_b = m[b];\\n        \\n        int x_diff = abs(p_a.first - p_b.first);\\n        int y_diff = abs(p_a.second - p_b.second);\\n        \\n        return x_diff + y_diff;\\n    }\\n    int dp[301][27][27];\\n    int minDist(string word, int i, char finger1_char, char finger2_char) {\\n        if(i == word.size()) return 0;\\n       \\n        if(dp[i][finger1_char - \\'A\\'][finger2_char - \\'A\\'] != -1) return dp[i][finger1_char - \\'A\\'][finger2_char - \\'A\\'];\\n        \\n        //finger1\\n        int op1 =  (finger1_char == \\'[\\' ? 0 : distCalc(finger1_char, word[i])) + minDist(word, i + 1, word[i], finger2_char);\\n        \\n        //finger2\\n        int op2 =  (finger2_char == \\'[\\' ? 0 : distCalc(finger2_char, word[i])) + minDist(word, i + 1, finger1_char, word[i]);\\n        \\n        return dp[i][finger1_char - \\'A\\'][finger2_char - \\'A\\'] = min(op1, op2);\\n    }\\n    int minimumDistance(string word) {\\n        //each letter has choice to be clicked by finger 1 or 2\\n        \\n        int row = -1;\\n        for(int i = 0; i < alpha.length(); i++) {\\n            int col = i % 6;\\n            if(col == 0) row++;\\n            m[alpha[i]] = {row, col};\\n        }\\n         memset(dp, -1, sizeof(dp));\\n         return minDist(word, 0, \\'[\\', \\'[\\');\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2222703,
                "title": "sumplke-recursion-memoization",
                "content": "\\n// ind1 => first pencil previous position,ind2 => second pencil previous position ,  st1 => 0, if first pencil has started or not , st2 => 0 if second pencil has started or not, prev => 0 , if previous pencil is first pencil,1 => if previous pencil is second pencil\\n\\t\\n// and rest is simple flow of recursion\\n\\nclass Solution {\\npublic:\\n    \\n    map<char,pair<int,int>> mp;\\n    \\n    int dp[301][301][2][2][2];\\n    \\n\\t\\n\\t\\n\\t\\n    int fun(string s,int ind1,int ind2,int st1,int st2,int prev)\\n    {\\n        int n1 = s.length();\\n        \\n        if(ind1 == n1-1 || ind2 == n1-1)\\n        {\\n            return 0;\\n        }\\n        \\n        if(dp[ind1][ind2][st1][st2][prev] != -1)\\n        {\\n            return dp[ind1][ind2][st1][st2][prev];\\n        }\\n        \\n        int ans = 0;\\n        \\n         if(prev == 0)\\n         {\\n             pair<int,int> p1 = mp[s[ind1+1]];\\n             \\n             pair<int,int> p2 = mp[s[ind1]];\\n             \\n             pair<int,int> p3 = mp[s[ind2]];\\n             \\n             ans += min(abs(p1.first - p2.first) + abs(p1.second - p2.second) + fun(s,ind1+1,ind2,st1,st2,0), st2 == 0 ? fun(s,ind1,ind1+1,st1,1,1) : abs(p3.first - p1.first) + abs(p3.second - p1.second) + fun(s,ind1,ind1+1,st1,st2,1));\\n         }\\n         else\\n         {\\n              pair<int,int> p1 = mp[s[ind2+1]];\\n             \\n              pair<int,int> p2 = mp[s[ind1]];\\n             \\n              pair<int,int> p3 = mp[s[ind2]];\\n             \\n               ans += min(abs(p1.first - p3.first) + abs(p1.second - p3.second) + fun(s,ind1,ind2+1,st1,st2,1), st1 == 0 ? fun(s,ind2+1,ind2,1,st2,0) : abs(p2.first - p1.first) + abs(p2.second - p1.second) + fun(s,ind2+1,ind2,st1,st2,0));\\n             \\n             \\n         }\\n        \\n        return dp[ind1][ind2][st1][st2][prev] = ans;\\n            \\n        \\n    }\\n    \\n    int minimumDistance(string word) {\\n        \\n        int n = word.length();\\n        \\n        \\n        \\n        char ch = \\'A\\';\\n        \\n        for(int i = 0; i < 4; i++)\\n        {\\n            for(int j = 1; j <= 6; j++,ch++)\\n            {\\n                mp[ch] = {i,j-1};\\n                \\n                //cout<<ch<<\" \"<<i<<\" \"<<j-1<<endl;\\n            }\\n        }\\n        \\n        for(int i = 0; i < 300; i++)\\n        {\\n            for(int j = 0; j < 300; j++)\\n            {\\n                for(int k = 0; k < 2;k++)\\n                {\\n                    for(int l = 0; l < 2; l++)\\n                    {\\n                        for(int m = 0; m < 2; m++)\\n                        {\\n                            dp[i][j][k][l][m] = -1;\\n                        }\\n                        \\n                    }\\n                }\\n            }\\n        }\\n        \\n        mp[\\'Y\\'] = {4,0};\\n        \\n        mp[\\'Z\\'] = {4,1};\\n        \\n        int a1 = fun(word,0,0,1,0,0);\\n        \\n        return a1;\\n    }\\n};",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    map<char,pair<int,int>> mp;\\n    \\n    int dp[301][301][2][2][2];\\n    \\n\\t\\n\\t\\n\\t\\n    int fun(string s,int ind1,int ind2,int st1,int st2,int prev)\\n    {\\n        int n1 = s.length();\\n        \\n        if(ind1 == n1-1 || ind2 == n1-1)\\n        {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2196343,
                "title": "c-solution-based-on-recursion-and-memorization",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> records;\\n    int minimumDistance(string word) {\\n        \\n        int m = 5, n = 6;\\n        vector<vector<char>> grid = {\\n            {\\'A\\', \\'B\\', \\'C\\', \\'D\\', \\'E\\', \\'F\\'}, \\n            {\\'G\\', \\'H\\', \\'I\\', \\'J\\', \\'K\\', \\'L\\'}, \\n            {\\'M\\', \\'N\\', \\'O\\', \\'P\\', \\'Q\\', \\'R\\'}, \\n            {\\'S\\', \\'T\\', \\'U\\', \\'V\\', \\'W\\', \\'X\\'}, \\n            {\\'Y\\', \\'Z\\', \\'*\\', \\'*\\', \\'*\\', \\'*\\'}};\\n        vector<pair<int, int>> letter_pos(26);\\n        for (int y = 0; y < m; y++){\\n            for (int x = 0; x < n; x++){\\n                if (grid[y][x] != \\'*\\'){\\n                    char letter = grid[y][x] - \\'A\\';\\n                    // letter to coordinate: [y][x]\\n                    letter_pos[letter] = {y, x};\\n                }\\n            }\\n        }\\n        int sz = word.size();\\n        this->records = vector<vector<int>> (sz, vector<int>(sz + 1, -1));\\n        return helper(letter_pos, word, (int)word.size(), 0, -1);\\n    }\\n    \\n    int calculate_distance(vector<pair<int, int>>& letter_pos, char a, char b){// calculate the move from a to b\\n            \\n        int letter_a = a - \\'A\\', letter_b = b - \\'A\\';\\n        int dy = abs(letter_pos[letter_a].first - letter_pos[letter_b].first);\\n        int dx = abs(letter_pos[letter_a].second - letter_pos[letter_b].second);\\n        return dy + dx;\\n    }\\n    \\n    /*\\n        subproblem function, initially we call:\\n        helper(letter_pos, word, n, 0, -1);\\n        \\n        p = 0 means: at begining, our first finger is at word[0], q is not used, so p = -1\\n    */\\n    long helper(vector<pair<int, int>>& letter_pos, string& word, int sz, int p, int q){\\n        \\n        /* r is the index of our aim at present */\\n        int r = max(p, q) + 1;\\n        \\n        if (r == sz){// if one of p and q achieve n, call an end\\n            if (q == -1){// we must use exactly two finger, q cannot be -1\\n                return INT_MAX;\\n            }\\n            return 0;\\n        }\\n        if (this->records[p][q + 1] != -1){\\n            return this->records[p][q + 1];\\n        }\\n        \\n        /*  regular case:\\n            now, r is our aim word[r]:\\n            we have three selections:\\n            1. p -> r\\n            2. q -> r*/\\n        /*\\n        1.p -> r\\n        */\\n        long sub, result = INT_MAX;\\n        long move_p = calculate_distance(letter_pos, word[p], word[r]);\\n        sub = move_p + helper(letter_pos, word, sz, r, q);\\n        result = min(result, sub);\\n        /*\\n        2. q -> r: \\n        */\\n        if (q == -1){// we can began to use q\\n            sub = helper(letter_pos, word, sz, p, r);\\n            result = min(result, sub);\\n        }\\n        else{\\n            long move_q = calculate_distance(letter_pos, word[q], word[r]);\\n            sub = move_q + helper(letter_pos, word, sz, p, r);\\n            result = min(result, sub);            \\n        }\\n        \\n        this->records[p][q + 1] = result;\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> records;\\n    int minimumDistance(string word) {\\n        \\n        int m = 5, n = 6;\\n        vector<vector<char>> grid = {\\n            {\\'A\\', \\'B\\', \\'C\\', \\'D\\', \\'E\\', \\'F\\'}, \\n            {\\'G\\', \\'H\\', \\'I\\', \\'J\\', \\'K\\', \\'L\\'}, \\n            {\\'M\\', \\'N\\', \\'O\\', \\'P\\', \\'Q\\', \\'R\\'}, \\n            {\\'S\\', \\'T\\', \\'U\\', \\'V\\', \\'W\\', \\'X\\'}, \\n            {\\'Y\\', \\'Z\\', \\'*\\', \\'*\\', \\'*\\', \\'*\\'}};\\n        vector<pair<int, int>> letter_pos(26);\\n        for (int y = 0; y < m; y++){\\n            for (int x = 0; x < n; x++){\\n                if (grid[y][x] != \\'*\\'){\\n                    char letter = grid[y][x] - \\'A\\';\\n                    // letter to coordinate: [y][x]\\n                    letter_pos[letter] = {y, x};\\n                }\\n            }\\n        }\\n        int sz = word.size();\\n        this->records = vector<vector<int>> (sz, vector<int>(sz + 1, -1));\\n        return helper(letter_pos, word, (int)word.size(), 0, -1);\\n    }\\n    \\n    int calculate_distance(vector<pair<int, int>>& letter_pos, char a, char b){// calculate the move from a to b\\n            \\n        int letter_a = a - \\'A\\', letter_b = b - \\'A\\';\\n        int dy = abs(letter_pos[letter_a].first - letter_pos[letter_b].first);\\n        int dx = abs(letter_pos[letter_a].second - letter_pos[letter_b].second);\\n        return dy + dx;\\n    }\\n    \\n    /*\\n        subproblem function, initially we call:\\n        helper(letter_pos, word, n, 0, -1);\\n        \\n        p = 0 means: at begining, our first finger is at word[0], q is not used, so p = -1\\n    */\\n    long helper(vector<pair<int, int>>& letter_pos, string& word, int sz, int p, int q){\\n        \\n        /* r is the index of our aim at present */\\n        int r = max(p, q) + 1;\\n        \\n        if (r == sz){// if one of p and q achieve n, call an end\\n            if (q == -1){// we must use exactly two finger, q cannot be -1\\n                return INT_MAX;\\n            }\\n            return 0;\\n        }\\n        if (this->records[p][q + 1] != -1){\\n            return this->records[p][q + 1];\\n        }\\n        \\n        /*  regular case:\\n            now, r is our aim word[r]:\\n            we have three selections:\\n            1. p -> r\\n            2. q -> r*/\\n        /*\\n        1.p -> r\\n        */\\n        long sub, result = INT_MAX;\\n        long move_p = calculate_distance(letter_pos, word[p], word[r]);\\n        sub = move_p + helper(letter_pos, word, sz, r, q);\\n        result = min(result, sub);\\n        /*\\n        2. q -> r: \\n        */\\n        if (q == -1){// we can began to use q\\n            sub = helper(letter_pos, word, sz, p, r);\\n            result = min(result, sub);\\n        }\\n        else{\\n            long move_q = calculate_distance(letter_pos, word[q], word[r]);\\n            sub = move_q + helper(letter_pos, word, sz, p, r);\\n            result = min(result, sub);            \\n        }\\n        \\n        this->records[p][q + 1] = result;\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2164828,
                "title": "python-top-down-dp",
                "content": "dfs(lhand, rhand, i): the minimum cost when the left finger is on lhand, the right finger is on rhand, and the current character to type is word[i]\\n```\\nfrom functools import cache\\nclass Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        alphabets = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\\n        COL = 6\\n        index = { c:(i//COL, i%COL) for i, c in enumerate(alphabets)}\\n        def dist(a, b):\\n            return abs(index[a][0] - index[b][0]) + abs(index[a][1] - index[b][1])\\n        @cache\\n        def dfs(lhand, rhand, i):\\n            if i == len(word): return 0\\n            res = float(\\'inf\\')\\n            res = min(res, dfs(word[i], rhand, i+1)) if lhand == -1 else min(res, dist(lhand, word[i])+dfs(word[i], rhand, i+1))\\n            res = min(res, dfs(lhand, word[i],i+1)) if rhand == -1 else min(res, dist(word[i], rhand) + dfs(lhand, word[i], i+1))\\n            return res\\n        return dfs(-1, -1, 0)",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def minimumDistance(self, word: str) -> int:\\n        alphabets = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\\n        COL = 6\\n        index = { c:(i//COL, i%COL) for i, c in enumerate(alphabets)}",
                "codeTag": "Java"
            },
            {
                "id": 2132340,
                "title": "c-hot-potato-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int dist(int i, int j) {\\n        return j == -1 ? 0 : abs(i%6 - j%6) + abs(i/6 - j/6);\\n    }\\n    int minimumDistance(string word) {\\n        vector<vector<vector<int>>> dp(27, vector<vector<int>>(27, vector<int>(word.size(), -1)));\\n        function<int(int, int, int)> dfs = [&](int pos, int f1, int f2) {\\n            if (pos == word.size())\\n                return 0;\\n            if (dp[f1+1][f2+1][pos] > -1)\\n                return dp[f1+1][f2+1][pos];\\n            auto move_f1 = dist(word[pos]-\\'A\\', f1), move_f2 = dist(word[pos]-\\'A\\', f2);\\n            dp[f1+1][f2+1][pos] = min(move_f1 + dfs(pos+1, word[pos]-\\'A\\', f2), move_f2 + dfs(pos+1, f1, word[pos]-\\'A\\'));\\n            return dp[f1+1][f2+1][pos];\\n        };\\n        return dfs(0, -1, -1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dist(int i, int j) {\\n        return j == -1 ? 0 : abs(i%6 - j%6) + abs(i/6 - j/6);\\n    }\\n    int minimumDistance(string word) {\\n        vector<vector<vector<int>>> dp(27, vector<vector<int>>(27, vector<int>(word.size(), -1)));\\n        function<int(int, int, int)> dfs = [&](int pos, int f1, int f2) {\\n            if (pos == word.size())\\n                return 0;\\n            if (dp[f1+1][f2+1][pos] > -1)\\n                return dp[f1+1][f2+1][pos];\\n            auto move_f1 = dist(word[pos]-\\'A\\', f1), move_f2 = dist(word[pos]-\\'A\\', f2);\\n            dp[f1+1][f2+1][pos] = min(move_f1 + dfs(pos+1, word[pos]-\\'A\\', f2), move_f2 + dfs(pos+1, f1, word[pos]-\\'A\\'));\\n            return dp[f1+1][f2+1][pos];\\n        };\\n        return dfs(0, -1, -1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2097741,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(string word, int index, pair<int, int>fing1, pair<int, int>fing2, vector<vector<vector<int>>>&dp){\\n        \\n        if(index<0) return 0;\\n        \\n        int prevx1 = fing1.first;\\n        int prevy1 = fing1.second;\\n        int prevx2 = fing2.first;\\n        int prevy2 = fing2.second;\\n        if(prevx1==-1 && prevy1==-1){\\n            prevx1=4;\\n            prevy1=2;\\n        }\\n        if(prevx2==-1 && prevy2==-1){\\n            prevx2=4;\\n            prevy2=2;\\n        }\\n        if(dp[index][prevx1*6+prevy1][prevx2*6+prevy2]!=-1)\\n            return dp[index][prevx1*6+prevy1][prevx2*6+prevy2];\\n        \\n        int tmp = word[index] - \\'A\\';\\n        int x = tmp/6;\\n        int y = tmp%6;\\n        \\n        int ans = INT_MAX;\\n        \\n        // fing1 used\\n        if(fing1.first == -1 && fing1.second == -1){\\n            ans = min(ans, solve(word, index-1, {x, y}, fing2, dp));\\n        }\\n        else{\\n            int dist = abs(fing1.first - x) + abs(fing1.second - y);\\n            ans = min(ans, solve(word, index-1, {x, y}, fing2, dp) + dist);\\n        }\\n        \\n        // fing2\\n        \\n        if(fing2.first == -1 && fing2.second == -1){\\n            ans = min(ans, solve(word, index-1, fing1, {x, y}, dp));\\n        }\\n        else{\\n            int dist = abs(fing2.first-x) + abs(fing2.second - y);\\n            ans = min(ans, solve(word, index-1, fing1, {x, y}, dp) + dist);\\n        }\\n        \\n        return dp[index][prevx1*6+prevy1][prevx2*6+prevy2] = ans;\\n    }\\n    int minimumDistance(string word) {\\n        int n = word.length();\\n        vector<vector<vector<int>>>dp(n, vector<vector<int>>(27, vector<int>(27, -1)));\\n        return solve(word, n-1, {-1, -1}, {-1, -1}, dp);\\n        \\n\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(string word, int index, pair<int, int>fing1, pair<int, int>fing2, vector<vector<vector<int>>>&dp){\\n        \\n        if(index<0) return 0;\\n        \\n        int prevx1 = fing1.first;\\n        int prevy1 = fing1.second;\\n        int prevx2 = fing2.first;\\n        int prevy2 = fing2.second;\\n        if(prevx1==-1 && prevy1==-1){\\n            prevx1=4;\\n            prevy1=2;\\n        }\\n        if(prevx2==-1 && prevy2==-1){\\n            prevx2=4;\\n            prevy2=2;\\n        }\\n        if(dp[index][prevx1*6+prevy1][prevx2*6+prevy2]!=-1)\\n            return dp[index][prevx1*6+prevy1][prevx2*6+prevy2];\\n        \\n        int tmp = word[index] - \\'A\\';\\n        int x = tmp/6;\\n        int y = tmp%6;\\n        \\n        int ans = INT_MAX;\\n        \\n        // fing1 used\\n        if(fing1.first == -1 && fing1.second == -1){\\n            ans = min(ans, solve(word, index-1, {x, y}, fing2, dp));\\n        }\\n        else{\\n            int dist = abs(fing1.first - x) + abs(fing1.second - y);\\n            ans = min(ans, solve(word, index-1, {x, y}, fing2, dp) + dist);\\n        }\\n        \\n        // fing2\\n        \\n        if(fing2.first == -1 && fing2.second == -1){\\n            ans = min(ans, solve(word, index-1, fing1, {x, y}, dp));\\n        }\\n        else{\\n            int dist = abs(fing2.first-x) + abs(fing2.second - y);\\n            ans = min(ans, solve(word, index-1, fing1, {x, y}, dp) + dist);\\n        }\\n        \\n        return dp[index][prevx1*6+prevy1][prevx2*6+prevy2] = ans;\\n    }\\n    int minimumDistance(string word) {\\n        int n = word.length();\\n        vector<vector<vector<int>>>dp(n, vector<vector<int>>(27, vector<int>(27, -1)));\\n        return solve(word, n-1, {-1, -1}, {-1, -1}, dp);\\n        \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083556,
                "title": "recursive-with-memorization-o-n-2-dp-a-little-tricky",
                "content": "```\\nconst int N=305;\\n\\nclass Solution {\\npublic:\\n    int n,dp[N][N];\\n    string s;\\n    map<char,pair<int,int>> mp;\\n    \\n    int dis(int i,int j)\\n    {\\n        char x=s[i],y=s[j];\\n        return abs(mp[x].first-mp[y].first)+abs(mp[x].second-mp[y].second);\\n    }\\n    \\n    int sol(int i,int j)\\n    {\\n        int cur=max(i,j)+1;\\n        if(cur==n) return 0;\\n        \\n        int ans=dp[i][j];\\n        if(ans!=-1) return ans;\\n        ans=1e9;\\n        \\n        ans=min(ans,dis(i,cur)+sol(cur,j));\\n        ans=min(ans,dis(cur,j)+sol(i,cur));\\n        \\n        return dp[i][j]=ans;\\n    }\\n    \\n    \\n    int minimumDistance(string ss) \\n    {\\n        s=ss;\\n        n=ss.length();\\n        for(int i=0;i<26;i++)\\n            mp[\\'A\\'+i]={i/6,i%6};\\n        memset(dp,-1,sizeof(dp));\\n        int ans=1e9,sum=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(i>1) sum+=dis(i-1,i-2);\\n            ans=min(ans,sum+sol(i-1,i));\\n        }\\n        return sol(0,1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nconst int N=305;\\n\\nclass Solution {\\npublic:\\n    int n,dp[N][N];\\n    string s;\\n    map<char,pair<int,int>> mp;\\n    \\n    int dis(int i,int j)\\n    {\\n        char x=s[i],y=s[j];\\n        return abs(mp[x].first-mp[y].first)+abs(mp[x].second-mp[y].second);\\n    }\\n    \\n    int sol(int i,int j)\\n    {\\n        int cur=max(i,j)+1;\\n        if(cur==n) return 0;\\n        \\n        int ans=dp[i][j];\\n        if(ans!=-1) return ans;\\n        ans=1e9;\\n        \\n        ans=min(ans,dis(i,cur)+sol(cur,j));\\n        ans=min(ans,dis(cur,j)+sol(i,cur));\\n        \\n        return dp[i][j]=ans;\\n    }\\n    \\n    \\n    int minimumDistance(string ss) \\n    {\\n        s=ss;\\n        n=ss.length();\\n        for(int i=0;i<26;i++)\\n            mp[\\'A\\'+i]={i/6,i%6};\\n        memset(dp,-1,sizeof(dp));\\n        int ans=1e9,sum=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(i>1) sum+=dis(i-1,i-2);\\n            ans=min(ans,sum+sol(i-1,i));\\n        }\\n        return sol(0,1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2080262,
                "title": "c-bottom-up-dp-approach",
                "content": "```\\n#define ll long long\\n#define vb vector<bool>\\n#define vi vector<int>\\n#define vl vector<long long>\\n#define vvb vector<vector<bool>>\\n#define vvi vector<vector<int>>\\n#define vvl vector<vector<long long>>\\n#define pii pair<int,int>\\n#define f(i,s,e) for(int i = s; i < e; i++)\\n#define b(i,s,e) for(int i = s; i >= e; i--)\\n\\nclass Solution {\\npublic:\\n    const int cols = 6, rows = 5;\\n\\n    int distance(int a, int b) {\\n        pii ac = {a/cols,a%cols}, bc = {b/cols,b%cols};\\n        return abs(ac.first-bc.first)+abs(ac.second-bc.second);\\n    }\\n    \\n    int minimumDistance(string word) {\\n        int dp[26][26][301], n = word.length();\\n        f(k,0,n+1) {\\n            f(i,0,26) {\\n                f(j,0,26) {\\n                    if(k == 0) dp[i][j][k] = 0;\\n                    else {\\n                        char first = word[n-k];\\n                        int idx = first-\\'A\\';\\n                        dp[i][j][k] = min(distance(i,idx)+dp[idx][j][k-1],distance(j,idx)+dp[i][idx][k-1]);\\n                    }\\n                }\\n            }\\n        }\\n\\n        int ans = INT32_MAX;\\n        f(i,0,26) {\\n            f(j,0,26) {\\n                ans = min(ans,dp[i][j][n]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n#define ll long long\\n#define vb vector<bool>\\n#define vi vector<int>\\n#define vl vector<long long>\\n#define vvb vector<vector<bool>>\\n#define vvi vector<vector<int>>\\n#define vvl vector<vector<long long>>\\n#define pii pair<int,int>\\n#define f(i,s,e) for(int i = s; i < e; i++)\\n#define b(i,s,e) for(int i = s; i >= e; i--)\\n\\nclass Solution {\\npublic:\\n    const int cols = 6, rows = 5;\\n\\n    int distance(int a, int b) {\\n        pii ac = {a/cols,a%cols}, bc = {b/cols,b%cols};\\n        return abs(ac.first-bc.first)+abs(ac.second-bc.second);\\n    }\\n    \\n    int minimumDistance(string word) {\\n        int dp[26][26][301], n = word.length();\\n        f(k,0,n+1) {\\n            f(i,0,26) {\\n                f(j,0,26) {\\n                    if(k == 0) dp[i][j][k] = 0;\\n                    else {\\n                        char first = word[n-k];\\n                        int idx = first-\\'A\\';\\n                        dp[i][j][k] = min(distance(i,idx)+dp[idx][j][k-1],distance(j,idx)+dp[i][idx][k-1]);\\n                    }\\n                }\\n            }\\n        }\\n\\n        int ans = INT32_MAX;\\n        f(i,0,26) {\\n            f(j,0,26) {\\n                ans = min(ans,dp[i][j][n]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2050951,
                "title": "c-memoization-solution",
                "content": "Subproblems: S(index,firstFingerChar,secondFingerChar)=The minimum distance covered to type s[index:] given that the first finger is on character *firstFingerChar* and the second finger is on *secondFingerChar*\\n\\nRelation: S(index,firstFingerChar,secondFingerChar)=min{dist(index,firstFingerChar)+S(index+1,s[index],secondFingerChar),\\ndist(index,secondFingerChar)+S(index+1,firstFingerChar,s[index])}\\n\\nBase case: S(index,f,s)=0 **if** index>=n\\n\\nOriginal: min{S(0,s[0],c) **for all** c **in** [A-Z]}\\n\\nTime: O(n^3)xO(1)=O(n^3)\\n```\\nclass Solution {\\nprivate:\\n    vector<vector<vector<int>>>mem;\\n    int distance(char a, char b) {\\n        int x1 = (a-\\'A\\') / 6, y1 = (a-\\'A\\') % 6;\\n        int x2 = (b-\\'A\\') / 6, y2 = (b-\\'A\\') % 6; \\n        return abs(x1-x2) + abs(y1-y2);\\n    }\\n    int solve(string &word,int index,char first,char second){\\n        int n=word.size();\\n        int firstPos=first-\\'A\\',secondPos=second-\\'A\\';\\n        if(index==n){\\n            return 0;\\n        } else if(mem[index][firstPos][secondPos]!=-1){\\n            return mem[index][firstPos][secondPos];\\n        } else {\\n            int ans1=distance(word[index],first)+solve(word,index+1,word[index],second);\\n            int ans2=distance(word[index],second)+solve(word,index+1,first,word[index]);\\n            return mem[index][firstPos][secondPos]=min(ans1,ans2);\\n        }\\n    }\\npublic:\\n    int minimumDistance(string word) {\\n        int n=word.size();\\n        mem=vector<vector<vector<int>>>(n,vector<vector<int>>(26,vector<int>(26,-1)));\\n        int ans=INT_MAX;\\n        for(char c=\\'A\\';c<=\\'Z\\';c++){\\n            ans=min(ans,solve(word,0,word[0],c));\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\nprivate:\\n    vector<vector<vector<int>>>mem;\\n    int distance(char a, char b) {\\n        int x1 = (a-\\'A\\') / 6, y1 = (a-\\'A\\') % 6;\\n        int x2 = (b-\\'A\\') / 6, y2 = (b-\\'A\\') % 6; \\n        return abs(x1-x2) + abs(y1-y2);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2045566,
                "title": "go-golang-clean-code",
                "content": "```\\ntype Finger struct {\\n    Left, Right int\\n}\\n\\nfunc minimumDistance(word string) int {\\n    dp := map[Finger]int{}\\n    \\n    dp[Finger{26,26}] = 1\\n    \\n    for _, c := range word {\\n        now := int(c-\\'A\\')\\n        \\n        nextDp := map[Finger]int{}\\n        \\n        for finger, distance := range dp {         \\n            newFinger := finger\\n            newFinger.Left = now\\n            \\n            update(nextDp, newFinger, distance + getDistance(finger.Left, now))\\n            \\n            newFinger = finger\\n            newFinger.Right = now\\n            \\n            update(nextDp, newFinger, distance + getDistance(finger.Right, now))\\n        }\\n        \\n        dp = nextDp\\n    }\\n    \\n    result := math.MaxInt32\\n    \\n    for _, distance := range dp {\\n        result = min(result, distance)\\n    }\\n    \\n    return result - 1\\n}\\n                       \\nfunc update(dp map[Finger]int, finger Finger, distance int) {\\n    if val, found := dp[finger]; found {\\n            dp[finger] = min(val, distance)\\n    } else {\\n        dp[finger] = distance\\n    }\\n}\\n\\nfunc getDistance(a, b int) int {\\n    if a == 26 || b == 26 {\\n        return 0\\n    }\\n    \\n    row := a/6 - b/6\\n    col := a%6 - b%6\\n      \\n    return abs(row)+abs(col)\\n}\\n\\nfunc min(i, j int) int {\\n    if i < j {\\n        return i\\n    }\\n    return j\\n}\\n\\nfunc abs(a int) int {\\n    if a < 0 {\\n        return -a\\n    }\\n    return a\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\ntype Finger struct {\\n    Left, Right int\\n}\\n\\nfunc minimumDistance(word string) int {\\n    dp := map[Finger]int{}\\n    \\n    dp[Finger{26,26}] = 1\\n    \\n    for _, c := range word {\\n        now := int(c-\\'A\\')\\n        \\n        nextDp := map[Finger]int{}\\n        \\n        for finger, distance := range dp {         \\n            newFinger := finger\\n            newFinger.Left = now\\n            \\n            update(nextDp, newFinger, distance + getDistance(finger.Left, now))\\n            \\n            newFinger = finger\\n            newFinger.Right = now\\n            \\n            update(nextDp, newFinger, distance + getDistance(finger.Right, now))\\n        }\\n        \\n        dp = nextDp\\n    }\\n    \\n    result := math.MaxInt32\\n    \\n    for _, distance := range dp {\\n        result = min(result, distance)\\n    }\\n    \\n    return result - 1\\n}\\n                       \\nfunc update(dp map[Finger]int, finger Finger, distance int) {\\n    if val, found := dp[finger]; found {\\n            dp[finger] = min(val, distance)\\n    } else {\\n        dp[finger] = distance\\n    }\\n}\\n\\nfunc getDistance(a, b int) int {\\n    if a == 26 || b == 26 {\\n        return 0\\n    }\\n    \\n    row := a/6 - b/6\\n    col := a%6 - b%6\\n      \\n    return abs(row)+abs(col)\\n}\\n\\nfunc min(i, j int) int {\\n    if i < j {\\n        return i\\n    }\\n    return j\\n}\\n\\nfunc abs(a int) int {\\n    if a < 0 {\\n        return -a\\n    }\\n    return a\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2004777,
                "title": "java-dp",
                "content": "```\\nclass Solution {\\n     Map<Character,Pair<Integer,Integer>> map = new HashMap<>();\\n    Map<String, Integer> dp = new HashMap<>();\\n    public int minimumDistance(String word) {\\n       \\n        char temp = \\'A\\';\\n        for(int i =0; i < 5; i++){\\n            for(int j =0; j < 6; j++){\\n               map.put(temp,new Pair<>(i,j));\\n               temp++; \\n            }\\n        }\\n        \\n        \\n        \\n        return helper(word,0,\\'@\\',\\'@\\');\\n        \\n    }\\n    \\n    public int helper(String word,int idx, Character fin1, Character fin2){\\n        if(idx >= word.length() ) return 0;\\n       \\n        if(dp.containsKey(idx+\"\"+fin1+\"\"+fin2)){\\n           return dp.get(idx+\"\"+fin1+\"\"+fin2);\\n        }\\n       int fig1 = dist(fin1,word.charAt(idx)) +\\n           helper(word,idx+1,word.charAt(idx),fin2);  \\n         \\n     int fig2 = dist(word.charAt(idx),fin2) +  \\n         helper(word,idx+1,fin1,word.charAt(idx));           \\n       int res = Math.min(fig1,fig2); \\n       dp.put((idx+\"\"+fin1+\"\"+fin2),res); \\n       return res;\\n    }\\n    \\n    public int dist(char a, char b){\\n        if(!map.containsKey(a) || !map.containsKey(b)) return 0; \\n        return Math.abs(map.get(a).getKey() - map.get(b).getKey()) + Math.abs(map.get(a).getValue() - map.get(b).getValue());\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n     Map<Character,Pair<Integer,Integer>> map = new HashMap<>();\\n    Map<String, Integer> dp = new HashMap<>();\\n    public int minimumDistance(String word) {\\n       \\n        char temp = \\'A\\';\\n        for(int i =0; i < 5; i++){\\n            for(int j =0; j < 6; j++){\\n               map.put(temp,new Pair<>(i,j));\\n               temp++; \\n            }\\n        }\\n        \\n        \\n        \\n        return helper(word,0,\\'@\\',\\'@\\');\\n        \\n    }\\n    \\n    public int helper(String word,int idx, Character fin1, Character fin2){\\n        if(idx >= word.length() ) return 0;\\n       \\n        if(dp.containsKey(idx+\"\"+fin1+\"\"+fin2)){\\n           return dp.get(idx+\"\"+fin1+\"\"+fin2);\\n        }\\n       int fig1 = dist(fin1,word.charAt(idx)) +\\n           helper(word,idx+1,word.charAt(idx),fin2);  \\n         \\n     int fig2 = dist(word.charAt(idx),fin2) +  \\n         helper(word,idx+1,fin1,word.charAt(idx));           \\n       int res = Math.min(fig1,fig2); \\n       dp.put((idx+\"\"+fin1+\"\"+fin2),res); \\n       return res;\\n    }\\n    \\n    public int dist(char a, char b){\\n        if(!map.containsKey(a) || !map.containsKey(b)) return 0; \\n        return Math.abs(map.get(a).getKey() - map.get(b).getKey()) + Math.abs(map.get(a).getValue() - map.get(b).getValue());\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1973902,
                "title": "c-3d-dp-recursion-memoization-simple-and-clean",
                "content": "Main idea for 3d dp is there is no need to track coordinates. Can get them on the fly from the Alphabet.\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[305][26][26];\\n    \\n    // Given a number [0-26], returns the coordinate of it in the keyboard.\\n    pair<int,int> GetCoord(int num) {\\n        return {num/6,num%6};\\n    }\\n    \\n    // Method to return distance between two coordinates.\\n    int GetPairDist(pair<int,int> p1, pair<int,int> p2) {\\n        return abs(p1.first - p2.first) + abs(p1.second - p2.second);\\n    }\\n    \\n    // Method to return distance between two numbers.\\n    int GetCharDist(int c1, int c2) {\\n        return GetPairDist(GetCoord(c1),  GetCoord(c2));\\n    }\\n    \\n    \\n    // Input is current index, character on which 1st finger is there, character on which 2nd finger is there\\n    int recurse(int i, int p1, int p2, string& word) {\\n        if(i == word.size()) {\\n            return 0;\\n        }\\n        \\n        if(dp[i][p1][p2] != -1) {\\n            return dp[i][p1][p2];\\n        }\\n        \\n        int nxt = word[i] - \\'A\\';\\n        \\n        // We need to go char in next index. Two possibilities either move 1st finger or 2nd finger.\\n        int ans1 = recurse(i+1, nxt,p2, word) + GetCharDist(p1, nxt);\\n        int ans2 = recurse(i+1, p1,nxt, word) + GetCharDist(p2, nxt);\\n        dp[i][p1][p2] = min(ans1, ans2);\\n        return min(ans1, ans2);\\n        \\n    }\\n    \\n    int minimumDistance(string word) {\\n        int n = word.length();       \\n        memset(dp, -1, sizeof(dp));\\n        int mini = INT_MAX;\\n        \\n        // Initially finger can be anywhere so trying all possible finger locations.\\n        for(int i=0;i<26;i++) {\\n            for(int j=0;j<26;j++) {\\n                mini = min(mini, recurse(0,i,j, word));\\n            }\\n        }\\n        \\n        \\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[305][26][26];\\n    \\n    // Given a number [0-26], returns the coordinate of it in the keyboard.\\n    pair<int,int> GetCoord(int num) {\\n        return {num/6,num%6};\\n    }\\n    \\n    // Method to return distance between two coordinates.\\n    int GetPairDist(pair<int,int> p1, pair<int,int> p2) {\\n        return abs(p1.first - p2.first) + abs(p1.second - p2.second);\\n    }\\n    \\n    // Method to return distance between two numbers.\\n    int GetCharDist(int c1, int c2) {\\n        return GetPairDist(GetCoord(c1),  GetCoord(c2));\\n    }\\n    \\n    \\n    // Input is current index, character on which 1st finger is there, character on which 2nd finger is there\\n    int recurse(int i, int p1, int p2, string& word) {\\n        if(i == word.size()) {\\n            return 0;\\n        }\\n        \\n        if(dp[i][p1][p2] != -1) {\\n            return dp[i][p1][p2];\\n        }\\n        \\n        int nxt = word[i] - \\'A\\';\\n        \\n        // We need to go char in next index. Two possibilities either move 1st finger or 2nd finger.\\n        int ans1 = recurse(i+1, nxt,p2, word) + GetCharDist(p1, nxt);\\n        int ans2 = recurse(i+1, p1,nxt, word) + GetCharDist(p2, nxt);\\n        dp[i][p1][p2] = min(ans1, ans2);\\n        return min(ans1, ans2);\\n        \\n    }\\n    \\n    int minimumDistance(string word) {\\n        int n = word.length();       \\n        memset(dp, -1, sizeof(dp));\\n        int mini = INT_MAX;\\n        \\n        // Initially finger can be anywhere so trying all possible finger locations.\\n        for(int i=0;i<26;i++) {\\n            for(int j=0;j<26;j++) {\\n                mini = min(mini, recurse(0,i,j, word));\\n            }\\n        }\\n        \\n        \\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566933,
                "content": [
                    {
                        "username": "shariqazz",
                        "content": "I\\'m trying to approach this as a Minimum Spanning Tree problem.\\n\\nThe test case \"TUGR\" has expected value 5 - but shouldnt the result be 4?\\nGo from U to T to G and then second finger on R. Thats a total of 1 + 3 + 0 = 4. Why is the expected 5?"
                    },
                    {
                        "username": "Weildcard",
                        "content": "If you go from U to T to G, you will get UTG, not TUG."
                    },
                    {
                        "username": "emli",
                        "content": "Why for case \"HAPPY\" answer is 6 ? \\n\\nMaybe I missed something. But I am getting 5\\n\\nFirst finger begins at A , second stays at Y\\n\\nFirst finger\\n\\nA->H\\nH->P\\nP->P\\n\\nSecond finger\\nY"
                    },
                    {
                        "username": "jumadaru",
                        "content": "You wrote AHPPY"
                    },
                    {
                        "username": "abhishek_sharma_yo",
                        "content": "Can someone please explain what this line actually mean?\\n\\n**also your two fingers do not have to start at the first letter or the first two letters**"
                    },
                    {
                        "username": "Weildcard",
                        "content": "It means you can type the first several letters with the same finger, and the second finger can start on a letter that comes, for example, fifth in the word or whatever.  The \"HAPPY\" example illustrates this."
                    },
                    {
                        "username": "KBJ_1412",
                        "content": "![image](https://assets.leetcode.com/users/images/fdf3a28e-65a4-426a-8de3-41c8ce6c7472_1592723749.0815127.png)\\n But the answer is 4 when T and R are where fingers placed \\n T R 4"
                    }
                ]
            },
            {
                "id": 1569738,
                "content": [
                    {
                        "username": "shariqazz",
                        "content": "I\\'m trying to approach this as a Minimum Spanning Tree problem.\\n\\nThe test case \"TUGR\" has expected value 5 - but shouldnt the result be 4?\\nGo from U to T to G and then second finger on R. Thats a total of 1 + 3 + 0 = 4. Why is the expected 5?"
                    },
                    {
                        "username": "Weildcard",
                        "content": "If you go from U to T to G, you will get UTG, not TUG."
                    },
                    {
                        "username": "emli",
                        "content": "Why for case \"HAPPY\" answer is 6 ? \\n\\nMaybe I missed something. But I am getting 5\\n\\nFirst finger begins at A , second stays at Y\\n\\nFirst finger\\n\\nA->H\\nH->P\\nP->P\\n\\nSecond finger\\nY"
                    },
                    {
                        "username": "jumadaru",
                        "content": "You wrote AHPPY"
                    },
                    {
                        "username": "abhishek_sharma_yo",
                        "content": "Can someone please explain what this line actually mean?\\n\\n**also your two fingers do not have to start at the first letter or the first two letters**"
                    },
                    {
                        "username": "Weildcard",
                        "content": "It means you can type the first several letters with the same finger, and the second finger can start on a letter that comes, for example, fifth in the word or whatever.  The \"HAPPY\" example illustrates this."
                    },
                    {
                        "username": "KBJ_1412",
                        "content": "![image](https://assets.leetcode.com/users/images/fdf3a28e-65a4-426a-8de3-41c8ce6c7472_1592723749.0815127.png)\\n But the answer is 4 when T and R are where fingers placed \\n T R 4"
                    }
                ]
            },
            {
                "id": 1566982,
                "content": [
                    {
                        "username": "shariqazz",
                        "content": "I\\'m trying to approach this as a Minimum Spanning Tree problem.\\n\\nThe test case \"TUGR\" has expected value 5 - but shouldnt the result be 4?\\nGo from U to T to G and then second finger on R. Thats a total of 1 + 3 + 0 = 4. Why is the expected 5?"
                    },
                    {
                        "username": "Weildcard",
                        "content": "If you go from U to T to G, you will get UTG, not TUG."
                    },
                    {
                        "username": "emli",
                        "content": "Why for case \"HAPPY\" answer is 6 ? \\n\\nMaybe I missed something. But I am getting 5\\n\\nFirst finger begins at A , second stays at Y\\n\\nFirst finger\\n\\nA->H\\nH->P\\nP->P\\n\\nSecond finger\\nY"
                    },
                    {
                        "username": "jumadaru",
                        "content": "You wrote AHPPY"
                    },
                    {
                        "username": "abhishek_sharma_yo",
                        "content": "Can someone please explain what this line actually mean?\\n\\n**also your two fingers do not have to start at the first letter or the first two letters**"
                    },
                    {
                        "username": "Weildcard",
                        "content": "It means you can type the first several letters with the same finger, and the second finger can start on a letter that comes, for example, fifth in the word or whatever.  The \"HAPPY\" example illustrates this."
                    },
                    {
                        "username": "KBJ_1412",
                        "content": "![image](https://assets.leetcode.com/users/images/fdf3a28e-65a4-426a-8de3-41c8ce6c7472_1592723749.0815127.png)\\n But the answer is 4 when T and R are where fingers placed \\n T R 4"
                    }
                ]
            },
            {
                "id": 1573952,
                "content": [
                    {
                        "username": "shariqazz",
                        "content": "I\\'m trying to approach this as a Minimum Spanning Tree problem.\\n\\nThe test case \"TUGR\" has expected value 5 - but shouldnt the result be 4?\\nGo from U to T to G and then second finger on R. Thats a total of 1 + 3 + 0 = 4. Why is the expected 5?"
                    },
                    {
                        "username": "Weildcard",
                        "content": "If you go from U to T to G, you will get UTG, not TUG."
                    },
                    {
                        "username": "emli",
                        "content": "Why for case \"HAPPY\" answer is 6 ? \\n\\nMaybe I missed something. But I am getting 5\\n\\nFirst finger begins at A , second stays at Y\\n\\nFirst finger\\n\\nA->H\\nH->P\\nP->P\\n\\nSecond finger\\nY"
                    },
                    {
                        "username": "jumadaru",
                        "content": "You wrote AHPPY"
                    },
                    {
                        "username": "abhishek_sharma_yo",
                        "content": "Can someone please explain what this line actually mean?\\n\\n**also your two fingers do not have to start at the first letter or the first two letters**"
                    },
                    {
                        "username": "Weildcard",
                        "content": "It means you can type the first several letters with the same finger, and the second finger can start on a letter that comes, for example, fifth in the word or whatever.  The \"HAPPY\" example illustrates this."
                    },
                    {
                        "username": "KBJ_1412",
                        "content": "![image](https://assets.leetcode.com/users/images/fdf3a28e-65a4-426a-8de3-41c8ce6c7472_1592723749.0815127.png)\\n But the answer is 4 when T and R are where fingers placed \\n T R 4"
                    }
                ]
            }
        ]
    }
]