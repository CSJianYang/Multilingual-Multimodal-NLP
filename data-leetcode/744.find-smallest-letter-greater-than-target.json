[
    {
        "title": "Shortest Distance from All Buildings",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1565898,
                "content": [
                    {
                        "username": "giof07",
                        "content": "The problem says the distance from one point to another is the mahattan distance, this should make bfs impossible... I see no solution in the discussion using the mahattan distance. What is going here? Can someone explain? If we use the manhattan distance to calculate the distance between two points how can we detect if there is an obstacle between two 0\\'s? If we can only move point to point and count each move as one, the problem is trivial, but manhattan distance seems to imply diagonal movement."
                    },
                    {
                        "username": "jeffkmeng",
                        "content": "The distance between two points is calculated with the manhattan distance, but that assumes there are no obstacles in between. The definition of manhattan distance is just that you assume you were walking along city blocks, so you *can\\'t* move diagonally."
                    },
                    {
                        "username": "pppprinciple",
                        "content": "\"The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.\"\\n\\nPlease fix. Looking at the tests, distance is expected to be calculated as number of steps taken in a given path."
                    },
                    {
                        "username": "lc4tc",
                        "content": "Last two sentences of the problem were blindly copied from https://leetcode.com/problems/best-meeting-point/, lol"
                    },
                    {
                        "username": "wuyinan",
                        "content": "Update:\\nI think I misunderstood this problem... I thought it asks to find an empty location that has access to all the houses and has the smallest sum of manhattan distances to all the houses and return that sum. It actually asks for the smallest sum of total steps to all the houses not Manhattan distances.\\n\\n=============================================================================================\\nTest case:\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\nMy code found the position at (3,2) has the shortest sum of distance of 72:\\n\\nPosition: dist to house 1, house 2, ...., sum of distance: \\n\\n6,0 : 1 1  sum: 2\\n5,1 : 6 5 6 7 8 8 3 4 7 3 4 6 2 2 5 1 4 1 2 3 4  sum: 91\\n5,2 : 7 6 5 6 7 7 4 3 6 4 3 5 3 1 4 2 3 2 1 2 3  sum: 84\\n4,1 : 5 4 5 6 7 7 2 3 6 2 3 5 1 1 4 2 5 2 3 4 5  sum: 82\\n2,0 : 2 3 4 5 6 6 1 2 5 1 4 6 2 4 7 3 8 5 6 7 8  sum: 95\\n5,3 : 8 7 6 5 6 6 5 4 5 5 2 4 4 2 3 3 2 3 2 1 2  sum: 85\\n3,1 : 4 3 4 5 6 6 1 2 5 1 2 4 2 2 5 3 6 3 4 5 6  sum: 79\\n1,0 : 1 2 3 4 5 5 2 3 6 2 5 7 3 5 8 4 9 6 7 8 9  sum: 104\\n5,4 : 9 8 7 6 5 5 6 5 4 6 3 3 5 3 2 4 1 4 3 2 1  sum: 92\\n4,3 : 7 6 5 4 5 5 4 3 4 4 1 3 3 1 2 4 3 4 3 2 3  sum: 76\\n3,2 : 5 4 3 4 5 5 2 1 4 2 1 3 3 1 4 4 5 4 3 4 5  sum: 72\\n6,5 : 1 1  sum: 2\\n1,1 : 2 1 2 3 4 4 1 2 5 3 4 6 4 4 7 5 8 5 6 7 8  sum: 91\\n4,4 : 8 7 6 5 4 4 5 4 3 5 2 2 4 2 1 5 2 5 4 3 2  sum: 83\\n1,2 : 3 2 1 2 3 3 2 1 4 4 3 5 5 3 6 6 7 6 5 6 7  sum: 84\\n2,3 : 5 4 3 2 3 3 2 1 2 4 1 3 5 3 4 6 5 6 5 4 5  sum: 76\\n3,4 : 7 6 5 4 3 3 4 3 2 4 1 1 5 3 2 6 3 6 5 4 3  sum: 80\\n1,3 : 4 3 2 1 2 2 3 2 3 5 2 4 6 4 5 7 6 7 6 5 6  sum: 85\\n2,4 : 6 5 4 3 2 2 3 2 1 5 2 2 6 4 3 7 4 7 6 5 4  sum: 83\\n1,4 : 5 4 3 2 1 1 4 3 2 6 3 3 7 5 4 8 5 8 7 6 5  sum: 92\\n0,5 : 1 1  sum: 2"
                    },
                    {
                        "username": "aivanilov",
                        "content": "I\\'ve got 72 as well in this case. And I don\\'t get why it\\'s 88 in the answer."
                    },
                    {
                        "username": "shchybovyk",
                        "content": "I still don\\'t understand what is actually asked to find"
                    },
                    {
                        "username": "sanemiliano",
                        "content": "Terrible statement: \"The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|. FIX ASAP. Spent two hours debbuging because I calculate the mahattan distance and turns out the test cases expect the sum of the steps."
                    },
                    {
                        "username": "littlelionman1",
                        "content": "TY for helping me"
                    },
                    {
                        "username": "cosR",
                        "content": "To solve this question there are two approaches:\\n1. start bfs from empty position i.e. 0\\n2. start bfs from building position i.e. 1\\n\\nApproach 1 mostly ends up with time ~ 250 ms\\nApproach 2 however ends up with time ~30 ms\\n\\nIs this due to the fact that majority of the test cases have lesser 1s compared to 0s in the grid? What do you think?"
                    },
                    {
                        "username": "doublefat",
                        "content": "Return the shortest travel distance for such a house. If it is not possible to build such a house according to the above rules, return -1.\\n\\nThe total travel distance is the sum of the distances between the houses of the friends and the meeting point.\\n\\n**The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.**\\n\\ntest case :\\n\\n\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\n![image](https://assets.leetcode.com/users/images/e8af8452-9bcd-4b9c-95b2-c8a1254cc45e_1641067609.3005052.png)\\n\\n1 ,point [3,2] to building [0] [0] distance is 5 , total is 5\\n2 ,point [3,2] to building [0] [1] distance is 4 , total is 9\\n3 ,point [3,2] to building [0] [2] distance is 3 , total is 12\\n4 ,point [3,2] to building [0] [3] distance is 4 , total is 16\\n5 ,point [3,2] to building [0] [4] distance is 5 , total is 21\\n6 ,point [3,2] to building [1] [5] distance is 5 , total is 26\\n7 ,point [3,2] to building [2] [1] distance is 2 , total is 28\\n8 ,point [3,2] to building [2] [2] distance is 1 , total is 29\\n9 ,point [3,2] to building [2] [5] distance is 4 , total is 33\\n10 ,point [3,2] to building [3] [0] distance is 2 , total is 35\\n11 ,point [3,2] to building [3] [3] distance is 1 , total is 36\\n12 ,point [3,2] to building [3] [5] distance is 3 , total is 39\\n13 ,point [3,2] to building [4] [0] distance is 3 , total is 42\\n14 ,point [3,2] to building [4] [2] distance is 1 , total is 43\\n15 ,point [3,2] to building [4] [5] distance is 4 , total is 47\\n16 ,point [3,2] to building [5] [0] distance is 4 , total is 51\\n17 ,point [3,2] to building [5] [5] distance is 5 , total is 56\\n18 ,point [3,2] to building [6] [1] distance is 4 , total is 60\\n19 ,point [3,2] to building [6] [2] distance is 3 , total is 63\\n20 ,point [3,2] to building [6] [3] distance is 4 , total is 67\\n21 ,point [3,2] to building [6] [4] distance is 5 , total is 72\\n\\n![image](https://assets.leetcode.com/users/images/ce6c3d14-8826-4d86-864e-ab7806865d31_1641067774.8862677.png)\\n\\n\\n"
                    },
                    {
                        "username": "sabrinasong",
                        "content": "The question is almost the same as 296 except that here we have obstacles. In 296 we simply calculate its median, while here we have to use bfs. Can we do something on the basis of median solution?"
                    },
                    {
                        "username": "luckymaster",
                        "content": "How the distance is 88 for this test case.\\n\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\n\\nMine is 72,\\n\\nLeetcode 88;\\n\\n\\nBuildings = [2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 5,0, 6,1, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4] Size true\\nI can visit All buldings from (1,0)[2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 104\\nI can visit All buldings from (1,1)[2,1, 2,2, 0,0, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 91\\nI can visit All buldings from (1,2)[2,1, 2,2, 3,3, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 84\\nI can visit All buldings from (1,3)[2,1, 3,3, 2,2, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 85\\nI can visit All buldings from (1,4)[2,1, 3,3, 2,2, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 92\\nI can visit All buldings from (2,0)[2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 95\\nI can visit All buldings from (2,3)[2,1, 3,3, 2,2, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 76\\nI can visit All buldings from (2,4)[2,1, 3,3, 2,2, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 83\\nI can visit All buldings from (3,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 79\\nI can visit All buldings from (3,2)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 72\\nI can visit All buldings from (3,4)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 80\\nI can visit All buldings from (4,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 82\\nI can visit All buldings from (4,3)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 76\\nI can visit All buldings from (4,4)[2,1, 5,5, 3,3, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 83\\nI can visit All buldings from (5,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 91\\nI can visit All buldings from (5,2)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 84\\nI can visit All buldings from (5,3)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 85\\nI can visit All buldings from (5,4)[2,1, 5,5, 3,3, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 92"
                    },
                    {
                        "username": "jonreiland",
                        "content": "It\\'s because the problem description is incorrect. It\\'s not the Manhattan Distance that should be used, but the number of steps."
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store all the paths from all the buildings to the shortest path on the grid?\\n\\nAny ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "brahma0545",
                        "content": "in this test case the answer is mentioned 88\\n[1,1,1,1,1,0],\\n[0,0,0,0,0,1],\\n[0,1,1,0,0,1],\\n[1,0,0,1,0,1],\\n[1,0,1,0,0,1],\\n[1,0,0,0,0,1],\\n[0,1,1,1,1,0]\\n\\nbut how come (0,5) is rechable from the nodes (0,0)?\\n\\nshouldn\\'t it be -1"
                    },
                    {
                        "username": "aivanilov",
                        "content": "[@NekoShadow](/NekoShadow) The problem is that there\\'s a solution in [3,2] with distance 72 (instead of 88)"
                    },
                    {
                        "username": "NekoShadow",
                        "content": "Yes, (0, 5) is not reachable from (0, 0). So (0, 5) should not be used for building your new house. Just build the house somewhere else. Remember, you goal is to look for an empty land that can reach all buildings with minimum total Manhattan distance, NOT making sure that all empty lands can be reached by every building :)"
                    }
                ]
            },
            {
                "id": 1567097,
                "content": [
                    {
                        "username": "giof07",
                        "content": "The problem says the distance from one point to another is the mahattan distance, this should make bfs impossible... I see no solution in the discussion using the mahattan distance. What is going here? Can someone explain? If we use the manhattan distance to calculate the distance between two points how can we detect if there is an obstacle between two 0\\'s? If we can only move point to point and count each move as one, the problem is trivial, but manhattan distance seems to imply diagonal movement."
                    },
                    {
                        "username": "jeffkmeng",
                        "content": "The distance between two points is calculated with the manhattan distance, but that assumes there are no obstacles in between. The definition of manhattan distance is just that you assume you were walking along city blocks, so you *can\\'t* move diagonally."
                    },
                    {
                        "username": "pppprinciple",
                        "content": "\"The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.\"\\n\\nPlease fix. Looking at the tests, distance is expected to be calculated as number of steps taken in a given path."
                    },
                    {
                        "username": "lc4tc",
                        "content": "Last two sentences of the problem were blindly copied from https://leetcode.com/problems/best-meeting-point/, lol"
                    },
                    {
                        "username": "wuyinan",
                        "content": "Update:\\nI think I misunderstood this problem... I thought it asks to find an empty location that has access to all the houses and has the smallest sum of manhattan distances to all the houses and return that sum. It actually asks for the smallest sum of total steps to all the houses not Manhattan distances.\\n\\n=============================================================================================\\nTest case:\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\nMy code found the position at (3,2) has the shortest sum of distance of 72:\\n\\nPosition: dist to house 1, house 2, ...., sum of distance: \\n\\n6,0 : 1 1  sum: 2\\n5,1 : 6 5 6 7 8 8 3 4 7 3 4 6 2 2 5 1 4 1 2 3 4  sum: 91\\n5,2 : 7 6 5 6 7 7 4 3 6 4 3 5 3 1 4 2 3 2 1 2 3  sum: 84\\n4,1 : 5 4 5 6 7 7 2 3 6 2 3 5 1 1 4 2 5 2 3 4 5  sum: 82\\n2,0 : 2 3 4 5 6 6 1 2 5 1 4 6 2 4 7 3 8 5 6 7 8  sum: 95\\n5,3 : 8 7 6 5 6 6 5 4 5 5 2 4 4 2 3 3 2 3 2 1 2  sum: 85\\n3,1 : 4 3 4 5 6 6 1 2 5 1 2 4 2 2 5 3 6 3 4 5 6  sum: 79\\n1,0 : 1 2 3 4 5 5 2 3 6 2 5 7 3 5 8 4 9 6 7 8 9  sum: 104\\n5,4 : 9 8 7 6 5 5 6 5 4 6 3 3 5 3 2 4 1 4 3 2 1  sum: 92\\n4,3 : 7 6 5 4 5 5 4 3 4 4 1 3 3 1 2 4 3 4 3 2 3  sum: 76\\n3,2 : 5 4 3 4 5 5 2 1 4 2 1 3 3 1 4 4 5 4 3 4 5  sum: 72\\n6,5 : 1 1  sum: 2\\n1,1 : 2 1 2 3 4 4 1 2 5 3 4 6 4 4 7 5 8 5 6 7 8  sum: 91\\n4,4 : 8 7 6 5 4 4 5 4 3 5 2 2 4 2 1 5 2 5 4 3 2  sum: 83\\n1,2 : 3 2 1 2 3 3 2 1 4 4 3 5 5 3 6 6 7 6 5 6 7  sum: 84\\n2,3 : 5 4 3 2 3 3 2 1 2 4 1 3 5 3 4 6 5 6 5 4 5  sum: 76\\n3,4 : 7 6 5 4 3 3 4 3 2 4 1 1 5 3 2 6 3 6 5 4 3  sum: 80\\n1,3 : 4 3 2 1 2 2 3 2 3 5 2 4 6 4 5 7 6 7 6 5 6  sum: 85\\n2,4 : 6 5 4 3 2 2 3 2 1 5 2 2 6 4 3 7 4 7 6 5 4  sum: 83\\n1,4 : 5 4 3 2 1 1 4 3 2 6 3 3 7 5 4 8 5 8 7 6 5  sum: 92\\n0,5 : 1 1  sum: 2"
                    },
                    {
                        "username": "aivanilov",
                        "content": "I\\'ve got 72 as well in this case. And I don\\'t get why it\\'s 88 in the answer."
                    },
                    {
                        "username": "shchybovyk",
                        "content": "I still don\\'t understand what is actually asked to find"
                    },
                    {
                        "username": "sanemiliano",
                        "content": "Terrible statement: \"The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|. FIX ASAP. Spent two hours debbuging because I calculate the mahattan distance and turns out the test cases expect the sum of the steps."
                    },
                    {
                        "username": "littlelionman1",
                        "content": "TY for helping me"
                    },
                    {
                        "username": "cosR",
                        "content": "To solve this question there are two approaches:\\n1. start bfs from empty position i.e. 0\\n2. start bfs from building position i.e. 1\\n\\nApproach 1 mostly ends up with time ~ 250 ms\\nApproach 2 however ends up with time ~30 ms\\n\\nIs this due to the fact that majority of the test cases have lesser 1s compared to 0s in the grid? What do you think?"
                    },
                    {
                        "username": "doublefat",
                        "content": "Return the shortest travel distance for such a house. If it is not possible to build such a house according to the above rules, return -1.\\n\\nThe total travel distance is the sum of the distances between the houses of the friends and the meeting point.\\n\\n**The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.**\\n\\ntest case :\\n\\n\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\n![image](https://assets.leetcode.com/users/images/e8af8452-9bcd-4b9c-95b2-c8a1254cc45e_1641067609.3005052.png)\\n\\n1 ,point [3,2] to building [0] [0] distance is 5 , total is 5\\n2 ,point [3,2] to building [0] [1] distance is 4 , total is 9\\n3 ,point [3,2] to building [0] [2] distance is 3 , total is 12\\n4 ,point [3,2] to building [0] [3] distance is 4 , total is 16\\n5 ,point [3,2] to building [0] [4] distance is 5 , total is 21\\n6 ,point [3,2] to building [1] [5] distance is 5 , total is 26\\n7 ,point [3,2] to building [2] [1] distance is 2 , total is 28\\n8 ,point [3,2] to building [2] [2] distance is 1 , total is 29\\n9 ,point [3,2] to building [2] [5] distance is 4 , total is 33\\n10 ,point [3,2] to building [3] [0] distance is 2 , total is 35\\n11 ,point [3,2] to building [3] [3] distance is 1 , total is 36\\n12 ,point [3,2] to building [3] [5] distance is 3 , total is 39\\n13 ,point [3,2] to building [4] [0] distance is 3 , total is 42\\n14 ,point [3,2] to building [4] [2] distance is 1 , total is 43\\n15 ,point [3,2] to building [4] [5] distance is 4 , total is 47\\n16 ,point [3,2] to building [5] [0] distance is 4 , total is 51\\n17 ,point [3,2] to building [5] [5] distance is 5 , total is 56\\n18 ,point [3,2] to building [6] [1] distance is 4 , total is 60\\n19 ,point [3,2] to building [6] [2] distance is 3 , total is 63\\n20 ,point [3,2] to building [6] [3] distance is 4 , total is 67\\n21 ,point [3,2] to building [6] [4] distance is 5 , total is 72\\n\\n![image](https://assets.leetcode.com/users/images/ce6c3d14-8826-4d86-864e-ab7806865d31_1641067774.8862677.png)\\n\\n\\n"
                    },
                    {
                        "username": "sabrinasong",
                        "content": "The question is almost the same as 296 except that here we have obstacles. In 296 we simply calculate its median, while here we have to use bfs. Can we do something on the basis of median solution?"
                    },
                    {
                        "username": "luckymaster",
                        "content": "How the distance is 88 for this test case.\\n\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\n\\nMine is 72,\\n\\nLeetcode 88;\\n\\n\\nBuildings = [2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 5,0, 6,1, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4] Size true\\nI can visit All buldings from (1,0)[2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 104\\nI can visit All buldings from (1,1)[2,1, 2,2, 0,0, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 91\\nI can visit All buldings from (1,2)[2,1, 2,2, 3,3, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 84\\nI can visit All buldings from (1,3)[2,1, 3,3, 2,2, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 85\\nI can visit All buldings from (1,4)[2,1, 3,3, 2,2, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 92\\nI can visit All buldings from (2,0)[2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 95\\nI can visit All buldings from (2,3)[2,1, 3,3, 2,2, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 76\\nI can visit All buldings from (2,4)[2,1, 3,3, 2,2, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 83\\nI can visit All buldings from (3,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 79\\nI can visit All buldings from (3,2)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 72\\nI can visit All buldings from (3,4)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 80\\nI can visit All buldings from (4,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 82\\nI can visit All buldings from (4,3)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 76\\nI can visit All buldings from (4,4)[2,1, 5,5, 3,3, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 83\\nI can visit All buldings from (5,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 91\\nI can visit All buldings from (5,2)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 84\\nI can visit All buldings from (5,3)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 85\\nI can visit All buldings from (5,4)[2,1, 5,5, 3,3, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 92"
                    },
                    {
                        "username": "jonreiland",
                        "content": "It\\'s because the problem description is incorrect. It\\'s not the Manhattan Distance that should be used, but the number of steps."
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store all the paths from all the buildings to the shortest path on the grid?\\n\\nAny ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "brahma0545",
                        "content": "in this test case the answer is mentioned 88\\n[1,1,1,1,1,0],\\n[0,0,0,0,0,1],\\n[0,1,1,0,0,1],\\n[1,0,0,1,0,1],\\n[1,0,1,0,0,1],\\n[1,0,0,0,0,1],\\n[0,1,1,1,1,0]\\n\\nbut how come (0,5) is rechable from the nodes (0,0)?\\n\\nshouldn\\'t it be -1"
                    },
                    {
                        "username": "aivanilov",
                        "content": "[@NekoShadow](/NekoShadow) The problem is that there\\'s a solution in [3,2] with distance 72 (instead of 88)"
                    },
                    {
                        "username": "NekoShadow",
                        "content": "Yes, (0, 5) is not reachable from (0, 0). So (0, 5) should not be used for building your new house. Just build the house somewhere else. Remember, you goal is to look for an empty land that can reach all buildings with minimum total Manhattan distance, NOT making sure that all empty lands can be reached by every building :)"
                    }
                ]
            },
            {
                "id": 1567044,
                "content": [
                    {
                        "username": "giof07",
                        "content": "The problem says the distance from one point to another is the mahattan distance, this should make bfs impossible... I see no solution in the discussion using the mahattan distance. What is going here? Can someone explain? If we use the manhattan distance to calculate the distance between two points how can we detect if there is an obstacle between two 0\\'s? If we can only move point to point and count each move as one, the problem is trivial, but manhattan distance seems to imply diagonal movement."
                    },
                    {
                        "username": "jeffkmeng",
                        "content": "The distance between two points is calculated with the manhattan distance, but that assumes there are no obstacles in between. The definition of manhattan distance is just that you assume you were walking along city blocks, so you *can\\'t* move diagonally."
                    },
                    {
                        "username": "pppprinciple",
                        "content": "\"The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.\"\\n\\nPlease fix. Looking at the tests, distance is expected to be calculated as number of steps taken in a given path."
                    },
                    {
                        "username": "lc4tc",
                        "content": "Last two sentences of the problem were blindly copied from https://leetcode.com/problems/best-meeting-point/, lol"
                    },
                    {
                        "username": "wuyinan",
                        "content": "Update:\\nI think I misunderstood this problem... I thought it asks to find an empty location that has access to all the houses and has the smallest sum of manhattan distances to all the houses and return that sum. It actually asks for the smallest sum of total steps to all the houses not Manhattan distances.\\n\\n=============================================================================================\\nTest case:\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\nMy code found the position at (3,2) has the shortest sum of distance of 72:\\n\\nPosition: dist to house 1, house 2, ...., sum of distance: \\n\\n6,0 : 1 1  sum: 2\\n5,1 : 6 5 6 7 8 8 3 4 7 3 4 6 2 2 5 1 4 1 2 3 4  sum: 91\\n5,2 : 7 6 5 6 7 7 4 3 6 4 3 5 3 1 4 2 3 2 1 2 3  sum: 84\\n4,1 : 5 4 5 6 7 7 2 3 6 2 3 5 1 1 4 2 5 2 3 4 5  sum: 82\\n2,0 : 2 3 4 5 6 6 1 2 5 1 4 6 2 4 7 3 8 5 6 7 8  sum: 95\\n5,3 : 8 7 6 5 6 6 5 4 5 5 2 4 4 2 3 3 2 3 2 1 2  sum: 85\\n3,1 : 4 3 4 5 6 6 1 2 5 1 2 4 2 2 5 3 6 3 4 5 6  sum: 79\\n1,0 : 1 2 3 4 5 5 2 3 6 2 5 7 3 5 8 4 9 6 7 8 9  sum: 104\\n5,4 : 9 8 7 6 5 5 6 5 4 6 3 3 5 3 2 4 1 4 3 2 1  sum: 92\\n4,3 : 7 6 5 4 5 5 4 3 4 4 1 3 3 1 2 4 3 4 3 2 3  sum: 76\\n3,2 : 5 4 3 4 5 5 2 1 4 2 1 3 3 1 4 4 5 4 3 4 5  sum: 72\\n6,5 : 1 1  sum: 2\\n1,1 : 2 1 2 3 4 4 1 2 5 3 4 6 4 4 7 5 8 5 6 7 8  sum: 91\\n4,4 : 8 7 6 5 4 4 5 4 3 5 2 2 4 2 1 5 2 5 4 3 2  sum: 83\\n1,2 : 3 2 1 2 3 3 2 1 4 4 3 5 5 3 6 6 7 6 5 6 7  sum: 84\\n2,3 : 5 4 3 2 3 3 2 1 2 4 1 3 5 3 4 6 5 6 5 4 5  sum: 76\\n3,4 : 7 6 5 4 3 3 4 3 2 4 1 1 5 3 2 6 3 6 5 4 3  sum: 80\\n1,3 : 4 3 2 1 2 2 3 2 3 5 2 4 6 4 5 7 6 7 6 5 6  sum: 85\\n2,4 : 6 5 4 3 2 2 3 2 1 5 2 2 6 4 3 7 4 7 6 5 4  sum: 83\\n1,4 : 5 4 3 2 1 1 4 3 2 6 3 3 7 5 4 8 5 8 7 6 5  sum: 92\\n0,5 : 1 1  sum: 2"
                    },
                    {
                        "username": "aivanilov",
                        "content": "I\\'ve got 72 as well in this case. And I don\\'t get why it\\'s 88 in the answer."
                    },
                    {
                        "username": "shchybovyk",
                        "content": "I still don\\'t understand what is actually asked to find"
                    },
                    {
                        "username": "sanemiliano",
                        "content": "Terrible statement: \"The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|. FIX ASAP. Spent two hours debbuging because I calculate the mahattan distance and turns out the test cases expect the sum of the steps."
                    },
                    {
                        "username": "littlelionman1",
                        "content": "TY for helping me"
                    },
                    {
                        "username": "cosR",
                        "content": "To solve this question there are two approaches:\\n1. start bfs from empty position i.e. 0\\n2. start bfs from building position i.e. 1\\n\\nApproach 1 mostly ends up with time ~ 250 ms\\nApproach 2 however ends up with time ~30 ms\\n\\nIs this due to the fact that majority of the test cases have lesser 1s compared to 0s in the grid? What do you think?"
                    },
                    {
                        "username": "doublefat",
                        "content": "Return the shortest travel distance for such a house. If it is not possible to build such a house according to the above rules, return -1.\\n\\nThe total travel distance is the sum of the distances between the houses of the friends and the meeting point.\\n\\n**The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.**\\n\\ntest case :\\n\\n\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\n![image](https://assets.leetcode.com/users/images/e8af8452-9bcd-4b9c-95b2-c8a1254cc45e_1641067609.3005052.png)\\n\\n1 ,point [3,2] to building [0] [0] distance is 5 , total is 5\\n2 ,point [3,2] to building [0] [1] distance is 4 , total is 9\\n3 ,point [3,2] to building [0] [2] distance is 3 , total is 12\\n4 ,point [3,2] to building [0] [3] distance is 4 , total is 16\\n5 ,point [3,2] to building [0] [4] distance is 5 , total is 21\\n6 ,point [3,2] to building [1] [5] distance is 5 , total is 26\\n7 ,point [3,2] to building [2] [1] distance is 2 , total is 28\\n8 ,point [3,2] to building [2] [2] distance is 1 , total is 29\\n9 ,point [3,2] to building [2] [5] distance is 4 , total is 33\\n10 ,point [3,2] to building [3] [0] distance is 2 , total is 35\\n11 ,point [3,2] to building [3] [3] distance is 1 , total is 36\\n12 ,point [3,2] to building [3] [5] distance is 3 , total is 39\\n13 ,point [3,2] to building [4] [0] distance is 3 , total is 42\\n14 ,point [3,2] to building [4] [2] distance is 1 , total is 43\\n15 ,point [3,2] to building [4] [5] distance is 4 , total is 47\\n16 ,point [3,2] to building [5] [0] distance is 4 , total is 51\\n17 ,point [3,2] to building [5] [5] distance is 5 , total is 56\\n18 ,point [3,2] to building [6] [1] distance is 4 , total is 60\\n19 ,point [3,2] to building [6] [2] distance is 3 , total is 63\\n20 ,point [3,2] to building [6] [3] distance is 4 , total is 67\\n21 ,point [3,2] to building [6] [4] distance is 5 , total is 72\\n\\n![image](https://assets.leetcode.com/users/images/ce6c3d14-8826-4d86-864e-ab7806865d31_1641067774.8862677.png)\\n\\n\\n"
                    },
                    {
                        "username": "sabrinasong",
                        "content": "The question is almost the same as 296 except that here we have obstacles. In 296 we simply calculate its median, while here we have to use bfs. Can we do something on the basis of median solution?"
                    },
                    {
                        "username": "luckymaster",
                        "content": "How the distance is 88 for this test case.\\n\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\n\\nMine is 72,\\n\\nLeetcode 88;\\n\\n\\nBuildings = [2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 5,0, 6,1, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4] Size true\\nI can visit All buldings from (1,0)[2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 104\\nI can visit All buldings from (1,1)[2,1, 2,2, 0,0, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 91\\nI can visit All buldings from (1,2)[2,1, 2,2, 3,3, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 84\\nI can visit All buldings from (1,3)[2,1, 3,3, 2,2, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 85\\nI can visit All buldings from (1,4)[2,1, 3,3, 2,2, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 92\\nI can visit All buldings from (2,0)[2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 95\\nI can visit All buldings from (2,3)[2,1, 3,3, 2,2, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 76\\nI can visit All buldings from (2,4)[2,1, 3,3, 2,2, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 83\\nI can visit All buldings from (3,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 79\\nI can visit All buldings from (3,2)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 72\\nI can visit All buldings from (3,4)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 80\\nI can visit All buldings from (4,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 82\\nI can visit All buldings from (4,3)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 76\\nI can visit All buldings from (4,4)[2,1, 5,5, 3,3, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 83\\nI can visit All buldings from (5,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 91\\nI can visit All buldings from (5,2)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 84\\nI can visit All buldings from (5,3)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 85\\nI can visit All buldings from (5,4)[2,1, 5,5, 3,3, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 92"
                    },
                    {
                        "username": "jonreiland",
                        "content": "It\\'s because the problem description is incorrect. It\\'s not the Manhattan Distance that should be used, but the number of steps."
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store all the paths from all the buildings to the shortest path on the grid?\\n\\nAny ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "brahma0545",
                        "content": "in this test case the answer is mentioned 88\\n[1,1,1,1,1,0],\\n[0,0,0,0,0,1],\\n[0,1,1,0,0,1],\\n[1,0,0,1,0,1],\\n[1,0,1,0,0,1],\\n[1,0,0,0,0,1],\\n[0,1,1,1,1,0]\\n\\nbut how come (0,5) is rechable from the nodes (0,0)?\\n\\nshouldn\\'t it be -1"
                    },
                    {
                        "username": "aivanilov",
                        "content": "[@NekoShadow](/NekoShadow) The problem is that there\\'s a solution in [3,2] with distance 72 (instead of 88)"
                    },
                    {
                        "username": "NekoShadow",
                        "content": "Yes, (0, 5) is not reachable from (0, 0). So (0, 5) should not be used for building your new house. Just build the house somewhere else. Remember, you goal is to look for an empty land that can reach all buildings with minimum total Manhattan distance, NOT making sure that all empty lands can be reached by every building :)"
                    }
                ]
            },
            {
                "id": 1684672,
                "content": [
                    {
                        "username": "giof07",
                        "content": "The problem says the distance from one point to another is the mahattan distance, this should make bfs impossible... I see no solution in the discussion using the mahattan distance. What is going here? Can someone explain? If we use the manhattan distance to calculate the distance between two points how can we detect if there is an obstacle between two 0\\'s? If we can only move point to point and count each move as one, the problem is trivial, but manhattan distance seems to imply diagonal movement."
                    },
                    {
                        "username": "jeffkmeng",
                        "content": "The distance between two points is calculated with the manhattan distance, but that assumes there are no obstacles in between. The definition of manhattan distance is just that you assume you were walking along city blocks, so you *can\\'t* move diagonally."
                    },
                    {
                        "username": "pppprinciple",
                        "content": "\"The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.\"\\n\\nPlease fix. Looking at the tests, distance is expected to be calculated as number of steps taken in a given path."
                    },
                    {
                        "username": "lc4tc",
                        "content": "Last two sentences of the problem were blindly copied from https://leetcode.com/problems/best-meeting-point/, lol"
                    },
                    {
                        "username": "wuyinan",
                        "content": "Update:\\nI think I misunderstood this problem... I thought it asks to find an empty location that has access to all the houses and has the smallest sum of manhattan distances to all the houses and return that sum. It actually asks for the smallest sum of total steps to all the houses not Manhattan distances.\\n\\n=============================================================================================\\nTest case:\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\nMy code found the position at (3,2) has the shortest sum of distance of 72:\\n\\nPosition: dist to house 1, house 2, ...., sum of distance: \\n\\n6,0 : 1 1  sum: 2\\n5,1 : 6 5 6 7 8 8 3 4 7 3 4 6 2 2 5 1 4 1 2 3 4  sum: 91\\n5,2 : 7 6 5 6 7 7 4 3 6 4 3 5 3 1 4 2 3 2 1 2 3  sum: 84\\n4,1 : 5 4 5 6 7 7 2 3 6 2 3 5 1 1 4 2 5 2 3 4 5  sum: 82\\n2,0 : 2 3 4 5 6 6 1 2 5 1 4 6 2 4 7 3 8 5 6 7 8  sum: 95\\n5,3 : 8 7 6 5 6 6 5 4 5 5 2 4 4 2 3 3 2 3 2 1 2  sum: 85\\n3,1 : 4 3 4 5 6 6 1 2 5 1 2 4 2 2 5 3 6 3 4 5 6  sum: 79\\n1,0 : 1 2 3 4 5 5 2 3 6 2 5 7 3 5 8 4 9 6 7 8 9  sum: 104\\n5,4 : 9 8 7 6 5 5 6 5 4 6 3 3 5 3 2 4 1 4 3 2 1  sum: 92\\n4,3 : 7 6 5 4 5 5 4 3 4 4 1 3 3 1 2 4 3 4 3 2 3  sum: 76\\n3,2 : 5 4 3 4 5 5 2 1 4 2 1 3 3 1 4 4 5 4 3 4 5  sum: 72\\n6,5 : 1 1  sum: 2\\n1,1 : 2 1 2 3 4 4 1 2 5 3 4 6 4 4 7 5 8 5 6 7 8  sum: 91\\n4,4 : 8 7 6 5 4 4 5 4 3 5 2 2 4 2 1 5 2 5 4 3 2  sum: 83\\n1,2 : 3 2 1 2 3 3 2 1 4 4 3 5 5 3 6 6 7 6 5 6 7  sum: 84\\n2,3 : 5 4 3 2 3 3 2 1 2 4 1 3 5 3 4 6 5 6 5 4 5  sum: 76\\n3,4 : 7 6 5 4 3 3 4 3 2 4 1 1 5 3 2 6 3 6 5 4 3  sum: 80\\n1,3 : 4 3 2 1 2 2 3 2 3 5 2 4 6 4 5 7 6 7 6 5 6  sum: 85\\n2,4 : 6 5 4 3 2 2 3 2 1 5 2 2 6 4 3 7 4 7 6 5 4  sum: 83\\n1,4 : 5 4 3 2 1 1 4 3 2 6 3 3 7 5 4 8 5 8 7 6 5  sum: 92\\n0,5 : 1 1  sum: 2"
                    },
                    {
                        "username": "aivanilov",
                        "content": "I\\'ve got 72 as well in this case. And I don\\'t get why it\\'s 88 in the answer."
                    },
                    {
                        "username": "shchybovyk",
                        "content": "I still don\\'t understand what is actually asked to find"
                    },
                    {
                        "username": "sanemiliano",
                        "content": "Terrible statement: \"The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|. FIX ASAP. Spent two hours debbuging because I calculate the mahattan distance and turns out the test cases expect the sum of the steps."
                    },
                    {
                        "username": "littlelionman1",
                        "content": "TY for helping me"
                    },
                    {
                        "username": "cosR",
                        "content": "To solve this question there are two approaches:\\n1. start bfs from empty position i.e. 0\\n2. start bfs from building position i.e. 1\\n\\nApproach 1 mostly ends up with time ~ 250 ms\\nApproach 2 however ends up with time ~30 ms\\n\\nIs this due to the fact that majority of the test cases have lesser 1s compared to 0s in the grid? What do you think?"
                    },
                    {
                        "username": "doublefat",
                        "content": "Return the shortest travel distance for such a house. If it is not possible to build such a house according to the above rules, return -1.\\n\\nThe total travel distance is the sum of the distances between the houses of the friends and the meeting point.\\n\\n**The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.**\\n\\ntest case :\\n\\n\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\n![image](https://assets.leetcode.com/users/images/e8af8452-9bcd-4b9c-95b2-c8a1254cc45e_1641067609.3005052.png)\\n\\n1 ,point [3,2] to building [0] [0] distance is 5 , total is 5\\n2 ,point [3,2] to building [0] [1] distance is 4 , total is 9\\n3 ,point [3,2] to building [0] [2] distance is 3 , total is 12\\n4 ,point [3,2] to building [0] [3] distance is 4 , total is 16\\n5 ,point [3,2] to building [0] [4] distance is 5 , total is 21\\n6 ,point [3,2] to building [1] [5] distance is 5 , total is 26\\n7 ,point [3,2] to building [2] [1] distance is 2 , total is 28\\n8 ,point [3,2] to building [2] [2] distance is 1 , total is 29\\n9 ,point [3,2] to building [2] [5] distance is 4 , total is 33\\n10 ,point [3,2] to building [3] [0] distance is 2 , total is 35\\n11 ,point [3,2] to building [3] [3] distance is 1 , total is 36\\n12 ,point [3,2] to building [3] [5] distance is 3 , total is 39\\n13 ,point [3,2] to building [4] [0] distance is 3 , total is 42\\n14 ,point [3,2] to building [4] [2] distance is 1 , total is 43\\n15 ,point [3,2] to building [4] [5] distance is 4 , total is 47\\n16 ,point [3,2] to building [5] [0] distance is 4 , total is 51\\n17 ,point [3,2] to building [5] [5] distance is 5 , total is 56\\n18 ,point [3,2] to building [6] [1] distance is 4 , total is 60\\n19 ,point [3,2] to building [6] [2] distance is 3 , total is 63\\n20 ,point [3,2] to building [6] [3] distance is 4 , total is 67\\n21 ,point [3,2] to building [6] [4] distance is 5 , total is 72\\n\\n![image](https://assets.leetcode.com/users/images/ce6c3d14-8826-4d86-864e-ab7806865d31_1641067774.8862677.png)\\n\\n\\n"
                    },
                    {
                        "username": "sabrinasong",
                        "content": "The question is almost the same as 296 except that here we have obstacles. In 296 we simply calculate its median, while here we have to use bfs. Can we do something on the basis of median solution?"
                    },
                    {
                        "username": "luckymaster",
                        "content": "How the distance is 88 for this test case.\\n\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\n\\nMine is 72,\\n\\nLeetcode 88;\\n\\n\\nBuildings = [2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 5,0, 6,1, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4] Size true\\nI can visit All buldings from (1,0)[2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 104\\nI can visit All buldings from (1,1)[2,1, 2,2, 0,0, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 91\\nI can visit All buldings from (1,2)[2,1, 2,2, 3,3, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 84\\nI can visit All buldings from (1,3)[2,1, 3,3, 2,2, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 85\\nI can visit All buldings from (1,4)[2,1, 3,3, 2,2, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 92\\nI can visit All buldings from (2,0)[2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 95\\nI can visit All buldings from (2,3)[2,1, 3,3, 2,2, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 76\\nI can visit All buldings from (2,4)[2,1, 3,3, 2,2, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 83\\nI can visit All buldings from (3,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 79\\nI can visit All buldings from (3,2)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 72\\nI can visit All buldings from (3,4)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 80\\nI can visit All buldings from (4,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 82\\nI can visit All buldings from (4,3)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 76\\nI can visit All buldings from (4,4)[2,1, 5,5, 3,3, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 83\\nI can visit All buldings from (5,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 91\\nI can visit All buldings from (5,2)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 84\\nI can visit All buldings from (5,3)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 85\\nI can visit All buldings from (5,4)[2,1, 5,5, 3,3, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 92"
                    },
                    {
                        "username": "jonreiland",
                        "content": "It\\'s because the problem description is incorrect. It\\'s not the Manhattan Distance that should be used, but the number of steps."
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store all the paths from all the buildings to the shortest path on the grid?\\n\\nAny ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "brahma0545",
                        "content": "in this test case the answer is mentioned 88\\n[1,1,1,1,1,0],\\n[0,0,0,0,0,1],\\n[0,1,1,0,0,1],\\n[1,0,0,1,0,1],\\n[1,0,1,0,0,1],\\n[1,0,0,0,0,1],\\n[0,1,1,1,1,0]\\n\\nbut how come (0,5) is rechable from the nodes (0,0)?\\n\\nshouldn\\'t it be -1"
                    },
                    {
                        "username": "aivanilov",
                        "content": "[@NekoShadow](/NekoShadow) The problem is that there\\'s a solution in [3,2] with distance 72 (instead of 88)"
                    },
                    {
                        "username": "NekoShadow",
                        "content": "Yes, (0, 5) is not reachable from (0, 0). So (0, 5) should not be used for building your new house. Just build the house somewhere else. Remember, you goal is to look for an empty land that can reach all buildings with minimum total Manhattan distance, NOT making sure that all empty lands can be reached by every building :)"
                    }
                ]
            },
            {
                "id": 1573867,
                "content": [
                    {
                        "username": "giof07",
                        "content": "The problem says the distance from one point to another is the mahattan distance, this should make bfs impossible... I see no solution in the discussion using the mahattan distance. What is going here? Can someone explain? If we use the manhattan distance to calculate the distance between two points how can we detect if there is an obstacle between two 0\\'s? If we can only move point to point and count each move as one, the problem is trivial, but manhattan distance seems to imply diagonal movement."
                    },
                    {
                        "username": "jeffkmeng",
                        "content": "The distance between two points is calculated with the manhattan distance, but that assumes there are no obstacles in between. The definition of manhattan distance is just that you assume you were walking along city blocks, so you *can\\'t* move diagonally."
                    },
                    {
                        "username": "pppprinciple",
                        "content": "\"The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.\"\\n\\nPlease fix. Looking at the tests, distance is expected to be calculated as number of steps taken in a given path."
                    },
                    {
                        "username": "lc4tc",
                        "content": "Last two sentences of the problem were blindly copied from https://leetcode.com/problems/best-meeting-point/, lol"
                    },
                    {
                        "username": "wuyinan",
                        "content": "Update:\\nI think I misunderstood this problem... I thought it asks to find an empty location that has access to all the houses and has the smallest sum of manhattan distances to all the houses and return that sum. It actually asks for the smallest sum of total steps to all the houses not Manhattan distances.\\n\\n=============================================================================================\\nTest case:\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\nMy code found the position at (3,2) has the shortest sum of distance of 72:\\n\\nPosition: dist to house 1, house 2, ...., sum of distance: \\n\\n6,0 : 1 1  sum: 2\\n5,1 : 6 5 6 7 8 8 3 4 7 3 4 6 2 2 5 1 4 1 2 3 4  sum: 91\\n5,2 : 7 6 5 6 7 7 4 3 6 4 3 5 3 1 4 2 3 2 1 2 3  sum: 84\\n4,1 : 5 4 5 6 7 7 2 3 6 2 3 5 1 1 4 2 5 2 3 4 5  sum: 82\\n2,0 : 2 3 4 5 6 6 1 2 5 1 4 6 2 4 7 3 8 5 6 7 8  sum: 95\\n5,3 : 8 7 6 5 6 6 5 4 5 5 2 4 4 2 3 3 2 3 2 1 2  sum: 85\\n3,1 : 4 3 4 5 6 6 1 2 5 1 2 4 2 2 5 3 6 3 4 5 6  sum: 79\\n1,0 : 1 2 3 4 5 5 2 3 6 2 5 7 3 5 8 4 9 6 7 8 9  sum: 104\\n5,4 : 9 8 7 6 5 5 6 5 4 6 3 3 5 3 2 4 1 4 3 2 1  sum: 92\\n4,3 : 7 6 5 4 5 5 4 3 4 4 1 3 3 1 2 4 3 4 3 2 3  sum: 76\\n3,2 : 5 4 3 4 5 5 2 1 4 2 1 3 3 1 4 4 5 4 3 4 5  sum: 72\\n6,5 : 1 1  sum: 2\\n1,1 : 2 1 2 3 4 4 1 2 5 3 4 6 4 4 7 5 8 5 6 7 8  sum: 91\\n4,4 : 8 7 6 5 4 4 5 4 3 5 2 2 4 2 1 5 2 5 4 3 2  sum: 83\\n1,2 : 3 2 1 2 3 3 2 1 4 4 3 5 5 3 6 6 7 6 5 6 7  sum: 84\\n2,3 : 5 4 3 2 3 3 2 1 2 4 1 3 5 3 4 6 5 6 5 4 5  sum: 76\\n3,4 : 7 6 5 4 3 3 4 3 2 4 1 1 5 3 2 6 3 6 5 4 3  sum: 80\\n1,3 : 4 3 2 1 2 2 3 2 3 5 2 4 6 4 5 7 6 7 6 5 6  sum: 85\\n2,4 : 6 5 4 3 2 2 3 2 1 5 2 2 6 4 3 7 4 7 6 5 4  sum: 83\\n1,4 : 5 4 3 2 1 1 4 3 2 6 3 3 7 5 4 8 5 8 7 6 5  sum: 92\\n0,5 : 1 1  sum: 2"
                    },
                    {
                        "username": "aivanilov",
                        "content": "I\\'ve got 72 as well in this case. And I don\\'t get why it\\'s 88 in the answer."
                    },
                    {
                        "username": "shchybovyk",
                        "content": "I still don\\'t understand what is actually asked to find"
                    },
                    {
                        "username": "sanemiliano",
                        "content": "Terrible statement: \"The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|. FIX ASAP. Spent two hours debbuging because I calculate the mahattan distance and turns out the test cases expect the sum of the steps."
                    },
                    {
                        "username": "littlelionman1",
                        "content": "TY for helping me"
                    },
                    {
                        "username": "cosR",
                        "content": "To solve this question there are two approaches:\\n1. start bfs from empty position i.e. 0\\n2. start bfs from building position i.e. 1\\n\\nApproach 1 mostly ends up with time ~ 250 ms\\nApproach 2 however ends up with time ~30 ms\\n\\nIs this due to the fact that majority of the test cases have lesser 1s compared to 0s in the grid? What do you think?"
                    },
                    {
                        "username": "doublefat",
                        "content": "Return the shortest travel distance for such a house. If it is not possible to build such a house according to the above rules, return -1.\\n\\nThe total travel distance is the sum of the distances between the houses of the friends and the meeting point.\\n\\n**The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.**\\n\\ntest case :\\n\\n\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\n![image](https://assets.leetcode.com/users/images/e8af8452-9bcd-4b9c-95b2-c8a1254cc45e_1641067609.3005052.png)\\n\\n1 ,point [3,2] to building [0] [0] distance is 5 , total is 5\\n2 ,point [3,2] to building [0] [1] distance is 4 , total is 9\\n3 ,point [3,2] to building [0] [2] distance is 3 , total is 12\\n4 ,point [3,2] to building [0] [3] distance is 4 , total is 16\\n5 ,point [3,2] to building [0] [4] distance is 5 , total is 21\\n6 ,point [3,2] to building [1] [5] distance is 5 , total is 26\\n7 ,point [3,2] to building [2] [1] distance is 2 , total is 28\\n8 ,point [3,2] to building [2] [2] distance is 1 , total is 29\\n9 ,point [3,2] to building [2] [5] distance is 4 , total is 33\\n10 ,point [3,2] to building [3] [0] distance is 2 , total is 35\\n11 ,point [3,2] to building [3] [3] distance is 1 , total is 36\\n12 ,point [3,2] to building [3] [5] distance is 3 , total is 39\\n13 ,point [3,2] to building [4] [0] distance is 3 , total is 42\\n14 ,point [3,2] to building [4] [2] distance is 1 , total is 43\\n15 ,point [3,2] to building [4] [5] distance is 4 , total is 47\\n16 ,point [3,2] to building [5] [0] distance is 4 , total is 51\\n17 ,point [3,2] to building [5] [5] distance is 5 , total is 56\\n18 ,point [3,2] to building [6] [1] distance is 4 , total is 60\\n19 ,point [3,2] to building [6] [2] distance is 3 , total is 63\\n20 ,point [3,2] to building [6] [3] distance is 4 , total is 67\\n21 ,point [3,2] to building [6] [4] distance is 5 , total is 72\\n\\n![image](https://assets.leetcode.com/users/images/ce6c3d14-8826-4d86-864e-ab7806865d31_1641067774.8862677.png)\\n\\n\\n"
                    },
                    {
                        "username": "sabrinasong",
                        "content": "The question is almost the same as 296 except that here we have obstacles. In 296 we simply calculate its median, while here we have to use bfs. Can we do something on the basis of median solution?"
                    },
                    {
                        "username": "luckymaster",
                        "content": "How the distance is 88 for this test case.\\n\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\n\\nMine is 72,\\n\\nLeetcode 88;\\n\\n\\nBuildings = [2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 5,0, 6,1, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4] Size true\\nI can visit All buldings from (1,0)[2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 104\\nI can visit All buldings from (1,1)[2,1, 2,2, 0,0, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 91\\nI can visit All buldings from (1,2)[2,1, 2,2, 3,3, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 84\\nI can visit All buldings from (1,3)[2,1, 3,3, 2,2, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 85\\nI can visit All buldings from (1,4)[2,1, 3,3, 2,2, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 92\\nI can visit All buldings from (2,0)[2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 95\\nI can visit All buldings from (2,3)[2,1, 3,3, 2,2, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 76\\nI can visit All buldings from (2,4)[2,1, 3,3, 2,2, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 83\\nI can visit All buldings from (3,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 79\\nI can visit All buldings from (3,2)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 72\\nI can visit All buldings from (3,4)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 80\\nI can visit All buldings from (4,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 82\\nI can visit All buldings from (4,3)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 76\\nI can visit All buldings from (4,4)[2,1, 5,5, 3,3, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 83\\nI can visit All buldings from (5,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 91\\nI can visit All buldings from (5,2)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 84\\nI can visit All buldings from (5,3)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 85\\nI can visit All buldings from (5,4)[2,1, 5,5, 3,3, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 92"
                    },
                    {
                        "username": "jonreiland",
                        "content": "It\\'s because the problem description is incorrect. It\\'s not the Manhattan Distance that should be used, but the number of steps."
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store all the paths from all the buildings to the shortest path on the grid?\\n\\nAny ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "brahma0545",
                        "content": "in this test case the answer is mentioned 88\\n[1,1,1,1,1,0],\\n[0,0,0,0,0,1],\\n[0,1,1,0,0,1],\\n[1,0,0,1,0,1],\\n[1,0,1,0,0,1],\\n[1,0,0,0,0,1],\\n[0,1,1,1,1,0]\\n\\nbut how come (0,5) is rechable from the nodes (0,0)?\\n\\nshouldn\\'t it be -1"
                    },
                    {
                        "username": "aivanilov",
                        "content": "[@NekoShadow](/NekoShadow) The problem is that there\\'s a solution in [3,2] with distance 72 (instead of 88)"
                    },
                    {
                        "username": "NekoShadow",
                        "content": "Yes, (0, 5) is not reachable from (0, 0). So (0, 5) should not be used for building your new house. Just build the house somewhere else. Remember, you goal is to look for an empty land that can reach all buildings with minimum total Manhattan distance, NOT making sure that all empty lands can be reached by every building :)"
                    }
                ]
            },
            {
                "id": 1576156,
                "content": [
                    {
                        "username": "giof07",
                        "content": "The problem says the distance from one point to another is the mahattan distance, this should make bfs impossible... I see no solution in the discussion using the mahattan distance. What is going here? Can someone explain? If we use the manhattan distance to calculate the distance between two points how can we detect if there is an obstacle between two 0\\'s? If we can only move point to point and count each move as one, the problem is trivial, but manhattan distance seems to imply diagonal movement."
                    },
                    {
                        "username": "jeffkmeng",
                        "content": "The distance between two points is calculated with the manhattan distance, but that assumes there are no obstacles in between. The definition of manhattan distance is just that you assume you were walking along city blocks, so you *can\\'t* move diagonally."
                    },
                    {
                        "username": "pppprinciple",
                        "content": "\"The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.\"\\n\\nPlease fix. Looking at the tests, distance is expected to be calculated as number of steps taken in a given path."
                    },
                    {
                        "username": "lc4tc",
                        "content": "Last two sentences of the problem were blindly copied from https://leetcode.com/problems/best-meeting-point/, lol"
                    },
                    {
                        "username": "wuyinan",
                        "content": "Update:\\nI think I misunderstood this problem... I thought it asks to find an empty location that has access to all the houses and has the smallest sum of manhattan distances to all the houses and return that sum. It actually asks for the smallest sum of total steps to all the houses not Manhattan distances.\\n\\n=============================================================================================\\nTest case:\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\nMy code found the position at (3,2) has the shortest sum of distance of 72:\\n\\nPosition: dist to house 1, house 2, ...., sum of distance: \\n\\n6,0 : 1 1  sum: 2\\n5,1 : 6 5 6 7 8 8 3 4 7 3 4 6 2 2 5 1 4 1 2 3 4  sum: 91\\n5,2 : 7 6 5 6 7 7 4 3 6 4 3 5 3 1 4 2 3 2 1 2 3  sum: 84\\n4,1 : 5 4 5 6 7 7 2 3 6 2 3 5 1 1 4 2 5 2 3 4 5  sum: 82\\n2,0 : 2 3 4 5 6 6 1 2 5 1 4 6 2 4 7 3 8 5 6 7 8  sum: 95\\n5,3 : 8 7 6 5 6 6 5 4 5 5 2 4 4 2 3 3 2 3 2 1 2  sum: 85\\n3,1 : 4 3 4 5 6 6 1 2 5 1 2 4 2 2 5 3 6 3 4 5 6  sum: 79\\n1,0 : 1 2 3 4 5 5 2 3 6 2 5 7 3 5 8 4 9 6 7 8 9  sum: 104\\n5,4 : 9 8 7 6 5 5 6 5 4 6 3 3 5 3 2 4 1 4 3 2 1  sum: 92\\n4,3 : 7 6 5 4 5 5 4 3 4 4 1 3 3 1 2 4 3 4 3 2 3  sum: 76\\n3,2 : 5 4 3 4 5 5 2 1 4 2 1 3 3 1 4 4 5 4 3 4 5  sum: 72\\n6,5 : 1 1  sum: 2\\n1,1 : 2 1 2 3 4 4 1 2 5 3 4 6 4 4 7 5 8 5 6 7 8  sum: 91\\n4,4 : 8 7 6 5 4 4 5 4 3 5 2 2 4 2 1 5 2 5 4 3 2  sum: 83\\n1,2 : 3 2 1 2 3 3 2 1 4 4 3 5 5 3 6 6 7 6 5 6 7  sum: 84\\n2,3 : 5 4 3 2 3 3 2 1 2 4 1 3 5 3 4 6 5 6 5 4 5  sum: 76\\n3,4 : 7 6 5 4 3 3 4 3 2 4 1 1 5 3 2 6 3 6 5 4 3  sum: 80\\n1,3 : 4 3 2 1 2 2 3 2 3 5 2 4 6 4 5 7 6 7 6 5 6  sum: 85\\n2,4 : 6 5 4 3 2 2 3 2 1 5 2 2 6 4 3 7 4 7 6 5 4  sum: 83\\n1,4 : 5 4 3 2 1 1 4 3 2 6 3 3 7 5 4 8 5 8 7 6 5  sum: 92\\n0,5 : 1 1  sum: 2"
                    },
                    {
                        "username": "aivanilov",
                        "content": "I\\'ve got 72 as well in this case. And I don\\'t get why it\\'s 88 in the answer."
                    },
                    {
                        "username": "shchybovyk",
                        "content": "I still don\\'t understand what is actually asked to find"
                    },
                    {
                        "username": "sanemiliano",
                        "content": "Terrible statement: \"The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|. FIX ASAP. Spent two hours debbuging because I calculate the mahattan distance and turns out the test cases expect the sum of the steps."
                    },
                    {
                        "username": "littlelionman1",
                        "content": "TY for helping me"
                    },
                    {
                        "username": "cosR",
                        "content": "To solve this question there are two approaches:\\n1. start bfs from empty position i.e. 0\\n2. start bfs from building position i.e. 1\\n\\nApproach 1 mostly ends up with time ~ 250 ms\\nApproach 2 however ends up with time ~30 ms\\n\\nIs this due to the fact that majority of the test cases have lesser 1s compared to 0s in the grid? What do you think?"
                    },
                    {
                        "username": "doublefat",
                        "content": "Return the shortest travel distance for such a house. If it is not possible to build such a house according to the above rules, return -1.\\n\\nThe total travel distance is the sum of the distances between the houses of the friends and the meeting point.\\n\\n**The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.**\\n\\ntest case :\\n\\n\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\n![image](https://assets.leetcode.com/users/images/e8af8452-9bcd-4b9c-95b2-c8a1254cc45e_1641067609.3005052.png)\\n\\n1 ,point [3,2] to building [0] [0] distance is 5 , total is 5\\n2 ,point [3,2] to building [0] [1] distance is 4 , total is 9\\n3 ,point [3,2] to building [0] [2] distance is 3 , total is 12\\n4 ,point [3,2] to building [0] [3] distance is 4 , total is 16\\n5 ,point [3,2] to building [0] [4] distance is 5 , total is 21\\n6 ,point [3,2] to building [1] [5] distance is 5 , total is 26\\n7 ,point [3,2] to building [2] [1] distance is 2 , total is 28\\n8 ,point [3,2] to building [2] [2] distance is 1 , total is 29\\n9 ,point [3,2] to building [2] [5] distance is 4 , total is 33\\n10 ,point [3,2] to building [3] [0] distance is 2 , total is 35\\n11 ,point [3,2] to building [3] [3] distance is 1 , total is 36\\n12 ,point [3,2] to building [3] [5] distance is 3 , total is 39\\n13 ,point [3,2] to building [4] [0] distance is 3 , total is 42\\n14 ,point [3,2] to building [4] [2] distance is 1 , total is 43\\n15 ,point [3,2] to building [4] [5] distance is 4 , total is 47\\n16 ,point [3,2] to building [5] [0] distance is 4 , total is 51\\n17 ,point [3,2] to building [5] [5] distance is 5 , total is 56\\n18 ,point [3,2] to building [6] [1] distance is 4 , total is 60\\n19 ,point [3,2] to building [6] [2] distance is 3 , total is 63\\n20 ,point [3,2] to building [6] [3] distance is 4 , total is 67\\n21 ,point [3,2] to building [6] [4] distance is 5 , total is 72\\n\\n![image](https://assets.leetcode.com/users/images/ce6c3d14-8826-4d86-864e-ab7806865d31_1641067774.8862677.png)\\n\\n\\n"
                    },
                    {
                        "username": "sabrinasong",
                        "content": "The question is almost the same as 296 except that here we have obstacles. In 296 we simply calculate its median, while here we have to use bfs. Can we do something on the basis of median solution?"
                    },
                    {
                        "username": "luckymaster",
                        "content": "How the distance is 88 for this test case.\\n\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\n\\nMine is 72,\\n\\nLeetcode 88;\\n\\n\\nBuildings = [2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 5,0, 6,1, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4] Size true\\nI can visit All buldings from (1,0)[2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 104\\nI can visit All buldings from (1,1)[2,1, 2,2, 0,0, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 91\\nI can visit All buldings from (1,2)[2,1, 2,2, 3,3, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 84\\nI can visit All buldings from (1,3)[2,1, 3,3, 2,2, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 85\\nI can visit All buldings from (1,4)[2,1, 3,3, 2,2, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 92\\nI can visit All buldings from (2,0)[2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 95\\nI can visit All buldings from (2,3)[2,1, 3,3, 2,2, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 76\\nI can visit All buldings from (2,4)[2,1, 3,3, 2,2, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 83\\nI can visit All buldings from (3,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 79\\nI can visit All buldings from (3,2)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 72\\nI can visit All buldings from (3,4)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 80\\nI can visit All buldings from (4,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 82\\nI can visit All buldings from (4,3)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 76\\nI can visit All buldings from (4,4)[2,1, 5,5, 3,3, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 83\\nI can visit All buldings from (5,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 91\\nI can visit All buldings from (5,2)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 84\\nI can visit All buldings from (5,3)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 85\\nI can visit All buldings from (5,4)[2,1, 5,5, 3,3, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 92"
                    },
                    {
                        "username": "jonreiland",
                        "content": "It\\'s because the problem description is incorrect. It\\'s not the Manhattan Distance that should be used, but the number of steps."
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store all the paths from all the buildings to the shortest path on the grid?\\n\\nAny ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "brahma0545",
                        "content": "in this test case the answer is mentioned 88\\n[1,1,1,1,1,0],\\n[0,0,0,0,0,1],\\n[0,1,1,0,0,1],\\n[1,0,0,1,0,1],\\n[1,0,1,0,0,1],\\n[1,0,0,0,0,1],\\n[0,1,1,1,1,0]\\n\\nbut how come (0,5) is rechable from the nodes (0,0)?\\n\\nshouldn\\'t it be -1"
                    },
                    {
                        "username": "aivanilov",
                        "content": "[@NekoShadow](/NekoShadow) The problem is that there\\'s a solution in [3,2] with distance 72 (instead of 88)"
                    },
                    {
                        "username": "NekoShadow",
                        "content": "Yes, (0, 5) is not reachable from (0, 0). So (0, 5) should not be used for building your new house. Just build the house somewhere else. Remember, you goal is to look for an empty land that can reach all buildings with minimum total Manhattan distance, NOT making sure that all empty lands can be reached by every building :)"
                    }
                ]
            },
            {
                "id": 1569069,
                "content": [
                    {
                        "username": "giof07",
                        "content": "The problem says the distance from one point to another is the mahattan distance, this should make bfs impossible... I see no solution in the discussion using the mahattan distance. What is going here? Can someone explain? If we use the manhattan distance to calculate the distance between two points how can we detect if there is an obstacle between two 0\\'s? If we can only move point to point and count each move as one, the problem is trivial, but manhattan distance seems to imply diagonal movement."
                    },
                    {
                        "username": "jeffkmeng",
                        "content": "The distance between two points is calculated with the manhattan distance, but that assumes there are no obstacles in between. The definition of manhattan distance is just that you assume you were walking along city blocks, so you *can\\'t* move diagonally."
                    },
                    {
                        "username": "pppprinciple",
                        "content": "\"The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.\"\\n\\nPlease fix. Looking at the tests, distance is expected to be calculated as number of steps taken in a given path."
                    },
                    {
                        "username": "lc4tc",
                        "content": "Last two sentences of the problem were blindly copied from https://leetcode.com/problems/best-meeting-point/, lol"
                    },
                    {
                        "username": "wuyinan",
                        "content": "Update:\\nI think I misunderstood this problem... I thought it asks to find an empty location that has access to all the houses and has the smallest sum of manhattan distances to all the houses and return that sum. It actually asks for the smallest sum of total steps to all the houses not Manhattan distances.\\n\\n=============================================================================================\\nTest case:\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\nMy code found the position at (3,2) has the shortest sum of distance of 72:\\n\\nPosition: dist to house 1, house 2, ...., sum of distance: \\n\\n6,0 : 1 1  sum: 2\\n5,1 : 6 5 6 7 8 8 3 4 7 3 4 6 2 2 5 1 4 1 2 3 4  sum: 91\\n5,2 : 7 6 5 6 7 7 4 3 6 4 3 5 3 1 4 2 3 2 1 2 3  sum: 84\\n4,1 : 5 4 5 6 7 7 2 3 6 2 3 5 1 1 4 2 5 2 3 4 5  sum: 82\\n2,0 : 2 3 4 5 6 6 1 2 5 1 4 6 2 4 7 3 8 5 6 7 8  sum: 95\\n5,3 : 8 7 6 5 6 6 5 4 5 5 2 4 4 2 3 3 2 3 2 1 2  sum: 85\\n3,1 : 4 3 4 5 6 6 1 2 5 1 2 4 2 2 5 3 6 3 4 5 6  sum: 79\\n1,0 : 1 2 3 4 5 5 2 3 6 2 5 7 3 5 8 4 9 6 7 8 9  sum: 104\\n5,4 : 9 8 7 6 5 5 6 5 4 6 3 3 5 3 2 4 1 4 3 2 1  sum: 92\\n4,3 : 7 6 5 4 5 5 4 3 4 4 1 3 3 1 2 4 3 4 3 2 3  sum: 76\\n3,2 : 5 4 3 4 5 5 2 1 4 2 1 3 3 1 4 4 5 4 3 4 5  sum: 72\\n6,5 : 1 1  sum: 2\\n1,1 : 2 1 2 3 4 4 1 2 5 3 4 6 4 4 7 5 8 5 6 7 8  sum: 91\\n4,4 : 8 7 6 5 4 4 5 4 3 5 2 2 4 2 1 5 2 5 4 3 2  sum: 83\\n1,2 : 3 2 1 2 3 3 2 1 4 4 3 5 5 3 6 6 7 6 5 6 7  sum: 84\\n2,3 : 5 4 3 2 3 3 2 1 2 4 1 3 5 3 4 6 5 6 5 4 5  sum: 76\\n3,4 : 7 6 5 4 3 3 4 3 2 4 1 1 5 3 2 6 3 6 5 4 3  sum: 80\\n1,3 : 4 3 2 1 2 2 3 2 3 5 2 4 6 4 5 7 6 7 6 5 6  sum: 85\\n2,4 : 6 5 4 3 2 2 3 2 1 5 2 2 6 4 3 7 4 7 6 5 4  sum: 83\\n1,4 : 5 4 3 2 1 1 4 3 2 6 3 3 7 5 4 8 5 8 7 6 5  sum: 92\\n0,5 : 1 1  sum: 2"
                    },
                    {
                        "username": "aivanilov",
                        "content": "I\\'ve got 72 as well in this case. And I don\\'t get why it\\'s 88 in the answer."
                    },
                    {
                        "username": "shchybovyk",
                        "content": "I still don\\'t understand what is actually asked to find"
                    },
                    {
                        "username": "sanemiliano",
                        "content": "Terrible statement: \"The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|. FIX ASAP. Spent two hours debbuging because I calculate the mahattan distance and turns out the test cases expect the sum of the steps."
                    },
                    {
                        "username": "littlelionman1",
                        "content": "TY for helping me"
                    },
                    {
                        "username": "cosR",
                        "content": "To solve this question there are two approaches:\\n1. start bfs from empty position i.e. 0\\n2. start bfs from building position i.e. 1\\n\\nApproach 1 mostly ends up with time ~ 250 ms\\nApproach 2 however ends up with time ~30 ms\\n\\nIs this due to the fact that majority of the test cases have lesser 1s compared to 0s in the grid? What do you think?"
                    },
                    {
                        "username": "doublefat",
                        "content": "Return the shortest travel distance for such a house. If it is not possible to build such a house according to the above rules, return -1.\\n\\nThe total travel distance is the sum of the distances between the houses of the friends and the meeting point.\\n\\n**The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.**\\n\\ntest case :\\n\\n\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\n![image](https://assets.leetcode.com/users/images/e8af8452-9bcd-4b9c-95b2-c8a1254cc45e_1641067609.3005052.png)\\n\\n1 ,point [3,2] to building [0] [0] distance is 5 , total is 5\\n2 ,point [3,2] to building [0] [1] distance is 4 , total is 9\\n3 ,point [3,2] to building [0] [2] distance is 3 , total is 12\\n4 ,point [3,2] to building [0] [3] distance is 4 , total is 16\\n5 ,point [3,2] to building [0] [4] distance is 5 , total is 21\\n6 ,point [3,2] to building [1] [5] distance is 5 , total is 26\\n7 ,point [3,2] to building [2] [1] distance is 2 , total is 28\\n8 ,point [3,2] to building [2] [2] distance is 1 , total is 29\\n9 ,point [3,2] to building [2] [5] distance is 4 , total is 33\\n10 ,point [3,2] to building [3] [0] distance is 2 , total is 35\\n11 ,point [3,2] to building [3] [3] distance is 1 , total is 36\\n12 ,point [3,2] to building [3] [5] distance is 3 , total is 39\\n13 ,point [3,2] to building [4] [0] distance is 3 , total is 42\\n14 ,point [3,2] to building [4] [2] distance is 1 , total is 43\\n15 ,point [3,2] to building [4] [5] distance is 4 , total is 47\\n16 ,point [3,2] to building [5] [0] distance is 4 , total is 51\\n17 ,point [3,2] to building [5] [5] distance is 5 , total is 56\\n18 ,point [3,2] to building [6] [1] distance is 4 , total is 60\\n19 ,point [3,2] to building [6] [2] distance is 3 , total is 63\\n20 ,point [3,2] to building [6] [3] distance is 4 , total is 67\\n21 ,point [3,2] to building [6] [4] distance is 5 , total is 72\\n\\n![image](https://assets.leetcode.com/users/images/ce6c3d14-8826-4d86-864e-ab7806865d31_1641067774.8862677.png)\\n\\n\\n"
                    },
                    {
                        "username": "sabrinasong",
                        "content": "The question is almost the same as 296 except that here we have obstacles. In 296 we simply calculate its median, while here we have to use bfs. Can we do something on the basis of median solution?"
                    },
                    {
                        "username": "luckymaster",
                        "content": "How the distance is 88 for this test case.\\n\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\n\\nMine is 72,\\n\\nLeetcode 88;\\n\\n\\nBuildings = [2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 5,0, 6,1, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4] Size true\\nI can visit All buldings from (1,0)[2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 104\\nI can visit All buldings from (1,1)[2,1, 2,2, 0,0, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 91\\nI can visit All buldings from (1,2)[2,1, 2,2, 3,3, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 84\\nI can visit All buldings from (1,3)[2,1, 3,3, 2,2, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 85\\nI can visit All buldings from (1,4)[2,1, 3,3, 2,2, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 92\\nI can visit All buldings from (2,0)[2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 95\\nI can visit All buldings from (2,3)[2,1, 3,3, 2,2, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 76\\nI can visit All buldings from (2,4)[2,1, 3,3, 2,2, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 83\\nI can visit All buldings from (3,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 79\\nI can visit All buldings from (3,2)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 72\\nI can visit All buldings from (3,4)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 80\\nI can visit All buldings from (4,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 82\\nI can visit All buldings from (4,3)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 76\\nI can visit All buldings from (4,4)[2,1, 5,5, 3,3, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 83\\nI can visit All buldings from (5,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 91\\nI can visit All buldings from (5,2)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 84\\nI can visit All buldings from (5,3)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 85\\nI can visit All buldings from (5,4)[2,1, 5,5, 3,3, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 92"
                    },
                    {
                        "username": "jonreiland",
                        "content": "It\\'s because the problem description is incorrect. It\\'s not the Manhattan Distance that should be used, but the number of steps."
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store all the paths from all the buildings to the shortest path on the grid?\\n\\nAny ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "brahma0545",
                        "content": "in this test case the answer is mentioned 88\\n[1,1,1,1,1,0],\\n[0,0,0,0,0,1],\\n[0,1,1,0,0,1],\\n[1,0,0,1,0,1],\\n[1,0,1,0,0,1],\\n[1,0,0,0,0,1],\\n[0,1,1,1,1,0]\\n\\nbut how come (0,5) is rechable from the nodes (0,0)?\\n\\nshouldn\\'t it be -1"
                    },
                    {
                        "username": "aivanilov",
                        "content": "[@NekoShadow](/NekoShadow) The problem is that there\\'s a solution in [3,2] with distance 72 (instead of 88)"
                    },
                    {
                        "username": "NekoShadow",
                        "content": "Yes, (0, 5) is not reachable from (0, 0). So (0, 5) should not be used for building your new house. Just build the house somewhere else. Remember, you goal is to look for an empty land that can reach all buildings with minimum total Manhattan distance, NOT making sure that all empty lands can be reached by every building :)"
                    }
                ]
            },
            {
                "id": 1714386,
                "content": [
                    {
                        "username": "giof07",
                        "content": "The problem says the distance from one point to another is the mahattan distance, this should make bfs impossible... I see no solution in the discussion using the mahattan distance. What is going here? Can someone explain? If we use the manhattan distance to calculate the distance between two points how can we detect if there is an obstacle between two 0\\'s? If we can only move point to point and count each move as one, the problem is trivial, but manhattan distance seems to imply diagonal movement."
                    },
                    {
                        "username": "jeffkmeng",
                        "content": "The distance between two points is calculated with the manhattan distance, but that assumes there are no obstacles in between. The definition of manhattan distance is just that you assume you were walking along city blocks, so you *can\\'t* move diagonally."
                    },
                    {
                        "username": "pppprinciple",
                        "content": "\"The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.\"\\n\\nPlease fix. Looking at the tests, distance is expected to be calculated as number of steps taken in a given path."
                    },
                    {
                        "username": "lc4tc",
                        "content": "Last two sentences of the problem were blindly copied from https://leetcode.com/problems/best-meeting-point/, lol"
                    },
                    {
                        "username": "wuyinan",
                        "content": "Update:\\nI think I misunderstood this problem... I thought it asks to find an empty location that has access to all the houses and has the smallest sum of manhattan distances to all the houses and return that sum. It actually asks for the smallest sum of total steps to all the houses not Manhattan distances.\\n\\n=============================================================================================\\nTest case:\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\nMy code found the position at (3,2) has the shortest sum of distance of 72:\\n\\nPosition: dist to house 1, house 2, ...., sum of distance: \\n\\n6,0 : 1 1  sum: 2\\n5,1 : 6 5 6 7 8 8 3 4 7 3 4 6 2 2 5 1 4 1 2 3 4  sum: 91\\n5,2 : 7 6 5 6 7 7 4 3 6 4 3 5 3 1 4 2 3 2 1 2 3  sum: 84\\n4,1 : 5 4 5 6 7 7 2 3 6 2 3 5 1 1 4 2 5 2 3 4 5  sum: 82\\n2,0 : 2 3 4 5 6 6 1 2 5 1 4 6 2 4 7 3 8 5 6 7 8  sum: 95\\n5,3 : 8 7 6 5 6 6 5 4 5 5 2 4 4 2 3 3 2 3 2 1 2  sum: 85\\n3,1 : 4 3 4 5 6 6 1 2 5 1 2 4 2 2 5 3 6 3 4 5 6  sum: 79\\n1,0 : 1 2 3 4 5 5 2 3 6 2 5 7 3 5 8 4 9 6 7 8 9  sum: 104\\n5,4 : 9 8 7 6 5 5 6 5 4 6 3 3 5 3 2 4 1 4 3 2 1  sum: 92\\n4,3 : 7 6 5 4 5 5 4 3 4 4 1 3 3 1 2 4 3 4 3 2 3  sum: 76\\n3,2 : 5 4 3 4 5 5 2 1 4 2 1 3 3 1 4 4 5 4 3 4 5  sum: 72\\n6,5 : 1 1  sum: 2\\n1,1 : 2 1 2 3 4 4 1 2 5 3 4 6 4 4 7 5 8 5 6 7 8  sum: 91\\n4,4 : 8 7 6 5 4 4 5 4 3 5 2 2 4 2 1 5 2 5 4 3 2  sum: 83\\n1,2 : 3 2 1 2 3 3 2 1 4 4 3 5 5 3 6 6 7 6 5 6 7  sum: 84\\n2,3 : 5 4 3 2 3 3 2 1 2 4 1 3 5 3 4 6 5 6 5 4 5  sum: 76\\n3,4 : 7 6 5 4 3 3 4 3 2 4 1 1 5 3 2 6 3 6 5 4 3  sum: 80\\n1,3 : 4 3 2 1 2 2 3 2 3 5 2 4 6 4 5 7 6 7 6 5 6  sum: 85\\n2,4 : 6 5 4 3 2 2 3 2 1 5 2 2 6 4 3 7 4 7 6 5 4  sum: 83\\n1,4 : 5 4 3 2 1 1 4 3 2 6 3 3 7 5 4 8 5 8 7 6 5  sum: 92\\n0,5 : 1 1  sum: 2"
                    },
                    {
                        "username": "aivanilov",
                        "content": "I\\'ve got 72 as well in this case. And I don\\'t get why it\\'s 88 in the answer."
                    },
                    {
                        "username": "shchybovyk",
                        "content": "I still don\\'t understand what is actually asked to find"
                    },
                    {
                        "username": "sanemiliano",
                        "content": "Terrible statement: \"The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|. FIX ASAP. Spent two hours debbuging because I calculate the mahattan distance and turns out the test cases expect the sum of the steps."
                    },
                    {
                        "username": "littlelionman1",
                        "content": "TY for helping me"
                    },
                    {
                        "username": "cosR",
                        "content": "To solve this question there are two approaches:\\n1. start bfs from empty position i.e. 0\\n2. start bfs from building position i.e. 1\\n\\nApproach 1 mostly ends up with time ~ 250 ms\\nApproach 2 however ends up with time ~30 ms\\n\\nIs this due to the fact that majority of the test cases have lesser 1s compared to 0s in the grid? What do you think?"
                    },
                    {
                        "username": "doublefat",
                        "content": "Return the shortest travel distance for such a house. If it is not possible to build such a house according to the above rules, return -1.\\n\\nThe total travel distance is the sum of the distances between the houses of the friends and the meeting point.\\n\\n**The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.**\\n\\ntest case :\\n\\n\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\n![image](https://assets.leetcode.com/users/images/e8af8452-9bcd-4b9c-95b2-c8a1254cc45e_1641067609.3005052.png)\\n\\n1 ,point [3,2] to building [0] [0] distance is 5 , total is 5\\n2 ,point [3,2] to building [0] [1] distance is 4 , total is 9\\n3 ,point [3,2] to building [0] [2] distance is 3 , total is 12\\n4 ,point [3,2] to building [0] [3] distance is 4 , total is 16\\n5 ,point [3,2] to building [0] [4] distance is 5 , total is 21\\n6 ,point [3,2] to building [1] [5] distance is 5 , total is 26\\n7 ,point [3,2] to building [2] [1] distance is 2 , total is 28\\n8 ,point [3,2] to building [2] [2] distance is 1 , total is 29\\n9 ,point [3,2] to building [2] [5] distance is 4 , total is 33\\n10 ,point [3,2] to building [3] [0] distance is 2 , total is 35\\n11 ,point [3,2] to building [3] [3] distance is 1 , total is 36\\n12 ,point [3,2] to building [3] [5] distance is 3 , total is 39\\n13 ,point [3,2] to building [4] [0] distance is 3 , total is 42\\n14 ,point [3,2] to building [4] [2] distance is 1 , total is 43\\n15 ,point [3,2] to building [4] [5] distance is 4 , total is 47\\n16 ,point [3,2] to building [5] [0] distance is 4 , total is 51\\n17 ,point [3,2] to building [5] [5] distance is 5 , total is 56\\n18 ,point [3,2] to building [6] [1] distance is 4 , total is 60\\n19 ,point [3,2] to building [6] [2] distance is 3 , total is 63\\n20 ,point [3,2] to building [6] [3] distance is 4 , total is 67\\n21 ,point [3,2] to building [6] [4] distance is 5 , total is 72\\n\\n![image](https://assets.leetcode.com/users/images/ce6c3d14-8826-4d86-864e-ab7806865d31_1641067774.8862677.png)\\n\\n\\n"
                    },
                    {
                        "username": "sabrinasong",
                        "content": "The question is almost the same as 296 except that here we have obstacles. In 296 we simply calculate its median, while here we have to use bfs. Can we do something on the basis of median solution?"
                    },
                    {
                        "username": "luckymaster",
                        "content": "How the distance is 88 for this test case.\\n\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\n\\nMine is 72,\\n\\nLeetcode 88;\\n\\n\\nBuildings = [2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 5,0, 6,1, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4] Size true\\nI can visit All buldings from (1,0)[2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 104\\nI can visit All buldings from (1,1)[2,1, 2,2, 0,0, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 91\\nI can visit All buldings from (1,2)[2,1, 2,2, 3,3, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 84\\nI can visit All buldings from (1,3)[2,1, 3,3, 2,2, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 85\\nI can visit All buldings from (1,4)[2,1, 3,3, 2,2, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 92\\nI can visit All buldings from (2,0)[2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 95\\nI can visit All buldings from (2,3)[2,1, 3,3, 2,2, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 76\\nI can visit All buldings from (2,4)[2,1, 3,3, 2,2, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 83\\nI can visit All buldings from (3,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 79\\nI can visit All buldings from (3,2)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 72\\nI can visit All buldings from (3,4)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 80\\nI can visit All buldings from (4,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 82\\nI can visit All buldings from (4,3)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 76\\nI can visit All buldings from (4,4)[2,1, 5,5, 3,3, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 83\\nI can visit All buldings from (5,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 91\\nI can visit All buldings from (5,2)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 84\\nI can visit All buldings from (5,3)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 85\\nI can visit All buldings from (5,4)[2,1, 5,5, 3,3, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 92"
                    },
                    {
                        "username": "jonreiland",
                        "content": "It\\'s because the problem description is incorrect. It\\'s not the Manhattan Distance that should be used, but the number of steps."
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store all the paths from all the buildings to the shortest path on the grid?\\n\\nAny ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "brahma0545",
                        "content": "in this test case the answer is mentioned 88\\n[1,1,1,1,1,0],\\n[0,0,0,0,0,1],\\n[0,1,1,0,0,1],\\n[1,0,0,1,0,1],\\n[1,0,1,0,0,1],\\n[1,0,0,0,0,1],\\n[0,1,1,1,1,0]\\n\\nbut how come (0,5) is rechable from the nodes (0,0)?\\n\\nshouldn\\'t it be -1"
                    },
                    {
                        "username": "aivanilov",
                        "content": "[@NekoShadow](/NekoShadow) The problem is that there\\'s a solution in [3,2] with distance 72 (instead of 88)"
                    },
                    {
                        "username": "NekoShadow",
                        "content": "Yes, (0, 5) is not reachable from (0, 0). So (0, 5) should not be used for building your new house. Just build the house somewhere else. Remember, you goal is to look for an empty land that can reach all buildings with minimum total Manhattan distance, NOT making sure that all empty lands can be reached by every building :)"
                    }
                ]
            },
            {
                "id": 1573485,
                "content": [
                    {
                        "username": "giof07",
                        "content": "The problem says the distance from one point to another is the mahattan distance, this should make bfs impossible... I see no solution in the discussion using the mahattan distance. What is going here? Can someone explain? If we use the manhattan distance to calculate the distance between two points how can we detect if there is an obstacle between two 0\\'s? If we can only move point to point and count each move as one, the problem is trivial, but manhattan distance seems to imply diagonal movement."
                    },
                    {
                        "username": "jeffkmeng",
                        "content": "The distance between two points is calculated with the manhattan distance, but that assumes there are no obstacles in between. The definition of manhattan distance is just that you assume you were walking along city blocks, so you *can\\'t* move diagonally."
                    },
                    {
                        "username": "pppprinciple",
                        "content": "\"The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.\"\\n\\nPlease fix. Looking at the tests, distance is expected to be calculated as number of steps taken in a given path."
                    },
                    {
                        "username": "lc4tc",
                        "content": "Last two sentences of the problem were blindly copied from https://leetcode.com/problems/best-meeting-point/, lol"
                    },
                    {
                        "username": "wuyinan",
                        "content": "Update:\\nI think I misunderstood this problem... I thought it asks to find an empty location that has access to all the houses and has the smallest sum of manhattan distances to all the houses and return that sum. It actually asks for the smallest sum of total steps to all the houses not Manhattan distances.\\n\\n=============================================================================================\\nTest case:\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\nMy code found the position at (3,2) has the shortest sum of distance of 72:\\n\\nPosition: dist to house 1, house 2, ...., sum of distance: \\n\\n6,0 : 1 1  sum: 2\\n5,1 : 6 5 6 7 8 8 3 4 7 3 4 6 2 2 5 1 4 1 2 3 4  sum: 91\\n5,2 : 7 6 5 6 7 7 4 3 6 4 3 5 3 1 4 2 3 2 1 2 3  sum: 84\\n4,1 : 5 4 5 6 7 7 2 3 6 2 3 5 1 1 4 2 5 2 3 4 5  sum: 82\\n2,0 : 2 3 4 5 6 6 1 2 5 1 4 6 2 4 7 3 8 5 6 7 8  sum: 95\\n5,3 : 8 7 6 5 6 6 5 4 5 5 2 4 4 2 3 3 2 3 2 1 2  sum: 85\\n3,1 : 4 3 4 5 6 6 1 2 5 1 2 4 2 2 5 3 6 3 4 5 6  sum: 79\\n1,0 : 1 2 3 4 5 5 2 3 6 2 5 7 3 5 8 4 9 6 7 8 9  sum: 104\\n5,4 : 9 8 7 6 5 5 6 5 4 6 3 3 5 3 2 4 1 4 3 2 1  sum: 92\\n4,3 : 7 6 5 4 5 5 4 3 4 4 1 3 3 1 2 4 3 4 3 2 3  sum: 76\\n3,2 : 5 4 3 4 5 5 2 1 4 2 1 3 3 1 4 4 5 4 3 4 5  sum: 72\\n6,5 : 1 1  sum: 2\\n1,1 : 2 1 2 3 4 4 1 2 5 3 4 6 4 4 7 5 8 5 6 7 8  sum: 91\\n4,4 : 8 7 6 5 4 4 5 4 3 5 2 2 4 2 1 5 2 5 4 3 2  sum: 83\\n1,2 : 3 2 1 2 3 3 2 1 4 4 3 5 5 3 6 6 7 6 5 6 7  sum: 84\\n2,3 : 5 4 3 2 3 3 2 1 2 4 1 3 5 3 4 6 5 6 5 4 5  sum: 76\\n3,4 : 7 6 5 4 3 3 4 3 2 4 1 1 5 3 2 6 3 6 5 4 3  sum: 80\\n1,3 : 4 3 2 1 2 2 3 2 3 5 2 4 6 4 5 7 6 7 6 5 6  sum: 85\\n2,4 : 6 5 4 3 2 2 3 2 1 5 2 2 6 4 3 7 4 7 6 5 4  sum: 83\\n1,4 : 5 4 3 2 1 1 4 3 2 6 3 3 7 5 4 8 5 8 7 6 5  sum: 92\\n0,5 : 1 1  sum: 2"
                    },
                    {
                        "username": "aivanilov",
                        "content": "I\\'ve got 72 as well in this case. And I don\\'t get why it\\'s 88 in the answer."
                    },
                    {
                        "username": "shchybovyk",
                        "content": "I still don\\'t understand what is actually asked to find"
                    },
                    {
                        "username": "sanemiliano",
                        "content": "Terrible statement: \"The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|. FIX ASAP. Spent two hours debbuging because I calculate the mahattan distance and turns out the test cases expect the sum of the steps."
                    },
                    {
                        "username": "littlelionman1",
                        "content": "TY for helping me"
                    },
                    {
                        "username": "cosR",
                        "content": "To solve this question there are two approaches:\\n1. start bfs from empty position i.e. 0\\n2. start bfs from building position i.e. 1\\n\\nApproach 1 mostly ends up with time ~ 250 ms\\nApproach 2 however ends up with time ~30 ms\\n\\nIs this due to the fact that majority of the test cases have lesser 1s compared to 0s in the grid? What do you think?"
                    },
                    {
                        "username": "doublefat",
                        "content": "Return the shortest travel distance for such a house. If it is not possible to build such a house according to the above rules, return -1.\\n\\nThe total travel distance is the sum of the distances between the houses of the friends and the meeting point.\\n\\n**The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.**\\n\\ntest case :\\n\\n\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\n![image](https://assets.leetcode.com/users/images/e8af8452-9bcd-4b9c-95b2-c8a1254cc45e_1641067609.3005052.png)\\n\\n1 ,point [3,2] to building [0] [0] distance is 5 , total is 5\\n2 ,point [3,2] to building [0] [1] distance is 4 , total is 9\\n3 ,point [3,2] to building [0] [2] distance is 3 , total is 12\\n4 ,point [3,2] to building [0] [3] distance is 4 , total is 16\\n5 ,point [3,2] to building [0] [4] distance is 5 , total is 21\\n6 ,point [3,2] to building [1] [5] distance is 5 , total is 26\\n7 ,point [3,2] to building [2] [1] distance is 2 , total is 28\\n8 ,point [3,2] to building [2] [2] distance is 1 , total is 29\\n9 ,point [3,2] to building [2] [5] distance is 4 , total is 33\\n10 ,point [3,2] to building [3] [0] distance is 2 , total is 35\\n11 ,point [3,2] to building [3] [3] distance is 1 , total is 36\\n12 ,point [3,2] to building [3] [5] distance is 3 , total is 39\\n13 ,point [3,2] to building [4] [0] distance is 3 , total is 42\\n14 ,point [3,2] to building [4] [2] distance is 1 , total is 43\\n15 ,point [3,2] to building [4] [5] distance is 4 , total is 47\\n16 ,point [3,2] to building [5] [0] distance is 4 , total is 51\\n17 ,point [3,2] to building [5] [5] distance is 5 , total is 56\\n18 ,point [3,2] to building [6] [1] distance is 4 , total is 60\\n19 ,point [3,2] to building [6] [2] distance is 3 , total is 63\\n20 ,point [3,2] to building [6] [3] distance is 4 , total is 67\\n21 ,point [3,2] to building [6] [4] distance is 5 , total is 72\\n\\n![image](https://assets.leetcode.com/users/images/ce6c3d14-8826-4d86-864e-ab7806865d31_1641067774.8862677.png)\\n\\n\\n"
                    },
                    {
                        "username": "sabrinasong",
                        "content": "The question is almost the same as 296 except that here we have obstacles. In 296 we simply calculate its median, while here we have to use bfs. Can we do something on the basis of median solution?"
                    },
                    {
                        "username": "luckymaster",
                        "content": "How the distance is 88 for this test case.\\n\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\n\\nMine is 72,\\n\\nLeetcode 88;\\n\\n\\nBuildings = [2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 5,0, 6,1, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4] Size true\\nI can visit All buldings from (1,0)[2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 104\\nI can visit All buldings from (1,1)[2,1, 2,2, 0,0, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 91\\nI can visit All buldings from (1,2)[2,1, 2,2, 3,3, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 84\\nI can visit All buldings from (1,3)[2,1, 3,3, 2,2, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 85\\nI can visit All buldings from (1,4)[2,1, 3,3, 2,2, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 92\\nI can visit All buldings from (2,0)[2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 95\\nI can visit All buldings from (2,3)[2,1, 3,3, 2,2, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 76\\nI can visit All buldings from (2,4)[2,1, 3,3, 2,2, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 83\\nI can visit All buldings from (3,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 79\\nI can visit All buldings from (3,2)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 72\\nI can visit All buldings from (3,4)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 80\\nI can visit All buldings from (4,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 82\\nI can visit All buldings from (4,3)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 76\\nI can visit All buldings from (4,4)[2,1, 5,5, 3,3, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 83\\nI can visit All buldings from (5,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 91\\nI can visit All buldings from (5,2)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 84\\nI can visit All buldings from (5,3)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 85\\nI can visit All buldings from (5,4)[2,1, 5,5, 3,3, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 92"
                    },
                    {
                        "username": "jonreiland",
                        "content": "It\\'s because the problem description is incorrect. It\\'s not the Manhattan Distance that should be used, but the number of steps."
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store all the paths from all the buildings to the shortest path on the grid?\\n\\nAny ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "brahma0545",
                        "content": "in this test case the answer is mentioned 88\\n[1,1,1,1,1,0],\\n[0,0,0,0,0,1],\\n[0,1,1,0,0,1],\\n[1,0,0,1,0,1],\\n[1,0,1,0,0,1],\\n[1,0,0,0,0,1],\\n[0,1,1,1,1,0]\\n\\nbut how come (0,5) is rechable from the nodes (0,0)?\\n\\nshouldn\\'t it be -1"
                    },
                    {
                        "username": "aivanilov",
                        "content": "[@NekoShadow](/NekoShadow) The problem is that there\\'s a solution in [3,2] with distance 72 (instead of 88)"
                    },
                    {
                        "username": "NekoShadow",
                        "content": "Yes, (0, 5) is not reachable from (0, 0). So (0, 5) should not be used for building your new house. Just build the house somewhere else. Remember, you goal is to look for an empty land that can reach all buildings with minimum total Manhattan distance, NOT making sure that all empty lands can be reached by every building :)"
                    }
                ]
            },
            {
                "id": 1575492,
                "content": [
                    {
                        "username": "giof07",
                        "content": "The problem says the distance from one point to another is the mahattan distance, this should make bfs impossible... I see no solution in the discussion using the mahattan distance. What is going here? Can someone explain? If we use the manhattan distance to calculate the distance between two points how can we detect if there is an obstacle between two 0\\'s? If we can only move point to point and count each move as one, the problem is trivial, but manhattan distance seems to imply diagonal movement."
                    },
                    {
                        "username": "jeffkmeng",
                        "content": "The distance between two points is calculated with the manhattan distance, but that assumes there are no obstacles in between. The definition of manhattan distance is just that you assume you were walking along city blocks, so you *can\\'t* move diagonally."
                    },
                    {
                        "username": "pppprinciple",
                        "content": "\"The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.\"\\n\\nPlease fix. Looking at the tests, distance is expected to be calculated as number of steps taken in a given path."
                    },
                    {
                        "username": "lc4tc",
                        "content": "Last two sentences of the problem were blindly copied from https://leetcode.com/problems/best-meeting-point/, lol"
                    },
                    {
                        "username": "wuyinan",
                        "content": "Update:\\nI think I misunderstood this problem... I thought it asks to find an empty location that has access to all the houses and has the smallest sum of manhattan distances to all the houses and return that sum. It actually asks for the smallest sum of total steps to all the houses not Manhattan distances.\\n\\n=============================================================================================\\nTest case:\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\nMy code found the position at (3,2) has the shortest sum of distance of 72:\\n\\nPosition: dist to house 1, house 2, ...., sum of distance: \\n\\n6,0 : 1 1  sum: 2\\n5,1 : 6 5 6 7 8 8 3 4 7 3 4 6 2 2 5 1 4 1 2 3 4  sum: 91\\n5,2 : 7 6 5 6 7 7 4 3 6 4 3 5 3 1 4 2 3 2 1 2 3  sum: 84\\n4,1 : 5 4 5 6 7 7 2 3 6 2 3 5 1 1 4 2 5 2 3 4 5  sum: 82\\n2,0 : 2 3 4 5 6 6 1 2 5 1 4 6 2 4 7 3 8 5 6 7 8  sum: 95\\n5,3 : 8 7 6 5 6 6 5 4 5 5 2 4 4 2 3 3 2 3 2 1 2  sum: 85\\n3,1 : 4 3 4 5 6 6 1 2 5 1 2 4 2 2 5 3 6 3 4 5 6  sum: 79\\n1,0 : 1 2 3 4 5 5 2 3 6 2 5 7 3 5 8 4 9 6 7 8 9  sum: 104\\n5,4 : 9 8 7 6 5 5 6 5 4 6 3 3 5 3 2 4 1 4 3 2 1  sum: 92\\n4,3 : 7 6 5 4 5 5 4 3 4 4 1 3 3 1 2 4 3 4 3 2 3  sum: 76\\n3,2 : 5 4 3 4 5 5 2 1 4 2 1 3 3 1 4 4 5 4 3 4 5  sum: 72\\n6,5 : 1 1  sum: 2\\n1,1 : 2 1 2 3 4 4 1 2 5 3 4 6 4 4 7 5 8 5 6 7 8  sum: 91\\n4,4 : 8 7 6 5 4 4 5 4 3 5 2 2 4 2 1 5 2 5 4 3 2  sum: 83\\n1,2 : 3 2 1 2 3 3 2 1 4 4 3 5 5 3 6 6 7 6 5 6 7  sum: 84\\n2,3 : 5 4 3 2 3 3 2 1 2 4 1 3 5 3 4 6 5 6 5 4 5  sum: 76\\n3,4 : 7 6 5 4 3 3 4 3 2 4 1 1 5 3 2 6 3 6 5 4 3  sum: 80\\n1,3 : 4 3 2 1 2 2 3 2 3 5 2 4 6 4 5 7 6 7 6 5 6  sum: 85\\n2,4 : 6 5 4 3 2 2 3 2 1 5 2 2 6 4 3 7 4 7 6 5 4  sum: 83\\n1,4 : 5 4 3 2 1 1 4 3 2 6 3 3 7 5 4 8 5 8 7 6 5  sum: 92\\n0,5 : 1 1  sum: 2"
                    },
                    {
                        "username": "aivanilov",
                        "content": "I\\'ve got 72 as well in this case. And I don\\'t get why it\\'s 88 in the answer."
                    },
                    {
                        "username": "shchybovyk",
                        "content": "I still don\\'t understand what is actually asked to find"
                    },
                    {
                        "username": "sanemiliano",
                        "content": "Terrible statement: \"The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|. FIX ASAP. Spent two hours debbuging because I calculate the mahattan distance and turns out the test cases expect the sum of the steps."
                    },
                    {
                        "username": "littlelionman1",
                        "content": "TY for helping me"
                    },
                    {
                        "username": "cosR",
                        "content": "To solve this question there are two approaches:\\n1. start bfs from empty position i.e. 0\\n2. start bfs from building position i.e. 1\\n\\nApproach 1 mostly ends up with time ~ 250 ms\\nApproach 2 however ends up with time ~30 ms\\n\\nIs this due to the fact that majority of the test cases have lesser 1s compared to 0s in the grid? What do you think?"
                    },
                    {
                        "username": "doublefat",
                        "content": "Return the shortest travel distance for such a house. If it is not possible to build such a house according to the above rules, return -1.\\n\\nThe total travel distance is the sum of the distances between the houses of the friends and the meeting point.\\n\\n**The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.**\\n\\ntest case :\\n\\n\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\n![image](https://assets.leetcode.com/users/images/e8af8452-9bcd-4b9c-95b2-c8a1254cc45e_1641067609.3005052.png)\\n\\n1 ,point [3,2] to building [0] [0] distance is 5 , total is 5\\n2 ,point [3,2] to building [0] [1] distance is 4 , total is 9\\n3 ,point [3,2] to building [0] [2] distance is 3 , total is 12\\n4 ,point [3,2] to building [0] [3] distance is 4 , total is 16\\n5 ,point [3,2] to building [0] [4] distance is 5 , total is 21\\n6 ,point [3,2] to building [1] [5] distance is 5 , total is 26\\n7 ,point [3,2] to building [2] [1] distance is 2 , total is 28\\n8 ,point [3,2] to building [2] [2] distance is 1 , total is 29\\n9 ,point [3,2] to building [2] [5] distance is 4 , total is 33\\n10 ,point [3,2] to building [3] [0] distance is 2 , total is 35\\n11 ,point [3,2] to building [3] [3] distance is 1 , total is 36\\n12 ,point [3,2] to building [3] [5] distance is 3 , total is 39\\n13 ,point [3,2] to building [4] [0] distance is 3 , total is 42\\n14 ,point [3,2] to building [4] [2] distance is 1 , total is 43\\n15 ,point [3,2] to building [4] [5] distance is 4 , total is 47\\n16 ,point [3,2] to building [5] [0] distance is 4 , total is 51\\n17 ,point [3,2] to building [5] [5] distance is 5 , total is 56\\n18 ,point [3,2] to building [6] [1] distance is 4 , total is 60\\n19 ,point [3,2] to building [6] [2] distance is 3 , total is 63\\n20 ,point [3,2] to building [6] [3] distance is 4 , total is 67\\n21 ,point [3,2] to building [6] [4] distance is 5 , total is 72\\n\\n![image](https://assets.leetcode.com/users/images/ce6c3d14-8826-4d86-864e-ab7806865d31_1641067774.8862677.png)\\n\\n\\n"
                    },
                    {
                        "username": "sabrinasong",
                        "content": "The question is almost the same as 296 except that here we have obstacles. In 296 we simply calculate its median, while here we have to use bfs. Can we do something on the basis of median solution?"
                    },
                    {
                        "username": "luckymaster",
                        "content": "How the distance is 88 for this test case.\\n\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\n\\nMine is 72,\\n\\nLeetcode 88;\\n\\n\\nBuildings = [2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 5,0, 6,1, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4] Size true\\nI can visit All buldings from (1,0)[2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 104\\nI can visit All buldings from (1,1)[2,1, 2,2, 0,0, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 91\\nI can visit All buldings from (1,2)[2,1, 2,2, 3,3, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 84\\nI can visit All buldings from (1,3)[2,1, 3,3, 2,2, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 85\\nI can visit All buldings from (1,4)[2,1, 3,3, 2,2, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 92\\nI can visit All buldings from (2,0)[2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 95\\nI can visit All buldings from (2,3)[2,1, 3,3, 2,2, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 76\\nI can visit All buldings from (2,4)[2,1, 3,3, 2,2, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 83\\nI can visit All buldings from (3,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 79\\nI can visit All buldings from (3,2)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 72\\nI can visit All buldings from (3,4)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 80\\nI can visit All buldings from (4,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 82\\nI can visit All buldings from (4,3)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 76\\nI can visit All buldings from (4,4)[2,1, 5,5, 3,3, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 83\\nI can visit All buldings from (5,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 91\\nI can visit All buldings from (5,2)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 84\\nI can visit All buldings from (5,3)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 85\\nI can visit All buldings from (5,4)[2,1, 5,5, 3,3, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 92"
                    },
                    {
                        "username": "jonreiland",
                        "content": "It\\'s because the problem description is incorrect. It\\'s not the Manhattan Distance that should be used, but the number of steps."
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store all the paths from all the buildings to the shortest path on the grid?\\n\\nAny ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "brahma0545",
                        "content": "in this test case the answer is mentioned 88\\n[1,1,1,1,1,0],\\n[0,0,0,0,0,1],\\n[0,1,1,0,0,1],\\n[1,0,0,1,0,1],\\n[1,0,1,0,0,1],\\n[1,0,0,0,0,1],\\n[0,1,1,1,1,0]\\n\\nbut how come (0,5) is rechable from the nodes (0,0)?\\n\\nshouldn\\'t it be -1"
                    },
                    {
                        "username": "aivanilov",
                        "content": "[@NekoShadow](/NekoShadow) The problem is that there\\'s a solution in [3,2] with distance 72 (instead of 88)"
                    },
                    {
                        "username": "NekoShadow",
                        "content": "Yes, (0, 5) is not reachable from (0, 0). So (0, 5) should not be used for building your new house. Just build the house somewhere else. Remember, you goal is to look for an empty land that can reach all buildings with minimum total Manhattan distance, NOT making sure that all empty lands can be reached by every building :)"
                    }
                ]
            },
            {
                "id": 1565898,
                "content": [
                    {
                        "username": "giof07",
                        "content": "The problem says the distance from one point to another is the mahattan distance, this should make bfs impossible... I see no solution in the discussion using the mahattan distance. What is going here? Can someone explain? If we use the manhattan distance to calculate the distance between two points how can we detect if there is an obstacle between two 0\\'s? If we can only move point to point and count each move as one, the problem is trivial, but manhattan distance seems to imply diagonal movement."
                    },
                    {
                        "username": "jeffkmeng",
                        "content": "The distance between two points is calculated with the manhattan distance, but that assumes there are no obstacles in between. The definition of manhattan distance is just that you assume you were walking along city blocks, so you *can\\'t* move diagonally."
                    },
                    {
                        "username": "pppprinciple",
                        "content": "\"The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.\"\\n\\nPlease fix. Looking at the tests, distance is expected to be calculated as number of steps taken in a given path."
                    },
                    {
                        "username": "lc4tc",
                        "content": "Last two sentences of the problem were blindly copied from https://leetcode.com/problems/best-meeting-point/, lol"
                    },
                    {
                        "username": "wuyinan",
                        "content": "Update:\\nI think I misunderstood this problem... I thought it asks to find an empty location that has access to all the houses and has the smallest sum of manhattan distances to all the houses and return that sum. It actually asks for the smallest sum of total steps to all the houses not Manhattan distances.\\n\\n=============================================================================================\\nTest case:\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\nMy code found the position at (3,2) has the shortest sum of distance of 72:\\n\\nPosition: dist to house 1, house 2, ...., sum of distance: \\n\\n6,0 : 1 1  sum: 2\\n5,1 : 6 5 6 7 8 8 3 4 7 3 4 6 2 2 5 1 4 1 2 3 4  sum: 91\\n5,2 : 7 6 5 6 7 7 4 3 6 4 3 5 3 1 4 2 3 2 1 2 3  sum: 84\\n4,1 : 5 4 5 6 7 7 2 3 6 2 3 5 1 1 4 2 5 2 3 4 5  sum: 82\\n2,0 : 2 3 4 5 6 6 1 2 5 1 4 6 2 4 7 3 8 5 6 7 8  sum: 95\\n5,3 : 8 7 6 5 6 6 5 4 5 5 2 4 4 2 3 3 2 3 2 1 2  sum: 85\\n3,1 : 4 3 4 5 6 6 1 2 5 1 2 4 2 2 5 3 6 3 4 5 6  sum: 79\\n1,0 : 1 2 3 4 5 5 2 3 6 2 5 7 3 5 8 4 9 6 7 8 9  sum: 104\\n5,4 : 9 8 7 6 5 5 6 5 4 6 3 3 5 3 2 4 1 4 3 2 1  sum: 92\\n4,3 : 7 6 5 4 5 5 4 3 4 4 1 3 3 1 2 4 3 4 3 2 3  sum: 76\\n3,2 : 5 4 3 4 5 5 2 1 4 2 1 3 3 1 4 4 5 4 3 4 5  sum: 72\\n6,5 : 1 1  sum: 2\\n1,1 : 2 1 2 3 4 4 1 2 5 3 4 6 4 4 7 5 8 5 6 7 8  sum: 91\\n4,4 : 8 7 6 5 4 4 5 4 3 5 2 2 4 2 1 5 2 5 4 3 2  sum: 83\\n1,2 : 3 2 1 2 3 3 2 1 4 4 3 5 5 3 6 6 7 6 5 6 7  sum: 84\\n2,3 : 5 4 3 2 3 3 2 1 2 4 1 3 5 3 4 6 5 6 5 4 5  sum: 76\\n3,4 : 7 6 5 4 3 3 4 3 2 4 1 1 5 3 2 6 3 6 5 4 3  sum: 80\\n1,3 : 4 3 2 1 2 2 3 2 3 5 2 4 6 4 5 7 6 7 6 5 6  sum: 85\\n2,4 : 6 5 4 3 2 2 3 2 1 5 2 2 6 4 3 7 4 7 6 5 4  sum: 83\\n1,4 : 5 4 3 2 1 1 4 3 2 6 3 3 7 5 4 8 5 8 7 6 5  sum: 92\\n0,5 : 1 1  sum: 2"
                    },
                    {
                        "username": "aivanilov",
                        "content": "I\\'ve got 72 as well in this case. And I don\\'t get why it\\'s 88 in the answer."
                    },
                    {
                        "username": "shchybovyk",
                        "content": "I still don\\'t understand what is actually asked to find"
                    },
                    {
                        "username": "sanemiliano",
                        "content": "Terrible statement: \"The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|. FIX ASAP. Spent two hours debbuging because I calculate the mahattan distance and turns out the test cases expect the sum of the steps."
                    },
                    {
                        "username": "littlelionman1",
                        "content": "TY for helping me"
                    },
                    {
                        "username": "cosR",
                        "content": "To solve this question there are two approaches:\\n1. start bfs from empty position i.e. 0\\n2. start bfs from building position i.e. 1\\n\\nApproach 1 mostly ends up with time ~ 250 ms\\nApproach 2 however ends up with time ~30 ms\\n\\nIs this due to the fact that majority of the test cases have lesser 1s compared to 0s in the grid? What do you think?"
                    },
                    {
                        "username": "doublefat",
                        "content": "Return the shortest travel distance for such a house. If it is not possible to build such a house according to the above rules, return -1.\\n\\nThe total travel distance is the sum of the distances between the houses of the friends and the meeting point.\\n\\n**The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.**\\n\\ntest case :\\n\\n\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\n![image](https://assets.leetcode.com/users/images/e8af8452-9bcd-4b9c-95b2-c8a1254cc45e_1641067609.3005052.png)\\n\\n1 ,point [3,2] to building [0] [0] distance is 5 , total is 5\\n2 ,point [3,2] to building [0] [1] distance is 4 , total is 9\\n3 ,point [3,2] to building [0] [2] distance is 3 , total is 12\\n4 ,point [3,2] to building [0] [3] distance is 4 , total is 16\\n5 ,point [3,2] to building [0] [4] distance is 5 , total is 21\\n6 ,point [3,2] to building [1] [5] distance is 5 , total is 26\\n7 ,point [3,2] to building [2] [1] distance is 2 , total is 28\\n8 ,point [3,2] to building [2] [2] distance is 1 , total is 29\\n9 ,point [3,2] to building [2] [5] distance is 4 , total is 33\\n10 ,point [3,2] to building [3] [0] distance is 2 , total is 35\\n11 ,point [3,2] to building [3] [3] distance is 1 , total is 36\\n12 ,point [3,2] to building [3] [5] distance is 3 , total is 39\\n13 ,point [3,2] to building [4] [0] distance is 3 , total is 42\\n14 ,point [3,2] to building [4] [2] distance is 1 , total is 43\\n15 ,point [3,2] to building [4] [5] distance is 4 , total is 47\\n16 ,point [3,2] to building [5] [0] distance is 4 , total is 51\\n17 ,point [3,2] to building [5] [5] distance is 5 , total is 56\\n18 ,point [3,2] to building [6] [1] distance is 4 , total is 60\\n19 ,point [3,2] to building [6] [2] distance is 3 , total is 63\\n20 ,point [3,2] to building [6] [3] distance is 4 , total is 67\\n21 ,point [3,2] to building [6] [4] distance is 5 , total is 72\\n\\n![image](https://assets.leetcode.com/users/images/ce6c3d14-8826-4d86-864e-ab7806865d31_1641067774.8862677.png)\\n\\n\\n"
                    },
                    {
                        "username": "sabrinasong",
                        "content": "The question is almost the same as 296 except that here we have obstacles. In 296 we simply calculate its median, while here we have to use bfs. Can we do something on the basis of median solution?"
                    },
                    {
                        "username": "luckymaster",
                        "content": "How the distance is 88 for this test case.\\n\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\n\\nMine is 72,\\n\\nLeetcode 88;\\n\\n\\nBuildings = [2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 5,0, 6,1, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4] Size true\\nI can visit All buldings from (1,0)[2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 104\\nI can visit All buldings from (1,1)[2,1, 2,2, 0,0, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 91\\nI can visit All buldings from (1,2)[2,1, 2,2, 3,3, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 84\\nI can visit All buldings from (1,3)[2,1, 3,3, 2,2, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 85\\nI can visit All buldings from (1,4)[2,1, 3,3, 2,2, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 92\\nI can visit All buldings from (2,0)[2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 95\\nI can visit All buldings from (2,3)[2,1, 3,3, 2,2, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 76\\nI can visit All buldings from (2,4)[2,1, 3,3, 2,2, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 83\\nI can visit All buldings from (3,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 79\\nI can visit All buldings from (3,2)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 72\\nI can visit All buldings from (3,4)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 80\\nI can visit All buldings from (4,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 82\\nI can visit All buldings from (4,3)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 76\\nI can visit All buldings from (4,4)[2,1, 5,5, 3,3, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 83\\nI can visit All buldings from (5,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 91\\nI can visit All buldings from (5,2)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 84\\nI can visit All buldings from (5,3)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 85\\nI can visit All buldings from (5,4)[2,1, 5,5, 3,3, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 92"
                    },
                    {
                        "username": "jonreiland",
                        "content": "It\\'s because the problem description is incorrect. It\\'s not the Manhattan Distance that should be used, but the number of steps."
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store all the paths from all the buildings to the shortest path on the grid?\\n\\nAny ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "brahma0545",
                        "content": "in this test case the answer is mentioned 88\\n[1,1,1,1,1,0],\\n[0,0,0,0,0,1],\\n[0,1,1,0,0,1],\\n[1,0,0,1,0,1],\\n[1,0,1,0,0,1],\\n[1,0,0,0,0,1],\\n[0,1,1,1,1,0]\\n\\nbut how come (0,5) is rechable from the nodes (0,0)?\\n\\nshouldn\\'t it be -1"
                    },
                    {
                        "username": "aivanilov",
                        "content": "[@NekoShadow](/NekoShadow) The problem is that there\\'s a solution in [3,2] with distance 72 (instead of 88)"
                    },
                    {
                        "username": "NekoShadow",
                        "content": "Yes, (0, 5) is not reachable from (0, 0). So (0, 5) should not be used for building your new house. Just build the house somewhere else. Remember, you goal is to look for an empty land that can reach all buildings with minimum total Manhattan distance, NOT making sure that all empty lands can be reached by every building :)"
                    }
                ]
            },
            {
                "id": 1567097,
                "content": [
                    {
                        "username": "giof07",
                        "content": "The problem says the distance from one point to another is the mahattan distance, this should make bfs impossible... I see no solution in the discussion using the mahattan distance. What is going here? Can someone explain? If we use the manhattan distance to calculate the distance between two points how can we detect if there is an obstacle between two 0\\'s? If we can only move point to point and count each move as one, the problem is trivial, but manhattan distance seems to imply diagonal movement."
                    },
                    {
                        "username": "jeffkmeng",
                        "content": "The distance between two points is calculated with the manhattan distance, but that assumes there are no obstacles in between. The definition of manhattan distance is just that you assume you were walking along city blocks, so you *can\\'t* move diagonally."
                    },
                    {
                        "username": "pppprinciple",
                        "content": "\"The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.\"\\n\\nPlease fix. Looking at the tests, distance is expected to be calculated as number of steps taken in a given path."
                    },
                    {
                        "username": "lc4tc",
                        "content": "Last two sentences of the problem were blindly copied from https://leetcode.com/problems/best-meeting-point/, lol"
                    },
                    {
                        "username": "wuyinan",
                        "content": "Update:\\nI think I misunderstood this problem... I thought it asks to find an empty location that has access to all the houses and has the smallest sum of manhattan distances to all the houses and return that sum. It actually asks for the smallest sum of total steps to all the houses not Manhattan distances.\\n\\n=============================================================================================\\nTest case:\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\nMy code found the position at (3,2) has the shortest sum of distance of 72:\\n\\nPosition: dist to house 1, house 2, ...., sum of distance: \\n\\n6,0 : 1 1  sum: 2\\n5,1 : 6 5 6 7 8 8 3 4 7 3 4 6 2 2 5 1 4 1 2 3 4  sum: 91\\n5,2 : 7 6 5 6 7 7 4 3 6 4 3 5 3 1 4 2 3 2 1 2 3  sum: 84\\n4,1 : 5 4 5 6 7 7 2 3 6 2 3 5 1 1 4 2 5 2 3 4 5  sum: 82\\n2,0 : 2 3 4 5 6 6 1 2 5 1 4 6 2 4 7 3 8 5 6 7 8  sum: 95\\n5,3 : 8 7 6 5 6 6 5 4 5 5 2 4 4 2 3 3 2 3 2 1 2  sum: 85\\n3,1 : 4 3 4 5 6 6 1 2 5 1 2 4 2 2 5 3 6 3 4 5 6  sum: 79\\n1,0 : 1 2 3 4 5 5 2 3 6 2 5 7 3 5 8 4 9 6 7 8 9  sum: 104\\n5,4 : 9 8 7 6 5 5 6 5 4 6 3 3 5 3 2 4 1 4 3 2 1  sum: 92\\n4,3 : 7 6 5 4 5 5 4 3 4 4 1 3 3 1 2 4 3 4 3 2 3  sum: 76\\n3,2 : 5 4 3 4 5 5 2 1 4 2 1 3 3 1 4 4 5 4 3 4 5  sum: 72\\n6,5 : 1 1  sum: 2\\n1,1 : 2 1 2 3 4 4 1 2 5 3 4 6 4 4 7 5 8 5 6 7 8  sum: 91\\n4,4 : 8 7 6 5 4 4 5 4 3 5 2 2 4 2 1 5 2 5 4 3 2  sum: 83\\n1,2 : 3 2 1 2 3 3 2 1 4 4 3 5 5 3 6 6 7 6 5 6 7  sum: 84\\n2,3 : 5 4 3 2 3 3 2 1 2 4 1 3 5 3 4 6 5 6 5 4 5  sum: 76\\n3,4 : 7 6 5 4 3 3 4 3 2 4 1 1 5 3 2 6 3 6 5 4 3  sum: 80\\n1,3 : 4 3 2 1 2 2 3 2 3 5 2 4 6 4 5 7 6 7 6 5 6  sum: 85\\n2,4 : 6 5 4 3 2 2 3 2 1 5 2 2 6 4 3 7 4 7 6 5 4  sum: 83\\n1,4 : 5 4 3 2 1 1 4 3 2 6 3 3 7 5 4 8 5 8 7 6 5  sum: 92\\n0,5 : 1 1  sum: 2"
                    },
                    {
                        "username": "aivanilov",
                        "content": "I\\'ve got 72 as well in this case. And I don\\'t get why it\\'s 88 in the answer."
                    },
                    {
                        "username": "shchybovyk",
                        "content": "I still don\\'t understand what is actually asked to find"
                    },
                    {
                        "username": "sanemiliano",
                        "content": "Terrible statement: \"The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|. FIX ASAP. Spent two hours debbuging because I calculate the mahattan distance and turns out the test cases expect the sum of the steps."
                    },
                    {
                        "username": "littlelionman1",
                        "content": "TY for helping me"
                    },
                    {
                        "username": "cosR",
                        "content": "To solve this question there are two approaches:\\n1. start bfs from empty position i.e. 0\\n2. start bfs from building position i.e. 1\\n\\nApproach 1 mostly ends up with time ~ 250 ms\\nApproach 2 however ends up with time ~30 ms\\n\\nIs this due to the fact that majority of the test cases have lesser 1s compared to 0s in the grid? What do you think?"
                    },
                    {
                        "username": "doublefat",
                        "content": "Return the shortest travel distance for such a house. If it is not possible to build such a house according to the above rules, return -1.\\n\\nThe total travel distance is the sum of the distances between the houses of the friends and the meeting point.\\n\\n**The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.**\\n\\ntest case :\\n\\n\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\n![image](https://assets.leetcode.com/users/images/e8af8452-9bcd-4b9c-95b2-c8a1254cc45e_1641067609.3005052.png)\\n\\n1 ,point [3,2] to building [0] [0] distance is 5 , total is 5\\n2 ,point [3,2] to building [0] [1] distance is 4 , total is 9\\n3 ,point [3,2] to building [0] [2] distance is 3 , total is 12\\n4 ,point [3,2] to building [0] [3] distance is 4 , total is 16\\n5 ,point [3,2] to building [0] [4] distance is 5 , total is 21\\n6 ,point [3,2] to building [1] [5] distance is 5 , total is 26\\n7 ,point [3,2] to building [2] [1] distance is 2 , total is 28\\n8 ,point [3,2] to building [2] [2] distance is 1 , total is 29\\n9 ,point [3,2] to building [2] [5] distance is 4 , total is 33\\n10 ,point [3,2] to building [3] [0] distance is 2 , total is 35\\n11 ,point [3,2] to building [3] [3] distance is 1 , total is 36\\n12 ,point [3,2] to building [3] [5] distance is 3 , total is 39\\n13 ,point [3,2] to building [4] [0] distance is 3 , total is 42\\n14 ,point [3,2] to building [4] [2] distance is 1 , total is 43\\n15 ,point [3,2] to building [4] [5] distance is 4 , total is 47\\n16 ,point [3,2] to building [5] [0] distance is 4 , total is 51\\n17 ,point [3,2] to building [5] [5] distance is 5 , total is 56\\n18 ,point [3,2] to building [6] [1] distance is 4 , total is 60\\n19 ,point [3,2] to building [6] [2] distance is 3 , total is 63\\n20 ,point [3,2] to building [6] [3] distance is 4 , total is 67\\n21 ,point [3,2] to building [6] [4] distance is 5 , total is 72\\n\\n![image](https://assets.leetcode.com/users/images/ce6c3d14-8826-4d86-864e-ab7806865d31_1641067774.8862677.png)\\n\\n\\n"
                    },
                    {
                        "username": "sabrinasong",
                        "content": "The question is almost the same as 296 except that here we have obstacles. In 296 we simply calculate its median, while here we have to use bfs. Can we do something on the basis of median solution?"
                    },
                    {
                        "username": "luckymaster",
                        "content": "How the distance is 88 for this test case.\\n\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\n\\nMine is 72,\\n\\nLeetcode 88;\\n\\n\\nBuildings = [2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 5,0, 6,1, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4] Size true\\nI can visit All buldings from (1,0)[2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 104\\nI can visit All buldings from (1,1)[2,1, 2,2, 0,0, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 91\\nI can visit All buldings from (1,2)[2,1, 2,2, 3,3, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 84\\nI can visit All buldings from (1,3)[2,1, 3,3, 2,2, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 85\\nI can visit All buldings from (1,4)[2,1, 3,3, 2,2, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 92\\nI can visit All buldings from (2,0)[2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 95\\nI can visit All buldings from (2,3)[2,1, 3,3, 2,2, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 76\\nI can visit All buldings from (2,4)[2,1, 3,3, 2,2, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 83\\nI can visit All buldings from (3,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 79\\nI can visit All buldings from (3,2)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 72\\nI can visit All buldings from (3,4)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 80\\nI can visit All buldings from (4,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 82\\nI can visit All buldings from (4,3)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 76\\nI can visit All buldings from (4,4)[2,1, 5,5, 3,3, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 83\\nI can visit All buldings from (5,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 91\\nI can visit All buldings from (5,2)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 84\\nI can visit All buldings from (5,3)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 85\\nI can visit All buldings from (5,4)[2,1, 5,5, 3,3, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 92"
                    },
                    {
                        "username": "jonreiland",
                        "content": "It\\'s because the problem description is incorrect. It\\'s not the Manhattan Distance that should be used, but the number of steps."
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store all the paths from all the buildings to the shortest path on the grid?\\n\\nAny ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "brahma0545",
                        "content": "in this test case the answer is mentioned 88\\n[1,1,1,1,1,0],\\n[0,0,0,0,0,1],\\n[0,1,1,0,0,1],\\n[1,0,0,1,0,1],\\n[1,0,1,0,0,1],\\n[1,0,0,0,0,1],\\n[0,1,1,1,1,0]\\n\\nbut how come (0,5) is rechable from the nodes (0,0)?\\n\\nshouldn\\'t it be -1"
                    },
                    {
                        "username": "aivanilov",
                        "content": "[@NekoShadow](/NekoShadow) The problem is that there\\'s a solution in [3,2] with distance 72 (instead of 88)"
                    },
                    {
                        "username": "NekoShadow",
                        "content": "Yes, (0, 5) is not reachable from (0, 0). So (0, 5) should not be used for building your new house. Just build the house somewhere else. Remember, you goal is to look for an empty land that can reach all buildings with minimum total Manhattan distance, NOT making sure that all empty lands can be reached by every building :)"
                    }
                ]
            },
            {
                "id": 1567044,
                "content": [
                    {
                        "username": "giof07",
                        "content": "The problem says the distance from one point to another is the mahattan distance, this should make bfs impossible... I see no solution in the discussion using the mahattan distance. What is going here? Can someone explain? If we use the manhattan distance to calculate the distance between two points how can we detect if there is an obstacle between two 0\\'s? If we can only move point to point and count each move as one, the problem is trivial, but manhattan distance seems to imply diagonal movement."
                    },
                    {
                        "username": "jeffkmeng",
                        "content": "The distance between two points is calculated with the manhattan distance, but that assumes there are no obstacles in between. The definition of manhattan distance is just that you assume you were walking along city blocks, so you *can\\'t* move diagonally."
                    },
                    {
                        "username": "pppprinciple",
                        "content": "\"The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.\"\\n\\nPlease fix. Looking at the tests, distance is expected to be calculated as number of steps taken in a given path."
                    },
                    {
                        "username": "lc4tc",
                        "content": "Last two sentences of the problem were blindly copied from https://leetcode.com/problems/best-meeting-point/, lol"
                    },
                    {
                        "username": "wuyinan",
                        "content": "Update:\\nI think I misunderstood this problem... I thought it asks to find an empty location that has access to all the houses and has the smallest sum of manhattan distances to all the houses and return that sum. It actually asks for the smallest sum of total steps to all the houses not Manhattan distances.\\n\\n=============================================================================================\\nTest case:\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\nMy code found the position at (3,2) has the shortest sum of distance of 72:\\n\\nPosition: dist to house 1, house 2, ...., sum of distance: \\n\\n6,0 : 1 1  sum: 2\\n5,1 : 6 5 6 7 8 8 3 4 7 3 4 6 2 2 5 1 4 1 2 3 4  sum: 91\\n5,2 : 7 6 5 6 7 7 4 3 6 4 3 5 3 1 4 2 3 2 1 2 3  sum: 84\\n4,1 : 5 4 5 6 7 7 2 3 6 2 3 5 1 1 4 2 5 2 3 4 5  sum: 82\\n2,0 : 2 3 4 5 6 6 1 2 5 1 4 6 2 4 7 3 8 5 6 7 8  sum: 95\\n5,3 : 8 7 6 5 6 6 5 4 5 5 2 4 4 2 3 3 2 3 2 1 2  sum: 85\\n3,1 : 4 3 4 5 6 6 1 2 5 1 2 4 2 2 5 3 6 3 4 5 6  sum: 79\\n1,0 : 1 2 3 4 5 5 2 3 6 2 5 7 3 5 8 4 9 6 7 8 9  sum: 104\\n5,4 : 9 8 7 6 5 5 6 5 4 6 3 3 5 3 2 4 1 4 3 2 1  sum: 92\\n4,3 : 7 6 5 4 5 5 4 3 4 4 1 3 3 1 2 4 3 4 3 2 3  sum: 76\\n3,2 : 5 4 3 4 5 5 2 1 4 2 1 3 3 1 4 4 5 4 3 4 5  sum: 72\\n6,5 : 1 1  sum: 2\\n1,1 : 2 1 2 3 4 4 1 2 5 3 4 6 4 4 7 5 8 5 6 7 8  sum: 91\\n4,4 : 8 7 6 5 4 4 5 4 3 5 2 2 4 2 1 5 2 5 4 3 2  sum: 83\\n1,2 : 3 2 1 2 3 3 2 1 4 4 3 5 5 3 6 6 7 6 5 6 7  sum: 84\\n2,3 : 5 4 3 2 3 3 2 1 2 4 1 3 5 3 4 6 5 6 5 4 5  sum: 76\\n3,4 : 7 6 5 4 3 3 4 3 2 4 1 1 5 3 2 6 3 6 5 4 3  sum: 80\\n1,3 : 4 3 2 1 2 2 3 2 3 5 2 4 6 4 5 7 6 7 6 5 6  sum: 85\\n2,4 : 6 5 4 3 2 2 3 2 1 5 2 2 6 4 3 7 4 7 6 5 4  sum: 83\\n1,4 : 5 4 3 2 1 1 4 3 2 6 3 3 7 5 4 8 5 8 7 6 5  sum: 92\\n0,5 : 1 1  sum: 2"
                    },
                    {
                        "username": "aivanilov",
                        "content": "I\\'ve got 72 as well in this case. And I don\\'t get why it\\'s 88 in the answer."
                    },
                    {
                        "username": "shchybovyk",
                        "content": "I still don\\'t understand what is actually asked to find"
                    },
                    {
                        "username": "sanemiliano",
                        "content": "Terrible statement: \"The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|. FIX ASAP. Spent two hours debbuging because I calculate the mahattan distance and turns out the test cases expect the sum of the steps."
                    },
                    {
                        "username": "littlelionman1",
                        "content": "TY for helping me"
                    },
                    {
                        "username": "cosR",
                        "content": "To solve this question there are two approaches:\\n1. start bfs from empty position i.e. 0\\n2. start bfs from building position i.e. 1\\n\\nApproach 1 mostly ends up with time ~ 250 ms\\nApproach 2 however ends up with time ~30 ms\\n\\nIs this due to the fact that majority of the test cases have lesser 1s compared to 0s in the grid? What do you think?"
                    },
                    {
                        "username": "doublefat",
                        "content": "Return the shortest travel distance for such a house. If it is not possible to build such a house according to the above rules, return -1.\\n\\nThe total travel distance is the sum of the distances between the houses of the friends and the meeting point.\\n\\n**The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.**\\n\\ntest case :\\n\\n\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\n![image](https://assets.leetcode.com/users/images/e8af8452-9bcd-4b9c-95b2-c8a1254cc45e_1641067609.3005052.png)\\n\\n1 ,point [3,2] to building [0] [0] distance is 5 , total is 5\\n2 ,point [3,2] to building [0] [1] distance is 4 , total is 9\\n3 ,point [3,2] to building [0] [2] distance is 3 , total is 12\\n4 ,point [3,2] to building [0] [3] distance is 4 , total is 16\\n5 ,point [3,2] to building [0] [4] distance is 5 , total is 21\\n6 ,point [3,2] to building [1] [5] distance is 5 , total is 26\\n7 ,point [3,2] to building [2] [1] distance is 2 , total is 28\\n8 ,point [3,2] to building [2] [2] distance is 1 , total is 29\\n9 ,point [3,2] to building [2] [5] distance is 4 , total is 33\\n10 ,point [3,2] to building [3] [0] distance is 2 , total is 35\\n11 ,point [3,2] to building [3] [3] distance is 1 , total is 36\\n12 ,point [3,2] to building [3] [5] distance is 3 , total is 39\\n13 ,point [3,2] to building [4] [0] distance is 3 , total is 42\\n14 ,point [3,2] to building [4] [2] distance is 1 , total is 43\\n15 ,point [3,2] to building [4] [5] distance is 4 , total is 47\\n16 ,point [3,2] to building [5] [0] distance is 4 , total is 51\\n17 ,point [3,2] to building [5] [5] distance is 5 , total is 56\\n18 ,point [3,2] to building [6] [1] distance is 4 , total is 60\\n19 ,point [3,2] to building [6] [2] distance is 3 , total is 63\\n20 ,point [3,2] to building [6] [3] distance is 4 , total is 67\\n21 ,point [3,2] to building [6] [4] distance is 5 , total is 72\\n\\n![image](https://assets.leetcode.com/users/images/ce6c3d14-8826-4d86-864e-ab7806865d31_1641067774.8862677.png)\\n\\n\\n"
                    },
                    {
                        "username": "sabrinasong",
                        "content": "The question is almost the same as 296 except that here we have obstacles. In 296 we simply calculate its median, while here we have to use bfs. Can we do something on the basis of median solution?"
                    },
                    {
                        "username": "luckymaster",
                        "content": "How the distance is 88 for this test case.\\n\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\n\\nMine is 72,\\n\\nLeetcode 88;\\n\\n\\nBuildings = [2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 5,0, 6,1, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4] Size true\\nI can visit All buldings from (1,0)[2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 104\\nI can visit All buldings from (1,1)[2,1, 2,2, 0,0, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 91\\nI can visit All buldings from (1,2)[2,1, 2,2, 3,3, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 84\\nI can visit All buldings from (1,3)[2,1, 3,3, 2,2, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 85\\nI can visit All buldings from (1,4)[2,1, 3,3, 2,2, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 92\\nI can visit All buldings from (2,0)[2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 95\\nI can visit All buldings from (2,3)[2,1, 3,3, 2,2, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 76\\nI can visit All buldings from (2,4)[2,1, 3,3, 2,2, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 83\\nI can visit All buldings from (3,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 79\\nI can visit All buldings from (3,2)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 72\\nI can visit All buldings from (3,4)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 80\\nI can visit All buldings from (4,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 82\\nI can visit All buldings from (4,3)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 76\\nI can visit All buldings from (4,4)[2,1, 5,5, 3,3, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 83\\nI can visit All buldings from (5,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 91\\nI can visit All buldings from (5,2)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 84\\nI can visit All buldings from (5,3)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 85\\nI can visit All buldings from (5,4)[2,1, 5,5, 3,3, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 92"
                    },
                    {
                        "username": "jonreiland",
                        "content": "It\\'s because the problem description is incorrect. It\\'s not the Manhattan Distance that should be used, but the number of steps."
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store all the paths from all the buildings to the shortest path on the grid?\\n\\nAny ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "brahma0545",
                        "content": "in this test case the answer is mentioned 88\\n[1,1,1,1,1,0],\\n[0,0,0,0,0,1],\\n[0,1,1,0,0,1],\\n[1,0,0,1,0,1],\\n[1,0,1,0,0,1],\\n[1,0,0,0,0,1],\\n[0,1,1,1,1,0]\\n\\nbut how come (0,5) is rechable from the nodes (0,0)?\\n\\nshouldn\\'t it be -1"
                    },
                    {
                        "username": "aivanilov",
                        "content": "[@NekoShadow](/NekoShadow) The problem is that there\\'s a solution in [3,2] with distance 72 (instead of 88)"
                    },
                    {
                        "username": "NekoShadow",
                        "content": "Yes, (0, 5) is not reachable from (0, 0). So (0, 5) should not be used for building your new house. Just build the house somewhere else. Remember, you goal is to look for an empty land that can reach all buildings with minimum total Manhattan distance, NOT making sure that all empty lands can be reached by every building :)"
                    }
                ]
            },
            {
                "id": 1684672,
                "content": [
                    {
                        "username": "giof07",
                        "content": "The problem says the distance from one point to another is the mahattan distance, this should make bfs impossible... I see no solution in the discussion using the mahattan distance. What is going here? Can someone explain? If we use the manhattan distance to calculate the distance between two points how can we detect if there is an obstacle between two 0\\'s? If we can only move point to point and count each move as one, the problem is trivial, but manhattan distance seems to imply diagonal movement."
                    },
                    {
                        "username": "jeffkmeng",
                        "content": "The distance between two points is calculated with the manhattan distance, but that assumes there are no obstacles in between. The definition of manhattan distance is just that you assume you were walking along city blocks, so you *can\\'t* move diagonally."
                    },
                    {
                        "username": "pppprinciple",
                        "content": "\"The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.\"\\n\\nPlease fix. Looking at the tests, distance is expected to be calculated as number of steps taken in a given path."
                    },
                    {
                        "username": "lc4tc",
                        "content": "Last two sentences of the problem were blindly copied from https://leetcode.com/problems/best-meeting-point/, lol"
                    },
                    {
                        "username": "wuyinan",
                        "content": "Update:\\nI think I misunderstood this problem... I thought it asks to find an empty location that has access to all the houses and has the smallest sum of manhattan distances to all the houses and return that sum. It actually asks for the smallest sum of total steps to all the houses not Manhattan distances.\\n\\n=============================================================================================\\nTest case:\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\nMy code found the position at (3,2) has the shortest sum of distance of 72:\\n\\nPosition: dist to house 1, house 2, ...., sum of distance: \\n\\n6,0 : 1 1  sum: 2\\n5,1 : 6 5 6 7 8 8 3 4 7 3 4 6 2 2 5 1 4 1 2 3 4  sum: 91\\n5,2 : 7 6 5 6 7 7 4 3 6 4 3 5 3 1 4 2 3 2 1 2 3  sum: 84\\n4,1 : 5 4 5 6 7 7 2 3 6 2 3 5 1 1 4 2 5 2 3 4 5  sum: 82\\n2,0 : 2 3 4 5 6 6 1 2 5 1 4 6 2 4 7 3 8 5 6 7 8  sum: 95\\n5,3 : 8 7 6 5 6 6 5 4 5 5 2 4 4 2 3 3 2 3 2 1 2  sum: 85\\n3,1 : 4 3 4 5 6 6 1 2 5 1 2 4 2 2 5 3 6 3 4 5 6  sum: 79\\n1,0 : 1 2 3 4 5 5 2 3 6 2 5 7 3 5 8 4 9 6 7 8 9  sum: 104\\n5,4 : 9 8 7 6 5 5 6 5 4 6 3 3 5 3 2 4 1 4 3 2 1  sum: 92\\n4,3 : 7 6 5 4 5 5 4 3 4 4 1 3 3 1 2 4 3 4 3 2 3  sum: 76\\n3,2 : 5 4 3 4 5 5 2 1 4 2 1 3 3 1 4 4 5 4 3 4 5  sum: 72\\n6,5 : 1 1  sum: 2\\n1,1 : 2 1 2 3 4 4 1 2 5 3 4 6 4 4 7 5 8 5 6 7 8  sum: 91\\n4,4 : 8 7 6 5 4 4 5 4 3 5 2 2 4 2 1 5 2 5 4 3 2  sum: 83\\n1,2 : 3 2 1 2 3 3 2 1 4 4 3 5 5 3 6 6 7 6 5 6 7  sum: 84\\n2,3 : 5 4 3 2 3 3 2 1 2 4 1 3 5 3 4 6 5 6 5 4 5  sum: 76\\n3,4 : 7 6 5 4 3 3 4 3 2 4 1 1 5 3 2 6 3 6 5 4 3  sum: 80\\n1,3 : 4 3 2 1 2 2 3 2 3 5 2 4 6 4 5 7 6 7 6 5 6  sum: 85\\n2,4 : 6 5 4 3 2 2 3 2 1 5 2 2 6 4 3 7 4 7 6 5 4  sum: 83\\n1,4 : 5 4 3 2 1 1 4 3 2 6 3 3 7 5 4 8 5 8 7 6 5  sum: 92\\n0,5 : 1 1  sum: 2"
                    },
                    {
                        "username": "aivanilov",
                        "content": "I\\'ve got 72 as well in this case. And I don\\'t get why it\\'s 88 in the answer."
                    },
                    {
                        "username": "shchybovyk",
                        "content": "I still don\\'t understand what is actually asked to find"
                    },
                    {
                        "username": "sanemiliano",
                        "content": "Terrible statement: \"The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|. FIX ASAP. Spent two hours debbuging because I calculate the mahattan distance and turns out the test cases expect the sum of the steps."
                    },
                    {
                        "username": "littlelionman1",
                        "content": "TY for helping me"
                    },
                    {
                        "username": "cosR",
                        "content": "To solve this question there are two approaches:\\n1. start bfs from empty position i.e. 0\\n2. start bfs from building position i.e. 1\\n\\nApproach 1 mostly ends up with time ~ 250 ms\\nApproach 2 however ends up with time ~30 ms\\n\\nIs this due to the fact that majority of the test cases have lesser 1s compared to 0s in the grid? What do you think?"
                    },
                    {
                        "username": "doublefat",
                        "content": "Return the shortest travel distance for such a house. If it is not possible to build such a house according to the above rules, return -1.\\n\\nThe total travel distance is the sum of the distances between the houses of the friends and the meeting point.\\n\\n**The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.**\\n\\ntest case :\\n\\n\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\n![image](https://assets.leetcode.com/users/images/e8af8452-9bcd-4b9c-95b2-c8a1254cc45e_1641067609.3005052.png)\\n\\n1 ,point [3,2] to building [0] [0] distance is 5 , total is 5\\n2 ,point [3,2] to building [0] [1] distance is 4 , total is 9\\n3 ,point [3,2] to building [0] [2] distance is 3 , total is 12\\n4 ,point [3,2] to building [0] [3] distance is 4 , total is 16\\n5 ,point [3,2] to building [0] [4] distance is 5 , total is 21\\n6 ,point [3,2] to building [1] [5] distance is 5 , total is 26\\n7 ,point [3,2] to building [2] [1] distance is 2 , total is 28\\n8 ,point [3,2] to building [2] [2] distance is 1 , total is 29\\n9 ,point [3,2] to building [2] [5] distance is 4 , total is 33\\n10 ,point [3,2] to building [3] [0] distance is 2 , total is 35\\n11 ,point [3,2] to building [3] [3] distance is 1 , total is 36\\n12 ,point [3,2] to building [3] [5] distance is 3 , total is 39\\n13 ,point [3,2] to building [4] [0] distance is 3 , total is 42\\n14 ,point [3,2] to building [4] [2] distance is 1 , total is 43\\n15 ,point [3,2] to building [4] [5] distance is 4 , total is 47\\n16 ,point [3,2] to building [5] [0] distance is 4 , total is 51\\n17 ,point [3,2] to building [5] [5] distance is 5 , total is 56\\n18 ,point [3,2] to building [6] [1] distance is 4 , total is 60\\n19 ,point [3,2] to building [6] [2] distance is 3 , total is 63\\n20 ,point [3,2] to building [6] [3] distance is 4 , total is 67\\n21 ,point [3,2] to building [6] [4] distance is 5 , total is 72\\n\\n![image](https://assets.leetcode.com/users/images/ce6c3d14-8826-4d86-864e-ab7806865d31_1641067774.8862677.png)\\n\\n\\n"
                    },
                    {
                        "username": "sabrinasong",
                        "content": "The question is almost the same as 296 except that here we have obstacles. In 296 we simply calculate its median, while here we have to use bfs. Can we do something on the basis of median solution?"
                    },
                    {
                        "username": "luckymaster",
                        "content": "How the distance is 88 for this test case.\\n\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\n\\nMine is 72,\\n\\nLeetcode 88;\\n\\n\\nBuildings = [2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 5,0, 6,1, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4] Size true\\nI can visit All buldings from (1,0)[2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 104\\nI can visit All buldings from (1,1)[2,1, 2,2, 0,0, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 91\\nI can visit All buldings from (1,2)[2,1, 2,2, 3,3, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 84\\nI can visit All buldings from (1,3)[2,1, 3,3, 2,2, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 85\\nI can visit All buldings from (1,4)[2,1, 3,3, 2,2, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 92\\nI can visit All buldings from (2,0)[2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 95\\nI can visit All buldings from (2,3)[2,1, 3,3, 2,2, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 76\\nI can visit All buldings from (2,4)[2,1, 3,3, 2,2, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 83\\nI can visit All buldings from (3,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 79\\nI can visit All buldings from (3,2)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 72\\nI can visit All buldings from (3,4)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 80\\nI can visit All buldings from (4,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 82\\nI can visit All buldings from (4,3)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 76\\nI can visit All buldings from (4,4)[2,1, 5,5, 3,3, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 83\\nI can visit All buldings from (5,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 91\\nI can visit All buldings from (5,2)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 84\\nI can visit All buldings from (5,3)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 85\\nI can visit All buldings from (5,4)[2,1, 5,5, 3,3, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 92"
                    },
                    {
                        "username": "jonreiland",
                        "content": "It\\'s because the problem description is incorrect. It\\'s not the Manhattan Distance that should be used, but the number of steps."
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store all the paths from all the buildings to the shortest path on the grid?\\n\\nAny ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "brahma0545",
                        "content": "in this test case the answer is mentioned 88\\n[1,1,1,1,1,0],\\n[0,0,0,0,0,1],\\n[0,1,1,0,0,1],\\n[1,0,0,1,0,1],\\n[1,0,1,0,0,1],\\n[1,0,0,0,0,1],\\n[0,1,1,1,1,0]\\n\\nbut how come (0,5) is rechable from the nodes (0,0)?\\n\\nshouldn\\'t it be -1"
                    },
                    {
                        "username": "aivanilov",
                        "content": "[@NekoShadow](/NekoShadow) The problem is that there\\'s a solution in [3,2] with distance 72 (instead of 88)"
                    },
                    {
                        "username": "NekoShadow",
                        "content": "Yes, (0, 5) is not reachable from (0, 0). So (0, 5) should not be used for building your new house. Just build the house somewhere else. Remember, you goal is to look for an empty land that can reach all buildings with minimum total Manhattan distance, NOT making sure that all empty lands can be reached by every building :)"
                    }
                ]
            },
            {
                "id": 1573867,
                "content": [
                    {
                        "username": "giof07",
                        "content": "The problem says the distance from one point to another is the mahattan distance, this should make bfs impossible... I see no solution in the discussion using the mahattan distance. What is going here? Can someone explain? If we use the manhattan distance to calculate the distance between two points how can we detect if there is an obstacle between two 0\\'s? If we can only move point to point and count each move as one, the problem is trivial, but manhattan distance seems to imply diagonal movement."
                    },
                    {
                        "username": "jeffkmeng",
                        "content": "The distance between two points is calculated with the manhattan distance, but that assumes there are no obstacles in between. The definition of manhattan distance is just that you assume you were walking along city blocks, so you *can\\'t* move diagonally."
                    },
                    {
                        "username": "pppprinciple",
                        "content": "\"The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.\"\\n\\nPlease fix. Looking at the tests, distance is expected to be calculated as number of steps taken in a given path."
                    },
                    {
                        "username": "lc4tc",
                        "content": "Last two sentences of the problem were blindly copied from https://leetcode.com/problems/best-meeting-point/, lol"
                    },
                    {
                        "username": "wuyinan",
                        "content": "Update:\\nI think I misunderstood this problem... I thought it asks to find an empty location that has access to all the houses and has the smallest sum of manhattan distances to all the houses and return that sum. It actually asks for the smallest sum of total steps to all the houses not Manhattan distances.\\n\\n=============================================================================================\\nTest case:\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\nMy code found the position at (3,2) has the shortest sum of distance of 72:\\n\\nPosition: dist to house 1, house 2, ...., sum of distance: \\n\\n6,0 : 1 1  sum: 2\\n5,1 : 6 5 6 7 8 8 3 4 7 3 4 6 2 2 5 1 4 1 2 3 4  sum: 91\\n5,2 : 7 6 5 6 7 7 4 3 6 4 3 5 3 1 4 2 3 2 1 2 3  sum: 84\\n4,1 : 5 4 5 6 7 7 2 3 6 2 3 5 1 1 4 2 5 2 3 4 5  sum: 82\\n2,0 : 2 3 4 5 6 6 1 2 5 1 4 6 2 4 7 3 8 5 6 7 8  sum: 95\\n5,3 : 8 7 6 5 6 6 5 4 5 5 2 4 4 2 3 3 2 3 2 1 2  sum: 85\\n3,1 : 4 3 4 5 6 6 1 2 5 1 2 4 2 2 5 3 6 3 4 5 6  sum: 79\\n1,0 : 1 2 3 4 5 5 2 3 6 2 5 7 3 5 8 4 9 6 7 8 9  sum: 104\\n5,4 : 9 8 7 6 5 5 6 5 4 6 3 3 5 3 2 4 1 4 3 2 1  sum: 92\\n4,3 : 7 6 5 4 5 5 4 3 4 4 1 3 3 1 2 4 3 4 3 2 3  sum: 76\\n3,2 : 5 4 3 4 5 5 2 1 4 2 1 3 3 1 4 4 5 4 3 4 5  sum: 72\\n6,5 : 1 1  sum: 2\\n1,1 : 2 1 2 3 4 4 1 2 5 3 4 6 4 4 7 5 8 5 6 7 8  sum: 91\\n4,4 : 8 7 6 5 4 4 5 4 3 5 2 2 4 2 1 5 2 5 4 3 2  sum: 83\\n1,2 : 3 2 1 2 3 3 2 1 4 4 3 5 5 3 6 6 7 6 5 6 7  sum: 84\\n2,3 : 5 4 3 2 3 3 2 1 2 4 1 3 5 3 4 6 5 6 5 4 5  sum: 76\\n3,4 : 7 6 5 4 3 3 4 3 2 4 1 1 5 3 2 6 3 6 5 4 3  sum: 80\\n1,3 : 4 3 2 1 2 2 3 2 3 5 2 4 6 4 5 7 6 7 6 5 6  sum: 85\\n2,4 : 6 5 4 3 2 2 3 2 1 5 2 2 6 4 3 7 4 7 6 5 4  sum: 83\\n1,4 : 5 4 3 2 1 1 4 3 2 6 3 3 7 5 4 8 5 8 7 6 5  sum: 92\\n0,5 : 1 1  sum: 2"
                    },
                    {
                        "username": "aivanilov",
                        "content": "I\\'ve got 72 as well in this case. And I don\\'t get why it\\'s 88 in the answer."
                    },
                    {
                        "username": "shchybovyk",
                        "content": "I still don\\'t understand what is actually asked to find"
                    },
                    {
                        "username": "sanemiliano",
                        "content": "Terrible statement: \"The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|. FIX ASAP. Spent two hours debbuging because I calculate the mahattan distance and turns out the test cases expect the sum of the steps."
                    },
                    {
                        "username": "littlelionman1",
                        "content": "TY for helping me"
                    },
                    {
                        "username": "cosR",
                        "content": "To solve this question there are two approaches:\\n1. start bfs from empty position i.e. 0\\n2. start bfs from building position i.e. 1\\n\\nApproach 1 mostly ends up with time ~ 250 ms\\nApproach 2 however ends up with time ~30 ms\\n\\nIs this due to the fact that majority of the test cases have lesser 1s compared to 0s in the grid? What do you think?"
                    },
                    {
                        "username": "doublefat",
                        "content": "Return the shortest travel distance for such a house. If it is not possible to build such a house according to the above rules, return -1.\\n\\nThe total travel distance is the sum of the distances between the houses of the friends and the meeting point.\\n\\n**The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.**\\n\\ntest case :\\n\\n\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\n![image](https://assets.leetcode.com/users/images/e8af8452-9bcd-4b9c-95b2-c8a1254cc45e_1641067609.3005052.png)\\n\\n1 ,point [3,2] to building [0] [0] distance is 5 , total is 5\\n2 ,point [3,2] to building [0] [1] distance is 4 , total is 9\\n3 ,point [3,2] to building [0] [2] distance is 3 , total is 12\\n4 ,point [3,2] to building [0] [3] distance is 4 , total is 16\\n5 ,point [3,2] to building [0] [4] distance is 5 , total is 21\\n6 ,point [3,2] to building [1] [5] distance is 5 , total is 26\\n7 ,point [3,2] to building [2] [1] distance is 2 , total is 28\\n8 ,point [3,2] to building [2] [2] distance is 1 , total is 29\\n9 ,point [3,2] to building [2] [5] distance is 4 , total is 33\\n10 ,point [3,2] to building [3] [0] distance is 2 , total is 35\\n11 ,point [3,2] to building [3] [3] distance is 1 , total is 36\\n12 ,point [3,2] to building [3] [5] distance is 3 , total is 39\\n13 ,point [3,2] to building [4] [0] distance is 3 , total is 42\\n14 ,point [3,2] to building [4] [2] distance is 1 , total is 43\\n15 ,point [3,2] to building [4] [5] distance is 4 , total is 47\\n16 ,point [3,2] to building [5] [0] distance is 4 , total is 51\\n17 ,point [3,2] to building [5] [5] distance is 5 , total is 56\\n18 ,point [3,2] to building [6] [1] distance is 4 , total is 60\\n19 ,point [3,2] to building [6] [2] distance is 3 , total is 63\\n20 ,point [3,2] to building [6] [3] distance is 4 , total is 67\\n21 ,point [3,2] to building [6] [4] distance is 5 , total is 72\\n\\n![image](https://assets.leetcode.com/users/images/ce6c3d14-8826-4d86-864e-ab7806865d31_1641067774.8862677.png)\\n\\n\\n"
                    },
                    {
                        "username": "sabrinasong",
                        "content": "The question is almost the same as 296 except that here we have obstacles. In 296 we simply calculate its median, while here we have to use bfs. Can we do something on the basis of median solution?"
                    },
                    {
                        "username": "luckymaster",
                        "content": "How the distance is 88 for this test case.\\n\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\n\\nMine is 72,\\n\\nLeetcode 88;\\n\\n\\nBuildings = [2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 5,0, 6,1, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4] Size true\\nI can visit All buldings from (1,0)[2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 104\\nI can visit All buldings from (1,1)[2,1, 2,2, 0,0, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 91\\nI can visit All buldings from (1,2)[2,1, 2,2, 3,3, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 84\\nI can visit All buldings from (1,3)[2,1, 3,3, 2,2, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 85\\nI can visit All buldings from (1,4)[2,1, 3,3, 2,2, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 92\\nI can visit All buldings from (2,0)[2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 95\\nI can visit All buldings from (2,3)[2,1, 3,3, 2,2, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 76\\nI can visit All buldings from (2,4)[2,1, 3,3, 2,2, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 83\\nI can visit All buldings from (3,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 79\\nI can visit All buldings from (3,2)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 72\\nI can visit All buldings from (3,4)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 80\\nI can visit All buldings from (4,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 82\\nI can visit All buldings from (4,3)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 76\\nI can visit All buldings from (4,4)[2,1, 5,5, 3,3, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 83\\nI can visit All buldings from (5,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 91\\nI can visit All buldings from (5,2)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 84\\nI can visit All buldings from (5,3)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 85\\nI can visit All buldings from (5,4)[2,1, 5,5, 3,3, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 92"
                    },
                    {
                        "username": "jonreiland",
                        "content": "It\\'s because the problem description is incorrect. It\\'s not the Manhattan Distance that should be used, but the number of steps."
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store all the paths from all the buildings to the shortest path on the grid?\\n\\nAny ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "brahma0545",
                        "content": "in this test case the answer is mentioned 88\\n[1,1,1,1,1,0],\\n[0,0,0,0,0,1],\\n[0,1,1,0,0,1],\\n[1,0,0,1,0,1],\\n[1,0,1,0,0,1],\\n[1,0,0,0,0,1],\\n[0,1,1,1,1,0]\\n\\nbut how come (0,5) is rechable from the nodes (0,0)?\\n\\nshouldn\\'t it be -1"
                    },
                    {
                        "username": "aivanilov",
                        "content": "[@NekoShadow](/NekoShadow) The problem is that there\\'s a solution in [3,2] with distance 72 (instead of 88)"
                    },
                    {
                        "username": "NekoShadow",
                        "content": "Yes, (0, 5) is not reachable from (0, 0). So (0, 5) should not be used for building your new house. Just build the house somewhere else. Remember, you goal is to look for an empty land that can reach all buildings with minimum total Manhattan distance, NOT making sure that all empty lands can be reached by every building :)"
                    }
                ]
            },
            {
                "id": 1576156,
                "content": [
                    {
                        "username": "giof07",
                        "content": "The problem says the distance from one point to another is the mahattan distance, this should make bfs impossible... I see no solution in the discussion using the mahattan distance. What is going here? Can someone explain? If we use the manhattan distance to calculate the distance between two points how can we detect if there is an obstacle between two 0\\'s? If we can only move point to point and count each move as one, the problem is trivial, but manhattan distance seems to imply diagonal movement."
                    },
                    {
                        "username": "jeffkmeng",
                        "content": "The distance between two points is calculated with the manhattan distance, but that assumes there are no obstacles in between. The definition of manhattan distance is just that you assume you were walking along city blocks, so you *can\\'t* move diagonally."
                    },
                    {
                        "username": "pppprinciple",
                        "content": "\"The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.\"\\n\\nPlease fix. Looking at the tests, distance is expected to be calculated as number of steps taken in a given path."
                    },
                    {
                        "username": "lc4tc",
                        "content": "Last two sentences of the problem were blindly copied from https://leetcode.com/problems/best-meeting-point/, lol"
                    },
                    {
                        "username": "wuyinan",
                        "content": "Update:\\nI think I misunderstood this problem... I thought it asks to find an empty location that has access to all the houses and has the smallest sum of manhattan distances to all the houses and return that sum. It actually asks for the smallest sum of total steps to all the houses not Manhattan distances.\\n\\n=============================================================================================\\nTest case:\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\nMy code found the position at (3,2) has the shortest sum of distance of 72:\\n\\nPosition: dist to house 1, house 2, ...., sum of distance: \\n\\n6,0 : 1 1  sum: 2\\n5,1 : 6 5 6 7 8 8 3 4 7 3 4 6 2 2 5 1 4 1 2 3 4  sum: 91\\n5,2 : 7 6 5 6 7 7 4 3 6 4 3 5 3 1 4 2 3 2 1 2 3  sum: 84\\n4,1 : 5 4 5 6 7 7 2 3 6 2 3 5 1 1 4 2 5 2 3 4 5  sum: 82\\n2,0 : 2 3 4 5 6 6 1 2 5 1 4 6 2 4 7 3 8 5 6 7 8  sum: 95\\n5,3 : 8 7 6 5 6 6 5 4 5 5 2 4 4 2 3 3 2 3 2 1 2  sum: 85\\n3,1 : 4 3 4 5 6 6 1 2 5 1 2 4 2 2 5 3 6 3 4 5 6  sum: 79\\n1,0 : 1 2 3 4 5 5 2 3 6 2 5 7 3 5 8 4 9 6 7 8 9  sum: 104\\n5,4 : 9 8 7 6 5 5 6 5 4 6 3 3 5 3 2 4 1 4 3 2 1  sum: 92\\n4,3 : 7 6 5 4 5 5 4 3 4 4 1 3 3 1 2 4 3 4 3 2 3  sum: 76\\n3,2 : 5 4 3 4 5 5 2 1 4 2 1 3 3 1 4 4 5 4 3 4 5  sum: 72\\n6,5 : 1 1  sum: 2\\n1,1 : 2 1 2 3 4 4 1 2 5 3 4 6 4 4 7 5 8 5 6 7 8  sum: 91\\n4,4 : 8 7 6 5 4 4 5 4 3 5 2 2 4 2 1 5 2 5 4 3 2  sum: 83\\n1,2 : 3 2 1 2 3 3 2 1 4 4 3 5 5 3 6 6 7 6 5 6 7  sum: 84\\n2,3 : 5 4 3 2 3 3 2 1 2 4 1 3 5 3 4 6 5 6 5 4 5  sum: 76\\n3,4 : 7 6 5 4 3 3 4 3 2 4 1 1 5 3 2 6 3 6 5 4 3  sum: 80\\n1,3 : 4 3 2 1 2 2 3 2 3 5 2 4 6 4 5 7 6 7 6 5 6  sum: 85\\n2,4 : 6 5 4 3 2 2 3 2 1 5 2 2 6 4 3 7 4 7 6 5 4  sum: 83\\n1,4 : 5 4 3 2 1 1 4 3 2 6 3 3 7 5 4 8 5 8 7 6 5  sum: 92\\n0,5 : 1 1  sum: 2"
                    },
                    {
                        "username": "aivanilov",
                        "content": "I\\'ve got 72 as well in this case. And I don\\'t get why it\\'s 88 in the answer."
                    },
                    {
                        "username": "shchybovyk",
                        "content": "I still don\\'t understand what is actually asked to find"
                    },
                    {
                        "username": "sanemiliano",
                        "content": "Terrible statement: \"The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|. FIX ASAP. Spent two hours debbuging because I calculate the mahattan distance and turns out the test cases expect the sum of the steps."
                    },
                    {
                        "username": "littlelionman1",
                        "content": "TY for helping me"
                    },
                    {
                        "username": "cosR",
                        "content": "To solve this question there are two approaches:\\n1. start bfs from empty position i.e. 0\\n2. start bfs from building position i.e. 1\\n\\nApproach 1 mostly ends up with time ~ 250 ms\\nApproach 2 however ends up with time ~30 ms\\n\\nIs this due to the fact that majority of the test cases have lesser 1s compared to 0s in the grid? What do you think?"
                    },
                    {
                        "username": "doublefat",
                        "content": "Return the shortest travel distance for such a house. If it is not possible to build such a house according to the above rules, return -1.\\n\\nThe total travel distance is the sum of the distances between the houses of the friends and the meeting point.\\n\\n**The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.**\\n\\ntest case :\\n\\n\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\n![image](https://assets.leetcode.com/users/images/e8af8452-9bcd-4b9c-95b2-c8a1254cc45e_1641067609.3005052.png)\\n\\n1 ,point [3,2] to building [0] [0] distance is 5 , total is 5\\n2 ,point [3,2] to building [0] [1] distance is 4 , total is 9\\n3 ,point [3,2] to building [0] [2] distance is 3 , total is 12\\n4 ,point [3,2] to building [0] [3] distance is 4 , total is 16\\n5 ,point [3,2] to building [0] [4] distance is 5 , total is 21\\n6 ,point [3,2] to building [1] [5] distance is 5 , total is 26\\n7 ,point [3,2] to building [2] [1] distance is 2 , total is 28\\n8 ,point [3,2] to building [2] [2] distance is 1 , total is 29\\n9 ,point [3,2] to building [2] [5] distance is 4 , total is 33\\n10 ,point [3,2] to building [3] [0] distance is 2 , total is 35\\n11 ,point [3,2] to building [3] [3] distance is 1 , total is 36\\n12 ,point [3,2] to building [3] [5] distance is 3 , total is 39\\n13 ,point [3,2] to building [4] [0] distance is 3 , total is 42\\n14 ,point [3,2] to building [4] [2] distance is 1 , total is 43\\n15 ,point [3,2] to building [4] [5] distance is 4 , total is 47\\n16 ,point [3,2] to building [5] [0] distance is 4 , total is 51\\n17 ,point [3,2] to building [5] [5] distance is 5 , total is 56\\n18 ,point [3,2] to building [6] [1] distance is 4 , total is 60\\n19 ,point [3,2] to building [6] [2] distance is 3 , total is 63\\n20 ,point [3,2] to building [6] [3] distance is 4 , total is 67\\n21 ,point [3,2] to building [6] [4] distance is 5 , total is 72\\n\\n![image](https://assets.leetcode.com/users/images/ce6c3d14-8826-4d86-864e-ab7806865d31_1641067774.8862677.png)\\n\\n\\n"
                    },
                    {
                        "username": "sabrinasong",
                        "content": "The question is almost the same as 296 except that here we have obstacles. In 296 we simply calculate its median, while here we have to use bfs. Can we do something on the basis of median solution?"
                    },
                    {
                        "username": "luckymaster",
                        "content": "How the distance is 88 for this test case.\\n\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\n\\nMine is 72,\\n\\nLeetcode 88;\\n\\n\\nBuildings = [2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 5,0, 6,1, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4] Size true\\nI can visit All buldings from (1,0)[2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 104\\nI can visit All buldings from (1,1)[2,1, 2,2, 0,0, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 91\\nI can visit All buldings from (1,2)[2,1, 2,2, 3,3, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 84\\nI can visit All buldings from (1,3)[2,1, 3,3, 2,2, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 85\\nI can visit All buldings from (1,4)[2,1, 3,3, 2,2, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 92\\nI can visit All buldings from (2,0)[2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 95\\nI can visit All buldings from (2,3)[2,1, 3,3, 2,2, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 76\\nI can visit All buldings from (2,4)[2,1, 3,3, 2,2, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 83\\nI can visit All buldings from (3,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 79\\nI can visit All buldings from (3,2)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 72\\nI can visit All buldings from (3,4)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 80\\nI can visit All buldings from (4,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 82\\nI can visit All buldings from (4,3)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 76\\nI can visit All buldings from (4,4)[2,1, 5,5, 3,3, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 83\\nI can visit All buldings from (5,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 91\\nI can visit All buldings from (5,2)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 84\\nI can visit All buldings from (5,3)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 85\\nI can visit All buldings from (5,4)[2,1, 5,5, 3,3, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 92"
                    },
                    {
                        "username": "jonreiland",
                        "content": "It\\'s because the problem description is incorrect. It\\'s not the Manhattan Distance that should be used, but the number of steps."
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store all the paths from all the buildings to the shortest path on the grid?\\n\\nAny ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "brahma0545",
                        "content": "in this test case the answer is mentioned 88\\n[1,1,1,1,1,0],\\n[0,0,0,0,0,1],\\n[0,1,1,0,0,1],\\n[1,0,0,1,0,1],\\n[1,0,1,0,0,1],\\n[1,0,0,0,0,1],\\n[0,1,1,1,1,0]\\n\\nbut how come (0,5) is rechable from the nodes (0,0)?\\n\\nshouldn\\'t it be -1"
                    },
                    {
                        "username": "aivanilov",
                        "content": "[@NekoShadow](/NekoShadow) The problem is that there\\'s a solution in [3,2] with distance 72 (instead of 88)"
                    },
                    {
                        "username": "NekoShadow",
                        "content": "Yes, (0, 5) is not reachable from (0, 0). So (0, 5) should not be used for building your new house. Just build the house somewhere else. Remember, you goal is to look for an empty land that can reach all buildings with minimum total Manhattan distance, NOT making sure that all empty lands can be reached by every building :)"
                    }
                ]
            },
            {
                "id": 1569069,
                "content": [
                    {
                        "username": "giof07",
                        "content": "The problem says the distance from one point to another is the mahattan distance, this should make bfs impossible... I see no solution in the discussion using the mahattan distance. What is going here? Can someone explain? If we use the manhattan distance to calculate the distance between two points how can we detect if there is an obstacle between two 0\\'s? If we can only move point to point and count each move as one, the problem is trivial, but manhattan distance seems to imply diagonal movement."
                    },
                    {
                        "username": "jeffkmeng",
                        "content": "The distance between two points is calculated with the manhattan distance, but that assumes there are no obstacles in between. The definition of manhattan distance is just that you assume you were walking along city blocks, so you *can\\'t* move diagonally."
                    },
                    {
                        "username": "pppprinciple",
                        "content": "\"The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.\"\\n\\nPlease fix. Looking at the tests, distance is expected to be calculated as number of steps taken in a given path."
                    },
                    {
                        "username": "lc4tc",
                        "content": "Last two sentences of the problem were blindly copied from https://leetcode.com/problems/best-meeting-point/, lol"
                    },
                    {
                        "username": "wuyinan",
                        "content": "Update:\\nI think I misunderstood this problem... I thought it asks to find an empty location that has access to all the houses and has the smallest sum of manhattan distances to all the houses and return that sum. It actually asks for the smallest sum of total steps to all the houses not Manhattan distances.\\n\\n=============================================================================================\\nTest case:\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\nMy code found the position at (3,2) has the shortest sum of distance of 72:\\n\\nPosition: dist to house 1, house 2, ...., sum of distance: \\n\\n6,0 : 1 1  sum: 2\\n5,1 : 6 5 6 7 8 8 3 4 7 3 4 6 2 2 5 1 4 1 2 3 4  sum: 91\\n5,2 : 7 6 5 6 7 7 4 3 6 4 3 5 3 1 4 2 3 2 1 2 3  sum: 84\\n4,1 : 5 4 5 6 7 7 2 3 6 2 3 5 1 1 4 2 5 2 3 4 5  sum: 82\\n2,0 : 2 3 4 5 6 6 1 2 5 1 4 6 2 4 7 3 8 5 6 7 8  sum: 95\\n5,3 : 8 7 6 5 6 6 5 4 5 5 2 4 4 2 3 3 2 3 2 1 2  sum: 85\\n3,1 : 4 3 4 5 6 6 1 2 5 1 2 4 2 2 5 3 6 3 4 5 6  sum: 79\\n1,0 : 1 2 3 4 5 5 2 3 6 2 5 7 3 5 8 4 9 6 7 8 9  sum: 104\\n5,4 : 9 8 7 6 5 5 6 5 4 6 3 3 5 3 2 4 1 4 3 2 1  sum: 92\\n4,3 : 7 6 5 4 5 5 4 3 4 4 1 3 3 1 2 4 3 4 3 2 3  sum: 76\\n3,2 : 5 4 3 4 5 5 2 1 4 2 1 3 3 1 4 4 5 4 3 4 5  sum: 72\\n6,5 : 1 1  sum: 2\\n1,1 : 2 1 2 3 4 4 1 2 5 3 4 6 4 4 7 5 8 5 6 7 8  sum: 91\\n4,4 : 8 7 6 5 4 4 5 4 3 5 2 2 4 2 1 5 2 5 4 3 2  sum: 83\\n1,2 : 3 2 1 2 3 3 2 1 4 4 3 5 5 3 6 6 7 6 5 6 7  sum: 84\\n2,3 : 5 4 3 2 3 3 2 1 2 4 1 3 5 3 4 6 5 6 5 4 5  sum: 76\\n3,4 : 7 6 5 4 3 3 4 3 2 4 1 1 5 3 2 6 3 6 5 4 3  sum: 80\\n1,3 : 4 3 2 1 2 2 3 2 3 5 2 4 6 4 5 7 6 7 6 5 6  sum: 85\\n2,4 : 6 5 4 3 2 2 3 2 1 5 2 2 6 4 3 7 4 7 6 5 4  sum: 83\\n1,4 : 5 4 3 2 1 1 4 3 2 6 3 3 7 5 4 8 5 8 7 6 5  sum: 92\\n0,5 : 1 1  sum: 2"
                    },
                    {
                        "username": "aivanilov",
                        "content": "I\\'ve got 72 as well in this case. And I don\\'t get why it\\'s 88 in the answer."
                    },
                    {
                        "username": "shchybovyk",
                        "content": "I still don\\'t understand what is actually asked to find"
                    },
                    {
                        "username": "sanemiliano",
                        "content": "Terrible statement: \"The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|. FIX ASAP. Spent two hours debbuging because I calculate the mahattan distance and turns out the test cases expect the sum of the steps."
                    },
                    {
                        "username": "littlelionman1",
                        "content": "TY for helping me"
                    },
                    {
                        "username": "cosR",
                        "content": "To solve this question there are two approaches:\\n1. start bfs from empty position i.e. 0\\n2. start bfs from building position i.e. 1\\n\\nApproach 1 mostly ends up with time ~ 250 ms\\nApproach 2 however ends up with time ~30 ms\\n\\nIs this due to the fact that majority of the test cases have lesser 1s compared to 0s in the grid? What do you think?"
                    },
                    {
                        "username": "doublefat",
                        "content": "Return the shortest travel distance for such a house. If it is not possible to build such a house according to the above rules, return -1.\\n\\nThe total travel distance is the sum of the distances between the houses of the friends and the meeting point.\\n\\n**The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.**\\n\\ntest case :\\n\\n\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\n![image](https://assets.leetcode.com/users/images/e8af8452-9bcd-4b9c-95b2-c8a1254cc45e_1641067609.3005052.png)\\n\\n1 ,point [3,2] to building [0] [0] distance is 5 , total is 5\\n2 ,point [3,2] to building [0] [1] distance is 4 , total is 9\\n3 ,point [3,2] to building [0] [2] distance is 3 , total is 12\\n4 ,point [3,2] to building [0] [3] distance is 4 , total is 16\\n5 ,point [3,2] to building [0] [4] distance is 5 , total is 21\\n6 ,point [3,2] to building [1] [5] distance is 5 , total is 26\\n7 ,point [3,2] to building [2] [1] distance is 2 , total is 28\\n8 ,point [3,2] to building [2] [2] distance is 1 , total is 29\\n9 ,point [3,2] to building [2] [5] distance is 4 , total is 33\\n10 ,point [3,2] to building [3] [0] distance is 2 , total is 35\\n11 ,point [3,2] to building [3] [3] distance is 1 , total is 36\\n12 ,point [3,2] to building [3] [5] distance is 3 , total is 39\\n13 ,point [3,2] to building [4] [0] distance is 3 , total is 42\\n14 ,point [3,2] to building [4] [2] distance is 1 , total is 43\\n15 ,point [3,2] to building [4] [5] distance is 4 , total is 47\\n16 ,point [3,2] to building [5] [0] distance is 4 , total is 51\\n17 ,point [3,2] to building [5] [5] distance is 5 , total is 56\\n18 ,point [3,2] to building [6] [1] distance is 4 , total is 60\\n19 ,point [3,2] to building [6] [2] distance is 3 , total is 63\\n20 ,point [3,2] to building [6] [3] distance is 4 , total is 67\\n21 ,point [3,2] to building [6] [4] distance is 5 , total is 72\\n\\n![image](https://assets.leetcode.com/users/images/ce6c3d14-8826-4d86-864e-ab7806865d31_1641067774.8862677.png)\\n\\n\\n"
                    },
                    {
                        "username": "sabrinasong",
                        "content": "The question is almost the same as 296 except that here we have obstacles. In 296 we simply calculate its median, while here we have to use bfs. Can we do something on the basis of median solution?"
                    },
                    {
                        "username": "luckymaster",
                        "content": "How the distance is 88 for this test case.\\n\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\n\\nMine is 72,\\n\\nLeetcode 88;\\n\\n\\nBuildings = [2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 5,0, 6,1, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4] Size true\\nI can visit All buldings from (1,0)[2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 104\\nI can visit All buldings from (1,1)[2,1, 2,2, 0,0, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 91\\nI can visit All buldings from (1,2)[2,1, 2,2, 3,3, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 84\\nI can visit All buldings from (1,3)[2,1, 3,3, 2,2, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 85\\nI can visit All buldings from (1,4)[2,1, 3,3, 2,2, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 92\\nI can visit All buldings from (2,0)[2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 95\\nI can visit All buldings from (2,3)[2,1, 3,3, 2,2, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 76\\nI can visit All buldings from (2,4)[2,1, 3,3, 2,2, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 83\\nI can visit All buldings from (3,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 79\\nI can visit All buldings from (3,2)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 72\\nI can visit All buldings from (3,4)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 80\\nI can visit All buldings from (4,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 82\\nI can visit All buldings from (4,3)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 76\\nI can visit All buldings from (4,4)[2,1, 5,5, 3,3, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 83\\nI can visit All buldings from (5,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 91\\nI can visit All buldings from (5,2)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 84\\nI can visit All buldings from (5,3)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 85\\nI can visit All buldings from (5,4)[2,1, 5,5, 3,3, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 92"
                    },
                    {
                        "username": "jonreiland",
                        "content": "It\\'s because the problem description is incorrect. It\\'s not the Manhattan Distance that should be used, but the number of steps."
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store all the paths from all the buildings to the shortest path on the grid?\\n\\nAny ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "brahma0545",
                        "content": "in this test case the answer is mentioned 88\\n[1,1,1,1,1,0],\\n[0,0,0,0,0,1],\\n[0,1,1,0,0,1],\\n[1,0,0,1,0,1],\\n[1,0,1,0,0,1],\\n[1,0,0,0,0,1],\\n[0,1,1,1,1,0]\\n\\nbut how come (0,5) is rechable from the nodes (0,0)?\\n\\nshouldn\\'t it be -1"
                    },
                    {
                        "username": "aivanilov",
                        "content": "[@NekoShadow](/NekoShadow) The problem is that there\\'s a solution in [3,2] with distance 72 (instead of 88)"
                    },
                    {
                        "username": "NekoShadow",
                        "content": "Yes, (0, 5) is not reachable from (0, 0). So (0, 5) should not be used for building your new house. Just build the house somewhere else. Remember, you goal is to look for an empty land that can reach all buildings with minimum total Manhattan distance, NOT making sure that all empty lands can be reached by every building :)"
                    }
                ]
            },
            {
                "id": 1714386,
                "content": [
                    {
                        "username": "giof07",
                        "content": "The problem says the distance from one point to another is the mahattan distance, this should make bfs impossible... I see no solution in the discussion using the mahattan distance. What is going here? Can someone explain? If we use the manhattan distance to calculate the distance between two points how can we detect if there is an obstacle between two 0\\'s? If we can only move point to point and count each move as one, the problem is trivial, but manhattan distance seems to imply diagonal movement."
                    },
                    {
                        "username": "jeffkmeng",
                        "content": "The distance between two points is calculated with the manhattan distance, but that assumes there are no obstacles in between. The definition of manhattan distance is just that you assume you were walking along city blocks, so you *can\\'t* move diagonally."
                    },
                    {
                        "username": "pppprinciple",
                        "content": "\"The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.\"\\n\\nPlease fix. Looking at the tests, distance is expected to be calculated as number of steps taken in a given path."
                    },
                    {
                        "username": "lc4tc",
                        "content": "Last two sentences of the problem were blindly copied from https://leetcode.com/problems/best-meeting-point/, lol"
                    },
                    {
                        "username": "wuyinan",
                        "content": "Update:\\nI think I misunderstood this problem... I thought it asks to find an empty location that has access to all the houses and has the smallest sum of manhattan distances to all the houses and return that sum. It actually asks for the smallest sum of total steps to all the houses not Manhattan distances.\\n\\n=============================================================================================\\nTest case:\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\nMy code found the position at (3,2) has the shortest sum of distance of 72:\\n\\nPosition: dist to house 1, house 2, ...., sum of distance: \\n\\n6,0 : 1 1  sum: 2\\n5,1 : 6 5 6 7 8 8 3 4 7 3 4 6 2 2 5 1 4 1 2 3 4  sum: 91\\n5,2 : 7 6 5 6 7 7 4 3 6 4 3 5 3 1 4 2 3 2 1 2 3  sum: 84\\n4,1 : 5 4 5 6 7 7 2 3 6 2 3 5 1 1 4 2 5 2 3 4 5  sum: 82\\n2,0 : 2 3 4 5 6 6 1 2 5 1 4 6 2 4 7 3 8 5 6 7 8  sum: 95\\n5,3 : 8 7 6 5 6 6 5 4 5 5 2 4 4 2 3 3 2 3 2 1 2  sum: 85\\n3,1 : 4 3 4 5 6 6 1 2 5 1 2 4 2 2 5 3 6 3 4 5 6  sum: 79\\n1,0 : 1 2 3 4 5 5 2 3 6 2 5 7 3 5 8 4 9 6 7 8 9  sum: 104\\n5,4 : 9 8 7 6 5 5 6 5 4 6 3 3 5 3 2 4 1 4 3 2 1  sum: 92\\n4,3 : 7 6 5 4 5 5 4 3 4 4 1 3 3 1 2 4 3 4 3 2 3  sum: 76\\n3,2 : 5 4 3 4 5 5 2 1 4 2 1 3 3 1 4 4 5 4 3 4 5  sum: 72\\n6,5 : 1 1  sum: 2\\n1,1 : 2 1 2 3 4 4 1 2 5 3 4 6 4 4 7 5 8 5 6 7 8  sum: 91\\n4,4 : 8 7 6 5 4 4 5 4 3 5 2 2 4 2 1 5 2 5 4 3 2  sum: 83\\n1,2 : 3 2 1 2 3 3 2 1 4 4 3 5 5 3 6 6 7 6 5 6 7  sum: 84\\n2,3 : 5 4 3 2 3 3 2 1 2 4 1 3 5 3 4 6 5 6 5 4 5  sum: 76\\n3,4 : 7 6 5 4 3 3 4 3 2 4 1 1 5 3 2 6 3 6 5 4 3  sum: 80\\n1,3 : 4 3 2 1 2 2 3 2 3 5 2 4 6 4 5 7 6 7 6 5 6  sum: 85\\n2,4 : 6 5 4 3 2 2 3 2 1 5 2 2 6 4 3 7 4 7 6 5 4  sum: 83\\n1,4 : 5 4 3 2 1 1 4 3 2 6 3 3 7 5 4 8 5 8 7 6 5  sum: 92\\n0,5 : 1 1  sum: 2"
                    },
                    {
                        "username": "aivanilov",
                        "content": "I\\'ve got 72 as well in this case. And I don\\'t get why it\\'s 88 in the answer."
                    },
                    {
                        "username": "shchybovyk",
                        "content": "I still don\\'t understand what is actually asked to find"
                    },
                    {
                        "username": "sanemiliano",
                        "content": "Terrible statement: \"The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|. FIX ASAP. Spent two hours debbuging because I calculate the mahattan distance and turns out the test cases expect the sum of the steps."
                    },
                    {
                        "username": "littlelionman1",
                        "content": "TY for helping me"
                    },
                    {
                        "username": "cosR",
                        "content": "To solve this question there are two approaches:\\n1. start bfs from empty position i.e. 0\\n2. start bfs from building position i.e. 1\\n\\nApproach 1 mostly ends up with time ~ 250 ms\\nApproach 2 however ends up with time ~30 ms\\n\\nIs this due to the fact that majority of the test cases have lesser 1s compared to 0s in the grid? What do you think?"
                    },
                    {
                        "username": "doublefat",
                        "content": "Return the shortest travel distance for such a house. If it is not possible to build such a house according to the above rules, return -1.\\n\\nThe total travel distance is the sum of the distances between the houses of the friends and the meeting point.\\n\\n**The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.**\\n\\ntest case :\\n\\n\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\n![image](https://assets.leetcode.com/users/images/e8af8452-9bcd-4b9c-95b2-c8a1254cc45e_1641067609.3005052.png)\\n\\n1 ,point [3,2] to building [0] [0] distance is 5 , total is 5\\n2 ,point [3,2] to building [0] [1] distance is 4 , total is 9\\n3 ,point [3,2] to building [0] [2] distance is 3 , total is 12\\n4 ,point [3,2] to building [0] [3] distance is 4 , total is 16\\n5 ,point [3,2] to building [0] [4] distance is 5 , total is 21\\n6 ,point [3,2] to building [1] [5] distance is 5 , total is 26\\n7 ,point [3,2] to building [2] [1] distance is 2 , total is 28\\n8 ,point [3,2] to building [2] [2] distance is 1 , total is 29\\n9 ,point [3,2] to building [2] [5] distance is 4 , total is 33\\n10 ,point [3,2] to building [3] [0] distance is 2 , total is 35\\n11 ,point [3,2] to building [3] [3] distance is 1 , total is 36\\n12 ,point [3,2] to building [3] [5] distance is 3 , total is 39\\n13 ,point [3,2] to building [4] [0] distance is 3 , total is 42\\n14 ,point [3,2] to building [4] [2] distance is 1 , total is 43\\n15 ,point [3,2] to building [4] [5] distance is 4 , total is 47\\n16 ,point [3,2] to building [5] [0] distance is 4 , total is 51\\n17 ,point [3,2] to building [5] [5] distance is 5 , total is 56\\n18 ,point [3,2] to building [6] [1] distance is 4 , total is 60\\n19 ,point [3,2] to building [6] [2] distance is 3 , total is 63\\n20 ,point [3,2] to building [6] [3] distance is 4 , total is 67\\n21 ,point [3,2] to building [6] [4] distance is 5 , total is 72\\n\\n![image](https://assets.leetcode.com/users/images/ce6c3d14-8826-4d86-864e-ab7806865d31_1641067774.8862677.png)\\n\\n\\n"
                    },
                    {
                        "username": "sabrinasong",
                        "content": "The question is almost the same as 296 except that here we have obstacles. In 296 we simply calculate its median, while here we have to use bfs. Can we do something on the basis of median solution?"
                    },
                    {
                        "username": "luckymaster",
                        "content": "How the distance is 88 for this test case.\\n\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\n\\nMine is 72,\\n\\nLeetcode 88;\\n\\n\\nBuildings = [2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 5,0, 6,1, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4] Size true\\nI can visit All buldings from (1,0)[2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 104\\nI can visit All buldings from (1,1)[2,1, 2,2, 0,0, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 91\\nI can visit All buldings from (1,2)[2,1, 2,2, 3,3, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 84\\nI can visit All buldings from (1,3)[2,1, 3,3, 2,2, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 85\\nI can visit All buldings from (1,4)[2,1, 3,3, 2,2, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 92\\nI can visit All buldings from (2,0)[2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 95\\nI can visit All buldings from (2,3)[2,1, 3,3, 2,2, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 76\\nI can visit All buldings from (2,4)[2,1, 3,3, 2,2, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 83\\nI can visit All buldings from (3,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 79\\nI can visit All buldings from (3,2)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 72\\nI can visit All buldings from (3,4)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 80\\nI can visit All buldings from (4,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 82\\nI can visit All buldings from (4,3)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 76\\nI can visit All buldings from (4,4)[2,1, 5,5, 3,3, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 83\\nI can visit All buldings from (5,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 91\\nI can visit All buldings from (5,2)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 84\\nI can visit All buldings from (5,3)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 85\\nI can visit All buldings from (5,4)[2,1, 5,5, 3,3, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 92"
                    },
                    {
                        "username": "jonreiland",
                        "content": "It\\'s because the problem description is incorrect. It\\'s not the Manhattan Distance that should be used, but the number of steps."
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store all the paths from all the buildings to the shortest path on the grid?\\n\\nAny ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "brahma0545",
                        "content": "in this test case the answer is mentioned 88\\n[1,1,1,1,1,0],\\n[0,0,0,0,0,1],\\n[0,1,1,0,0,1],\\n[1,0,0,1,0,1],\\n[1,0,1,0,0,1],\\n[1,0,0,0,0,1],\\n[0,1,1,1,1,0]\\n\\nbut how come (0,5) is rechable from the nodes (0,0)?\\n\\nshouldn\\'t it be -1"
                    },
                    {
                        "username": "aivanilov",
                        "content": "[@NekoShadow](/NekoShadow) The problem is that there\\'s a solution in [3,2] with distance 72 (instead of 88)"
                    },
                    {
                        "username": "NekoShadow",
                        "content": "Yes, (0, 5) is not reachable from (0, 0). So (0, 5) should not be used for building your new house. Just build the house somewhere else. Remember, you goal is to look for an empty land that can reach all buildings with minimum total Manhattan distance, NOT making sure that all empty lands can be reached by every building :)"
                    }
                ]
            },
            {
                "id": 1573485,
                "content": [
                    {
                        "username": "giof07",
                        "content": "The problem says the distance from one point to another is the mahattan distance, this should make bfs impossible... I see no solution in the discussion using the mahattan distance. What is going here? Can someone explain? If we use the manhattan distance to calculate the distance between two points how can we detect if there is an obstacle between two 0\\'s? If we can only move point to point and count each move as one, the problem is trivial, but manhattan distance seems to imply diagonal movement."
                    },
                    {
                        "username": "jeffkmeng",
                        "content": "The distance between two points is calculated with the manhattan distance, but that assumes there are no obstacles in between. The definition of manhattan distance is just that you assume you were walking along city blocks, so you *can\\'t* move diagonally."
                    },
                    {
                        "username": "pppprinciple",
                        "content": "\"The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.\"\\n\\nPlease fix. Looking at the tests, distance is expected to be calculated as number of steps taken in a given path."
                    },
                    {
                        "username": "lc4tc",
                        "content": "Last two sentences of the problem were blindly copied from https://leetcode.com/problems/best-meeting-point/, lol"
                    },
                    {
                        "username": "wuyinan",
                        "content": "Update:\\nI think I misunderstood this problem... I thought it asks to find an empty location that has access to all the houses and has the smallest sum of manhattan distances to all the houses and return that sum. It actually asks for the smallest sum of total steps to all the houses not Manhattan distances.\\n\\n=============================================================================================\\nTest case:\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\nMy code found the position at (3,2) has the shortest sum of distance of 72:\\n\\nPosition: dist to house 1, house 2, ...., sum of distance: \\n\\n6,0 : 1 1  sum: 2\\n5,1 : 6 5 6 7 8 8 3 4 7 3 4 6 2 2 5 1 4 1 2 3 4  sum: 91\\n5,2 : 7 6 5 6 7 7 4 3 6 4 3 5 3 1 4 2 3 2 1 2 3  sum: 84\\n4,1 : 5 4 5 6 7 7 2 3 6 2 3 5 1 1 4 2 5 2 3 4 5  sum: 82\\n2,0 : 2 3 4 5 6 6 1 2 5 1 4 6 2 4 7 3 8 5 6 7 8  sum: 95\\n5,3 : 8 7 6 5 6 6 5 4 5 5 2 4 4 2 3 3 2 3 2 1 2  sum: 85\\n3,1 : 4 3 4 5 6 6 1 2 5 1 2 4 2 2 5 3 6 3 4 5 6  sum: 79\\n1,0 : 1 2 3 4 5 5 2 3 6 2 5 7 3 5 8 4 9 6 7 8 9  sum: 104\\n5,4 : 9 8 7 6 5 5 6 5 4 6 3 3 5 3 2 4 1 4 3 2 1  sum: 92\\n4,3 : 7 6 5 4 5 5 4 3 4 4 1 3 3 1 2 4 3 4 3 2 3  sum: 76\\n3,2 : 5 4 3 4 5 5 2 1 4 2 1 3 3 1 4 4 5 4 3 4 5  sum: 72\\n6,5 : 1 1  sum: 2\\n1,1 : 2 1 2 3 4 4 1 2 5 3 4 6 4 4 7 5 8 5 6 7 8  sum: 91\\n4,4 : 8 7 6 5 4 4 5 4 3 5 2 2 4 2 1 5 2 5 4 3 2  sum: 83\\n1,2 : 3 2 1 2 3 3 2 1 4 4 3 5 5 3 6 6 7 6 5 6 7  sum: 84\\n2,3 : 5 4 3 2 3 3 2 1 2 4 1 3 5 3 4 6 5 6 5 4 5  sum: 76\\n3,4 : 7 6 5 4 3 3 4 3 2 4 1 1 5 3 2 6 3 6 5 4 3  sum: 80\\n1,3 : 4 3 2 1 2 2 3 2 3 5 2 4 6 4 5 7 6 7 6 5 6  sum: 85\\n2,4 : 6 5 4 3 2 2 3 2 1 5 2 2 6 4 3 7 4 7 6 5 4  sum: 83\\n1,4 : 5 4 3 2 1 1 4 3 2 6 3 3 7 5 4 8 5 8 7 6 5  sum: 92\\n0,5 : 1 1  sum: 2"
                    },
                    {
                        "username": "aivanilov",
                        "content": "I\\'ve got 72 as well in this case. And I don\\'t get why it\\'s 88 in the answer."
                    },
                    {
                        "username": "shchybovyk",
                        "content": "I still don\\'t understand what is actually asked to find"
                    },
                    {
                        "username": "sanemiliano",
                        "content": "Terrible statement: \"The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|. FIX ASAP. Spent two hours debbuging because I calculate the mahattan distance and turns out the test cases expect the sum of the steps."
                    },
                    {
                        "username": "littlelionman1",
                        "content": "TY for helping me"
                    },
                    {
                        "username": "cosR",
                        "content": "To solve this question there are two approaches:\\n1. start bfs from empty position i.e. 0\\n2. start bfs from building position i.e. 1\\n\\nApproach 1 mostly ends up with time ~ 250 ms\\nApproach 2 however ends up with time ~30 ms\\n\\nIs this due to the fact that majority of the test cases have lesser 1s compared to 0s in the grid? What do you think?"
                    },
                    {
                        "username": "doublefat",
                        "content": "Return the shortest travel distance for such a house. If it is not possible to build such a house according to the above rules, return -1.\\n\\nThe total travel distance is the sum of the distances between the houses of the friends and the meeting point.\\n\\n**The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.**\\n\\ntest case :\\n\\n\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\n![image](https://assets.leetcode.com/users/images/e8af8452-9bcd-4b9c-95b2-c8a1254cc45e_1641067609.3005052.png)\\n\\n1 ,point [3,2] to building [0] [0] distance is 5 , total is 5\\n2 ,point [3,2] to building [0] [1] distance is 4 , total is 9\\n3 ,point [3,2] to building [0] [2] distance is 3 , total is 12\\n4 ,point [3,2] to building [0] [3] distance is 4 , total is 16\\n5 ,point [3,2] to building [0] [4] distance is 5 , total is 21\\n6 ,point [3,2] to building [1] [5] distance is 5 , total is 26\\n7 ,point [3,2] to building [2] [1] distance is 2 , total is 28\\n8 ,point [3,2] to building [2] [2] distance is 1 , total is 29\\n9 ,point [3,2] to building [2] [5] distance is 4 , total is 33\\n10 ,point [3,2] to building [3] [0] distance is 2 , total is 35\\n11 ,point [3,2] to building [3] [3] distance is 1 , total is 36\\n12 ,point [3,2] to building [3] [5] distance is 3 , total is 39\\n13 ,point [3,2] to building [4] [0] distance is 3 , total is 42\\n14 ,point [3,2] to building [4] [2] distance is 1 , total is 43\\n15 ,point [3,2] to building [4] [5] distance is 4 , total is 47\\n16 ,point [3,2] to building [5] [0] distance is 4 , total is 51\\n17 ,point [3,2] to building [5] [5] distance is 5 , total is 56\\n18 ,point [3,2] to building [6] [1] distance is 4 , total is 60\\n19 ,point [3,2] to building [6] [2] distance is 3 , total is 63\\n20 ,point [3,2] to building [6] [3] distance is 4 , total is 67\\n21 ,point [3,2] to building [6] [4] distance is 5 , total is 72\\n\\n![image](https://assets.leetcode.com/users/images/ce6c3d14-8826-4d86-864e-ab7806865d31_1641067774.8862677.png)\\n\\n\\n"
                    },
                    {
                        "username": "sabrinasong",
                        "content": "The question is almost the same as 296 except that here we have obstacles. In 296 we simply calculate its median, while here we have to use bfs. Can we do something on the basis of median solution?"
                    },
                    {
                        "username": "luckymaster",
                        "content": "How the distance is 88 for this test case.\\n\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\n\\nMine is 72,\\n\\nLeetcode 88;\\n\\n\\nBuildings = [2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 5,0, 6,1, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4] Size true\\nI can visit All buldings from (1,0)[2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 104\\nI can visit All buldings from (1,1)[2,1, 2,2, 0,0, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 91\\nI can visit All buldings from (1,2)[2,1, 2,2, 3,3, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 84\\nI can visit All buldings from (1,3)[2,1, 3,3, 2,2, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 85\\nI can visit All buldings from (1,4)[2,1, 3,3, 2,2, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 92\\nI can visit All buldings from (2,0)[2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 95\\nI can visit All buldings from (2,3)[2,1, 3,3, 2,2, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 76\\nI can visit All buldings from (2,4)[2,1, 3,3, 2,2, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 83\\nI can visit All buldings from (3,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 79\\nI can visit All buldings from (3,2)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 72\\nI can visit All buldings from (3,4)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 80\\nI can visit All buldings from (4,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 82\\nI can visit All buldings from (4,3)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 76\\nI can visit All buldings from (4,4)[2,1, 5,5, 3,3, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 83\\nI can visit All buldings from (5,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 91\\nI can visit All buldings from (5,2)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 84\\nI can visit All buldings from (5,3)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 85\\nI can visit All buldings from (5,4)[2,1, 5,5, 3,3, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 92"
                    },
                    {
                        "username": "jonreiland",
                        "content": "It\\'s because the problem description is incorrect. It\\'s not the Manhattan Distance that should be used, but the number of steps."
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store all the paths from all the buildings to the shortest path on the grid?\\n\\nAny ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "brahma0545",
                        "content": "in this test case the answer is mentioned 88\\n[1,1,1,1,1,0],\\n[0,0,0,0,0,1],\\n[0,1,1,0,0,1],\\n[1,0,0,1,0,1],\\n[1,0,1,0,0,1],\\n[1,0,0,0,0,1],\\n[0,1,1,1,1,0]\\n\\nbut how come (0,5) is rechable from the nodes (0,0)?\\n\\nshouldn\\'t it be -1"
                    },
                    {
                        "username": "aivanilov",
                        "content": "[@NekoShadow](/NekoShadow) The problem is that there\\'s a solution in [3,2] with distance 72 (instead of 88)"
                    },
                    {
                        "username": "NekoShadow",
                        "content": "Yes, (0, 5) is not reachable from (0, 0). So (0, 5) should not be used for building your new house. Just build the house somewhere else. Remember, you goal is to look for an empty land that can reach all buildings with minimum total Manhattan distance, NOT making sure that all empty lands can be reached by every building :)"
                    }
                ]
            },
            {
                "id": 1575492,
                "content": [
                    {
                        "username": "giof07",
                        "content": "The problem says the distance from one point to another is the mahattan distance, this should make bfs impossible... I see no solution in the discussion using the mahattan distance. What is going here? Can someone explain? If we use the manhattan distance to calculate the distance between two points how can we detect if there is an obstacle between two 0\\'s? If we can only move point to point and count each move as one, the problem is trivial, but manhattan distance seems to imply diagonal movement."
                    },
                    {
                        "username": "jeffkmeng",
                        "content": "The distance between two points is calculated with the manhattan distance, but that assumes there are no obstacles in between. The definition of manhattan distance is just that you assume you were walking along city blocks, so you *can\\'t* move diagonally."
                    },
                    {
                        "username": "pppprinciple",
                        "content": "\"The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.\"\\n\\nPlease fix. Looking at the tests, distance is expected to be calculated as number of steps taken in a given path."
                    },
                    {
                        "username": "lc4tc",
                        "content": "Last two sentences of the problem were blindly copied from https://leetcode.com/problems/best-meeting-point/, lol"
                    },
                    {
                        "username": "wuyinan",
                        "content": "Update:\\nI think I misunderstood this problem... I thought it asks to find an empty location that has access to all the houses and has the smallest sum of manhattan distances to all the houses and return that sum. It actually asks for the smallest sum of total steps to all the houses not Manhattan distances.\\n\\n=============================================================================================\\nTest case:\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\nMy code found the position at (3,2) has the shortest sum of distance of 72:\\n\\nPosition: dist to house 1, house 2, ...., sum of distance: \\n\\n6,0 : 1 1  sum: 2\\n5,1 : 6 5 6 7 8 8 3 4 7 3 4 6 2 2 5 1 4 1 2 3 4  sum: 91\\n5,2 : 7 6 5 6 7 7 4 3 6 4 3 5 3 1 4 2 3 2 1 2 3  sum: 84\\n4,1 : 5 4 5 6 7 7 2 3 6 2 3 5 1 1 4 2 5 2 3 4 5  sum: 82\\n2,0 : 2 3 4 5 6 6 1 2 5 1 4 6 2 4 7 3 8 5 6 7 8  sum: 95\\n5,3 : 8 7 6 5 6 6 5 4 5 5 2 4 4 2 3 3 2 3 2 1 2  sum: 85\\n3,1 : 4 3 4 5 6 6 1 2 5 1 2 4 2 2 5 3 6 3 4 5 6  sum: 79\\n1,0 : 1 2 3 4 5 5 2 3 6 2 5 7 3 5 8 4 9 6 7 8 9  sum: 104\\n5,4 : 9 8 7 6 5 5 6 5 4 6 3 3 5 3 2 4 1 4 3 2 1  sum: 92\\n4,3 : 7 6 5 4 5 5 4 3 4 4 1 3 3 1 2 4 3 4 3 2 3  sum: 76\\n3,2 : 5 4 3 4 5 5 2 1 4 2 1 3 3 1 4 4 5 4 3 4 5  sum: 72\\n6,5 : 1 1  sum: 2\\n1,1 : 2 1 2 3 4 4 1 2 5 3 4 6 4 4 7 5 8 5 6 7 8  sum: 91\\n4,4 : 8 7 6 5 4 4 5 4 3 5 2 2 4 2 1 5 2 5 4 3 2  sum: 83\\n1,2 : 3 2 1 2 3 3 2 1 4 4 3 5 5 3 6 6 7 6 5 6 7  sum: 84\\n2,3 : 5 4 3 2 3 3 2 1 2 4 1 3 5 3 4 6 5 6 5 4 5  sum: 76\\n3,4 : 7 6 5 4 3 3 4 3 2 4 1 1 5 3 2 6 3 6 5 4 3  sum: 80\\n1,3 : 4 3 2 1 2 2 3 2 3 5 2 4 6 4 5 7 6 7 6 5 6  sum: 85\\n2,4 : 6 5 4 3 2 2 3 2 1 5 2 2 6 4 3 7 4 7 6 5 4  sum: 83\\n1,4 : 5 4 3 2 1 1 4 3 2 6 3 3 7 5 4 8 5 8 7 6 5  sum: 92\\n0,5 : 1 1  sum: 2"
                    },
                    {
                        "username": "aivanilov",
                        "content": "I\\'ve got 72 as well in this case. And I don\\'t get why it\\'s 88 in the answer."
                    },
                    {
                        "username": "shchybovyk",
                        "content": "I still don\\'t understand what is actually asked to find"
                    },
                    {
                        "username": "sanemiliano",
                        "content": "Terrible statement: \"The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|. FIX ASAP. Spent two hours debbuging because I calculate the mahattan distance and turns out the test cases expect the sum of the steps."
                    },
                    {
                        "username": "littlelionman1",
                        "content": "TY for helping me"
                    },
                    {
                        "username": "cosR",
                        "content": "To solve this question there are two approaches:\\n1. start bfs from empty position i.e. 0\\n2. start bfs from building position i.e. 1\\n\\nApproach 1 mostly ends up with time ~ 250 ms\\nApproach 2 however ends up with time ~30 ms\\n\\nIs this due to the fact that majority of the test cases have lesser 1s compared to 0s in the grid? What do you think?"
                    },
                    {
                        "username": "doublefat",
                        "content": "Return the shortest travel distance for such a house. If it is not possible to build such a house according to the above rules, return -1.\\n\\nThe total travel distance is the sum of the distances between the houses of the friends and the meeting point.\\n\\n**The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.**\\n\\ntest case :\\n\\n\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\n![image](https://assets.leetcode.com/users/images/e8af8452-9bcd-4b9c-95b2-c8a1254cc45e_1641067609.3005052.png)\\n\\n1 ,point [3,2] to building [0] [0] distance is 5 , total is 5\\n2 ,point [3,2] to building [0] [1] distance is 4 , total is 9\\n3 ,point [3,2] to building [0] [2] distance is 3 , total is 12\\n4 ,point [3,2] to building [0] [3] distance is 4 , total is 16\\n5 ,point [3,2] to building [0] [4] distance is 5 , total is 21\\n6 ,point [3,2] to building [1] [5] distance is 5 , total is 26\\n7 ,point [3,2] to building [2] [1] distance is 2 , total is 28\\n8 ,point [3,2] to building [2] [2] distance is 1 , total is 29\\n9 ,point [3,2] to building [2] [5] distance is 4 , total is 33\\n10 ,point [3,2] to building [3] [0] distance is 2 , total is 35\\n11 ,point [3,2] to building [3] [3] distance is 1 , total is 36\\n12 ,point [3,2] to building [3] [5] distance is 3 , total is 39\\n13 ,point [3,2] to building [4] [0] distance is 3 , total is 42\\n14 ,point [3,2] to building [4] [2] distance is 1 , total is 43\\n15 ,point [3,2] to building [4] [5] distance is 4 , total is 47\\n16 ,point [3,2] to building [5] [0] distance is 4 , total is 51\\n17 ,point [3,2] to building [5] [5] distance is 5 , total is 56\\n18 ,point [3,2] to building [6] [1] distance is 4 , total is 60\\n19 ,point [3,2] to building [6] [2] distance is 3 , total is 63\\n20 ,point [3,2] to building [6] [3] distance is 4 , total is 67\\n21 ,point [3,2] to building [6] [4] distance is 5 , total is 72\\n\\n![image](https://assets.leetcode.com/users/images/ce6c3d14-8826-4d86-864e-ab7806865d31_1641067774.8862677.png)\\n\\n\\n"
                    },
                    {
                        "username": "sabrinasong",
                        "content": "The question is almost the same as 296 except that here we have obstacles. In 296 we simply calculate its median, while here we have to use bfs. Can we do something on the basis of median solution?"
                    },
                    {
                        "username": "luckymaster",
                        "content": "How the distance is 88 for this test case.\\n\\n[[1,1,1,1,1,0],[0,0,0,0,0,1],[0,1,1,0,0,1],[1,0,0,1,0,1],[1,0,1,0,0,1],[1,0,0,0,0,1],[0,1,1,1,1,0]]\\n\\n\\nMine is 72,\\n\\nLeetcode 88;\\n\\n\\nBuildings = [2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 5,0, 6,1, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4] Size true\\nI can visit All buldings from (1,0)[2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 104\\nI can visit All buldings from (1,1)[2,1, 2,2, 0,0, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 91\\nI can visit All buldings from (1,2)[2,1, 2,2, 3,3, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 84\\nI can visit All buldings from (1,3)[2,1, 3,3, 2,2, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 85\\nI can visit All buldings from (1,4)[2,1, 3,3, 2,2, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 92\\nI can visit All buldings from (2,0)[2,1, 0,0, 2,2, 3,3, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 95\\nI can visit All buldings from (2,3)[2,1, 3,3, 2,2, 0,0, 5,5, 0,1, 4,5, 0,2, 3,5, 0,3, 2,5, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 3,0, 6,3, 6,4, 4,2]\\nManhatten distance = 76\\nI can visit All buldings from (2,4)[2,1, 3,3, 2,2, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 83\\nI can visit All buldings from (3,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 79\\nI can visit All buldings from (3,2)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 72\\nI can visit All buldings from (3,4)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 80\\nI can visit All buldings from (4,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 82\\nI can visit All buldings from (4,3)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 76\\nI can visit All buldings from (4,4)[2,1, 5,5, 3,3, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 83\\nI can visit All buldings from (5,1)[2,1, 2,2, 3,3, 5,5, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 4,0, 6,2, 3,0, 6,3, 4,2, 6,4]\\nManhatten distance = 91\\nI can visit All buldings from (5,2)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 84\\nI can visit All buldings from (5,3)[2,1, 3,3, 5,5, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 4,2, 6,4]\\nManhatten distance = 85\\nI can visit All buldings from (5,4)[2,1, 5,5, 3,3, 2,2, 0,0, 4,5, 0,1, 3,5, 0,2, 2,5, 0,3, 0,4, 1,5, 6,1, 5,0, 6,2, 4,0, 6,3, 3,0, 6,4, 4,2]\\nManhatten distance = 92"
                    },
                    {
                        "username": "jonreiland",
                        "content": "It\\'s because the problem description is incorrect. It\\'s not the Manhattan Distance that should be used, but the number of steps."
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store all the paths from all the buildings to the shortest path on the grid?\\n\\nAny ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "brahma0545",
                        "content": "in this test case the answer is mentioned 88\\n[1,1,1,1,1,0],\\n[0,0,0,0,0,1],\\n[0,1,1,0,0,1],\\n[1,0,0,1,0,1],\\n[1,0,1,0,0,1],\\n[1,0,0,0,0,1],\\n[0,1,1,1,1,0]\\n\\nbut how come (0,5) is rechable from the nodes (0,0)?\\n\\nshouldn\\'t it be -1"
                    },
                    {
                        "username": "aivanilov",
                        "content": "[@NekoShadow](/NekoShadow) The problem is that there\\'s a solution in [3,2] with distance 72 (instead of 88)"
                    },
                    {
                        "username": "NekoShadow",
                        "content": "Yes, (0, 5) is not reachable from (0, 0). So (0, 5) should not be used for building your new house. Just build the house somewhere else. Remember, you goal is to look for an empty land that can reach all buildings with minimum total Manhattan distance, NOT making sure that all empty lands can be reached by every building :)"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find Smallest Letter Greater Than Target",
        "question_content": "<p>You are given an array of characters <code>letters</code> that is sorted in <strong>non-decreasing order</strong>, and a character <code>target</code>. There are <strong>at least two different</strong> characters in <code>letters</code>.</p>\n\n<p>Return <em>the smallest character in </em><code>letters</code><em> that is lexicographically greater than </em><code>target</code>. If such a character does not exist, return the first character in <code>letters</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> letters = [&quot;c&quot;,&quot;f&quot;,&quot;j&quot;], target = &quot;a&quot;\n<strong>Output:</strong> &quot;c&quot;\n<strong>Explanation:</strong> The smallest character that is lexicographically greater than &#39;a&#39; in letters is &#39;c&#39;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> letters = [&quot;c&quot;,&quot;f&quot;,&quot;j&quot;], target = &quot;c&quot;\n<strong>Output:</strong> &quot;f&quot;\n<strong>Explanation:</strong> The smallest character that is lexicographically greater than &#39;c&#39; in letters is &#39;f&#39;.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> letters = [&quot;x&quot;,&quot;x&quot;,&quot;y&quot;,&quot;y&quot;], target = &quot;z&quot;\n<strong>Output:</strong> &quot;x&quot;\n<strong>Explanation:</strong> There are no characters in letters that is lexicographically greater than &#39;z&#39; so we return letters[0].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= letters.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>letters[i]</code> is a lowercase English letter.</li>\n\t<li><code>letters</code> is sorted in <strong>non-decreasing</strong> order.</li>\n\t<li><code>letters</code> contains at least two different characters.</li>\n\t<li><code>target</code> is a lowercase English letter.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1568523,
                "title": "python-easy-solution-with-detail-explanation-modified-binary-search",
                "content": "##### Idea : the trick is to use modified binary search\\nWe keep searching until low bound greater than upper bound\\n* First we need to take care of edge cases \\n\\t* If the letter is out of boundary (above the last letter or below the first letter)\\n\\t\\t* return the first letter \\n* If the letter is in the boundary of the list \\n\\t* Apply the binary search with only one change\\n\\t\\t* **when updating the bottom boundary check if the target is greater than or equal to the mid value** ( In binary search we only check if it is greater than )\\n\\t\\t\\t* The reason is : since we are asked to return the value above the target value we want to keep track of the value one step above the low value \\n\\t* when the low > high \\n\\t\\t* we return the letters[low]\\n\\n```\\nclass Solution(object):\\n    def nextGreatestLetter(self, letters, target):\\n        \"\"\"\\n        :type letters: List[str]\\n        :type target: str\\n        :rtype: str\\n        \"\"\"\\n        \\n        # if the number is out of bound\\n        if target >= letters[-1] or target < letters[0]:\\n            return letters[0]\\n        \\n        low = 0\\n        high = len(letters)-1\\n        while low <= high:\\n            mid = (high+low)//2\\n            \\n            if  target >= letters[mid]: # in binary search this would be only greater than\\n                low = mid+1\\n            \\n            if target < letters[mid]:\\n                high = mid-1\\n                \\n        return letters[low]\\n```\\n\\n##### I hope you\\'ve found this helpful\\n##### Please upvote and encourage me to on my quest to document all leetcode problems \\uD83D\\uDC4D\\n##### PS: Search for Abeni tag in the discussion, if I have solved it, You will find a detial explanation there\\uD83D\\uDCBB",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution(object):\\n    def nextGreatestLetter(self, letters, target):\\n        \"\"\"\\n        :type letters: List[str]\\n        :type target: str\\n        :rtype: str\\n        \"\"\"\\n        \\n        # if the number is out of bound\\n        if target >= letters[-1] or target < letters[0]:\\n            return letters[0]\\n        \\n        low = 0\\n        high = len(letters)-1\\n        while low <= high:\\n            mid = (high+low)//2\\n            \\n            if  target >= letters[mid]: # in binary search this would be only greater than\\n                low = mid+1\\n            \\n            if target < letters[mid]:\\n                high = mid-1\\n                \\n        return letters[low]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 110005,
                "title": "easy-binary-search-in-java-o-log-n-time",
                "content": "Binary search for the character which comes immediately after character target in the alphabets, or if the target is greater than or equal to the last character in the input list, then search for the first character in the list.\\n\\n```\\nclass Solution {\\n    public char nextGreatestLetter(char[] a, char x) {\\n        int n = a.length;\\n       \\n        if (x >= a[n - 1])   x = a[0];\\n        else    x++;\\n        \\n        int lo = 0, hi = n - 1;\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (a[mid] == x)    return a[mid];\\n            if (a[mid] < x)     lo = mid + 1;\\n            else    hi = mid;\\n        }\\n        return a[hi];\\n    }\\n}\\n```\\n\\nEDIT: Thanks to @xpfxzxc for a further optimized solution:\\n\\n```\\nclass Solution {\\n    public char nextGreatestLetter(char[] a, char x) {\\n        int n = a.length;\\n\\n        //hi starts at 'n' rather than the usual 'n - 1'. \\n        //It is because the terminal condition is 'lo < hi' and if hi starts from 'n - 1', \\n        //we can never consider value at index 'n - 1'\\n        int lo = 0, hi = n;\\n\\n        //Terminal condition is 'lo < hi', to avoid infinite loop when target is smaller than the first element\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (a[mid] > x)     hi = mid;\\n            else    lo = mid + 1;                 //a[mid] <= x\\n        }\\n \\n        //Because lo can end up pointing to index 'n', in which case we return the first element\\n        return a[lo % n];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public char nextGreatestLetter(char[] a, char x) {\\n        int n = a.length;\\n       \\n        if (x >= a[n - 1])   x = a[0];\\n        else    x++;\\n        \\n        int lo = 0, hi = n - 1;\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (a[mid] == x)    return a[mid];\\n            if (a[mid] < x)     lo = mid + 1;\\n            else    hi = mid;\\n        }\\n        return a[hi];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public char nextGreatestLetter(char[] a, char x) {\\n        int n = a.length;\\n\\n        //hi starts at 'n' rather than the usual 'n - 1'. \\n        //It is because the terminal condition is 'lo < hi' and if hi starts from 'n - 1', \\n        //we can never consider value at index 'n - 1'\\n        int lo = 0, hi = n;\\n\\n        //Terminal condition is 'lo < hi', to avoid infinite loop when target is smaller than the first element\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (a[mid] > x)     hi = mid;\\n            else    lo = mid + 1;                 //a[mid] <= x\\n        }\\n \\n        //Because lo can end up pointing to index 'n', in which case we return the first element\\n        return a[lo % n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 110030,
                "title": "python-no-brainer",
                "content": "Since the input is sorted, you can use binary search, or simply linear scan and it will still be accepted.\\n\\n```\\nclass Solution(object):\\n    def nextGreatestLetter(self, letters, target):\\n        for letter in letters:\\n            if letter > target:\\n                return letter\\n        return letters[0] # If not found\\n```\\n\\nUsing `bisect`:\\n\\n```\\nclass Solution(object):\\n    def nextGreatestLetter(self, letters, target):\\n        pos = bisect.bisect_right(letters, target)\\n        return letters[0] if pos == len(letters) else letters[pos]\\n```\\n\\n**\\uD83D\\uDCAF Check out https://www.techinterviewhandbook.org for more tips and tricks by me to ace your coding interview \\uD83D\\uDCAF**",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def nextGreatestLetter(self, letters, target):\\n        for letter in letters:\\n            if letter > target:\\n                return letter\\n        return letters[0] # If not found\\n```\n```\\nclass Solution(object):\\n    def nextGreatestLetter(self, letters, target):\\n        pos = bisect.bisect_right(letters, target)\\n        return letters[0] if pos == len(letters) else letters[pos]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 112825,
                "title": "c-2-lines-solution-using-upper-bound",
                "content": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        auto it = upper_bound(letters.begin(), letters.end(), target);\\n        return it == letters.end() ? letters[0] : *it;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        auto it = upper_bound(letters.begin(), letters.end(), target);\\n        return it == letters.end() ? letters[0] : *it;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615581,
                "title": "python3-binary-search-template",
                "content": "I was looking for an **intuitive binary search template** for a while and eventually found this one which I really like:\\n```python\\ndef binarySearch():\\n    s = 0               ### a start index (a valid index)\\n    e = len(something)  ### the total length of something (an invalid index, assuming 0-indexed)\\n    while s+1<e:\\n        mid = (s+e)//2\\n        ### when we check mid, if it meets the condition, we assign mid to s\\n        ### because we want to make sure s is always at a valid index\\n        if check(mid):\\n            s = mid\\n        else:\\n            e = mid\\n    return s ### again s is always a valid index, so it should be the answer\\n```\\nThe advantage of this template is that we don\\'t need to think too much about the indices (e.g., +1, -1, odd, even, etc.) because we know that s will always be valid and it will be the result at the end. Note that, sometimes, depending on the problem, we may want to make ```e``` be the result, and in that case, we will assign ```s``` to -1 (0-indexed) and let ```e``` be len(something)-1 at the beginning, and make sure ```e``` is always valid during the search (see solution to this problem).\\n\\n**Solution to the problem** O(logn)\\n\\n```python\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        s = -1\\n        e = len(letters)-1\\n        while s+1<e:\\n            mid = (s+e)//2\\n            if letters[mid]>target:\\n                e = mid\\n            else:\\n                s = mid\\n        return letters[e] if letters[e]>target else letters[0]\\n```",
                "solutionTags": [],
                "code": "```python\\ndef binarySearch():\\n    s = 0               ### a start index (a valid index)\\n    e = len(something)  ### the total length of something (an invalid index, assuming 0-indexed)\\n    while s+1<e:\\n        mid = (s+e)//2\\n        ### when we check mid, if it meets the condition, we assign mid to s\\n        ### because we want to make sure s is always at a valid index\\n        if check(mid):\\n            s = mid\\n        else:\\n            e = mid\\n    return s ### again s is always a valid index, so it should be the answer\\n```\n```e```\n```s```\n```e```\n```e```\n```python\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        s = -1\\n        e = len(letters)-1\\n        while s+1<e:\\n            mid = (s+e)//2\\n            if letters[mid]>target:\\n                e = mid\\n            else:\\n                s = mid\\n        return letters[e] if letters[e]>target else letters[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 110027,
                "title": "c-solution-o-log-n",
                "content": "upper_bound solution:\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        auto begin = letters.begin(), end = letters.end();\\n        auto iter = upper_bound(begin, end, target);\\n        return iter != end ? *iter : *begin;\\n    }\\n};\\n```\\nbinary search solution:\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        if (letters.back() <= target) return letters.front();\\n        int low = 0, high = letters.size() - 1;\\n        while (low < high) {\\n            auto mid = (low + high) / 2;\\n            if (target < letters[mid]) high = mid;\\n            else low = mid + 1;\\n        }\\n        return letters[low];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        auto begin = letters.begin(), end = letters.end();\\n        auto iter = upper_bound(begin, end, target);\\n        return iter != end ? *iter : *begin;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        if (letters.back() <= target) return letters.front();\\n        int low = 0, high = letters.size() - 1;\\n        while (low < high) {\\n            auto mid = (low + high) / 2;\\n            if (target < letters[mid]) high = mid;\\n            else low = mid + 1;\\n        }\\n        return letters[low];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760959,
                "title": "c-3-approaches-easy-to-understand",
                "content": "***Runtime: 28 ms, faster than 87.59% of C++ online submissions for Find Smallest Letter Greater Than Target.\\nMemory Usage: 16.2 MB, less than 6.06% of C++ online submissions for Find Smallest Letter Greater Than Target.***\\n\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        vector<int> alphabets(26, 0);\\n        for(int i=0; i<letters.size() ;i++){\\n            alphabets[letters[i] - \\'a\\']++;\\n        }\\n        int index = (target - \\'a\\' + 1)%26;\\n        while(alphabets[index] == 0){\\n            index = (index+1)%26;\\n        }\\n        return \\'a\\'+index;\\n    }\\n};\\n```\\n***Runtime: 24 ms, faster than 95.45% of C++ online submissions for Find Smallest Letter Greater Than Target.\\nMemory Usage: 16.2 MB, less than 9.85% of C++ online submissions for Find Smallest Letter Greater Than Target.***\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int index = upper_bound(letters.begin(), letters.end(), target) - letters.begin();\\n        return index >= letters.size() ? letters[0] : letters[index];\\n    }\\n};\\n```\\n***Runtime: 28 ms, faster than 87.59% of C++ online submissions for Find Smallest Letter Greater Than Target.\\nMemory Usage: 15.9 MB, less than 77.27% of C++ online submissions for Find Smallest Letter Greater Than Target.***\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int low = 0;\\n        int high = letters.size()-1;\\n        while(low < high){\\n            int mid = low + (high - low)/2;\\n            if(letters[mid] <= target){\\n                low = mid+1;\\n            }else{\\n                high = mid;\\n            }\\n        }\\n        return letters[low] > target ? letters[low] : letters[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        vector<int> alphabets(26, 0);\\n        for(int i=0; i<letters.size() ;i++){\\n            alphabets[letters[i] - \\'a\\']++;\\n        }\\n        int index = (target - \\'a\\' + 1)%26;\\n        while(alphabets[index] == 0){\\n            index = (index+1)%26;\\n        }\\n        return \\'a\\'+index;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int index = upper_bound(letters.begin(), letters.end(), target) - letters.begin();\\n        return index >= letters.size() ? letters[0] : letters[index];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int low = 0;\\n        int high = letters.size()-1;\\n        while(low < high){\\n            int mid = low + (high - low)/2;\\n            if(letters[mid] <= target){\\n                low = mid+1;\\n            }else{\\n                high = mid;\\n            }\\n        }\\n        return letters[low] > target ? letters[low] : letters[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 694632,
                "title": "100-binary-search-java",
                "content": "```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        char res=letters[0];\\n        int start=0;\\n        int end=letters.length-1;\\n        while(start<=end)\\n        {\\n            int mid=start+(end-start)/2;\\n            if(letters[mid]==target)\\n            {\\n                start=mid+1;\\n            }\\n            else if(target>letters[mid])\\n            {\\n                start=mid+1;\\n            }\\n            else if(letters[mid]>target)\\n            {\\n                res=letters[mid];\\n                end=mid-1;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        char res=letters[0];\\n        int start=0;\\n        int end=letters.length-1;\\n        while(start<=end)\\n        {\\n            int mid=start+(end-start)/2;\\n            if(letters[mid]==target)\\n            {\\n                start=mid+1;\\n            }\\n            else if(target>letters[mid])\\n            {\\n                start=mid+1;\\n            }\\n            else if(letters[mid]>target)\\n            {\\n                res=letters[mid];\\n                end=mid-1;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 506564,
                "title": "javascript-one-line-o-n",
                "content": "**Binary Search** will give you O(log(n)), but if you just want a quick O(n) solution, see below:\\n\\n```javascript\\n/**\\n * @param {character[]} letters\\n * @param {character} target\\n * @return {character}\\n */\\nvar nextGreatestLetter = function(letters, target) {\\n  return letters.find(c => c > target) || letters[0];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {character[]} letters\\n * @param {character} target\\n * @return {character}\\n */\\nvar nextGreatestLetter = function(letters, target) {\\n  return letters.find(c => c > target) || letters[0];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 432458,
                "title": "beats-99-9-modified-binary-search-approach-in-o-log-n-with-constant-space",
                "content": "```\\n\"\"\"\\nRuntime O(log n)\\nSpacetime O(1)\\n\\n\\n-- submission stats --\\nRuntime: 104 ms, faster than 99.92% of Python3 online submissions for Find Smallest Letter Greater Than Target.\\nMemory Usage: 12.9 MB, less than 100.00% of Python3 online submissions for Find Smallest Letter Greater Than Target.\\n\"\"\"\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        letters_length = len(letters)\\n        low = 0\\n        high = letters_length - 1\\n        \\n\\t\\t# target is outside the bounds of letters\\n\\t\\t# because the array is circular, this means that the next greatest value \\n\\t\\t# must be the first value in the array. If the value is within the bounds\\n\\t\\t# of the array we can perform our regular modified binary search\\n        if target < letters[low] or target >= letters[high]:\\n            return letters[low]\\n\\n        while low <= high:\\n            middle =  (low + high) // 2\\n            candidate = letters[middle]\\n            \\n            if target < candidate: \\n                high = middle - 1\\n            \\n\\t\\t\\t# becuase we\\'re looking for the smallest value thats greater then the target\\n\\t\\t\\t# we can condense the typical case where target == letters[middle] into the \\n\\t\\t\\t# the target > letters[middle] case\\n            if target >= candidate :\\n                low = middle + 1\\n        \\n        return letters[low]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\"\"\"\\nRuntime O(log n)\\nSpacetime O(1)\\n\\n\\n-- submission stats --\\nRuntime: 104 ms, faster than 99.92% of Python3 online submissions for Find Smallest Letter Greater Than Target.\\nMemory Usage: 12.9 MB, less than 100.00% of Python3 online submissions for Find Smallest Letter Greater Than Target.\\n\"\"\"\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        letters_length = len(letters)\\n        low = 0\\n        high = letters_length - 1\\n        \\n\\t\\t# target is outside the bounds of letters\\n\\t\\t# because the array is circular, this means that the next greatest value \\n\\t\\t# must be the first value in the array. If the value is within the bounds\\n\\t\\t# of the array we can perform our regular modified binary search\\n        if target < letters[low] or target >= letters[high]:\\n            return letters[low]\\n\\n        while low <= high:\\n            middle =  (low + high) // 2\\n            candidate = letters[middle]\\n            \\n            if target < candidate: \\n                high = middle - 1\\n            \\n\\t\\t\\t# becuase we\\'re looking for the smallest value thats greater then the target\\n\\t\\t\\t# we can condense the typical case where target == letters[middle] into the \\n\\t\\t\\t# the target > letters[middle] case\\n            if target >= candidate :\\n                low = middle + 1\\n        \\n        return letters[low]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 191707,
                "title": "java-binary-search-solution",
                "content": "O(logn) time complexity O(1) space\\n```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        int i = 0;\\n        int start = 0;\\n        int end = letters.length-1;\\n        while(start<=end){\\n            int mid = start+(end-start)/2;\\n            if(letters[mid]<=target){\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n        return letters[(start)%letters.length];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        int i = 0;\\n        int start = 0;\\n        int end = letters.length-1;\\n        while(start<=end){\\n            int mid = start+(end-start)/2;\\n            if(letters[mid]<=target){\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n        return letters[(start)%letters.length];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615637,
                "title": "java-easy-solution-100-faster-code-beginner-friendly",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic char nextGreatestLetter(char[] letters, char target) {\\nint left = 0;\\nint right = letters.length-1;\\nwhile(left<=right){\\nint mid = left +(right-left)/2;\\nif(letters[mid]>target){\\nright=mid-1;\\n}\\nelse{\\nleft = mid+1;\\n}\\n}\\nreturn letters[left%letters.length];\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic char nextGreatestLetter(char[] letters, char target) {\\nint left = 0;\\nint right = letters.length-1;\\nwhile(left<=right){\\nint mid = left +(right-left)/2;\\nif(letters[mid]>target){\\nright=mid-1;\\n}\\nelse{\\nleft = mid+1;\\n}\\n}\\nreturn letters[left%letters.length];\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507850,
                "title": "4-lines-of-code-easy-understandable-in-python",
                "content": "![image](https://assets.leetcode.com/users/images/e24044e3-a0ab-46d9-bb0a-4ec7969326f5_1661924487.626893.png)\\n\\n```\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n\\n        t_ord = ord(target) - ord(\\'a\\')\\n        for i in letters:\\n            l_ord = ord(i) - ord(\\'a\\')\\n            if l_ord > t_ord:\\n                return i\\n        return letters[0] # if no chrater is gte that target then return 0 index element\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n\\n        t_ord = ord(target) - ord(\\'a\\')\\n        for i in letters:\\n            l_ord = ord(i) - ord(\\'a\\')\\n            if l_ord > t_ord:\\n                return i\\n        return letters[0] # if no chrater is gte that target then return 0 index element\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1256995,
                "title": "c-binary-search-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tchar nextGreatestLetter(vector<char>& letters, char target) {\\n\\t\\t\\tint mid, l = 0, r = letters.size() - 1;\\n\\t\\t\\twhile(l < r){\\n\\t\\t\\t\\tmid = (l + r) / 2;\\n\\t\\t\\t\\tif(letters[mid] <= target){\\n\\t\\t\\t\\t\\tl = mid + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tr = mid;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(letters[l] > target){\\n\\t\\t\\t\\treturn letters[l];\\n\\t\\t\\t}\\n\\t\\t\\treturn letters[0];\\n\\t\\t}\\n\\t};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tchar nextGreatestLetter(vector<char>& letters, char target) {\\n\\t\\t\\tint mid, l = 0, r = letters.size() - 1;\\n\\t\\t\\twhile(l < r){\\n\\t\\t\\t\\tmid = (l + r) / 2;\\n\\t\\t\\t\\tif(letters[mid] <= target){\\n\\t\\t\\t\\t\\tl = mid + 1;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 257556,
                "title": "python-100",
                "content": "```\\nclass Solution(object):\\n    def nextGreatestLetter(self, letters, target):\\n        \"\"\"\\n        :type letters: List[str]\\n        :type target: str\\n        :rtype: str\\n        \"\"\"\\n        n = len(letters)\\n        if n == 0:\\n            return None\\n        \\n        low = 0\\n        high = n - 1\\n        # If it can not be found, must be the first element (wrap around)\\n        result = 0 \\n        \\n        while low <= high:\\n            mid = low + (high-low) // 2\\n            if letters[mid] > target:\\n                result = mid\\n                high = mid - 1\\n            else:\\n                low = mid + 1\\n\\n        return letters[result]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def nextGreatestLetter(self, letters, target):\\n        \"\"\"\\n        :type letters: List[str]\\n        :type target: str\\n        :rtype: str\\n        \"\"\"\\n        n = len(letters)\\n        if n == 0:\\n            return None\\n        \\n        low = 0\\n        high = n - 1\\n        # If it can not be found, must be the first element (wrap around)\\n        result = 0 \\n        \\n        while low <= high:\\n            mid = low + (high-low) // 2\\n            if letters[mid] > target:\\n                result = mid\\n                high = mid - 1\\n            else:\\n                low = mid + 1\\n\\n        return letters[result]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615593,
                "title": "c-easy-fast-solution-binary-search-linear-search",
                "content": "\\n\\n# Approach 1: Brute Force\\nUsing a range-based for loop, we can compare each letter to the target. Since we are given the Array in order from a-z. We can return the first letter that is greater than the target. If the loop finishes that means the target is greater than all letters in the array so we return letters[0] because it is the next letter to the right of target.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        for (char letter : letters) {\\n            if (letter > target) {\\n                return letter;\\n            }\\n        }\\n        return letters[0];\\n    }\\n};\\n```\\n\\n\\n# Approach 2: Binary Search\\n- Instead of linear search we will use binary search for this answer. \\n- if (letters[right] <= target)\\nThe first if statement is used to check right away if the target is greater than or equal to the highest letter in the array. If it is then we return letters[0].\\n- while (left <= right)\\nUsing binary search to find where the target letter would be in the array of letters.\\n- return letters[left];\\nWe use left not mid because left is always pointing at the letter that is larger than target. letter[mid] might be pointing at the letter that is equal to or less than target when while (left <= right) loop ends.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int left = 0;\\n        int right = letters.size()-1;\\n        int mid = 0;\\n        if (letters[right] <= target) {\\n            return letters[0];\\n        }\\n        while (left <= right) {\\n            mid = left + (right - left) / 2;\\n            if (letters[mid] > target) {\\n                right = mid-1;\\n            } else {\\n                left = mid+1;\\n            }\\n        }\\n        return letters[left];\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        for (char letter : letters) {\\n            if (letter > target) {\\n                return letter;\\n            }\\n        }\\n        return letters[0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int left = 0;\\n        int right = letters.size()-1;\\n        int mid = 0;\\n        if (letters[right] <= target) {\\n            return letters[0];\\n        }\\n        while (left <= right) {\\n            mid = left + (right - left) / 2;\\n            if (letters[mid] > target) {\\n                right = mid-1;\\n            } else {\\n                left = mid+1;\\n            }\\n        }\\n        return letters[left];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 110029,
                "title": "java-2-lines-o-log-n",
                "content": "    public char nextGreatestLetter(char[] letters, char target) {\\n        int i = Arrays.binarySearch(letters, (char) (target + 1));\\n        return letters[i >= 0 ? i : ~i % letters.length];\\n    }\\n\\nSadly if an element appears several times, Java's `Arrays.binarySearch` might find any of them. There's no way to ask for the first or last occurrence like you can in some other languages. So I can't ask \"Where's the last occurrence of the target?\" and then just look at the letter after it.\\n\\nBut if I don't ask for the target letter but instead for the *next larger* letter, that doesn't matter. If it exists in the array, I don't care which one I'm shown. I just return the one I'm shown. And if it doesn't exist, then I'm shown the location where it would be inserted, which is where the next even larger letter is or where the string ends.\\n\\nFor example when the target is `e`, I ask \"Where is an `f`?\". If there is one, then I get an index `i >= 0` where I can simply grab it. And if there isn't one, then `~i` gives me the index where it would be inserted, i.e., where the next even larger letter (in my example that's `g`, `h`, `i`, or whatever the next existing letter is) is or where the string ends. For the latter case I wrap around by using `% letters.length`.",
                "solutionTags": [],
                "code": "    public char nextGreatestLetter(char[] letters, char target) {\\n        int i = Arrays.binarySearch(letters, (char) (target + 1));\\n        return letters[i >= 0 ? i : ~i % letters.length];\\n    }\\n\\nSadly if an element appears several times, Java's `Arrays.binarySearch` might find any of them. There's no way to ask for the first or last occurrence like you can in some other languages. So I can't ask \"Where's the last occurrence of the target?\" and then just look at the letter after it.\\n\\nBut if I don't ask for the target letter but instead for the *next larger* letter, that doesn't matter. If it exists in the array, I don't care which one I'm shown. I just return the one I'm shown. And if it doesn't exist, then I'm shown the location where it would be inserted, which is where the next even larger letter is or where the string ends.\\n\\nFor example when the target is `e`, I ask \"Where is an `f`?\". If there is one, then I get an index `i >= 0` where I can simply grab it. And if there isn't one, then `~i` gives me the index where it would be inserted, i.e., where the next even larger letter (in my example that's `g`, `h`, `i`, or whatever the next existing letter is) is or where the string ends. For the latter case I wrap around by using `% letters.length`.",
                "codeTag": "Unknown"
            },
            {
                "id": 3615706,
                "title": "beats-100-binary-search-video-java-c-python",
                "content": "# Intuition\\nWhenever the array is sorted and we have to find an element, the answer is Binary Search. But the more beautiful thing is, you can just observe how our Brains solved this problem: Pick up an element and eliminate the other part of search Space. Exactly what Binary Search Does.\\n\\nPick the middle element of the search space and eliminate the other half.\\n\\n# Approach\\n1.Set left to 0 and right to the last index of the letters array.\\n2. Repeat the following steps while left is less than or equal to right:\\n\\ta.Calculate the middle index mid as the average of left and right.\\n\\tb.If the value at letters[mid] is less than or equal to the target, update left to mid + 1.\\n\\tc.Otherwise, update right to mid - 1.\\n3. If left is equal to the length of letters, return letters[0] as the target is greater than all elements.\\n4. Otherwise, return letters[left] as the target is either present or should be inserted at index left.\\n\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/J0Ao0uJ_ytU\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n\\n```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        int l = 0;\\n        int r = letters.length - 1;\\n        int mid;\\n        while (l <= r) {\\n            mid = (l + r) / 2;\\n            if (letters[mid] <= target) {\\n                l = mid + 1;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n\\n        return l == letters.length ? letters[0] : letters[l];\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int left = 0;\\n        int right = letters.size() - 1;\\n        int mid;\\n        while (left <= right) {\\n            mid = (left + right) / 2;\\n            if (letters[mid] <= target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return left == letters.size() ? letters[0] : letters[left];\\n    }\\n};\\n\\n```\\n\\n```\\nclass Solution:\\n    def nextGreatestLetter(self, letters, target):\\n        left = 0\\n        right = len(letters) - 1\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if letters[mid] <= target:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n\\n        return letters[0] if left == len(letters) else letters[left]\\n\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        int l = 0;\\n        int r = letters.length - 1;\\n        int mid;\\n        while (l <= r) {\\n            mid = (l + r) / 2;\\n            if (letters[mid] <= target) {\\n                l = mid + 1;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n\\n        return l == letters.length ? letters[0] : letters[l];\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int left = 0;\\n        int right = letters.size() - 1;\\n        int mid;\\n        while (left <= right) {\\n            mid = (left + right) / 2;\\n            if (letters[mid] <= target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return left == letters.size() ? letters[0] : letters[left];\\n    }\\n};\\n\\n```\n```\\nclass Solution:\\n    def nextGreatestLetter(self, letters, target):\\n        left = 0\\n        right = len(letters) - 1\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if letters[mid] <= target:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n\\n        return letters[0] if left == len(letters) else letters[left]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312998,
                "title": "binary-search-approach-python3",
                "content": "\\n# Binary Search Approach\\n```\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        if target>=letters[-1]:\\n            return letters[0]\\n        left,right=0,len(letters)-1\\n        while left<=right:\\n            mid=(right+left)//2\\n            if letters[mid]<=target:\\n                left=mid+1\\n            else:\\n                right=mid-1\\n        return letters[left] \\n    //please upvote me it would encourage me alot\\n    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        if target>=letters[-1]:\\n            return letters[0]\\n        left,right=0,len(letters)-1\\n        while left<=right:\\n            mid=(right+left)//2\\n            if letters[mid]<=target:\\n                left=mid+1\\n            else:\\n                right=mid-1\\n        return letters[left] \\n    //please upvote me it would encourage me alot\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949525,
                "title": "4-lines-simple-java-solution-100-faster-o-n-time-complexity-o-1-space",
                "content": "# Intuition\\nSince the given input is in inc order, just traversed through the letter array and checked which elemenmt is smaller than target and returned it.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        for(int i =0; i<letters.length; i++)\\n            if(letters[i]>target)\\n                return letters[i];\\n        return letters[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        for(int i =0; i<letters.length; i++)\\n            if(letters[i]>target)\\n                return letters[i];\\n        return letters[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888874,
                "title": "c-using-binary-search-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int low=0,high=letters.size()-1;\\n        while(low<=high){\\n            int mid=(low+high+1)/2;\\n            if(mid<letters.size()-1 && letters[mid]<= target && letters[mid+1]>target)   \\n                return letters[mid+1];\\n            else if(letters[mid]<= target)   low=mid+1;\\n            else high=mid-1;\\n        }\\n        return letters[0];\\n    }\\n};\\n```\\n\\nIf you liked the solution, then please upvote \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int low=0,high=letters.size()-1;\\n        while(low<=high){\\n            int mid=(low+high+1)/2;\\n            if(mid<letters.size()-1 && letters[mid]<= target && letters[mid+1]>target)   \\n                return letters[mid+1];\\n            else if(letters[mid]<= target)   low=mid+1;\\n            else high=mid-1;\\n        }\\n        return letters[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824564,
                "title": "javascript-binary-search",
                "content": "```\\n/**\\n * @param {character[]} letters\\n * @param {character} target\\n * @return {character}\\n */\\nvar nextGreatestLetter = function(letters, target) {\\n    if (letters.length === 1) {\\n        return letters[0];\\n    }\\n\\n    let left = 0;\\n    let right = letters.length;\\n    \\n    while (left <= right) {\\n        const mid = left + Math.floor((right - left) / 2);\\n        if (letters[mid] <= target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    if (left === letters.length) {\\n        return letters[0];\\n    } else {\\n        return letters[left];\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {character[]} letters\\n * @param {character} target\\n * @return {character}\\n */\\nvar nextGreatestLetter = function(letters, target) {\\n    if (letters.length === 1) {\\n        return letters[0];\\n    }\\n\\n    let left = 0;\\n    let right = letters.length;\\n    \\n    while (left <= right) {\\n        const mid = left + Math.floor((right - left) / 2);\\n        if (letters[mid] <= target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    if (left === letters.length) {\\n        return letters[0];\\n    } else {\\n        return letters[left];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 879546,
                "title": "java-runtime-0-ms",
                "content": "```\\n/*\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Find Smallest Letter Greater Than Target.\\nMemory Usage: 39 MB, less than 99.73% of Java online submissions for Find Smallest Letter Greater Than Target.\\n*/\\n\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        for(char ch : letters){\\n            if (ch > target) return ch;\\n        }\\n        return letters[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Find Smallest Letter Greater Than Target.\\nMemory Usage: 39 MB, less than 99.73% of Java online submissions for Find Smallest Letter Greater Than Target.\\n*/\\n\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        for(char ch : letters){\\n            if (ch > target) return ch;\\n        }\\n        return letters[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615576,
                "title": "98-35-javascript-very-easy-and-very-fast",
                "content": "If it helps, Thank you for subscribing me.\\n\\nhttps://www.youtube.com/channel/UCkhEaNAOO8tig5NHqqxXIeg\\n\\n# Code\\n```\\n/**\\n * @param {character[]} letters\\n * @param {character} target\\n * @return {character}\\n */\\nvar nextGreatestLetter = function(letters, target) {\\n    let set = new Set(letters)\\n    for(let c of set){\\n        if(c>target) return c\\n    }\\n    return letters[0]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {character[]} letters\\n * @param {character} target\\n * @return {character}\\n */\\nvar nextGreatestLetter = function(letters, target) {\\n    let set = new Set(letters)\\n    for(let c of set){\\n        if(c>target) return c\\n    }\\n    return letters[0]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1020043,
                "title": "2-ways-to-solve",
                "content": "1. Simple way -> Time Complexity: O(n)\\n```\\nvar nextGreatestLetter = function (letters, target) {\\n  return letters.find((letter) => letter > target);\\n};\\n```\\n2. Binary Search -> Time Complexity: O(logN)\\n```\\nvar nextGreatestLetter = function (letters, target) {\\n  if (letters[0] > target || target >= letters[letters.length - 1])\\n    return letters[0];\\n\\n  let left = 0,\\n    right = letters.length - 1;\\n\\n  while (left < right) {\\n    const mid = left + Math.floor((right - left) / 2);\\n    if (letters[mid] <= target) left = mid + 1;\\n    else if (letters[mid] > target) right = mid;\\n  }\\n\\n  return letters[left];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nvar nextGreatestLetter = function (letters, target) {\\n  return letters.find((letter) => letter > target);\\n};\\n```\n```\\nvar nextGreatestLetter = function (letters, target) {\\n  if (letters[0] > target || target >= letters[letters.length - 1])\\n    return letters[0];\\n\\n  let left = 0,\\n    right = letters.length - 1;\\n\\n  while (left < right) {\\n    const mid = left + Math.floor((right - left) / 2);\\n    if (letters[mid] <= target) left = mid + 1;\\n    else if (letters[mid] > target) right = mid;\\n  }\\n\\n  return letters[left];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3616038,
                "title": "beginner-friendly-explantion-of-optimal-binary-search-python",
                "content": "# Intuition\\nIt might seem like a direct solution would be to scan through each element in the array. However this solution would have O(n) time complexity.\\n\\nGiven the sorted nature of the array, we can do better! We will make use of binary search to efficiently find the character we need.\\n\\n# Approach\\nBinary search is a fast search algorithm that works by repeatedly dividing in half the portion of the array that could contain the target. The binary search has two pointers, `l` (left) and `r` (right), to point to the start and end of the segment of `letters` we are searching.\\n\\nThe binary search process is performed in a loop, in which the middle index, `mid`, is calculated as the middle of `l` and `r`. If the character at the `mid` index in letters array is greater than the target, we update `r` to be `mid` to narrow down the search space to the left half of the current search space. Otherwise, we update `l` to be `mid + 1`, narrowing down the search space to the right half.\\n\\n# Complexity\\n- Time complexity: O(log(n)) - each time we divide the search space in half. An array of length `n` can be divided in half at most log(n) times.\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        l, r = 0, len(letters)\\n        while l < r:\\n            mid = (l + r) // 2\\n            if letters[mid] > target:\\n                r = mid\\n            else:\\n                l = mid + 1\\n        return letters[r] if r < len(letters) else letters[0]\\n```\\n\\n# Get Faster Interview Prep Results with Top Algos\\nWe all know how time-consuming it is to prepare for interviews and how frustratingly difficult it is to improve. We made **Top Algos** - a tool recommends the perfect algorithm problem based on your current skill level to help you improve the fastest in the shortest amount of time. Top Algos is your personalized coach that learns your skill level and finds the best problem you need to solve to improve.\\n\\nThe beta version of the product is available for **free** right now! You can sign up at https://topalgos.xyz/.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        l, r = 0, len(letters)\\n        while l < r:\\n            mid = (l + r) // 2\\n            if letters[mid] > target:\\n                r = mid\\n            else:\\n                l = mid + 1\\n        return letters[r] if r < len(letters) else letters[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615590,
                "title": "c-java-python-solution-beats-100-easy-to-understand",
                "content": "- Linkedin Profile (https://linkedin.com/in/ayush-kumar-a276a124a)\\n//-------------> \\uD83D\\uDC7B Pls Upvote if it is helpful for You \\uD83D\\uDC7B <-----------------//\\n# Complexity\\n- Time complexity: -------> Log(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: ---------->O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n\\n         // Base Case\\n        if(letters[0]>target || letters[letters.size()-1]<=target){\\n            return letters[0];\\n        }\\n\\n        int l=0,h=letters.size();\\n        while(l<h){\\n            int mid=l+(h-l)/2;\\n            if(letters[mid]>target){\\n                h=mid;\\n            }else{\\n                l=mid+1;\\n            }\\n        }\\n        return letters[l%letters.size()];    }\\n};\\n```\\n# Java Code\\n```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n\\n        // Base Case\\n         if (letters[0] > target || letters[letters.length - 1] <= target) {\\n            return letters[0];\\n         }\\n\\n        int l = 0;\\n        int h = letters.length;\\n        while (l < h) {\\n            int mid = l + (h - l) / 2;\\n            if (letters[mid] > target) {\\n                h = mid;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        return letters[l % letters.length];\\n    }\\n}\\n```\\n# Python code\\n```\\nclass Solution:\\n    def nextGreatestLetter(self, letters, target):\\n          \\n        # Base Case\\n        if letters[0] > target or letters[-1] <= target:\\n            return letters[0]\\n\\n        l = 0\\n        h = len(letters)\\n        while l < h:\\n            mid = l + (h - l) // 2\\n            if letters[mid] > target:\\n                h = mid\\n            else:\\n                l = mid + 1\\n        return letters[l % len(letters)]\\n\\n\\n```\\n\\uD83D\\uDC7B IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION\\uD83D\\uDC7B*\\n\\n![image.png](https://assets.leetcode.com/users/images/727956ed-b8e9-4003-83cd-c071626c76b9_1686269762.0533545.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n\\n         // Base Case\\n        if(letters[0]>target || letters[letters.size()-1]<=target){\\n            return letters[0];\\n        }\\n\\n        int l=0,h=letters.size();\\n        while(l<h){\\n            int mid=l+(h-l)/2;\\n            if(letters[mid]>target){\\n                h=mid;\\n            }else{\\n                l=mid+1;\\n            }\\n        }\\n        return letters[l%letters.size()];    }\\n};\\n```\n```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n\\n        // Base Case\\n         if (letters[0] > target || letters[letters.length - 1] <= target) {\\n            return letters[0];\\n         }\\n\\n        int l = 0;\\n        int h = letters.length;\\n        while (l < h) {\\n            int mid = l + (h - l) / 2;\\n            if (letters[mid] > target) {\\n                h = mid;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        return letters[l % letters.length];\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def nextGreatestLetter(self, letters, target):\\n          \\n        # Base Case\\n        if letters[0] > target or letters[-1] <= target:\\n            return letters[0]\\n\\n        l = 0\\n        h = len(letters)\\n        while l < h:\\n            mid = l + (h - l) // 2\\n            if letters[mid] > target:\\n                h = mid\\n            else:\\n                l = mid + 1\\n        return letters[l % len(letters)]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833419,
                "title": "python-two-one-liners-using-binary-search-and-modulo-trick",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\n**Python #1.** Using *bisect_right*.\\n```\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], t: str) -> str:\\n        \\n        return letters[bisect.bisect_right(letters, t) % len(letters)]\\n```\\n**Python #2.** Using *bisect_left*, however, searching for the next letter.\\n```\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], t: str) -> str:\\n        \\n        return letters[bisect_left(letters, chr(ord(t)+1)) % len(letters)]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], t: str) -> str:\\n        \\n        return letters[bisect.bisect_right(letters, t) % len(letters)]\\n```\n```\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], t: str) -> str:\\n        \\n        return letters[bisect_left(letters, chr(ord(t)+1)) % len(letters)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2176655,
                "title": "python3-solution-o-log-n",
                "content": "```\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        low, high = 0, len(letters) - 1\\n        while low < high:\\n            mid = (low+high) // 2\\n            if letters[mid] <= target:\\n                low = mid + 1\\n            else:\\n                high = mid\\n        return letters[low] if letters[low] > target else letters[0]\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        low, high = 0, len(letters) - 1\\n        while low < high:\\n            mid = (low+high) // 2\\n            if letters[mid] <= target:\\n                low = mid + 1\\n            else:\\n                high = mid\\n        return letters[low] if letters[low] > target else letters[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1363095,
                "title": "c-binary-search-easy",
                "content": "We can easily find next element using binary search.\\n\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& l, char t) {\\n        int left=0, right = l.size()-1;\\n        char ans = \\' \\';\\n        \\n        while(left <= right){\\n            int mid = left + (right-left)/2;\\n            if(l[mid] > t){\\n                ans = l[mid];\\n                right = mid-1;\\n            }\\n            else{\\n                left = mid+1;\\n            }\\n        }\\n        if(ans==\\' \\')\\n            return l[0];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& l, char t) {\\n        int left=0, right = l.size()-1;\\n        char ans = \\' \\';\\n        \\n        while(left <= right){\\n            int mid = left + (right-left)/2;\\n            if(l[mid] > t){\\n                ans = l[mid];\\n                right = mid-1;\\n            }\\n            else{\\n                left = mid+1;\\n            }\\n        }\\n        if(ans==\\' \\')\\n            return l[0];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616973,
                "title": "easy-clear-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        for letter in letters:\\n            if letter > target:\\n                return letter\\n        return letters[0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        for letter in letters:\\n            if letter > target:\\n                return letter\\n        return letters[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615560,
                "title": "java-brute-force-3-lines-clean-code",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public char nextGreatestLetter(char[] letters, char target) {\\n    for (var letter : letters)\\n      if (letter > target) return letter;\\n    \\n    return letters[0];\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public char nextGreatestLetter(char[] letters, char target) {\\n    for (var letter : letters)\\n      if (letter > target) return letter;\\n    \\n    return letters[0];\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996691,
                "title": "binary-search-c-o-log-n",
                "content": "\\n# Complexity\\n- Time complexity : O ( log N )\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O ( 1 )\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int start=0, n = letters.size(), end = n-1;\\n        while(start<=end)\\n        {\\n           int mid=start+(end-start)/2;\\n            if(target<letters[mid])\\n            {end=mid-1;\\n            }\\n            else\\n            {\\n                start=mid+1;  \\n            }\\n        }\\n        return letters[start%n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int start=0, n = letters.size(), end = n-1;\\n        while(start<=end)\\n        {\\n           int mid=start+(end-start)/2;\\n            if(target<letters[mid])\\n            {end=mid-1;\\n            }\\n            else\\n            {\\n                start=mid+1;  \\n            }\\n        }\\n        return letters[start%n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 445003,
                "title": "c-one-liner",
                "content": "```cpp\\nchar nextGreatestLetter(vector<char>& A, char target) {\\n\\treturn target < A.back() ? *upper_bound(begin(A), end(A), target) : A.front();\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "```cpp\\nchar nextGreatestLetter(vector<char>& A, char target) {\\n\\treturn target < A.back() ? *upper_bound(begin(A), end(A), target) : A.front();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3619536,
                "title": "simple-java-solution-easy-explanation",
                "content": "# Approach\\nLet\\'s go through the code step by step and explain it easily:\\n\\nStep 1: Function Definition\\n```java\\npublic char nextGreatestLetter(char[] letters, char target)\\n```\\nThe code defines a method named `nextGreatestLetter` that takes two parameters: an array of characters named `letters` and a character named `target`. It is expected to find the next greatest letter in the `letters` array compared to the `target` character.\\n\\nStep 2: Sorting the Letters\\n```java\\nArrays.sort(letters);\\n```\\nThe `Arrays.sort()` function is used to sort the `letters` array in ascending order. This will ensure that the letters are arranged in a sequential manner.\\n\\nStep 3: Initializing the Output\\n```java\\nchar output = letters[0];\\n```\\nA variable named `output` is declared and initialized with the first element of the sorted `letters` array. This is done as a default value in case there is no letter greater than the `target` character in the array.\\n\\nStep 4: Looping through the Letters\\n```java\\nfor (char x : letters) {\\n    if (x > target) {\\n        output = x;\\n        break;\\n    } else {\\n        continue;\\n    }\\n}\\n```\\nThe code iterates over each character `x` in the `letters` array. It checks if the current character `x` is greater than the `target` character.\\n\\n- If `x` is greater than `target`, it means we have found the next greatest letter. The `output` variable is updated with the value of `x`, and the loop is terminated using the `break` statement.\\n- If `x` is not greater than `target`, the loop continues to the next iteration using the `continue` statement.\\n\\nStep 5: Returning the Output\\n```java\\nreturn output;\\n```\\nAfter the loop finishes, the function returns the `output` character, which represents the next greatest letter in the `letters` array compared to the `target` character.\\n\\nIn summary, the code sorts the `letters` array, then iterates through the sorted array to find the next greatest letter after the `target` character. It returns that letter as the output.\\n\\n# Final Code\\n```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        Arrays.sort(letters);\\n        char output = letters[0];\\n        for (char x:letters){\\n            if (x>target){\\n                output = x;\\n                break;\\n            }\\n            else {\\n               continue;\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```\\nPlease upvote if you like the solution.\\nHappy Coding! \\uD83D\\uDE0A",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```java\\npublic char nextGreatestLetter(char[] letters, char target)\\n```\n```java\\nArrays.sort(letters);\\n```\n```java\\nchar output = letters[0];\\n```\n```java\\nfor (char x : letters) {\\n    if (x > target) {\\n        output = x;\\n        break;\\n    } else {\\n        continue;\\n    }\\n}\\n```\n```java\\nreturn output;\\n```\n```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        Arrays.sort(letters);\\n        char output = letters[0];\\n        for (char x:letters){\\n            if (x>target){\\n                output = x;\\n                break;\\n            }\\n            else {\\n               continue;\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616585,
                "title": "c-one-liner",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n      return letters[(upper_bound(letters.begin(), letters.end(), target)- letters.begin())%letters.size()];\\n    }\\n};\\n```\\n\\n# *and Upvote?*",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n      return letters[(upper_bound(letters.begin(), letters.end(), target)- letters.begin())%letters.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616457,
                "title": "c-easy-o-n",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        for(auto i:letters){\\n            if(i>target)return i;\\n        }\\n        return letters[0];\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/c2c3da55-b6de-42d6-a497-184ac7b3fa60_1686287842.245189.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        for(auto i:letters){\\n            if(i>target)return i;\\n        }\\n        return letters[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616452,
                "title": "c-easy-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int i=0,j=letters.size()-1;\\n        int ans=0;\\n        while(i<=j){\\n            int m=(i+j)/2;\\n            if(letters[m]>target){\\n                ans=m;\\n                j=m-1;\\n            }\\n            else i=m+1;\\n        }\\n        return letters[ans];\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/f82054c8-dde4-4dd2-ab5a-92424866f4bb_1686287802.5642939.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int i=0,j=letters.size()-1;\\n        int ans=0;\\n        while(i<=j){\\n            int m=(i+j)/2;\\n            if(letters[m]>target){\\n                ans=m;\\n                j=m-1;\\n            }\\n            else i=m+1;\\n        }\\n        return letters[ans];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590076,
                "title": "easy-c-code-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int l=0,h=letters.size()-1,m;\\n        int ans=0;\\n\\n        while(l<=h){\\n            m=l+(h-l)/2;\\n            if(letters[m]>target){\\n                ans=m;\\n                h=m-1;\\n\\n            }else{\\n                l=m+1;\\n            }\\n            \\n        }\\n        return letters[ans];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int l=0,h=letters.size()-1,m;\\n        int ans=0;\\n\\n        while(l<=h){\\n            m=l+(h-l)/2;\\n            if(letters[m]>target){\\n                ans=m;\\n                h=m-1;\\n\\n            }else{\\n                l=m+1;\\n            }\\n            \\n        }\\n        return letters[ans];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453335,
                "title": "simple-and-explained-binary-search-approach-beats-97",
                "content": "# Intuition\\nSince we know that  we have to find the character which is lexicographically greater than the target we will not check the condition for the character to be equal. If the target is less than the middle element then we will take our search space to left else we will take it to the right. This gurantees us that we will find the element just greater than the target.\\n\\n# Approach\\nTake a variable ans of type char and store the first element of array letter in it then apply binary search and if (letters[mid]>target) then store the answer as letters[mid] and make the search space towards left else take it to the right.\\n\\n# Complexity\\n- Time complexity:\\nO(log n) , where n=letters.size\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int s=0,e=letters.size()-1;\\n        char ans=letters[0];\\n        int mid=s+(e-s)/2;\\n        while(s<=e){\\n            if(letters[mid]>target)\\n            {\\n                ans=letters[mid];\\n                e=mid-1;\\n            }\\n            else\\n            {\\n                s=mid+1;\\n            }\\n            mid=s+(e-s)/2;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int s=0,e=letters.size()-1;\\n        char ans=letters[0];\\n        int mid=s+(e-s)/2;\\n        while(s<=e){\\n            if(letters[mid]>target)\\n            {\\n                ans=letters[mid];\\n                e=mid-1;\\n            }\\n            else\\n            {\\n                s=mid+1;\\n            }\\n            mid=s+(e-s)/2;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2931177,
                "title": "o-log-n-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        int s = 0;\\n        int e = letters.length-1;\\n        while(s<=e){\\n            int mid = s + (e-s)/2;\\n            if(letters[mid]>target){\\n                e = mid-1;\\n            }else{\\n                s = mid+1;\\n            }\\n        }\\n        return letters[s % letters.length];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        int s = 0;\\n        int e = letters.length-1;\\n        while(s<=e){\\n            int mid = s + (e-s)/2;\\n            if(letters[mid]>target){\\n                e = mid-1;\\n            }else{\\n                s = mid+1;\\n            }\\n        }\\n        return letters[s % letters.length];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695769,
                "title": "java-binary-search-100-faster-easy-solution",
                "content": "```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n\\n\\tint s=0,e=letters.length-1;\\n\\tchar val=letters[0];\\n\\n\\twhile(s<=e)\\n\\t{\\n\\t\\tint m=s+(e-s)/2;\\n\\t\\tif(letters[m]>target)\\n\\t\\t{\\n\\t\\t\\tval=letters[m];\\n\\t\\t\\te=m-1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\ts=m+1;\\n\\t}\\n\\treturn(val);\\n}\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n\\n\\tint s=0,e=letters.length-1;\\n\\tchar val=letters[0];\\n\\n\\twhile(s<=e)\\n\\t{\\n\\t\\tint m=s+(e-s)/2;\\n\\t\\tif(letters[m]>target)\\n\\t\\t{\\n\\t\\t\\tval=letters[m];\\n\\t\\t\\te=m-1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\ts=m+1;\\n\\t}\\n\\treturn(val);\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846914,
                "title": "94-faster-python-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        start = 0\\n        end = len(letters)-1\\n        \\n        while start <= end:\\n            mid = start + (end-start)//2\\n            \\n            if letters[mid] > target:\\n                end = mid - 1\\n            else :\\n                start = mid + 1\\n                \\n        return letters[start%len(letters)]\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        start = 0\\n        end = len(letters)-1\\n        \\n        while start <= end:\\n            mid = start + (end-start)//2\\n            \\n            if letters[mid] > target:\\n                end = mid - 1\\n            else :\\n                start = mid + 1\\n                \\n        return letters[start%len(letters)]\\n",
                "codeTag": "Java"
            },
            {
                "id": 1252199,
                "title": "c-binary-search-upper-bound-very-easy",
                "content": "**Solution 1 - Using Upper Bound**\\n\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        auto itr = upper_bound(letters.begin(), letters.end(), target);\\n        return (itr == letters.end()) ? letters[0] : *itr;\\n    }\\n};\\n```\\n\\n<hr>\\n\\n**Solution 2 - Using Binary Search**\\n\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int start = 0;\\n        int end = letters.size() - 1;\\n        char smChar = letters[0];\\n        \\n        while (start <= end) {\\n            int mid = (start + end) / 2;\\n            if (letters[mid] > target) {\\n                end = mid - 1;\\n                smChar = letters[mid];\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        \\n        return smChar;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        auto itr = upper_bound(letters.begin(), letters.end(), target);\\n        return (itr == letters.end()) ? letters[0] : *itr;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int start = 0;\\n        int end = letters.size() - 1;\\n        char smChar = letters[0];\\n        \\n        while (start <= end) {\\n            int mid = (start + end) / 2;\\n            if (letters[mid] > target) {\\n                end = mid - 1;\\n                smChar = letters[mid];\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        \\n        return smChar;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 143355,
                "title": "java-binary-search",
                "content": "Very straightforward binary search implementation. The only tricky thing is to deal with wrap case:\\nIf the result of binary search is still not greater than the target, the letters[0] will become the right answer.\\n\\n```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        int l = 0, r = letters.length - 1;\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (letters[mid] <= target) {\\n                l = mid + 1;\\n            } else {\\n                r = mid;\\n            }\\n        }\\n        return target >= letters[l] ? letters[0] : letters[l];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        int l = 0, r = letters.length - 1;\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (letters[mid] <= target) {\\n                l = mid + 1;\\n            } else {\\n                r = mid;\\n            }\\n        }\\n        return target >= letters[l] ? letters[0] : letters[l];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617267,
                "title": "simple-solution-with-both-brute-force-and-optimal-approaches-in-three-languages",
                "content": "# Brute Force\\n## Intuition\\nBrute force approach is just go through the array and compare each characters with the target-character, if character is lexicographically greater than target-character then just return it fron that point no need to go through the end of the array cause it\\'s told us that the array is sorted in non-decreasing order.And if not found such character then just return the first letter of the array.\\n\\n## Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is same as I discussed in intution section \\n\\n## Complexity\\n- Time complexity: let n be the size of the array the T.C in worst case  $$O(n)$$\\n \\n- Space complexity: $$O(1)$$\\n\\n\\n## code\\n\\n```c++ []\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        for(auto var:letters){\\n            if(var>target){\\n                return var;\\n            }\\n        }\\n        return letters[0];\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        for(char var:letters){\\n            if(var>target){\\n                return var;\\n            }\\n        }\\n        return letters[0];\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        for i in letters:\\n            if i > target:\\n                return i\\n        return letters[0]            \\n```\\n\\n\\n\\n\\n# Optimal approach\\n## Intuition\\nIn the question they told us that the array is sorted in non-decreasing order ,so we can apply binarysearch here.\\n## Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is same as regular binarysearch just run a while loop untill start exceed the end index and in that loop find the mid_index by [(Start+(end-start))/2] and compare the mid_index character with the target_character and so on and finally return the character,if not found such type of character then just return the first character of the letters array.\\n\\n## Complexity\\n- Time complexity:  let n be the size of the array them T.C  $$O(logn)$$\\n \\n- Space complexity: $$O(1)$$\\n\\n\\n# Code\\n```c++ []\\nclass Solution {\\npublic:\\n    char binarySearch(vector<char>& letters,char target,int s,int e){\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(letters[mid]<=target){\\n                s=mid+1;\\n            }\\n            else{\\n                e=mid-1;\\n            }\\n        }\\n        return s<letters.size()?letters[s]:letters[0];\\n    }\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        char c=binarySearch(letters,target,0,letters.size()-1);\\n        return c;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public char binarySearch(char[] letters,char target,int s,int e){\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(letters[mid]<=target){\\n                s=mid+1;\\n            }\\n            else{\\n                e=mid-1;\\n            }\\n        }\\n        return s<letters.length?letters[s]:letters[0];\\n    }\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        char c=binarySearch(letters,target,0,letters.length-1);\\n        return c;\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        s,e=0,len(letters)-1\\n        while s<=e:\\n            mid=s+(e-s)//2\\n            if letters[mid]<=target: s=mid+1\\n            else: e=mid-1;\\n        return letters[s] if s<len(letters) else letters[0]           \\n```\\n\\n\\n\\n\\n![cat.jpg](https://assets.leetcode.com/users/images/f98ef2b8-08f0-4ed9-9ea8-41146fcfa80e_1686227684.925494.jpeg)\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```c++ []\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        for(auto var:letters){\\n            if(var>target){\\n                return var;\\n            }\\n        }\\n        return letters[0];\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        for(char var:letters){\\n            if(var>target){\\n                return var;\\n            }\\n        }\\n        return letters[0];\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        for i in letters:\\n            if i > target:\\n                return i\\n        return letters[0]            \\n```\n```c++ []\\nclass Solution {\\npublic:\\n    char binarySearch(vector<char>& letters,char target,int s,int e){\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(letters[mid]<=target){\\n                s=mid+1;\\n            }\\n            else{\\n                e=mid-1;\\n            }\\n        }\\n        return s<letters.size()?letters[s]:letters[0];\\n    }\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        char c=binarySearch(letters,target,0,letters.size()-1);\\n        return c;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public char binarySearch(char[] letters,char target,int s,int e){\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(letters[mid]<=target){\\n                s=mid+1;\\n            }\\n            else{\\n                e=mid-1;\\n            }\\n        }\\n        return s<letters.length?letters[s]:letters[0];\\n    }\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        char c=binarySearch(letters,target,0,letters.length-1);\\n        return c;\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        s,e=0,len(letters)-1\\n        while s<=e:\\n            mid=s+(e-s)//2\\n            if letters[mid]<=target: s=mid+1\\n            else: e=mid-1;\\n        return letters[s] if s<len(letters) else letters[0]           \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616108,
                "title": "c-binary-search-solution-clean-code-o-log-n",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBy looking at the question we can see it asks for a typical binary search approach as it has given a sorted array with a search query, the one that is similar to upper_bound\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int i = 0, j = letters.size()-1; \\n        char ans = letters[0]; //if no greater find the default ans would be first letter, as asked in question\\n        while(i<=j){\\n            int mid = (i+j)/2;\\n            if(letters[mid]>target){ //if the mid char greater than target then it can be an answer but we also search behind it if any smaller ans can be found\\n                ans = letters[mid];\\n                j = mid-1;\\n            }\\n            else{ //if mid char is less or equal to target then its not the ans and ans lies in range greater than mid\\n                i = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int i = 0, j = letters.size()-1; \\n        char ans = letters[0]; //if no greater find the default ans would be first letter, as asked in question\\n        while(i<=j){\\n            int mid = (i+j)/2;\\n            if(letters[mid]>target){ //if the mid char greater than target then it can be an answer but we also search behind it if any smaller ans can be found\\n                ans = letters[mid];\\n                j = mid-1;\\n            }\\n            else{ //if mid char is less or equal to target then its not the ans and ans lies in range greater than mid\\n                i = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615840,
                "title": "two-easy-solutions-binary-search-and-brute-force-fast",
                "content": "\\n# Code : Binary Search \\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n    int left =0;\\n    int  right = letters.size()-1;\\n\\n    int mid =0;\\n\\n    if(letters[right] <= target)\\n    {\\n        return letters[0];\\n    }\\n\\n    while(left <= right){\\n        mid = left + ( right-left)/2;\\n        if(letters[mid]> target){\\n            right=mid-1;\\n\\n        }\\n        else{\\n            left= mid+1;\\n\\n        }\\n    }\\n\\n    return letters[left];\\n\\n        \\n    }\\n};\\n```\\n\\n# Code : Brute Force\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        for (char letter : letters) {\\n            if (letter > target) {\\n                return letter;\\n            }\\n        }\\n        return letters[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n    int left =0;\\n    int  right = letters.size()-1;\\n\\n    int mid =0;\\n\\n    if(letters[right] <= target)\\n    {\\n        return letters[0];\\n    }\\n\\n    while(left <= right){\\n        mid = left + ( right-left)/2;\\n        if(letters[mid]> target){\\n            right=mid-1;\\n\\n        }\\n        else{\\n            left= mid+1;\\n\\n        }\\n    }\\n\\n    return letters[left];\\n\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        for (char letter : letters) {\\n            if (letter > target) {\\n                return letter;\\n            }\\n        }\\n        return letters[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615764,
                "title": "c-python-solutions-only-2-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nC++ upper_bound is the real least upper bound w.r.t \\'<\\'.\\nbisect_right has the same function in Python.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int i=upper_bound(letters.begin(), letters.end(), target)-letters.begin();\\n        return (i==letters.size())?letters[0]:letters[i];\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def nextGreatestLetter(self, L: List[str], target: str) -> str:\\n        i=bisect_right(L, target)\\n        return L[i] if i<len(L) else L[0]\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int i=upper_bound(letters.begin(), letters.end(), target)-letters.begin();\\n        return (i==letters.size())?letters[0]:letters[i];\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def nextGreatestLetter(self, L: List[str], target: str) -> str:\\n        i=bisect_right(L, target)\\n        return L[i] if i<len(L) else L[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615739,
                "title": "c-stl-upperbound-3-lines-of-code",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe upper_bound function returns an iterator pointing to the element in the array that is greater than target-\\'a\\'. If the target character is not equal to the element pointed by x, it means that there is a character in letters that is greater than target. In this case, the function returns the character *x.\\n\\nIf the target character is equal to the element pointed by x, it means that there is no character in letters that is greater than target. In this case, the function returns the first character in letters, which is letters[0].\\n\\nif you want to know nore about lower_bound and upper bound , keep following -\\n\\n# lower_bound:\\n\\n- Function Signature: iterator lower_bound (iterator first, iterator last, const T& val)\\n- Description: It returns an iterator pointing to the first element that is not less than (i.e., greater or equal to) the given value.\\n- Return Type: The return type of lower_bound is an iterator.\\n- Key Found: If the key is present in the sequence, lower_bound returns an iterator pointing to the first occurrence of the key.\\n- Key Not Found: If the key is not present in the sequence, lower_bound returns an iterator pointing to the first element that is greater than the key.\\n\\n# lower_bound\\n- Function Signature: iterator upper_bound (iterator first, iterator last, const T& val)\\n- Description: It returns an iterator pointing to the first element that is greater than the given value.\\n- Return Type: The return type of upper_bound is an iterator.\\n- Key Found: If the key is present in the sequence, upper_bound returns an iterator pointing to the first element that is greater than the key.\\n- Key Not Found: If the key is not present in the sequence, upper_bound returns an iterator pointing to the first element that is greater than the key.\\n\\n# Time complexity:\\n\\nThe time complexity of the corrected solution is O(log N), where N is the number of elements in the letters array.\\n\\nThe upper_bound function uses a binary search algorithm, which has a time complexity of O(log N) in the worst case. It efficiently finds the position of the smallest element in letters that is greater than target. Therefore, the time complexity of this part is O(log N).\\n\\n\\n- Space complexity:\\n\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   char nextGreatestLetter(vector<char>& letters, char target) {\\n    auto x = upper_bound(letters.begin(), letters.end(), target);\\n    if (x == letters.end()) return letters[0];\\n    return *x;\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   char nextGreatestLetter(vector<char>& letters, char target) {\\n    auto x = upper_bound(letters.begin(), letters.end(), target);\\n    if (x == letters.end()) return letters[0];\\n    return *x;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615555,
                "title": "daily-leetcoding-challenge-june-day-9",
                "content": "This problem is the Daily LeetCoding Challenge for June, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-smallest-letter-greater-than-target/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-smallest-letter-greater-than-target/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3464077,
                "title": "swift-easy-to-understand-and-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    func nextGreatestLetter(_ letters: [Character], _ target: Character) -> Character {\\n        letters.first{$0 > target} ?? letters.first!\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func nextGreatestLetter(_ letters: [Character], _ target: Character) -> Character {\\n        letters.first{$0 > target} ?? letters.first!\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455266,
                "title": "easy-solving",
                "content": "# Code\\n```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        int left = 0;\\n        int right = letters.length - 1;\\n\\n        while (left <= right) {\\n            int middle = left + (right - left) / 2;\\n            if (target >= letters[middle]) {\\n                left = middle + 1;\\n            } else {\\n                right = middle - 1;\\n            }\\n        }\\n\\n        return letters[left % letters.length];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        int left = 0;\\n        int right = letters.length - 1;\\n\\n        while (left <= right) {\\n            int middle = left + (right - left) / 2;\\n            if (target >= letters[middle]) {\\n                left = middle + 1;\\n            } else {\\n                right = middle - 1;\\n            }\\n        }\\n\\n        return letters[left % letters.length];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944047,
                "title": "python3-code",
                "content": "# Code\\n```\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        alphabet = \"abcdefghijklmnopqrstuvwxyz\"\\n        for letter in alphabet[alphabet.index(target) + 1:]:\\n            if letter in letters: return letter\\n        return letters[0]\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/694c8f14-1654-41e6-af95-2a200ff6fed0_1671848139.879172.png)\\n![image.png](https://assets.leetcode.com/users/images/d0f8291d-d963-442d-a799-a54dd7f00dae_1671848264.693118.png)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "String",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        alphabet = \"abcdefghijklmnopqrstuvwxyz\"\\n        for letter in alphabet[alphabet.index(target) + 1:]:\\n            if letter in letters: return letter\\n        return letters[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785947,
                "title": "simple-java-solution-easy-to-understand",
                "content": "Upvote if you liked the solution\\n```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        \\n        int lo=0,hi=letters.length-1;\\n        int ans=0;\\n        while(lo<=hi)\\n        {\\n            int mid=lo+(hi-lo)/2;\\n            \\n            if(letters[mid]-target>0)\\n            {\\n                hi=mid-1;\\n                ans=mid;\\n            }\\n            else if(letters[mid]-target<=0) lo=mid+1;\\n            //else return ans;\\n        }\\n        return letters[ans];\\n    }\\n}",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        \\n        int lo=0,hi=letters.length-1;\\n        int ans=0;\\n        while(lo<=hi)\\n        {\\n            int mid=lo+(hi-lo)/2;\\n            \\n            if(letters[mid]-target>0)\\n            {\\n                hi=mid-1;\\n                ans=mid;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2657831,
                "title": "easy-binary-search-implementation-o-log-n",
                "content": "**Runtime: 8 ms, faster than 99.24% of C++ online submissions for Find Smallest Letter Greater Than Target.\\nMemory Usage: 15.9 MB, less than 69.98% of C++ online submissions for Find Smallest Letter Greater Than Target.**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int n = letters.size();\\n        if(letters[n-1]<=target)\\n            return letters[0];\\n        \\n        int start =0,end =n-1;\\n        char small=letters[n-1];\\n        while(start<=end)\\n        {\\n            int mid = start+(end-start)/2;\\n            if(letters[mid]>target)\\n            {\\n                if(small>letters[mid])\\n                    small=letters[mid];\\n                end = mid-1;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n            }\\n        }\\n        return small;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int n = letters.size();\\n        if(letters[n-1]<=target)\\n            return letters[0];\\n        \\n        int start =0,end =n-1;\\n        char small=letters[n-1];\\n        while(start<=end)\\n        {\\n            int mid = start+(end-start)/2;\\n            if(letters[mid]>target)\\n            {\\n                if(small>letters[mid])\\n                    small=letters[mid];\\n                end = mid-1;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n            }\\n        }\\n        return small;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2636947,
                "title": "java-easiest-100-faster",
                "content": "**Runtime: 0 ms, faster than 100.00% of Java online submissions for Find Smallest Letter Greater Than Target.\\nMemory Usage: 42.2 MB, less than 99.28% of Java online submissions for Find Smallest Letter Greater Than Target.**\\n\\n\\n```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        \\n        int st = 0, end = letters.length;\\n        while(st < end)\\n        {\\n            int mid = st + (end - st) / 2;\\n            if(letters[mid] > target)\\n            {\\n                end = mid;\\n            }else{\\n                st = mid + 1;\\n            }\\n        }\\n        return letters[st % letters.length];\\n    }\\n}\\n```\\n\\n\\n![upvote.webp](https://assets.leetcode.com/users/images/99d511d5-1c94-4afe-96c9-25eadc6b2c6c_1674204263.1308918.webp)\\n\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348) Thanks for voting!**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        \\n        int st = 0, end = letters.length;\\n        while(st < end)\\n        {\\n            int mid = st + (end - st) / 2;\\n            if(letters[mid] > target)\\n            {\\n                end = mid;\\n            }else{\\n                st = mid + 1;\\n            }\\n        }\\n        return letters[st % letters.length];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2595931,
                "title": "java-binary-search",
                "content": "```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n         int start = 0;\\n         int end = letters.length-1;\\n         int ans = 0;\\n         while(start<=end){\\n             int mid = start + (end-start)/2;\\n             if(letters[mid]<=target){\\n                 start = mid+1;\\n             }\\n             else{\\n                 ans = mid;\\n                 end = mid-1;\\n             }\\n         }\\n        return letters[ans];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n         int start = 0;\\n         int end = letters.length-1;\\n         int ans = 0;\\n         while(start<=end){\\n             int mid = start + (end-start)/2;\\n             if(letters[mid]<=target){\\n                 start = mid+1;\\n             }\\n             else{\\n                 ans = mid;\\n                 end = mid-1;\\n             }\\n         }\\n        return letters[ans];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2317792,
                "title": "simple-and-clever-solution",
                "content": "\\n  A simple logic to unterstand\\n  \\n  that is wrap of letters what we can do is a clever move is when our while condition is over we could\\n  directly print the first element ... this logic we could perform by initializing an extra char with starting char \\n \\n after that simply apply your binary search // no need to calculate distance or any diff stuff \\n \\n just go for it !!!!!!!!!!!\\n \\n char nextGreatestLetter(vector<char>& letters, char target) {\\n       \\n        int i = 0 ; \\n        int j = letters.size()-1 ;\\n        char ans = letters[0] ;  // initializing ans with first char for wrapping up the letters \\n        \\n        while(i<=j)\\n        {\\n            int mid = (i+j)/2 ;  \\n            \\n            if(letters[mid]==target)\\n            {\\n                i = mid+1 ;  // if target become equal to mid element then it move forward \\n            }\\n            else if( letters[mid] > target)\\n            {\\n                ans = letters[mid] ;  // if middle is greater then target it simply store it in ans \\n                j = mid-1 ;  // check for other element that is shorter but greater then target \\n            }\\n            else\\n            {\\n                i = mid+1 ; // if mid is smaller then simply move right word for getting greater element\\n            }\\n    \\n        }\\n       \\n        return ans ; \\n    }\\n\\t\\n\\tif you understand the ans then please do a upvote",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "\\n  A simple logic to unterstand\\n  \\n  that is wrap of letters what we can do is a clever move is when our while condition is over we could\\n  directly print the first element ... this logic we could perform by initializing an extra char with starting char \\n \\n after that simply apply your binary search // no need to calculate distance or any diff stuff \\n \\n just go for it !!!!!!!!!!!\\n \\n char nextGreatestLetter(vector<char>& letters, char target) {\\n       \\n        int i = 0 ; \\n        int j = letters.size()-1 ;\\n        char ans = letters[0] ;  // initializing ans with first char for wrapping up the letters \\n        \\n        while(i<=j)\\n        {\\n            int mid = (i+j)/2 ;  \\n            \\n            if(letters[mid]==target)\\n            {\\n                i = mid+1 ;  // if target become equal to mid element then it move forward \\n            }\\n            else if( letters[mid] > target)\\n            {\\n                ans = letters[mid] ;  // if middle is greater then target it simply store it in ans \\n                j = mid-1 ;  // check for other element that is shorter but greater then target \\n            }\\n            else\\n            {\\n                i = mid+1 ; // if mid is smaller then simply move right word for getting greater element\\n            }\\n    \\n        }\\n       \\n        return ans ; \\n    }\\n\\t\\n\\tif you understand the ans then please do a upvote",
                "codeTag": "Unknown"
            },
            {
                "id": 2175232,
                "title": "binary-search-o-logn-easy",
                "content": "```\\nchar ans = letters[0];\\n        int l=0,h=letters.length-1;\\n        while(l<=h){\\n            int m=l+((h-l)/2);\\n            if((int)letters[m]>(int)target){\\n                ans= letters[m];\\n                h=m-1;\\n            }else{\\n                l=m+1;\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nchar ans = letters[0];\\n        int l=0,h=letters.length-1;\\n        while(l<=h){\\n            int m=l+((h-l)/2);\\n            if((int)letters[m]>(int)target){\\n                ans= letters[m];\\n                h=m-1;\\n            }else{\\n                l=m+1;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1735570,
                "title": "runtime-8-ms-faster-than-98-93-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int s=0;\\n        int e = letters.size()-1;\\n        while(s<=e){\\n            int mid = s+(e-s)/2;\\n            if(letters[mid]>target) e = mid-1;   //if mid is greater than the target, search on the left side for a value smaller than mid but still greater than the target.\\n            else    s = mid+1;                             //if mid is smaller, as this is sorted array, value greater than target would be on the right side of array.\\n        }\\n        return letters[s%letters.size()];   //if character goes out of array modulo it with size of array to keep it in array range\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int s=0;\\n        int e = letters.size()-1;\\n        while(s<=e){\\n            int mid = s+(e-s)/2;\\n            if(letters[mid]>target) e = mid-1;   //if mid is greater than the target, search on the left side for a value smaller than mid but still greater than the target.\\n            else    s = mid+1;                             //if mid is smaller, as this is sorted array, value greater than target would be on the right side of array.\\n        }\\n        return letters[s%letters.size()];   //if character goes out of array modulo it with size of array to keep it in array range\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1608999,
                "title": "easy-python-solution",
                "content": "```\\ndef nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        for i in letters:\\n            if i > target:\\n                return i\\n        return letters[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        for i in letters:\\n            if i > target:\\n                return i\\n        return letters[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1045338,
                "title": "rust-optimum-solution-4-lines-of-code",
                "content": "```rust\\nimpl Solution {\\n    pub fn next_greatest_letter(letters: Vec<char>, target: char) -> char {\\n        let i = letters.binary_search(&target)\\n            .map(|i| i + 1)\\n            .unwrap_or_else(|i| i);\\n        letters[i % letters.len()]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Binary Tree"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn next_greatest_letter(letters: Vec<char>, target: char) -> char {\\n        let i = letters.binary_search(&target)\\n            .map(|i| i + 1)\\n            .unwrap_or_else(|i| i);\\n        letters[i % letters.len()]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 161440,
                "title": "javascript-o-logn-cracking-the-code-interview-typical-binary-search",
                "content": "The bits that differ from the Cracking The Code Interview version are marked as `HERE`.\\n\\n```\\n/**\\n * @param {character[]} letters\\n * @param {character} target\\n * @return {character}\\n */\\nvar nextGreatestLetter = function(letters, target) {\\n    let low = 0;\\n    let high = letters.length - 1;\\n\\n    while (low <= high) {\\n        const mid = Math.floor((high - low) / 2) + low;\\n        \\n        if (letters[mid] > target) {\\n            high = mid - 1;\\n        } else {\\n            // HERE: When the target is found we still want to continue searching on the right.\\n            low = mid + 1;\\n        }\\n    }\\n\\n    // HERE. % letter.length if low = mid + 1 got us to the end return the first letters entry.\\n    return letters[low % letters.length];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {character[]} letters\\n * @param {character} target\\n * @return {character}\\n */\\nvar nextGreatestLetter = function(letters, target) {\\n    let low = 0;\\n    let high = letters.length - 1;\\n\\n    while (low <= high) {\\n        const mid = Math.floor((high - low) / 2) + low;\\n        \\n        if (letters[mid] > target) {\\n            high = mid - 1;\\n        } else {\\n            // HERE: When the target is found we still want to continue searching on the right.\\n            low = mid + 1;\\n        }\\n    }\\n\\n    // HERE. % letter.length if low = mid + 1 got us to the end return the first letters entry.\\n    return letters[low % letters.length];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3619405,
                "title": "easy-java-solution-0ms-100-faster-beginner-friendly",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        int tar = (int)target;\\n        for(int i = 0 ; i < letters.length; i ++){\\n            char ch = letters[i];\\n            if((int)ch > tar){\\n                return ch;\\n            }\\n        }\\n        return letters[0];\\n    }\\n}\\n```\\n**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.\\nHappy Coding**",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        int tar = (int)target;\\n        for(int i = 0 ; i < letters.length; i ++){\\n            char ch = letters[i];\\n            if((int)ch > tar){\\n                return ch;\\n            }\\n        }\\n        return letters[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618096,
                "title": "using-arrays-binarysearch-in-java",
                "content": "# Complexity\\n- Time complexity: $$O(\\\\log N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        int index = Arrays.binarySearch(letters, (char)(target+1));\\n        if(index<0){\\n            index = -index-1;\\n        }\\n        int n = letters.length;\\n        return index < n? letters[index]:letters[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        int index = Arrays.binarySearch(letters, (char)(target+1));\\n        if(index<0){\\n            index = -index-1;\\n        }\\n        int n = letters.length;\\n        return index < n? letters[index]:letters[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618063,
                "title": "java-c",
                "content": "# Intuition\\n```Java []\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        char ans;\\n      for(int i=0;i<letters.length;i++)\\n      {\\n          if(letters[i] >target)\\n          {\\n              return letters[i];\\n          }\\n      } \\n      return letters[0]; \\n    }\\n}\\n// 97 to 122 lowercase\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int left = 0, right = letters.size() - 1, mid;\\n        while (left <= right) {\\n            mid = (left + right) / 2;\\n            if (letters[mid] <= target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n            }     \\n            if(left==letters.size())\\n            {\\n            return letters[0];\\n            }\\n            return letters[left];\\n        }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Binary Search"
                ],
                "code": "```Java []\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        char ans;\\n      for(int i=0;i<letters.length;i++)\\n      {\\n          if(letters[i] >target)\\n          {\\n              return letters[i];\\n          }\\n      } \\n      return letters[0]; \\n    }\\n}\\n// 97 to 122 lowercase\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617665,
                "title": "c-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->The given code aims to find the next greatest letter in a given vector of characters, relative to a target letter. Here are my initial thoughts on how to solve this problem:\\n\\n1. The code uses a simple approach of iterating through each letter in the vector using a for-each loop.\\n2. For each letter, it checks if the letter is greater than the target letter. If it is, then it immediately returns that letter as the next greatest letter.\\n3. If the loop completes without finding a greater letter, it means that the next greatest letter should wrap around to the beginning of the vector. In this case, the code returns the first letter of the vector.\\n\\nWhile this code seems to be functional, there are a few potential improvements that could be considered:\\n\\n1. The given code assumes that the vector of letters is already sorted in ascending order. If the input is not guaranteed to be sorted, we might need to add a step to sort the vector before performing the search.\\n2. The current implementation uses a linear search, which has a time complexity of O(n), where n is the number of letters in the vector. If the vector is large, this approach could be time-consuming. Considering that the vector is sorted, we could potentially utilize a binary search algorithm to find the next greatest letter more efficiently with a time complexity of O(log n).\\n3. The code does not handle the case when the target letter is greater than all the letters in the vector. In this case, it should return the first letter of the vector as the next greatest letter. A simple modification can be made to handle this situation explicitly.\\n\\nConsidering these points, a more optimized version of the code could involve the following steps:\\n\\n1. Sort the vector of letters if it is not already sorted.\\n2. Implement a binary search algorithm to find the next greatest letter efficiently.\\n3. Handle the case when the target letter is greater than all the letters in the vector by returning the first letter.\\n\\nBy incorporating these improvements, we can enhance the performance and functionality of the code.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->To solve the problem of finding the next greatest letter in a vector of characters relative to a target letter, here\\'s a step-by-step approach:\\n\\n1. Initialize a variable, let\\'s say `nextLetter`, to store the next greatest letter. Set its initial value to the first letter in the vector, `letters[0]`.\\n\\n2. Perform a binary search on the sorted vector of letters to find the next greatest letter. To do this, set up two pointers, `left` and `right`, initially pointing to the beginning and end of the vector, respectively.\\n\\n3. While `left` is less than or equal to `right`, calculate the middle index as `(left + right) / 2` and store it in a variable called `mid`.\\n\\n4. Compare the letter at index `mid` with the target letter:\\n   - If the letter at `mid` is greater than the target letter, update `nextLetter` to the current letter at `mid` and move the `right` pointer to `mid - 1` to continue searching in the left half of the vector.\\n   - If the letter at `mid` is less than or equal to the target letter, move the `left` pointer to `mid + 1` to continue searching in the right half of the vector.\\n\\n5. Repeat steps 3-4 until `left` becomes greater than `right`. At this point, the `nextLetter` variable will contain the next greatest letter in the vector.\\n\\n6. Check if `nextLetter` is valid. If it is, return `nextLetter` as the next greatest letter. Otherwise, since the target letter is greater than all the letters in the vector, return the first letter of the vector as the next greatest letter.\\n\\nBy using a binary search algorithm instead of a linear search, we can reduce the time complexity from O(n) to O(log n), resulting in a more efficient solution. Additionally, handling the edge case where the target letter is greater than all the letters ensures that the code covers all possible scenarios.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->o(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->o(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target)\\n     {\\n        for (char letter : letters) \\n        {\\n            if (letter > target)\\n             {\\n                return letter;\\n            }\\n        }\\n        return letters[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target)\\n     {\\n        for (char letter : letters) \\n        {\\n            if (letter > target)\\n             {\\n                return letter;\\n            }\\n        }\\n        return letters[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617071,
                "title": "java-solutions-with-explanations",
                "content": "# Intuition \\nThere are many ways to solve this problem so i\\'m going to show two solutions\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# 1. Iterative\\n<!-- Describe your approach to solving the pcroblem. -->\\n\\nThe first approach is iteration, how does it work?- first we compare the last character in the array with our target char if the last character is less than  target it means there is no element which is greater than target(because our array is in non-decreasing order), so we just return the first element of the array.\\n    e.x: letters = [\"a\",\"b\",\"c\",\"d\"], target = \"e\"\\n    we compare the last element of array which is `d`, `d`<`e`, sowe  should return `a`.\\nIf the last character is not less than or equal to the target we iterate the array untill we find the answer.\\n\\n\\n\\n# Complexity\\n- Time complexity: `O(N)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity:`O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        if(letters[letters.length - 1] <= target) return letters[0]; //no need to iterate whole array\\n\\n        for (char letter : letters) {\\n            if (letter > target) {\\n                return letter;\\n            }\\n        }\\n        //just return smth\\n        return letters[0];\\n    }\\n}\\n```\\n# 2. Binary Search\\n This approach is more optimal than the first one because time complexity is `O(logN)`. I tried to explain it with comments.\\n\\n# Complexity\\n- Time complexity: `O(logN)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:`O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        int left = 0;\\n        int right = letters.length - 1;\\n\\n        while(left < right) {\\n            int mid = (left + right) / 2;\\n\\n            if(letters[mid] > target) {\\n                // letters[mid] > target, if letters[mid - 1] <= target answer is letters[mid]\\n                if(mid - 1 >= 0 && letters[mid - 1] <= target) {\\n                    return letters[mid];\\n                }\\n                right = mid - 1;\\n            } else {\\n                // letters[mid] <= target, if letters[mid+1] > target answer is leteers[mid+1]\\n                if(letters[mid+1] > target) return letters[mid+1];\\n                left = mid + 1;\\n            }\\n        }\\n        return letters[0];\\n    }\\n}\\n```\\n\\n# *PLEASE UPVOTE IF YOU LIKE THE SOLUTIONS*\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        if(letters[letters.length - 1] <= target) return letters[0]; //no need to iterate whole array\\n\\n        for (char letter : letters) {\\n            if (letter > target) {\\n                return letter;\\n            }\\n        }\\n        //just return smth\\n        return letters[0];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        int left = 0;\\n        int right = letters.length - 1;\\n\\n        while(left < right) {\\n            int mid = (left + right) / 2;\\n\\n            if(letters[mid] > target) {\\n                // letters[mid] > target, if letters[mid - 1] <= target answer is letters[mid]\\n                if(mid - 1 >= 0 && letters[mid - 1] <= target) {\\n                    return letters[mid];\\n                }\\n                right = mid - 1;\\n            } else {\\n                // letters[mid] <= target, if letters[mid+1] > target answer is leteers[mid+1]\\n                if(letters[mid+1] > target) return letters[mid+1];\\n                left = mid + 1;\\n            }\\n        }\\n        return letters[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616875,
                "title": "c-easy-solution-o-logn-n-o-n-approaches",
                "content": "### Approach 1:\\nWe iterate over each character one by one and the characters are compared directly using the \\'>\\' operator, as characters in C++ are represented as ASCII values. This ensures that the comparison is done correctly based on the character\\'s alphabetical order.\\n\\n**Complexity**\\n* Time complexity: O(n)\\n\\n* Space complexity: O(1)\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) \\n    {\\n        int targetnum=target-\\'0\\';\\n        for(char i : letters)\\n        {\\n            int ch=i-\\'0\\';\\n            if(ch>targetnum)\\n                return i;\\n        }\\n        return letters[0];\\n            \\n    }\\n};\\n```\\n\\n**OR**\\n\\n```\\n  class Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        for (char i : letters) {\\n            if (i > target) {\\n                return i;\\n            }\\n        }\\n        return letters[0];\\n    }\\n};\\n\\n```\\n\\n### Approach 2:\\nWe simply find the ***UPPERBOUND*** which finds the value that is just greater than the target.\\nIf not found then return the first element of vector.\\n\\n\\n**Complexity**\\n* Time complexity: O(log n)\\n\\n* Space complexity: O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        auto it = upper_bound(letters.begin(),letters.end(),target);\\n        return it!=letters.end() ?*it:letters[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) \\n    {\\n        int targetnum=target-\\'0\\';\\n        for(char i : letters)\\n        {\\n            int ch=i-\\'0\\';\\n            if(ch>targetnum)\\n                return i;\\n        }\\n        return letters[0];\\n            \\n    }\\n};\\n```\n```\\n  class Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        for (char i : letters) {\\n            if (i > target) {\\n                return i;\\n            }\\n        }\\n        return letters[0];\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        auto it = upper_bound(letters.begin(),letters.end(),target);\\n        return it!=letters.end() ?*it:letters[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616367,
                "title": "c-binary-search",
                "content": "# Intuition\\nUsed binary search to solve this problem.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public char NextGreatestLetter(char[] letters, char target) {\\n        int s = 0, e = letters.Length - 1;\\n        \\n        if (letters[letters.Length - 1] <= target) \\n            return letters[0];\\n\\n        while(s < e) {\\n            int mid = (s + e)/2;\\n            if (letters[mid] <= target) \\n                s = mid + 1;\\n            else \\n                e = mid;    \\n        }\\n\\n        return letters[s];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Binary Search"
                ],
                "code": "```\\npublic class Solution {\\n    public char NextGreatestLetter(char[] letters, char target) {\\n        int s = 0, e = letters.Length - 1;\\n        \\n        if (letters[letters.Length - 1] <= target) \\n            return letters[0];\\n\\n        while(s < e) {\\n            int mid = (s + e)/2;\\n            if (letters[mid] <= target) \\n                s = mid + 1;\\n            else \\n                e = mid;    \\n        }\\n\\n        return letters[s];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616293,
                "title": "c-2-lines-solution-beats-100-full-optmized",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        // set<int>jat;\\n        // if(letters[letters.size()-1]<=target)\\n        // {\\n        //     return letters[0];\\n        // }\\n        // for(int i=0;i<letters.size();i++)\\n        // {\\n        //     if(letters[i]>target){\\n        //     int temp=letters[i]-target;\\n        //     if(temp==0)\\n        //     {\\n        //         return letters[i+1];\\n        //     }\\n        //     jat.insert(temp);}\\n        // }\\n        // return target+*jat.begin();\\n        int i=upper_bound(letters.begin(), letters.end(), target)-letters.begin();\\n        return (i==letters.size())?letters[0]:letters[i];\\n\\n\\n        \\n    }\\n};\\n```\\n![7abc56.jpg](https://assets.leetcode.com/users/images/fb6a1a9c-032a-44d9-b8bd-586384bf45d8_1686285707.9943612.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        // set<int>jat;\\n        // if(letters[letters.size()-1]<=target)\\n        // {\\n        //     return letters[0];\\n        // }\\n        // for(int i=0;i<letters.size();i++)\\n        // {\\n        //     if(letters[i]>target){\\n        //     int temp=letters[i]-target;\\n        //     if(temp==0)\\n        //     {\\n        //         return letters[i+1];\\n        //     }\\n        //     jat.insert(temp);}\\n        // }\\n        // return target+*jat.begin();\\n        int i=upper_bound(letters.begin(), letters.end(), target)-letters.begin();\\n        return (i==letters.size())?letters[0]:letters[i];\\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615697,
                "title": "c-binary-search-linear",
                "content": "# Linear\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& v, char &c) {\\n        for(auto &i: v){\\n            if(i>c)return i;\\n        }\\n        return v[0];\\n    }\\n};\\n```\\n# Binary search\\n````\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& v, char &c) {\\n        int x = upper_bound(v.begin(),v.end(),c)-v.begin();\\n        if(x == v.size())return v[0];\\n        return v[x];\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& v, char &c) {\\n        for(auto &i: v){\\n            if(i>c)return i;\\n        }\\n        return v[0];\\n    }\\n};\\n```\n````\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& v, char &c) {\\n        int x = upper_bound(v.begin(),v.end(),c)-v.begin();\\n        if(x == v.size())return v[0];\\n        return v[x];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615628,
                "title": "simple-binary-search-python-js-solution",
                "content": "Hello **Tenno Leetcoders**, \\nFor this problem, we are given an array of characters `letters` that is sorted in non-decreasing order, and a character `target`. There are at least two different characters in letters.\\n\\nReturn the `smallest character` in `letters` that is `lexicographically greater` than target. If such a character does not exist, return the first character in letters.\\n\\n### Explanation\\n\\nSince our `letters` array is already sorted in non-decreasing order. We can utilize Binary Search to help us find the smallest character greater than the target\\n\\nInitialize two pointers, `left` and `right` pointing to the start and the end of the array\\n\\nIterate and perform binary search until left becomes greater than right:\\n\\n   - For each iteration calculate the middle index\\n   \\n   - If the mid character is less than or equal to our target, we can update left to `mid + 1` \\n     to search in the right half of the array as the next greater character lies in the right half of the array\\n     \\n   - Otherwise if the mid character is greater than the target, we should update the right to `mid - 1` to search in the left half of the array as the next greater character can be at mid or lies in the left half of the array\\n   \\nAfter left becomes greater than right pointer, we will check for the following:\\n\\n1) Check if left has reached the last index. In this case, our target value is greater than all the characters in the array.\\n      \\n      - Return the first character in the array\\n      \\n2) Otherwise, we should return the character at the left, which will be the smallest character greater than the target \\n\\n\\n# Code\\n**Python**\\n\\n```\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        n = len(letters)\\n        left, right =  0, n - 1\\n\\n        while left <= right:\\n            mid = left + (right - left) // 2\\n            if letters[mid] <= target:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n                \\n        if left == n: return letters[0]\\n        else: return letters[left]\\n```\\n\\n**JavaScript**\\n```\\n/**\\n * @param {character[]} letters\\n * @param {character} target\\n * @return {character}\\n */\\nvar nextGreatestLetter = function(letters, target) {\\n\\n    const n = letters.length  \\n    let left = 0, right = n - 1\\n    while (left <= right){\\n        const mid = Math.floor(left + (right - left) / 2)\\n        letters[mid] <= target ? left = mid + 1 : right = mid - 1\\n    }\\n    return left == n ? letters[0] : letters[left]\\n};\\n```\\n\\n### Time Complexity: `O(n log n)`\\n### Space Complexity: `O(1)`\\n\\n \\n***Warframe\\'s Darvo wants you to upvote this post  \\uD83D\\uDE4F\\uD83C\\uDFFB \\u2764\\uFE0F\\u200D\\uD83D\\uDD25***\\n\\n![image](https://assets.leetcode.com/users/images/814f5668-c966-46d7-ba42-e5435c4c1761_1675302761.3081913.gif)",
                "solutionTags": [
                    "Python3",
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        n = len(letters)\\n        left, right =  0, n - 1\\n\\n        while left <= right:\\n            mid = left + (right - left) // 2\\n            if letters[mid] <= target:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n                \\n        if left == n: return letters[0]\\n        else: return letters[left]\\n```\n```\\n/**\\n * @param {character[]} letters\\n * @param {character} target\\n * @return {character}\\n */\\nvar nextGreatestLetter = function(letters, target) {\\n\\n    const n = letters.length  \\n    let left = 0, right = n - 1\\n    while (left <= right){\\n        const mid = Math.floor(left + (right - left) / 2)\\n        letters[mid] <= target ? left = mid + 1 : right = mid - 1\\n    }\\n    return left == n ? letters[0] : letters[left]\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372172,
                "title": "fastest-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        int n =letters.length;\\n        int low =0;\\n        int high=n-1;\\n        if(target>letters[n-1])\\n        {\\n            return letters[0];\\n        }\\n        while(low<=high)\\n        {\\n            int mid =low+(high-low)/2;\\n            // if(letters[mid]==target)\\n            // {\\n            //     return letters[mid+1];\\n            // }\\n             if(letters[mid]>target)\\n            {\\n                                high=mid-1;\\n\\n            }\\n            else{\\n                                low=mid+1;\\n\\n            }\\n\\n        }\\n        return letters[low%n];\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        int n =letters.length;\\n        int low =0;\\n        int high=n-1;\\n        if(target>letters[n-1])\\n        {\\n            return letters[0];\\n        }\\n        while(low<=high)\\n        {\\n            int mid =low+(high-low)/2;\\n            // if(letters[mid]==target)\\n            // {\\n            //     return letters[mid+1];\\n            // }\\n             if(letters[mid]>target)\\n            {\\n                                high=mid-1;\\n\\n            }\\n            else{\\n                                low=mid+1;\\n\\n            }\\n\\n        }\\n        return letters[low%n];\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300858,
                "title": "c-solution-binary-search-brute-force",
                "content": "\\n# Approach: Binary Search\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n\\n    // binary search\\n    int n=letters.size();\\n    int start = 0;\\n    int end = n - 1;\\n    char ans = letters[0];\\n    if(letters[end]<=target)\\n        return ans;\\n    while (start < end)\\n    {\\n        int mid = start + (end - start) / 2;\\n        if (letters[mid] == target || letters[mid] < target)\\n        {\\n            start = mid + 1;\\n            ans=letters[start];\\n        }\\n        else if (letters[mid] > target)\\n        {\\n            end = mid;\\n            ans = letters[end];\\n        }\\n    }\\n    return ans;\\n\\n    }\\n};\\n```\\n# Approach: Brute Force\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n\\n    // brute force\\n    for (int i = 0; i < letters.size(); i++)\\n        if (letters[i] > target)\\n            return letters[i];\\n    return letters[0];\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n\\n    // binary search\\n    int n=letters.size();\\n    int start = 0;\\n    int end = n - 1;\\n    char ans = letters[0];\\n    if(letters[end]<=target)\\n        return ans;\\n    while (start < end)\\n    {\\n        int mid = start + (end - start) / 2;\\n        if (letters[mid] == target || letters[mid] < target)\\n        {\\n            start = mid + 1;\\n            ans=letters[start];\\n        }\\n        else if (letters[mid] > target)\\n        {\\n            end = mid;\\n            ans = letters[end];\\n        }\\n    }\\n    return ans;\\n\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n\\n    // brute force\\n    for (int i = 0; i < letters.size(); i++)\\n        if (letters[i] > target)\\n            return letters[i];\\n    return letters[0];\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3128774,
                "title": "beats-100-by-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf the target char is smaller or bigger than any other char in the list, we need to return the first element (it is implicitly sad in problem description).\\nOtherwise we should run binary search.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def nextGreatestLetter(self, letters, target):\\n        \"\"\"\\n        :type letters: List[str]\\n        :type target: str\\n        :rtype: str\\n        \"\"\"\\n\\n        if target < letters[0] or target >= letters[-1]:\\n            return letters[0]\\n        \\n        left = 0\\n        right = len(letters) - 2\\n\\n        while left <= right:\\n\\n            mid = (left + right) // 2\\n\\n            if target >= letters[mid]:\\n                res = letters[mid+1]\\n                left = mid + 1\\n            else:\\n                res = letters[mid]\\n                right = mid - 1\\n                \\n\\n        return res            \\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def nextGreatestLetter(self, letters, target):\\n        \"\"\"\\n        :type letters: List[str]\\n        :type target: str\\n        :rtype: str\\n        \"\"\"\\n\\n        if target < letters[0] or target >= letters[-1]:\\n            return letters[0]\\n        \\n        left = 0\\n        right = len(letters) - 2\\n\\n        while left <= right:\\n\\n            mid = (left + right) // 2\\n\\n            if target >= letters[mid]:\\n                res = letters[mid+1]\\n                left = mid + 1\\n            else:\\n                res = letters[mid]\\n                right = mid - 1\\n                \\n\\n        return res            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2931182,
                "title": "binary-search-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        int start = 0, end = letters.length-1; \\n        \\n        while(start<=end){\\n            int mid = start + (end - start)/2;\\n            if(letters[mid]>target){\\n                end = mid - 1;\\n            }\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        \\n        return letters[start % letters.length];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        int start = 0, end = letters.length-1; \\n        \\n        while(start<=end){\\n            int mid = start + (end - start)/2;\\n            if(letters[mid]>target){\\n                end = mid - 1;\\n            }\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        \\n        return letters[start % letters.length];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2572358,
                "title": "check-ascii-val-easy-java-code",
                "content": "```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        \\n        for(char c : letters){\\n         if(c-\\'a\\'>target-\\'a\\')return c;   \\n        }\\n        return letters[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        \\n        for(char c : letters){\\n         if(c-\\'a\\'>target-\\'a\\')return c;   \\n        }\\n        return letters[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2360023,
                "title": "c-binary-search",
                "content": "*Please upvote if you find it helpful :)*\\n\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int low=0, high=letters.size()-1,n=letters.size();\\n        char res=\\'#\\';\\n        while(low<=high) {\\n            int mid = (low+high)/2;\\n            if(low<=mid && letters[mid]<=target)\\n                low=mid+1;\\n            else if(mid<=high) {\\n                res = letters[mid];\\n                high = mid-1;\\n            }\\n        }\\n        if(res==\\'#\\')\\n            res = letters[0];                                   // due to letters wrap \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int low=0, high=letters.size()-1,n=letters.size();\\n        char res=\\'#\\';\\n        while(low<=high) {\\n            int mid = (low+high)/2;\\n            if(low<=mid && letters[mid]<=target)\\n                low=mid+1;\\n            else if(mid<=high) {\\n                res = letters[mid];\\n                high = mid-1;\\n            }\\n        }\\n        if(res==\\'#\\')\\n            res = letters[0];                                   // due to letters wrap \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2078998,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        letters.sort()\\n        for i in letters:\\n            if (i>target):\\n                return i\\n        return letters[0]\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        letters.sort()\\n        for i in letters:\\n            if (i>target):\\n                return i\\n        return letters[0]\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2060942,
                "title": "clear-explanation-3-different-methods",
                "content": "This question took me awhile to understand, but thanks to the leetcode discuss section and amazing folks helping each other here - I was able to figure it out and understand completely.\\n\\nExplanation to problem: We are given a char array (alphabets lol), and lets suppose all of them are sitting on a round table in non decreasing order or serialwise, \\'a\\' being at the right of \\'z\\'.\\n\\nSo we are supposed to return the most near right neighbour of the given char (target) - which is obviously greater then itself!\\nand, if not -\\nThink of it as like - *you will travel the whole circle starting from the right of you and encounter a element present in that array - that will be the first element, right!*\\n\\n**Code:**\\n\\n**First Method:** Linear search\\nTime complexity: O(n)\\nExplanation: Traverse through whole array and check if there\\'s an element greater than the target, if not return first element. \\n\\n```\\nchar nextGreatestLetter(vector<char> &letters, char target)\\n{\\n    // brute force\\n    // O(n)\\n    // O(1)\\n    int n = letters.size();\\n    for (int i = 0; i < n; i++)\\n    {\\n        if (letters[i] > target)\\n            return letters[i];\\n    }\\n    return letters[0];\\n}\\n```\\n\\n**Second Method:** Binary search\\nTime complexity: O(logn)\\nExplanation: Apply binary search to find the index of the element greater to target, return the index in by using modulo arithmetic (letters [low % n], if there no such index exists, then low pointer will become equal to size of array, and n%n=0, so it will return first element of array.\\n\\n```\\nchar nextGreatestLetter(vector<char> &letters, char target)\\n{\\n    // optimized\\n    // binary search\\n    // O(logn)\\n    // O(1)\\n    int n = letters.size();\\n    int low = 0, hi = n - 1;\\n    while (low <= hi)\\n    {\\n        int mid = low + (hi - low) / 2;\\n        if (letters[mid] > target)\\n            hi = mid - 1;\\n        else\\n            low = mid + 1;\\n    }\\n\\n    // if (low == n) then return letters[0]\\n    // else return letters[low]\\n    return letters[low % n];\\n}\\n```\\n\\n**Third Method:** Using C++ STL \\nTime complexity: O(logn)\\nExplanation: Use C++ upper bound function, as the array is already sorted, it will give the next greater element if it exists in the array or first element if it doesn\\'t.\\n\\n```\\nchar nextGreatestLetter(vector<char> &letters, char target)\\n{\\n    // using STL\\n    // O(logn)\\n    // O(1)\\n    auto it = upper_bound(letters.begin(), letters.end(), target);\\n    return it == letters.end() ? letters[0] : *it;\\n}\\n```\\n\\nHope you liked the explanation! Happy leetcoding ^^\\n",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nchar nextGreatestLetter(vector<char> &letters, char target)\\n{\\n    // brute force\\n    // O(n)\\n    // O(1)\\n    int n = letters.size();\\n    for (int i = 0; i < n; i++)\\n    {\\n        if (letters[i] > target)\\n            return letters[i];\\n    }\\n    return letters[0];\\n}\\n```\n```\\nchar nextGreatestLetter(vector<char> &letters, char target)\\n{\\n    // optimized\\n    // binary search\\n    // O(logn)\\n    // O(1)\\n    int n = letters.size();\\n    int low = 0, hi = n - 1;\\n    while (low <= hi)\\n    {\\n        int mid = low + (hi - low) / 2;\\n        if (letters[mid] > target)\\n            hi = mid - 1;\\n        else\\n            low = mid + 1;\\n    }\\n\\n    // if (low == n) then return letters[0]\\n    // else return letters[low]\\n    return letters[low % n];\\n}\\n```\n```\\nchar nextGreatestLetter(vector<char> &letters, char target)\\n{\\n    // using STL\\n    // O(logn)\\n    // O(1)\\n    auto it = upper_bound(letters.begin(), letters.end(), target);\\n    return it == letters.end() ? letters[0] : *it;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1878756,
                "title": "find-smallest-letter-greater-than-target-solution-java",
                "content": "class Solution {\\n  public char nextGreatestLetter(char[] letters, char target) {\\n    int l = 0;\\n    int r = letters.length;\\n\\n    while (l < r) {\\n      final int m = l + (r - l) / 2;\\n      if (letters[m] > target)\\n        r = m;\\n      else\\n        l = m + 1;\\n    }\\n\\n    return letters[l % letters.length];\\n  }\\n}\\n",
                "solutionTags": [
                    "Array",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n  public char nextGreatestLetter(char[] letters, char target) {\\n    int l = 0;\\n    int r = letters.length;\\n\\n    while (l < r) {\\n      final int m = l + (r - l) / 2;\\n      if (letters[m] > target)\\n        r = m;\\n      else\\n        l = m + 1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1846580,
                "title": "go-idiomatic-binary-search-solution-easy-to-understand",
                "content": "```\\nfunc nextGreatestLetter(letters []byte, target byte) byte {\\n    left, right := 0, len(letters)-1\\n    index := -1\\n    for left <= right {\\n        mid := left+(right-left)/2\\n        if letters[mid] < target {\\n            left = mid+1\\n        } else if letters[mid] == target {\\n            index = mid+1\\n            left = mid+1\\n        } else {\\n            right = mid-1\\n        }\\n    }\\n    if index == -1 { return letters[left%len(letters)] }\\n    return letters[index%len(letters)]\\n}\\n```\\n\\n```\\nfunc nextGreatestLetter(letters []byte, target byte) byte {\\n    left, right := 0, len(letters)-1\\n    for left <= right {\\n        mid := left+(right-left)/2\\n        if letters[mid] <= target {\\n            left = mid+1\\n        } else {\\n            right = mid-1\\n        }\\n    }\\n    return letters[left%len(letters)]\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Tree"
                ],
                "code": "```\\nfunc nextGreatestLetter(letters []byte, target byte) byte {\\n    left, right := 0, len(letters)-1\\n    index := -1\\n    for left <= right {\\n        mid := left+(right-left)/2\\n        if letters[mid] < target {\\n            left = mid+1\\n        } else if letters[mid] == target {\\n            index = mid+1\\n            left = mid+1\\n        } else {\\n            right = mid-1\\n        }\\n    }\\n    if index == -1 { return letters[left%len(letters)] }\\n    return letters[index%len(letters)]\\n}\\n```\n```\\nfunc nextGreatestLetter(letters []byte, target byte) byte {\\n    left, right := 0, len(letters)-1\\n    for left <= right {\\n        mid := left+(right-left)/2\\n        if letters[mid] <= target {\\n            left = mid+1\\n        } else {\\n            right = mid-1\\n        }\\n    }\\n    return letters[left%len(letters)]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1485910,
                "title": "java-runtime-0ms-faster-than-100-00",
                "content": "\\n```\\npublic char nextGreatestLetter(char[] letters, char target) {\\n        \\n        int start = 0;\\n        int end = letters.length-1;\\n        \\n\\t\\t// return the first element if there is no character greater than target in the array\\n        if(target >= letters[letters.length-1]){\\n            return letters[0];\\n        }\\n        \\n        while(start <= end){\\n            \\n            int mid = start + (end-start)/2;\\n            \\n            if(target >= letters[mid]){\\n                start = mid+1;\\n            }\\n            else if(target < letters[mid]){\\n                end = mid-1;\\n            }\\n        }\\n        \\n\\t\\t// after the loop breaks; start element will be smallest element greater than target\\n        return letters[start];\\n    }\\n\\t",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "\\n```\\npublic char nextGreatestLetter(char[] letters, char target) {\\n        \\n        int start = 0;\\n        int end = letters.length-1;\\n        \\n\\t\\t// return the first element if there is no character greater than target in the array\\n        if(target >= letters[letters.length-1]){\\n            return letters[0];\\n        }\\n        \\n        while(start <= end){\\n            \\n            int mid = start + (end-start)/2;\\n            \\n            if(target >= letters[mid]){\\n                start = mid+1;\\n            }\\n            else if(target < letters[mid]){\\n                end = mid-1;\\n            }\\n        }\\n        \\n\\t\\t// after the loop breaks; start element will be smallest element greater than target\\n        return letters[start];\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 793654,
                "title": "c-simple-bin-search",
                "content": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& A, char target) {\\n        int l=0,r=A.size()-1;\\n        int res=-1;\\n        while(l<=r){\\n            int mid=l+(r-l)/2;\\n            if(A[mid]>target){\\n                res=mid;\\n                r=mid-1;\\n            }else{\\n                l=mid+1;\\n            }\\n        }\\n        if(res==-1)res=0;\\n        return A[res];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& A, char target) {\\n        int l=0,r=A.size()-1;\\n        int res=-1;\\n        while(l<=r){\\n            int mid=l+(r-l)/2;\\n            if(A[mid]>target){\\n                res=mid;\\n                r=mid-1;\\n            }else{\\n                l=mid+1;\\n            }\\n        }\\n        if(res==-1)res=0;\\n        return A[res];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 681190,
                "title": "easy-to-understand-python-3-code",
                "content": "```\\nclass Solution:\\n    def nextGreatestLetter(self, arr: List[str], target: str) -> str:\\n        n=len(arr)\\n        low,high=0,n-1\\n        if target<arr[0]:\\n            return arr[0]\\n        if target>=arr[n-1]:\\n            return arr[0]\\n        \\n        res=None\\n        while low<=high:\\n            mid=low+(high-low)//2\\n            if target>=arr[mid]:\\n                low=mid+1\\n            else:\\n                res=arr[mid]\\n                high=mid-1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextGreatestLetter(self, arr: List[str], target: str) -> str:\\n        n=len(arr)\\n        low,high=0,n-1\\n        if target<arr[0]:\\n            return arr[0]\\n        if target>=arr[n-1]:\\n            return arr[0]\\n        \\n        res=None\\n        while low<=high:\\n            mid=low+(high-low)//2\\n            if target>=arr[mid]:\\n                low=mid+1\\n            else:\\n                res=arr[mid]\\n                high=mid-1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 225457,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        int lo = 0;\\n        int hi = letters.length - 1;\\n        char result = letters[0]; // Possible result\\n        while (lo <= hi) {\\n            int m = lo + (hi - lo) / 2;\\n            if (letters[m] > target) {\\n                result = letters[m]; // Possible result\\n                hi = m - 1;\\n            } else {\\n                lo = m + 1;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        int lo = 0;\\n        int hi = letters.length - 1;\\n        char result = letters[0]; // Possible result\\n        while (lo <= hi) {\\n            int m = lo + (hi - lo) / 2;\\n            if (letters[m] > target) {\\n                result = letters[m]; // Possible result\\n                hi = m - 1;\\n            } else {\\n                lo = m + 1;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 190551,
                "title": "c-c-sharp-solution",
                "content": "foreach (var l in letters)\n            {\n                 if (l > target) return l;\n            }\n            return letters[0];",
                "solutionTags": [],
                "code": "foreach (var l in letters)\n            {\n                 if (l > target) return l;\n            }\n            return letters[0];",
                "codeTag": "Unknown"
            },
            {
                "id": 4044504,
                "title": "0ms-beats-100-00-of-users-with-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        int start=0;\\n        int end=letters.length-1;\\n        if(letters[end]<=target || target<letters[start]) {\\n            return letters[start];\\n        }\\n        \\n        while(start<=end) {\\n            int mid=start+(end-start)/2;\\n            if(letters[mid]<=target) {\\n                start=mid+1;\\n            } else {\\n                end=mid-1;\\n                \\n            }\\n        }\\n        return letters[start];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        int start=0;\\n        int end=letters.length-1;\\n        if(letters[end]<=target || target<letters[start]) {\\n            return letters[start];\\n        }\\n        \\n        while(start<=end) {\\n            int mid=start+(end-start)/2;\\n            if(letters[mid]<=target) {\\n                start=mid+1;\\n            } else {\\n                end=mid-1;\\n                \\n            }\\n        }\\n        return letters[start];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006657,
                "title": "find-smallest-letter-greater-than-target",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int index = -1;\\n        int s = 0, e = letters.size()-1;\\n\\n        while (s<=e) {\\n            int m = (s+e)/2;\\n\\n            if (letters[m] > target) {\\n                index = m;\\n                e = m-1;\\n            }\\n            else s = m+1;\\n        }\\n\\n        return index>-1? letters[index]: letters[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int index = -1;\\n        int s = 0, e = letters.size()-1;\\n\\n        while (s<=e) {\\n            int m = (s+e)/2;\\n\\n            if (letters[m] > target) {\\n                index = m;\\n                e = m-1;\\n            }\\n            else s = m+1;\\n        }\\n\\n        return index>-1? letters[index]: letters[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904919,
                "title": "best-and-simple-solution-with-explaination-for-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst thought tnat came in my mind was if the array of charcter is already sorted then we can use binary search instead of linear search so the we can reduce the time coplexity fron O(n) to O(log n)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStep 1 : As the array is sorted then the first step is already clear we have to use binary search\\n\\nStep 2 : In the we to return the next elemnet of the target if the next element is not present then we have to print the first elemnt\\n\\nStep 3 : Now you might be thinking that we can get the position of\\nthe target element and we can just return arr[mid+1] instead of    arr[mid] \"well that is also a good approach but what is the elemnt is in the last then it will throw error //outofbound\"\\n\\nStep 4:here is my approach i have just printed the start but why \\nlet there are 3 element c f j\\ns=start\\ne=end \\nm=mid\\n----> s(c)  m(f)  e(j)  here start pointer is in c like wise mid in f and end in j  \\n\\nnow, \\n          target =c    o/p must be f\\n          first check\\n                if (target < letters[mid]) //pass\\n                {\\n                    end = mid - 1;\\n                } \\n----->s,e,m(c)  f   j\\n\\n        second check\\n               if (target < letters[mid]) //fail   \\n                {\\n                    end = mid - 1;\\n                } \\n                else //pass\\n                {\\n                    start= mid + 1;\\n                }\\n-----> e,m(c)  s(f)   j  here the while loop will break as start is greater then end and we have our and now\\n\\nstep 5 as we have to be in the bound so we are performing modulo operation \\n # Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(logn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        int end = letters.length - 1;\\n        int start = 0;\\n        while (start <= end) \\n        {\\n                int mid = start + (end - start) / 2;\\n                if (target < letters[mid]) \\n                {\\n                    end = mid - 1;\\n                } \\n                else \\n                {\\n                    start= mid + 1;\\n                }\\n        }\\n    return letters[start%letters.length];    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        int end = letters.length - 1;\\n        int start = 0;\\n        while (start <= end) \\n        {\\n                int mid = start + (end - start) / 2;\\n                if (target < letters[mid]) \\n                {\\n                    end = mid - 1;\\n                } \\n                else \\n                {\\n                    start= mid + 1;\\n                }\\n        }\\n    return letters[start%letters.length];    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749478,
                "title": "implementation-binary-search-2-methods",
                "content": "[More such problems on Binary-search](https://github.com/Glorycs29/Binary_Search/tree/main)\\n\\n# Method 1\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int low=0, high=letters.size()-1;\\n        while(low<=high){\\n            int mid = low + ((high-low)>>1);\\n            if(letters[mid]>target){\\n                high = mid-1;\\n            }else{\\n                low = mid+1;\\n            }\\n        }\\n        return low==letters.size()? letters[0] : letters[low];\\n    }\\n};\\n```\\n# Method 2\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        //int num = target-\\'0\\';\\n        auto idx = upper_bound(letters.begin(), letters.end(), target);\\n        return idx == letters.end() ? letters[0] : *idx;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int low=0, high=letters.size()-1;\\n        while(low<=high){\\n            int mid = low + ((high-low)>>1);\\n            if(letters[mid]>target){\\n                high = mid-1;\\n            }else{\\n                low = mid+1;\\n            }\\n        }\\n        return low==letters.size()? letters[0] : letters[low];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        //int num = target-\\'0\\';\\n        auto idx = upper_bound(letters.begin(), letters.end(), target);\\n        return idx == letters.end() ? letters[0] : *idx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681202,
                "title": "100-beats-java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public char nextGreatestLetter(char[] arr, char target) {\\n          int start = 0;\\n        int end = arr.length-1;\\n    if(target >= arr[end]){\\n        return arr[0];\\n    }\\n        while(start<=end){\\n            int mid = start+(end-start)/2;\\n            if(target>=arr[mid]){\\n                start = mid+1;\\n            }\\n            else{\\n                end = mid-1;\\n            }\\n        }\\n\\n       return arr[start];\\n    }\\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public char nextGreatestLetter(char[] arr, char target) {\\n          int start = 0;\\n        int end = arr.length-1;\\n    if(target >= arr[end]){\\n        return arr[0];\\n    }\\n        while(start<=end){\\n            int mid = start+(end-start)/2;\\n            if(target>=arr[mid]){\\n                start = mid+1;\\n            }\\n            else{\\n                end = mid-1;\\n            }\\n        }\\n\\n       return arr[start];\\n    }\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634750,
                "title": "simple-easy-0-ms-binary-search-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUpon reading the FIRST line of the question, one should immediately realise that this is a BINARY SEARCH question. The key part is the array being lexographically sorted.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe simply implement classic binary search on this array while keeping position as the returning value which holds the index where the next greatest letter should be inserted in the sorted vector.\\n\\nIf the middle element > target, it means the next greatest letter should be present in the left half of the search range. Thus, position is updated to store the current middle index search is narrowed down.\\n\\nIf the middle element is not greater than the target, it means the next greatest letter should be present in the right half of the search range. Again, narrowing down the search area\\n\\nWe check if the returned index is equal to the size of the vector (letters.size()), which would mean that the target character is greater than or equal to all the letters in the vector. In such a case, the first letter (letters[0]) is returned as the next greatest letter. Otherwise, it returns the letter at the obtained index.\\n\\n# Complexity\\n- Time complexity: O( log(n) )\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binarySearch(vector<char>& letters, char target) {\\n        int n = letters.size();\\n        int l = 0, r = n-1;\\n        int position = n;\\n                                                \\n        while(l <= r) {\\n            int mid = l + (r-l)/2;\\n            if(letters[mid] > target) {\\n                position = mid;\\n                r = mid-1;\\n            } else {\\n                l = mid+1;\\n            }\\n        }\\n        return position;\\n    }\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int idx = binarySearch(letters, target);\\n        if(idx == letters.size())\\n            return letters[0];\\n        return letters[idx];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binarySearch(vector<char>& letters, char target) {\\n        int n = letters.size();\\n        int l = 0, r = n-1;\\n        int position = n;\\n                                                \\n        while(l <= r) {\\n            int mid = l + (r-l)/2;\\n            if(letters[mid] > target) {\\n                position = mid;\\n                r = mid-1;\\n            } else {\\n                l = mid+1;\\n            }\\n        }\\n        return position;\\n    }\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int idx = binarySearch(letters, target);\\n        if(idx == letters.size())\\n            return letters[0];\\n        return letters[idx];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619522,
                "title": "dart-with-binary-search",
                "content": "class Solution {\\nString nextGreatestLetter(List<String> letters, String target) {\\n    int start=0;\\n    int end=letters.length-1;\\n     \\n       \\n      \\n    String ans=letters[0];\\n    while(start<=end){\\n        int med=((start+end)/2).floor();\\n        if(letters[med].compareTo(target)>0){\\n            ans=letters[med];\\n            end=med-1;\\n         }  \\n         else{\\n        start=med+1;\\n         }\\n      }\\n      return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "class Solution {\\nString nextGreatestLetter(List<String> letters, String target) {\\n    int start=0;\\n    int end=letters.length-1;\\n     \\n       \\n      \\n    String ans=letters[0];\\n    while(start<=end){\\n        int med=((start+end)/2).floor();\\n        if(letters[med].compareTo(target)>0){\\n            ans=letters[med];\\n            end=med-1;\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 3619207,
                "title": "pythonic-solution-binary-approach-o-logn-and-o-1",
                "content": "# Intuition\\n- What to return and How?\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Binary Search approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        left=0\\n        right=len(letters)-1\\n       \\n        while left<=right:\\n            mid=(left+right)//2\\n            if (letters[mid]<=target):\\n                left=mid+1\\n            else:\\n                right=mid-1\\n        return letters[0] if left==len(letters) else letters[left]\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "# Intuition\\n- What to return and How?\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Binary Search approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        left=0\\n        right=len(letters)-1\\n       \\n        while left<=right:\\n            mid=(left+right)//2\\n            if (letters[mid]<=target):\\n                left=mid+1\\n            else:\\n                right=mid-1\\n        return letters[0] if left==len(letters) else letters[left]\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 3618674,
                "title": "c-solution-using-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int s=0;\\n        int e=letters.size()-1;\\n\\n        int res=0;\\n\\n        while(s<=e){\\n\\n            int mid=s+(e-s)/2;\\n            if(letters[mid]==target)\\n            s=mid+1;\\n            else if(target>letters[mid])\\n            s=mid+1;\\n            else{\\n                res=mid;\\n                e=mid-1;\\n            }\\n        }\\n        return letters[res];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int s=0;\\n        int e=letters.size()-1;\\n\\n        int res=0;\\n\\n        while(s<=e){\\n\\n            int mid=s+(e-s)/2;\\n            if(letters[mid]==target)\\n            s=mid+1;\\n            else if(target>letters[mid])\\n            s=mid+1;\\n            else{\\n                res=mid;\\n                e=mid-1;\\n            }\\n        }\\n        return letters[res];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618224,
                "title": "python-binary-search-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\nThe approach behind this code is to take advantage of the fact that the input letters list is already sorted in alphabetical order. The binary search algorithm works by repeatedly dividing the search interval in half until the target element is found or the search interval is empty. In this implementation, the search interval is defined by two indices low and high, initially set to the first and last elements of the input list respectively.\\n\\nThe algorithm then computes the middle index mid and compares the target letter with the letter at the middle index. If the target letter is greater than or equal to the middle letter, it means that the smallest letter greater than the target must be located to the right of the middle index, so the left index low is updated to mid+1. Otherwise, the smallest letter greater than the target must be located to the left of the middle index, so the right index high is updated to mid.\\n\\nThe loop continues until the left index low is equal to the right index high, which indicates that the search interval has been reduced to a single element. Finally, the function returns the letter at the low index, which is the smallest letter in the list that is greater than the target letter.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBinary search works by repeatedly dividing the search interval in half until the target element is found or the search interval is empty. In this implementation, the search interval is defined by two indices low and high, initially set to the first and last elements of the input list respectively.\\n\\nThe algorithm then computes the middle index mid and compares the target value with the value at the middle index. If the target value is greater than the middle value, it means that the desired element must be located to the right of the middle index, so the left index low is updated to mid+1. Otherwise, if the target value is less than the middle value, the desired element must be located to the left of the middle index, so the right index high is updated to mid-1.\\n\\nThe loop repeats until the left index low is greater than the right index high, which indicates that the search interval has been reduced to an empty set and the target element is not present in the list. If the target element is found, the loop terminates when the left and right indices are equal, and the function returns the index of the target element.\\n\\n\\n# Complexity\\n- Time complexity:$$O(log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python3 []\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        letters_length = len(letters)\\n        low = 0\\n        high = letters_length - 1\\n        \\n        if target < letters[low] or target >= letters[high]:\\n            return letters[low]\\n\\n        while low <= high:\\n            middle =  (low + high) // 2\\n            candidate = letters[middle]\\n            \\n            if target < candidate: \\n                high = middle - 1\\n\\n            if target >= candidate :\\n                low = middle + 1\\n        \\n        return letters[low]\\n\\n```\\n```Python []\\nclass Solution(object):\\n    def nextGreatestLetter(self, letters, target):\\n        \"\"\"\\n        :type letters: List[str]\\n        :type target: str\\n        :rtype: str\\n        \"\"\"\\n        \\n        # if the number is out of bound\\n        if target >= letters[-1] or target < letters[0]:\\n            return letters[0]\\n        \\n        low = 0\\n        high = len(letters)-1\\n        while low < high:\\n            mid = (high+low)//2\\n            \\n            if  target >= letters[mid]: #In binary search only >\\n                low = mid+1\\n            \\n            if target < letters[mid]:\\n                high = mid\\n                \\n        return letters[low]\\n\\n```\\n\\n\\n\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/6261946d-88d3-4c02-b8c5-8e620f2ef755_1686315757.6793537.png)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        letters_length = len(letters)\\n        low = 0\\n        high = letters_length - 1\\n        \\n        if target < letters[low] or target >= letters[high]:\\n            return letters[low]\\n\\n        while low <= high:\\n            middle =  (low + high) // 2\\n            candidate = letters[middle]\\n            \\n            if target < candidate: \\n                high = middle - 1\\n\\n            if target >= candidate :\\n                low = middle + 1\\n        \\n        return letters[low]\\n\\n```\n```Python []\\nclass Solution(object):\\n    def nextGreatestLetter(self, letters, target):\\n        \"\"\"\\n        :type letters: List[str]\\n        :type target: str\\n        :rtype: str\\n        \"\"\"\\n        \\n        # if the number is out of bound\\n        if target >= letters[-1] or target < letters[0]:\\n            return letters[0]\\n        \\n        low = 0\\n        high = len(letters)-1\\n        while low < high:\\n            mid = (high+low)//2\\n            \\n            if  target >= letters[mid]: #In binary search only >\\n                low = mid+1\\n            \\n            if target < letters[mid]:\\n                high = mid\\n                \\n        return letters[low]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617716,
                "title": "easy-c-solution-o-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        for(int i=0;i<letters.size();i++){\\n            if(letters[i]>target){\\n                return letters[i];\\n            }\\n        }\\n        return letters[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        for(int i=0;i<letters.size();i++){\\n            if(letters[i]>target){\\n                return letters[i];\\n            }\\n        }\\n        return letters[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617597,
                "title": "c-with-binary-search-easy",
                "content": "# Complexity\\n- Time complexity: O(Log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        if (letters[0] > target || target > letters[letters.size() - 1])\\n            return letters[0];\\n        \\n        char res = letters[0];\\n        \\n        int left = 0;\\n        int right = letters.size() - 1;\\n        int middle = (left + right) / 2;\\n        \\n\\n        while (left <=  right) {\\n            if (letters[middle] > target) {\\n                res = letters[middle];\\n                right = middle - 1;\\n            }\\n            else {\\n                left = middle + 1;\\n            }\\n            \\n            middle = (left + right) / 2;\\n        }\\n\\n        return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        if (letters[0] > target || target > letters[letters.size() - 1])\\n            return letters[0];\\n        \\n        char res = letters[0];\\n        \\n        int left = 0;\\n        int right = letters.size() - 1;\\n        int middle = (left + right) / 2;\\n        \\n\\n        while (left <=  right) {\\n            if (letters[middle] > target) {\\n                res = letters[middle];\\n                right = middle - 1;\\n            }\\n            else {\\n                left = middle + 1;\\n            }\\n            \\n            middle = (left + right) / 2;\\n        }\\n\\n        return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617405,
                "title": "linear-search-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBrute force approach\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        char ans=letters[0];\\n        for(int i=0;i<letters.size();i++){\\n            if(letters[i] > target){\\n                ans = letters[i];\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        char ans=letters[0];\\n        for(int i=0;i<letters.size();i++){\\n            if(letters[i] > target){\\n                ans = letters[i];\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617012,
                "title": "python-elegant-short-o-log-n-bisect",
                "content": "# Complexity\\n- Time complexity: $$O(\\\\log_2 {n})$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        return letters[bisect(letters, target) % len(letters)]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        return letters[bisect(letters, target) % len(letters)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616808,
                "title": "c-just-find-the-upper-bound",
                "content": "# Approach\\nJust Find the **UPPER_BOUND** which finds the value that is just greater than the target.\\nIf not found then return the first element.\\n\\n# Complexity\\n- Time complexity:\\nO(logn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        auto it = upper_bound(letters.begin(),letters.end(),target);\\n        return it!=letters.end() ?*it:letters[0];\\n    }\\n};\\n```\\n**Please Upvote if you like it.**",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        auto it = upper_bound(letters.begin(),letters.end(),target);\\n        return it!=letters.end() ?*it:letters[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616514,
                "title": "java-solution-for-find-smallest-letter-greater-than-target-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given array letters is sorted in non-decreasing order. We are asked to find the smallest character that is lexicographically greater than the target character. Since the array is sorted, we can utilize the property of a sorted array to optimize our search for the next greatest character.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in the solution is binary search. We initialize two pointers, left and right, to the start and end of the letters array, respectively. Then, we perform a binary search to find the desired character.\\n\\n1. Initialize left to 0 and right to letters.length - 1.\\n1. While left is less than or equal to right, repeat steps 3-5.\\n1. Calculate the middle index mid as left + (right - left) / 2.\\n1. Compare the character at letters[mid] with the target character:\\n- If letters[mid] is less than or equal to the target, update left to mid + 1 (since the desired character should be to the right of mid).\\n- If letters[mid] is greater than the target, update right to mid - 1 (since the desired character should be at mid or to the left of it).\\n5. Repeat steps 2-4 until left becomes greater than right.\\n6. If left is less than letters.length, return letters[left] (smallest character greater than the target); otherwise, return letters[0] (the first character in the array).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the binary search algorithm is O(log n), where n is the length of the letters array. Since we are performing binary search on the array, the number of comparisons reduces by half at each step. Therefore, the time complexity of the solution is O(log n).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution is O(1) because we are using a constant amount of extra space to store the left, right, and mid variables. The space required does not depend on the size of the input array.\\n\\n# Code\\n```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        int left = 0;\\n        int right = letters.length - 1;\\n    \\n        while (left <= right) \\n        {\\n            int mid = left + (right - left) / 2;\\n        \\n            if (letters[mid] <= target) \\n            {\\n                left = mid + 1;\\n            } \\n            else \\n            {\\n                right = mid - 1;\\n            }\\n        }\\n        return (left < letters.length) ? letters[left] : letters[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        int left = 0;\\n        int right = letters.length - 1;\\n    \\n        while (left <= right) \\n        {\\n            int mid = left + (right - left) / 2;\\n        \\n            if (letters[mid] <= target) \\n            {\\n                left = mid + 1;\\n            } \\n            else \\n            {\\n                right = mid - 1;\\n            }\\n        }\\n        return (left < letters.length) ? letters[left] : letters[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616311,
                "title": "python-short-and-clean-binary-search",
                "content": "# Complexity\\n- Time complexity: $$O(log(n))$$\\n\\n- Space complexity: $$O(1)$$\\n\\nwhere, `n is number of elements in letters.`\\n\\n# Code\\nWith library functions:\\n```python\\nclass Solution:\\n    def nextGreatestLetter(self, letters: list[str], target: str) -> str:\\n        return letters[bisect_right(letters, target) % len(letters)]\\n\\n\\n```\\n\\nWithout library functions:\\n```python\\nclass Solution:\\n    def nextGreatestLetter(self, letters: list[str], target: str) -> str:\\n        n = len(letters)\\n        l, r = 0, n - 1\\n        while l <= r:\\n            m = (l + r) // 2\\n            l, r = (m + 1, r) if letters[m] <= target else (l, m - 1)\\n        return letters[l % n]\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```python\\nclass Solution:\\n    def nextGreatestLetter(self, letters: list[str], target: str) -> str:\\n        return letters[bisect_right(letters, target) % len(letters)]\\n\\n\\n```\n```python\\nclass Solution:\\n    def nextGreatestLetter(self, letters: list[str], target: str) -> str:\\n        n = len(letters)\\n        l, r = 0, n - 1\\n        while l <= r:\\n            m = (l + r) // 2\\n            l, r = (m + 1, r) if letters[m] <= target else (l, m - 1)\\n        return letters[l % n]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616266,
                "title": "simple-bruteforce-approach-c-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStart!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Make a set to store the difference between the target and the each element of the vector.\\n- First check if the letter is in last of array it has no greater char so return letter[0];\\n- Now compare each element of vector to target only if greater than itself (diff must be of next char not previous);\\n- If char found in vector then return next to it.\\n- Otherwire set is in accending order its first element is always the **min difference** so thats the answer [difference between next and target is always the shortest];\\n- DONE!!\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(Nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        set<int>jat;\\n        if(letters[letters.size()-1]<=target)\\n        {\\n            return letters[0];\\n        }\\n        for(int i=0;i<letters.size();i++)\\n        {\\n            if(letters[i]>target){\\n            int temp=letters[i]-target;\\n            if(temp==0)\\n            {\\n                return letters[i+1];\\n            }\\n            jat.insert(temp);}\\n        }\\n        return target+*jat.begin();\\n\\n\\n\\n        \\n    }\\n};\\n```\\n![7abc56.jpg](https://assets.leetcode.com/users/images/1d61acfc-4df2-4e75-a7bf-26c1fa0a2745_1686285268.0052047.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        set<int>jat;\\n        if(letters[letters.size()-1]<=target)\\n        {\\n            return letters[0];\\n        }\\n        for(int i=0;i<letters.size();i++)\\n        {\\n            if(letters[i]>target){\\n            int temp=letters[i]-target;\\n            if(temp==0)\\n            {\\n                return letters[i+1];\\n            }\\n            jat.insert(temp);}\\n        }\\n        return target+*jat.begin();\\n\\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616156,
                "title": "best-and-easy-comparsion-approach-c",
                "content": "# Intuition and Approach\\nWe are just using simple comparsion between elements to get to the result \\nWe can also go with Binary search to get better time complexity.\\n**PS. Check code for better explanation**\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& l, char target) {\\n    // Initialize ans value to first letter as given in question \\n    //  it will be our alternate solution    \\n    char ans=l[0];\\n\\n        //create a diff int to check difference between two char\\n        //difference show how much far one char is to another char\\n        int diff=INT_MAX;//set it to max as we dont know the diff yet so any diff will always be less than it in start\\n\\n        for(int i=0;i<l.size();i++){\\n            //calulating difference between for every char in letter vector to given target\\n            int currdiff = (l[i]+\\'0\\')-(target+\\'0\\');\\n\\n            //if the letter is bigger then target we check then compare it \\n            // to the previous diff and if the currdiff is less than the \\n            //  diff then we update ans and diff value            \\n            if(l[i]>target and currdiff < diff){\\n                diff=currdiff;\\n                ans=l[i];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& l, char target) {\\n    // Initialize ans value to first letter as given in question \\n    //  it will be our alternate solution    \\n    char ans=l[0];\\n\\n        //create a diff int to check difference between two char\\n        //difference show how much far one char is to another char\\n        int diff=INT_MAX;//set it to max as we dont know the diff yet so any diff will always be less than it in start\\n\\n        for(int i=0;i<l.size();i++){\\n            //calulating difference between for every char in letter vector to given target\\n            int currdiff = (l[i]+\\'0\\')-(target+\\'0\\');\\n\\n            //if the letter is bigger then target we check then compare it \\n            // to the previous diff and if the currdiff is less than the \\n            //  diff then we update ans and diff value            \\n            if(l[i]>target and currdiff < diff){\\n                diff=currdiff;\\n                ans=l[i];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615988,
                "title": "c-easy-implementation-using-upper-bound",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char y) {\\n        set<char> s;\\n        for(auto x : letters) {\\n            s.insert(x);\\n        }\\n        auto it = s.upper_bound(y);\\n        if(it != s.end()) {\\n            return *it;\\n        }\\n\\n        else {\\n            return *s.begin();\\n        }        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char y) {\\n        set<char> s;\\n        for(auto x : letters) {\\n            s.insert(x);\\n        }\\n        auto it = s.upper_bound(y);\\n        if(it != s.end()) {\\n            return *it;\\n        }\\n\\n        else {\\n            return *s.begin();\\n        }        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615812,
                "title": "binary-search-c",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(logn)\\n\\n\\n- Space complexity:O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n    int left = 0;\\n    int right = letters.size() - 1;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (letters[mid] <= target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    return letters[left % letters.size()];\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n    int left = 0;\\n    int right = letters.size() - 1;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (letters[mid] <= target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    return letters[left % letters.size()];\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615777,
                "title": "simple-python-one-liner-using-bisect-right-binary-search",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        idx = bisect_right(letters, target)\\n        return letters[idx] if idx < len(letters) else letters[0]\\n```\\njust converted it into 1 line for fun heh\\n```\\nclass Solution:\\n    def nextGreatestLetter(self, L: List[str], T: str) -> str:\\n        return L[bisect_right(L, T)] if bisect_right(L, T) < len(L) else L[0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        idx = bisect_right(letters, target)\\n        return letters[idx] if idx < len(letters) else letters[0]\\n```\n```\\nclass Solution:\\n    def nextGreatestLetter(self, L: List[str], T: str) -> str:\\n        return L[bisect_right(L, T)] if bisect_right(L, T) < len(L) else L[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615629,
                "title": "c-easy-binary-search",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int ans=0,low=0,high=letters.size()-1;\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(letters[mid]==target){\\n                low=mid+1;\\n            }\\n            else if(target>letters[mid]){\\n                low=mid+1;\\n            }\\n            else {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n        }\\n        return letters[ans];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int ans=0,low=0,high=letters.size()-1;\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(letters[mid]==target){\\n                low=mid+1;\\n            }\\n            else if(target>letters[mid]){\\n                low=mid+1;\\n            }\\n            else {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n        }\\n        return letters[ans];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478147,
                "title": "find-smallest-letter-greater-than-target-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int i=0;\\n        if(letters[letters.size()-1]<=target)\\n            return letters[0];\\n        for(i=0 ; i<letters.size() ; i++)\\n        {\\n            if(letters[i]>target)\\n            {\\n                return letters[i];\\n            }\\n        }\\n        return letters[i-1];\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/22158102-f309-4f79-8dd4-3181701b039f_1683040350.107574.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int i=0;\\n        if(letters[letters.size()-1]<=target)\\n            return letters[0];\\n        for(i=0 ; i<letters.size() ; i++)\\n        {\\n            if(letters[i]>target)\\n            {\\n                return letters[i];\\n            }\\n        }\\n        return letters[i-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453824,
                "title": "beats-100-easy-java-solution-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        int l=0,h=letters.length-1;\\n        char ans=letters[0];\\n        while(l<=h)\\n        {\\n            int mid=l+(h-l)/2;\\n            if(letters[mid]==target  || target>letters[mid])\\n                l=mid+1;\\n            else if(letters[mid]>target)\\n            {\\n                ans=letters[mid];\\n                h=mid-1;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        int l=0,h=letters.length-1;\\n        char ans=letters[0];\\n        while(l<=h)\\n        {\\n            int mid=l+(h-l)/2;\\n            if(letters[mid]==target  || target>letters[mid])\\n                l=mid+1;\\n            else if(letters[mid]>target)\\n            {\\n                ans=letters[mid];\\n                h=mid-1;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435097,
                "title": "simple-and-best-solution-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public char nextGreatestLetter(char[] arr, char t) {\\n        if(t==\\'z\\')return arr[0];\\n        HashMap<Character, Integer> map = new HashMap<>();\\n        for(int i=0; i<arr.length; i++)map.put(arr[i],1);\\n        for(char i=t; i<=\\'z\\'; i++){\\n            if(map.containsKey(i) && i!=t)return i;\\n            if(i==\\'z\\')i=\\'a\\';\\n        }\\n        return arr[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public char nextGreatestLetter(char[] arr, char t) {\\n        if(t==\\'z\\')return arr[0];\\n        HashMap<Character, Integer> map = new HashMap<>();\\n        for(int i=0; i<arr.length; i++)map.put(arr[i],1);\\n        for(char i=t; i<=\\'z\\'; i++){\\n            if(map.containsKey(i) && i!=t)return i;\\n            if(i==\\'z\\')i=\\'a\\';\\n        }\\n        return arr[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357087,
                "title": "java-0-ms-intuitive-approach-with-beats-100-without-bs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> \\nThe problem asks to find the next greatest letter in an array of characters \\'letters\\' with respect to a given character \\'tar\\'. One way to solve this problem is to compare each character of the array with the target character and find the next greatest letter.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe trick here is to understand that the given array is sorted.\\nWe can loop through the array and compare each character with the target character \\'tar\\' by subtracting their ASCII values. If the result is greater than zero, then the current character is the next greatest character and is returned. If no such character is found, then the first character of the array is returned. \\n# Complexity\\n- Time complexity:  The time complexity of this approach is O(n), where n is the number of characters in the array \\'letters\\'. This is because we are iterating through the entire array to find the next greatest letter. \\n\\n- Space complexity:The space complexity of this approach is O(1), as we are not using any extra space.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char tar) {\\n        for(char c:letters){\\n            if(c-tar >0){\\n                return c;\\n            }\\n        }\\n        return letters[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char tar) {\\n        for(char c:letters){\\n            if(c-tar >0){\\n                return c;\\n            }\\n        }\\n        return letters[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3352115,
                "title": "c-17ms-beats-55",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int low = 0;\\n        int high = letters.size()-1;\\n        if(letters[letters.size()-1] <= target){\\n                return letters[0];\\n            }\\n        while(low <= high){\\n            int mid = low +(high-low)/2;\\n            if(letters[mid] <= target){\\n                low = mid +1;\\n            }else{\\n                high = mid-1;\\n            }\\n\\n        }\\n    return letters[high+1];}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int low = 0;\\n        int high = letters.size()-1;\\n        if(letters[letters.size()-1] <= target){\\n                return letters[0];\\n            }\\n        while(low <= high){\\n            int mid = low +(high-low)/2;\\n            if(letters[mid] <= target){\\n                low = mid +1;\\n            }else{\\n                high = mid-1;\\n            }\\n\\n        }\\n    return letters[high+1];}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3336829,
                "title": "100-faster-binary-search-beginner-friendly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince the given  char array is sorted therefore we can apply Binary Search.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere can be 2 cases:-\\n1. The target is present  in the array\\n   Since an element can ocur more thanonce in the array so as soon as    we find a match we will set the Start to mid+1 to find if that elemnent is repeated,if yes the we will store its index.We will return its element at next index.If its at last index then 0th index\\'s element is returned.\\n2. when the element is not present\\n    If the element is not present then after the traversal of array the start will store the value of the index of the smallest  charcater  gretaer than the target.so return start.\\n\\nPLEASE UPVOTE :)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target)\\n     {\\n        int s=0,e=letters.length-1,m,flg=0,ans=0;\\n        \\n        while(s<=e){\\n            m=s+(e-s)/2;\\n            if(target==letters[m])\\n            {  \\n                flg=0;\\n                ans=m;\\n                s=m+1;\\n             }\\n            else if(target<letters[m])\\n            {\\n                e=m-1;\\n             }\\n            else{\\n                s=m+1;\\n            }\\n\\n        }\\n        if(flg==1)\\n             return letters[(ans+1)%letters.length];\\n        else   \\n             return letters[s%letters.length];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target)\\n     {\\n        int s=0,e=letters.length-1,m,flg=0,ans=0;\\n        \\n        while(s<=e){\\n            m=s+(e-s)/2;\\n            if(target==letters[m])\\n            {  \\n                flg=0;\\n                ans=m;\\n                s=m+1;\\n             }\\n            else if(target<letters[m])\\n            {\\n                e=m-1;\\n             }\\n            else{\\n                s=m+1;\\n            }\\n\\n        }\\n        if(flg==1)\\n             return letters[(ans+1)%letters.length];\\n        else   \\n             return letters[s%letters.length];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3285693,
                "title": "awesome-4-line-code-in-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        y=bisect.bisect_right(letters,target)\\n        if y>=len(letters):\\n            return letters[0]\\n        else:\\n            return letters[y]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        y=bisect.bisect_right(letters,target)\\n        if y>=len(letters):\\n            return letters[0]\\n        else:\\n            return letters[y]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3277905,
                "title": "c-simple-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& v, char target) {\\n        int n = v.size();\\n        for(int i = 0 ; i < n ; i++)\\n            if(v[i]>target)\\n                return v[i];\\n        return v[0];\\n        }\\n    code by OK!\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& v, char target) {\\n        int n = v.size();\\n        for(int i = 0 ; i < n ; i++)\\n            if(v[i]>target)\\n                return v[i];\\n        return v[0];\\n        }\\n    code by OK!\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224954,
                "title": "c-solution-easy-understanding-using-hashed-array-brute-force",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Store the frequencies of the letters in an array of `size 26` storing frequencies of all the letters\\n> \\'a\\' corresponds to 0th index \\n\\'b\\' corresponds to 1st \\n\\'c\\' corresponds to 2nd\\n.....\\n....\\n...\\n..\\n.\\n\\'z\\' corresponds to 25th index\\n\\n2. Find the index where the target character will be stored\\nThis index is stored in variable `val`\\n\\n3. Iterate through the array and *find the first element whose index is greater than val and the frequency stored in it is greater than 0.*\\n4. Convert this index to the character it represents\\n`-> Return this element. `\\n\\n5. If no such element is found in the array then\\n`-> Return the first element of the letters vector. `\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(26) == O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int arr[26] = {0} ;\\n        char ans ; \\n        for (int i = 0 ; i < letters.size() ; i ++)\\n        {\\n            int num = letters[i] - \\'a\\';\\n            arr[num] ++ ;\\n        } \\n        int val = target - \\'a\\' ; \\n        for (int i = 0 ; i < 26 ; i ++)\\n        {\\n            if (i > val && arr[i] != 0)\\n            {\\n                ans = i + \\'a\\' ;\\n                return ans ; \\n            }\\n        }\\n        return letters[0] ; \\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/4f73238a-7fe9-4c50-b0fc-0b8122fd0d26_1677239085.6653605.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int arr[26] = {0} ;\\n        char ans ; \\n        for (int i = 0 ; i < letters.size() ; i ++)\\n        {\\n            int num = letters[i] - \\'a\\';\\n            arr[num] ++ ;\\n        } \\n        int val = target - \\'a\\' ; \\n        for (int i = 0 ; i < 26 ; i ++)\\n        {\\n            if (i > val && arr[i] != 0)\\n            {\\n                ans = i + \\'a\\' ;\\n                return ans ; \\n            }\\n        }\\n        return letters[0] ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206992,
                "title": "beats-98-of-python-solutions-with-using-bisect",
                "content": "Upvote if you like it \\uD83D\\uDC4D\\n```\\nfrom bisect import bisect\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        try:\\n            return letters[bisect(letters,target)]\\n        except:\\n            return letters[0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom bisect import bisect\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        try:\\n            return letters[bisect(letters,target)]\\n        except:\\n            return letters[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201151,
                "title": "c-accepted-easy-to-understand",
                "content": "```\\npublic class Solution {\\n    public char NextGreatestLetter(char[] letters, char target) {\\n        int l=0,r=letters.Length-1,m;\\n        while(l<=r){\\n            m=l+(r-l)/2;\\n            if(letters[m]-\\'0\\'>target-\\'0\\')\\n                r=m-1;\\n            else{\\n                l=m+1;\\n            }\\n        }\\n        if(l>=letters.Length) l = 0;\\n        return letters[l];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public char NextGreatestLetter(char[] letters, char target) {\\n        int l=0,r=letters.Length-1,m;\\n        while(l<=r){\\n            m=l+(r-l)/2;\\n            if(letters[m]-\\'0\\'>target-\\'0\\')\\n                r=m-1;\\n            else{\\n                l=m+1;\\n            }\\n        }\\n        if(l>=letters.Length) l = 0;\\n        return letters[l];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3190892,
                "title": "c-one-liner-best-solution-for-this-problem",
                "content": "please upvote if you think i worked hard to make this solution come in one line ^_^\\n```\\nchar nextGreatestLetter(vector<char>& letters, char target) {\\n    return letters[(upper_bound(letters.begin(), letters.end(), target) - letters.begin()) % letters.size()];\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "please upvote if you think i worked hard to make this solution come in one line ^_^\\n```\\nchar nextGreatestLetter(vector<char>& letters, char target) {\\n    return letters[(upper_bound(letters.begin(), letters.end(), target) - letters.begin()) % letters.size()];\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 3141373,
                "title": "beginner-friendly-binary-search-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Go for traditional `Binary Search` \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Here we need to find the `char` which is is `lexicographically` greater than `target` \\n- `lexicography` is a simple increasing order of `char` or `numbers` etc.\\n- Here it is predefined in question that if no char is found just return the `start` char, so we will initialize `char ans = letters[0]`\\n- Now apply the simple `binary approach` initialize `mid` inside `while` loop\\n- If the `target` is less than the `mid` than `ans = letters[mid]` (visualise this by using any static example)\\n- Now for `target >= mid` we will simplly update `start = mid + 1`\\n- Finally return the `ans`\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n`O(n)`\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        \\n        char ans = letters[0];\\n        int start = 0;\\n        int end = letters.length - 1;\\n\\n        while(start <= end){\\n            int mid = start + (end - start) / 2;\\n\\n            if(target < letters[mid]){\\n                ans = letters[mid];\\n                end = mid - 1;\\n            }\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n- `Please UpVote The Answer if You understood it` `,` \\n- `If not please Comment And Let Me Know , So that I can Help You Out.` \\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        \\n        char ans = letters[0];\\n        int start = 0;\\n        int end = letters.length - 1;\\n\\n        while(start <= end){\\n            int mid = start + (end - start) / 2;\\n\\n            if(target < letters[mid]){\\n                ans = letters[mid];\\n                end = mid - 1;\\n            }\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3073196,
                "title": "java-easy-solution-beats-100-0ms-runtime",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n# Please upvote if you like the code.\\n# Complexity\\n- Time complexity: O(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        // initialised starting and ending variables\\n        int start = 0, end = letters.length-1; \\n        \\n        // loop for iterations\\n        while(start<=end){\\n            // using Binary search So.\\n            int mid = start + (end - start)/2;// getting mid value of that array\\n            // Now we have to get the element just greater then the target character so if mid value of letters array is greater then targer means closest greater char is on left side. so we dercrement end pointer and set to mid-1\\n            if(letters[mid]>target){\\n                end = mid - 1;\\n            }\\n            // if target is bigger than the letters[mid] value then our closest greater number is on right side of an array. so increment the starting pointer to right.\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        // at last we focus on starting pointer as we are increment it mid+1 so we take modulus of start pointer with the length of letters array. It give the poistion of that character and return that element from letters array letters[position_of_closest_greater_number]\\n        return letters[start % letters.length];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        // initialised starting and ending variables\\n        int start = 0, end = letters.length-1; \\n        \\n        // loop for iterations\\n        while(start<=end){\\n            // using Binary search So.\\n            int mid = start + (end - start)/2;// getting mid value of that array\\n            // Now we have to get the element just greater then the target character so if mid value of letters array is greater then targer means closest greater char is on left side. so we dercrement end pointer and set to mid-1\\n            if(letters[mid]>target){\\n                end = mid - 1;\\n            }\\n            // if target is bigger than the letters[mid] value then our closest greater number is on right side of an array. so increment the starting pointer to right.\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        // at last we focus on starting pointer as we are increment it mid+1 so we take modulus of start pointer with the length of letters array. It give the poistion of that character and return that element from letters array letters[position_of_closest_greater_number]\\n        return letters[start % letters.length];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066574,
                "title": "c-100-easy-solution-in-two-different-ways-binary-search-simple-loop",
                "content": "# Intuition\\nThis Problem Can be Solved in Two ways\\n##  1. Binary Search || Time Complexity O(logn)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int len = letters.size();\\n        int l = 0,h = len-1,m;\\n        while(l <= h){\\n            m = l + (h-l)/2;\\n            if(letters[m]>target)\\n                h = m - 1;\\n            else\\n                l = m + 1;\\n        }\\n        return letters[l % len];\\n    }\\n};\\n```\\n\\n## 2. Simple For Loop and Comparing with Target and Current Character || Time Complexity O(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        char local_medium =\\'z\\';\\n        bool flag = false;\\n        for(int i=0;i<letters.size();i++){\\n            if(letters[i]>target and letters[i]<=local_medium){\\n                local_medium = letters[i];\\n                flag = true;\\n            }\\n        }\\n        return flag?local_medium:letters[0];\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int len = letters.size();\\n        int l = 0,h = len-1,m;\\n        while(l <= h){\\n            m = l + (h-l)/2;\\n            if(letters[m]>target)\\n                h = m - 1;\\n            else\\n                l = m + 1;\\n        }\\n        return letters[l % len];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        char local_medium =\\'z\\';\\n        bool flag = false;\\n        for(int i=0;i<letters.size();i++){\\n            if(letters[i]>target and letters[i]<=local_medium){\\n                local_medium = letters[i];\\n                flag = true;\\n            }\\n        }\\n        return flag?local_medium:letters[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3062009,
                "title": "best-java-solution-binary-search-approach-0-ms",
                "content": "# Code\\n```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) \\n    {\\n        int start = 0;\\n        int end = letters.length-1;\\n    \\n        while (start <= end) \\n        {\\n            int mid = start + (end - start) / 2;\\n\\n            if (target < letters[mid]) {\\n                end = mid - 1;\\n            }\\n\\n            else {\\n                start = mid + 1;\\n            }\\n        }\\n        return letters[start % letters.length];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) \\n    {\\n        int start = 0;\\n        int end = letters.length-1;\\n    \\n        while (start <= end) \\n        {\\n            int mid = start + (end - start) / 2;\\n\\n            if (target < letters[mid]) {\\n                end = mid - 1;\\n            }\\n\\n            else {\\n                start = mid + 1;\\n            }\\n        }\\n        return letters[start % letters.length];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2940714,
                "title": "java-using-binary-search-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt first I thought I can do it using iteration and then I thought about the time complexity and decided to go for another approach\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI used binary search\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        int low=0,high=letters.length-1;\\n        if(letters[high]<=target){\\n            return letters[low];\\n        }\\n        while(low<high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(letters[mid]>target){\\n                high=mid;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return letters[low];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        int low=0,high=letters.length-1;\\n        if(letters[high]<=target){\\n            return letters[low];\\n        }\\n        while(low<high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(letters[mid]>target){\\n                high=mid;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return letters[low];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2904138,
                "title": "easy-c-solution-using-binary-search",
                "content": "## Code\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int low= 0; int high= letters.size()-1;\\n        while (low<= high){\\n            int mid= low+ (high-low)/2;\\n            if (letters[mid]<= target){\\n                low= mid+1;\\n            }\\n            else{\\n                high= mid-1;\\n            }\\n        }\\n        if (low>= letters.size())return letters[0];\\n        return letters[low];\\n    }\\n};\\n```\\n## Complexity\\n- Time complexity: O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int low= 0; int high= letters.size()-1;\\n        while (low<= high){\\n            int mid= low+ (high-low)/2;\\n            if (letters[mid]<= target){\\n                low= mid+1;\\n            }\\n            else{\\n                high= mid-1;\\n            }\\n        }\\n        if (low>= letters.size())return letters[0];\\n        return letters[low];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885318,
                "title": "python-94-35-faster-binary-search-o-n-solution",
                "content": "```\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        if target >= letters[-1] or target < letters[0]:\\n            return letters[0]\\n        l=0\\n        h=len(letters)-1\\n        ans=letters[0]\\n        while l<=h:\\n            m=(l+h)>>1\\n            if letters[m]<=target:\\n                l=m+1\\n            else:\\n                ans=letters[m]\\n                h=m-1\\n        return ans\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        if target >= letters[-1] or target < letters[0]:\\n            return letters[0]\\n        l=0\\n        h=len(letters)-1\\n        ans=letters[0]\\n        while l<=h:\\n            m=(l+h)>>1\\n            if letters[m]<=target:\\n                l=m+1\\n            else:\\n                ans=letters[m]\\n                h=m-1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2874501,
                "title": "java-2-easy-and-fast-solutions",
                "content": "BINARY SEARCH SOLUTION\\nTIME COMPLEXITY: O(log n)\\nSPACE COMPLEXITY: O(1)\\n```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        int l=0;\\n        int r=letters.length;\\n        while(l<r){\\n            int mid=l+(r-l)/2;\\n            if(letters[mid]<=target){\\n                l=mid+1;\\n            }\\n            else{\\n                r=mid;\\n            }\\n        }\\n        return letters[l%letters.length];\\n    }\\n}\\n```\\n\\n\\n\\nLINEAR SCAN SOLUTION\\nTIME COMPLEXITY: O(n)\\nSPACE COMPLEXITY:O(n)\\n```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        for(char c:letters){\\n            if(c>target){\\n                return c;\\n            }\\n        }\\n        return letters[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        int l=0;\\n        int r=letters.length;\\n        while(l<r){\\n            int mid=l+(r-l)/2;\\n            if(letters[mid]<=target){\\n                l=mid+1;\\n            }\\n            else{\\n                r=mid;\\n            }\\n        }\\n        return letters[l%letters.length];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        for(char c:letters){\\n            if(c>target){\\n                return c;\\n            }\\n        }\\n        return letters[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2839490,
                "title": "easy-clean-solution-c",
                "content": "```class Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int start = 0, end = letters.size()-1, mid = start +(end -start)/2;\\n        \\n        char a = letters[0];\\n        while(start<=end)\\n        {\\n               \\n              if(letters[mid] > target)\\n              {\\n                  a = letters[mid];\\n                  end = mid-1;\\n              }\\n              \\n              \\n            else\\n            {\\n                start = mid+1;\\n            } \\n            mid = start +(end -start)/2;\\n        }\\n        return a;\\n    }\\n\\n};\\n",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        int start = 0, end = letters.size()-1, mid = start +(end -start)/2;\\n        \\n        char a = letters[0];\\n        while(start<=end)\\n        {\\n               \\n              if(letters[mid] > target)\\n              {\\n                  a = letters[mid];\\n                  end = mid-1;\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 2838943,
                "title": "cpp-solution-simple-and-easy",
                "content": "class Solution {\\npublic:\\n    char nextGreatestLetter(vector<char\\\\>& letters, char target) {\\n        set<char\\\\>st;\\n        char ans=letters[0];\\n        for(auto i: letters)\\n        {\\n            st.insert(i);\\n        }\\n        for(auto i: st)\\n        {\\n            if(i>target)\\n            {\\n                ans=i;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    char nextGreatestLetter(vector<char\\\\>& letters, char target) {\\n        set<char\\\\>st;\\n        char ans=letters[0];\\n        for(auto i: letters)\\n        {\\n            st.insert(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2804633,
                "title": "applying-binary-search-to-find-smallest-letter-greater-than-target",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        int start=0;\\n        int end=letters.length-1;\\n        while(start<=end)\\n        {\\n           int mid=start+(end-start)/2;\\n            if(target<letters[mid])\\n            {\\n                \\n                 \\n                end=mid-1;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n             \\n                \\n            }\\n        }\\n        return letters[start%letters.length];\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        int start=0;\\n        int end=letters.length-1;\\n        while(start<=end)\\n        {\\n           int mid=start+(end-start)/2;\\n            if(target<letters[mid])\\n            {\\n                \\n                 \\n                end=mid-1;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n             \\n                \\n            }\\n        }\\n        return letters[start%letters.length];\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2797932,
                "title": "one-line-but-it-s-o-n",
                "content": "Note 1: The array is sorted so its easy if we search linearly in O(n)\\nNote2: Use Binary search as it\\'s O(logn) as its takes very very less time\\n\\n\\n```\\nfor(auto x: letters) if (x>target) return x;  return letters[0];\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nfor(auto x: letters) if (x>target) return x;  return letters[0];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2733050,
                "title": "simple-and-easy-c-solution",
                "content": "**class Solution {\\npublic:\\nchar nextGreatestLetter(vector& letters, char target) {\\nint n=letters.size();\\nfor(int i=0;i<n;i++){\\nif(letters[i]>target)\\n{ return letters[i];\\nbreak;\\n}\\n}\\nreturn letters[0];\\n}\\n};**",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\nchar nextGreatestLetter(vector& letters, char target) {\\nint n=letters.size();\\nfor(int i=0;i<n;i++){\\nif(letters[i]>target)\\n{ return letters[i];\\nbreak;\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2707793,
                "title": "find-smallest-letter-greater-than-target-python",
                "content": "I have this problem explained and solved on my channel , please check it out.\\nhttps://youtube.com/playlist?list=PLxukZCav2iGzzFMWq-esWbEEZ0KJ17t9L\\nalso please, give your valueable feedback.\\n```\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        if target<letters[0] or target>=letters[-1] :\\n            return letters[0]\\n        left=0\\n        right=len(letters)-1\\n        while left<=right :\\n            mid=(left+right)//2\\n            if target>=letters[mid]:\\n                left=mid+1\\n            if target<letters[mid] :\\n                right=mid-1\\n        return letters[left]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        if target<letters[0] or target>=letters[-1] :\\n            return letters[0]\\n        left=0\\n        right=len(letters)-1\\n        while left<=right :\\n            mid=(left+right)//2\\n            if target>=letters[mid]:\\n                left=mid+1\\n            if target<letters[mid] :\\n                right=mid-1\\n        return letters[left]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678457,
                "title": "short-javascript-solution",
                "content": "Found this solution helpful? Consider showing support by upvoting this post.\\nHave a question? Kindly leave a comment below.\\nThank you and happy hacking!\\n```\\nvar nextGreatestLetter = function (letters, target) {\\n    for (let i = 0; i < letters.length; i++) {\\n        if (letters[i].charCodeAt(0) > target.charCodeAt(0)) {\\n            return letters[i]\\n        }\\n    }\\n\\n    return letters[0]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar nextGreatestLetter = function (letters, target) {\\n    for (let i = 0; i < letters.length; i++) {\\n        if (letters[i].charCodeAt(0) > target.charCodeAt(0)) {\\n            return letters[i]\\n        }\\n    }\\n\\n    return letters[0]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2654541,
                "title": "c-easy-binary-search-2-lines-built-in-function-100-time",
                "content": "# **Statement of the Problem:**\\n\\nyou are given some sorted `letters` and you want to return the smallest letter that is greater than `target`\\n\\n# **Remark about upper_bound function:** \\n\\nthe built-in function `upper_bound(first iterator, last iterator, target)`\\n- is used to return the iterator of the smallest object greater than the `target`\\n- by dereferencing you will know the value of this iterator\\n- be careful, the objects which is used to search for must be sorted \\n- if the target not found the function will return the last iterator\\n\\n# **Explanination:**\\n\\nwhen you call the function for the target character it will return 2 possible things\\n\\n1. if there exist character that is the smallest one greater than the target, the function will return iterator points to this charcter\\n2. otherwise it will return last iterator, in this case we will wrap around for the first character in the `letters` vector which we can access it easily by `letters[0]`\\n\\n```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        auto it = upper_bound(letters.begin(), letters.end(), target);\\n        if (it == letters.end()) return letters[0];\\n        return *it;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n        auto it = upper_bound(letters.begin(), letters.end(), target);\\n        if (it == letters.end()) return letters[0];\\n        return *it;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2503734,
                "title": "javascript-easy-solution-with-ascii-100",
                "content": "```\\nvar nextGreatestLetter = function(letters, target) {\\n    for (let i = 0; i < letters.length; i++) {\\n        if (letters[i].charCodeAt(0) > target.charCodeAt(0)) return letters[i];\\n    }\\n    \\n    return letters[0];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar nextGreatestLetter = function(letters, target) {\\n    for (let i = 0; i < letters.length; i++) {\\n        if (letters[i].charCodeAt(0) > target.charCodeAt(0)) return letters[i];\\n    }\\n    \\n    return letters[0];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2427518,
                "title": "java-binary-search-0ms-100-faster-solution",
                "content": "```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n       int n = letters.length;\\n        int lo = 0, hi = n;\\n\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (letters[mid] > target) hi = mid;\\n            else lo = mid + 1;          \\n        }\\n \\n        return letters[lo % n]; \\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n       int n = letters.length;\\n        int lo = 0, hi = n;\\n\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (letters[mid] > target) hi = mid;\\n            else lo = mid + 1;          \\n        }\\n \\n        return letters[lo % n]; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401228,
                "title": "java-0ms-faster-than-100",
                "content": "```\\nint start = 0;\\n        int end = letters.length-1;\\n        char ans= letters[0];\\n        \\n        while(start <= end)\\n        {\\n            int mid = start + (end-start)/2;\\n            \\n            if(letters[mid] == target || target >= letters[mid])\\n                start = mid+1;\\n            \\n            else if(letters[mid] > target)\\n            {\\n                ans = letters[mid];\\n                end = mid-1;\\n            }   \\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nint start = 0;\\n        int end = letters.length-1;\\n        char ans= letters[0];\\n        \\n        while(start <= end)\\n        {\\n            int mid = start + (end-start)/2;\\n            \\n            if(letters[mid] == target || target >= letters[mid])\\n                start = mid+1;\\n            \\n            else if(letters[mid] > target)\\n            {\\n                ans = letters[mid];\\n                end = mid-1;\\n            }   \\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2321571,
                "title": "c-1-liner-o-n",
                "content": "```\\nchar nextGreatestLetter(vector<char>& chars, char ch) {\\n        for (int i = 0 ; i < chars.size() ; i++) if (ch < chars[i]) return chars[i];\\n        // return first char since letters wrap around\\n        return chars[0];\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar nextGreatestLetter(vector<char>& chars, char ch) {\\n        for (int i = 0 ; i < chars.size() ; i++) if (ch < chars[i]) return chars[i];\\n        // return first char since letters wrap around\\n        return chars[0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2224731,
                "title": "javascript-solution-simple-understandable-fast",
                "content": "```\\nfunction nextGreatestLetter(letters, target) {\\n    let alphabet = [\\n        \\'a\\', \\'b\\', \\'c\\',\\n        \\'d\\', \\'e\\', \\'f\\',\\n        \\'g\\', \\'h\\', \\'i\\',\\n        \\'j\\', \\'k\\', \\'l\\',\\n        \\'m\\', \\'n\\', \\'o\\',\\n        \\'p\\', \\'q\\', \\'r\\',\\n        \\'s\\', \\'t\\', \\'u\\',\\n        \\'v\\', \\'w\\', \\'x\\',\\n        \\'y\\', \\'z\\'\\n    ]\\n\\n    let index = alphabet.indexOf(target)\\n    var i = alphabet.indexOf(target) + 1\\n    while (i != index) {\\n        if (i==alphabet.length) i=0\\n        if (letters.includes(alphabet[i])) return alphabet[i]\\n        i++\\n    }\\n    return \\'a\\'\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction nextGreatestLetter(letters, target) {\\n    let alphabet = [\\n        \\'a\\', \\'b\\', \\'c\\',\\n        \\'d\\', \\'e\\', \\'f\\',\\n        \\'g\\', \\'h\\', \\'i\\',\\n        \\'j\\', \\'k\\', \\'l\\',\\n        \\'m\\', \\'n\\', \\'o\\',\\n        \\'p\\', \\'q\\', \\'r\\',\\n        \\'s\\', \\'t\\', \\'u\\',\\n        \\'v\\', \\'w\\', \\'x\\',\\n        \\'y\\', \\'z\\'\\n    ]\\n\\n    let index = alphabet.indexOf(target)\\n    var i = alphabet.indexOf(target) + 1\\n    while (i != index) {\\n        if (i==alphabet.length) i=0\\n        if (letters.includes(alphabet[i])) return alphabet[i]\\n        i++\\n    }\\n    return \\'a\\'\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2182781,
                "title": "easy-to-understand-self-explanatory-c",
                "content": "```\\nchar nextGreatestLetter(vector<char>& let, char target) {\\n        int l = 0, r = let.size(),m;\\n        while(l<r){\\n            m = l+(r-l)/2;\\n            if(let[m]<=target) l = m+1;\\n            else r = m;\\n        }\\n        if(r<let.size()) return let[r];\\n        return let[0];\\n    }\\n\\t\\n//If Someone could tell me when exactly do we do l<=r and when l<r in while condition that would be great....",
                "solutionTags": [
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nchar nextGreatestLetter(vector<char>& let, char target) {\\n        int l = 0, r = let.size(),m;\\n        while(l<r){\\n            m = l+(r-l)/2;\\n            if(let[m]<=target) l = m+1;\\n            else r = m;\\n        }\\n        if(r<let.size()) return let[r];\\n        return let[0];\\n    }\\n\\t\\n//If Someone could tell me when exactly do we do l<=r and when l<r in while condition that would be great....",
                "codeTag": "Unknown"
            },
            {
                "id": 2166087,
                "title": "o-n-python-solution",
                "content": "```\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        i = 0 \\n        while i < len(letters):\\n            if letters[i] > target:\\n                return letters[i]\\n            i+=1\\n        return letters[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        i = 0 \\n        while i < len(letters):\\n            if letters[i] > target:\\n                return letters[i]\\n            i+=1\\n        return letters[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2114882,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public char nextGreatestLetter(char[] l, char t) {\\n        int a[]=new int[26];\\n        for(char c:l)\\n        {\\n            a[c-\\'a\\']++;\\n        }\\n        for(int i=t-\\'a\\'+1;i<26;i++)\\n        {\\n            if(a[i]!=0)\\n            {\\n                return (char)(i+\\'a\\');\\n            }\\n        }\\n        for(int i=0;i<t-\\'a\\';i++)\\n        {\\n            if(a[i]!=0)\\n            {\\n                return (char)(i+\\'a\\');\\n            }\\n        }\\n        return \\' \\';\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public char nextGreatestLetter(char[] l, char t) {\\n        int a[]=new int[26];\\n        for(char c:l)\\n        {\\n            a[c-\\'a\\']++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2102273,
                "title": "c-simple-solution-find-smallest-letter-greater-than-target",
                "content": "char nextGreatestLetter(vector<char>& letters, char target) {\\n        \\n        for(int i=0;i<letters.size();i++){\\n            if(letters[i]>target){\\n                return letters[i];\\n            }\\n        }\\n        \\n        return letters[0];\\n    }\\n\\t\\n\\t// Up-Vote if you like \\n\\t// Thankyou",
                "solutionTags": [
                    "C++"
                ],
                "code": "char nextGreatestLetter(vector<char>& letters, char target) {\\n        \\n        for(int i=0;i<letters.size();i++){\\n            if(letters[i]>target){\\n                return letters[i];\\n            }\\n        }\\n        \\n        return letters[0];\\n    }\\n\\t\\n\\t// Up-Vote if you like \\n\\t// Thankyou",
                "codeTag": "Unknown"
            },
            {
                "id": 2096186,
                "title": "easy-to-understand-binary-search-100-faster",
                "content": "```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        int start = 0;\\n        int end = letters.length - 1;\\n\\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n\\n            if (target < letters[mid]) {\\n                end = mid - 1; // go left\\n            } else {\\n                start = mid + 1; // go right\\n            }\\n        }\\n        return letters[start % letters.length]; // return char greater than target &\\n\\t\\t                                        // incase target is not in array return first char\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        int start = 0;\\n        int end = letters.length - 1;\\n\\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n\\n            if (target < letters[mid]) {\\n                end = mid - 1; // go left\\n            } else {\\n                start = mid + 1; // go right\\n            }\\n        }\\n        return letters[start % letters.length]; // return char greater than target &\\n\\t\\t                                        // incase target is not in array return first char\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564640,
                "content": [
                    {
                        "username": "onebigsalmon",
                        "content": "\"find the smallest element in the list that is larger than the given target. Letters also wrap around.\"\\n\\nI read this 5 times and still didn\\'t understand. If my input is:\\n\\n[\"a\",\"z\"]\\ntarget: \"y\"\\n\\nThen \\'a\\' is returned due to the wrap around.\\n\\nBut if the input is:\\n\\n[\"c\",\"f\"]\\ntarget: \"d\"\\n\\nThen how come \"c\" is not returned? \"c\" is bigger than \"d\" with wrap around and it is smaller than \"f\" (which is supposed to be the right answer. How does this make sense?"
                    },
                    {
                        "username": "bingolive9104",
                        "content": "the correct ans is f because it mention in question that we have to return the value which is greater then target ..... but if target is at n-1 position then no other element exist greater then target if you do it will give out of bound error ... so now in your test case .. we implement the binary search and on that basis we identify that search failed ... because target is missing .. now our task is to cheack is there any value exisit in the given char array which is greater then target if yes then return it .. you can simply put a for loop ... (linear search)...."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "in this q if target is not present in letters , we have to handle 2 cases .\\n1) if there exists a value greater than target return it \\n2) if target is the largest value , return letters[0] .\\n\\nif target is present , we check\\n1) if any value greater than target , return it , else return letters[0] \\nhope this clears your query"
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "[@suresh_Hariharan](/suresh_Hariharan)  but he has provided the example -> [\"c\",\"f\"]\\ntarget: \"d\"\\nhere target is not the largest char present , so why f is not returned "
                    },
                    {
                        "username": "sureshHariharan",
                        "content": "if the target letter is the largest letter in the array (e.g if target is Z there is not greater char than Z ) , so you should return the char of the first Index of the array this is \"wrap around\""
                    },
                    {
                        "username": "RegexSage",
                        "content": "if u see ascii value of d and f , f is greater so f is being return as answer"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "The calm before the storm."
                    },
                    {
                        "username": "ryan2156",
                        "content": "At least got 50 points "
                    },
                    {
                        "username": "user7421CT",
                        "content": "[@Dhananjay40](/Dhananjay40)  the streak gonna end tomorrow lol\\n"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "tomorrow we probably gonna get destroyed T_T"
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "It should be highlighted that solving the problem with $$O(log(n))$$ time complexity is better for educational purposes. Way too easy with bruteforce."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Easiest question I have ever solved."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@tungbuivn](/tungbuivn) To learn binary search, there are many questions on leetcode in which they reject solutions with linear search. If they accept linear search I don\\'t think there is any problem with linear search. They didn\\'t mention any \"Follow-up\". That\\'s why I said it\\'s easiest, and it\\'s my opinion whether it is easy or not okay! I just gave feedback, please ignore if you are not liking it."
                    },
                    {
                        "username": "nishant101",
                        "content": "[@pun_yeeet](/pun_yeeet) Yeah \\uD83E\\uDD23"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "what does the easiest mean ? the key point here is who is having the best answer for the same question. here is two question\n1. have you try your best to solve problem ?\n2. does your solution is the best ?\n\nso prove your self is the best choice is some one must choose you or others. by your submited solution, this is chanlenge with you but you are refun it"
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@swati dubey](/swati_dubey) LeetCode is being lenient. this daily challange is giving us easy problem from the past few days. It\\'s gonna suddenly give us a Hard problem and then we\\'re screwd."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@RadecX1](/RadecX1) \\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "pun_yeeet",
                        "content": "I hope you tried it using Binary Search and not linear search\\n"
                    },
                    {
                        "username": "RadecX1",
                        "content": "Try this : https://leetcode.com/problems/add-two-integers/"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@gajendralenovo](/gajendralenovo) \\uD83D\\uDE05"
                    },
                    {
                        "username": "gajendralenovo",
                        "content": "that\\'s why it has 3k likes and 2k dislikes."
                    },
                    {
                        "username": "iffthen",
                        "content": "Soldiers be ready for Dp and graph.."
                    },
                    {
                        "username": "anwendeng",
                        "content": " In C++ upper_bound can find the least upper bound for sorted data!\nbisect_right has the same function in Python."
                    },
                    {
                        "username": "yipanhuasheng",
                        "content": "This question is not difficult, but I don\\'t understand its Chinese translation.What\\'s the meaning about \"Letters also wrap around. \"?Letters can be reused\\uFF1F"
                    },
                    {
                        "username": "UdhayaK",
                        "content": "It means that the values are bound only bound to the array values .\nExample: If we start from 1 and ends at 10 then it only starts from 1 to 10 ,just bound to the range [1,10]\nin such cases if we want to represent 11 in range [1,10] then use modulus 11%10==1 ,the answer for representing 11 in range [1,10] is 1.\nThe same trick in this question also just use modulus to solve the wrap around thing."
                    },
                    {
                        "username": "user9133ra",
                        "content": "in simple terms, abcd goes     abcd...xyzabcd...xyz indefinately i.e. after letter 'z', sequence starts from 'a' to 'z' and so on.. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "My linear search takes less time than my binary search \\uD83E\\uDD23\\n\\nLeetcode\\u2615"
                    },
                    {
                        "username": "Kaltu",
                        "content": "big O is only eventually true for large enough N. I guess for small N in an easy problem(2 <= letters.length <= 10^4), overheads for simple loop are easier to optimize than some branching logics binary search uses."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "The Question could have been framed better .\n\n### Just ask to return a  Ist letter    lexicographically greater than target. if  doesn't exist just return Ist letter.\n\nWhat they have made mess out of it . It took me 10 minutes to understand the question and 2 minutes to solve."
                    },
                    {
                        "username": "sk1122",
                        "content": "This Question Just tells to find Upper Bound of target character using binary search. \\nYou can use upper_bound method in c++ or use binary search to get upper bound\\nBut dont forget to check if the returned index is greater than size of string if it is then return the first char or use %size"
                    }
                ]
            },
            {
                "id": 1922041,
                "content": [
                    {
                        "username": "onebigsalmon",
                        "content": "\"find the smallest element in the list that is larger than the given target. Letters also wrap around.\"\\n\\nI read this 5 times and still didn\\'t understand. If my input is:\\n\\n[\"a\",\"z\"]\\ntarget: \"y\"\\n\\nThen \\'a\\' is returned due to the wrap around.\\n\\nBut if the input is:\\n\\n[\"c\",\"f\"]\\ntarget: \"d\"\\n\\nThen how come \"c\" is not returned? \"c\" is bigger than \"d\" with wrap around and it is smaller than \"f\" (which is supposed to be the right answer. How does this make sense?"
                    },
                    {
                        "username": "bingolive9104",
                        "content": "the correct ans is f because it mention in question that we have to return the value which is greater then target ..... but if target is at n-1 position then no other element exist greater then target if you do it will give out of bound error ... so now in your test case .. we implement the binary search and on that basis we identify that search failed ... because target is missing .. now our task is to cheack is there any value exisit in the given char array which is greater then target if yes then return it .. you can simply put a for loop ... (linear search)...."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "in this q if target is not present in letters , we have to handle 2 cases .\\n1) if there exists a value greater than target return it \\n2) if target is the largest value , return letters[0] .\\n\\nif target is present , we check\\n1) if any value greater than target , return it , else return letters[0] \\nhope this clears your query"
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "[@suresh_Hariharan](/suresh_Hariharan)  but he has provided the example -> [\"c\",\"f\"]\\ntarget: \"d\"\\nhere target is not the largest char present , so why f is not returned "
                    },
                    {
                        "username": "sureshHariharan",
                        "content": "if the target letter is the largest letter in the array (e.g if target is Z there is not greater char than Z ) , so you should return the char of the first Index of the array this is \"wrap around\""
                    },
                    {
                        "username": "RegexSage",
                        "content": "if u see ascii value of d and f , f is greater so f is being return as answer"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "The calm before the storm."
                    },
                    {
                        "username": "ryan2156",
                        "content": "At least got 50 points "
                    },
                    {
                        "username": "user7421CT",
                        "content": "[@Dhananjay40](/Dhananjay40)  the streak gonna end tomorrow lol\\n"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "tomorrow we probably gonna get destroyed T_T"
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "It should be highlighted that solving the problem with $$O(log(n))$$ time complexity is better for educational purposes. Way too easy with bruteforce."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Easiest question I have ever solved."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@tungbuivn](/tungbuivn) To learn binary search, there are many questions on leetcode in which they reject solutions with linear search. If they accept linear search I don\\'t think there is any problem with linear search. They didn\\'t mention any \"Follow-up\". That\\'s why I said it\\'s easiest, and it\\'s my opinion whether it is easy or not okay! I just gave feedback, please ignore if you are not liking it."
                    },
                    {
                        "username": "nishant101",
                        "content": "[@pun_yeeet](/pun_yeeet) Yeah \\uD83E\\uDD23"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "what does the easiest mean ? the key point here is who is having the best answer for the same question. here is two question\n1. have you try your best to solve problem ?\n2. does your solution is the best ?\n\nso prove your self is the best choice is some one must choose you or others. by your submited solution, this is chanlenge with you but you are refun it"
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@swati dubey](/swati_dubey) LeetCode is being lenient. this daily challange is giving us easy problem from the past few days. It\\'s gonna suddenly give us a Hard problem and then we\\'re screwd."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@RadecX1](/RadecX1) \\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "pun_yeeet",
                        "content": "I hope you tried it using Binary Search and not linear search\\n"
                    },
                    {
                        "username": "RadecX1",
                        "content": "Try this : https://leetcode.com/problems/add-two-integers/"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@gajendralenovo](/gajendralenovo) \\uD83D\\uDE05"
                    },
                    {
                        "username": "gajendralenovo",
                        "content": "that\\'s why it has 3k likes and 2k dislikes."
                    },
                    {
                        "username": "iffthen",
                        "content": "Soldiers be ready for Dp and graph.."
                    },
                    {
                        "username": "anwendeng",
                        "content": " In C++ upper_bound can find the least upper bound for sorted data!\nbisect_right has the same function in Python."
                    },
                    {
                        "username": "yipanhuasheng",
                        "content": "This question is not difficult, but I don\\'t understand its Chinese translation.What\\'s the meaning about \"Letters also wrap around. \"?Letters can be reused\\uFF1F"
                    },
                    {
                        "username": "UdhayaK",
                        "content": "It means that the values are bound only bound to the array values .\nExample: If we start from 1 and ends at 10 then it only starts from 1 to 10 ,just bound to the range [1,10]\nin such cases if we want to represent 11 in range [1,10] then use modulus 11%10==1 ,the answer for representing 11 in range [1,10] is 1.\nThe same trick in this question also just use modulus to solve the wrap around thing."
                    },
                    {
                        "username": "user9133ra",
                        "content": "in simple terms, abcd goes     abcd...xyzabcd...xyz indefinately i.e. after letter 'z', sequence starts from 'a' to 'z' and so on.. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "My linear search takes less time than my binary search \\uD83E\\uDD23\\n\\nLeetcode\\u2615"
                    },
                    {
                        "username": "Kaltu",
                        "content": "big O is only eventually true for large enough N. I guess for small N in an easy problem(2 <= letters.length <= 10^4), overheads for simple loop are easier to optimize than some branching logics binary search uses."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "The Question could have been framed better .\n\n### Just ask to return a  Ist letter    lexicographically greater than target. if  doesn't exist just return Ist letter.\n\nWhat they have made mess out of it . It took me 10 minutes to understand the question and 2 minutes to solve."
                    },
                    {
                        "username": "sk1122",
                        "content": "This Question Just tells to find Upper Bound of target character using binary search. \\nYou can use upper_bound method in c++ or use binary search to get upper bound\\nBut dont forget to check if the returned index is greater than size of string if it is then return the first char or use %size"
                    }
                ]
            },
            {
                "id": 1922301,
                "content": [
                    {
                        "username": "onebigsalmon",
                        "content": "\"find the smallest element in the list that is larger than the given target. Letters also wrap around.\"\\n\\nI read this 5 times and still didn\\'t understand. If my input is:\\n\\n[\"a\",\"z\"]\\ntarget: \"y\"\\n\\nThen \\'a\\' is returned due to the wrap around.\\n\\nBut if the input is:\\n\\n[\"c\",\"f\"]\\ntarget: \"d\"\\n\\nThen how come \"c\" is not returned? \"c\" is bigger than \"d\" with wrap around and it is smaller than \"f\" (which is supposed to be the right answer. How does this make sense?"
                    },
                    {
                        "username": "bingolive9104",
                        "content": "the correct ans is f because it mention in question that we have to return the value which is greater then target ..... but if target is at n-1 position then no other element exist greater then target if you do it will give out of bound error ... so now in your test case .. we implement the binary search and on that basis we identify that search failed ... because target is missing .. now our task is to cheack is there any value exisit in the given char array which is greater then target if yes then return it .. you can simply put a for loop ... (linear search)...."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "in this q if target is not present in letters , we have to handle 2 cases .\\n1) if there exists a value greater than target return it \\n2) if target is the largest value , return letters[0] .\\n\\nif target is present , we check\\n1) if any value greater than target , return it , else return letters[0] \\nhope this clears your query"
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "[@suresh_Hariharan](/suresh_Hariharan)  but he has provided the example -> [\"c\",\"f\"]\\ntarget: \"d\"\\nhere target is not the largest char present , so why f is not returned "
                    },
                    {
                        "username": "sureshHariharan",
                        "content": "if the target letter is the largest letter in the array (e.g if target is Z there is not greater char than Z ) , so you should return the char of the first Index of the array this is \"wrap around\""
                    },
                    {
                        "username": "RegexSage",
                        "content": "if u see ascii value of d and f , f is greater so f is being return as answer"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "The calm before the storm."
                    },
                    {
                        "username": "ryan2156",
                        "content": "At least got 50 points "
                    },
                    {
                        "username": "user7421CT",
                        "content": "[@Dhananjay40](/Dhananjay40)  the streak gonna end tomorrow lol\\n"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "tomorrow we probably gonna get destroyed T_T"
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "It should be highlighted that solving the problem with $$O(log(n))$$ time complexity is better for educational purposes. Way too easy with bruteforce."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Easiest question I have ever solved."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@tungbuivn](/tungbuivn) To learn binary search, there are many questions on leetcode in which they reject solutions with linear search. If they accept linear search I don\\'t think there is any problem with linear search. They didn\\'t mention any \"Follow-up\". That\\'s why I said it\\'s easiest, and it\\'s my opinion whether it is easy or not okay! I just gave feedback, please ignore if you are not liking it."
                    },
                    {
                        "username": "nishant101",
                        "content": "[@pun_yeeet](/pun_yeeet) Yeah \\uD83E\\uDD23"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "what does the easiest mean ? the key point here is who is having the best answer for the same question. here is two question\n1. have you try your best to solve problem ?\n2. does your solution is the best ?\n\nso prove your self is the best choice is some one must choose you or others. by your submited solution, this is chanlenge with you but you are refun it"
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@swati dubey](/swati_dubey) LeetCode is being lenient. this daily challange is giving us easy problem from the past few days. It\\'s gonna suddenly give us a Hard problem and then we\\'re screwd."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@RadecX1](/RadecX1) \\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "pun_yeeet",
                        "content": "I hope you tried it using Binary Search and not linear search\\n"
                    },
                    {
                        "username": "RadecX1",
                        "content": "Try this : https://leetcode.com/problems/add-two-integers/"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@gajendralenovo](/gajendralenovo) \\uD83D\\uDE05"
                    },
                    {
                        "username": "gajendralenovo",
                        "content": "that\\'s why it has 3k likes and 2k dislikes."
                    },
                    {
                        "username": "iffthen",
                        "content": "Soldiers be ready for Dp and graph.."
                    },
                    {
                        "username": "anwendeng",
                        "content": " In C++ upper_bound can find the least upper bound for sorted data!\nbisect_right has the same function in Python."
                    },
                    {
                        "username": "yipanhuasheng",
                        "content": "This question is not difficult, but I don\\'t understand its Chinese translation.What\\'s the meaning about \"Letters also wrap around. \"?Letters can be reused\\uFF1F"
                    },
                    {
                        "username": "UdhayaK",
                        "content": "It means that the values are bound only bound to the array values .\nExample: If we start from 1 and ends at 10 then it only starts from 1 to 10 ,just bound to the range [1,10]\nin such cases if we want to represent 11 in range [1,10] then use modulus 11%10==1 ,the answer for representing 11 in range [1,10] is 1.\nThe same trick in this question also just use modulus to solve the wrap around thing."
                    },
                    {
                        "username": "user9133ra",
                        "content": "in simple terms, abcd goes     abcd...xyzabcd...xyz indefinately i.e. after letter 'z', sequence starts from 'a' to 'z' and so on.. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "My linear search takes less time than my binary search \\uD83E\\uDD23\\n\\nLeetcode\\u2615"
                    },
                    {
                        "username": "Kaltu",
                        "content": "big O is only eventually true for large enough N. I guess for small N in an easy problem(2 <= letters.length <= 10^4), overheads for simple loop are easier to optimize than some branching logics binary search uses."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "The Question could have been framed better .\n\n### Just ask to return a  Ist letter    lexicographically greater than target. if  doesn't exist just return Ist letter.\n\nWhat they have made mess out of it . It took me 10 minutes to understand the question and 2 minutes to solve."
                    },
                    {
                        "username": "sk1122",
                        "content": "This Question Just tells to find Upper Bound of target character using binary search. \\nYou can use upper_bound method in c++ or use binary search to get upper bound\\nBut dont forget to check if the returned index is greater than size of string if it is then return the first char or use %size"
                    }
                ]
            },
            {
                "id": 1921794,
                "content": [
                    {
                        "username": "onebigsalmon",
                        "content": "\"find the smallest element in the list that is larger than the given target. Letters also wrap around.\"\\n\\nI read this 5 times and still didn\\'t understand. If my input is:\\n\\n[\"a\",\"z\"]\\ntarget: \"y\"\\n\\nThen \\'a\\' is returned due to the wrap around.\\n\\nBut if the input is:\\n\\n[\"c\",\"f\"]\\ntarget: \"d\"\\n\\nThen how come \"c\" is not returned? \"c\" is bigger than \"d\" with wrap around and it is smaller than \"f\" (which is supposed to be the right answer. How does this make sense?"
                    },
                    {
                        "username": "bingolive9104",
                        "content": "the correct ans is f because it mention in question that we have to return the value which is greater then target ..... but if target is at n-1 position then no other element exist greater then target if you do it will give out of bound error ... so now in your test case .. we implement the binary search and on that basis we identify that search failed ... because target is missing .. now our task is to cheack is there any value exisit in the given char array which is greater then target if yes then return it .. you can simply put a for loop ... (linear search)...."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "in this q if target is not present in letters , we have to handle 2 cases .\\n1) if there exists a value greater than target return it \\n2) if target is the largest value , return letters[0] .\\n\\nif target is present , we check\\n1) if any value greater than target , return it , else return letters[0] \\nhope this clears your query"
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "[@suresh_Hariharan](/suresh_Hariharan)  but he has provided the example -> [\"c\",\"f\"]\\ntarget: \"d\"\\nhere target is not the largest char present , so why f is not returned "
                    },
                    {
                        "username": "sureshHariharan",
                        "content": "if the target letter is the largest letter in the array (e.g if target is Z there is not greater char than Z ) , so you should return the char of the first Index of the array this is \"wrap around\""
                    },
                    {
                        "username": "RegexSage",
                        "content": "if u see ascii value of d and f , f is greater so f is being return as answer"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "The calm before the storm."
                    },
                    {
                        "username": "ryan2156",
                        "content": "At least got 50 points "
                    },
                    {
                        "username": "user7421CT",
                        "content": "[@Dhananjay40](/Dhananjay40)  the streak gonna end tomorrow lol\\n"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "tomorrow we probably gonna get destroyed T_T"
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "It should be highlighted that solving the problem with $$O(log(n))$$ time complexity is better for educational purposes. Way too easy with bruteforce."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Easiest question I have ever solved."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@tungbuivn](/tungbuivn) To learn binary search, there are many questions on leetcode in which they reject solutions with linear search. If they accept linear search I don\\'t think there is any problem with linear search. They didn\\'t mention any \"Follow-up\". That\\'s why I said it\\'s easiest, and it\\'s my opinion whether it is easy or not okay! I just gave feedback, please ignore if you are not liking it."
                    },
                    {
                        "username": "nishant101",
                        "content": "[@pun_yeeet](/pun_yeeet) Yeah \\uD83E\\uDD23"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "what does the easiest mean ? the key point here is who is having the best answer for the same question. here is two question\n1. have you try your best to solve problem ?\n2. does your solution is the best ?\n\nso prove your self is the best choice is some one must choose you or others. by your submited solution, this is chanlenge with you but you are refun it"
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@swati dubey](/swati_dubey) LeetCode is being lenient. this daily challange is giving us easy problem from the past few days. It\\'s gonna suddenly give us a Hard problem and then we\\'re screwd."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@RadecX1](/RadecX1) \\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "pun_yeeet",
                        "content": "I hope you tried it using Binary Search and not linear search\\n"
                    },
                    {
                        "username": "RadecX1",
                        "content": "Try this : https://leetcode.com/problems/add-two-integers/"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@gajendralenovo](/gajendralenovo) \\uD83D\\uDE05"
                    },
                    {
                        "username": "gajendralenovo",
                        "content": "that\\'s why it has 3k likes and 2k dislikes."
                    },
                    {
                        "username": "iffthen",
                        "content": "Soldiers be ready for Dp and graph.."
                    },
                    {
                        "username": "anwendeng",
                        "content": " In C++ upper_bound can find the least upper bound for sorted data!\nbisect_right has the same function in Python."
                    },
                    {
                        "username": "yipanhuasheng",
                        "content": "This question is not difficult, but I don\\'t understand its Chinese translation.What\\'s the meaning about \"Letters also wrap around. \"?Letters can be reused\\uFF1F"
                    },
                    {
                        "username": "UdhayaK",
                        "content": "It means that the values are bound only bound to the array values .\nExample: If we start from 1 and ends at 10 then it only starts from 1 to 10 ,just bound to the range [1,10]\nin such cases if we want to represent 11 in range [1,10] then use modulus 11%10==1 ,the answer for representing 11 in range [1,10] is 1.\nThe same trick in this question also just use modulus to solve the wrap around thing."
                    },
                    {
                        "username": "user9133ra",
                        "content": "in simple terms, abcd goes     abcd...xyzabcd...xyz indefinately i.e. after letter 'z', sequence starts from 'a' to 'z' and so on.. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "My linear search takes less time than my binary search \\uD83E\\uDD23\\n\\nLeetcode\\u2615"
                    },
                    {
                        "username": "Kaltu",
                        "content": "big O is only eventually true for large enough N. I guess for small N in an easy problem(2 <= letters.length <= 10^4), overheads for simple loop are easier to optimize than some branching logics binary search uses."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "The Question could have been framed better .\n\n### Just ask to return a  Ist letter    lexicographically greater than target. if  doesn't exist just return Ist letter.\n\nWhat they have made mess out of it . It took me 10 minutes to understand the question and 2 minutes to solve."
                    },
                    {
                        "username": "sk1122",
                        "content": "This Question Just tells to find Upper Bound of target character using binary search. \\nYou can use upper_bound method in c++ or use binary search to get upper bound\\nBut dont forget to check if the returned index is greater than size of string if it is then return the first char or use %size"
                    }
                ]
            },
            {
                "id": 1922139,
                "content": [
                    {
                        "username": "onebigsalmon",
                        "content": "\"find the smallest element in the list that is larger than the given target. Letters also wrap around.\"\\n\\nI read this 5 times and still didn\\'t understand. If my input is:\\n\\n[\"a\",\"z\"]\\ntarget: \"y\"\\n\\nThen \\'a\\' is returned due to the wrap around.\\n\\nBut if the input is:\\n\\n[\"c\",\"f\"]\\ntarget: \"d\"\\n\\nThen how come \"c\" is not returned? \"c\" is bigger than \"d\" with wrap around and it is smaller than \"f\" (which is supposed to be the right answer. How does this make sense?"
                    },
                    {
                        "username": "bingolive9104",
                        "content": "the correct ans is f because it mention in question that we have to return the value which is greater then target ..... but if target is at n-1 position then no other element exist greater then target if you do it will give out of bound error ... so now in your test case .. we implement the binary search and on that basis we identify that search failed ... because target is missing .. now our task is to cheack is there any value exisit in the given char array which is greater then target if yes then return it .. you can simply put a for loop ... (linear search)...."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "in this q if target is not present in letters , we have to handle 2 cases .\\n1) if there exists a value greater than target return it \\n2) if target is the largest value , return letters[0] .\\n\\nif target is present , we check\\n1) if any value greater than target , return it , else return letters[0] \\nhope this clears your query"
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "[@suresh_Hariharan](/suresh_Hariharan)  but he has provided the example -> [\"c\",\"f\"]\\ntarget: \"d\"\\nhere target is not the largest char present , so why f is not returned "
                    },
                    {
                        "username": "sureshHariharan",
                        "content": "if the target letter is the largest letter in the array (e.g if target is Z there is not greater char than Z ) , so you should return the char of the first Index of the array this is \"wrap around\""
                    },
                    {
                        "username": "RegexSage",
                        "content": "if u see ascii value of d and f , f is greater so f is being return as answer"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "The calm before the storm."
                    },
                    {
                        "username": "ryan2156",
                        "content": "At least got 50 points "
                    },
                    {
                        "username": "user7421CT",
                        "content": "[@Dhananjay40](/Dhananjay40)  the streak gonna end tomorrow lol\\n"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "tomorrow we probably gonna get destroyed T_T"
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "It should be highlighted that solving the problem with $$O(log(n))$$ time complexity is better for educational purposes. Way too easy with bruteforce."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Easiest question I have ever solved."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@tungbuivn](/tungbuivn) To learn binary search, there are many questions on leetcode in which they reject solutions with linear search. If they accept linear search I don\\'t think there is any problem with linear search. They didn\\'t mention any \"Follow-up\". That\\'s why I said it\\'s easiest, and it\\'s my opinion whether it is easy or not okay! I just gave feedback, please ignore if you are not liking it."
                    },
                    {
                        "username": "nishant101",
                        "content": "[@pun_yeeet](/pun_yeeet) Yeah \\uD83E\\uDD23"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "what does the easiest mean ? the key point here is who is having the best answer for the same question. here is two question\n1. have you try your best to solve problem ?\n2. does your solution is the best ?\n\nso prove your self is the best choice is some one must choose you or others. by your submited solution, this is chanlenge with you but you are refun it"
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@swati dubey](/swati_dubey) LeetCode is being lenient. this daily challange is giving us easy problem from the past few days. It\\'s gonna suddenly give us a Hard problem and then we\\'re screwd."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@RadecX1](/RadecX1) \\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "pun_yeeet",
                        "content": "I hope you tried it using Binary Search and not linear search\\n"
                    },
                    {
                        "username": "RadecX1",
                        "content": "Try this : https://leetcode.com/problems/add-two-integers/"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@gajendralenovo](/gajendralenovo) \\uD83D\\uDE05"
                    },
                    {
                        "username": "gajendralenovo",
                        "content": "that\\'s why it has 3k likes and 2k dislikes."
                    },
                    {
                        "username": "iffthen",
                        "content": "Soldiers be ready for Dp and graph.."
                    },
                    {
                        "username": "anwendeng",
                        "content": " In C++ upper_bound can find the least upper bound for sorted data!\nbisect_right has the same function in Python."
                    },
                    {
                        "username": "yipanhuasheng",
                        "content": "This question is not difficult, but I don\\'t understand its Chinese translation.What\\'s the meaning about \"Letters also wrap around. \"?Letters can be reused\\uFF1F"
                    },
                    {
                        "username": "UdhayaK",
                        "content": "It means that the values are bound only bound to the array values .\nExample: If we start from 1 and ends at 10 then it only starts from 1 to 10 ,just bound to the range [1,10]\nin such cases if we want to represent 11 in range [1,10] then use modulus 11%10==1 ,the answer for representing 11 in range [1,10] is 1.\nThe same trick in this question also just use modulus to solve the wrap around thing."
                    },
                    {
                        "username": "user9133ra",
                        "content": "in simple terms, abcd goes     abcd...xyzabcd...xyz indefinately i.e. after letter 'z', sequence starts from 'a' to 'z' and so on.. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "My linear search takes less time than my binary search \\uD83E\\uDD23\\n\\nLeetcode\\u2615"
                    },
                    {
                        "username": "Kaltu",
                        "content": "big O is only eventually true for large enough N. I guess for small N in an easy problem(2 <= letters.length <= 10^4), overheads for simple loop are easier to optimize than some branching logics binary search uses."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "The Question could have been framed better .\n\n### Just ask to return a  Ist letter    lexicographically greater than target. if  doesn't exist just return Ist letter.\n\nWhat they have made mess out of it . It took me 10 minutes to understand the question and 2 minutes to solve."
                    },
                    {
                        "username": "sk1122",
                        "content": "This Question Just tells to find Upper Bound of target character using binary search. \\nYou can use upper_bound method in c++ or use binary search to get upper bound\\nBut dont forget to check if the returned index is greater than size of string if it is then return the first char or use %size"
                    }
                ]
            },
            {
                "id": 1921854,
                "content": [
                    {
                        "username": "onebigsalmon",
                        "content": "\"find the smallest element in the list that is larger than the given target. Letters also wrap around.\"\\n\\nI read this 5 times and still didn\\'t understand. If my input is:\\n\\n[\"a\",\"z\"]\\ntarget: \"y\"\\n\\nThen \\'a\\' is returned due to the wrap around.\\n\\nBut if the input is:\\n\\n[\"c\",\"f\"]\\ntarget: \"d\"\\n\\nThen how come \"c\" is not returned? \"c\" is bigger than \"d\" with wrap around and it is smaller than \"f\" (which is supposed to be the right answer. How does this make sense?"
                    },
                    {
                        "username": "bingolive9104",
                        "content": "the correct ans is f because it mention in question that we have to return the value which is greater then target ..... but if target is at n-1 position then no other element exist greater then target if you do it will give out of bound error ... so now in your test case .. we implement the binary search and on that basis we identify that search failed ... because target is missing .. now our task is to cheack is there any value exisit in the given char array which is greater then target if yes then return it .. you can simply put a for loop ... (linear search)...."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "in this q if target is not present in letters , we have to handle 2 cases .\\n1) if there exists a value greater than target return it \\n2) if target is the largest value , return letters[0] .\\n\\nif target is present , we check\\n1) if any value greater than target , return it , else return letters[0] \\nhope this clears your query"
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "[@suresh_Hariharan](/suresh_Hariharan)  but he has provided the example -> [\"c\",\"f\"]\\ntarget: \"d\"\\nhere target is not the largest char present , so why f is not returned "
                    },
                    {
                        "username": "sureshHariharan",
                        "content": "if the target letter is the largest letter in the array (e.g if target is Z there is not greater char than Z ) , so you should return the char of the first Index of the array this is \"wrap around\""
                    },
                    {
                        "username": "RegexSage",
                        "content": "if u see ascii value of d and f , f is greater so f is being return as answer"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "The calm before the storm."
                    },
                    {
                        "username": "ryan2156",
                        "content": "At least got 50 points "
                    },
                    {
                        "username": "user7421CT",
                        "content": "[@Dhananjay40](/Dhananjay40)  the streak gonna end tomorrow lol\\n"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "tomorrow we probably gonna get destroyed T_T"
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "It should be highlighted that solving the problem with $$O(log(n))$$ time complexity is better for educational purposes. Way too easy with bruteforce."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Easiest question I have ever solved."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@tungbuivn](/tungbuivn) To learn binary search, there are many questions on leetcode in which they reject solutions with linear search. If they accept linear search I don\\'t think there is any problem with linear search. They didn\\'t mention any \"Follow-up\". That\\'s why I said it\\'s easiest, and it\\'s my opinion whether it is easy or not okay! I just gave feedback, please ignore if you are not liking it."
                    },
                    {
                        "username": "nishant101",
                        "content": "[@pun_yeeet](/pun_yeeet) Yeah \\uD83E\\uDD23"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "what does the easiest mean ? the key point here is who is having the best answer for the same question. here is two question\n1. have you try your best to solve problem ?\n2. does your solution is the best ?\n\nso prove your self is the best choice is some one must choose you or others. by your submited solution, this is chanlenge with you but you are refun it"
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@swati dubey](/swati_dubey) LeetCode is being lenient. this daily challange is giving us easy problem from the past few days. It\\'s gonna suddenly give us a Hard problem and then we\\'re screwd."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@RadecX1](/RadecX1) \\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "pun_yeeet",
                        "content": "I hope you tried it using Binary Search and not linear search\\n"
                    },
                    {
                        "username": "RadecX1",
                        "content": "Try this : https://leetcode.com/problems/add-two-integers/"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@gajendralenovo](/gajendralenovo) \\uD83D\\uDE05"
                    },
                    {
                        "username": "gajendralenovo",
                        "content": "that\\'s why it has 3k likes and 2k dislikes."
                    },
                    {
                        "username": "iffthen",
                        "content": "Soldiers be ready for Dp and graph.."
                    },
                    {
                        "username": "anwendeng",
                        "content": " In C++ upper_bound can find the least upper bound for sorted data!\nbisect_right has the same function in Python."
                    },
                    {
                        "username": "yipanhuasheng",
                        "content": "This question is not difficult, but I don\\'t understand its Chinese translation.What\\'s the meaning about \"Letters also wrap around. \"?Letters can be reused\\uFF1F"
                    },
                    {
                        "username": "UdhayaK",
                        "content": "It means that the values are bound only bound to the array values .\nExample: If we start from 1 and ends at 10 then it only starts from 1 to 10 ,just bound to the range [1,10]\nin such cases if we want to represent 11 in range [1,10] then use modulus 11%10==1 ,the answer for representing 11 in range [1,10] is 1.\nThe same trick in this question also just use modulus to solve the wrap around thing."
                    },
                    {
                        "username": "user9133ra",
                        "content": "in simple terms, abcd goes     abcd...xyzabcd...xyz indefinately i.e. after letter 'z', sequence starts from 'a' to 'z' and so on.. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "My linear search takes less time than my binary search \\uD83E\\uDD23\\n\\nLeetcode\\u2615"
                    },
                    {
                        "username": "Kaltu",
                        "content": "big O is only eventually true for large enough N. I guess for small N in an easy problem(2 <= letters.length <= 10^4), overheads for simple loop are easier to optimize than some branching logics binary search uses."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "The Question could have been framed better .\n\n### Just ask to return a  Ist letter    lexicographically greater than target. if  doesn't exist just return Ist letter.\n\nWhat they have made mess out of it . It took me 10 minutes to understand the question and 2 minutes to solve."
                    },
                    {
                        "username": "sk1122",
                        "content": "This Question Just tells to find Upper Bound of target character using binary search. \\nYou can use upper_bound method in c++ or use binary search to get upper bound\\nBut dont forget to check if the returned index is greater than size of string if it is then return the first char or use %size"
                    }
                ]
            },
            {
                "id": 1569372,
                "content": [
                    {
                        "username": "onebigsalmon",
                        "content": "\"find the smallest element in the list that is larger than the given target. Letters also wrap around.\"\\n\\nI read this 5 times and still didn\\'t understand. If my input is:\\n\\n[\"a\",\"z\"]\\ntarget: \"y\"\\n\\nThen \\'a\\' is returned due to the wrap around.\\n\\nBut if the input is:\\n\\n[\"c\",\"f\"]\\ntarget: \"d\"\\n\\nThen how come \"c\" is not returned? \"c\" is bigger than \"d\" with wrap around and it is smaller than \"f\" (which is supposed to be the right answer. How does this make sense?"
                    },
                    {
                        "username": "bingolive9104",
                        "content": "the correct ans is f because it mention in question that we have to return the value which is greater then target ..... but if target is at n-1 position then no other element exist greater then target if you do it will give out of bound error ... so now in your test case .. we implement the binary search and on that basis we identify that search failed ... because target is missing .. now our task is to cheack is there any value exisit in the given char array which is greater then target if yes then return it .. you can simply put a for loop ... (linear search)...."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "in this q if target is not present in letters , we have to handle 2 cases .\\n1) if there exists a value greater than target return it \\n2) if target is the largest value , return letters[0] .\\n\\nif target is present , we check\\n1) if any value greater than target , return it , else return letters[0] \\nhope this clears your query"
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "[@suresh_Hariharan](/suresh_Hariharan)  but he has provided the example -> [\"c\",\"f\"]\\ntarget: \"d\"\\nhere target is not the largest char present , so why f is not returned "
                    },
                    {
                        "username": "sureshHariharan",
                        "content": "if the target letter is the largest letter in the array (e.g if target is Z there is not greater char than Z ) , so you should return the char of the first Index of the array this is \"wrap around\""
                    },
                    {
                        "username": "RegexSage",
                        "content": "if u see ascii value of d and f , f is greater so f is being return as answer"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "The calm before the storm."
                    },
                    {
                        "username": "ryan2156",
                        "content": "At least got 50 points "
                    },
                    {
                        "username": "user7421CT",
                        "content": "[@Dhananjay40](/Dhananjay40)  the streak gonna end tomorrow lol\\n"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "tomorrow we probably gonna get destroyed T_T"
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "It should be highlighted that solving the problem with $$O(log(n))$$ time complexity is better for educational purposes. Way too easy with bruteforce."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Easiest question I have ever solved."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@tungbuivn](/tungbuivn) To learn binary search, there are many questions on leetcode in which they reject solutions with linear search. If they accept linear search I don\\'t think there is any problem with linear search. They didn\\'t mention any \"Follow-up\". That\\'s why I said it\\'s easiest, and it\\'s my opinion whether it is easy or not okay! I just gave feedback, please ignore if you are not liking it."
                    },
                    {
                        "username": "nishant101",
                        "content": "[@pun_yeeet](/pun_yeeet) Yeah \\uD83E\\uDD23"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "what does the easiest mean ? the key point here is who is having the best answer for the same question. here is two question\n1. have you try your best to solve problem ?\n2. does your solution is the best ?\n\nso prove your self is the best choice is some one must choose you or others. by your submited solution, this is chanlenge with you but you are refun it"
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@swati dubey](/swati_dubey) LeetCode is being lenient. this daily challange is giving us easy problem from the past few days. It\\'s gonna suddenly give us a Hard problem and then we\\'re screwd."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@RadecX1](/RadecX1) \\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "pun_yeeet",
                        "content": "I hope you tried it using Binary Search and not linear search\\n"
                    },
                    {
                        "username": "RadecX1",
                        "content": "Try this : https://leetcode.com/problems/add-two-integers/"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@gajendralenovo](/gajendralenovo) \\uD83D\\uDE05"
                    },
                    {
                        "username": "gajendralenovo",
                        "content": "that\\'s why it has 3k likes and 2k dislikes."
                    },
                    {
                        "username": "iffthen",
                        "content": "Soldiers be ready for Dp and graph.."
                    },
                    {
                        "username": "anwendeng",
                        "content": " In C++ upper_bound can find the least upper bound for sorted data!\nbisect_right has the same function in Python."
                    },
                    {
                        "username": "yipanhuasheng",
                        "content": "This question is not difficult, but I don\\'t understand its Chinese translation.What\\'s the meaning about \"Letters also wrap around. \"?Letters can be reused\\uFF1F"
                    },
                    {
                        "username": "UdhayaK",
                        "content": "It means that the values are bound only bound to the array values .\nExample: If we start from 1 and ends at 10 then it only starts from 1 to 10 ,just bound to the range [1,10]\nin such cases if we want to represent 11 in range [1,10] then use modulus 11%10==1 ,the answer for representing 11 in range [1,10] is 1.\nThe same trick in this question also just use modulus to solve the wrap around thing."
                    },
                    {
                        "username": "user9133ra",
                        "content": "in simple terms, abcd goes     abcd...xyzabcd...xyz indefinately i.e. after letter 'z', sequence starts from 'a' to 'z' and so on.. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "My linear search takes less time than my binary search \\uD83E\\uDD23\\n\\nLeetcode\\u2615"
                    },
                    {
                        "username": "Kaltu",
                        "content": "big O is only eventually true for large enough N. I guess for small N in an easy problem(2 <= letters.length <= 10^4), overheads for simple loop are easier to optimize than some branching logics binary search uses."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "The Question could have been framed better .\n\n### Just ask to return a  Ist letter    lexicographically greater than target. if  doesn't exist just return Ist letter.\n\nWhat they have made mess out of it . It took me 10 minutes to understand the question and 2 minutes to solve."
                    },
                    {
                        "username": "sk1122",
                        "content": "This Question Just tells to find Upper Bound of target character using binary search. \\nYou can use upper_bound method in c++ or use binary search to get upper bound\\nBut dont forget to check if the returned index is greater than size of string if it is then return the first char or use %size"
                    }
                ]
            },
            {
                "id": 1922039,
                "content": [
                    {
                        "username": "onebigsalmon",
                        "content": "\"find the smallest element in the list that is larger than the given target. Letters also wrap around.\"\\n\\nI read this 5 times and still didn\\'t understand. If my input is:\\n\\n[\"a\",\"z\"]\\ntarget: \"y\"\\n\\nThen \\'a\\' is returned due to the wrap around.\\n\\nBut if the input is:\\n\\n[\"c\",\"f\"]\\ntarget: \"d\"\\n\\nThen how come \"c\" is not returned? \"c\" is bigger than \"d\" with wrap around and it is smaller than \"f\" (which is supposed to be the right answer. How does this make sense?"
                    },
                    {
                        "username": "bingolive9104",
                        "content": "the correct ans is f because it mention in question that we have to return the value which is greater then target ..... but if target is at n-1 position then no other element exist greater then target if you do it will give out of bound error ... so now in your test case .. we implement the binary search and on that basis we identify that search failed ... because target is missing .. now our task is to cheack is there any value exisit in the given char array which is greater then target if yes then return it .. you can simply put a for loop ... (linear search)...."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "in this q if target is not present in letters , we have to handle 2 cases .\\n1) if there exists a value greater than target return it \\n2) if target is the largest value , return letters[0] .\\n\\nif target is present , we check\\n1) if any value greater than target , return it , else return letters[0] \\nhope this clears your query"
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "[@suresh_Hariharan](/suresh_Hariharan)  but he has provided the example -> [\"c\",\"f\"]\\ntarget: \"d\"\\nhere target is not the largest char present , so why f is not returned "
                    },
                    {
                        "username": "sureshHariharan",
                        "content": "if the target letter is the largest letter in the array (e.g if target is Z there is not greater char than Z ) , so you should return the char of the first Index of the array this is \"wrap around\""
                    },
                    {
                        "username": "RegexSage",
                        "content": "if u see ascii value of d and f , f is greater so f is being return as answer"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "The calm before the storm."
                    },
                    {
                        "username": "ryan2156",
                        "content": "At least got 50 points "
                    },
                    {
                        "username": "user7421CT",
                        "content": "[@Dhananjay40](/Dhananjay40)  the streak gonna end tomorrow lol\\n"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "tomorrow we probably gonna get destroyed T_T"
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "It should be highlighted that solving the problem with $$O(log(n))$$ time complexity is better for educational purposes. Way too easy with bruteforce."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Easiest question I have ever solved."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@tungbuivn](/tungbuivn) To learn binary search, there are many questions on leetcode in which they reject solutions with linear search. If they accept linear search I don\\'t think there is any problem with linear search. They didn\\'t mention any \"Follow-up\". That\\'s why I said it\\'s easiest, and it\\'s my opinion whether it is easy or not okay! I just gave feedback, please ignore if you are not liking it."
                    },
                    {
                        "username": "nishant101",
                        "content": "[@pun_yeeet](/pun_yeeet) Yeah \\uD83E\\uDD23"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "what does the easiest mean ? the key point here is who is having the best answer for the same question. here is two question\n1. have you try your best to solve problem ?\n2. does your solution is the best ?\n\nso prove your self is the best choice is some one must choose you or others. by your submited solution, this is chanlenge with you but you are refun it"
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@swati dubey](/swati_dubey) LeetCode is being lenient. this daily challange is giving us easy problem from the past few days. It\\'s gonna suddenly give us a Hard problem and then we\\'re screwd."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@RadecX1](/RadecX1) \\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "pun_yeeet",
                        "content": "I hope you tried it using Binary Search and not linear search\\n"
                    },
                    {
                        "username": "RadecX1",
                        "content": "Try this : https://leetcode.com/problems/add-two-integers/"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@gajendralenovo](/gajendralenovo) \\uD83D\\uDE05"
                    },
                    {
                        "username": "gajendralenovo",
                        "content": "that\\'s why it has 3k likes and 2k dislikes."
                    },
                    {
                        "username": "iffthen",
                        "content": "Soldiers be ready for Dp and graph.."
                    },
                    {
                        "username": "anwendeng",
                        "content": " In C++ upper_bound can find the least upper bound for sorted data!\nbisect_right has the same function in Python."
                    },
                    {
                        "username": "yipanhuasheng",
                        "content": "This question is not difficult, but I don\\'t understand its Chinese translation.What\\'s the meaning about \"Letters also wrap around. \"?Letters can be reused\\uFF1F"
                    },
                    {
                        "username": "UdhayaK",
                        "content": "It means that the values are bound only bound to the array values .\nExample: If we start from 1 and ends at 10 then it only starts from 1 to 10 ,just bound to the range [1,10]\nin such cases if we want to represent 11 in range [1,10] then use modulus 11%10==1 ,the answer for representing 11 in range [1,10] is 1.\nThe same trick in this question also just use modulus to solve the wrap around thing."
                    },
                    {
                        "username": "user9133ra",
                        "content": "in simple terms, abcd goes     abcd...xyzabcd...xyz indefinately i.e. after letter 'z', sequence starts from 'a' to 'z' and so on.. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "My linear search takes less time than my binary search \\uD83E\\uDD23\\n\\nLeetcode\\u2615"
                    },
                    {
                        "username": "Kaltu",
                        "content": "big O is only eventually true for large enough N. I guess for small N in an easy problem(2 <= letters.length <= 10^4), overheads for simple loop are easier to optimize than some branching logics binary search uses."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "The Question could have been framed better .\n\n### Just ask to return a  Ist letter    lexicographically greater than target. if  doesn't exist just return Ist letter.\n\nWhat they have made mess out of it . It took me 10 minutes to understand the question and 2 minutes to solve."
                    },
                    {
                        "username": "sk1122",
                        "content": "This Question Just tells to find Upper Bound of target character using binary search. \\nYou can use upper_bound method in c++ or use binary search to get upper bound\\nBut dont forget to check if the returned index is greater than size of string if it is then return the first char or use %size"
                    }
                ]
            },
            {
                "id": 1921876,
                "content": [
                    {
                        "username": "onebigsalmon",
                        "content": "\"find the smallest element in the list that is larger than the given target. Letters also wrap around.\"\\n\\nI read this 5 times and still didn\\'t understand. If my input is:\\n\\n[\"a\",\"z\"]\\ntarget: \"y\"\\n\\nThen \\'a\\' is returned due to the wrap around.\\n\\nBut if the input is:\\n\\n[\"c\",\"f\"]\\ntarget: \"d\"\\n\\nThen how come \"c\" is not returned? \"c\" is bigger than \"d\" with wrap around and it is smaller than \"f\" (which is supposed to be the right answer. How does this make sense?"
                    },
                    {
                        "username": "bingolive9104",
                        "content": "the correct ans is f because it mention in question that we have to return the value which is greater then target ..... but if target is at n-1 position then no other element exist greater then target if you do it will give out of bound error ... so now in your test case .. we implement the binary search and on that basis we identify that search failed ... because target is missing .. now our task is to cheack is there any value exisit in the given char array which is greater then target if yes then return it .. you can simply put a for loop ... (linear search)...."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "in this q if target is not present in letters , we have to handle 2 cases .\\n1) if there exists a value greater than target return it \\n2) if target is the largest value , return letters[0] .\\n\\nif target is present , we check\\n1) if any value greater than target , return it , else return letters[0] \\nhope this clears your query"
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "[@suresh_Hariharan](/suresh_Hariharan)  but he has provided the example -> [\"c\",\"f\"]\\ntarget: \"d\"\\nhere target is not the largest char present , so why f is not returned "
                    },
                    {
                        "username": "sureshHariharan",
                        "content": "if the target letter is the largest letter in the array (e.g if target is Z there is not greater char than Z ) , so you should return the char of the first Index of the array this is \"wrap around\""
                    },
                    {
                        "username": "RegexSage",
                        "content": "if u see ascii value of d and f , f is greater so f is being return as answer"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "The calm before the storm."
                    },
                    {
                        "username": "ryan2156",
                        "content": "At least got 50 points "
                    },
                    {
                        "username": "user7421CT",
                        "content": "[@Dhananjay40](/Dhananjay40)  the streak gonna end tomorrow lol\\n"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "tomorrow we probably gonna get destroyed T_T"
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "It should be highlighted that solving the problem with $$O(log(n))$$ time complexity is better for educational purposes. Way too easy with bruteforce."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Easiest question I have ever solved."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@tungbuivn](/tungbuivn) To learn binary search, there are many questions on leetcode in which they reject solutions with linear search. If they accept linear search I don\\'t think there is any problem with linear search. They didn\\'t mention any \"Follow-up\". That\\'s why I said it\\'s easiest, and it\\'s my opinion whether it is easy or not okay! I just gave feedback, please ignore if you are not liking it."
                    },
                    {
                        "username": "nishant101",
                        "content": "[@pun_yeeet](/pun_yeeet) Yeah \\uD83E\\uDD23"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "what does the easiest mean ? the key point here is who is having the best answer for the same question. here is two question\n1. have you try your best to solve problem ?\n2. does your solution is the best ?\n\nso prove your self is the best choice is some one must choose you or others. by your submited solution, this is chanlenge with you but you are refun it"
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@swati dubey](/swati_dubey) LeetCode is being lenient. this daily challange is giving us easy problem from the past few days. It\\'s gonna suddenly give us a Hard problem and then we\\'re screwd."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@RadecX1](/RadecX1) \\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "pun_yeeet",
                        "content": "I hope you tried it using Binary Search and not linear search\\n"
                    },
                    {
                        "username": "RadecX1",
                        "content": "Try this : https://leetcode.com/problems/add-two-integers/"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@gajendralenovo](/gajendralenovo) \\uD83D\\uDE05"
                    },
                    {
                        "username": "gajendralenovo",
                        "content": "that\\'s why it has 3k likes and 2k dislikes."
                    },
                    {
                        "username": "iffthen",
                        "content": "Soldiers be ready for Dp and graph.."
                    },
                    {
                        "username": "anwendeng",
                        "content": " In C++ upper_bound can find the least upper bound for sorted data!\nbisect_right has the same function in Python."
                    },
                    {
                        "username": "yipanhuasheng",
                        "content": "This question is not difficult, but I don\\'t understand its Chinese translation.What\\'s the meaning about \"Letters also wrap around. \"?Letters can be reused\\uFF1F"
                    },
                    {
                        "username": "UdhayaK",
                        "content": "It means that the values are bound only bound to the array values .\nExample: If we start from 1 and ends at 10 then it only starts from 1 to 10 ,just bound to the range [1,10]\nin such cases if we want to represent 11 in range [1,10] then use modulus 11%10==1 ,the answer for representing 11 in range [1,10] is 1.\nThe same trick in this question also just use modulus to solve the wrap around thing."
                    },
                    {
                        "username": "user9133ra",
                        "content": "in simple terms, abcd goes     abcd...xyzabcd...xyz indefinately i.e. after letter 'z', sequence starts from 'a' to 'z' and so on.. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "My linear search takes less time than my binary search \\uD83E\\uDD23\\n\\nLeetcode\\u2615"
                    },
                    {
                        "username": "Kaltu",
                        "content": "big O is only eventually true for large enough N. I guess for small N in an easy problem(2 <= letters.length <= 10^4), overheads for simple loop are easier to optimize than some branching logics binary search uses."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "The Question could have been framed better .\n\n### Just ask to return a  Ist letter    lexicographically greater than target. if  doesn't exist just return Ist letter.\n\nWhat they have made mess out of it . It took me 10 minutes to understand the question and 2 minutes to solve."
                    },
                    {
                        "username": "sk1122",
                        "content": "This Question Just tells to find Upper Bound of target character using binary search. \\nYou can use upper_bound method in c++ or use binary search to get upper bound\\nBut dont forget to check if the returned index is greater than size of string if it is then return the first char or use %size"
                    }
                ]
            },
            {
                "id": 1574596,
                "content": [
                    {
                        "username": "onebigsalmon",
                        "content": "\"find the smallest element in the list that is larger than the given target. Letters also wrap around.\"\\n\\nI read this 5 times and still didn\\'t understand. If my input is:\\n\\n[\"a\",\"z\"]\\ntarget: \"y\"\\n\\nThen \\'a\\' is returned due to the wrap around.\\n\\nBut if the input is:\\n\\n[\"c\",\"f\"]\\ntarget: \"d\"\\n\\nThen how come \"c\" is not returned? \"c\" is bigger than \"d\" with wrap around and it is smaller than \"f\" (which is supposed to be the right answer. How does this make sense?"
                    },
                    {
                        "username": "bingolive9104",
                        "content": "the correct ans is f because it mention in question that we have to return the value which is greater then target ..... but if target is at n-1 position then no other element exist greater then target if you do it will give out of bound error ... so now in your test case .. we implement the binary search and on that basis we identify that search failed ... because target is missing .. now our task is to cheack is there any value exisit in the given char array which is greater then target if yes then return it .. you can simply put a for loop ... (linear search)...."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "in this q if target is not present in letters , we have to handle 2 cases .\\n1) if there exists a value greater than target return it \\n2) if target is the largest value , return letters[0] .\\n\\nif target is present , we check\\n1) if any value greater than target , return it , else return letters[0] \\nhope this clears your query"
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "[@suresh_Hariharan](/suresh_Hariharan)  but he has provided the example -> [\"c\",\"f\"]\\ntarget: \"d\"\\nhere target is not the largest char present , so why f is not returned "
                    },
                    {
                        "username": "sureshHariharan",
                        "content": "if the target letter is the largest letter in the array (e.g if target is Z there is not greater char than Z ) , so you should return the char of the first Index of the array this is \"wrap around\""
                    },
                    {
                        "username": "RegexSage",
                        "content": "if u see ascii value of d and f , f is greater so f is being return as answer"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "The calm before the storm."
                    },
                    {
                        "username": "ryan2156",
                        "content": "At least got 50 points "
                    },
                    {
                        "username": "user7421CT",
                        "content": "[@Dhananjay40](/Dhananjay40)  the streak gonna end tomorrow lol\\n"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "tomorrow we probably gonna get destroyed T_T"
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "It should be highlighted that solving the problem with $$O(log(n))$$ time complexity is better for educational purposes. Way too easy with bruteforce."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Easiest question I have ever solved."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@tungbuivn](/tungbuivn) To learn binary search, there are many questions on leetcode in which they reject solutions with linear search. If they accept linear search I don\\'t think there is any problem with linear search. They didn\\'t mention any \"Follow-up\". That\\'s why I said it\\'s easiest, and it\\'s my opinion whether it is easy or not okay! I just gave feedback, please ignore if you are not liking it."
                    },
                    {
                        "username": "nishant101",
                        "content": "[@pun_yeeet](/pun_yeeet) Yeah \\uD83E\\uDD23"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "what does the easiest mean ? the key point here is who is having the best answer for the same question. here is two question\n1. have you try your best to solve problem ?\n2. does your solution is the best ?\n\nso prove your self is the best choice is some one must choose you or others. by your submited solution, this is chanlenge with you but you are refun it"
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@swati dubey](/swati_dubey) LeetCode is being lenient. this daily challange is giving us easy problem from the past few days. It\\'s gonna suddenly give us a Hard problem and then we\\'re screwd."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@RadecX1](/RadecX1) \\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "pun_yeeet",
                        "content": "I hope you tried it using Binary Search and not linear search\\n"
                    },
                    {
                        "username": "RadecX1",
                        "content": "Try this : https://leetcode.com/problems/add-two-integers/"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@gajendralenovo](/gajendralenovo) \\uD83D\\uDE05"
                    },
                    {
                        "username": "gajendralenovo",
                        "content": "that\\'s why it has 3k likes and 2k dislikes."
                    },
                    {
                        "username": "iffthen",
                        "content": "Soldiers be ready for Dp and graph.."
                    },
                    {
                        "username": "anwendeng",
                        "content": " In C++ upper_bound can find the least upper bound for sorted data!\nbisect_right has the same function in Python."
                    },
                    {
                        "username": "yipanhuasheng",
                        "content": "This question is not difficult, but I don\\'t understand its Chinese translation.What\\'s the meaning about \"Letters also wrap around. \"?Letters can be reused\\uFF1F"
                    },
                    {
                        "username": "UdhayaK",
                        "content": "It means that the values are bound only bound to the array values .\nExample: If we start from 1 and ends at 10 then it only starts from 1 to 10 ,just bound to the range [1,10]\nin such cases if we want to represent 11 in range [1,10] then use modulus 11%10==1 ,the answer for representing 11 in range [1,10] is 1.\nThe same trick in this question also just use modulus to solve the wrap around thing."
                    },
                    {
                        "username": "user9133ra",
                        "content": "in simple terms, abcd goes     abcd...xyzabcd...xyz indefinately i.e. after letter 'z', sequence starts from 'a' to 'z' and so on.. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "My linear search takes less time than my binary search \\uD83E\\uDD23\\n\\nLeetcode\\u2615"
                    },
                    {
                        "username": "Kaltu",
                        "content": "big O is only eventually true for large enough N. I guess for small N in an easy problem(2 <= letters.length <= 10^4), overheads for simple loop are easier to optimize than some branching logics binary search uses."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "The Question could have been framed better .\n\n### Just ask to return a  Ist letter    lexicographically greater than target. if  doesn't exist just return Ist letter.\n\nWhat they have made mess out of it . It took me 10 minutes to understand the question and 2 minutes to solve."
                    },
                    {
                        "username": "sk1122",
                        "content": "This Question Just tells to find Upper Bound of target character using binary search. \\nYou can use upper_bound method in c++ or use binary search to get upper bound\\nBut dont forget to check if the returned index is greater than size of string if it is then return the first char or use %size"
                    }
                ]
            },
            {
                "id": 1564640,
                "content": [
                    {
                        "username": "onebigsalmon",
                        "content": "\"find the smallest element in the list that is larger than the given target. Letters also wrap around.\"\\n\\nI read this 5 times and still didn\\'t understand. If my input is:\\n\\n[\"a\",\"z\"]\\ntarget: \"y\"\\n\\nThen \\'a\\' is returned due to the wrap around.\\n\\nBut if the input is:\\n\\n[\"c\",\"f\"]\\ntarget: \"d\"\\n\\nThen how come \"c\" is not returned? \"c\" is bigger than \"d\" with wrap around and it is smaller than \"f\" (which is supposed to be the right answer. How does this make sense?"
                    },
                    {
                        "username": "bingolive9104",
                        "content": "the correct ans is f because it mention in question that we have to return the value which is greater then target ..... but if target is at n-1 position then no other element exist greater then target if you do it will give out of bound error ... so now in your test case .. we implement the binary search and on that basis we identify that search failed ... because target is missing .. now our task is to cheack is there any value exisit in the given char array which is greater then target if yes then return it .. you can simply put a for loop ... (linear search)...."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "in this q if target is not present in letters , we have to handle 2 cases .\\n1) if there exists a value greater than target return it \\n2) if target is the largest value , return letters[0] .\\n\\nif target is present , we check\\n1) if any value greater than target , return it , else return letters[0] \\nhope this clears your query"
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "[@suresh_Hariharan](/suresh_Hariharan)  but he has provided the example -> [\"c\",\"f\"]\\ntarget: \"d\"\\nhere target is not the largest char present , so why f is not returned "
                    },
                    {
                        "username": "sureshHariharan",
                        "content": "if the target letter is the largest letter in the array (e.g if target is Z there is not greater char than Z ) , so you should return the char of the first Index of the array this is \"wrap around\""
                    },
                    {
                        "username": "RegexSage",
                        "content": "if u see ascii value of d and f , f is greater so f is being return as answer"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "The calm before the storm."
                    },
                    {
                        "username": "ryan2156",
                        "content": "At least got 50 points "
                    },
                    {
                        "username": "user7421CT",
                        "content": "[@Dhananjay40](/Dhananjay40)  the streak gonna end tomorrow lol\\n"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "tomorrow we probably gonna get destroyed T_T"
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "It should be highlighted that solving the problem with $$O(log(n))$$ time complexity is better for educational purposes. Way too easy with bruteforce."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Easiest question I have ever solved."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@tungbuivn](/tungbuivn) To learn binary search, there are many questions on leetcode in which they reject solutions with linear search. If they accept linear search I don\\'t think there is any problem with linear search. They didn\\'t mention any \"Follow-up\". That\\'s why I said it\\'s easiest, and it\\'s my opinion whether it is easy or not okay! I just gave feedback, please ignore if you are not liking it."
                    },
                    {
                        "username": "nishant101",
                        "content": "[@pun_yeeet](/pun_yeeet) Yeah \\uD83E\\uDD23"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "what does the easiest mean ? the key point here is who is having the best answer for the same question. here is two question\n1. have you try your best to solve problem ?\n2. does your solution is the best ?\n\nso prove your self is the best choice is some one must choose you or others. by your submited solution, this is chanlenge with you but you are refun it"
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@swati dubey](/swati_dubey) LeetCode is being lenient. this daily challange is giving us easy problem from the past few days. It\\'s gonna suddenly give us a Hard problem and then we\\'re screwd."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@RadecX1](/RadecX1) \\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "pun_yeeet",
                        "content": "I hope you tried it using Binary Search and not linear search\\n"
                    },
                    {
                        "username": "RadecX1",
                        "content": "Try this : https://leetcode.com/problems/add-two-integers/"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@gajendralenovo](/gajendralenovo) \\uD83D\\uDE05"
                    },
                    {
                        "username": "gajendralenovo",
                        "content": "that\\'s why it has 3k likes and 2k dislikes."
                    },
                    {
                        "username": "iffthen",
                        "content": "Soldiers be ready for Dp and graph.."
                    },
                    {
                        "username": "anwendeng",
                        "content": " In C++ upper_bound can find the least upper bound for sorted data!\nbisect_right has the same function in Python."
                    },
                    {
                        "username": "yipanhuasheng",
                        "content": "This question is not difficult, but I don\\'t understand its Chinese translation.What\\'s the meaning about \"Letters also wrap around. \"?Letters can be reused\\uFF1F"
                    },
                    {
                        "username": "UdhayaK",
                        "content": "It means that the values are bound only bound to the array values .\nExample: If we start from 1 and ends at 10 then it only starts from 1 to 10 ,just bound to the range [1,10]\nin such cases if we want to represent 11 in range [1,10] then use modulus 11%10==1 ,the answer for representing 11 in range [1,10] is 1.\nThe same trick in this question also just use modulus to solve the wrap around thing."
                    },
                    {
                        "username": "user9133ra",
                        "content": "in simple terms, abcd goes     abcd...xyzabcd...xyz indefinately i.e. after letter 'z', sequence starts from 'a' to 'z' and so on.. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "My linear search takes less time than my binary search \\uD83E\\uDD23\\n\\nLeetcode\\u2615"
                    },
                    {
                        "username": "Kaltu",
                        "content": "big O is only eventually true for large enough N. I guess for small N in an easy problem(2 <= letters.length <= 10^4), overheads for simple loop are easier to optimize than some branching logics binary search uses."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "The Question could have been framed better .\n\n### Just ask to return a  Ist letter    lexicographically greater than target. if  doesn't exist just return Ist letter.\n\nWhat they have made mess out of it . It took me 10 minutes to understand the question and 2 minutes to solve."
                    },
                    {
                        "username": "sk1122",
                        "content": "This Question Just tells to find Upper Bound of target character using binary search. \\nYou can use upper_bound method in c++ or use binary search to get upper bound\\nBut dont forget to check if the returned index is greater than size of string if it is then return the first char or use %size"
                    }
                ]
            },
            {
                "id": 1922041,
                "content": [
                    {
                        "username": "onebigsalmon",
                        "content": "\"find the smallest element in the list that is larger than the given target. Letters also wrap around.\"\\n\\nI read this 5 times and still didn\\'t understand. If my input is:\\n\\n[\"a\",\"z\"]\\ntarget: \"y\"\\n\\nThen \\'a\\' is returned due to the wrap around.\\n\\nBut if the input is:\\n\\n[\"c\",\"f\"]\\ntarget: \"d\"\\n\\nThen how come \"c\" is not returned? \"c\" is bigger than \"d\" with wrap around and it is smaller than \"f\" (which is supposed to be the right answer. How does this make sense?"
                    },
                    {
                        "username": "bingolive9104",
                        "content": "the correct ans is f because it mention in question that we have to return the value which is greater then target ..... but if target is at n-1 position then no other element exist greater then target if you do it will give out of bound error ... so now in your test case .. we implement the binary search and on that basis we identify that search failed ... because target is missing .. now our task is to cheack is there any value exisit in the given char array which is greater then target if yes then return it .. you can simply put a for loop ... (linear search)...."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "in this q if target is not present in letters , we have to handle 2 cases .\\n1) if there exists a value greater than target return it \\n2) if target is the largest value , return letters[0] .\\n\\nif target is present , we check\\n1) if any value greater than target , return it , else return letters[0] \\nhope this clears your query"
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "[@suresh_Hariharan](/suresh_Hariharan)  but he has provided the example -> [\"c\",\"f\"]\\ntarget: \"d\"\\nhere target is not the largest char present , so why f is not returned "
                    },
                    {
                        "username": "sureshHariharan",
                        "content": "if the target letter is the largest letter in the array (e.g if target is Z there is not greater char than Z ) , so you should return the char of the first Index of the array this is \"wrap around\""
                    },
                    {
                        "username": "RegexSage",
                        "content": "if u see ascii value of d and f , f is greater so f is being return as answer"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "The calm before the storm."
                    },
                    {
                        "username": "ryan2156",
                        "content": "At least got 50 points "
                    },
                    {
                        "username": "user7421CT",
                        "content": "[@Dhananjay40](/Dhananjay40)  the streak gonna end tomorrow lol\\n"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "tomorrow we probably gonna get destroyed T_T"
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "It should be highlighted that solving the problem with $$O(log(n))$$ time complexity is better for educational purposes. Way too easy with bruteforce."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Easiest question I have ever solved."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@tungbuivn](/tungbuivn) To learn binary search, there are many questions on leetcode in which they reject solutions with linear search. If they accept linear search I don\\'t think there is any problem with linear search. They didn\\'t mention any \"Follow-up\". That\\'s why I said it\\'s easiest, and it\\'s my opinion whether it is easy or not okay! I just gave feedback, please ignore if you are not liking it."
                    },
                    {
                        "username": "nishant101",
                        "content": "[@pun_yeeet](/pun_yeeet) Yeah \\uD83E\\uDD23"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "what does the easiest mean ? the key point here is who is having the best answer for the same question. here is two question\n1. have you try your best to solve problem ?\n2. does your solution is the best ?\n\nso prove your self is the best choice is some one must choose you or others. by your submited solution, this is chanlenge with you but you are refun it"
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@swati dubey](/swati_dubey) LeetCode is being lenient. this daily challange is giving us easy problem from the past few days. It\\'s gonna suddenly give us a Hard problem and then we\\'re screwd."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@RadecX1](/RadecX1) \\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "pun_yeeet",
                        "content": "I hope you tried it using Binary Search and not linear search\\n"
                    },
                    {
                        "username": "RadecX1",
                        "content": "Try this : https://leetcode.com/problems/add-two-integers/"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@gajendralenovo](/gajendralenovo) \\uD83D\\uDE05"
                    },
                    {
                        "username": "gajendralenovo",
                        "content": "that\\'s why it has 3k likes and 2k dislikes."
                    },
                    {
                        "username": "iffthen",
                        "content": "Soldiers be ready for Dp and graph.."
                    },
                    {
                        "username": "anwendeng",
                        "content": " In C++ upper_bound can find the least upper bound for sorted data!\nbisect_right has the same function in Python."
                    },
                    {
                        "username": "yipanhuasheng",
                        "content": "This question is not difficult, but I don\\'t understand its Chinese translation.What\\'s the meaning about \"Letters also wrap around. \"?Letters can be reused\\uFF1F"
                    },
                    {
                        "username": "UdhayaK",
                        "content": "It means that the values are bound only bound to the array values .\nExample: If we start from 1 and ends at 10 then it only starts from 1 to 10 ,just bound to the range [1,10]\nin such cases if we want to represent 11 in range [1,10] then use modulus 11%10==1 ,the answer for representing 11 in range [1,10] is 1.\nThe same trick in this question also just use modulus to solve the wrap around thing."
                    },
                    {
                        "username": "user9133ra",
                        "content": "in simple terms, abcd goes     abcd...xyzabcd...xyz indefinately i.e. after letter 'z', sequence starts from 'a' to 'z' and so on.. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "My linear search takes less time than my binary search \\uD83E\\uDD23\\n\\nLeetcode\\u2615"
                    },
                    {
                        "username": "Kaltu",
                        "content": "big O is only eventually true for large enough N. I guess for small N in an easy problem(2 <= letters.length <= 10^4), overheads for simple loop are easier to optimize than some branching logics binary search uses."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "The Question could have been framed better .\n\n### Just ask to return a  Ist letter    lexicographically greater than target. if  doesn't exist just return Ist letter.\n\nWhat they have made mess out of it . It took me 10 minutes to understand the question and 2 minutes to solve."
                    },
                    {
                        "username": "sk1122",
                        "content": "This Question Just tells to find Upper Bound of target character using binary search. \\nYou can use upper_bound method in c++ or use binary search to get upper bound\\nBut dont forget to check if the returned index is greater than size of string if it is then return the first char or use %size"
                    }
                ]
            },
            {
                "id": 1922301,
                "content": [
                    {
                        "username": "onebigsalmon",
                        "content": "\"find the smallest element in the list that is larger than the given target. Letters also wrap around.\"\\n\\nI read this 5 times and still didn\\'t understand. If my input is:\\n\\n[\"a\",\"z\"]\\ntarget: \"y\"\\n\\nThen \\'a\\' is returned due to the wrap around.\\n\\nBut if the input is:\\n\\n[\"c\",\"f\"]\\ntarget: \"d\"\\n\\nThen how come \"c\" is not returned? \"c\" is bigger than \"d\" with wrap around and it is smaller than \"f\" (which is supposed to be the right answer. How does this make sense?"
                    },
                    {
                        "username": "bingolive9104",
                        "content": "the correct ans is f because it mention in question that we have to return the value which is greater then target ..... but if target is at n-1 position then no other element exist greater then target if you do it will give out of bound error ... so now in your test case .. we implement the binary search and on that basis we identify that search failed ... because target is missing .. now our task is to cheack is there any value exisit in the given char array which is greater then target if yes then return it .. you can simply put a for loop ... (linear search)...."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "in this q if target is not present in letters , we have to handle 2 cases .\\n1) if there exists a value greater than target return it \\n2) if target is the largest value , return letters[0] .\\n\\nif target is present , we check\\n1) if any value greater than target , return it , else return letters[0] \\nhope this clears your query"
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "[@suresh_Hariharan](/suresh_Hariharan)  but he has provided the example -> [\"c\",\"f\"]\\ntarget: \"d\"\\nhere target is not the largest char present , so why f is not returned "
                    },
                    {
                        "username": "sureshHariharan",
                        "content": "if the target letter is the largest letter in the array (e.g if target is Z there is not greater char than Z ) , so you should return the char of the first Index of the array this is \"wrap around\""
                    },
                    {
                        "username": "RegexSage",
                        "content": "if u see ascii value of d and f , f is greater so f is being return as answer"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "The calm before the storm."
                    },
                    {
                        "username": "ryan2156",
                        "content": "At least got 50 points "
                    },
                    {
                        "username": "user7421CT",
                        "content": "[@Dhananjay40](/Dhananjay40)  the streak gonna end tomorrow lol\\n"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "tomorrow we probably gonna get destroyed T_T"
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "It should be highlighted that solving the problem with $$O(log(n))$$ time complexity is better for educational purposes. Way too easy with bruteforce."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Easiest question I have ever solved."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@tungbuivn](/tungbuivn) To learn binary search, there are many questions on leetcode in which they reject solutions with linear search. If they accept linear search I don\\'t think there is any problem with linear search. They didn\\'t mention any \"Follow-up\". That\\'s why I said it\\'s easiest, and it\\'s my opinion whether it is easy or not okay! I just gave feedback, please ignore if you are not liking it."
                    },
                    {
                        "username": "nishant101",
                        "content": "[@pun_yeeet](/pun_yeeet) Yeah \\uD83E\\uDD23"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "what does the easiest mean ? the key point here is who is having the best answer for the same question. here is two question\n1. have you try your best to solve problem ?\n2. does your solution is the best ?\n\nso prove your self is the best choice is some one must choose you or others. by your submited solution, this is chanlenge with you but you are refun it"
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@swati dubey](/swati_dubey) LeetCode is being lenient. this daily challange is giving us easy problem from the past few days. It\\'s gonna suddenly give us a Hard problem and then we\\'re screwd."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@RadecX1](/RadecX1) \\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "pun_yeeet",
                        "content": "I hope you tried it using Binary Search and not linear search\\n"
                    },
                    {
                        "username": "RadecX1",
                        "content": "Try this : https://leetcode.com/problems/add-two-integers/"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@gajendralenovo](/gajendralenovo) \\uD83D\\uDE05"
                    },
                    {
                        "username": "gajendralenovo",
                        "content": "that\\'s why it has 3k likes and 2k dislikes."
                    },
                    {
                        "username": "iffthen",
                        "content": "Soldiers be ready for Dp and graph.."
                    },
                    {
                        "username": "anwendeng",
                        "content": " In C++ upper_bound can find the least upper bound for sorted data!\nbisect_right has the same function in Python."
                    },
                    {
                        "username": "yipanhuasheng",
                        "content": "This question is not difficult, but I don\\'t understand its Chinese translation.What\\'s the meaning about \"Letters also wrap around. \"?Letters can be reused\\uFF1F"
                    },
                    {
                        "username": "UdhayaK",
                        "content": "It means that the values are bound only bound to the array values .\nExample: If we start from 1 and ends at 10 then it only starts from 1 to 10 ,just bound to the range [1,10]\nin such cases if we want to represent 11 in range [1,10] then use modulus 11%10==1 ,the answer for representing 11 in range [1,10] is 1.\nThe same trick in this question also just use modulus to solve the wrap around thing."
                    },
                    {
                        "username": "user9133ra",
                        "content": "in simple terms, abcd goes     abcd...xyzabcd...xyz indefinately i.e. after letter 'z', sequence starts from 'a' to 'z' and so on.. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "My linear search takes less time than my binary search \\uD83E\\uDD23\\n\\nLeetcode\\u2615"
                    },
                    {
                        "username": "Kaltu",
                        "content": "big O is only eventually true for large enough N. I guess for small N in an easy problem(2 <= letters.length <= 10^4), overheads for simple loop are easier to optimize than some branching logics binary search uses."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "The Question could have been framed better .\n\n### Just ask to return a  Ist letter    lexicographically greater than target. if  doesn't exist just return Ist letter.\n\nWhat they have made mess out of it . It took me 10 minutes to understand the question and 2 minutes to solve."
                    },
                    {
                        "username": "sk1122",
                        "content": "This Question Just tells to find Upper Bound of target character using binary search. \\nYou can use upper_bound method in c++ or use binary search to get upper bound\\nBut dont forget to check if the returned index is greater than size of string if it is then return the first char or use %size"
                    }
                ]
            },
            {
                "id": 1921794,
                "content": [
                    {
                        "username": "onebigsalmon",
                        "content": "\"find the smallest element in the list that is larger than the given target. Letters also wrap around.\"\\n\\nI read this 5 times and still didn\\'t understand. If my input is:\\n\\n[\"a\",\"z\"]\\ntarget: \"y\"\\n\\nThen \\'a\\' is returned due to the wrap around.\\n\\nBut if the input is:\\n\\n[\"c\",\"f\"]\\ntarget: \"d\"\\n\\nThen how come \"c\" is not returned? \"c\" is bigger than \"d\" with wrap around and it is smaller than \"f\" (which is supposed to be the right answer. How does this make sense?"
                    },
                    {
                        "username": "bingolive9104",
                        "content": "the correct ans is f because it mention in question that we have to return the value which is greater then target ..... but if target is at n-1 position then no other element exist greater then target if you do it will give out of bound error ... so now in your test case .. we implement the binary search and on that basis we identify that search failed ... because target is missing .. now our task is to cheack is there any value exisit in the given char array which is greater then target if yes then return it .. you can simply put a for loop ... (linear search)...."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "in this q if target is not present in letters , we have to handle 2 cases .\\n1) if there exists a value greater than target return it \\n2) if target is the largest value , return letters[0] .\\n\\nif target is present , we check\\n1) if any value greater than target , return it , else return letters[0] \\nhope this clears your query"
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "[@suresh_Hariharan](/suresh_Hariharan)  but he has provided the example -> [\"c\",\"f\"]\\ntarget: \"d\"\\nhere target is not the largest char present , so why f is not returned "
                    },
                    {
                        "username": "sureshHariharan",
                        "content": "if the target letter is the largest letter in the array (e.g if target is Z there is not greater char than Z ) , so you should return the char of the first Index of the array this is \"wrap around\""
                    },
                    {
                        "username": "RegexSage",
                        "content": "if u see ascii value of d and f , f is greater so f is being return as answer"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "The calm before the storm."
                    },
                    {
                        "username": "ryan2156",
                        "content": "At least got 50 points "
                    },
                    {
                        "username": "user7421CT",
                        "content": "[@Dhananjay40](/Dhananjay40)  the streak gonna end tomorrow lol\\n"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "tomorrow we probably gonna get destroyed T_T"
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "It should be highlighted that solving the problem with $$O(log(n))$$ time complexity is better for educational purposes. Way too easy with bruteforce."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Easiest question I have ever solved."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@tungbuivn](/tungbuivn) To learn binary search, there are many questions on leetcode in which they reject solutions with linear search. If they accept linear search I don\\'t think there is any problem with linear search. They didn\\'t mention any \"Follow-up\". That\\'s why I said it\\'s easiest, and it\\'s my opinion whether it is easy or not okay! I just gave feedback, please ignore if you are not liking it."
                    },
                    {
                        "username": "nishant101",
                        "content": "[@pun_yeeet](/pun_yeeet) Yeah \\uD83E\\uDD23"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "what does the easiest mean ? the key point here is who is having the best answer for the same question. here is two question\n1. have you try your best to solve problem ?\n2. does your solution is the best ?\n\nso prove your self is the best choice is some one must choose you or others. by your submited solution, this is chanlenge with you but you are refun it"
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@swati dubey](/swati_dubey) LeetCode is being lenient. this daily challange is giving us easy problem from the past few days. It\\'s gonna suddenly give us a Hard problem and then we\\'re screwd."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@RadecX1](/RadecX1) \\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "pun_yeeet",
                        "content": "I hope you tried it using Binary Search and not linear search\\n"
                    },
                    {
                        "username": "RadecX1",
                        "content": "Try this : https://leetcode.com/problems/add-two-integers/"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@gajendralenovo](/gajendralenovo) \\uD83D\\uDE05"
                    },
                    {
                        "username": "gajendralenovo",
                        "content": "that\\'s why it has 3k likes and 2k dislikes."
                    },
                    {
                        "username": "iffthen",
                        "content": "Soldiers be ready for Dp and graph.."
                    },
                    {
                        "username": "anwendeng",
                        "content": " In C++ upper_bound can find the least upper bound for sorted data!\nbisect_right has the same function in Python."
                    },
                    {
                        "username": "yipanhuasheng",
                        "content": "This question is not difficult, but I don\\'t understand its Chinese translation.What\\'s the meaning about \"Letters also wrap around. \"?Letters can be reused\\uFF1F"
                    },
                    {
                        "username": "UdhayaK",
                        "content": "It means that the values are bound only bound to the array values .\nExample: If we start from 1 and ends at 10 then it only starts from 1 to 10 ,just bound to the range [1,10]\nin such cases if we want to represent 11 in range [1,10] then use modulus 11%10==1 ,the answer for representing 11 in range [1,10] is 1.\nThe same trick in this question also just use modulus to solve the wrap around thing."
                    },
                    {
                        "username": "user9133ra",
                        "content": "in simple terms, abcd goes     abcd...xyzabcd...xyz indefinately i.e. after letter 'z', sequence starts from 'a' to 'z' and so on.. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "My linear search takes less time than my binary search \\uD83E\\uDD23\\n\\nLeetcode\\u2615"
                    },
                    {
                        "username": "Kaltu",
                        "content": "big O is only eventually true for large enough N. I guess for small N in an easy problem(2 <= letters.length <= 10^4), overheads for simple loop are easier to optimize than some branching logics binary search uses."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "The Question could have been framed better .\n\n### Just ask to return a  Ist letter    lexicographically greater than target. if  doesn't exist just return Ist letter.\n\nWhat they have made mess out of it . It took me 10 minutes to understand the question and 2 minutes to solve."
                    },
                    {
                        "username": "sk1122",
                        "content": "This Question Just tells to find Upper Bound of target character using binary search. \\nYou can use upper_bound method in c++ or use binary search to get upper bound\\nBut dont forget to check if the returned index is greater than size of string if it is then return the first char or use %size"
                    }
                ]
            },
            {
                "id": 1922139,
                "content": [
                    {
                        "username": "onebigsalmon",
                        "content": "\"find the smallest element in the list that is larger than the given target. Letters also wrap around.\"\\n\\nI read this 5 times and still didn\\'t understand. If my input is:\\n\\n[\"a\",\"z\"]\\ntarget: \"y\"\\n\\nThen \\'a\\' is returned due to the wrap around.\\n\\nBut if the input is:\\n\\n[\"c\",\"f\"]\\ntarget: \"d\"\\n\\nThen how come \"c\" is not returned? \"c\" is bigger than \"d\" with wrap around and it is smaller than \"f\" (which is supposed to be the right answer. How does this make sense?"
                    },
                    {
                        "username": "bingolive9104",
                        "content": "the correct ans is f because it mention in question that we have to return the value which is greater then target ..... but if target is at n-1 position then no other element exist greater then target if you do it will give out of bound error ... so now in your test case .. we implement the binary search and on that basis we identify that search failed ... because target is missing .. now our task is to cheack is there any value exisit in the given char array which is greater then target if yes then return it .. you can simply put a for loop ... (linear search)...."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "in this q if target is not present in letters , we have to handle 2 cases .\\n1) if there exists a value greater than target return it \\n2) if target is the largest value , return letters[0] .\\n\\nif target is present , we check\\n1) if any value greater than target , return it , else return letters[0] \\nhope this clears your query"
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "[@suresh_Hariharan](/suresh_Hariharan)  but he has provided the example -> [\"c\",\"f\"]\\ntarget: \"d\"\\nhere target is not the largest char present , so why f is not returned "
                    },
                    {
                        "username": "sureshHariharan",
                        "content": "if the target letter is the largest letter in the array (e.g if target is Z there is not greater char than Z ) , so you should return the char of the first Index of the array this is \"wrap around\""
                    },
                    {
                        "username": "RegexSage",
                        "content": "if u see ascii value of d and f , f is greater so f is being return as answer"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "The calm before the storm."
                    },
                    {
                        "username": "ryan2156",
                        "content": "At least got 50 points "
                    },
                    {
                        "username": "user7421CT",
                        "content": "[@Dhananjay40](/Dhananjay40)  the streak gonna end tomorrow lol\\n"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "tomorrow we probably gonna get destroyed T_T"
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "It should be highlighted that solving the problem with $$O(log(n))$$ time complexity is better for educational purposes. Way too easy with bruteforce."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Easiest question I have ever solved."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@tungbuivn](/tungbuivn) To learn binary search, there are many questions on leetcode in which they reject solutions with linear search. If they accept linear search I don\\'t think there is any problem with linear search. They didn\\'t mention any \"Follow-up\". That\\'s why I said it\\'s easiest, and it\\'s my opinion whether it is easy or not okay! I just gave feedback, please ignore if you are not liking it."
                    },
                    {
                        "username": "nishant101",
                        "content": "[@pun_yeeet](/pun_yeeet) Yeah \\uD83E\\uDD23"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "what does the easiest mean ? the key point here is who is having the best answer for the same question. here is two question\n1. have you try your best to solve problem ?\n2. does your solution is the best ?\n\nso prove your self is the best choice is some one must choose you or others. by your submited solution, this is chanlenge with you but you are refun it"
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@swati dubey](/swati_dubey) LeetCode is being lenient. this daily challange is giving us easy problem from the past few days. It\\'s gonna suddenly give us a Hard problem and then we\\'re screwd."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@RadecX1](/RadecX1) \\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "pun_yeeet",
                        "content": "I hope you tried it using Binary Search and not linear search\\n"
                    },
                    {
                        "username": "RadecX1",
                        "content": "Try this : https://leetcode.com/problems/add-two-integers/"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@gajendralenovo](/gajendralenovo) \\uD83D\\uDE05"
                    },
                    {
                        "username": "gajendralenovo",
                        "content": "that\\'s why it has 3k likes and 2k dislikes."
                    },
                    {
                        "username": "iffthen",
                        "content": "Soldiers be ready for Dp and graph.."
                    },
                    {
                        "username": "anwendeng",
                        "content": " In C++ upper_bound can find the least upper bound for sorted data!\nbisect_right has the same function in Python."
                    },
                    {
                        "username": "yipanhuasheng",
                        "content": "This question is not difficult, but I don\\'t understand its Chinese translation.What\\'s the meaning about \"Letters also wrap around. \"?Letters can be reused\\uFF1F"
                    },
                    {
                        "username": "UdhayaK",
                        "content": "It means that the values are bound only bound to the array values .\nExample: If we start from 1 and ends at 10 then it only starts from 1 to 10 ,just bound to the range [1,10]\nin such cases if we want to represent 11 in range [1,10] then use modulus 11%10==1 ,the answer for representing 11 in range [1,10] is 1.\nThe same trick in this question also just use modulus to solve the wrap around thing."
                    },
                    {
                        "username": "user9133ra",
                        "content": "in simple terms, abcd goes     abcd...xyzabcd...xyz indefinately i.e. after letter 'z', sequence starts from 'a' to 'z' and so on.. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "My linear search takes less time than my binary search \\uD83E\\uDD23\\n\\nLeetcode\\u2615"
                    },
                    {
                        "username": "Kaltu",
                        "content": "big O is only eventually true for large enough N. I guess for small N in an easy problem(2 <= letters.length <= 10^4), overheads for simple loop are easier to optimize than some branching logics binary search uses."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "The Question could have been framed better .\n\n### Just ask to return a  Ist letter    lexicographically greater than target. if  doesn't exist just return Ist letter.\n\nWhat they have made mess out of it . It took me 10 minutes to understand the question and 2 minutes to solve."
                    },
                    {
                        "username": "sk1122",
                        "content": "This Question Just tells to find Upper Bound of target character using binary search. \\nYou can use upper_bound method in c++ or use binary search to get upper bound\\nBut dont forget to check if the returned index is greater than size of string if it is then return the first char or use %size"
                    }
                ]
            },
            {
                "id": 1921854,
                "content": [
                    {
                        "username": "onebigsalmon",
                        "content": "\"find the smallest element in the list that is larger than the given target. Letters also wrap around.\"\\n\\nI read this 5 times and still didn\\'t understand. If my input is:\\n\\n[\"a\",\"z\"]\\ntarget: \"y\"\\n\\nThen \\'a\\' is returned due to the wrap around.\\n\\nBut if the input is:\\n\\n[\"c\",\"f\"]\\ntarget: \"d\"\\n\\nThen how come \"c\" is not returned? \"c\" is bigger than \"d\" with wrap around and it is smaller than \"f\" (which is supposed to be the right answer. How does this make sense?"
                    },
                    {
                        "username": "bingolive9104",
                        "content": "the correct ans is f because it mention in question that we have to return the value which is greater then target ..... but if target is at n-1 position then no other element exist greater then target if you do it will give out of bound error ... so now in your test case .. we implement the binary search and on that basis we identify that search failed ... because target is missing .. now our task is to cheack is there any value exisit in the given char array which is greater then target if yes then return it .. you can simply put a for loop ... (linear search)...."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "in this q if target is not present in letters , we have to handle 2 cases .\\n1) if there exists a value greater than target return it \\n2) if target is the largest value , return letters[0] .\\n\\nif target is present , we check\\n1) if any value greater than target , return it , else return letters[0] \\nhope this clears your query"
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "[@suresh_Hariharan](/suresh_Hariharan)  but he has provided the example -> [\"c\",\"f\"]\\ntarget: \"d\"\\nhere target is not the largest char present , so why f is not returned "
                    },
                    {
                        "username": "sureshHariharan",
                        "content": "if the target letter is the largest letter in the array (e.g if target is Z there is not greater char than Z ) , so you should return the char of the first Index of the array this is \"wrap around\""
                    },
                    {
                        "username": "RegexSage",
                        "content": "if u see ascii value of d and f , f is greater so f is being return as answer"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "The calm before the storm."
                    },
                    {
                        "username": "ryan2156",
                        "content": "At least got 50 points "
                    },
                    {
                        "username": "user7421CT",
                        "content": "[@Dhananjay40](/Dhananjay40)  the streak gonna end tomorrow lol\\n"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "tomorrow we probably gonna get destroyed T_T"
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "It should be highlighted that solving the problem with $$O(log(n))$$ time complexity is better for educational purposes. Way too easy with bruteforce."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Easiest question I have ever solved."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@tungbuivn](/tungbuivn) To learn binary search, there are many questions on leetcode in which they reject solutions with linear search. If they accept linear search I don\\'t think there is any problem with linear search. They didn\\'t mention any \"Follow-up\". That\\'s why I said it\\'s easiest, and it\\'s my opinion whether it is easy or not okay! I just gave feedback, please ignore if you are not liking it."
                    },
                    {
                        "username": "nishant101",
                        "content": "[@pun_yeeet](/pun_yeeet) Yeah \\uD83E\\uDD23"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "what does the easiest mean ? the key point here is who is having the best answer for the same question. here is two question\n1. have you try your best to solve problem ?\n2. does your solution is the best ?\n\nso prove your self is the best choice is some one must choose you or others. by your submited solution, this is chanlenge with you but you are refun it"
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@swati dubey](/swati_dubey) LeetCode is being lenient. this daily challange is giving us easy problem from the past few days. It\\'s gonna suddenly give us a Hard problem and then we\\'re screwd."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@RadecX1](/RadecX1) \\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "pun_yeeet",
                        "content": "I hope you tried it using Binary Search and not linear search\\n"
                    },
                    {
                        "username": "RadecX1",
                        "content": "Try this : https://leetcode.com/problems/add-two-integers/"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@gajendralenovo](/gajendralenovo) \\uD83D\\uDE05"
                    },
                    {
                        "username": "gajendralenovo",
                        "content": "that\\'s why it has 3k likes and 2k dislikes."
                    },
                    {
                        "username": "iffthen",
                        "content": "Soldiers be ready for Dp and graph.."
                    },
                    {
                        "username": "anwendeng",
                        "content": " In C++ upper_bound can find the least upper bound for sorted data!\nbisect_right has the same function in Python."
                    },
                    {
                        "username": "yipanhuasheng",
                        "content": "This question is not difficult, but I don\\'t understand its Chinese translation.What\\'s the meaning about \"Letters also wrap around. \"?Letters can be reused\\uFF1F"
                    },
                    {
                        "username": "UdhayaK",
                        "content": "It means that the values are bound only bound to the array values .\nExample: If we start from 1 and ends at 10 then it only starts from 1 to 10 ,just bound to the range [1,10]\nin such cases if we want to represent 11 in range [1,10] then use modulus 11%10==1 ,the answer for representing 11 in range [1,10] is 1.\nThe same trick in this question also just use modulus to solve the wrap around thing."
                    },
                    {
                        "username": "user9133ra",
                        "content": "in simple terms, abcd goes     abcd...xyzabcd...xyz indefinately i.e. after letter 'z', sequence starts from 'a' to 'z' and so on.. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "My linear search takes less time than my binary search \\uD83E\\uDD23\\n\\nLeetcode\\u2615"
                    },
                    {
                        "username": "Kaltu",
                        "content": "big O is only eventually true for large enough N. I guess for small N in an easy problem(2 <= letters.length <= 10^4), overheads for simple loop are easier to optimize than some branching logics binary search uses."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "The Question could have been framed better .\n\n### Just ask to return a  Ist letter    lexicographically greater than target. if  doesn't exist just return Ist letter.\n\nWhat they have made mess out of it . It took me 10 minutes to understand the question and 2 minutes to solve."
                    },
                    {
                        "username": "sk1122",
                        "content": "This Question Just tells to find Upper Bound of target character using binary search. \\nYou can use upper_bound method in c++ or use binary search to get upper bound\\nBut dont forget to check if the returned index is greater than size of string if it is then return the first char or use %size"
                    }
                ]
            },
            {
                "id": 1569372,
                "content": [
                    {
                        "username": "onebigsalmon",
                        "content": "\"find the smallest element in the list that is larger than the given target. Letters also wrap around.\"\\n\\nI read this 5 times and still didn\\'t understand. If my input is:\\n\\n[\"a\",\"z\"]\\ntarget: \"y\"\\n\\nThen \\'a\\' is returned due to the wrap around.\\n\\nBut if the input is:\\n\\n[\"c\",\"f\"]\\ntarget: \"d\"\\n\\nThen how come \"c\" is not returned? \"c\" is bigger than \"d\" with wrap around and it is smaller than \"f\" (which is supposed to be the right answer. How does this make sense?"
                    },
                    {
                        "username": "bingolive9104",
                        "content": "the correct ans is f because it mention in question that we have to return the value which is greater then target ..... but if target is at n-1 position then no other element exist greater then target if you do it will give out of bound error ... so now in your test case .. we implement the binary search and on that basis we identify that search failed ... because target is missing .. now our task is to cheack is there any value exisit in the given char array which is greater then target if yes then return it .. you can simply put a for loop ... (linear search)...."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "in this q if target is not present in letters , we have to handle 2 cases .\\n1) if there exists a value greater than target return it \\n2) if target is the largest value , return letters[0] .\\n\\nif target is present , we check\\n1) if any value greater than target , return it , else return letters[0] \\nhope this clears your query"
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "[@suresh_Hariharan](/suresh_Hariharan)  but he has provided the example -> [\"c\",\"f\"]\\ntarget: \"d\"\\nhere target is not the largest char present , so why f is not returned "
                    },
                    {
                        "username": "sureshHariharan",
                        "content": "if the target letter is the largest letter in the array (e.g if target is Z there is not greater char than Z ) , so you should return the char of the first Index of the array this is \"wrap around\""
                    },
                    {
                        "username": "RegexSage",
                        "content": "if u see ascii value of d and f , f is greater so f is being return as answer"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "The calm before the storm."
                    },
                    {
                        "username": "ryan2156",
                        "content": "At least got 50 points "
                    },
                    {
                        "username": "user7421CT",
                        "content": "[@Dhananjay40](/Dhananjay40)  the streak gonna end tomorrow lol\\n"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "tomorrow we probably gonna get destroyed T_T"
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "It should be highlighted that solving the problem with $$O(log(n))$$ time complexity is better for educational purposes. Way too easy with bruteforce."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Easiest question I have ever solved."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@tungbuivn](/tungbuivn) To learn binary search, there are many questions on leetcode in which they reject solutions with linear search. If they accept linear search I don\\'t think there is any problem with linear search. They didn\\'t mention any \"Follow-up\". That\\'s why I said it\\'s easiest, and it\\'s my opinion whether it is easy or not okay! I just gave feedback, please ignore if you are not liking it."
                    },
                    {
                        "username": "nishant101",
                        "content": "[@pun_yeeet](/pun_yeeet) Yeah \\uD83E\\uDD23"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "what does the easiest mean ? the key point here is who is having the best answer for the same question. here is two question\n1. have you try your best to solve problem ?\n2. does your solution is the best ?\n\nso prove your self is the best choice is some one must choose you or others. by your submited solution, this is chanlenge with you but you are refun it"
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@swati dubey](/swati_dubey) LeetCode is being lenient. this daily challange is giving us easy problem from the past few days. It\\'s gonna suddenly give us a Hard problem and then we\\'re screwd."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@RadecX1](/RadecX1) \\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "pun_yeeet",
                        "content": "I hope you tried it using Binary Search and not linear search\\n"
                    },
                    {
                        "username": "RadecX1",
                        "content": "Try this : https://leetcode.com/problems/add-two-integers/"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@gajendralenovo](/gajendralenovo) \\uD83D\\uDE05"
                    },
                    {
                        "username": "gajendralenovo",
                        "content": "that\\'s why it has 3k likes and 2k dislikes."
                    },
                    {
                        "username": "iffthen",
                        "content": "Soldiers be ready for Dp and graph.."
                    },
                    {
                        "username": "anwendeng",
                        "content": " In C++ upper_bound can find the least upper bound for sorted data!\nbisect_right has the same function in Python."
                    },
                    {
                        "username": "yipanhuasheng",
                        "content": "This question is not difficult, but I don\\'t understand its Chinese translation.What\\'s the meaning about \"Letters also wrap around. \"?Letters can be reused\\uFF1F"
                    },
                    {
                        "username": "UdhayaK",
                        "content": "It means that the values are bound only bound to the array values .\nExample: If we start from 1 and ends at 10 then it only starts from 1 to 10 ,just bound to the range [1,10]\nin such cases if we want to represent 11 in range [1,10] then use modulus 11%10==1 ,the answer for representing 11 in range [1,10] is 1.\nThe same trick in this question also just use modulus to solve the wrap around thing."
                    },
                    {
                        "username": "user9133ra",
                        "content": "in simple terms, abcd goes     abcd...xyzabcd...xyz indefinately i.e. after letter 'z', sequence starts from 'a' to 'z' and so on.. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "My linear search takes less time than my binary search \\uD83E\\uDD23\\n\\nLeetcode\\u2615"
                    },
                    {
                        "username": "Kaltu",
                        "content": "big O is only eventually true for large enough N. I guess for small N in an easy problem(2 <= letters.length <= 10^4), overheads for simple loop are easier to optimize than some branching logics binary search uses."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "The Question could have been framed better .\n\n### Just ask to return a  Ist letter    lexicographically greater than target. if  doesn't exist just return Ist letter.\n\nWhat they have made mess out of it . It took me 10 minutes to understand the question and 2 minutes to solve."
                    },
                    {
                        "username": "sk1122",
                        "content": "This Question Just tells to find Upper Bound of target character using binary search. \\nYou can use upper_bound method in c++ or use binary search to get upper bound\\nBut dont forget to check if the returned index is greater than size of string if it is then return the first char or use %size"
                    }
                ]
            },
            {
                "id": 1922039,
                "content": [
                    {
                        "username": "onebigsalmon",
                        "content": "\"find the smallest element in the list that is larger than the given target. Letters also wrap around.\"\\n\\nI read this 5 times and still didn\\'t understand. If my input is:\\n\\n[\"a\",\"z\"]\\ntarget: \"y\"\\n\\nThen \\'a\\' is returned due to the wrap around.\\n\\nBut if the input is:\\n\\n[\"c\",\"f\"]\\ntarget: \"d\"\\n\\nThen how come \"c\" is not returned? \"c\" is bigger than \"d\" with wrap around and it is smaller than \"f\" (which is supposed to be the right answer. How does this make sense?"
                    },
                    {
                        "username": "bingolive9104",
                        "content": "the correct ans is f because it mention in question that we have to return the value which is greater then target ..... but if target is at n-1 position then no other element exist greater then target if you do it will give out of bound error ... so now in your test case .. we implement the binary search and on that basis we identify that search failed ... because target is missing .. now our task is to cheack is there any value exisit in the given char array which is greater then target if yes then return it .. you can simply put a for loop ... (linear search)...."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "in this q if target is not present in letters , we have to handle 2 cases .\\n1) if there exists a value greater than target return it \\n2) if target is the largest value , return letters[0] .\\n\\nif target is present , we check\\n1) if any value greater than target , return it , else return letters[0] \\nhope this clears your query"
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "[@suresh_Hariharan](/suresh_Hariharan)  but he has provided the example -> [\"c\",\"f\"]\\ntarget: \"d\"\\nhere target is not the largest char present , so why f is not returned "
                    },
                    {
                        "username": "sureshHariharan",
                        "content": "if the target letter is the largest letter in the array (e.g if target is Z there is not greater char than Z ) , so you should return the char of the first Index of the array this is \"wrap around\""
                    },
                    {
                        "username": "RegexSage",
                        "content": "if u see ascii value of d and f , f is greater so f is being return as answer"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "The calm before the storm."
                    },
                    {
                        "username": "ryan2156",
                        "content": "At least got 50 points "
                    },
                    {
                        "username": "user7421CT",
                        "content": "[@Dhananjay40](/Dhananjay40)  the streak gonna end tomorrow lol\\n"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "tomorrow we probably gonna get destroyed T_T"
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "It should be highlighted that solving the problem with $$O(log(n))$$ time complexity is better for educational purposes. Way too easy with bruteforce."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Easiest question I have ever solved."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@tungbuivn](/tungbuivn) To learn binary search, there are many questions on leetcode in which they reject solutions with linear search. If they accept linear search I don\\'t think there is any problem with linear search. They didn\\'t mention any \"Follow-up\". That\\'s why I said it\\'s easiest, and it\\'s my opinion whether it is easy or not okay! I just gave feedback, please ignore if you are not liking it."
                    },
                    {
                        "username": "nishant101",
                        "content": "[@pun_yeeet](/pun_yeeet) Yeah \\uD83E\\uDD23"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "what does the easiest mean ? the key point here is who is having the best answer for the same question. here is two question\n1. have you try your best to solve problem ?\n2. does your solution is the best ?\n\nso prove your self is the best choice is some one must choose you or others. by your submited solution, this is chanlenge with you but you are refun it"
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@swati dubey](/swati_dubey) LeetCode is being lenient. this daily challange is giving us easy problem from the past few days. It\\'s gonna suddenly give us a Hard problem and then we\\'re screwd."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@RadecX1](/RadecX1) \\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "pun_yeeet",
                        "content": "I hope you tried it using Binary Search and not linear search\\n"
                    },
                    {
                        "username": "RadecX1",
                        "content": "Try this : https://leetcode.com/problems/add-two-integers/"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@gajendralenovo](/gajendralenovo) \\uD83D\\uDE05"
                    },
                    {
                        "username": "gajendralenovo",
                        "content": "that\\'s why it has 3k likes and 2k dislikes."
                    },
                    {
                        "username": "iffthen",
                        "content": "Soldiers be ready for Dp and graph.."
                    },
                    {
                        "username": "anwendeng",
                        "content": " In C++ upper_bound can find the least upper bound for sorted data!\nbisect_right has the same function in Python."
                    },
                    {
                        "username": "yipanhuasheng",
                        "content": "This question is not difficult, but I don\\'t understand its Chinese translation.What\\'s the meaning about \"Letters also wrap around. \"?Letters can be reused\\uFF1F"
                    },
                    {
                        "username": "UdhayaK",
                        "content": "It means that the values are bound only bound to the array values .\nExample: If we start from 1 and ends at 10 then it only starts from 1 to 10 ,just bound to the range [1,10]\nin such cases if we want to represent 11 in range [1,10] then use modulus 11%10==1 ,the answer for representing 11 in range [1,10] is 1.\nThe same trick in this question also just use modulus to solve the wrap around thing."
                    },
                    {
                        "username": "user9133ra",
                        "content": "in simple terms, abcd goes     abcd...xyzabcd...xyz indefinately i.e. after letter 'z', sequence starts from 'a' to 'z' and so on.. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "My linear search takes less time than my binary search \\uD83E\\uDD23\\n\\nLeetcode\\u2615"
                    },
                    {
                        "username": "Kaltu",
                        "content": "big O is only eventually true for large enough N. I guess for small N in an easy problem(2 <= letters.length <= 10^4), overheads for simple loop are easier to optimize than some branching logics binary search uses."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "The Question could have been framed better .\n\n### Just ask to return a  Ist letter    lexicographically greater than target. if  doesn't exist just return Ist letter.\n\nWhat they have made mess out of it . It took me 10 minutes to understand the question and 2 minutes to solve."
                    },
                    {
                        "username": "sk1122",
                        "content": "This Question Just tells to find Upper Bound of target character using binary search. \\nYou can use upper_bound method in c++ or use binary search to get upper bound\\nBut dont forget to check if the returned index is greater than size of string if it is then return the first char or use %size"
                    }
                ]
            },
            {
                "id": 1921876,
                "content": [
                    {
                        "username": "onebigsalmon",
                        "content": "\"find the smallest element in the list that is larger than the given target. Letters also wrap around.\"\\n\\nI read this 5 times and still didn\\'t understand. If my input is:\\n\\n[\"a\",\"z\"]\\ntarget: \"y\"\\n\\nThen \\'a\\' is returned due to the wrap around.\\n\\nBut if the input is:\\n\\n[\"c\",\"f\"]\\ntarget: \"d\"\\n\\nThen how come \"c\" is not returned? \"c\" is bigger than \"d\" with wrap around and it is smaller than \"f\" (which is supposed to be the right answer. How does this make sense?"
                    },
                    {
                        "username": "bingolive9104",
                        "content": "the correct ans is f because it mention in question that we have to return the value which is greater then target ..... but if target is at n-1 position then no other element exist greater then target if you do it will give out of bound error ... so now in your test case .. we implement the binary search and on that basis we identify that search failed ... because target is missing .. now our task is to cheack is there any value exisit in the given char array which is greater then target if yes then return it .. you can simply put a for loop ... (linear search)...."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "in this q if target is not present in letters , we have to handle 2 cases .\\n1) if there exists a value greater than target return it \\n2) if target is the largest value , return letters[0] .\\n\\nif target is present , we check\\n1) if any value greater than target , return it , else return letters[0] \\nhope this clears your query"
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "[@suresh_Hariharan](/suresh_Hariharan)  but he has provided the example -> [\"c\",\"f\"]\\ntarget: \"d\"\\nhere target is not the largest char present , so why f is not returned "
                    },
                    {
                        "username": "sureshHariharan",
                        "content": "if the target letter is the largest letter in the array (e.g if target is Z there is not greater char than Z ) , so you should return the char of the first Index of the array this is \"wrap around\""
                    },
                    {
                        "username": "RegexSage",
                        "content": "if u see ascii value of d and f , f is greater so f is being return as answer"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "The calm before the storm."
                    },
                    {
                        "username": "ryan2156",
                        "content": "At least got 50 points "
                    },
                    {
                        "username": "user7421CT",
                        "content": "[@Dhananjay40](/Dhananjay40)  the streak gonna end tomorrow lol\\n"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "tomorrow we probably gonna get destroyed T_T"
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "It should be highlighted that solving the problem with $$O(log(n))$$ time complexity is better for educational purposes. Way too easy with bruteforce."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Easiest question I have ever solved."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@tungbuivn](/tungbuivn) To learn binary search, there are many questions on leetcode in which they reject solutions with linear search. If they accept linear search I don\\'t think there is any problem with linear search. They didn\\'t mention any \"Follow-up\". That\\'s why I said it\\'s easiest, and it\\'s my opinion whether it is easy or not okay! I just gave feedback, please ignore if you are not liking it."
                    },
                    {
                        "username": "nishant101",
                        "content": "[@pun_yeeet](/pun_yeeet) Yeah \\uD83E\\uDD23"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "what does the easiest mean ? the key point here is who is having the best answer for the same question. here is two question\n1. have you try your best to solve problem ?\n2. does your solution is the best ?\n\nso prove your self is the best choice is some one must choose you or others. by your submited solution, this is chanlenge with you but you are refun it"
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@swati dubey](/swati_dubey) LeetCode is being lenient. this daily challange is giving us easy problem from the past few days. It\\'s gonna suddenly give us a Hard problem and then we\\'re screwd."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@RadecX1](/RadecX1) \\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "pun_yeeet",
                        "content": "I hope you tried it using Binary Search and not linear search\\n"
                    },
                    {
                        "username": "RadecX1",
                        "content": "Try this : https://leetcode.com/problems/add-two-integers/"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@gajendralenovo](/gajendralenovo) \\uD83D\\uDE05"
                    },
                    {
                        "username": "gajendralenovo",
                        "content": "that\\'s why it has 3k likes and 2k dislikes."
                    },
                    {
                        "username": "iffthen",
                        "content": "Soldiers be ready for Dp and graph.."
                    },
                    {
                        "username": "anwendeng",
                        "content": " In C++ upper_bound can find the least upper bound for sorted data!\nbisect_right has the same function in Python."
                    },
                    {
                        "username": "yipanhuasheng",
                        "content": "This question is not difficult, but I don\\'t understand its Chinese translation.What\\'s the meaning about \"Letters also wrap around. \"?Letters can be reused\\uFF1F"
                    },
                    {
                        "username": "UdhayaK",
                        "content": "It means that the values are bound only bound to the array values .\nExample: If we start from 1 and ends at 10 then it only starts from 1 to 10 ,just bound to the range [1,10]\nin such cases if we want to represent 11 in range [1,10] then use modulus 11%10==1 ,the answer for representing 11 in range [1,10] is 1.\nThe same trick in this question also just use modulus to solve the wrap around thing."
                    },
                    {
                        "username": "user9133ra",
                        "content": "in simple terms, abcd goes     abcd...xyzabcd...xyz indefinately i.e. after letter 'z', sequence starts from 'a' to 'z' and so on.. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "My linear search takes less time than my binary search \\uD83E\\uDD23\\n\\nLeetcode\\u2615"
                    },
                    {
                        "username": "Kaltu",
                        "content": "big O is only eventually true for large enough N. I guess for small N in an easy problem(2 <= letters.length <= 10^4), overheads for simple loop are easier to optimize than some branching logics binary search uses."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "The Question could have been framed better .\n\n### Just ask to return a  Ist letter    lexicographically greater than target. if  doesn't exist just return Ist letter.\n\nWhat they have made mess out of it . It took me 10 minutes to understand the question and 2 minutes to solve."
                    },
                    {
                        "username": "sk1122",
                        "content": "This Question Just tells to find Upper Bound of target character using binary search. \\nYou can use upper_bound method in c++ or use binary search to get upper bound\\nBut dont forget to check if the returned index is greater than size of string if it is then return the first char or use %size"
                    }
                ]
            },
            {
                "id": 1574596,
                "content": [
                    {
                        "username": "onebigsalmon",
                        "content": "\"find the smallest element in the list that is larger than the given target. Letters also wrap around.\"\\n\\nI read this 5 times and still didn\\'t understand. If my input is:\\n\\n[\"a\",\"z\"]\\ntarget: \"y\"\\n\\nThen \\'a\\' is returned due to the wrap around.\\n\\nBut if the input is:\\n\\n[\"c\",\"f\"]\\ntarget: \"d\"\\n\\nThen how come \"c\" is not returned? \"c\" is bigger than \"d\" with wrap around and it is smaller than \"f\" (which is supposed to be the right answer. How does this make sense?"
                    },
                    {
                        "username": "bingolive9104",
                        "content": "the correct ans is f because it mention in question that we have to return the value which is greater then target ..... but if target is at n-1 position then no other element exist greater then target if you do it will give out of bound error ... so now in your test case .. we implement the binary search and on that basis we identify that search failed ... because target is missing .. now our task is to cheack is there any value exisit in the given char array which is greater then target if yes then return it .. you can simply put a for loop ... (linear search)...."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "in this q if target is not present in letters , we have to handle 2 cases .\\n1) if there exists a value greater than target return it \\n2) if target is the largest value , return letters[0] .\\n\\nif target is present , we check\\n1) if any value greater than target , return it , else return letters[0] \\nhope this clears your query"
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "[@suresh_Hariharan](/suresh_Hariharan)  but he has provided the example -> [\"c\",\"f\"]\\ntarget: \"d\"\\nhere target is not the largest char present , so why f is not returned "
                    },
                    {
                        "username": "sureshHariharan",
                        "content": "if the target letter is the largest letter in the array (e.g if target is Z there is not greater char than Z ) , so you should return the char of the first Index of the array this is \"wrap around\""
                    },
                    {
                        "username": "RegexSage",
                        "content": "if u see ascii value of d and f , f is greater so f is being return as answer"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "The calm before the storm."
                    },
                    {
                        "username": "ryan2156",
                        "content": "At least got 50 points "
                    },
                    {
                        "username": "user7421CT",
                        "content": "[@Dhananjay40](/Dhananjay40)  the streak gonna end tomorrow lol\\n"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "tomorrow we probably gonna get destroyed T_T"
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "It should be highlighted that solving the problem with $$O(log(n))$$ time complexity is better for educational purposes. Way too easy with bruteforce."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Easiest question I have ever solved."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@tungbuivn](/tungbuivn) To learn binary search, there are many questions on leetcode in which they reject solutions with linear search. If they accept linear search I don\\'t think there is any problem with linear search. They didn\\'t mention any \"Follow-up\". That\\'s why I said it\\'s easiest, and it\\'s my opinion whether it is easy or not okay! I just gave feedback, please ignore if you are not liking it."
                    },
                    {
                        "username": "nishant101",
                        "content": "[@pun_yeeet](/pun_yeeet) Yeah \\uD83E\\uDD23"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "what does the easiest mean ? the key point here is who is having the best answer for the same question. here is two question\n1. have you try your best to solve problem ?\n2. does your solution is the best ?\n\nso prove your self is the best choice is some one must choose you or others. by your submited solution, this is chanlenge with you but you are refun it"
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@swati dubey](/swati_dubey) LeetCode is being lenient. this daily challange is giving us easy problem from the past few days. It\\'s gonna suddenly give us a Hard problem and then we\\'re screwd."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@RadecX1](/RadecX1) \\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "pun_yeeet",
                        "content": "I hope you tried it using Binary Search and not linear search\\n"
                    },
                    {
                        "username": "RadecX1",
                        "content": "Try this : https://leetcode.com/problems/add-two-integers/"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@gajendralenovo](/gajendralenovo) \\uD83D\\uDE05"
                    },
                    {
                        "username": "gajendralenovo",
                        "content": "that\\'s why it has 3k likes and 2k dislikes."
                    },
                    {
                        "username": "iffthen",
                        "content": "Soldiers be ready for Dp and graph.."
                    },
                    {
                        "username": "anwendeng",
                        "content": " In C++ upper_bound can find the least upper bound for sorted data!\nbisect_right has the same function in Python."
                    },
                    {
                        "username": "yipanhuasheng",
                        "content": "This question is not difficult, but I don\\'t understand its Chinese translation.What\\'s the meaning about \"Letters also wrap around. \"?Letters can be reused\\uFF1F"
                    },
                    {
                        "username": "UdhayaK",
                        "content": "It means that the values are bound only bound to the array values .\nExample: If we start from 1 and ends at 10 then it only starts from 1 to 10 ,just bound to the range [1,10]\nin such cases if we want to represent 11 in range [1,10] then use modulus 11%10==1 ,the answer for representing 11 in range [1,10] is 1.\nThe same trick in this question also just use modulus to solve the wrap around thing."
                    },
                    {
                        "username": "user9133ra",
                        "content": "in simple terms, abcd goes     abcd...xyzabcd...xyz indefinately i.e. after letter 'z', sequence starts from 'a' to 'z' and so on.. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "My linear search takes less time than my binary search \\uD83E\\uDD23\\n\\nLeetcode\\u2615"
                    },
                    {
                        "username": "Kaltu",
                        "content": "big O is only eventually true for large enough N. I guess for small N in an easy problem(2 <= letters.length <= 10^4), overheads for simple loop are easier to optimize than some branching logics binary search uses."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "The Question could have been framed better .\n\n### Just ask to return a  Ist letter    lexicographically greater than target. if  doesn't exist just return Ist letter.\n\nWhat they have made mess out of it . It took me 10 minutes to understand the question and 2 minutes to solve."
                    },
                    {
                        "username": "sk1122",
                        "content": "This Question Just tells to find Upper Bound of target character using binary search. \\nYou can use upper_bound method in c++ or use binary search to get upper bound\\nBut dont forget to check if the returned index is greater than size of string if it is then return the first char or use %size"
                    }
                ]
            },
            {
                "id": 1859249,
                "content": [
                    {
                        "username": "AleksandrT",
                        "content": "Looks more like mid task, if you need to solve it with `O(logN)`. Because there are too many edge cases and right type of binsearch should be applied."
                    },
                    {
                        "username": "maheshrathi",
                        "content": "return ar[start % ar.length];\\n\\npass your all test cases using this return (majorly out of bound problem)."
                    },
                    {
                        "username": "r4jiv",
                        "content": "[@AdityaBhate](/AdityaBhate)  bro don\\'t spam, you already have this comment. why this again."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714Easy C++ FAANG\\uD83D\\uDE28\\uD83D\\uDE31 Interview code\\uD83E\\uDDE8\\nhttps://leetcode.com/problems/find-smallest-letter-greater-than-target/solutions/2267114/easy-c-faang-interview-code/"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "  this is my problem that  is i solved with out any  watching solution just take a hint from discussion\\nthis is super easy \\n . It took me 10 minutes to understand the question and 2 minutes to solve."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Remember there exist some special cases, not difficult but you should definitely consider them while wiriting down the code.\\ni/p: [\"c\",\"f\",\"j\"]\\ntarget: d\\no/p: f"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "when replacing left or right with mid+1 or -1 it not give absulute position, when the not found, the left will >right and give wrong result, do i correct ?"
                    },
                    {
                        "username": "AhmedMawhoob",
                        "content": "not understand"
                    },
                    {
                        "username": "prasunadash200",
                        "content": "here is my sollution\\n\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        \\n        int start=0;\\n        int end= letters.length-1;\\n     \\n    while ( start <= end ){\\n\\n        int mid = start + (end - start) / 2;\\n\\n    if ( target < letters[mid]){\\n\\n        end = mid -1;\\n\\n    }else\\n    {\\n        start = mid + 1;\\n    }\\n\\n\\n    }\\n return letters[start % letters.length];\\n    }\\n}"
                    },
                    {
                        "username": "sx2019",
                        "content": "Recall: Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "ShibaramSathua",
                        "content": "[@Shrubansall](/Shrubansall) this return statements is for giving the answer in wrap around case when you put any character which is greater than given letters in char array it will help to give us the first letter in the char array \nsuch as in char[] letters = {'c' , 'f' , 'j' };\nwhen you input letter greater than j it will give you the 0 index letter from that char array\ni.e c is the out put here when i input any letter greater than j . I hope you will understand thank you.."
                    },
                    {
                        "username": "Shrubansall",
                        "content": "what is the logic behind the return statement"
                    },
                    {
                        "username": "pushkar_s",
                        "content": "![image](https://assets.leetcode.com/users/images/62ee92d4-4eea-4d22-bf7d-979de8ca083d_1627709798.1154752.png)\\n"
                    },
                    {
                        "username": "irshad_s",
                        "content": "I understood this problem only because of Kunal Kushwaha bhaiya. His way of teaching is just awesome and providing that itself for free is really appreciated. "
                    },
                    {
                        "username": "shaikhsaif_codx",
                        "content": "Easy C++ Binary Search approach\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& arr, char target) {\\n        int s=0;\\n        int e = arr.size()-1;  \\n        int mid = s+(e-s)/2;\\n        while(s<=e){\\n            int mid = s+(e-s)/2;\\n            if(arr[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        } \\n        return arr[s%arr.size()];\\n    }\\n};"
                    },
                    {
                        "username": "Tapeky",
                        "content": "Binary Search !"
                    },
                    {
                        "username": "princeraj1703",
                        "content": "if the letter contains more than 3 unique characters what would be the code for that ?"
                    },
                    {
                        "username": "Imournate",
                        "content": "ill give you a hint if you haven\\'t figured it out yet, you want to be comparing the current value to the value immediately to the left in order to find the right position"
                    }
                ]
            },
            {
                "id": 1568716,
                "content": [
                    {
                        "username": "AleksandrT",
                        "content": "Looks more like mid task, if you need to solve it with `O(logN)`. Because there are too many edge cases and right type of binsearch should be applied."
                    },
                    {
                        "username": "maheshrathi",
                        "content": "return ar[start % ar.length];\\n\\npass your all test cases using this return (majorly out of bound problem)."
                    },
                    {
                        "username": "r4jiv",
                        "content": "[@AdityaBhate](/AdityaBhate)  bro don\\'t spam, you already have this comment. why this again."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714Easy C++ FAANG\\uD83D\\uDE28\\uD83D\\uDE31 Interview code\\uD83E\\uDDE8\\nhttps://leetcode.com/problems/find-smallest-letter-greater-than-target/solutions/2267114/easy-c-faang-interview-code/"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "  this is my problem that  is i solved with out any  watching solution just take a hint from discussion\\nthis is super easy \\n . It took me 10 minutes to understand the question and 2 minutes to solve."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Remember there exist some special cases, not difficult but you should definitely consider them while wiriting down the code.\\ni/p: [\"c\",\"f\",\"j\"]\\ntarget: d\\no/p: f"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "when replacing left or right with mid+1 or -1 it not give absulute position, when the not found, the left will >right and give wrong result, do i correct ?"
                    },
                    {
                        "username": "AhmedMawhoob",
                        "content": "not understand"
                    },
                    {
                        "username": "prasunadash200",
                        "content": "here is my sollution\\n\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        \\n        int start=0;\\n        int end= letters.length-1;\\n     \\n    while ( start <= end ){\\n\\n        int mid = start + (end - start) / 2;\\n\\n    if ( target < letters[mid]){\\n\\n        end = mid -1;\\n\\n    }else\\n    {\\n        start = mid + 1;\\n    }\\n\\n\\n    }\\n return letters[start % letters.length];\\n    }\\n}"
                    },
                    {
                        "username": "sx2019",
                        "content": "Recall: Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "ShibaramSathua",
                        "content": "[@Shrubansall](/Shrubansall) this return statements is for giving the answer in wrap around case when you put any character which is greater than given letters in char array it will help to give us the first letter in the char array \nsuch as in char[] letters = {'c' , 'f' , 'j' };\nwhen you input letter greater than j it will give you the 0 index letter from that char array\ni.e c is the out put here when i input any letter greater than j . I hope you will understand thank you.."
                    },
                    {
                        "username": "Shrubansall",
                        "content": "what is the logic behind the return statement"
                    },
                    {
                        "username": "pushkar_s",
                        "content": "![image](https://assets.leetcode.com/users/images/62ee92d4-4eea-4d22-bf7d-979de8ca083d_1627709798.1154752.png)\\n"
                    },
                    {
                        "username": "irshad_s",
                        "content": "I understood this problem only because of Kunal Kushwaha bhaiya. His way of teaching is just awesome and providing that itself for free is really appreciated. "
                    },
                    {
                        "username": "shaikhsaif_codx",
                        "content": "Easy C++ Binary Search approach\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& arr, char target) {\\n        int s=0;\\n        int e = arr.size()-1;  \\n        int mid = s+(e-s)/2;\\n        while(s<=e){\\n            int mid = s+(e-s)/2;\\n            if(arr[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        } \\n        return arr[s%arr.size()];\\n    }\\n};"
                    },
                    {
                        "username": "Tapeky",
                        "content": "Binary Search !"
                    },
                    {
                        "username": "princeraj1703",
                        "content": "if the letter contains more than 3 unique characters what would be the code for that ?"
                    },
                    {
                        "username": "Imournate",
                        "content": "ill give you a hint if you haven\\'t figured it out yet, you want to be comparing the current value to the value immediately to the left in order to find the right position"
                    }
                ]
            },
            {
                "id": 1951524,
                "content": [
                    {
                        "username": "AleksandrT",
                        "content": "Looks more like mid task, if you need to solve it with `O(logN)`. Because there are too many edge cases and right type of binsearch should be applied."
                    },
                    {
                        "username": "maheshrathi",
                        "content": "return ar[start % ar.length];\\n\\npass your all test cases using this return (majorly out of bound problem)."
                    },
                    {
                        "username": "r4jiv",
                        "content": "[@AdityaBhate](/AdityaBhate)  bro don\\'t spam, you already have this comment. why this again."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714Easy C++ FAANG\\uD83D\\uDE28\\uD83D\\uDE31 Interview code\\uD83E\\uDDE8\\nhttps://leetcode.com/problems/find-smallest-letter-greater-than-target/solutions/2267114/easy-c-faang-interview-code/"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "  this is my problem that  is i solved with out any  watching solution just take a hint from discussion\\nthis is super easy \\n . It took me 10 minutes to understand the question and 2 minutes to solve."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Remember there exist some special cases, not difficult but you should definitely consider them while wiriting down the code.\\ni/p: [\"c\",\"f\",\"j\"]\\ntarget: d\\no/p: f"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "when replacing left or right with mid+1 or -1 it not give absulute position, when the not found, the left will >right and give wrong result, do i correct ?"
                    },
                    {
                        "username": "AhmedMawhoob",
                        "content": "not understand"
                    },
                    {
                        "username": "prasunadash200",
                        "content": "here is my sollution\\n\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        \\n        int start=0;\\n        int end= letters.length-1;\\n     \\n    while ( start <= end ){\\n\\n        int mid = start + (end - start) / 2;\\n\\n    if ( target < letters[mid]){\\n\\n        end = mid -1;\\n\\n    }else\\n    {\\n        start = mid + 1;\\n    }\\n\\n\\n    }\\n return letters[start % letters.length];\\n    }\\n}"
                    },
                    {
                        "username": "sx2019",
                        "content": "Recall: Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "ShibaramSathua",
                        "content": "[@Shrubansall](/Shrubansall) this return statements is for giving the answer in wrap around case when you put any character which is greater than given letters in char array it will help to give us the first letter in the char array \nsuch as in char[] letters = {'c' , 'f' , 'j' };\nwhen you input letter greater than j it will give you the 0 index letter from that char array\ni.e c is the out put here when i input any letter greater than j . I hope you will understand thank you.."
                    },
                    {
                        "username": "Shrubansall",
                        "content": "what is the logic behind the return statement"
                    },
                    {
                        "username": "pushkar_s",
                        "content": "![image](https://assets.leetcode.com/users/images/62ee92d4-4eea-4d22-bf7d-979de8ca083d_1627709798.1154752.png)\\n"
                    },
                    {
                        "username": "irshad_s",
                        "content": "I understood this problem only because of Kunal Kushwaha bhaiya. His way of teaching is just awesome and providing that itself for free is really appreciated. "
                    },
                    {
                        "username": "shaikhsaif_codx",
                        "content": "Easy C++ Binary Search approach\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& arr, char target) {\\n        int s=0;\\n        int e = arr.size()-1;  \\n        int mid = s+(e-s)/2;\\n        while(s<=e){\\n            int mid = s+(e-s)/2;\\n            if(arr[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        } \\n        return arr[s%arr.size()];\\n    }\\n};"
                    },
                    {
                        "username": "Tapeky",
                        "content": "Binary Search !"
                    },
                    {
                        "username": "princeraj1703",
                        "content": "if the letter contains more than 3 unique characters what would be the code for that ?"
                    },
                    {
                        "username": "Imournate",
                        "content": "ill give you a hint if you haven\\'t figured it out yet, you want to be comparing the current value to the value immediately to the left in order to find the right position"
                    }
                ]
            },
            {
                "id": 1922062,
                "content": [
                    {
                        "username": "AleksandrT",
                        "content": "Looks more like mid task, if you need to solve it with `O(logN)`. Because there are too many edge cases and right type of binsearch should be applied."
                    },
                    {
                        "username": "maheshrathi",
                        "content": "return ar[start % ar.length];\\n\\npass your all test cases using this return (majorly out of bound problem)."
                    },
                    {
                        "username": "r4jiv",
                        "content": "[@AdityaBhate](/AdityaBhate)  bro don\\'t spam, you already have this comment. why this again."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714Easy C++ FAANG\\uD83D\\uDE28\\uD83D\\uDE31 Interview code\\uD83E\\uDDE8\\nhttps://leetcode.com/problems/find-smallest-letter-greater-than-target/solutions/2267114/easy-c-faang-interview-code/"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "  this is my problem that  is i solved with out any  watching solution just take a hint from discussion\\nthis is super easy \\n . It took me 10 minutes to understand the question and 2 minutes to solve."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Remember there exist some special cases, not difficult but you should definitely consider them while wiriting down the code.\\ni/p: [\"c\",\"f\",\"j\"]\\ntarget: d\\no/p: f"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "when replacing left or right with mid+1 or -1 it not give absulute position, when the not found, the left will >right and give wrong result, do i correct ?"
                    },
                    {
                        "username": "AhmedMawhoob",
                        "content": "not understand"
                    },
                    {
                        "username": "prasunadash200",
                        "content": "here is my sollution\\n\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        \\n        int start=0;\\n        int end= letters.length-1;\\n     \\n    while ( start <= end ){\\n\\n        int mid = start + (end - start) / 2;\\n\\n    if ( target < letters[mid]){\\n\\n        end = mid -1;\\n\\n    }else\\n    {\\n        start = mid + 1;\\n    }\\n\\n\\n    }\\n return letters[start % letters.length];\\n    }\\n}"
                    },
                    {
                        "username": "sx2019",
                        "content": "Recall: Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "ShibaramSathua",
                        "content": "[@Shrubansall](/Shrubansall) this return statements is for giving the answer in wrap around case when you put any character which is greater than given letters in char array it will help to give us the first letter in the char array \nsuch as in char[] letters = {'c' , 'f' , 'j' };\nwhen you input letter greater than j it will give you the 0 index letter from that char array\ni.e c is the out put here when i input any letter greater than j . I hope you will understand thank you.."
                    },
                    {
                        "username": "Shrubansall",
                        "content": "what is the logic behind the return statement"
                    },
                    {
                        "username": "pushkar_s",
                        "content": "![image](https://assets.leetcode.com/users/images/62ee92d4-4eea-4d22-bf7d-979de8ca083d_1627709798.1154752.png)\\n"
                    },
                    {
                        "username": "irshad_s",
                        "content": "I understood this problem only because of Kunal Kushwaha bhaiya. His way of teaching is just awesome and providing that itself for free is really appreciated. "
                    },
                    {
                        "username": "shaikhsaif_codx",
                        "content": "Easy C++ Binary Search approach\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& arr, char target) {\\n        int s=0;\\n        int e = arr.size()-1;  \\n        int mid = s+(e-s)/2;\\n        while(s<=e){\\n            int mid = s+(e-s)/2;\\n            if(arr[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        } \\n        return arr[s%arr.size()];\\n    }\\n};"
                    },
                    {
                        "username": "Tapeky",
                        "content": "Binary Search !"
                    },
                    {
                        "username": "princeraj1703",
                        "content": "if the letter contains more than 3 unique characters what would be the code for that ?"
                    },
                    {
                        "username": "Imournate",
                        "content": "ill give you a hint if you haven\\'t figured it out yet, you want to be comparing the current value to the value immediately to the left in order to find the right position"
                    }
                ]
            },
            {
                "id": 1712149,
                "content": [
                    {
                        "username": "AleksandrT",
                        "content": "Looks more like mid task, if you need to solve it with `O(logN)`. Because there are too many edge cases and right type of binsearch should be applied."
                    },
                    {
                        "username": "maheshrathi",
                        "content": "return ar[start % ar.length];\\n\\npass your all test cases using this return (majorly out of bound problem)."
                    },
                    {
                        "username": "r4jiv",
                        "content": "[@AdityaBhate](/AdityaBhate)  bro don\\'t spam, you already have this comment. why this again."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714Easy C++ FAANG\\uD83D\\uDE28\\uD83D\\uDE31 Interview code\\uD83E\\uDDE8\\nhttps://leetcode.com/problems/find-smallest-letter-greater-than-target/solutions/2267114/easy-c-faang-interview-code/"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "  this is my problem that  is i solved with out any  watching solution just take a hint from discussion\\nthis is super easy \\n . It took me 10 minutes to understand the question and 2 minutes to solve."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Remember there exist some special cases, not difficult but you should definitely consider them while wiriting down the code.\\ni/p: [\"c\",\"f\",\"j\"]\\ntarget: d\\no/p: f"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "when replacing left or right with mid+1 or -1 it not give absulute position, when the not found, the left will >right and give wrong result, do i correct ?"
                    },
                    {
                        "username": "AhmedMawhoob",
                        "content": "not understand"
                    },
                    {
                        "username": "prasunadash200",
                        "content": "here is my sollution\\n\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        \\n        int start=0;\\n        int end= letters.length-1;\\n     \\n    while ( start <= end ){\\n\\n        int mid = start + (end - start) / 2;\\n\\n    if ( target < letters[mid]){\\n\\n        end = mid -1;\\n\\n    }else\\n    {\\n        start = mid + 1;\\n    }\\n\\n\\n    }\\n return letters[start % letters.length];\\n    }\\n}"
                    },
                    {
                        "username": "sx2019",
                        "content": "Recall: Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "ShibaramSathua",
                        "content": "[@Shrubansall](/Shrubansall) this return statements is for giving the answer in wrap around case when you put any character which is greater than given letters in char array it will help to give us the first letter in the char array \nsuch as in char[] letters = {'c' , 'f' , 'j' };\nwhen you input letter greater than j it will give you the 0 index letter from that char array\ni.e c is the out put here when i input any letter greater than j . I hope you will understand thank you.."
                    },
                    {
                        "username": "Shrubansall",
                        "content": "what is the logic behind the return statement"
                    },
                    {
                        "username": "pushkar_s",
                        "content": "![image](https://assets.leetcode.com/users/images/62ee92d4-4eea-4d22-bf7d-979de8ca083d_1627709798.1154752.png)\\n"
                    },
                    {
                        "username": "irshad_s",
                        "content": "I understood this problem only because of Kunal Kushwaha bhaiya. His way of teaching is just awesome and providing that itself for free is really appreciated. "
                    },
                    {
                        "username": "shaikhsaif_codx",
                        "content": "Easy C++ Binary Search approach\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& arr, char target) {\\n        int s=0;\\n        int e = arr.size()-1;  \\n        int mid = s+(e-s)/2;\\n        while(s<=e){\\n            int mid = s+(e-s)/2;\\n            if(arr[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        } \\n        return arr[s%arr.size()];\\n    }\\n};"
                    },
                    {
                        "username": "Tapeky",
                        "content": "Binary Search !"
                    },
                    {
                        "username": "princeraj1703",
                        "content": "if the letter contains more than 3 unique characters what would be the code for that ?"
                    },
                    {
                        "username": "Imournate",
                        "content": "ill give you a hint if you haven\\'t figured it out yet, you want to be comparing the current value to the value immediately to the left in order to find the right position"
                    }
                ]
            },
            {
                "id": 1575593,
                "content": [
                    {
                        "username": "AleksandrT",
                        "content": "Looks more like mid task, if you need to solve it with `O(logN)`. Because there are too many edge cases and right type of binsearch should be applied."
                    },
                    {
                        "username": "maheshrathi",
                        "content": "return ar[start % ar.length];\\n\\npass your all test cases using this return (majorly out of bound problem)."
                    },
                    {
                        "username": "r4jiv",
                        "content": "[@AdityaBhate](/AdityaBhate)  bro don\\'t spam, you already have this comment. why this again."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714Easy C++ FAANG\\uD83D\\uDE28\\uD83D\\uDE31 Interview code\\uD83E\\uDDE8\\nhttps://leetcode.com/problems/find-smallest-letter-greater-than-target/solutions/2267114/easy-c-faang-interview-code/"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "  this is my problem that  is i solved with out any  watching solution just take a hint from discussion\\nthis is super easy \\n . It took me 10 minutes to understand the question and 2 minutes to solve."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Remember there exist some special cases, not difficult but you should definitely consider them while wiriting down the code.\\ni/p: [\"c\",\"f\",\"j\"]\\ntarget: d\\no/p: f"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "when replacing left or right with mid+1 or -1 it not give absulute position, when the not found, the left will >right and give wrong result, do i correct ?"
                    },
                    {
                        "username": "AhmedMawhoob",
                        "content": "not understand"
                    },
                    {
                        "username": "prasunadash200",
                        "content": "here is my sollution\\n\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        \\n        int start=0;\\n        int end= letters.length-1;\\n     \\n    while ( start <= end ){\\n\\n        int mid = start + (end - start) / 2;\\n\\n    if ( target < letters[mid]){\\n\\n        end = mid -1;\\n\\n    }else\\n    {\\n        start = mid + 1;\\n    }\\n\\n\\n    }\\n return letters[start % letters.length];\\n    }\\n}"
                    },
                    {
                        "username": "sx2019",
                        "content": "Recall: Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "ShibaramSathua",
                        "content": "[@Shrubansall](/Shrubansall) this return statements is for giving the answer in wrap around case when you put any character which is greater than given letters in char array it will help to give us the first letter in the char array \nsuch as in char[] letters = {'c' , 'f' , 'j' };\nwhen you input letter greater than j it will give you the 0 index letter from that char array\ni.e c is the out put here when i input any letter greater than j . I hope you will understand thank you.."
                    },
                    {
                        "username": "Shrubansall",
                        "content": "what is the logic behind the return statement"
                    },
                    {
                        "username": "pushkar_s",
                        "content": "![image](https://assets.leetcode.com/users/images/62ee92d4-4eea-4d22-bf7d-979de8ca083d_1627709798.1154752.png)\\n"
                    },
                    {
                        "username": "irshad_s",
                        "content": "I understood this problem only because of Kunal Kushwaha bhaiya. His way of teaching is just awesome and providing that itself for free is really appreciated. "
                    },
                    {
                        "username": "shaikhsaif_codx",
                        "content": "Easy C++ Binary Search approach\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& arr, char target) {\\n        int s=0;\\n        int e = arr.size()-1;  \\n        int mid = s+(e-s)/2;\\n        while(s<=e){\\n            int mid = s+(e-s)/2;\\n            if(arr[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        } \\n        return arr[s%arr.size()];\\n    }\\n};"
                    },
                    {
                        "username": "Tapeky",
                        "content": "Binary Search !"
                    },
                    {
                        "username": "princeraj1703",
                        "content": "if the letter contains more than 3 unique characters what would be the code for that ?"
                    },
                    {
                        "username": "Imournate",
                        "content": "ill give you a hint if you haven\\'t figured it out yet, you want to be comparing the current value to the value immediately to the left in order to find the right position"
                    }
                ]
            },
            {
                "id": 2023661,
                "content": [
                    {
                        "username": "AleksandrT",
                        "content": "Looks more like mid task, if you need to solve it with `O(logN)`. Because there are too many edge cases and right type of binsearch should be applied."
                    },
                    {
                        "username": "maheshrathi",
                        "content": "return ar[start % ar.length];\\n\\npass your all test cases using this return (majorly out of bound problem)."
                    },
                    {
                        "username": "r4jiv",
                        "content": "[@AdityaBhate](/AdityaBhate)  bro don\\'t spam, you already have this comment. why this again."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714Easy C++ FAANG\\uD83D\\uDE28\\uD83D\\uDE31 Interview code\\uD83E\\uDDE8\\nhttps://leetcode.com/problems/find-smallest-letter-greater-than-target/solutions/2267114/easy-c-faang-interview-code/"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "  this is my problem that  is i solved with out any  watching solution just take a hint from discussion\\nthis is super easy \\n . It took me 10 minutes to understand the question and 2 minutes to solve."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Remember there exist some special cases, not difficult but you should definitely consider them while wiriting down the code.\\ni/p: [\"c\",\"f\",\"j\"]\\ntarget: d\\no/p: f"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "when replacing left or right with mid+1 or -1 it not give absulute position, when the not found, the left will >right and give wrong result, do i correct ?"
                    },
                    {
                        "username": "AhmedMawhoob",
                        "content": "not understand"
                    },
                    {
                        "username": "prasunadash200",
                        "content": "here is my sollution\\n\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        \\n        int start=0;\\n        int end= letters.length-1;\\n     \\n    while ( start <= end ){\\n\\n        int mid = start + (end - start) / 2;\\n\\n    if ( target < letters[mid]){\\n\\n        end = mid -1;\\n\\n    }else\\n    {\\n        start = mid + 1;\\n    }\\n\\n\\n    }\\n return letters[start % letters.length];\\n    }\\n}"
                    },
                    {
                        "username": "sx2019",
                        "content": "Recall: Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "ShibaramSathua",
                        "content": "[@Shrubansall](/Shrubansall) this return statements is for giving the answer in wrap around case when you put any character which is greater than given letters in char array it will help to give us the first letter in the char array \nsuch as in char[] letters = {'c' , 'f' , 'j' };\nwhen you input letter greater than j it will give you the 0 index letter from that char array\ni.e c is the out put here when i input any letter greater than j . I hope you will understand thank you.."
                    },
                    {
                        "username": "Shrubansall",
                        "content": "what is the logic behind the return statement"
                    },
                    {
                        "username": "pushkar_s",
                        "content": "![image](https://assets.leetcode.com/users/images/62ee92d4-4eea-4d22-bf7d-979de8ca083d_1627709798.1154752.png)\\n"
                    },
                    {
                        "username": "irshad_s",
                        "content": "I understood this problem only because of Kunal Kushwaha bhaiya. His way of teaching is just awesome and providing that itself for free is really appreciated. "
                    },
                    {
                        "username": "shaikhsaif_codx",
                        "content": "Easy C++ Binary Search approach\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& arr, char target) {\\n        int s=0;\\n        int e = arr.size()-1;  \\n        int mid = s+(e-s)/2;\\n        while(s<=e){\\n            int mid = s+(e-s)/2;\\n            if(arr[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        } \\n        return arr[s%arr.size()];\\n    }\\n};"
                    },
                    {
                        "username": "Tapeky",
                        "content": "Binary Search !"
                    },
                    {
                        "username": "princeraj1703",
                        "content": "if the letter contains more than 3 unique characters what would be the code for that ?"
                    },
                    {
                        "username": "Imournate",
                        "content": "ill give you a hint if you haven\\'t figured it out yet, you want to be comparing the current value to the value immediately to the left in order to find the right position"
                    }
                ]
            },
            {
                "id": 2021585,
                "content": [
                    {
                        "username": "AleksandrT",
                        "content": "Looks more like mid task, if you need to solve it with `O(logN)`. Because there are too many edge cases and right type of binsearch should be applied."
                    },
                    {
                        "username": "maheshrathi",
                        "content": "return ar[start % ar.length];\\n\\npass your all test cases using this return (majorly out of bound problem)."
                    },
                    {
                        "username": "r4jiv",
                        "content": "[@AdityaBhate](/AdityaBhate)  bro don\\'t spam, you already have this comment. why this again."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714Easy C++ FAANG\\uD83D\\uDE28\\uD83D\\uDE31 Interview code\\uD83E\\uDDE8\\nhttps://leetcode.com/problems/find-smallest-letter-greater-than-target/solutions/2267114/easy-c-faang-interview-code/"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "  this is my problem that  is i solved with out any  watching solution just take a hint from discussion\\nthis is super easy \\n . It took me 10 minutes to understand the question and 2 minutes to solve."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Remember there exist some special cases, not difficult but you should definitely consider them while wiriting down the code.\\ni/p: [\"c\",\"f\",\"j\"]\\ntarget: d\\no/p: f"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "when replacing left or right with mid+1 or -1 it not give absulute position, when the not found, the left will >right and give wrong result, do i correct ?"
                    },
                    {
                        "username": "AhmedMawhoob",
                        "content": "not understand"
                    },
                    {
                        "username": "prasunadash200",
                        "content": "here is my sollution\\n\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        \\n        int start=0;\\n        int end= letters.length-1;\\n     \\n    while ( start <= end ){\\n\\n        int mid = start + (end - start) / 2;\\n\\n    if ( target < letters[mid]){\\n\\n        end = mid -1;\\n\\n    }else\\n    {\\n        start = mid + 1;\\n    }\\n\\n\\n    }\\n return letters[start % letters.length];\\n    }\\n}"
                    },
                    {
                        "username": "sx2019",
                        "content": "Recall: Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "ShibaramSathua",
                        "content": "[@Shrubansall](/Shrubansall) this return statements is for giving the answer in wrap around case when you put any character which is greater than given letters in char array it will help to give us the first letter in the char array \nsuch as in char[] letters = {'c' , 'f' , 'j' };\nwhen you input letter greater than j it will give you the 0 index letter from that char array\ni.e c is the out put here when i input any letter greater than j . I hope you will understand thank you.."
                    },
                    {
                        "username": "Shrubansall",
                        "content": "what is the logic behind the return statement"
                    },
                    {
                        "username": "pushkar_s",
                        "content": "![image](https://assets.leetcode.com/users/images/62ee92d4-4eea-4d22-bf7d-979de8ca083d_1627709798.1154752.png)\\n"
                    },
                    {
                        "username": "irshad_s",
                        "content": "I understood this problem only because of Kunal Kushwaha bhaiya. His way of teaching is just awesome and providing that itself for free is really appreciated. "
                    },
                    {
                        "username": "shaikhsaif_codx",
                        "content": "Easy C++ Binary Search approach\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& arr, char target) {\\n        int s=0;\\n        int e = arr.size()-1;  \\n        int mid = s+(e-s)/2;\\n        while(s<=e){\\n            int mid = s+(e-s)/2;\\n            if(arr[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        } \\n        return arr[s%arr.size()];\\n    }\\n};"
                    },
                    {
                        "username": "Tapeky",
                        "content": "Binary Search !"
                    },
                    {
                        "username": "princeraj1703",
                        "content": "if the letter contains more than 3 unique characters what would be the code for that ?"
                    },
                    {
                        "username": "Imournate",
                        "content": "ill give you a hint if you haven\\'t figured it out yet, you want to be comparing the current value to the value immediately to the left in order to find the right position"
                    }
                ]
            },
            {
                "id": 2017475,
                "content": [
                    {
                        "username": "AleksandrT",
                        "content": "Looks more like mid task, if you need to solve it with `O(logN)`. Because there are too many edge cases and right type of binsearch should be applied."
                    },
                    {
                        "username": "maheshrathi",
                        "content": "return ar[start % ar.length];\\n\\npass your all test cases using this return (majorly out of bound problem)."
                    },
                    {
                        "username": "r4jiv",
                        "content": "[@AdityaBhate](/AdityaBhate)  bro don\\'t spam, you already have this comment. why this again."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714Easy C++ FAANG\\uD83D\\uDE28\\uD83D\\uDE31 Interview code\\uD83E\\uDDE8\\nhttps://leetcode.com/problems/find-smallest-letter-greater-than-target/solutions/2267114/easy-c-faang-interview-code/"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "  this is my problem that  is i solved with out any  watching solution just take a hint from discussion\\nthis is super easy \\n . It took me 10 minutes to understand the question and 2 minutes to solve."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Remember there exist some special cases, not difficult but you should definitely consider them while wiriting down the code.\\ni/p: [\"c\",\"f\",\"j\"]\\ntarget: d\\no/p: f"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "when replacing left or right with mid+1 or -1 it not give absulute position, when the not found, the left will >right and give wrong result, do i correct ?"
                    },
                    {
                        "username": "AhmedMawhoob",
                        "content": "not understand"
                    },
                    {
                        "username": "prasunadash200",
                        "content": "here is my sollution\\n\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        \\n        int start=0;\\n        int end= letters.length-1;\\n     \\n    while ( start <= end ){\\n\\n        int mid = start + (end - start) / 2;\\n\\n    if ( target < letters[mid]){\\n\\n        end = mid -1;\\n\\n    }else\\n    {\\n        start = mid + 1;\\n    }\\n\\n\\n    }\\n return letters[start % letters.length];\\n    }\\n}"
                    },
                    {
                        "username": "sx2019",
                        "content": "Recall: Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "ShibaramSathua",
                        "content": "[@Shrubansall](/Shrubansall) this return statements is for giving the answer in wrap around case when you put any character which is greater than given letters in char array it will help to give us the first letter in the char array \nsuch as in char[] letters = {'c' , 'f' , 'j' };\nwhen you input letter greater than j it will give you the 0 index letter from that char array\ni.e c is the out put here when i input any letter greater than j . I hope you will understand thank you.."
                    },
                    {
                        "username": "Shrubansall",
                        "content": "what is the logic behind the return statement"
                    },
                    {
                        "username": "pushkar_s",
                        "content": "![image](https://assets.leetcode.com/users/images/62ee92d4-4eea-4d22-bf7d-979de8ca083d_1627709798.1154752.png)\\n"
                    },
                    {
                        "username": "irshad_s",
                        "content": "I understood this problem only because of Kunal Kushwaha bhaiya. His way of teaching is just awesome and providing that itself for free is really appreciated. "
                    },
                    {
                        "username": "shaikhsaif_codx",
                        "content": "Easy C++ Binary Search approach\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& arr, char target) {\\n        int s=0;\\n        int e = arr.size()-1;  \\n        int mid = s+(e-s)/2;\\n        while(s<=e){\\n            int mid = s+(e-s)/2;\\n            if(arr[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        } \\n        return arr[s%arr.size()];\\n    }\\n};"
                    },
                    {
                        "username": "Tapeky",
                        "content": "Binary Search !"
                    },
                    {
                        "username": "princeraj1703",
                        "content": "if the letter contains more than 3 unique characters what would be the code for that ?"
                    },
                    {
                        "username": "Imournate",
                        "content": "ill give you a hint if you haven\\'t figured it out yet, you want to be comparing the current value to the value immediately to the left in order to find the right position"
                    }
                ]
            },
            {
                "id": 1995816,
                "content": [
                    {
                        "username": "AleksandrT",
                        "content": "Looks more like mid task, if you need to solve it with `O(logN)`. Because there are too many edge cases and right type of binsearch should be applied."
                    },
                    {
                        "username": "maheshrathi",
                        "content": "return ar[start % ar.length];\\n\\npass your all test cases using this return (majorly out of bound problem)."
                    },
                    {
                        "username": "r4jiv",
                        "content": "[@AdityaBhate](/AdityaBhate)  bro don\\'t spam, you already have this comment. why this again."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714Easy C++ FAANG\\uD83D\\uDE28\\uD83D\\uDE31 Interview code\\uD83E\\uDDE8\\nhttps://leetcode.com/problems/find-smallest-letter-greater-than-target/solutions/2267114/easy-c-faang-interview-code/"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "  this is my problem that  is i solved with out any  watching solution just take a hint from discussion\\nthis is super easy \\n . It took me 10 minutes to understand the question and 2 minutes to solve."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Remember there exist some special cases, not difficult but you should definitely consider them while wiriting down the code.\\ni/p: [\"c\",\"f\",\"j\"]\\ntarget: d\\no/p: f"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "when replacing left or right with mid+1 or -1 it not give absulute position, when the not found, the left will >right and give wrong result, do i correct ?"
                    },
                    {
                        "username": "AhmedMawhoob",
                        "content": "not understand"
                    },
                    {
                        "username": "prasunadash200",
                        "content": "here is my sollution\\n\\nclass Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n        \\n        int start=0;\\n        int end= letters.length-1;\\n     \\n    while ( start <= end ){\\n\\n        int mid = start + (end - start) / 2;\\n\\n    if ( target < letters[mid]){\\n\\n        end = mid -1;\\n\\n    }else\\n    {\\n        start = mid + 1;\\n    }\\n\\n\\n    }\\n return letters[start % letters.length];\\n    }\\n}"
                    },
                    {
                        "username": "sx2019",
                        "content": "Recall: Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "ShibaramSathua",
                        "content": "[@Shrubansall](/Shrubansall) this return statements is for giving the answer in wrap around case when you put any character which is greater than given letters in char array it will help to give us the first letter in the char array \nsuch as in char[] letters = {'c' , 'f' , 'j' };\nwhen you input letter greater than j it will give you the 0 index letter from that char array\ni.e c is the out put here when i input any letter greater than j . I hope you will understand thank you.."
                    },
                    {
                        "username": "Shrubansall",
                        "content": "what is the logic behind the return statement"
                    },
                    {
                        "username": "pushkar_s",
                        "content": "![image](https://assets.leetcode.com/users/images/62ee92d4-4eea-4d22-bf7d-979de8ca083d_1627709798.1154752.png)\\n"
                    },
                    {
                        "username": "irshad_s",
                        "content": "I understood this problem only because of Kunal Kushwaha bhaiya. His way of teaching is just awesome and providing that itself for free is really appreciated. "
                    },
                    {
                        "username": "shaikhsaif_codx",
                        "content": "Easy C++ Binary Search approach\\nclass Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& arr, char target) {\\n        int s=0;\\n        int e = arr.size()-1;  \\n        int mid = s+(e-s)/2;\\n        while(s<=e){\\n            int mid = s+(e-s)/2;\\n            if(arr[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        } \\n        return arr[s%arr.size()];\\n    }\\n};"
                    },
                    {
                        "username": "Tapeky",
                        "content": "Binary Search !"
                    },
                    {
                        "username": "princeraj1703",
                        "content": "if the letter contains more than 3 unique characters what would be the code for that ?"
                    },
                    {
                        "username": "Imournate",
                        "content": "ill give you a hint if you haven\\'t figured it out yet, you want to be comparing the current value to the value immediately to the left in order to find the right position"
                    }
                ]
            },
            {
                "id": 1993524,
                "content": [
                    {
                        "username": "_garvit_goyal_",
                        "content": "in the test cast [\"c\",\"f\",\\'j\"] \\ntarget = \"g\"\\n\\nshowing output = \"c\"\\nand the expected answer is \"j\"\\nbut in every online compiler the answer coming out is \"j\""
                    },
                    {
                        "username": "treat",
                        "content": "Why it doesn\\'t accept a recursive solution?"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "oh, i dont know that, what a test cover :)). i think the cost of recursive is stack memory, almost stack size is 8M and align about 16byte(if the call in std pascal style), so you will have 512k call, i think you still use recursive on this without passing any argument. or you can emulate stack to do recursive"
                    },
                    {
                        "username": "Balgur",
                        "content": "```non-decreasing order```"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Set can be one of the option "
                    },
                    {
                        "username": "its_shubhamjha__",
                        "content": "its easy we can use binary search in this question .....  @"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "It\\'s good for practicing binary search."
                    },
                    {
                        "username": "ankit1478",
                        "content": "you can directly use binary search here \n"
                    },
                    {
                        "username": "Raghav_36",
                        "content": "use binary search\\n"
                    },
                    {
                        "username": "Praghna_K",
                        "content": "class Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n         for (char letter : letters) {\\n            if (letter > target) {\\n                return letter;\\n            }\\n        }\\n        return letters[0];\\n    }\\n};"
                    },
                    {
                        "username": "payek",
                        "content": " After seeing the Constraints, it's better to use linear search."
                    }
                ]
            },
            {
                "id": 1922747,
                "content": [
                    {
                        "username": "_garvit_goyal_",
                        "content": "in the test cast [\"c\",\"f\",\\'j\"] \\ntarget = \"g\"\\n\\nshowing output = \"c\"\\nand the expected answer is \"j\"\\nbut in every online compiler the answer coming out is \"j\""
                    },
                    {
                        "username": "treat",
                        "content": "Why it doesn\\'t accept a recursive solution?"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "oh, i dont know that, what a test cover :)). i think the cost of recursive is stack memory, almost stack size is 8M and align about 16byte(if the call in std pascal style), so you will have 512k call, i think you still use recursive on this without passing any argument. or you can emulate stack to do recursive"
                    },
                    {
                        "username": "Balgur",
                        "content": "```non-decreasing order```"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Set can be one of the option "
                    },
                    {
                        "username": "its_shubhamjha__",
                        "content": "its easy we can use binary search in this question .....  @"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "It\\'s good for practicing binary search."
                    },
                    {
                        "username": "ankit1478",
                        "content": "you can directly use binary search here \n"
                    },
                    {
                        "username": "Raghav_36",
                        "content": "use binary search\\n"
                    },
                    {
                        "username": "Praghna_K",
                        "content": "class Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n         for (char letter : letters) {\\n            if (letter > target) {\\n                return letter;\\n            }\\n        }\\n        return letters[0];\\n    }\\n};"
                    },
                    {
                        "username": "payek",
                        "content": " After seeing the Constraints, it's better to use linear search."
                    }
                ]
            },
            {
                "id": 1922709,
                "content": [
                    {
                        "username": "_garvit_goyal_",
                        "content": "in the test cast [\"c\",\"f\",\\'j\"] \\ntarget = \"g\"\\n\\nshowing output = \"c\"\\nand the expected answer is \"j\"\\nbut in every online compiler the answer coming out is \"j\""
                    },
                    {
                        "username": "treat",
                        "content": "Why it doesn\\'t accept a recursive solution?"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "oh, i dont know that, what a test cover :)). i think the cost of recursive is stack memory, almost stack size is 8M and align about 16byte(if the call in std pascal style), so you will have 512k call, i think you still use recursive on this without passing any argument. or you can emulate stack to do recursive"
                    },
                    {
                        "username": "Balgur",
                        "content": "```non-decreasing order```"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Set can be one of the option "
                    },
                    {
                        "username": "its_shubhamjha__",
                        "content": "its easy we can use binary search in this question .....  @"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "It\\'s good for practicing binary search."
                    },
                    {
                        "username": "ankit1478",
                        "content": "you can directly use binary search here \n"
                    },
                    {
                        "username": "Raghav_36",
                        "content": "use binary search\\n"
                    },
                    {
                        "username": "Praghna_K",
                        "content": "class Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n         for (char letter : letters) {\\n            if (letter > target) {\\n                return letter;\\n            }\\n        }\\n        return letters[0];\\n    }\\n};"
                    },
                    {
                        "username": "payek",
                        "content": " After seeing the Constraints, it's better to use linear search."
                    }
                ]
            },
            {
                "id": 1922592,
                "content": [
                    {
                        "username": "_garvit_goyal_",
                        "content": "in the test cast [\"c\",\"f\",\\'j\"] \\ntarget = \"g\"\\n\\nshowing output = \"c\"\\nand the expected answer is \"j\"\\nbut in every online compiler the answer coming out is \"j\""
                    },
                    {
                        "username": "treat",
                        "content": "Why it doesn\\'t accept a recursive solution?"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "oh, i dont know that, what a test cover :)). i think the cost of recursive is stack memory, almost stack size is 8M and align about 16byte(if the call in std pascal style), so you will have 512k call, i think you still use recursive on this without passing any argument. or you can emulate stack to do recursive"
                    },
                    {
                        "username": "Balgur",
                        "content": "```non-decreasing order```"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Set can be one of the option "
                    },
                    {
                        "username": "its_shubhamjha__",
                        "content": "its easy we can use binary search in this question .....  @"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "It\\'s good for practicing binary search."
                    },
                    {
                        "username": "ankit1478",
                        "content": "you can directly use binary search here \n"
                    },
                    {
                        "username": "Raghav_36",
                        "content": "use binary search\\n"
                    },
                    {
                        "username": "Praghna_K",
                        "content": "class Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n         for (char letter : letters) {\\n            if (letter > target) {\\n                return letter;\\n            }\\n        }\\n        return letters[0];\\n    }\\n};"
                    },
                    {
                        "username": "payek",
                        "content": " After seeing the Constraints, it's better to use linear search."
                    }
                ]
            },
            {
                "id": 1922560,
                "content": [
                    {
                        "username": "_garvit_goyal_",
                        "content": "in the test cast [\"c\",\"f\",\\'j\"] \\ntarget = \"g\"\\n\\nshowing output = \"c\"\\nand the expected answer is \"j\"\\nbut in every online compiler the answer coming out is \"j\""
                    },
                    {
                        "username": "treat",
                        "content": "Why it doesn\\'t accept a recursive solution?"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "oh, i dont know that, what a test cover :)). i think the cost of recursive is stack memory, almost stack size is 8M and align about 16byte(if the call in std pascal style), so you will have 512k call, i think you still use recursive on this without passing any argument. or you can emulate stack to do recursive"
                    },
                    {
                        "username": "Balgur",
                        "content": "```non-decreasing order```"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Set can be one of the option "
                    },
                    {
                        "username": "its_shubhamjha__",
                        "content": "its easy we can use binary search in this question .....  @"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "It\\'s good for practicing binary search."
                    },
                    {
                        "username": "ankit1478",
                        "content": "you can directly use binary search here \n"
                    },
                    {
                        "username": "Raghav_36",
                        "content": "use binary search\\n"
                    },
                    {
                        "username": "Praghna_K",
                        "content": "class Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n         for (char letter : letters) {\\n            if (letter > target) {\\n                return letter;\\n            }\\n        }\\n        return letters[0];\\n    }\\n};"
                    },
                    {
                        "username": "payek",
                        "content": " After seeing the Constraints, it's better to use linear search."
                    }
                ]
            },
            {
                "id": 1922541,
                "content": [
                    {
                        "username": "_garvit_goyal_",
                        "content": "in the test cast [\"c\",\"f\",\\'j\"] \\ntarget = \"g\"\\n\\nshowing output = \"c\"\\nand the expected answer is \"j\"\\nbut in every online compiler the answer coming out is \"j\""
                    },
                    {
                        "username": "treat",
                        "content": "Why it doesn\\'t accept a recursive solution?"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "oh, i dont know that, what a test cover :)). i think the cost of recursive is stack memory, almost stack size is 8M and align about 16byte(if the call in std pascal style), so you will have 512k call, i think you still use recursive on this without passing any argument. or you can emulate stack to do recursive"
                    },
                    {
                        "username": "Balgur",
                        "content": "```non-decreasing order```"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Set can be one of the option "
                    },
                    {
                        "username": "its_shubhamjha__",
                        "content": "its easy we can use binary search in this question .....  @"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "It\\'s good for practicing binary search."
                    },
                    {
                        "username": "ankit1478",
                        "content": "you can directly use binary search here \n"
                    },
                    {
                        "username": "Raghav_36",
                        "content": "use binary search\\n"
                    },
                    {
                        "username": "Praghna_K",
                        "content": "class Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n         for (char letter : letters) {\\n            if (letter > target) {\\n                return letter;\\n            }\\n        }\\n        return letters[0];\\n    }\\n};"
                    },
                    {
                        "username": "payek",
                        "content": " After seeing the Constraints, it's better to use linear search."
                    }
                ]
            },
            {
                "id": 1922363,
                "content": [
                    {
                        "username": "_garvit_goyal_",
                        "content": "in the test cast [\"c\",\"f\",\\'j\"] \\ntarget = \"g\"\\n\\nshowing output = \"c\"\\nand the expected answer is \"j\"\\nbut in every online compiler the answer coming out is \"j\""
                    },
                    {
                        "username": "treat",
                        "content": "Why it doesn\\'t accept a recursive solution?"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "oh, i dont know that, what a test cover :)). i think the cost of recursive is stack memory, almost stack size is 8M and align about 16byte(if the call in std pascal style), so you will have 512k call, i think you still use recursive on this without passing any argument. or you can emulate stack to do recursive"
                    },
                    {
                        "username": "Balgur",
                        "content": "```non-decreasing order```"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Set can be one of the option "
                    },
                    {
                        "username": "its_shubhamjha__",
                        "content": "its easy we can use binary search in this question .....  @"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "It\\'s good for practicing binary search."
                    },
                    {
                        "username": "ankit1478",
                        "content": "you can directly use binary search here \n"
                    },
                    {
                        "username": "Raghav_36",
                        "content": "use binary search\\n"
                    },
                    {
                        "username": "Praghna_K",
                        "content": "class Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n         for (char letter : letters) {\\n            if (letter > target) {\\n                return letter;\\n            }\\n        }\\n        return letters[0];\\n    }\\n};"
                    },
                    {
                        "username": "payek",
                        "content": " After seeing the Constraints, it's better to use linear search."
                    }
                ]
            },
            {
                "id": 1922355,
                "content": [
                    {
                        "username": "_garvit_goyal_",
                        "content": "in the test cast [\"c\",\"f\",\\'j\"] \\ntarget = \"g\"\\n\\nshowing output = \"c\"\\nand the expected answer is \"j\"\\nbut in every online compiler the answer coming out is \"j\""
                    },
                    {
                        "username": "treat",
                        "content": "Why it doesn\\'t accept a recursive solution?"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "oh, i dont know that, what a test cover :)). i think the cost of recursive is stack memory, almost stack size is 8M and align about 16byte(if the call in std pascal style), so you will have 512k call, i think you still use recursive on this without passing any argument. or you can emulate stack to do recursive"
                    },
                    {
                        "username": "Balgur",
                        "content": "```non-decreasing order```"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Set can be one of the option "
                    },
                    {
                        "username": "its_shubhamjha__",
                        "content": "its easy we can use binary search in this question .....  @"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "It\\'s good for practicing binary search."
                    },
                    {
                        "username": "ankit1478",
                        "content": "you can directly use binary search here \n"
                    },
                    {
                        "username": "Raghav_36",
                        "content": "use binary search\\n"
                    },
                    {
                        "username": "Praghna_K",
                        "content": "class Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n         for (char letter : letters) {\\n            if (letter > target) {\\n                return letter;\\n            }\\n        }\\n        return letters[0];\\n    }\\n};"
                    },
                    {
                        "username": "payek",
                        "content": " After seeing the Constraints, it's better to use linear search."
                    }
                ]
            },
            {
                "id": 1922313,
                "content": [
                    {
                        "username": "_garvit_goyal_",
                        "content": "in the test cast [\"c\",\"f\",\\'j\"] \\ntarget = \"g\"\\n\\nshowing output = \"c\"\\nand the expected answer is \"j\"\\nbut in every online compiler the answer coming out is \"j\""
                    },
                    {
                        "username": "treat",
                        "content": "Why it doesn\\'t accept a recursive solution?"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "oh, i dont know that, what a test cover :)). i think the cost of recursive is stack memory, almost stack size is 8M and align about 16byte(if the call in std pascal style), so you will have 512k call, i think you still use recursive on this without passing any argument. or you can emulate stack to do recursive"
                    },
                    {
                        "username": "Balgur",
                        "content": "```non-decreasing order```"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Set can be one of the option "
                    },
                    {
                        "username": "its_shubhamjha__",
                        "content": "its easy we can use binary search in this question .....  @"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "It\\'s good for practicing binary search."
                    },
                    {
                        "username": "ankit1478",
                        "content": "you can directly use binary search here \n"
                    },
                    {
                        "username": "Raghav_36",
                        "content": "use binary search\\n"
                    },
                    {
                        "username": "Praghna_K",
                        "content": "class Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n         for (char letter : letters) {\\n            if (letter > target) {\\n                return letter;\\n            }\\n        }\\n        return letters[0];\\n    }\\n};"
                    },
                    {
                        "username": "payek",
                        "content": " After seeing the Constraints, it's better to use linear search."
                    }
                ]
            },
            {
                "id": 1922276,
                "content": [
                    {
                        "username": "_garvit_goyal_",
                        "content": "in the test cast [\"c\",\"f\",\\'j\"] \\ntarget = \"g\"\\n\\nshowing output = \"c\"\\nand the expected answer is \"j\"\\nbut in every online compiler the answer coming out is \"j\""
                    },
                    {
                        "username": "treat",
                        "content": "Why it doesn\\'t accept a recursive solution?"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "oh, i dont know that, what a test cover :)). i think the cost of recursive is stack memory, almost stack size is 8M and align about 16byte(if the call in std pascal style), so you will have 512k call, i think you still use recursive on this without passing any argument. or you can emulate stack to do recursive"
                    },
                    {
                        "username": "Balgur",
                        "content": "```non-decreasing order```"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Set can be one of the option "
                    },
                    {
                        "username": "its_shubhamjha__",
                        "content": "its easy we can use binary search in this question .....  @"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "It\\'s good for practicing binary search."
                    },
                    {
                        "username": "ankit1478",
                        "content": "you can directly use binary search here \n"
                    },
                    {
                        "username": "Raghav_36",
                        "content": "use binary search\\n"
                    },
                    {
                        "username": "Praghna_K",
                        "content": "class Solution {\\npublic:\\n    char nextGreatestLetter(vector<char>& letters, char target) {\\n         for (char letter : letters) {\\n            if (letter > target) {\\n                return letter;\\n            }\\n        }\\n        return letters[0];\\n    }\\n};"
                    },
                    {
                        "username": "payek",
                        "content": " After seeing the Constraints, it's better to use linear search."
                    }
                ]
            },
            {
                "id": 1922268,
                "content": [
                    {
                        "username": "vetor",
                        "content": "easy on friday?\\n"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `\\n\\nfor(char letter : letters){\\n            if(letter > target){\\n                return letter;\\n            }\\n        }\\n        return letters[0];\\n\\n`"
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "in this q if target is not present in letters , we have to handle 2 cases .\n\n1) if there exists a value greater than target return it\n2) if target is the largest value , return letters[0] .\n\nif target is present , we check\n\n1)if any value greater than target , return it , else return letters[0]\nhope it helps"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "An easy week is going on"
                    },
                    {
                        "username": "surojitb",
                        "content": "I guess they removed the \"letters also wrap around\" from the question which was the reason for the large number of dislikes!"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Waaaaay too easy for Friday."
                    },
                    {
                        "username": "_SID_",
                        "content": "Simple Binary search"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "I hope LeetCode doesn\\'t give hard questions on weekends by giving the greed of easy questions."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "Leetcode be like \"just wait for the weekend\"!"
                    },
                    {
                        "username": "AYUSH_RAWAT_007",
                        "content": "Very easy problem, could be solved by binary search easily."
                    }
                ]
            },
            {
                "id": 1922221,
                "content": [
                    {
                        "username": "vetor",
                        "content": "easy on friday?\\n"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `\\n\\nfor(char letter : letters){\\n            if(letter > target){\\n                return letter;\\n            }\\n        }\\n        return letters[0];\\n\\n`"
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "in this q if target is not present in letters , we have to handle 2 cases .\n\n1) if there exists a value greater than target return it\n2) if target is the largest value , return letters[0] .\n\nif target is present , we check\n\n1)if any value greater than target , return it , else return letters[0]\nhope it helps"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "An easy week is going on"
                    },
                    {
                        "username": "surojitb",
                        "content": "I guess they removed the \"letters also wrap around\" from the question which was the reason for the large number of dislikes!"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Waaaaay too easy for Friday."
                    },
                    {
                        "username": "_SID_",
                        "content": "Simple Binary search"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "I hope LeetCode doesn\\'t give hard questions on weekends by giving the greed of easy questions."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "Leetcode be like \"just wait for the weekend\"!"
                    },
                    {
                        "username": "AYUSH_RAWAT_007",
                        "content": "Very easy problem, could be solved by binary search easily."
                    }
                ]
            },
            {
                "id": 1922178,
                "content": [
                    {
                        "username": "vetor",
                        "content": "easy on friday?\\n"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `\\n\\nfor(char letter : letters){\\n            if(letter > target){\\n                return letter;\\n            }\\n        }\\n        return letters[0];\\n\\n`"
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "in this q if target is not present in letters , we have to handle 2 cases .\n\n1) if there exists a value greater than target return it\n2) if target is the largest value , return letters[0] .\n\nif target is present , we check\n\n1)if any value greater than target , return it , else return letters[0]\nhope it helps"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "An easy week is going on"
                    },
                    {
                        "username": "surojitb",
                        "content": "I guess they removed the \"letters also wrap around\" from the question which was the reason for the large number of dislikes!"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Waaaaay too easy for Friday."
                    },
                    {
                        "username": "_SID_",
                        "content": "Simple Binary search"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "I hope LeetCode doesn\\'t give hard questions on weekends by giving the greed of easy questions."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "Leetcode be like \"just wait for the weekend\"!"
                    },
                    {
                        "username": "AYUSH_RAWAT_007",
                        "content": "Very easy problem, could be solved by binary search easily."
                    }
                ]
            },
            {
                "id": 1922163,
                "content": [
                    {
                        "username": "vetor",
                        "content": "easy on friday?\\n"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `\\n\\nfor(char letter : letters){\\n            if(letter > target){\\n                return letter;\\n            }\\n        }\\n        return letters[0];\\n\\n`"
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "in this q if target is not present in letters , we have to handle 2 cases .\n\n1) if there exists a value greater than target return it\n2) if target is the largest value , return letters[0] .\n\nif target is present , we check\n\n1)if any value greater than target , return it , else return letters[0]\nhope it helps"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "An easy week is going on"
                    },
                    {
                        "username": "surojitb",
                        "content": "I guess they removed the \"letters also wrap around\" from the question which was the reason for the large number of dislikes!"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Waaaaay too easy for Friday."
                    },
                    {
                        "username": "_SID_",
                        "content": "Simple Binary search"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "I hope LeetCode doesn\\'t give hard questions on weekends by giving the greed of easy questions."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "Leetcode be like \"just wait for the weekend\"!"
                    },
                    {
                        "username": "AYUSH_RAWAT_007",
                        "content": "Very easy problem, could be solved by binary search easily."
                    }
                ]
            },
            {
                "id": 1922122,
                "content": [
                    {
                        "username": "vetor",
                        "content": "easy on friday?\\n"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `\\n\\nfor(char letter : letters){\\n            if(letter > target){\\n                return letter;\\n            }\\n        }\\n        return letters[0];\\n\\n`"
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "in this q if target is not present in letters , we have to handle 2 cases .\n\n1) if there exists a value greater than target return it\n2) if target is the largest value , return letters[0] .\n\nif target is present , we check\n\n1)if any value greater than target , return it , else return letters[0]\nhope it helps"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "An easy week is going on"
                    },
                    {
                        "username": "surojitb",
                        "content": "I guess they removed the \"letters also wrap around\" from the question which was the reason for the large number of dislikes!"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Waaaaay too easy for Friday."
                    },
                    {
                        "username": "_SID_",
                        "content": "Simple Binary search"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "I hope LeetCode doesn\\'t give hard questions on weekends by giving the greed of easy questions."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "Leetcode be like \"just wait for the weekend\"!"
                    },
                    {
                        "username": "AYUSH_RAWAT_007",
                        "content": "Very easy problem, could be solved by binary search easily."
                    }
                ]
            },
            {
                "id": 1922117,
                "content": [
                    {
                        "username": "vetor",
                        "content": "easy on friday?\\n"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `\\n\\nfor(char letter : letters){\\n            if(letter > target){\\n                return letter;\\n            }\\n        }\\n        return letters[0];\\n\\n`"
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "in this q if target is not present in letters , we have to handle 2 cases .\n\n1) if there exists a value greater than target return it\n2) if target is the largest value , return letters[0] .\n\nif target is present , we check\n\n1)if any value greater than target , return it , else return letters[0]\nhope it helps"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "An easy week is going on"
                    },
                    {
                        "username": "surojitb",
                        "content": "I guess they removed the \"letters also wrap around\" from the question which was the reason for the large number of dislikes!"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Waaaaay too easy for Friday."
                    },
                    {
                        "username": "_SID_",
                        "content": "Simple Binary search"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "I hope LeetCode doesn\\'t give hard questions on weekends by giving the greed of easy questions."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "Leetcode be like \"just wait for the weekend\"!"
                    },
                    {
                        "username": "AYUSH_RAWAT_007",
                        "content": "Very easy problem, could be solved by binary search easily."
                    }
                ]
            },
            {
                "id": 1922099,
                "content": [
                    {
                        "username": "vetor",
                        "content": "easy on friday?\\n"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `\\n\\nfor(char letter : letters){\\n            if(letter > target){\\n                return letter;\\n            }\\n        }\\n        return letters[0];\\n\\n`"
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "in this q if target is not present in letters , we have to handle 2 cases .\n\n1) if there exists a value greater than target return it\n2) if target is the largest value , return letters[0] .\n\nif target is present , we check\n\n1)if any value greater than target , return it , else return letters[0]\nhope it helps"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "An easy week is going on"
                    },
                    {
                        "username": "surojitb",
                        "content": "I guess they removed the \"letters also wrap around\" from the question which was the reason for the large number of dislikes!"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Waaaaay too easy for Friday."
                    },
                    {
                        "username": "_SID_",
                        "content": "Simple Binary search"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "I hope LeetCode doesn\\'t give hard questions on weekends by giving the greed of easy questions."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "Leetcode be like \"just wait for the weekend\"!"
                    },
                    {
                        "username": "AYUSH_RAWAT_007",
                        "content": "Very easy problem, could be solved by binary search easily."
                    }
                ]
            },
            {
                "id": 1922058,
                "content": [
                    {
                        "username": "vetor",
                        "content": "easy on friday?\\n"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `\\n\\nfor(char letter : letters){\\n            if(letter > target){\\n                return letter;\\n            }\\n        }\\n        return letters[0];\\n\\n`"
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "in this q if target is not present in letters , we have to handle 2 cases .\n\n1) if there exists a value greater than target return it\n2) if target is the largest value , return letters[0] .\n\nif target is present , we check\n\n1)if any value greater than target , return it , else return letters[0]\nhope it helps"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "An easy week is going on"
                    },
                    {
                        "username": "surojitb",
                        "content": "I guess they removed the \"letters also wrap around\" from the question which was the reason for the large number of dislikes!"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Waaaaay too easy for Friday."
                    },
                    {
                        "username": "_SID_",
                        "content": "Simple Binary search"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "I hope LeetCode doesn\\'t give hard questions on weekends by giving the greed of easy questions."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "Leetcode be like \"just wait for the weekend\"!"
                    },
                    {
                        "username": "AYUSH_RAWAT_007",
                        "content": "Very easy problem, could be solved by binary search easily."
                    }
                ]
            },
            {
                "id": 1922018,
                "content": [
                    {
                        "username": "vetor",
                        "content": "easy on friday?\\n"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `\\n\\nfor(char letter : letters){\\n            if(letter > target){\\n                return letter;\\n            }\\n        }\\n        return letters[0];\\n\\n`"
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "in this q if target is not present in letters , we have to handle 2 cases .\n\n1) if there exists a value greater than target return it\n2) if target is the largest value , return letters[0] .\n\nif target is present , we check\n\n1)if any value greater than target , return it , else return letters[0]\nhope it helps"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "An easy week is going on"
                    },
                    {
                        "username": "surojitb",
                        "content": "I guess they removed the \"letters also wrap around\" from the question which was the reason for the large number of dislikes!"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Waaaaay too easy for Friday."
                    },
                    {
                        "username": "_SID_",
                        "content": "Simple Binary search"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "I hope LeetCode doesn\\'t give hard questions on weekends by giving the greed of easy questions."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "Leetcode be like \"just wait for the weekend\"!"
                    },
                    {
                        "username": "AYUSH_RAWAT_007",
                        "content": "Very easy problem, could be solved by binary search easily."
                    }
                ]
            },
            {
                "id": 1921997,
                "content": [
                    {
                        "username": "vetor",
                        "content": "easy on friday?\\n"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `\\n\\nfor(char letter : letters){\\n            if(letter > target){\\n                return letter;\\n            }\\n        }\\n        return letters[0];\\n\\n`"
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "in this q if target is not present in letters , we have to handle 2 cases .\n\n1) if there exists a value greater than target return it\n2) if target is the largest value , return letters[0] .\n\nif target is present , we check\n\n1)if any value greater than target , return it , else return letters[0]\nhope it helps"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "An easy week is going on"
                    },
                    {
                        "username": "surojitb",
                        "content": "I guess they removed the \"letters also wrap around\" from the question which was the reason for the large number of dislikes!"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Waaaaay too easy for Friday."
                    },
                    {
                        "username": "_SID_",
                        "content": "Simple Binary search"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "I hope LeetCode doesn\\'t give hard questions on weekends by giving the greed of easy questions."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "Leetcode be like \"just wait for the weekend\"!"
                    },
                    {
                        "username": "AYUSH_RAWAT_007",
                        "content": "Very easy problem, could be solved by binary search easily."
                    }
                ]
            },
            {
                "id": 1921990,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "BruteForce:Linear Search\\nOptimal : Binary Search\\n----------------------------\\nTime Complexity\\n**BruteForce---> T.C=O(n) \\nOptimal------>T.C=O(logn) \\nn==length of array.**\\n------------------------------\\nSpace Complexity\\n**BruteForce---> S.C=O(1) \\nOptimal------>S.C=O(1) \\nNo extra space in both method.**\\n--------------------------------\\nBruteForce: Traverse the array and check the first greatest element from target and if got the ans break from the loop noneed to iterate further because array is sorted. \\n-If the traversal is completed and no greater element found then return the first element of array.\\n---------------------------------\\n**Optimal:\\nStep1: Get the ASCII value of target by target-\\'a\\'.\\nStep2: initialize the low with 0 and high with length of array.\\niterate the array with help these two pointers.\\nStep3: find the mid. convert mid value of array to ASCII value.\\nStep4:if mid val1 is greater than the target value. Then there may be chance that the current value mid or the value before mid is answer. So do high==mid.\\nStep5: if mid value is less than or equal to target value. then move low pointer to mid+1.\\nStep6: If low reach to the end that mean no value greater than the target value. So return the first element of array.\\nStep7: else return the value at low pointer.**\\n------------------------------\\n\\nSolution link\\nhttps://leetcode.com/problems/find-smallest-letter-greater-than-target/solutions/3616368/brute-force-optimal-solution-c-java-python/"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "Don\\'t even try to run brute force approach....\\nResults will make you rethink your carrier decision... "
                    },
                    {
                        "username": "nishant101",
                        "content": "So the optimised Complexity is 26*logn right ?\\n"
                    },
                    {
                        "username": "Smuffinboy16",
                        "content": "Why does my code with lower_bound function is showing higher time complexity than normal for loop method??"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**EASY days==HAPPY days**"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "Can we do this problem by simple linear search "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Yes absolutely "
                    },
                    {
                        "username": "iamrohit3007",
                        "content": "int targetAscii = (int) target;\\nsnippet for cheaking/getting ASCII value in java"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Current problem setter loves easy questions."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "Tip : for solving a binary search problem , you just have to start writing the code , as you debug the solution you will be able to write the left test cases , this is the only way to make it correct . \\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s pray for tomorrow\\'s easy."
                    }
                ]
            },
            {
                "id": 1921981,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "BruteForce:Linear Search\\nOptimal : Binary Search\\n----------------------------\\nTime Complexity\\n**BruteForce---> T.C=O(n) \\nOptimal------>T.C=O(logn) \\nn==length of array.**\\n------------------------------\\nSpace Complexity\\n**BruteForce---> S.C=O(1) \\nOptimal------>S.C=O(1) \\nNo extra space in both method.**\\n--------------------------------\\nBruteForce: Traverse the array and check the first greatest element from target and if got the ans break from the loop noneed to iterate further because array is sorted. \\n-If the traversal is completed and no greater element found then return the first element of array.\\n---------------------------------\\n**Optimal:\\nStep1: Get the ASCII value of target by target-\\'a\\'.\\nStep2: initialize the low with 0 and high with length of array.\\niterate the array with help these two pointers.\\nStep3: find the mid. convert mid value of array to ASCII value.\\nStep4:if mid val1 is greater than the target value. Then there may be chance that the current value mid or the value before mid is answer. So do high==mid.\\nStep5: if mid value is less than or equal to target value. then move low pointer to mid+1.\\nStep6: If low reach to the end that mean no value greater than the target value. So return the first element of array.\\nStep7: else return the value at low pointer.**\\n------------------------------\\n\\nSolution link\\nhttps://leetcode.com/problems/find-smallest-letter-greater-than-target/solutions/3616368/brute-force-optimal-solution-c-java-python/"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "Don\\'t even try to run brute force approach....\\nResults will make you rethink your carrier decision... "
                    },
                    {
                        "username": "nishant101",
                        "content": "So the optimised Complexity is 26*logn right ?\\n"
                    },
                    {
                        "username": "Smuffinboy16",
                        "content": "Why does my code with lower_bound function is showing higher time complexity than normal for loop method??"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**EASY days==HAPPY days**"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "Can we do this problem by simple linear search "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Yes absolutely "
                    },
                    {
                        "username": "iamrohit3007",
                        "content": "int targetAscii = (int) target;\\nsnippet for cheaking/getting ASCII value in java"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Current problem setter loves easy questions."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "Tip : for solving a binary search problem , you just have to start writing the code , as you debug the solution you will be able to write the left test cases , this is the only way to make it correct . \\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s pray for tomorrow\\'s easy."
                    }
                ]
            },
            {
                "id": 1921979,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "BruteForce:Linear Search\\nOptimal : Binary Search\\n----------------------------\\nTime Complexity\\n**BruteForce---> T.C=O(n) \\nOptimal------>T.C=O(logn) \\nn==length of array.**\\n------------------------------\\nSpace Complexity\\n**BruteForce---> S.C=O(1) \\nOptimal------>S.C=O(1) \\nNo extra space in both method.**\\n--------------------------------\\nBruteForce: Traverse the array and check the first greatest element from target and if got the ans break from the loop noneed to iterate further because array is sorted. \\n-If the traversal is completed and no greater element found then return the first element of array.\\n---------------------------------\\n**Optimal:\\nStep1: Get the ASCII value of target by target-\\'a\\'.\\nStep2: initialize the low with 0 and high with length of array.\\niterate the array with help these two pointers.\\nStep3: find the mid. convert mid value of array to ASCII value.\\nStep4:if mid val1 is greater than the target value. Then there may be chance that the current value mid or the value before mid is answer. So do high==mid.\\nStep5: if mid value is less than or equal to target value. then move low pointer to mid+1.\\nStep6: If low reach to the end that mean no value greater than the target value. So return the first element of array.\\nStep7: else return the value at low pointer.**\\n------------------------------\\n\\nSolution link\\nhttps://leetcode.com/problems/find-smallest-letter-greater-than-target/solutions/3616368/brute-force-optimal-solution-c-java-python/"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "Don\\'t even try to run brute force approach....\\nResults will make you rethink your carrier decision... "
                    },
                    {
                        "username": "nishant101",
                        "content": "So the optimised Complexity is 26*logn right ?\\n"
                    },
                    {
                        "username": "Smuffinboy16",
                        "content": "Why does my code with lower_bound function is showing higher time complexity than normal for loop method??"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**EASY days==HAPPY days**"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "Can we do this problem by simple linear search "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Yes absolutely "
                    },
                    {
                        "username": "iamrohit3007",
                        "content": "int targetAscii = (int) target;\\nsnippet for cheaking/getting ASCII value in java"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Current problem setter loves easy questions."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "Tip : for solving a binary search problem , you just have to start writing the code , as you debug the solution you will be able to write the left test cases , this is the only way to make it correct . \\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s pray for tomorrow\\'s easy."
                    }
                ]
            },
            {
                "id": 1921962,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "BruteForce:Linear Search\\nOptimal : Binary Search\\n----------------------------\\nTime Complexity\\n**BruteForce---> T.C=O(n) \\nOptimal------>T.C=O(logn) \\nn==length of array.**\\n------------------------------\\nSpace Complexity\\n**BruteForce---> S.C=O(1) \\nOptimal------>S.C=O(1) \\nNo extra space in both method.**\\n--------------------------------\\nBruteForce: Traverse the array and check the first greatest element from target and if got the ans break from the loop noneed to iterate further because array is sorted. \\n-If the traversal is completed and no greater element found then return the first element of array.\\n---------------------------------\\n**Optimal:\\nStep1: Get the ASCII value of target by target-\\'a\\'.\\nStep2: initialize the low with 0 and high with length of array.\\niterate the array with help these two pointers.\\nStep3: find the mid. convert mid value of array to ASCII value.\\nStep4:if mid val1 is greater than the target value. Then there may be chance that the current value mid or the value before mid is answer. So do high==mid.\\nStep5: if mid value is less than or equal to target value. then move low pointer to mid+1.\\nStep6: If low reach to the end that mean no value greater than the target value. So return the first element of array.\\nStep7: else return the value at low pointer.**\\n------------------------------\\n\\nSolution link\\nhttps://leetcode.com/problems/find-smallest-letter-greater-than-target/solutions/3616368/brute-force-optimal-solution-c-java-python/"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "Don\\'t even try to run brute force approach....\\nResults will make you rethink your carrier decision... "
                    },
                    {
                        "username": "nishant101",
                        "content": "So the optimised Complexity is 26*logn right ?\\n"
                    },
                    {
                        "username": "Smuffinboy16",
                        "content": "Why does my code with lower_bound function is showing higher time complexity than normal for loop method??"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**EASY days==HAPPY days**"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "Can we do this problem by simple linear search "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Yes absolutely "
                    },
                    {
                        "username": "iamrohit3007",
                        "content": "int targetAscii = (int) target;\\nsnippet for cheaking/getting ASCII value in java"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Current problem setter loves easy questions."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "Tip : for solving a binary search problem , you just have to start writing the code , as you debug the solution you will be able to write the left test cases , this is the only way to make it correct . \\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s pray for tomorrow\\'s easy."
                    }
                ]
            },
            {
                "id": 1921943,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "BruteForce:Linear Search\\nOptimal : Binary Search\\n----------------------------\\nTime Complexity\\n**BruteForce---> T.C=O(n) \\nOptimal------>T.C=O(logn) \\nn==length of array.**\\n------------------------------\\nSpace Complexity\\n**BruteForce---> S.C=O(1) \\nOptimal------>S.C=O(1) \\nNo extra space in both method.**\\n--------------------------------\\nBruteForce: Traverse the array and check the first greatest element from target and if got the ans break from the loop noneed to iterate further because array is sorted. \\n-If the traversal is completed and no greater element found then return the first element of array.\\n---------------------------------\\n**Optimal:\\nStep1: Get the ASCII value of target by target-\\'a\\'.\\nStep2: initialize the low with 0 and high with length of array.\\niterate the array with help these two pointers.\\nStep3: find the mid. convert mid value of array to ASCII value.\\nStep4:if mid val1 is greater than the target value. Then there may be chance that the current value mid or the value before mid is answer. So do high==mid.\\nStep5: if mid value is less than or equal to target value. then move low pointer to mid+1.\\nStep6: If low reach to the end that mean no value greater than the target value. So return the first element of array.\\nStep7: else return the value at low pointer.**\\n------------------------------\\n\\nSolution link\\nhttps://leetcode.com/problems/find-smallest-letter-greater-than-target/solutions/3616368/brute-force-optimal-solution-c-java-python/"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "Don\\'t even try to run brute force approach....\\nResults will make you rethink your carrier decision... "
                    },
                    {
                        "username": "nishant101",
                        "content": "So the optimised Complexity is 26*logn right ?\\n"
                    },
                    {
                        "username": "Smuffinboy16",
                        "content": "Why does my code with lower_bound function is showing higher time complexity than normal for loop method??"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**EASY days==HAPPY days**"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "Can we do this problem by simple linear search "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Yes absolutely "
                    },
                    {
                        "username": "iamrohit3007",
                        "content": "int targetAscii = (int) target;\\nsnippet for cheaking/getting ASCII value in java"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Current problem setter loves easy questions."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "Tip : for solving a binary search problem , you just have to start writing the code , as you debug the solution you will be able to write the left test cases , this is the only way to make it correct . \\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s pray for tomorrow\\'s easy."
                    }
                ]
            },
            {
                "id": 1921941,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "BruteForce:Linear Search\\nOptimal : Binary Search\\n----------------------------\\nTime Complexity\\n**BruteForce---> T.C=O(n) \\nOptimal------>T.C=O(logn) \\nn==length of array.**\\n------------------------------\\nSpace Complexity\\n**BruteForce---> S.C=O(1) \\nOptimal------>S.C=O(1) \\nNo extra space in both method.**\\n--------------------------------\\nBruteForce: Traverse the array and check the first greatest element from target and if got the ans break from the loop noneed to iterate further because array is sorted. \\n-If the traversal is completed and no greater element found then return the first element of array.\\n---------------------------------\\n**Optimal:\\nStep1: Get the ASCII value of target by target-\\'a\\'.\\nStep2: initialize the low with 0 and high with length of array.\\niterate the array with help these two pointers.\\nStep3: find the mid. convert mid value of array to ASCII value.\\nStep4:if mid val1 is greater than the target value. Then there may be chance that the current value mid or the value before mid is answer. So do high==mid.\\nStep5: if mid value is less than or equal to target value. then move low pointer to mid+1.\\nStep6: If low reach to the end that mean no value greater than the target value. So return the first element of array.\\nStep7: else return the value at low pointer.**\\n------------------------------\\n\\nSolution link\\nhttps://leetcode.com/problems/find-smallest-letter-greater-than-target/solutions/3616368/brute-force-optimal-solution-c-java-python/"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "Don\\'t even try to run brute force approach....\\nResults will make you rethink your carrier decision... "
                    },
                    {
                        "username": "nishant101",
                        "content": "So the optimised Complexity is 26*logn right ?\\n"
                    },
                    {
                        "username": "Smuffinboy16",
                        "content": "Why does my code with lower_bound function is showing higher time complexity than normal for loop method??"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**EASY days==HAPPY days**"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "Can we do this problem by simple linear search "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Yes absolutely "
                    },
                    {
                        "username": "iamrohit3007",
                        "content": "int targetAscii = (int) target;\\nsnippet for cheaking/getting ASCII value in java"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Current problem setter loves easy questions."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "Tip : for solving a binary search problem , you just have to start writing the code , as you debug the solution you will be able to write the left test cases , this is the only way to make it correct . \\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s pray for tomorrow\\'s easy."
                    }
                ]
            },
            {
                "id": 1921886,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "BruteForce:Linear Search\\nOptimal : Binary Search\\n----------------------------\\nTime Complexity\\n**BruteForce---> T.C=O(n) \\nOptimal------>T.C=O(logn) \\nn==length of array.**\\n------------------------------\\nSpace Complexity\\n**BruteForce---> S.C=O(1) \\nOptimal------>S.C=O(1) \\nNo extra space in both method.**\\n--------------------------------\\nBruteForce: Traverse the array and check the first greatest element from target and if got the ans break from the loop noneed to iterate further because array is sorted. \\n-If the traversal is completed and no greater element found then return the first element of array.\\n---------------------------------\\n**Optimal:\\nStep1: Get the ASCII value of target by target-\\'a\\'.\\nStep2: initialize the low with 0 and high with length of array.\\niterate the array with help these two pointers.\\nStep3: find the mid. convert mid value of array to ASCII value.\\nStep4:if mid val1 is greater than the target value. Then there may be chance that the current value mid or the value before mid is answer. So do high==mid.\\nStep5: if mid value is less than or equal to target value. then move low pointer to mid+1.\\nStep6: If low reach to the end that mean no value greater than the target value. So return the first element of array.\\nStep7: else return the value at low pointer.**\\n------------------------------\\n\\nSolution link\\nhttps://leetcode.com/problems/find-smallest-letter-greater-than-target/solutions/3616368/brute-force-optimal-solution-c-java-python/"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "Don\\'t even try to run brute force approach....\\nResults will make you rethink your carrier decision... "
                    },
                    {
                        "username": "nishant101",
                        "content": "So the optimised Complexity is 26*logn right ?\\n"
                    },
                    {
                        "username": "Smuffinboy16",
                        "content": "Why does my code with lower_bound function is showing higher time complexity than normal for loop method??"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**EASY days==HAPPY days**"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "Can we do this problem by simple linear search "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Yes absolutely "
                    },
                    {
                        "username": "iamrohit3007",
                        "content": "int targetAscii = (int) target;\\nsnippet for cheaking/getting ASCII value in java"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Current problem setter loves easy questions."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "Tip : for solving a binary search problem , you just have to start writing the code , as you debug the solution you will be able to write the left test cases , this is the only way to make it correct . \\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s pray for tomorrow\\'s easy."
                    }
                ]
            },
            {
                "id": 1921884,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "BruteForce:Linear Search\\nOptimal : Binary Search\\n----------------------------\\nTime Complexity\\n**BruteForce---> T.C=O(n) \\nOptimal------>T.C=O(logn) \\nn==length of array.**\\n------------------------------\\nSpace Complexity\\n**BruteForce---> S.C=O(1) \\nOptimal------>S.C=O(1) \\nNo extra space in both method.**\\n--------------------------------\\nBruteForce: Traverse the array and check the first greatest element from target and if got the ans break from the loop noneed to iterate further because array is sorted. \\n-If the traversal is completed and no greater element found then return the first element of array.\\n---------------------------------\\n**Optimal:\\nStep1: Get the ASCII value of target by target-\\'a\\'.\\nStep2: initialize the low with 0 and high with length of array.\\niterate the array with help these two pointers.\\nStep3: find the mid. convert mid value of array to ASCII value.\\nStep4:if mid val1 is greater than the target value. Then there may be chance that the current value mid or the value before mid is answer. So do high==mid.\\nStep5: if mid value is less than or equal to target value. then move low pointer to mid+1.\\nStep6: If low reach to the end that mean no value greater than the target value. So return the first element of array.\\nStep7: else return the value at low pointer.**\\n------------------------------\\n\\nSolution link\\nhttps://leetcode.com/problems/find-smallest-letter-greater-than-target/solutions/3616368/brute-force-optimal-solution-c-java-python/"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "Don\\'t even try to run brute force approach....\\nResults will make you rethink your carrier decision... "
                    },
                    {
                        "username": "nishant101",
                        "content": "So the optimised Complexity is 26*logn right ?\\n"
                    },
                    {
                        "username": "Smuffinboy16",
                        "content": "Why does my code with lower_bound function is showing higher time complexity than normal for loop method??"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**EASY days==HAPPY days**"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "Can we do this problem by simple linear search "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Yes absolutely "
                    },
                    {
                        "username": "iamrohit3007",
                        "content": "int targetAscii = (int) target;\\nsnippet for cheaking/getting ASCII value in java"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Current problem setter loves easy questions."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "Tip : for solving a binary search problem , you just have to start writing the code , as you debug the solution you will be able to write the left test cases , this is the only way to make it correct . \\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s pray for tomorrow\\'s easy."
                    }
                ]
            },
            {
                "id": 1921859,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "BruteForce:Linear Search\\nOptimal : Binary Search\\n----------------------------\\nTime Complexity\\n**BruteForce---> T.C=O(n) \\nOptimal------>T.C=O(logn) \\nn==length of array.**\\n------------------------------\\nSpace Complexity\\n**BruteForce---> S.C=O(1) \\nOptimal------>S.C=O(1) \\nNo extra space in both method.**\\n--------------------------------\\nBruteForce: Traverse the array and check the first greatest element from target and if got the ans break from the loop noneed to iterate further because array is sorted. \\n-If the traversal is completed and no greater element found then return the first element of array.\\n---------------------------------\\n**Optimal:\\nStep1: Get the ASCII value of target by target-\\'a\\'.\\nStep2: initialize the low with 0 and high with length of array.\\niterate the array with help these two pointers.\\nStep3: find the mid. convert mid value of array to ASCII value.\\nStep4:if mid val1 is greater than the target value. Then there may be chance that the current value mid or the value before mid is answer. So do high==mid.\\nStep5: if mid value is less than or equal to target value. then move low pointer to mid+1.\\nStep6: If low reach to the end that mean no value greater than the target value. So return the first element of array.\\nStep7: else return the value at low pointer.**\\n------------------------------\\n\\nSolution link\\nhttps://leetcode.com/problems/find-smallest-letter-greater-than-target/solutions/3616368/brute-force-optimal-solution-c-java-python/"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "Don\\'t even try to run brute force approach....\\nResults will make you rethink your carrier decision... "
                    },
                    {
                        "username": "nishant101",
                        "content": "So the optimised Complexity is 26*logn right ?\\n"
                    },
                    {
                        "username": "Smuffinboy16",
                        "content": "Why does my code with lower_bound function is showing higher time complexity than normal for loop method??"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**EASY days==HAPPY days**"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "Can we do this problem by simple linear search "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Yes absolutely "
                    },
                    {
                        "username": "iamrohit3007",
                        "content": "int targetAscii = (int) target;\\nsnippet for cheaking/getting ASCII value in java"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Current problem setter loves easy questions."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "Tip : for solving a binary search problem , you just have to start writing the code , as you debug the solution you will be able to write the left test cases , this is the only way to make it correct . \\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s pray for tomorrow\\'s easy."
                    }
                ]
            },
            {
                "id": 1921851,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "BruteForce:Linear Search\\nOptimal : Binary Search\\n----------------------------\\nTime Complexity\\n**BruteForce---> T.C=O(n) \\nOptimal------>T.C=O(logn) \\nn==length of array.**\\n------------------------------\\nSpace Complexity\\n**BruteForce---> S.C=O(1) \\nOptimal------>S.C=O(1) \\nNo extra space in both method.**\\n--------------------------------\\nBruteForce: Traverse the array and check the first greatest element from target and if got the ans break from the loop noneed to iterate further because array is sorted. \\n-If the traversal is completed and no greater element found then return the first element of array.\\n---------------------------------\\n**Optimal:\\nStep1: Get the ASCII value of target by target-\\'a\\'.\\nStep2: initialize the low with 0 and high with length of array.\\niterate the array with help these two pointers.\\nStep3: find the mid. convert mid value of array to ASCII value.\\nStep4:if mid val1 is greater than the target value. Then there may be chance that the current value mid or the value before mid is answer. So do high==mid.\\nStep5: if mid value is less than or equal to target value. then move low pointer to mid+1.\\nStep6: If low reach to the end that mean no value greater than the target value. So return the first element of array.\\nStep7: else return the value at low pointer.**\\n------------------------------\\n\\nSolution link\\nhttps://leetcode.com/problems/find-smallest-letter-greater-than-target/solutions/3616368/brute-force-optimal-solution-c-java-python/"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "Don\\'t even try to run brute force approach....\\nResults will make you rethink your carrier decision... "
                    },
                    {
                        "username": "nishant101",
                        "content": "So the optimised Complexity is 26*logn right ?\\n"
                    },
                    {
                        "username": "Smuffinboy16",
                        "content": "Why does my code with lower_bound function is showing higher time complexity than normal for loop method??"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**EASY days==HAPPY days**"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "Can we do this problem by simple linear search "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Yes absolutely "
                    },
                    {
                        "username": "iamrohit3007",
                        "content": "int targetAscii = (int) target;\\nsnippet for cheaking/getting ASCII value in java"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Current problem setter loves easy questions."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "Tip : for solving a binary search problem , you just have to start writing the code , as you debug the solution you will be able to write the left test cases , this is the only way to make it correct . \\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s pray for tomorrow\\'s easy."
                    }
                ]
            },
            {
                "id": 1921832,
                "content": [
                    {
                        "username": "sfeingold",
                        "content": "\"sorted in non-decreasing order\"... so.. increasing order? \\uD83E\\uDD26"
                    },
                    {
                        "username": "psionl0",
                        "content": "No. [\"A\", \"B\", \"B\", \"C\"] is in non-decreasing order but not increasing order."
                    },
                    {
                        "username": "sushi27",
                        "content": "Wondering why so many down votes \\uD83D\\uDE44"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Earlier the question was not clear at all. You can check other comments and solutions mentioning the same. Leetcode has updated the problem statement."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Leetcode spoiling us with Easy\\'s for sometime now. \\nI think next few days will be continuously hards :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "Wow another easy (just basic binary search) question. We are really getting some gifts this month."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Yeah now it will be hards only for the next few days :D"
                    },
                    {
                        "username": "nikhills",
                        "content": "USING Binary search, it can be solved."
                    },
                    {
                        "username": "UdhayaK",
                        "content": "Clarification for using modulo here in the problem :\nIt means that the values are bound only bound to the array values .\nExample: If we start from 1 and ends at 10 then it only starts from 1 to 10 ,just bound to the range [1,10]\nin such cases if we want to count 11 times repeatedly in range [1,10] then use modulus 11%10==1 ,the answer for representing 11 in range [1,10] is 1.\nThe same trick in this question also just use modulus to solve the wrap around thing."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I wonder why such a naive problem has so many dislikes"
                    },
                    {
                        "username": "abdurrahmanshaikh830",
                        "content": "DETAILED EXPLANATION\\n# Intuition\\n<-- Array is sorted so we can use binary search. -->\\n\\n# Approach\\nIn binary search we used to return MID value but here we have to return the smallest letter which is greater then the target.\\nfor that run below condition inside while loop untill while(START <= END)\\n***\\nif(target < letters[mid]){\\n                end = mid - 1;\\n            }else{\\n                start = mid + 1;\\n            }\\n=\\nSAME AS WE DO IN BINARY SEARCH except the condition which is use to check if(TARGET == MID) and return the mid value when target found\\n***\\nthis condition will run until {START,MID and END} pointer point to the same element and in next itration when START become greater then END the condition (START <= END) will terminate then return START value(keep in mind that now START is pointing the value just greater then TARGET) so we can return START.\\n***\\nIt is also given that THE LETTERS WRAP AROUND means when there is no value greater then TARGET we have to return FIRST element.\\n***\\nfor that we can do\\n\\n[\\nif (start = = letters.length){\\n    return 0;\\n}\\n\\n<<<.....or....>>>\\n\\n***return letters[start % letters.length];***\\n\\nIt will work as if TARGET is not the last letter then it will return the letter just greater then the TARGET else it will return 0 {eg:- 2[START] % 4[LATTERS.LENGTH] = 2 but 4[START] % 4[LETTERS.LENGTH] = 0}\\n]\\n\\n***\\n\\nReturning START % LETTERS.LENGTH because when we perform modulo operation with any index which is less then last index it will return the same index[(3 % 10 = 3), (4 % 4 = 4), (10 % 10 = 0)] value but when it perform % with itself it will return 0 which match the condition of THE LETTERS WRAP AROUND will satisfy (remember that we have to return the value not index so \\nreturn letters[start % letters.length];)\\n\\n --> "
                    },
                    {
                        "username": "abanobraffet",
                        "content": "can someone solve it using c++ upper_bound( )  ??"
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "WHY THIS CODE IS SHOWING TLE ,i use Binary search in O(logn) coplexity\\n\\nint s=0,e=arr.size()-1,m;\\n        char ans=arr[0];\\n        while(s<=e){\\n            if(arr[m]>target){\\n                ans=arr[m];\\n                e=m-1;\\n            }\\n            else\\n                s=m+1;\\n        }\\n        return ans;"
                    }
                ]
            },
            {
                "id": 1921830,
                "content": [
                    {
                        "username": "sfeingold",
                        "content": "\"sorted in non-decreasing order\"... so.. increasing order? \\uD83E\\uDD26"
                    },
                    {
                        "username": "psionl0",
                        "content": "No. [\"A\", \"B\", \"B\", \"C\"] is in non-decreasing order but not increasing order."
                    },
                    {
                        "username": "sushi27",
                        "content": "Wondering why so many down votes \\uD83D\\uDE44"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Earlier the question was not clear at all. You can check other comments and solutions mentioning the same. Leetcode has updated the problem statement."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Leetcode spoiling us with Easy\\'s for sometime now. \\nI think next few days will be continuously hards :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "Wow another easy (just basic binary search) question. We are really getting some gifts this month."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Yeah now it will be hards only for the next few days :D"
                    },
                    {
                        "username": "nikhills",
                        "content": "USING Binary search, it can be solved."
                    },
                    {
                        "username": "UdhayaK",
                        "content": "Clarification for using modulo here in the problem :\nIt means that the values are bound only bound to the array values .\nExample: If we start from 1 and ends at 10 then it only starts from 1 to 10 ,just bound to the range [1,10]\nin such cases if we want to count 11 times repeatedly in range [1,10] then use modulus 11%10==1 ,the answer for representing 11 in range [1,10] is 1.\nThe same trick in this question also just use modulus to solve the wrap around thing."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I wonder why such a naive problem has so many dislikes"
                    },
                    {
                        "username": "abdurrahmanshaikh830",
                        "content": "DETAILED EXPLANATION\\n# Intuition\\n<-- Array is sorted so we can use binary search. -->\\n\\n# Approach\\nIn binary search we used to return MID value but here we have to return the smallest letter which is greater then the target.\\nfor that run below condition inside while loop untill while(START <= END)\\n***\\nif(target < letters[mid]){\\n                end = mid - 1;\\n            }else{\\n                start = mid + 1;\\n            }\\n=\\nSAME AS WE DO IN BINARY SEARCH except the condition which is use to check if(TARGET == MID) and return the mid value when target found\\n***\\nthis condition will run until {START,MID and END} pointer point to the same element and in next itration when START become greater then END the condition (START <= END) will terminate then return START value(keep in mind that now START is pointing the value just greater then TARGET) so we can return START.\\n***\\nIt is also given that THE LETTERS WRAP AROUND means when there is no value greater then TARGET we have to return FIRST element.\\n***\\nfor that we can do\\n\\n[\\nif (start = = letters.length){\\n    return 0;\\n}\\n\\n<<<.....or....>>>\\n\\n***return letters[start % letters.length];***\\n\\nIt will work as if TARGET is not the last letter then it will return the letter just greater then the TARGET else it will return 0 {eg:- 2[START] % 4[LATTERS.LENGTH] = 2 but 4[START] % 4[LETTERS.LENGTH] = 0}\\n]\\n\\n***\\n\\nReturning START % LETTERS.LENGTH because when we perform modulo operation with any index which is less then last index it will return the same index[(3 % 10 = 3), (4 % 4 = 4), (10 % 10 = 0)] value but when it perform % with itself it will return 0 which match the condition of THE LETTERS WRAP AROUND will satisfy (remember that we have to return the value not index so \\nreturn letters[start % letters.length];)\\n\\n --> "
                    },
                    {
                        "username": "abanobraffet",
                        "content": "can someone solve it using c++ upper_bound( )  ??"
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "WHY THIS CODE IS SHOWING TLE ,i use Binary search in O(logn) coplexity\\n\\nint s=0,e=arr.size()-1,m;\\n        char ans=arr[0];\\n        while(s<=e){\\n            if(arr[m]>target){\\n                ans=arr[m];\\n                e=m-1;\\n            }\\n            else\\n                s=m+1;\\n        }\\n        return ans;"
                    }
                ]
            },
            {
                "id": 1921822,
                "content": [
                    {
                        "username": "sfeingold",
                        "content": "\"sorted in non-decreasing order\"... so.. increasing order? \\uD83E\\uDD26"
                    },
                    {
                        "username": "psionl0",
                        "content": "No. [\"A\", \"B\", \"B\", \"C\"] is in non-decreasing order but not increasing order."
                    },
                    {
                        "username": "sushi27",
                        "content": "Wondering why so many down votes \\uD83D\\uDE44"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Earlier the question was not clear at all. You can check other comments and solutions mentioning the same. Leetcode has updated the problem statement."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Leetcode spoiling us with Easy\\'s for sometime now. \\nI think next few days will be continuously hards :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "Wow another easy (just basic binary search) question. We are really getting some gifts this month."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Yeah now it will be hards only for the next few days :D"
                    },
                    {
                        "username": "nikhills",
                        "content": "USING Binary search, it can be solved."
                    },
                    {
                        "username": "UdhayaK",
                        "content": "Clarification for using modulo here in the problem :\nIt means that the values are bound only bound to the array values .\nExample: If we start from 1 and ends at 10 then it only starts from 1 to 10 ,just bound to the range [1,10]\nin such cases if we want to count 11 times repeatedly in range [1,10] then use modulus 11%10==1 ,the answer for representing 11 in range [1,10] is 1.\nThe same trick in this question also just use modulus to solve the wrap around thing."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I wonder why such a naive problem has so many dislikes"
                    },
                    {
                        "username": "abdurrahmanshaikh830",
                        "content": "DETAILED EXPLANATION\\n# Intuition\\n<-- Array is sorted so we can use binary search. -->\\n\\n# Approach\\nIn binary search we used to return MID value but here we have to return the smallest letter which is greater then the target.\\nfor that run below condition inside while loop untill while(START <= END)\\n***\\nif(target < letters[mid]){\\n                end = mid - 1;\\n            }else{\\n                start = mid + 1;\\n            }\\n=\\nSAME AS WE DO IN BINARY SEARCH except the condition which is use to check if(TARGET == MID) and return the mid value when target found\\n***\\nthis condition will run until {START,MID and END} pointer point to the same element and in next itration when START become greater then END the condition (START <= END) will terminate then return START value(keep in mind that now START is pointing the value just greater then TARGET) so we can return START.\\n***\\nIt is also given that THE LETTERS WRAP AROUND means when there is no value greater then TARGET we have to return FIRST element.\\n***\\nfor that we can do\\n\\n[\\nif (start = = letters.length){\\n    return 0;\\n}\\n\\n<<<.....or....>>>\\n\\n***return letters[start % letters.length];***\\n\\nIt will work as if TARGET is not the last letter then it will return the letter just greater then the TARGET else it will return 0 {eg:- 2[START] % 4[LATTERS.LENGTH] = 2 but 4[START] % 4[LETTERS.LENGTH] = 0}\\n]\\n\\n***\\n\\nReturning START % LETTERS.LENGTH because when we perform modulo operation with any index which is less then last index it will return the same index[(3 % 10 = 3), (4 % 4 = 4), (10 % 10 = 0)] value but when it perform % with itself it will return 0 which match the condition of THE LETTERS WRAP AROUND will satisfy (remember that we have to return the value not index so \\nreturn letters[start % letters.length];)\\n\\n --> "
                    },
                    {
                        "username": "abanobraffet",
                        "content": "can someone solve it using c++ upper_bound( )  ??"
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "WHY THIS CODE IS SHOWING TLE ,i use Binary search in O(logn) coplexity\\n\\nint s=0,e=arr.size()-1,m;\\n        char ans=arr[0];\\n        while(s<=e){\\n            if(arr[m]>target){\\n                ans=arr[m];\\n                e=m-1;\\n            }\\n            else\\n                s=m+1;\\n        }\\n        return ans;"
                    }
                ]
            },
            {
                "id": 1921813,
                "content": [
                    {
                        "username": "sfeingold",
                        "content": "\"sorted in non-decreasing order\"... so.. increasing order? \\uD83E\\uDD26"
                    },
                    {
                        "username": "psionl0",
                        "content": "No. [\"A\", \"B\", \"B\", \"C\"] is in non-decreasing order but not increasing order."
                    },
                    {
                        "username": "sushi27",
                        "content": "Wondering why so many down votes \\uD83D\\uDE44"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Earlier the question was not clear at all. You can check other comments and solutions mentioning the same. Leetcode has updated the problem statement."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Leetcode spoiling us with Easy\\'s for sometime now. \\nI think next few days will be continuously hards :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "Wow another easy (just basic binary search) question. We are really getting some gifts this month."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Yeah now it will be hards only for the next few days :D"
                    },
                    {
                        "username": "nikhills",
                        "content": "USING Binary search, it can be solved."
                    },
                    {
                        "username": "UdhayaK",
                        "content": "Clarification for using modulo here in the problem :\nIt means that the values are bound only bound to the array values .\nExample: If we start from 1 and ends at 10 then it only starts from 1 to 10 ,just bound to the range [1,10]\nin such cases if we want to count 11 times repeatedly in range [1,10] then use modulus 11%10==1 ,the answer for representing 11 in range [1,10] is 1.\nThe same trick in this question also just use modulus to solve the wrap around thing."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I wonder why such a naive problem has so many dislikes"
                    },
                    {
                        "username": "abdurrahmanshaikh830",
                        "content": "DETAILED EXPLANATION\\n# Intuition\\n<-- Array is sorted so we can use binary search. -->\\n\\n# Approach\\nIn binary search we used to return MID value but here we have to return the smallest letter which is greater then the target.\\nfor that run below condition inside while loop untill while(START <= END)\\n***\\nif(target < letters[mid]){\\n                end = mid - 1;\\n            }else{\\n                start = mid + 1;\\n            }\\n=\\nSAME AS WE DO IN BINARY SEARCH except the condition which is use to check if(TARGET == MID) and return the mid value when target found\\n***\\nthis condition will run until {START,MID and END} pointer point to the same element and in next itration when START become greater then END the condition (START <= END) will terminate then return START value(keep in mind that now START is pointing the value just greater then TARGET) so we can return START.\\n***\\nIt is also given that THE LETTERS WRAP AROUND means when there is no value greater then TARGET we have to return FIRST element.\\n***\\nfor that we can do\\n\\n[\\nif (start = = letters.length){\\n    return 0;\\n}\\n\\n<<<.....or....>>>\\n\\n***return letters[start % letters.length];***\\n\\nIt will work as if TARGET is not the last letter then it will return the letter just greater then the TARGET else it will return 0 {eg:- 2[START] % 4[LATTERS.LENGTH] = 2 but 4[START] % 4[LETTERS.LENGTH] = 0}\\n]\\n\\n***\\n\\nReturning START % LETTERS.LENGTH because when we perform modulo operation with any index which is less then last index it will return the same index[(3 % 10 = 3), (4 % 4 = 4), (10 % 10 = 0)] value but when it perform % with itself it will return 0 which match the condition of THE LETTERS WRAP AROUND will satisfy (remember that we have to return the value not index so \\nreturn letters[start % letters.length];)\\n\\n --> "
                    },
                    {
                        "username": "abanobraffet",
                        "content": "can someone solve it using c++ upper_bound( )  ??"
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "WHY THIS CODE IS SHOWING TLE ,i use Binary search in O(logn) coplexity\\n\\nint s=0,e=arr.size()-1,m;\\n        char ans=arr[0];\\n        while(s<=e){\\n            if(arr[m]>target){\\n                ans=arr[m];\\n                e=m-1;\\n            }\\n            else\\n                s=m+1;\\n        }\\n        return ans;"
                    }
                ]
            },
            {
                "id": 1801857,
                "content": [
                    {
                        "username": "sfeingold",
                        "content": "\"sorted in non-decreasing order\"... so.. increasing order? \\uD83E\\uDD26"
                    },
                    {
                        "username": "psionl0",
                        "content": "No. [\"A\", \"B\", \"B\", \"C\"] is in non-decreasing order but not increasing order."
                    },
                    {
                        "username": "sushi27",
                        "content": "Wondering why so many down votes \\uD83D\\uDE44"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Earlier the question was not clear at all. You can check other comments and solutions mentioning the same. Leetcode has updated the problem statement."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Leetcode spoiling us with Easy\\'s for sometime now. \\nI think next few days will be continuously hards :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "Wow another easy (just basic binary search) question. We are really getting some gifts this month."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Yeah now it will be hards only for the next few days :D"
                    },
                    {
                        "username": "nikhills",
                        "content": "USING Binary search, it can be solved."
                    },
                    {
                        "username": "UdhayaK",
                        "content": "Clarification for using modulo here in the problem :\nIt means that the values are bound only bound to the array values .\nExample: If we start from 1 and ends at 10 then it only starts from 1 to 10 ,just bound to the range [1,10]\nin such cases if we want to count 11 times repeatedly in range [1,10] then use modulus 11%10==1 ,the answer for representing 11 in range [1,10] is 1.\nThe same trick in this question also just use modulus to solve the wrap around thing."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I wonder why such a naive problem has so many dislikes"
                    },
                    {
                        "username": "abdurrahmanshaikh830",
                        "content": "DETAILED EXPLANATION\\n# Intuition\\n<-- Array is sorted so we can use binary search. -->\\n\\n# Approach\\nIn binary search we used to return MID value but here we have to return the smallest letter which is greater then the target.\\nfor that run below condition inside while loop untill while(START <= END)\\n***\\nif(target < letters[mid]){\\n                end = mid - 1;\\n            }else{\\n                start = mid + 1;\\n            }\\n=\\nSAME AS WE DO IN BINARY SEARCH except the condition which is use to check if(TARGET == MID) and return the mid value when target found\\n***\\nthis condition will run until {START,MID and END} pointer point to the same element and in next itration when START become greater then END the condition (START <= END) will terminate then return START value(keep in mind that now START is pointing the value just greater then TARGET) so we can return START.\\n***\\nIt is also given that THE LETTERS WRAP AROUND means when there is no value greater then TARGET we have to return FIRST element.\\n***\\nfor that we can do\\n\\n[\\nif (start = = letters.length){\\n    return 0;\\n}\\n\\n<<<.....or....>>>\\n\\n***return letters[start % letters.length];***\\n\\nIt will work as if TARGET is not the last letter then it will return the letter just greater then the TARGET else it will return 0 {eg:- 2[START] % 4[LATTERS.LENGTH] = 2 but 4[START] % 4[LETTERS.LENGTH] = 0}\\n]\\n\\n***\\n\\nReturning START % LETTERS.LENGTH because when we perform modulo operation with any index which is less then last index it will return the same index[(3 % 10 = 3), (4 % 4 = 4), (10 % 10 = 0)] value but when it perform % with itself it will return 0 which match the condition of THE LETTERS WRAP AROUND will satisfy (remember that we have to return the value not index so \\nreturn letters[start % letters.length];)\\n\\n --> "
                    },
                    {
                        "username": "abanobraffet",
                        "content": "can someone solve it using c++ upper_bound( )  ??"
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "WHY THIS CODE IS SHOWING TLE ,i use Binary search in O(logn) coplexity\\n\\nint s=0,e=arr.size()-1,m;\\n        char ans=arr[0];\\n        while(s<=e){\\n            if(arr[m]>target){\\n                ans=arr[m];\\n                e=m-1;\\n            }\\n            else\\n                s=m+1;\\n        }\\n        return ans;"
                    }
                ]
            },
            {
                "id": 1796715,
                "content": [
                    {
                        "username": "sfeingold",
                        "content": "\"sorted in non-decreasing order\"... so.. increasing order? \\uD83E\\uDD26"
                    },
                    {
                        "username": "psionl0",
                        "content": "No. [\"A\", \"B\", \"B\", \"C\"] is in non-decreasing order but not increasing order."
                    },
                    {
                        "username": "sushi27",
                        "content": "Wondering why so many down votes \\uD83D\\uDE44"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Earlier the question was not clear at all. You can check other comments and solutions mentioning the same. Leetcode has updated the problem statement."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Leetcode spoiling us with Easy\\'s for sometime now. \\nI think next few days will be continuously hards :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "Wow another easy (just basic binary search) question. We are really getting some gifts this month."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Yeah now it will be hards only for the next few days :D"
                    },
                    {
                        "username": "nikhills",
                        "content": "USING Binary search, it can be solved."
                    },
                    {
                        "username": "UdhayaK",
                        "content": "Clarification for using modulo here in the problem :\nIt means that the values are bound only bound to the array values .\nExample: If we start from 1 and ends at 10 then it only starts from 1 to 10 ,just bound to the range [1,10]\nin such cases if we want to count 11 times repeatedly in range [1,10] then use modulus 11%10==1 ,the answer for representing 11 in range [1,10] is 1.\nThe same trick in this question also just use modulus to solve the wrap around thing."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I wonder why such a naive problem has so many dislikes"
                    },
                    {
                        "username": "abdurrahmanshaikh830",
                        "content": "DETAILED EXPLANATION\\n# Intuition\\n<-- Array is sorted so we can use binary search. -->\\n\\n# Approach\\nIn binary search we used to return MID value but here we have to return the smallest letter which is greater then the target.\\nfor that run below condition inside while loop untill while(START <= END)\\n***\\nif(target < letters[mid]){\\n                end = mid - 1;\\n            }else{\\n                start = mid + 1;\\n            }\\n=\\nSAME AS WE DO IN BINARY SEARCH except the condition which is use to check if(TARGET == MID) and return the mid value when target found\\n***\\nthis condition will run until {START,MID and END} pointer point to the same element and in next itration when START become greater then END the condition (START <= END) will terminate then return START value(keep in mind that now START is pointing the value just greater then TARGET) so we can return START.\\n***\\nIt is also given that THE LETTERS WRAP AROUND means when there is no value greater then TARGET we have to return FIRST element.\\n***\\nfor that we can do\\n\\n[\\nif (start = = letters.length){\\n    return 0;\\n}\\n\\n<<<.....or....>>>\\n\\n***return letters[start % letters.length];***\\n\\nIt will work as if TARGET is not the last letter then it will return the letter just greater then the TARGET else it will return 0 {eg:- 2[START] % 4[LATTERS.LENGTH] = 2 but 4[START] % 4[LETTERS.LENGTH] = 0}\\n]\\n\\n***\\n\\nReturning START % LETTERS.LENGTH because when we perform modulo operation with any index which is less then last index it will return the same index[(3 % 10 = 3), (4 % 4 = 4), (10 % 10 = 0)] value but when it perform % with itself it will return 0 which match the condition of THE LETTERS WRAP AROUND will satisfy (remember that we have to return the value not index so \\nreturn letters[start % letters.length];)\\n\\n --> "
                    },
                    {
                        "username": "abanobraffet",
                        "content": "can someone solve it using c++ upper_bound( )  ??"
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "WHY THIS CODE IS SHOWING TLE ,i use Binary search in O(logn) coplexity\\n\\nint s=0,e=arr.size()-1,m;\\n        char ans=arr[0];\\n        while(s<=e){\\n            if(arr[m]>target){\\n                ans=arr[m];\\n                e=m-1;\\n            }\\n            else\\n                s=m+1;\\n        }\\n        return ans;"
                    }
                ]
            },
            {
                "id": 1785806,
                "content": [
                    {
                        "username": "sfeingold",
                        "content": "\"sorted in non-decreasing order\"... so.. increasing order? \\uD83E\\uDD26"
                    },
                    {
                        "username": "psionl0",
                        "content": "No. [\"A\", \"B\", \"B\", \"C\"] is in non-decreasing order but not increasing order."
                    },
                    {
                        "username": "sushi27",
                        "content": "Wondering why so many down votes \\uD83D\\uDE44"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Earlier the question was not clear at all. You can check other comments and solutions mentioning the same. Leetcode has updated the problem statement."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Leetcode spoiling us with Easy\\'s for sometime now. \\nI think next few days will be continuously hards :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "Wow another easy (just basic binary search) question. We are really getting some gifts this month."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Yeah now it will be hards only for the next few days :D"
                    },
                    {
                        "username": "nikhills",
                        "content": "USING Binary search, it can be solved."
                    },
                    {
                        "username": "UdhayaK",
                        "content": "Clarification for using modulo here in the problem :\nIt means that the values are bound only bound to the array values .\nExample: If we start from 1 and ends at 10 then it only starts from 1 to 10 ,just bound to the range [1,10]\nin such cases if we want to count 11 times repeatedly in range [1,10] then use modulus 11%10==1 ,the answer for representing 11 in range [1,10] is 1.\nThe same trick in this question also just use modulus to solve the wrap around thing."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I wonder why such a naive problem has so many dislikes"
                    },
                    {
                        "username": "abdurrahmanshaikh830",
                        "content": "DETAILED EXPLANATION\\n# Intuition\\n<-- Array is sorted so we can use binary search. -->\\n\\n# Approach\\nIn binary search we used to return MID value but here we have to return the smallest letter which is greater then the target.\\nfor that run below condition inside while loop untill while(START <= END)\\n***\\nif(target < letters[mid]){\\n                end = mid - 1;\\n            }else{\\n                start = mid + 1;\\n            }\\n=\\nSAME AS WE DO IN BINARY SEARCH except the condition which is use to check if(TARGET == MID) and return the mid value when target found\\n***\\nthis condition will run until {START,MID and END} pointer point to the same element and in next itration when START become greater then END the condition (START <= END) will terminate then return START value(keep in mind that now START is pointing the value just greater then TARGET) so we can return START.\\n***\\nIt is also given that THE LETTERS WRAP AROUND means when there is no value greater then TARGET we have to return FIRST element.\\n***\\nfor that we can do\\n\\n[\\nif (start = = letters.length){\\n    return 0;\\n}\\n\\n<<<.....or....>>>\\n\\n***return letters[start % letters.length];***\\n\\nIt will work as if TARGET is not the last letter then it will return the letter just greater then the TARGET else it will return 0 {eg:- 2[START] % 4[LATTERS.LENGTH] = 2 but 4[START] % 4[LETTERS.LENGTH] = 0}\\n]\\n\\n***\\n\\nReturning START % LETTERS.LENGTH because when we perform modulo operation with any index which is less then last index it will return the same index[(3 % 10 = 3), (4 % 4 = 4), (10 % 10 = 0)] value but when it perform % with itself it will return 0 which match the condition of THE LETTERS WRAP AROUND will satisfy (remember that we have to return the value not index so \\nreturn letters[start % letters.length];)\\n\\n --> "
                    },
                    {
                        "username": "abanobraffet",
                        "content": "can someone solve it using c++ upper_bound( )  ??"
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "WHY THIS CODE IS SHOWING TLE ,i use Binary search in O(logn) coplexity\\n\\nint s=0,e=arr.size()-1,m;\\n        char ans=arr[0];\\n        while(s<=e){\\n            if(arr[m]>target){\\n                ans=arr[m];\\n                e=m-1;\\n            }\\n            else\\n                s=m+1;\\n        }\\n        return ans;"
                    }
                ]
            },
            {
                "id": 1775464,
                "content": [
                    {
                        "username": "sfeingold",
                        "content": "\"sorted in non-decreasing order\"... so.. increasing order? \\uD83E\\uDD26"
                    },
                    {
                        "username": "psionl0",
                        "content": "No. [\"A\", \"B\", \"B\", \"C\"] is in non-decreasing order but not increasing order."
                    },
                    {
                        "username": "sushi27",
                        "content": "Wondering why so many down votes \\uD83D\\uDE44"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Earlier the question was not clear at all. You can check other comments and solutions mentioning the same. Leetcode has updated the problem statement."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Leetcode spoiling us with Easy\\'s for sometime now. \\nI think next few days will be continuously hards :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "Wow another easy (just basic binary search) question. We are really getting some gifts this month."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Yeah now it will be hards only for the next few days :D"
                    },
                    {
                        "username": "nikhills",
                        "content": "USING Binary search, it can be solved."
                    },
                    {
                        "username": "UdhayaK",
                        "content": "Clarification for using modulo here in the problem :\nIt means that the values are bound only bound to the array values .\nExample: If we start from 1 and ends at 10 then it only starts from 1 to 10 ,just bound to the range [1,10]\nin such cases if we want to count 11 times repeatedly in range [1,10] then use modulus 11%10==1 ,the answer for representing 11 in range [1,10] is 1.\nThe same trick in this question also just use modulus to solve the wrap around thing."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I wonder why such a naive problem has so many dislikes"
                    },
                    {
                        "username": "abdurrahmanshaikh830",
                        "content": "DETAILED EXPLANATION\\n# Intuition\\n<-- Array is sorted so we can use binary search. -->\\n\\n# Approach\\nIn binary search we used to return MID value but here we have to return the smallest letter which is greater then the target.\\nfor that run below condition inside while loop untill while(START <= END)\\n***\\nif(target < letters[mid]){\\n                end = mid - 1;\\n            }else{\\n                start = mid + 1;\\n            }\\n=\\nSAME AS WE DO IN BINARY SEARCH except the condition which is use to check if(TARGET == MID) and return the mid value when target found\\n***\\nthis condition will run until {START,MID and END} pointer point to the same element and in next itration when START become greater then END the condition (START <= END) will terminate then return START value(keep in mind that now START is pointing the value just greater then TARGET) so we can return START.\\n***\\nIt is also given that THE LETTERS WRAP AROUND means when there is no value greater then TARGET we have to return FIRST element.\\n***\\nfor that we can do\\n\\n[\\nif (start = = letters.length){\\n    return 0;\\n}\\n\\n<<<.....or....>>>\\n\\n***return letters[start % letters.length];***\\n\\nIt will work as if TARGET is not the last letter then it will return the letter just greater then the TARGET else it will return 0 {eg:- 2[START] % 4[LATTERS.LENGTH] = 2 but 4[START] % 4[LETTERS.LENGTH] = 0}\\n]\\n\\n***\\n\\nReturning START % LETTERS.LENGTH because when we perform modulo operation with any index which is less then last index it will return the same index[(3 % 10 = 3), (4 % 4 = 4), (10 % 10 = 0)] value but when it perform % with itself it will return 0 which match the condition of THE LETTERS WRAP AROUND will satisfy (remember that we have to return the value not index so \\nreturn letters[start % letters.length];)\\n\\n --> "
                    },
                    {
                        "username": "abanobraffet",
                        "content": "can someone solve it using c++ upper_bound( )  ??"
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "WHY THIS CODE IS SHOWING TLE ,i use Binary search in O(logn) coplexity\\n\\nint s=0,e=arr.size()-1,m;\\n        char ans=arr[0];\\n        while(s<=e){\\n            if(arr[m]>target){\\n                ans=arr[m];\\n                e=m-1;\\n            }\\n            else\\n                s=m+1;\\n        }\\n        return ans;"
                    }
                ]
            },
            {
                "id": 1757444,
                "content": [
                    {
                        "username": "sfeingold",
                        "content": "\"sorted in non-decreasing order\"... so.. increasing order? \\uD83E\\uDD26"
                    },
                    {
                        "username": "psionl0",
                        "content": "No. [\"A\", \"B\", \"B\", \"C\"] is in non-decreasing order but not increasing order."
                    },
                    {
                        "username": "sushi27",
                        "content": "Wondering why so many down votes \\uD83D\\uDE44"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Earlier the question was not clear at all. You can check other comments and solutions mentioning the same. Leetcode has updated the problem statement."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Leetcode spoiling us with Easy\\'s for sometime now. \\nI think next few days will be continuously hards :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "Wow another easy (just basic binary search) question. We are really getting some gifts this month."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Yeah now it will be hards only for the next few days :D"
                    },
                    {
                        "username": "nikhills",
                        "content": "USING Binary search, it can be solved."
                    },
                    {
                        "username": "UdhayaK",
                        "content": "Clarification for using modulo here in the problem :\nIt means that the values are bound only bound to the array values .\nExample: If we start from 1 and ends at 10 then it only starts from 1 to 10 ,just bound to the range [1,10]\nin such cases if we want to count 11 times repeatedly in range [1,10] then use modulus 11%10==1 ,the answer for representing 11 in range [1,10] is 1.\nThe same trick in this question also just use modulus to solve the wrap around thing."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I wonder why such a naive problem has so many dislikes"
                    },
                    {
                        "username": "abdurrahmanshaikh830",
                        "content": "DETAILED EXPLANATION\\n# Intuition\\n<-- Array is sorted so we can use binary search. -->\\n\\n# Approach\\nIn binary search we used to return MID value but here we have to return the smallest letter which is greater then the target.\\nfor that run below condition inside while loop untill while(START <= END)\\n***\\nif(target < letters[mid]){\\n                end = mid - 1;\\n            }else{\\n                start = mid + 1;\\n            }\\n=\\nSAME AS WE DO IN BINARY SEARCH except the condition which is use to check if(TARGET == MID) and return the mid value when target found\\n***\\nthis condition will run until {START,MID and END} pointer point to the same element and in next itration when START become greater then END the condition (START <= END) will terminate then return START value(keep in mind that now START is pointing the value just greater then TARGET) so we can return START.\\n***\\nIt is also given that THE LETTERS WRAP AROUND means when there is no value greater then TARGET we have to return FIRST element.\\n***\\nfor that we can do\\n\\n[\\nif (start = = letters.length){\\n    return 0;\\n}\\n\\n<<<.....or....>>>\\n\\n***return letters[start % letters.length];***\\n\\nIt will work as if TARGET is not the last letter then it will return the letter just greater then the TARGET else it will return 0 {eg:- 2[START] % 4[LATTERS.LENGTH] = 2 but 4[START] % 4[LETTERS.LENGTH] = 0}\\n]\\n\\n***\\n\\nReturning START % LETTERS.LENGTH because when we perform modulo operation with any index which is less then last index it will return the same index[(3 % 10 = 3), (4 % 4 = 4), (10 % 10 = 0)] value but when it perform % with itself it will return 0 which match the condition of THE LETTERS WRAP AROUND will satisfy (remember that we have to return the value not index so \\nreturn letters[start % letters.length];)\\n\\n --> "
                    },
                    {
                        "username": "abanobraffet",
                        "content": "can someone solve it using c++ upper_bound( )  ??"
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "WHY THIS CODE IS SHOWING TLE ,i use Binary search in O(logn) coplexity\\n\\nint s=0,e=arr.size()-1,m;\\n        char ans=arr[0];\\n        while(s<=e){\\n            if(arr[m]>target){\\n                ans=arr[m];\\n                e=m-1;\\n            }\\n            else\\n                s=m+1;\\n        }\\n        return ans;"
                    }
                ]
            },
            {
                "id": 1749692,
                "content": [
                    {
                        "username": "sfeingold",
                        "content": "\"sorted in non-decreasing order\"... so.. increasing order? \\uD83E\\uDD26"
                    },
                    {
                        "username": "psionl0",
                        "content": "No. [\"A\", \"B\", \"B\", \"C\"] is in non-decreasing order but not increasing order."
                    },
                    {
                        "username": "sushi27",
                        "content": "Wondering why so many down votes \\uD83D\\uDE44"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Earlier the question was not clear at all. You can check other comments and solutions mentioning the same. Leetcode has updated the problem statement."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Leetcode spoiling us with Easy\\'s for sometime now. \\nI think next few days will be continuously hards :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "Wow another easy (just basic binary search) question. We are really getting some gifts this month."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Yeah now it will be hards only for the next few days :D"
                    },
                    {
                        "username": "nikhills",
                        "content": "USING Binary search, it can be solved."
                    },
                    {
                        "username": "UdhayaK",
                        "content": "Clarification for using modulo here in the problem :\nIt means that the values are bound only bound to the array values .\nExample: If we start from 1 and ends at 10 then it only starts from 1 to 10 ,just bound to the range [1,10]\nin such cases if we want to count 11 times repeatedly in range [1,10] then use modulus 11%10==1 ,the answer for representing 11 in range [1,10] is 1.\nThe same trick in this question also just use modulus to solve the wrap around thing."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I wonder why such a naive problem has so many dislikes"
                    },
                    {
                        "username": "abdurrahmanshaikh830",
                        "content": "DETAILED EXPLANATION\\n# Intuition\\n<-- Array is sorted so we can use binary search. -->\\n\\n# Approach\\nIn binary search we used to return MID value but here we have to return the smallest letter which is greater then the target.\\nfor that run below condition inside while loop untill while(START <= END)\\n***\\nif(target < letters[mid]){\\n                end = mid - 1;\\n            }else{\\n                start = mid + 1;\\n            }\\n=\\nSAME AS WE DO IN BINARY SEARCH except the condition which is use to check if(TARGET == MID) and return the mid value when target found\\n***\\nthis condition will run until {START,MID and END} pointer point to the same element and in next itration when START become greater then END the condition (START <= END) will terminate then return START value(keep in mind that now START is pointing the value just greater then TARGET) so we can return START.\\n***\\nIt is also given that THE LETTERS WRAP AROUND means when there is no value greater then TARGET we have to return FIRST element.\\n***\\nfor that we can do\\n\\n[\\nif (start = = letters.length){\\n    return 0;\\n}\\n\\n<<<.....or....>>>\\n\\n***return letters[start % letters.length];***\\n\\nIt will work as if TARGET is not the last letter then it will return the letter just greater then the TARGET else it will return 0 {eg:- 2[START] % 4[LATTERS.LENGTH] = 2 but 4[START] % 4[LETTERS.LENGTH] = 0}\\n]\\n\\n***\\n\\nReturning START % LETTERS.LENGTH because when we perform modulo operation with any index which is less then last index it will return the same index[(3 % 10 = 3), (4 % 4 = 4), (10 % 10 = 0)] value but when it perform % with itself it will return 0 which match the condition of THE LETTERS WRAP AROUND will satisfy (remember that we have to return the value not index so \\nreturn letters[start % letters.length];)\\n\\n --> "
                    },
                    {
                        "username": "abanobraffet",
                        "content": "can someone solve it using c++ upper_bound( )  ??"
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "WHY THIS CODE IS SHOWING TLE ,i use Binary search in O(logn) coplexity\\n\\nint s=0,e=arr.size()-1,m;\\n        char ans=arr[0];\\n        while(s<=e){\\n            if(arr[m]>target){\\n                ans=arr[m];\\n                e=m-1;\\n            }\\n            else\\n                s=m+1;\\n        }\\n        return ans;"
                    }
                ]
            }
        ]
    }
]