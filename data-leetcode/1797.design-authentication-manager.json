[
    {
        "title": "K Closest Points to Origin",
        "question_content": "Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0).\nThe distance between two points on the X-Y plane is the Euclidean distance (i.e., &radic;(x1 - x2)2 + (y1 - y2)2).\nYou may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in).\n&nbsp;\nExample 1:\n\nInput: points = [[1,3],[-2,2]], k = 1\nOutput: [[-2,2]]\nExplanation:\nThe distance between (1, 3) and the origin is sqrt(10).\nThe distance between (-2, 2) and the origin is sqrt(8).\nSince sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.\nWe only want the closest k = 1 points from the origin, so the answer is just [[-2,2]].\n\nExample 2:\n\nInput: points = [[3,3],[5,-1],[-2,4]], k = 2\nOutput: [[3,3],[-2,4]]\nExplanation: The answer [[-2,4],[3,3]] would also be accepted.\n\n&nbsp;\nConstraints:\n\n\t1 <= k <= points.length <= 104\n\t-104 <= xi, yi <= 104",
        "solutions": [
            {
                "id": 220235,
                "title": "java-three-solutions-to-this-classical-k-th-problem",
                "content": "This is a very classical problem, so-called K-th problem.\\nHere I will share some summaries and some classical solutions to this kind of problem.\\n\\n**I.** The very naive and simple solution is sorting the all points by their distance to the origin point directly, then get the top k closest points. We can use the sort function and the code is very short. \\n\\n**Theoretically**, the time complexity is **O(NlogN)**, **pratically**, the real time it takes on leetcode is **104ms**.\\n\\nThe **advantages** of this solution are **short**, intuitive and easy to implement.\\nThe **disadvatages** of this solution are not very efficient and have to know all of the points previously, and it is unable to deal with real-time(online) case, it is an **off-line** solution.\\n\\nThe short code shows as follows: \\n\\n\\n    public int[][] kClosest(int[][] points, int K) {\\n        Arrays.sort(points, (p1, p2) -> p1[0] * p1[0] + p1[1] * p1[1] - p2[0] * p2[0] - p2[1] * p2[1]);\\n        return Arrays.copyOfRange(points, 0, K);\\n    }\\n\\n\\n**II.** The second solution is based on the first one. We don\\'t have to sort all points.\\n\\tInstead, we can maintain a **max-heap** with size K. Then for each point, we add it to the heap. Once the size of the heap is greater than K, we are supposed to extract one from the max heap to ensure the size of the heap is always K. Thus, the max heap is always maintain top K smallest elements from the first one to crruent one. Once the size of the heap is over its maximum capacity, it will exclude the maximum element in it, since it can not be the proper candidate anymore.\\n\\t\\n**Theoretically**, the time complexity is **O(NlogK)**, but **pratically**, the real time it takes on leetcode is **134ms**. \\n\\nThe **advantage** of this solution is it can deal with **real-time(online) stream data**. It does not have to know the size of the data previously.\\nThe **disadvatage** of this solution is it is not the most efficient solution.\\n\\nThe short code shows as follows:\\n\\n    public int[][] kClosest(int[][] points, int K) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((p1, p2) -> p2[0] * p2[0] + p2[1] * p2[1] - p1[0] * p1[0] - p1[1] * p1[1]);\\n        for (int[] p : points) {\\n            pq.offer(p);\\n            if (pq.size() > K) {\\n                pq.poll();\\n            }\\n        }\\n        int[][] res = new int[K][2];\\n        while (K > 0) {\\n            res[--K] = pq.poll();\\n        }\\n        return res;\\n    }\\n\\n**III.** The last solution is based on quick sort, we can also call it **quick select**. In the quick sort, we will always choose a pivot to compare with other elements. After one iteration, we will get an array that  all elements smaller than the pivot are on the left side of the pivot and all elements greater than the pivot are on the right side of the pviot (assuming we sort the array in ascending order). So, inspired from this, each iteration, we choose a pivot and then find the position **p** the pivot should be. Then we compare  **p** with the **K**, if the **p** is smaller than the **K**, meaning the all element on the left of the pivot are all proper candidates but it is not adequate, we have to do the same thing on right side, and vice versa. If the **p**  is exactly equal to the **K**, meaning that we\\'ve found the K-th position. Therefore, we just return the first K elements, since they are not greater than the pivot.\\n\\n**Theoretically**, the average time complexity is **O(N)** , but just like quick sort, in the worst case, this solution would be degenerated to **O(N^2)**, and **pratically**, the real time it takes on leetcode is **15ms**.\\n\\nThe **advantage** of this solution is it is very efficient.\\nThe **disadvatage** of this solution are it is neither an online solution nor a stable one. And the K elements closest are **not sorted** in ascending order.\\n\\nThe short code shows as follows:\\n\\n    public int[][] kClosest(int[][] points, int K) {\\n        int len =  points.length, l = 0, r = len - 1;\\n        while (l <= r) {\\n            int mid = helper(points, l, r);\\n            if (mid == K) break;\\n            if (mid < K) {\\n                l = mid + 1;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n        return Arrays.copyOfRange(points, 0, K);\\n    }\\n    \\n    private int helper(int[][] A, int l, int r) {\\n        int[] pivot = A[l];\\n        while (l < r) {\\n            while (l < r && compare(A[r], pivot) >= 0) r--;\\n            A[l] = A[r];\\n            while (l < r && compare(A[l], pivot) <= 0) l++;\\n            A[r] = A[l];\\n        }\\n        A[l] = pivot;\\n        return l;\\n    }\\n    \\n    private int compare(int[] p1, int[] p2) {\\n        return p1[0] * p1[0] + p1[1] * p1[1] - p2[0] * p2[0] - p2[1] * p2[1];\\n    }\\n",
                "solutionTags": [],
                "code": "This is a very classical problem, so-called K-th problem.\\nHere I will share some summaries and some classical solutions to this kind of problem.\\n\\n**I.** The very naive and simple solution is sorting the all points by their distance to the origin point directly, then get the top k closest points. We can use the sort function and the code is very short. \\n\\n**Theoretically**, the time complexity is **O(NlogN)**, **pratically**, the real time it takes on leetcode is **104ms**.\\n\\nThe **advantages** of this solution are **short**, intuitive and easy to implement.\\nThe **disadvatages** of this solution are not very efficient and have to know all of the points previously, and it is unable to deal with real-time(online) case, it is an **off-line** solution.\\n\\nThe short code shows as follows: \\n\\n\\n    public int[][] kClosest(int[][] points, int K) {\\n        Arrays.sort(points, (p1, p2) -> p1[0] * p1[0] + p1[1] * p1[1] - p2[0] * p2[0] - p2[1] * p2[1]);\\n        return Arrays.copyOfRange(points, 0, K);\\n    }\\n\\n\\n**II.** The second solution is based on the first one. We don\\'t have to sort all points.\\n\\tInstead, we can maintain a **max-heap** with size K. Then for each point, we add it to the heap. Once the size of the heap is greater than K, we are supposed to extract one from the max heap to ensure the size of the heap is always K. Thus, the max heap is always maintain top K smallest elements from the first one to crruent one. Once the size of the heap is over its maximum capacity, it will exclude the maximum element in it, since it can not be the proper candidate anymore.\\n\\t\\n**Theoretically**, the time complexity is **O(NlogK)**, but **pratically**, the real time it takes on leetcode is **134ms**. \\n\\nThe **advantage** of this solution is it can deal with **real-time(online) stream data**. It does not have to know the size of the data previously.\\nThe **disadvatage** of this solution is it is not the most efficient solution.\\n\\nThe short code shows as follows:\\n\\n    public int[][] kClosest(int[][] points, int K) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((p1, p2) -> p2[0] * p2[0] + p2[1] * p2[1] - p1[0] * p1[0] - p1[1] * p1[1]);\\n        for (int[] p : points) {\\n            pq.offer(p);\\n            if (pq.size() > K) {\\n                pq.poll();\\n            }\\n        }\\n        int[][] res = new int[K][2];\\n        while (K > 0) {\\n            res[--K] = pq.poll();\\n        }\\n        return res;\\n    }\\n\\n**III.** The last solution is based on quick sort, we can also call it **quick select**. In the quick sort, we will always choose a pivot to compare with other elements. After one iteration, we will get an array that  all elements smaller than the pivot are on the left side of the pivot and all elements greater than the pivot are on the right side of the pviot (assuming we sort the array in ascending order). So, inspired from this, each iteration, we choose a pivot and then find the position **p** the pivot should be. Then we compare  **p** with the **K**, if the **p** is smaller than the **K**, meaning the all element on the left of the pivot are all proper candidates but it is not adequate, we have to do the same thing on right side, and vice versa. If the **p**  is exactly equal to the **K**, meaning that we\\'ve found the K-th position. Therefore, we just return the first K elements, since they are not greater than the pivot.\\n\\n**Theoretically**, the average time complexity is **O(N)** , but just like quick sort, in the worst case, this solution would be degenerated to **O(N^2)**, and **pratically**, the real time it takes on leetcode is **15ms**.\\n\\nThe **advantage** of this solution is it is very efficient.\\nThe **disadvatage** of this solution are it is neither an online solution nor a stable one. And the K elements closest are **not sorted** in ascending order.\\n\\nThe short code shows as follows:\\n\\n    public int[][] kClosest(int[][] points, int K) {\\n        int len =  points.length, l = 0, r = len - 1;\\n        while (l <= r) {\\n            int mid = helper(points, l, r);\\n            if (mid == K) break;\\n            if (mid < K) {\\n                l = mid + 1;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n        return Arrays.copyOfRange(points, 0, K);\\n    }\\n    \\n    private int helper(int[][] A, int l, int r) {\\n        int[] pivot = A[l];\\n        while (l < r) {\\n            while (l < r && compare(A[r], pivot) >= 0) r--;\\n            A[l] = A[r];\\n            while (l < r && compare(A[l], pivot) <= 0) l++;\\n            A[r] = A[l];\\n        }\\n        A[l] = pivot;\\n        return l;\\n    }\\n    \\n    private int compare(int[] p1, int[] p2) {\\n        return p1[0] * p1[0] + p1[1] * p1[1] - p2[0] * p2[0] - p2[1] * p2[1];\\n    }\\n",
                "codeTag": "Java"
            },
            {
                "id": 294389,
                "title": "easy-to-read-python-min-heap-solution-beat-99-python-solutions",
                "content": "We keep a min heap of size K.\\nFor each item, we insert an item to our heap.\\nIf inserting an item makes heap size larger than k, then we immediately pop an item after inserting ( `heappushpop` ).\\n\\nRuntime: \\nInserting an item to a heap of size k take `O(logK)` time.\\nAnd we do this for each item points.\\nSo runtime is `O(N * logK)` where N is the length of `points`.\\n\\nSpace: O(K) for our heap.\\n```\\nimport heapq\\n\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        \\n        heap = []\\n        \\n        for (x, y) in points:\\n            dist = -(x*x + y*y)\\n            if len(heap) == K:\\n                heapq.heappushpop(heap, (dist, x, y))\\n            else:\\n                heapq.heappush(heap, (dist, x, y))\\n        \\n        return [(x,y) for (dist,x, y) in heap]\\n```\\n\\nI found it interesting that my solution ran much faster than \"Divide And Conquer\" solution under \"Solution\" tab which is supposed to run in O(N). \\nMine ran at 316ms while D&C solution ran at 536 ms.\\n\\nI am guessing that the D&C solution ran much slower than mine because it used recursions which would involved creating callstacks.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport heapq\\n\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        \\n        heap = []\\n        \\n        for (x, y) in points:\\n            dist = -(x*x + y*y)\\n            if len(heap) == K:\\n                heapq.heappushpop(heap, (dist, x, y))\\n            else:\\n                heapq.heappush(heap, (dist, x, y))\\n        \\n        return [(x,y) for (dist,x, y) in heap]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 221532,
                "title": "c-stl-quickselect-priority-queue-and-multiset",
                "content": "The simplest solution is to use `partial_sort` or `nth_element` to order the `K` closest points at the beginning of `points`. Here we need a custom comparator to compare the *closeness* of points. This solution is of `O(nlogK)` time. If we ignore the space of the output since that is inevitable, this solution is of `O(1)` space.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        partial_sort(points.begin(), points.begin() + K, points.end(), [](vector<int>& p, vector<int>& q) {\\n            return p[0] * p[0] + p[1] * p[1] < q[0] * q[0] + q[1] * q[1];\\n        });\\n        return vector<vector<int>>(points.begin(), points.begin() + K);\\n    }\\n};\\n```\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        nth_element(points.begin(), points.begin() + K - 1, points.end(), [](vector<int>& p, vector<int>& q) {\\n            return p[0] * p[0] + p[1] * p[1] < q[0] * q[0] + q[1] * q[1];\\n        });\\n        return vector<vector<int>>(points.begin(), points.begin() + K);\\n    }\\n};\\n```\\n\\nYou may also implement the underlying quickselect algorithm yourself.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        int l = 0, r = points.size() - 1;\\n        while (true) {\\n            int p = partition(points, l, r);\\n            if (p == K - 1) {\\n                break;\\n            }\\n            if (p < K - 1) {\\n                l = p + 1;\\n            } else {\\n                r = p - 1;\\n            }\\n        }\\n        return vector<vector<int>>(points.begin(), points.begin() + K);\\n    }\\nprivate:\\n    bool farther(vector<int>& p, vector<int>& q) {\\n        return p[0] * p[0] + p[1] * p[1] > q[0] * q[0] + q[1] * q[1];\\n    }\\n    \\n    bool closer(vector<int>& p, vector<int>& q) {\\n        return p[0] * p[0] + p[1] * p[1] < q[0] * q[0] + q[1] * q[1];\\n    }\\n    \\n    int partition(vector<vector<int>>& points, int left, int right) {\\n        int pivot = left, l = left + 1, r = right;\\n        while (l <= r) {\\n            if (farther(points[l], points[pivot]) && closer(points[r], points[pivot])) {\\n                swap(points[l++], points[r--]);\\n            }\\n            if (!farther(points[l], points[pivot])) {\\n                l++;\\n            }\\n            if (!closer(points[r], points[pivot])) {\\n                r--;\\n            }\\n        }\\n        swap(points[pivot], points[r]);\\n        return r;\\n    }\\n};\\n```\\n\\nIf you would not like to modify `points`, you may maintain the `K` closest points so far in a separate data structure. We can use a **max** heap to maintain the `K` closest points. A max heap has its largest element in the root. Each time we add a point to the heap, if its size exceeds `K`, we pop the root, which means we get rid of the farthest point and keep the closest ones. This solution is also of `O(nlogK)` time.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        priority_queue<vector<int>, vector<vector<int>>, compare> pq;\\n        for (vector<int>& point : points) {\\n            pq.push(point);\\n            if (pq.size() > K) {\\n                pq.pop();\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        while (!pq.empty()) {\\n            ans.push_back(pq.top());\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\nprivate:\\n    struct compare {\\n        bool operator()(vector<int>& p, vector<int>& q) {\\n            return p[0] * p[0] + p[1] * p[1] < q[0] * q[0] + q[1] * q[1];\\n        }\\n    };\\n};\\n```\\n\\nWe can also use a min heap. A min heap has the smallest element in the root. We add all the points to the heap, and then pop the first `K` ones, we are just the closest ones. This makes the code shorter. Now this one is of `O(n + Klogn)` time. The `n` part is on adding all points to the heap (building a min heap for all the points) and the `Klogn` part is on fetching the top `K` points from the heap.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        priority_queue<vector<int>, vector<vector<int>>, compare> pq(points.begin(), points.end());\\n        vector<vector<int>> ans;\\n        for (int i = 0; i < K; i++) {\\n            ans.push_back(pq.top());\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\nprivate:\\n    struct compare {\\n        bool operator()(vector<int>& p, vector<int>& q) {\\n            return p[0] * p[0] + p[1] * p[1] > q[0] * q[0] + q[1] * q[1];\\n        }\\n    };\\n};\\n```\\n\\nNote that for `priority_queue`, if you would like to use it as a max heap, the comparator should be `<` and if as a min heap, the comparator is `>`.\\n\\nMax/min heaps can also be implemented using `multiset`. For `multiset`, max heap has `>` and min heap has `<` in the comparator. The following two solutions are respectively max/min heap using `multiset`.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        multiset<vector<int>, compare> mset;\\n        for (vector<int>& point : points) {\\n            mset.insert(point);\\n            if (mset.size() > K) {\\n                mset.erase(mset.begin());\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        copy_n(mset.begin(), K, back_inserter(ans));\\n        return ans;\\n    }\\nprivate:\\n    struct compare {\\n        bool operator()(const vector<int>& p, const vector<int>& q) const {\\n            return p[0] * p[0] + p[1] * p[1] > q[0] * q[0] + q[1] * q[1];\\n        }\\n    };\\n};\\n```\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        multiset<vector<int>, compare> mset(points.begin(), points.end());\\n        vector<vector<int>> ans;\\n        copy_n(mset.begin(), K, back_inserter(ans));\\n        return ans;\\n    }\\nprivate:\\n    struct compare {\\n        bool operator()(const vector<int>& p, const vector<int>& q) const {\\n            return p[0] * p[0] + p[1] * p[1] < q[0] * q[0] + q[1] * q[1];\\n        }\\n    };\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        partial_sort(points.begin(), points.begin() + K, points.end(), [](vector<int>& p, vector<int>& q) {\\n            return p[0] * p[0] + p[1] * p[1] < q[0] * q[0] + q[1] * q[1];\\n        });\\n        return vector<vector<int>>(points.begin(), points.begin() + K);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        nth_element(points.begin(), points.begin() + K - 1, points.end(), [](vector<int>& p, vector<int>& q) {\\n            return p[0] * p[0] + p[1] * p[1] < q[0] * q[0] + q[1] * q[1];\\n        });\\n        return vector<vector<int>>(points.begin(), points.begin() + K);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        int l = 0, r = points.size() - 1;\\n        while (true) {\\n            int p = partition(points, l, r);\\n            if (p == K - 1) {\\n                break;\\n            }\\n            if (p < K - 1) {\\n                l = p + 1;\\n            } else {\\n                r = p - 1;\\n            }\\n        }\\n        return vector<vector<int>>(points.begin(), points.begin() + K);\\n    }\\nprivate:\\n    bool farther(vector<int>& p, vector<int>& q) {\\n        return p[0] * p[0] + p[1] * p[1] > q[0] * q[0] + q[1] * q[1];\\n    }\\n    \\n    bool closer(vector<int>& p, vector<int>& q) {\\n        return p[0] * p[0] + p[1] * p[1] < q[0] * q[0] + q[1] * q[1];\\n    }\\n    \\n    int partition(vector<vector<int>>& points, int left, int right) {\\n        int pivot = left, l = left + 1, r = right;\\n        while (l <= r) {\\n            if (farther(points[l], points[pivot]) && closer(points[r], points[pivot])) {\\n                swap(points[l++], points[r--]);\\n            }\\n            if (!farther(points[l], points[pivot])) {\\n                l++;\\n            }\\n            if (!closer(points[r], points[pivot])) {\\n                r--;\\n            }\\n        }\\n        swap(points[pivot], points[r]);\\n        return r;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        priority_queue<vector<int>, vector<vector<int>>, compare> pq;\\n        for (vector<int>& point : points) {\\n            pq.push(point);\\n            if (pq.size() > K) {\\n                pq.pop();\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        while (!pq.empty()) {\\n            ans.push_back(pq.top());\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\nprivate:\\n    struct compare {\\n        bool operator()(vector<int>& p, vector<int>& q) {\\n            return p[0] * p[0] + p[1] * p[1] < q[0] * q[0] + q[1] * q[1];\\n        }\\n    };\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        priority_queue<vector<int>, vector<vector<int>>, compare> pq(points.begin(), points.end());\\n        vector<vector<int>> ans;\\n        for (int i = 0; i < K; i++) {\\n            ans.push_back(pq.top());\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\nprivate:\\n    struct compare {\\n        bool operator()(vector<int>& p, vector<int>& q) {\\n            return p[0] * p[0] + p[1] * p[1] > q[0] * q[0] + q[1] * q[1];\\n        }\\n    };\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        multiset<vector<int>, compare> mset;\\n        for (vector<int>& point : points) {\\n            mset.insert(point);\\n            if (mset.size() > K) {\\n                mset.erase(mset.begin());\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        copy_n(mset.begin(), K, back_inserter(ans));\\n        return ans;\\n    }\\nprivate:\\n    struct compare {\\n        bool operator()(const vector<int>& p, const vector<int>& q) const {\\n            return p[0] * p[0] + p[1] * p[1] > q[0] * q[0] + q[1] * q[1];\\n        }\\n    };\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        multiset<vector<int>, compare> mset(points.begin(), points.end());\\n        vector<vector<int>> ans;\\n        copy_n(mset.begin(), K, back_inserter(ans));\\n        return ans;\\n    }\\nprivate:\\n    struct compare {\\n        bool operator()(const vector<int>& p, const vector<int>& q) const {\\n            return p[0] * p[0] + p[1] * p[1] < q[0] * q[0] + q[1] * q[1];\\n        }\\n    };\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 217999,
                "title": "java-c-python-o-n",
                "content": "**Java:**\\nSort all points and return `K` first, `O(NlogN)`\\n```java\\n    public int[][] kClosest(int[][] points, int K) {\\n        Arrays.sort(points, Comparator.comparing(p -> p[0] * p[0] + p[1] * p[1]));\\n        return Arrays.copyOfRange(points, 0, K);\\n    }\\n```\\n\\n**Python:**\\nSort using heap of size `K`, `O(NlogK)`\\n```cpp\\n    def kClosest(self, points, K):\\n        return heapq.nsmallest(K, points, lambda (x, y): x * x + y * y)\\n```\\n\\n**C++**\\n`O(N)` quick select\\n```cpp\\n    vector<vector<int>> kClosest(vector<vector<int>>& A, int K) {\\n        nth_element(A.begin(), A.begin() + K, A.end(), [](vector<int>& a, vector<int>& b) {\\n            return a[0] * a[0] + a[1] * a[1] < b[0] * b[0] + b[1] * b[1];\\n        });\\n        return vector<vector<int>>(A.begin(), A.begin() + K);\\n    }\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```java\\n    public int[][] kClosest(int[][] points, int K) {\\n        Arrays.sort(points, Comparator.comparing(p -> p[0] * p[0] + p[1] * p[1]));\\n        return Arrays.copyOfRange(points, 0, K);\\n    }\\n```\n```cpp\\n    def kClosest(self, points, K):\\n        return heapq.nsmallest(K, points, lambda (x, y): x * x + y * y)\\n```\n```cpp\\n    vector<vector<int>> kClosest(vector<vector<int>>& A, int K) {\\n        nth_element(A.begin(), A.begin() + K, A.end(), [](vector<int>& a, vector<int>& b) {\\n            return a[0] * a[0] + a[1] * a[1] < b[0] * b[0] + b[1] * b[1];\\n        });\\n        return vector<vector<int>>(A.begin(), A.begin() + K);\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 576025,
                "title": "python-3-lines-knn-search-using-kd-tree-for-large-number-of-queries",
                "content": "Using a kd-tree to solve this problem is an overkill. However, it will be a nice approach for discussion if this follow up question comes up during interview.\\n**What if I have 10 million points now and I have to perform the search 10000 times? How would you optimize it?**\\n\\nLet\\'s first have a review of some solutions that we have already come across:\\n1. **Sorting - O(NlogN)**, since we need to sort the entire list of points\\n2. **Max Heap - O(NlogK)**, since we need to maintain a priority queue of size K and extract the closest K points with a bunch of heap push and pop\\n3. **Quick Select - O(N) on average**, a modified quick-sort like algorithm (proof of complexity not shown here)\\n\\nAs we can see, if we have `N=10000000` and we have to perform the search over a large number of times, even **O(N)** solution may seem to be inefficient in this extreme case.\\n\\nSo, what can we do? We can make use of a data structure called **kd-tree** which are particularly good at searching 2D (or 3D,...,KD) points in **logarithmic time**.\\nSince the points on the 2D planes aren\\'t going to change (in most cases) during the query, we can **prepocess** the points by constructing a kd-tree to store them for later queries.\\n\\nkd-tree has the following comeplexity:\\n1. **Build the tree - O(NlogN)**, building the tree requires presorting the points and find the medians (but we only need to do this once).\\n2. **Search, Insert, Delete - O(logN)**, similar to how a normal binary tree works (with a tree balancing mechanism)\\n\\nNow, as we can see, it greatly reduces the time complexity for each nearest neighbor query to **O(logN)**, and if we need to find the K closest points, the total complexity will be **O(KlogN)**. This is great if we have a lof of points and we are only interested in a few neighbors.\\n\\nCoding a kd-tree seems daunting and not feasible in a 45-min interviews. However, in Python, there is some data science library which allows you to build a tree and perform the search in just a few lines of code! Since interviewers typically don\\'t expect you to code an actual kd-tree, using the following code may not only show that you have insights of more advanced data structure, but also demostrate that you have practical experience implementing them with pre-existing libraries.\\n\\n```\\nfrom scipy import spatial\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        tree = spatial.KDTree(points)\\n\\t\\t# x is the origin, k is the number of closest neighbors, p=2 refers to choosing l2 norm (euclidean distance)\\n        distance, idx = tree.query(x=[0,0], k=K, p=2) \\n        return [points[i] for i in idx] if K > 1 else [points[idx]]\\n```\\n\\nReference: https://en.wikipedia.org/wiki/K-d_tree\\n",
                "solutionTags": [],
                "code": "```\\nfrom scipy import spatial\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        tree = spatial.KDTree(points)\\n\\t\\t# x is the origin, k is the number of closest neighbors, p=2 refers to choosing l2 norm (euclidean distance)\\n        distance, idx = tree.query(x=[0,0], k=K, p=2) \\n        return [points[i] for i in idx] if K > 1 else [points[idx]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647773,
                "title": "c-python-simple-solutions-w-explanation-sort-heap-randomized-quickselect-o-n",
                "content": "We are given array of points and we need to return `k` closest points to the origin.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I (Sort by Euclidean Distance)***\\n\\nWe can simply sort the points by their euclidean distance from the origin and select the 1st `k` points from the sorted array. For a slightly more efficient implementation, we can choose squared euclidean distance as a comparator while sorting instead of euclidean distance itself which would help avoid calculating `sqrt` everytime and not affect result either since if an euclidean distance `a > b`, then we will also have <code>a<sup>2</sup> > b<sup>2</sup></code>\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& P, int k) {\\n        auto euclidean = [](auto& p) { return p[0] * p[0] + p[1] * p[1]; };\\n        sort(begin(P), end(P), [&](auto& a, auto& b) { return euclidean(a) < euclidean(b); });\\n        P.resize(k);\\n        return P;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def kClosest(self, P, k):\\n        return sorted(P, key=lambda p: p[0]**2 + p[1]**2)[:k]\\n```\\n\\n***Time Complexity :*** `O(NlogN)`, where `N` is the number of elements in `P`. It is required for sorting\\n***Space Complexity :*** `O(sort)`, space used by in-built sort algorithms\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Max-Heap / Priority Queue)***\\n\\nA better solution would be to use max-heap solution. This would allow us iterate over array and to only maintain `k` elements in the heap. If it exceeds `k` element, we pop the largest element. At the end of iteration, we would only be left with `k` smallest elements (since we popped off larger distanced elements whenever number of elements in heap exceeded `k`).  \\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& P, int k) {\\n        auto euclidean = [](auto& p) { return p[0] * p[0] + p[1] * p[1]; };\\n        priority_queue<pair<int, int>> pq;\\n        for(int i = 0; i < size(P); i++) {\\n            pq.emplace(euclidean(P[i]), i);\\n            if(size(pq) > k) pq.pop();\\n        }\\n        vector<vector<int>> ans(k);\\n        for(int i = 0; i < k; i++) \\n            ans[i] = P[pq.top().second], pq.pop();\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def kClosest(self, P, k):\\n        heap, euclidean = [], lambda x, y : x*x + y*y\\n        for i, (x, y) in enumerate(P):\\n            d = euclidean(x, y)\\n            if len(heap) == k:\\n                heappushpop(heap, (-d, i))     # -d to convert to max-heap (default is min)\\n            else: \\n                heappush(heap, (-d, i))\\n        return [P[i] for (_, i) in heap]\\n```\\n\\n***Time Complexity :*** `O(Nlogk)`, where `N` is the number of elements in the array and `k` is the number of closest elements we need to find. Since there are a max of `O(k)` elements at any point in the heap, the `push` and `pop` operation only take `O(logk)` and this happens `O(N)` times leading to total time complexity of `O(Nlogk)`\\n***Space Complexity :*** `O(k)`, for maintain heap\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Min-Heap)***\\n\\nAnother way to use heap would be to construct a min-heap and pop the min elements `k` times. \\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& P, int k) {\\n        auto euclidean = [](auto& p) { return p[0] * p[0] + p[1] * p[1]; };\\n        auto comp = [&](auto& a, auto& b) { return euclidean(a) > euclidean(b); };\\n        make_heap(begin(P), end(P), comp);\\n        \\n        vector<vector<int>> ans(k);\\n        for(int i = 0; i < k; i++) {\\n            ans[i] = P[0];\\n            pop_heap(begin(P), end(P), comp);\\n            P.pop_back();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nor even like this -\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& P, int k) {\\n        auto euclidean = [](auto& p) { return p[0] * p[0] + p[1] * p[1]; };\\n        auto comp = [&](auto& a, auto& b) { return euclidean(a) > euclidean(b); };\\n        make_heap(begin(P), end(P), comp);\\n        \\n        for(int i = 0; i < k; i++) \\n            pop_heap(begin(P), end(P)-i, comp);\\n\\n        return vector<vector<int>>(begin(P)+size(P)-k, end(P));\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def kClosest(self, P, k):\\n        euclidean = lambda x, y : x*x + y*y\\n        for p in P:\\n            p.insert(0, euclidean(p[0], p[1]))\\n        heapify(P)\\n        return [heappop(P)[1:] for i in range(k)]\\n```\\n\\n***Time Complexity :*** `O(N + klogN)`, constructing the heap from given array of points `P` can be done in `O(N)` time. Then each heap pop operation would take `O(logN)` time which will be called for `k` times. Thus overall time will be `O(N + klogN)`\\n***Space Complexity :*** `O(1)`, we are doing it in-place. If input modification is not allowed, use a copy of `P` and that would take `O(N)` space\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - IV (Randomized QuickSelect)***\\n\\nThis solution is a modifed version of Quick-sort meant to be used when we need to find k(or kth) smallest(or largest) elements (based on some comparator) but not in any particular order. Most of the partition logic used in this algorithm remains the same as in quicksort but we just modify the recursive part of quicksort to suit our use case.\\n\\nEach time, we choose a pivot and partition the array around that pivot using a comparator. In this case, we will choose a randomized pivot (the choice of pivot majorly affects the performace of algorithm and we need to try to choose a pivot that partitions the range roughly equally for best result. Without any knowledge of the way that elements occur in array, it\\'s best to choose randomized pivot each time to avoid worst case) and for comparator, we will use the squared euclidean distance.\\n\\nInitially we start with whole range of array `[L, R] = [0, size(P)-1]`. After each partition, the `partition` function will return the pivot index (denoted as `p` below) which is basically the element which separates all the elements <= than it to left side and all elements > than it to the right side (not in particular order). We have:\\n* If `p < k`, then we now have `p` elements which are closest to origin (although they aren\\'t sorted in any particular order) but we still need some more elements to get `k` points in total. Thus, we iterate again and partition the array from indices `[p+1, R]` till we find `k` elements (by getting pivot at `k`th index)\\n* If `p > k`, then we now have more than `k` elements with us that are closest to origin. But we are sure that any element to the right of `p` wont be ever in our answer. So we iterate again and partition just the range `[L, p-1]` till we find `k` elements\\n* If `p == k`, we now have exactly `k` elements with us which are closest to origin. Thus,  we return the 1st `k` elements of array\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& P, int k) {\\n        int L = 0, R = size(P)-1, p = size(P);\\n        while(p != k) {\\n            p = partition(P, L, R);\\n            if(p < k)   L = p + 1;\\n            else        R = p - 1;\\n        }\\n        P.resize(k);\\n        return P;\\n    }\\n\\t// randomized partition algorithm similar to the one used in quicksort\\n    int partition(vector<vector<int>>& P, int L, int R) {\\n\\t\\tauto euclidean = [](auto& p) { return p[0] * p[0] + p[1] * p[1]; };\\n        srand(time(0));\\n        swap(P[R], P[L + rand() % (R-L+1)]);       // choose a random pivot and swap with last element. Then partition with last element as pivot\\n        int i = L, pivotDist = euclidean(P[R]);\\n        for(int j = L; j <= R; j++) \\n            if(euclidean(P[j]) <= pivotDist)       // move all points having less distance to the left\\n                swap(P[i++], P[j]);\\n        return i-1;                                // returns final position of pivot after partition\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def kClosest(self, P, k):\\n        euclidean = lambda p : p[0]**2 + p[1]**2\\n        def partition(L, R):\\n            random = randint(L, R)                 # choosing random pivot\\n            P[R], P[random] = P[random], P[R]      # and swapping it to the end\\n            i, pivotDist = L, euclidean(P[R])\\n            for j in range(L, R+1):\\n                if euclidean(P[j]) <= pivotDist:\\n                    P[i], P[j] = P[j], P[i]\\n                    i += 1\\n            return i-1\\n        \\n        L, R, p = 0, len(P)-1, len(P)\\n        while p != k:\\n            p = partition(L, R)\\n            if p < k:   L = p + 1\\n            else    :   R = p - 1\\n        return P[:k]\\n```\\n\\n***Time Complexity :*** <code>O(N)</code>, at each partition, we are eliminating one end and re-partitioning the other end till we get pivot at `k`th index. On average, the partitions  roughly eliminate half of remaining elements each time thus leading to `N + N/2 + N/4 + ... + 1 = O(2N)` iterations. However, in the worst case, there\\'s still a chance (although very low) that we choose the worst pivot at each partition and this leads to <code>N + N-1 + N-2 + ... + 1 = N<sup>2</sup></code> total iterations leading to time complexity of <code>O(N<sup>2</sup>)</code>\\n***Space Complexity :*** `O(1)`, only constant extra space is being used\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - V (nth_element)***\\n\\nThe same functionality as above is provided by an built-in STL method in C++: **[`std::nth_element`](https://en.cppreference.com/w/cpp/algorithm/nth_element)**. The array is rearranged in a way that nth element would occur at position same as if array was sorted and all elements before it are less than or equal (based on provided comparator) to elements after nth element.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& P, int k) {\\n        auto euclidean = [](auto& p){return p[0] * p[0] + p[1] * p[1];};\\n        nth_element(begin(P), begin(P)+k, end(P), [&](auto& a, auto& b) { return euclidean(a) < euclidean(b); });\\n        P.resize(k);\\n        return P;\\n    }\\n};\\n```\\n\\n\\n***Time Complexity :*** `O(N)`, same as above\\n***Space Complexity :*** `O(1)`, same as above\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---\\n",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& P, int k) {\\n        auto euclidean = [](auto& p) { return p[0] * p[0] + p[1] * p[1]; };\\n        sort(begin(P), end(P), [&](auto& a, auto& b) { return euclidean(a) < euclidean(b); });\\n        P.resize(k);\\n        return P;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def kClosest(self, P, k):\\n        return sorted(P, key=lambda p: p[0]**2 + p[1]**2)[:k]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& P, int k) {\\n        auto euclidean = [](auto& p) { return p[0] * p[0] + p[1] * p[1]; };\\n        priority_queue<pair<int, int>> pq;\\n        for(int i = 0; i < size(P); i++) {\\n            pq.emplace(euclidean(P[i]), i);\\n            if(size(pq) > k) pq.pop();\\n        }\\n        vector<vector<int>> ans(k);\\n        for(int i = 0; i < k; i++) \\n            ans[i] = P[pq.top().second], pq.pop();\\n        \\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def kClosest(self, P, k):\\n        heap, euclidean = [], lambda x, y : x*x + y*y\\n        for i, (x, y) in enumerate(P):\\n            d = euclidean(x, y)\\n            if len(heap) == k:\\n                heappushpop(heap, (-d, i))     # -d to convert to max-heap (default is min)\\n            else: \\n                heappush(heap, (-d, i))\\n        return [P[i] for (_, i) in heap]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& P, int k) {\\n        auto euclidean = [](auto& p) { return p[0] * p[0] + p[1] * p[1]; };\\n        auto comp = [&](auto& a, auto& b) { return euclidean(a) > euclidean(b); };\\n        make_heap(begin(P), end(P), comp);\\n        \\n        vector<vector<int>> ans(k);\\n        for(int i = 0; i < k; i++) {\\n            ans[i] = P[0];\\n            pop_heap(begin(P), end(P), comp);\\n            P.pop_back();\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& P, int k) {\\n        auto euclidean = [](auto& p) { return p[0] * p[0] + p[1] * p[1]; };\\n        auto comp = [&](auto& a, auto& b) { return euclidean(a) > euclidean(b); };\\n        make_heap(begin(P), end(P), comp);\\n        \\n        for(int i = 0; i < k; i++) \\n            pop_heap(begin(P), end(P)-i, comp);\\n\\n        return vector<vector<int>>(begin(P)+size(P)-k, end(P));\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def kClosest(self, P, k):\\n        euclidean = lambda x, y : x*x + y*y\\n        for p in P:\\n            p.insert(0, euclidean(p[0], p[1]))\\n        heapify(P)\\n        return [heappop(P)[1:] for i in range(k)]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& P, int k) {\\n        int L = 0, R = size(P)-1, p = size(P);\\n        while(p != k) {\\n            p = partition(P, L, R);\\n            if(p < k)   L = p + 1;\\n            else        R = p - 1;\\n        }\\n        P.resize(k);\\n        return P;\\n    }\\n\\t// randomized partition algorithm similar to the one used in quicksort\\n    int partition(vector<vector<int>>& P, int L, int R) {\\n\\t\\tauto euclidean = [](auto& p) { return p[0] * p[0] + p[1] * p[1]; };\\n        srand(time(0));\\n        swap(P[R], P[L + rand() % (R-L+1)]);       // choose a random pivot and swap with last element. Then partition with last element as pivot\\n        int i = L, pivotDist = euclidean(P[R]);\\n        for(int j = L; j <= R; j++) \\n            if(euclidean(P[j]) <= pivotDist)       // move all points having less distance to the left\\n                swap(P[i++], P[j]);\\n        return i-1;                                // returns final position of pivot after partition\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def kClosest(self, P, k):\\n        euclidean = lambda p : p[0]**2 + p[1]**2\\n        def partition(L, R):\\n            random = randint(L, R)                 # choosing random pivot\\n            P[R], P[random] = P[random], P[R]      # and swapping it to the end\\n            i, pivotDist = L, euclidean(P[R])\\n            for j in range(L, R+1):\\n                if euclidean(P[j]) <= pivotDist:\\n                    P[i], P[j] = P[j], P[i]\\n                    i += 1\\n            return i-1\\n        \\n        L, R, p = 0, len(P)-1, len(P)\\n        while p != k:\\n            p = partition(L, R)\\n            if p < k:   L = p + 1\\n            else    :   R = p - 1\\n        return P[:k]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& P, int k) {\\n        auto euclidean = [](auto& p){return p[0] * p[0] + p[1] * p[1];};\\n        nth_element(begin(P), begin(P)+k, end(P), [&](auto& a, auto& b) { return euclidean(a) < euclidean(b); });\\n        P.resize(k);\\n        return P;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647428,
                "title": "c-easy-to-solve-beginner-friendly-with-detailed-explanations",
                "content": "# **This are the reasons behind why we should not to use Sort function, minHeap and why we should use a maxHeap .**\\n\\n\\nThe basic gist of the question is that we need to find the k closest point from the origin . \\n**Intuition :-**\\n* The intuition we all got at first was to sort the points in increasing order and just do the math. But this is not a viable solution, i believe this the worst solution beacause let\\'s think of a scenerio were there will be streaming of online data. Everytime a new data[points] comes, we need to sort the entire inputs till that point and since it\\'s online we all know how much data could have been there in just one sec .\\n* So a good solution can be a heap approach. To be specific a maxheap since in minheap It will store all the array elements and this can be costly for large elemented arrays while in maxheap we just need to store k elements.\\n\\n***ALWAYS REMEMBER* :-*Whenever a question asks for k closest or k smallest or k largest it\\'s a heap question .Though these questions might be implemented using other algorithms as well but heap will allow to simplify the problem as well as code and your code will have a achievement unlocked known as erorr resistnace , lol.***\\n\\n\\n\\n**Before starting with algo let\\'s take a example from the description of this question:-**\\n```\\nInput: points = [[1,3],[-2,2]], k = 1\\n\\nThe way to judge whether a point is close or not is to find the euclidean distance.\\nwe dont have to perform square root and make the code look complex moreover it\\'s more prone to errors . we can simply just use `dist = x*x+y*y`\\n\\nNow let\\'s calculate the distance:\\n\\ndist = 1*1 + 3*3 = 10\\ndist = -2*-2 + 2*2 = 8\\n\\nWe can see that dist of the 2nd element is smaller so we need to pushback that element into our result vector.\\n```\\n\\n**Algorithm:-**\\n1. Initialize a priority queue for storing the maxheap data. let\\'s name this as `maxHeap` and initialize a `result` vector .\\n2. let `x` and `y` be the co-ordinates of point `p` .\\n3. Main logic behind maxHeap is that, we will maintain a maxHeap of size k Thus after addding new points to our maxHeap we need to check the size of heap if it is greater than k or not .If the size is greater than k we will remove remove the root element  to ensure the size of the heap is always k . Thus, the max heap is always maintain top K smallest elements from the first one to current one. \\n4. In short The maxheap will show true potential once the size of the heap is over its maximum capacity i.e it will exclude the maximum element in it as it can not be the proper candidate anymore.\\n\\n**Code:-**\\n```\\n//Upvote and Comment\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n         //Answer vector\\n        vector<vector<int>> result(k);\\n        //maxheap storage initialization\\n        priority_queue<vector<int>> maxHeap;\\n        //Construction of maxheap\\n        for (auto& p : points) {\\n            int x = p[0], y = p[1];\\n            maxHeap.push({x*x + y*y, x, y});\\n            if (maxHeap.size() > k) {\\n                maxHeap.pop();\\n            }\\n        }\\n        \\n        for (int i = 0; i < k; ++i) {\\n            vector<int> top = maxHeap.top();\\n            maxHeap.pop();\\n            result[i] = {top[1], top[2]};\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n**Time Complexity:-** *`O(NlogK)`*\\n**Space Complexity:-** *`O(K) [Since in maxheap we will be maintaining just k elements]`*\\n\\n***\\n\\n**[My Github Repo](https://github.com/Jatin-Shihora/LeetCode-Solutions) where I keep track of my solutions :)))**\\n\\n***\\n\\n.......Continuation from previous posts ...\\nAfter yomru reached to the east end, he saw a text in black, the text was \\'ALL SPECIES...\\' . Meanwhile Doggo, Dogelina and JThree also reached their ending location .All of them saw some texts . Doggo saw the text saying \\'POTENTIAL,..\\' ,Dogelina saw the text saying \\'SHOULD HAVE EQUAL....\\' and JThree saw the text saying \\'THE QUICK BROWN FOX JUMPS OVER A LAZY DOG \\'. After seeing all this text\\'s which were located at all four diections. All of them took a picture of their respective texts . When JThree was clicking the picture of the text because of the flash of camera a new text appeared which was \\'  ~ ! @ # $ % ^ & * ( _ ) + = - { : > } ? | \\\\ ; \\' , . ]  \\' ..\\nTo be continued in the next post........\\n\\n**Feel free to comment or upvote if you liked my post**\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nInput: points = [[1,3],[-2,2]], k = 1\\n\\nThe way to judge whether a point is close or not is to find the euclidean distance.\\nwe dont have to perform square root and make the code look complex moreover it\\'s more prone to errors . we can simply just use `dist = x*x+y*y`\\n\\nNow let\\'s calculate the distance:\\n\\ndist = 1*1 + 3*3 = 10\\ndist = -2*-2 + 2*2 = 8\\n\\nWe can see that dist of the 2nd element is smaller so we need to pushback that element into our result vector.\\n```\n```\\n//Upvote and Comment\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n         //Answer vector\\n        vector<vector<int>> result(k);\\n        //maxheap storage initialization\\n        priority_queue<vector<int>> maxHeap;\\n        //Construction of maxheap\\n        for (auto& p : points) {\\n            int x = p[0], y = p[1];\\n            maxHeap.push({x*x + y*y, x, y});\\n            if (maxHeap.size() > k) {\\n                maxHeap.pop();\\n            }\\n        }\\n        \\n        for (int i = 0; i < k; ++i) {\\n            vector<int> top = maxHeap.top();\\n            maxHeap.pop();\\n            result[i] = {top[1], top[2]};\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 219442,
                "title": "python-with-quicksort-algorithm",
                "content": "```\\nclass Solution:\\n    def kClosest(self, points, K):\\n        self.sort(points, 0, len(points)-1, K)\\n        return points[:K]\\n    \\n    def sort(self, points, l, r, K):\\n        if l < r:\\n            p = self.partition(points, l, r)\\n            if p == K:\\n                return\\n            elif p < K:\\n                self.sort(points, p+1, r, K)\\n            else:\\n                self.sort(points, l, p-1, K)\\n            \\n    def partition(self, points, l, r):\\n        pivot = points[r]\\n        a = l\\n        for i in range(l, r):\\n            if (points[i][0]**2 + points[i][1]**2) <= (pivot[0]**2 + pivot[1]**2):\\n                points[a], points[i] = points[i], points[a]\\n                a += 1\\n        points[a], points[r] = points[r], points[a]                \\n        return a\\n\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kClosest(self, points, K):\\n        self.sort(points, 0, len(points)-1, K)\\n        return points[:K]\\n    \\n    def sort(self, points, l, r, K):\\n        if l < r:\\n            p = self.partition(points, l, r)\\n            if p == K:\\n                return\\n            elif p < K:\\n                self.sort(points, p+1, r, K)\\n            else:\\n                self.sort(points, l, p-1, K)\\n            \\n    def partition(self, points, l, r):\\n        pivot = points[r]\\n        a = l\\n        for i in range(l, r):\\n            if (points[i][0]**2 + points[i][1]**2) <= (pivot[0]**2 + pivot[1]**2):\\n                points[a], points[i] = points[i], points[a]\\n                a += 1\\n        points[a], points[r] = points[r], points[a]                \\n        return a\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 660317,
                "title": "c-java-python-2-solutions-max-heap-minheap-clean-code-o-nlogk",
                "content": "**\\u2714\\uFE0F Solution 1: Max Heap**\\n- Same problem: **[215. Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/discuss/1349609)**.\\n- We use `maxHeap` to keep `k` smallest elements in array `n` elements. In the max heap, the top is the max element of the heap and it costs in `O(1)` in time complexity. By using max heap, we can remove `(n-k)` largest elements and keep `k` smallest elements in array.\\n\\n<iframe src=\"https://leetcode.com/playground/LjhEydzH/shared\" frameBorder=\"0\" width=\"100%\" height=\"410\"></iframe>\\n\\n**Complexity**\\n- Time: `O(NlogK)`, where `N <= 10^4` is number of points.\\n- Extra Space (don\\'t count output as space): `O(K)`, it\\'s size of maxHeap.\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Min Heap**\\n- Same problem: **[215. Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/discuss/1349609)**.\\n\\n<iframe src=\"https://leetcode.com/playground/CpasNhUz/shared\" frameBorder=\"0\" width=\"100%\" height=\"440\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N + KlogN)`, where `N <= 10^4` is number of points.\\n- Extra Space (don\\'t count output as space): `O(N)`.",
                "solutionTags": [],
                "code": "**\\u2714\\uFE0F Solution 1: Max Heap**\\n- Same problem: **[215. Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/discuss/1349609)**.\\n- We use `maxHeap` to keep `k` smallest elements in array `n` elements. In the max heap, the top is the max element of the heap and it costs in `O(1)` in time complexity. By using max heap, we can remove `(n-k)` largest elements and keep `k` smallest elements in array.\\n\\n<iframe src=\"https://leetcode.com/playground/LjhEydzH/shared\" frameBorder=\"0\" width=\"100%\" height=\"410\"></iframe>\\n\\n**Complexity**\\n- Time: `O(NlogK)`, where `N <= 10^4` is number of points.\\n- Extra Space (don\\'t count output as space): `O(K)`, it\\'s size of maxHeap.\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Min Heap**\\n- Same problem: **[215. Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/discuss/1349609)**.\\n\\n<iframe src=\"https://leetcode.com/playground/CpasNhUz/shared\" frameBorder=\"0\" width=\"100%\" height=\"440\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N + KlogN)`, where `N <= 10^4` is number of points.\\n- Extra Space (don\\'t count output as space): `O(N)`.",
                "codeTag": "Unknown"
            },
            {
                "id": 348171,
                "title": "python3-sort-o-nlogn-minimum-heap-o-nlogn-and-maximum-heap-o-nlogk",
                "content": "*  Time complexity: O(NlogN)\\n\\tSort the list according to the distance to origin.  Apparently, we did more than the question asked. We sorted all the distance, the question only ask for top k. To improve time complexity, we need to think about how to get we ask without extra effort. This is where heap data structure comes in.\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        points.sort(key = lambda P:P[0]**2+P[1]**2)\\n        return points[:K]\\n```\\n\\n\\n* Time complexity: O(nlogn), intuitively use minimum Heap:\\n\\t1. make a maximum-heap to store distance, (point\\'s distance to original, point)\\n\\t2. each time call heapq.heappop (distance), it will pop the smallest item in the heap. So heappop K times will be the result.\\n```\\nimport heapq\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        distance = []\\n        for i in points:\\n            heapq.heappush(distance,(i[0]**2+i[1]**2,i))\\n        K_points = []\\n        for i in range(K):\\n            K_points.append(heapq.heappop(distance)[1])\\n        return K_points\\n```\\n* \\tAs we can see here, we used heap, but the problem is we still sorted all the element, the time complexity is O(NlogN) .Still we only need the top k smallest element. We don\\'t need to take of other elements\\' order. So if we keep a size of k\\'s heap,  use the heap[0] element as threshhold, interate through the array, only those meet the requirment element get into the heap. \\n```\\n[1,5,3,4,10]  k = 3\\n\\ncur = 1\\nmaximum heap = [1]\\ncur =5 \\nmaximum heap = [5,1]\\ncur = 3 \\nmaximum heap = [5,3,1]\\ncur = 4 peek = 5\\ncur < peek:\\n\\tmaximum heap. pop\\n\\tmaximum heap = [3,1]\\n\\tmaximum heap.push(4)\\n\\tmaximum heap = [4,3,1]\\ncur = 10 peek = 4\\ncur > peek:\\n\\tmaximum heap = [4,3,1]\\n## python 3 doesn\\'t have maximum heap pop to the best of my knowledge.\\n```\\n* Time compiexity: O(NlogK)\\n\\tSince python3 doesn\\'t have a build-in maximum heap, so I use the minimum heap to achieve maximum heap\\'s property as shown above. Here, we keep a heap with size of K. So we can improve the time complexity to O(NlogK).\\n```\\nimport heapq\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        distance = []\\n        for p in points:\\n            if len(distance) <= K-1:\\n                heapq.heappush(distance,(-p[0]**2-p[1]**2,p))\\n            else:\\n                if -p[0]**2-p[1]**2 > distance[0][0]:\\n                    heapq.heappop(distance)\\n                    heapq.heappush(distance,(-p[0]**2-p[1]**2,p))\\n        res = []\\n        for i in range (K):\\n            res.append(heapq.heappop(distance)[1])\\n        return res\\n```\\n\\tTime compiexity: O(NlogK)\\n\\theapq is a binary heap, with O(log n) push and O(log n) pop. n is the size of the minimum heap. In this case, n = K.\\n\\tSo the time complexit is Nlog(K)\\n\\t\\n```\\nimport heapq\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        h = []\\n        for p in points:\\n            if len(h) <= K-1:\\n                heapq.heappush(h,(-p[0]**2-p[1]**2,p))\\n            else:\\n                if -p[0]**2-p[1]**2 > h[0][0]:\\n                    heapq.heapreplace(h,(-p[0]**2-p[1]**2,p))\\n        res = []\\n        for i in range(K):\\n            res.append(heapq.heappop(h)[1])\\n        return res\\n```\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        points.sort(key = lambda P:P[0]**2+P[1]**2)\\n        return points[:K]\\n```\n```\\nimport heapq\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        distance = []\\n        for i in points:\\n            heapq.heappush(distance,(i[0]**2+i[1]**2,i))\\n        K_points = []\\n        for i in range(K):\\n            K_points.append(heapq.heappop(distance)[1])\\n        return K_points\\n```\n```\\n[1,5,3,4,10]  k = 3\\n\\ncur = 1\\nmaximum heap = [1]\\ncur =5 \\nmaximum heap = [5,1]\\ncur = 3 \\nmaximum heap = [5,3,1]\\ncur = 4 peek = 5\\ncur < peek:\\n\\tmaximum heap. pop\\n\\tmaximum heap = [3,1]\\n\\tmaximum heap.push(4)\\n\\tmaximum heap = [4,3,1]\\ncur = 10 peek = 4\\ncur > peek:\\n\\tmaximum heap = [4,3,1]\\n## python 3 doesn\\'t have maximum heap pop to the best of my knowledge.\\n```\n```\\nimport heapq\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        distance = []\\n        for p in points:\\n            if len(distance) <= K-1:\\n                heapq.heappush(distance,(-p[0]**2-p[1]**2,p))\\n            else:\\n                if -p[0]**2-p[1]**2 > distance[0][0]:\\n                    heapq.heappop(distance)\\n                    heapq.heappush(distance,(-p[0]**2-p[1]**2,p))\\n        res = []\\n        for i in range (K):\\n            res.append(heapq.heappop(distance)[1])\\n        return res\\n```\n```\\nimport heapq\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        h = []\\n        for p in points:\\n            if len(h) <= K-1:\\n                heapq.heappush(h,(-p[0]**2-p[1]**2,p))\\n            else:\\n                if -p[0]**2-p[1]**2 > h[0][0]:\\n                    heapq.heapreplace(h,(-p[0]**2-p[1]**2,p))\\n        res = []\\n        for i in range(K):\\n            res.append(heapq.heappop(h)[1])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 217966,
                "title": "c-3-lines-nth-element-o-n",
                "content": "Here, I am showing four solutions:\\n1. Na\\xEFve sorting solution, O(n log n)\\n2. Short and efficient O(n) solution using ```nth_element``` <-- recommended\\n3. Simple implementation of ```quickselect```, with O(n) *average case* complexity\\n4. Improved ```quickselect``` with O(n) *worst case* complexity\\n\\n# Solution 1: Sorting\\nWe can just sort our points by the distance using a multimap (value is the index in the input array). Then we can take K first elements from the multimap and build the result vector.\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& ps, int K) {\\n  multimap<int, int> m;\\n  for (int i = 0; i < ps.size(); ++i)\\n    m.insert({ ps[i][0] * ps[i][0] + ps[i][1] * ps[i][1], i });\\n  vector<vector<int>> res;\\n  for (auto it = m.begin(); K > 0; ++it, --K) res.push_back(ps[it->second]);\\n  return res;\\n}\\n```\\n# Solution 2: nth_element\\nHowever, multimap sorts all elements, and what we need is just re-arrange elements so that none of the elements preceding Kth are greater than it, and none of the elements following it are less. To accomplish this, we could use ```partial_sort``` or ```nth_element``` functions, and the latter is better suited for this problem as we do not care about the order of the returning elements.\\n\\nThe ```nth_element``` function is typically implemented using [Introselect](https://en.wikipedia.org/wiki/Introselect), which brings the *average* complexity down to O(n).\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& ps, int K) {\\n  nth_element(begin(ps), begin(ps) + K, end(ps), [](vector<int> &a, vector<int> &b) {\\n      return a[0]*a[0]+a[1]*a[1] < b[0]*b[0]+b[1]*b[1];\\n  });\\n  ps.resize(K);\\n  return ps;\\n}\\n```\\n# Solution 3: Quickselect\\nIf you don\\'t want to use the library function, below is a sample implementation using [quickselect](https://en.wikipedia.org/wiki/Quickselect). I implemented it in a generic way to keep the same signature as for ```nth_element```. You can have a simpler implementation without using generics, like [Approach 2: Divide and Conquer](https://leetcode.com/problems/k-closest-points-to-origin/solution/).\\n\\nFor this implementation, we use the last element as a pivot. This gives us *average* O(n) complexity.\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& ps, int K) {\\n  quickselect(begin(ps), end(ps), K, [](vector<int> &a, vector<int> &b) {\\n      return a[0]*a[0]+a[1]*a[1] < b[0]*b[0]+b[1]*b[1];\\n  });\\n  ps.resize(K);\\n  return ps;\\n}\\ntemplate<class RndIt, class Compare> void quickselect(RndIt first, RndIt end, int K, Compare cmp) {\\n  auto p = partition(first, end, cmp);\\n  if (p - first + 1 == K) return;\\n  if (p - first + 1 < K) \\n      quickselect(p + 1, end, K - (p - first + 1), cmp);\\n  else \\n      quickselect(first, p, K, cmp);\\n}\\ntemplate<class RndIt, class Compare> RndIt partition(RndIt first, RndIt end, Compare cmp) {\\n  auto last = next(end, -1);\\n  auto pivot = *last;\\n  while (first < last) {\\n    while (cmp(*first, pivot))\\n        ++first;\\n    while (cmp(pivot, *last)) \\n        --last;\\n    if (first < last) {\\n        swap(*first, *last);\\n        if (!cmp(*first, *last))\\n            --last;\\n    }\\n  }\\n  return first;\\n}\\n```\\n# Solution 4: Improved quickselect\\nIn the previsou solution, we used the last element as a pivot. It\\'s a simple approach, but in the worst case the runtime can be O(n * n). To combat that, we coluld use the [median-of-median](https://en.wikipedia.org/wiki/Median_of_medians) method to pick our pivot.",
                "solutionTags": [],
                "code": "```nth_element```\n```quickselect```\n```quickselect```\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& ps, int K) {\\n  multimap<int, int> m;\\n  for (int i = 0; i < ps.size(); ++i)\\n    m.insert({ ps[i][0] * ps[i][0] + ps[i][1] * ps[i][1], i });\\n  vector<vector<int>> res;\\n  for (auto it = m.begin(); K > 0; ++it, --K) res.push_back(ps[it->second]);\\n  return res;\\n}\\n```\n```partial_sort```\n```nth_element```\n```nth_element```\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& ps, int K) {\\n  nth_element(begin(ps), begin(ps) + K, end(ps), [](vector<int> &a, vector<int> &b) {\\n      return a[0]*a[0]+a[1]*a[1] < b[0]*b[0]+b[1]*b[1];\\n  });\\n  ps.resize(K);\\n  return ps;\\n}\\n```\n```nth_element```\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& ps, int K) {\\n  quickselect(begin(ps), end(ps), K, [](vector<int> &a, vector<int> &b) {\\n      return a[0]*a[0]+a[1]*a[1] < b[0]*b[0]+b[1]*b[1];\\n  });\\n  ps.resize(K);\\n  return ps;\\n}\\ntemplate<class RndIt, class Compare> void quickselect(RndIt first, RndIt end, int K, Compare cmp) {\\n  auto p = partition(first, end, cmp);\\n  if (p - first + 1 == K) return;\\n  if (p - first + 1 < K) \\n      quickselect(p + 1, end, K - (p - first + 1), cmp);\\n  else \\n      quickselect(first, p, K, cmp);\\n}\\ntemplate<class RndIt, class Compare> RndIt partition(RndIt first, RndIt end, Compare cmp) {\\n  auto last = next(end, -1);\\n  auto pivot = *last;\\n  while (first < last) {\\n    while (cmp(*first, pivot))\\n        ++first;\\n    while (cmp(pivot, *last)) \\n        --last;\\n    if (first < last) {\\n        swap(*first, *last);\\n        if (!cmp(*first, *last))\\n            --last;\\n    }\\n  }\\n  return first;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 762781,
                "title": "javascript-sort-minheap-and-maxheap-solutions",
                "content": "```\\n/**\\n * @param {number[][]} points\\n * @param {number} K\\n * @return {number[][]}\\n */\\n/*\\nsort approach:\\n- need to compute all distances, we can just omit the sqrt and just do x^2 + y^2\\n- need to sort by the distance: best: n log(n)\\n- do quicksort with a custom sorting function, then take the first k elements from the array\\nruntime: O(N log(N))\\nspace: O(1)\\n*/\\nvar kClosest = function(points, K) {\\n    points.sort((a,b) => (a[0]*a[0] + a[1]*a[1]) - (b[0]*b[0] + b[1]*b[1]))\\n\\n    return points.slice(0,K)\\n};\\n\\n/*\\nmin heap approach:\\nwe can create a minHeap of the whole data set in O(n) time if we start from n/2 and heapify down each parent (see floyd method https://en.wikipedia.org/wiki/Binary_heap#Building_a_heap)\\n\\nthen we remove k times from the heap -> k * log(n) (need to heapify down on each removal)\\nruntime: O(N + k log (N))\\nspace: O(1) since we are doing it in place\\n*/\\nvar kClosest = function(points, k) {\\n    // we can build the heap in place\\n    let p = Math.floor((points.length - 2) / 2) // last parent\\n    for(let i = p; i >= 0; i--) {\\n        heapifyDown(points, i, distance)\\n    }\\n    \\n    // now we need to remove the smallest (points[0]) k times\\n    let solution = []\\n    for(let i=0; i<k; i++) {\\n        solution.push(remove(points, distance))\\n    }\\n    \\n    return solution\\n    \\n    // read 0, replace 0 with last position, heapifyDown\\n    function remove(heap, weightFunction) {\\n        let val = heap[0]\\n        heap[0] = heap.pop()\\n        heapifyDown(heap, 0, weightFunction)\\n        return val\\n    }\\n    \\n    // compare with children, swap with smallest, repeat\\n    function heapifyDown(heap, idx, weightFunction) {\\n        let left = 2*idx + 1\\n        let right = 2*idx + 2\\n        let smallest = left\\n        \\n        if(left >= heap.length) return\\n        \\n        if(right < heap.length && weightFunction(heap[left]) > weightFunction(heap[right])) {\\n            smallest = right\\n        }\\n        \\n        if (weightFunction(heap[idx]) > weightFunction(heap[smallest])) {\\n            [heap[idx], heap[smallest]] = [heap[smallest], heap[idx]]\\n            heapifyDown(heap, smallest, weightFunction)\\n        }\\n    }\\n    \\n    function distance(point) {\\n        return point[0] * point[0] + point[1] * point[1]\\n    }\\n}\\n\\n\\n/*\\nmax heap approach:\\nhave a max heap of size k, so we would do N insertions that take log(k)\\nfor this case we would need to implement heapify up (insert) and heapify down (remove)\\n\\nruntime: O(N log(k))\\nspace: O(k)\\n*/\\nvar kClosest = function(points, k) {\\n    let heap = []\\n    \\n    // now we need to try to add all points to the heap\\n    for(let i=0; i<points.length; i++) {\\n        if(heap.length >= k && distance(points[i]) > distance(heap[0])) { // it\\'s bigger than the max, we can just skip it\\n            continue\\n        }\\n        add(heap, points[i], distance)\\n        if(heap.length > k) {\\n            remove(heap, distance)\\n        }\\n    }\\n    \\n    return heap\\n    \\n    // add at end, heapify up\\n    function add(heap, node, weightFunction) {\\n        heap.push(node)\\n        heapifyUp(heap, heap.length - 1, weightFunction)\\n    }\\n    \\n    // compare with parent and swap if needed, repeat\\n    function heapifyUp(heap, idx, weightFunction) {\\n        if(idx === 0) return\\n        let parent = Math.floor((idx-1) / 2)\\n        if(weightFunction(heap[idx]) > weightFunction(heap[parent])) {\\n            [heap[idx], heap[parent]] = [heap[parent], heap[idx]]\\n            heapifyUp(heap, parent, weightFunction)\\n        }\\n    }\\n    \\n    // read 0, replace 0 with last position, heapifyDown\\n    function remove(heap, weightFunction) {\\n        let val = heap[0]\\n        heap[0] = heap.pop()\\n        heapifyDown(heap, 0, weightFunction)\\n        return val\\n    }\\n    \\n    // compare with children, swap with biggest, repeat\\n    function heapifyDown(heap, idx, weightFunction) {\\n        let left = 2*idx + 1\\n        let right = 2*idx + 2\\n        let biggest = left\\n        \\n        if(left >= heap.length) return\\n        \\n        if(right < heap.length && weightFunction(heap[left]) < weightFunction(heap[right])) {\\n            biggest = right\\n        }\\n        \\n        if (weightFunction(heap[idx]) < weightFunction(heap[biggest])) {\\n            [heap[idx], heap[biggest]] = [heap[biggest], heap[idx]]\\n            heapifyDown(heap, biggest, weightFunction)\\n        }\\n    }\\n    \\n    function distance(point) {\\n        return point[0] * point[0] + point[1] * point[1]\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * @param {number[][]} points\\n * @param {number} K\\n * @return {number[][]}\\n */\\n/*\\nsort approach:\\n- need to compute all distances, we can just omit the sqrt and just do x^2 + y^2\\n- need to sort by the distance: best: n log(n)\\n- do quicksort with a custom sorting function, then take the first k elements from the array\\nruntime: O(N log(N))\\nspace: O(1)\\n*/\\nvar kClosest = function(points, K) {\\n    points.sort((a,b) => (a[0]*a[0] + a[1]*a[1]) - (b[0]*b[0] + b[1]*b[1]))\\n\\n    return points.slice(0,K)\\n};\\n\\n/*\\nmin heap approach:\\nwe can create a minHeap of the whole data set in O(n) time if we start from n/2 and heapify down each parent (see floyd method https://en.wikipedia.org/wiki/Binary_heap#Building_a_heap)\\n\\nthen we remove k times from the heap -> k * log(n) (need to heapify down on each removal)\\nruntime: O(N + k log (N))\\nspace: O(1) since we are doing it in place\\n*/\\nvar kClosest = function(points, k) {\\n    // we can build the heap in place\\n    let p = Math.floor((points.length - 2) / 2) // last parent\\n    for(let i = p; i >= 0; i--) {\\n        heapifyDown(points, i, distance)\\n    }\\n    \\n    // now we need to remove the smallest (points[0]) k times\\n    let solution = []\\n    for(let i=0; i<k; i++) {\\n        solution.push(remove(points, distance))\\n    }\\n    \\n    return solution\\n    \\n    // read 0, replace 0 with last position, heapifyDown\\n    function remove(heap, weightFunction) {\\n        let val = heap[0]\\n        heap[0] = heap.pop()\\n        heapifyDown(heap, 0, weightFunction)\\n        return val\\n    }\\n    \\n    // compare with children, swap with smallest, repeat\\n    function heapifyDown(heap, idx, weightFunction) {\\n        let left = 2*idx + 1\\n        let right = 2*idx + 2\\n        let smallest = left\\n        \\n        if(left >= heap.length) return\\n        \\n        if(right < heap.length && weightFunction(heap[left]) > weightFunction(heap[right])) {\\n            smallest = right\\n        }\\n        \\n        if (weightFunction(heap[idx]) > weightFunction(heap[smallest])) {\\n            [heap[idx], heap[smallest]] = [heap[smallest], heap[idx]]\\n            heapifyDown(heap, smallest, weightFunction)\\n        }\\n    }\\n    \\n    function distance(point) {\\n        return point[0] * point[0] + point[1] * point[1]\\n    }\\n}\\n\\n\\n/*\\nmax heap approach:\\nhave a max heap of size k, so we would do N insertions that take log(k)\\nfor this case we would need to implement heapify up (insert) and heapify down (remove)\\n\\nruntime: O(N log(k))\\nspace: O(k)\\n*/\\nvar kClosest = function(points, k) {\\n    let heap = []\\n    \\n    // now we need to try to add all points to the heap\\n    for(let i=0; i<points.length; i++) {\\n        if(heap.length >= k && distance(points[i]) > distance(heap[0])) { // it\\'s bigger than the max, we can just skip it\\n            continue\\n        }\\n        add(heap, points[i], distance)\\n        if(heap.length > k) {\\n            remove(heap, distance)\\n        }\\n    }\\n    \\n    return heap\\n    \\n    // add at end, heapify up\\n    function add(heap, node, weightFunction) {\\n        heap.push(node)\\n        heapifyUp(heap, heap.length - 1, weightFunction)\\n    }\\n    \\n    // compare with parent and swap if needed, repeat\\n    function heapifyUp(heap, idx, weightFunction) {\\n        if(idx === 0) return\\n        let parent = Math.floor((idx-1) / 2)\\n        if(weightFunction(heap[idx]) > weightFunction(heap[parent])) {\\n            [heap[idx], heap[parent]] = [heap[parent], heap[idx]]\\n            heapifyUp(heap, parent, weightFunction)\\n        }\\n    }\\n    \\n    // read 0, replace 0 with last position, heapifyDown\\n    function remove(heap, weightFunction) {\\n        let val = heap[0]\\n        heap[0] = heap.pop()\\n        heapifyDown(heap, 0, weightFunction)\\n        return val\\n    }\\n    \\n    // compare with children, swap with biggest, repeat\\n    function heapifyDown(heap, idx, weightFunction) {\\n        let left = 2*idx + 1\\n        let right = 2*idx + 2\\n        let biggest = left\\n        \\n        if(left >= heap.length) return\\n        \\n        if(right < heap.length && weightFunction(heap[left]) < weightFunction(heap[right])) {\\n            biggest = right\\n        }\\n        \\n        if (weightFunction(heap[idx]) < weightFunction(heap[biggest])) {\\n            [heap[idx], heap[biggest]] = [heap[biggest], heap[idx]]\\n            heapifyDown(heap, biggest, weightFunction)\\n        }\\n    }\\n    \\n    function distance(point) {\\n        return point[0] * point[0] + point[1] * point[1]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 217969,
                "title": "java-python-3-6-1-liner-using-priorityqueue-heapq",
                "content": "1. Put the points into a PriorityQueue, and the order is by their distance to origin `descendingly`;\\n2. Whenever the size reaches K + 1, poll the farthest point out.\\n\\n**Analysis:**\\n\\n**Time: O(nlogK), space: O(K).**\\n\\n```java\\n    public int[][] kClosest(int[][] points, int K) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparing(a -> -a[0] * a[0] - a[1] * a[1]));\\n        for (int[] p : points) { \\n            pq.offer(p); \\n            if (pq.size() > K) { pq.poll(); } // poll out the farthest among the K + 1 points.\\n        }\\n        // int[][] ans = new int[K][2];\\n        // while (K-- > 0) { ans[K] = pq.poll(); }\\n        // return ans; // the above 3 lines can be replaced by the following line.\\n        return pq.toArray(new int[K][2]); // credit to @roolerzz, who make the code neat.\\n    }\\n```\\n\\n----\\n\\n**Analysis:**\\n\\n**Time: O(nlogK), space: O(n).**\\n```python\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        return heapq.nsmallest(K, points, lambda p: p[0] * p[0] + p[1] * p[1])\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int[][] kClosest(int[][] points, int K) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparing(a -> -a[0] * a[0] - a[1] * a[1]));\\n        for (int[] p : points) { \\n            pq.offer(p); \\n            if (pq.size() > K) { pq.poll(); } // poll out the farthest among the K + 1 points.\\n        }\\n        // int[][] ans = new int[K][2];\\n        // while (K-- > 0) { ans[K] = pq.poll(); }\\n        // return ans; // the above 3 lines can be replaced by the following line.\\n        return pq.toArray(new int[K][2]); // credit to @roolerzz, who make the code neat.\\n    }\\n```\n```python\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        return heapq.nsmallest(K, points, lambda p: p[0] * p[0] + p[1] * p[1])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 367136,
                "title": "very-simple-priorityqueue",
                "content": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n        if(K == points.length) return points;\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>(K, new Comparator<int[]>() {\\n            public int compare(int[] a, int[] b) {\\n                return (b[0]*b[0] + b[1]*b[1]) - (a[0]*a[0] + a[1]*a[1]);\\n            }\\n        });\\n        \\n        for(int[] point: points) {\\n            pq.add(point);\\n            if(pq.size() > K) pq.poll();\\n        }\\n        return pq.toArray(new int[0][0]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n        if(K == points.length) return points;\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>(K, new Comparator<int[]>() {\\n            public int compare(int[] a, int[] b) {\\n                return (b[0]*b[0] + b[1]*b[1]) - (a[0]*a[0] + a[1]*a[1]);\\n            }\\n        });\\n        \\n        for(int[] point: points) {\\n            pq.add(point);\\n            if(pq.size() > K) pq.poll();\\n        }\\n        return pq.toArray(new int[0][0]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 518968,
                "title": "cpp-quickselect-avg-o-n-clean-and-concise-beats-98",
                "content": "```\\nclass Solution {\\n    static inline int getsum(const vector<int> &v){ return v[0]*v[0]+v[1]*v[1]; }\\n    static inline bool comp(const vector<int> &l, const vector<int> &r) { return getsum(l)<=getsum(r); }\\n     \\n    //standard Quicksort(Lomuto) partition\\n    int partition(vector<vector<int>>& arr, int left, int right){\\n        vector<int> pivot = arr[right];\\n        int partitionIndex = left;\\n        for(int i = left; i<right; i++){\\n            if (comp(arr[i], pivot)) {//custom comparator for point (x, y)\\n                swap(arr[i],arr[partitionIndex]);\\n                partitionIndex++;\\n            }\\n        }\\n        swap(arr[partitionIndex], arr[right]);\\n        return partitionIndex;\\n    }\\n    void quickselect(vector<vector<int>>&v, int l, int r, int K){\\n        while(l<=r){\\n             int mid = partition(v, l, r);\\n             if (mid==K) return;\\n             if (mid<K) l = mid+1;\\n             else r = mid - 1;\\n        }\\n    }\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        quickselect(points, 0, points.size()-1, K);\\n        return vector<vector<int>>(points.begin(), points.begin() + K);\\n    }    \\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n    static inline int getsum(const vector<int> &v){ return v[0]*v[0]+v[1]*v[1]; }",
                "codeTag": "Java"
            },
            {
                "id": 1578232,
                "title": "all-possible-3-python-solutions-interviewer-expectations",
                "content": "### So this problem, has 3 possible solutions:\\n\\n**1) Basic sorting:** -->`* Time: O(NlogN), Space=O(1)*`\\nWe sort the whole array and return the first k elements\\n```\\n        return sorted(points, key=lambda x:(x[0]**2+x[1]**2))[:k] \\n```\\n\\nIf we look at the sorting solution, we will find that we are sorting the WHOLE array while the problem is asking for K-nearest, so we are doing extra work than we need to!\\nSo can we reduce it by only sorting the K we need, yes thats is ahieved using heaps.\\n\\n**2) Heaps**  -->` Time O(nlogK), Space=O(K)`\\nThis problem can easily be solved using Max heaps, why max heaps ? because we are intrested in keeping the smallest elements, so we want to pop the largest ones from the top of the stack. So make the heap pop biggest elements first, we multiply the calculated distance by -1.\\n\\n ```\\n    h=[]\\n\\n\\tfor x,y in points:\\n\\t\\tdist=math.sqrt(x**2+y**2)\\n\\t\\tif len(h)<k:\\n\\t\\t\\theapq.heappush(h,(-dist,[x,y]))\\n\\t\\telse:\\n\\t\\t\\theapq.heappushpop(h,(-dist,[x,y]))\\n\\treturn [h[i][1] for i  in range(k)]\\n```\\n\\nNow, the interviewer might ask for a different solution that *might* achieve a better time complexity, which is quick select. (Note: The interviewer might stop at the heap solution but there has been cases where the interviewer need to hear about the quick select and how it would work. So in my opinion it is important to know it.\\n\\n\\n**3) Quick-Select:** ---> `Time: O(N) best-case, O(N^2) worst case, O(1) Space`\\nQuick select implementation during an interview is not the nicest thing, but I guess walking through the solution and discussing how it would work (like what the parition function would do, what the select function does and the general idea) even if it was not  implemented fully, in my opinion it would still be a good sign, then you know how to approach this problem in different ways, trading-off time complexity and space complexity.\\n\\n```\\nimport heapq\\nimport math\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        #quick select O(n), worst case O(n2)\\n        def partition(l,r,pivot_index):\\n\\t\\t\\n            #1. move pivot to end\\n            pivot=points[pivot_index][0]**2 +points[pivot_index][1]**2\\n            points[pivot_index],points[r]=points[r],points[pivot_index]\\n            \\n            #2. now start moving elements less than pivot to left and greater to right\\n            store_index=l\\n            for i in range(l,r):\\n                if (points[i][0]**2+points[i][1]**2)<pivot:\\n                    points[store_index],points[i]=points[i],points[store_index]\\n                    store_index+=1\\n\\t\\t\\t\\t\\t\\n            #3. now store_index has the place that pivot should be stored in, swap with pivot elemnted which is stored in index r (last element)\\n            points[store_index],points[r]=points[r],points[store_index]\\n            return store_index\\n\\n        \\n        def select(l,r,k):\\n            if l<r:\\n                pivot_index=random.randint(l,r)\\n                pivot_index=partition(l,r,pivot_index)\\n\\t\\t\\t\\t\\n                if pivot_index==k:\\n                    return \\n                if pivot_index<k:\\n                    select(pivot_index+1,r,k)\\n                else:\\n                    select(l,pivot_index-1,k)\\n                \\n\\n        select(0,len(points)-1,k)\\n        \\n        return points[:k]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n        return sorted(points, key=lambda x:(x[0]**2+x[1]**2))[:k] \\n```\n```\\n    h=[]\\n\\n\\tfor x,y in points:\\n\\t\\tdist=math.sqrt(x**2+y**2)\\n\\t\\tif len(h)<k:\\n\\t\\t\\theapq.heappush(h,(-dist,[x,y]))\\n\\t\\telse:\\n\\t\\t\\theapq.heappushpop(h,(-dist,[x,y]))\\n\\treturn [h[i][1] for i  in range(k)]\\n```\n```\\nimport heapq\\nimport math\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        #quick select O(n), worst case O(n2)\\n        def partition(l,r,pivot_index):\\n\\t\\t\\n            #1. move pivot to end\\n            pivot=points[pivot_index][0]**2 +points[pivot_index][1]**2\\n            points[pivot_index],points[r]=points[r],points[pivot_index]\\n            \\n            #2. now start moving elements less than pivot to left and greater to right\\n            store_index=l\\n            for i in range(l,r):\\n                if (points[i][0]**2+points[i][1]**2)<pivot:\\n                    points[store_index],points[i]=points[i],points[store_index]\\n                    store_index+=1\\n\\t\\t\\t\\t\\t\\n            #3. now store_index has the place that pivot should be stored in, swap with pivot elemnted which is stored in index r (last element)\\n            points[store_index],points[r]=points[r],points[store_index]\\n            return store_index\\n\\n        \\n        def select(l,r,k):\\n            if l<r:\\n                pivot_index=random.randint(l,r)\\n                pivot_index=partition(l,r,pivot_index)\\n\\t\\t\\t\\t\\n                if pivot_index==k:\\n                    return \\n                if pivot_index<k:\\n                    select(pivot_index+1,r,k)\\n                else:\\n                    select(l,pivot_index-1,k)\\n                \\n\\n        select(0,len(points)-1,k)\\n        \\n        return points[:k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 660016,
                "title": "python-oneliner-using-sort",
                "content": "Even though this algorighm has not optimal algorithmic complexity (it is `O(n log n)` vs heaps `O(n log k)`, on leetcode it can work faster. Just sort points by distances and choose the smallest `K` of them\\n\\n```\\nclass Solution:\\n    def kClosest(self, points, K):\\n        return sorted(points, key = lambda x: x[0]**2 + x[1]**2)[:K]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kClosest(self, points, K):\\n        return sorted(points, key = lambda x: x[0]**2 + x[1]**2)[:K]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 600936,
                "title": "c-o-nlogk-high-speed-solution-with-detailed-explanation",
                "content": "```\\nThe give away to a heap question is whenever a question asks for k closest or k smallest or k largest.\\nThough these questions might me implemented using other algorithms heap will allow to simply the problem as well as code.\\nYour code will look compact and u can rectify ur mistakes quickly.\\nThis can be solved using miheap or maxheap.\\nThe only probem with min heap is space.It will store all the array elements and this can be costly of large elemented arrays.\\nHowever using a maxheap we just need to be storing k elements.\\nThat is all the difference between them.\\n\\nLet points = [[1,3],[-2,2]], K = 1\\nThe way to judge whether a point is clore or not is to find the euclidean distance.\\nNote:u dont have to perform square root and make the code look complex moreover it s more prone to errors.\\n\\ndist = x*x+y*y\\nWe have the choose the k smallest distance values.\\n\\nLets see the above question:\\n\\ndist = 1*1 + 3*3 = 10\\ndist = -2*-2 + 2*2 = 8\\n\\nWe can see that dist of the 2nd element is smaller and question asks for only 1 so we pushback that element into our ans array.\\n    \\n\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<vector<int>> ans;\\n        if(points.size()==0)return ans;\\n        priority_queue<pair<int,pair<int,int>>> pq;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            int dist=points[i][0]*points[i][0]+points[i][1]*points[i][1];\\n            if(pq.size()<k)\\n            pq.push({dist,{points[i][0],points[i][1]}});\\n            else\\n            {\\n                if(dist<pq.top().first)\\n                {\\n                    pq.pop();\\n                    pq.push({dist,{points[i][0],points[i][1]}});\\n                }\\n            }\\n        }\\n        while(!pq.empty())\\n        {\\n            ans.push_back({pq.top().second.first,pq.top().second.second});\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nThe give away to a heap question is whenever a question asks for k closest or k smallest or k largest.\\nThough these questions might me implemented using other algorithms heap will allow to simply the problem as well as code.\\nYour code will look compact and u can rectify ur mistakes quickly.\\nThis can be solved using miheap or maxheap.\\nThe only probem with min heap is space.It will store all the array elements and this can be costly of large elemented arrays.\\nHowever using a maxheap we just need to be storing k elements.\\nThat is all the difference between them.\\n\\nLet points = [[1,3],[-2,2]], K = 1\\nThe way to judge whether a point is clore or not is to find the euclidean distance.\\nNote:u dont have to perform square root and make the code look complex moreover it s more prone to errors.\\n\\ndist = x*x+y*y\\nWe have the choose the k smallest distance values.\\n\\nLets see the above question:\\n\\ndist = 1*1 + 3*3 = 10\\ndist = -2*-2 + 2*2 = 8\\n\\nWe can see that dist of the 2nd element is smaller and question asks for only 1 so we pushback that element into our ans array.\\n    \\n\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<vector<int>> ans;\\n        if(points.size()==0)return ans;\\n        priority_queue<pair<int,pair<int,int>>> pq;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            int dist=points[i][0]*points[i][0]+points[i][1]*points[i][1];\\n            if(pq.size()<k)\\n            pq.push({dist,{points[i][0],points[i][1]}});\\n            else\\n            {\\n                if(dist<pq.top().first)\\n                {\\n                    pq.pop();\\n                    pq.push({dist,{points[i][0],points[i][1]}});\\n                }\\n            }\\n        }\\n        while(!pq.empty())\\n        {\\n            ans.push_back({pq.top().second.first,pq.top().second.second});\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 455176,
                "title": "java-quick-select-for-beginner",
                "content": "Here is a very good entity visualization video:\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/MZaf_9IZCrc\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\\n\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n        int i = 0, j = points.length - 1;\\n        while(i < j) {\\n            int mid = partition(points, i, j);\\n            if(mid == K) break;\\n            if(mid < K) {\\n                i = mid + 1;\\n            } else {\\n                j = mid - 1;\\n            }\\n        }\\n        return Arrays.copyOf(points, K);\\n    }\\n    \\n    private int partition(int[][] points, int start, int end) {\\n        int[] pivot = points[end];\\n        int swapIndex = start - 1;\\n        for(int i = start; i < end; i++) {\\n            if(value(points[i]) < value(pivot)) {\\n                swapIndex++;\\n                swap(points, swapIndex, i);\\n            }\\n        }\\n        swap(points, ++swapIndex, end);\\n        return swapIndex;\\n    }\\n    \\n    private int value(int[] a) {\\n        return a[0] * a[0] + a[1] * a[1];\\n    }\\n    \\n    private void swap(int[][] points, int i, int j) {\\n        int[] temp = points[i];\\n        points[i] = points[j];\\n        points[j] = temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Quickselect"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n        int i = 0, j = points.length - 1;\\n        while(i < j) {\\n            int mid = partition(points, i, j);\\n            if(mid == K) break;\\n            if(mid < K) {\\n                i = mid + 1;\\n            } else {\\n                j = mid - 1;\\n            }\\n        }\\n        return Arrays.copyOf(points, K);\\n    }\\n    \\n    private int partition(int[][] points, int start, int end) {\\n        int[] pivot = points[end];\\n        int swapIndex = start - 1;\\n        for(int i = start; i < end; i++) {\\n            if(value(points[i]) < value(pivot)) {\\n                swapIndex++;\\n                swap(points, swapIndex, i);\\n            }\\n        }\\n        swap(points, ++swapIndex, end);\\n        return swapIndex;\\n    }\\n    \\n    private int value(int[] a) {\\n        return a[0] * a[0] + a[1] * a[1];\\n    }\\n    \\n    private void swap(int[][] points, int i, int j) {\\n        int[] temp = points[i];\\n        points[i] = points[j];\\n        points[j] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 268190,
                "title": "python-quick-select-o-n",
                "content": "Time complexity: **O(n)** (even at worst case thanks to the median of median method)\\nSpace complexity: **O(n)**. It can be improved to **O(1)** with in-place swap.\\n\\nThis quick select method has better time complexity than heap method ( O(n log k) ). However, heap method can handle in-stream data (i.e., not given all at once). So, if you are asked this question in interview, you can implement either one but make sure to mention the other and talk about suitable use case. Also, this sub-optimal space complexity implemention is enough in the interview, coz you need enough time to explain clearly on what you are doing. Just make sure to mention in-place swap can improve space complexity to constant.\\n\\nCodes are straightforward. See in-line comments.\\n\\n```\\nclass Solution:\\n    def kClosest(self, points, K):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :type K: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        def quick_select(lst, k):\\n            \"\"\"\\n            This function is to get the k-th order statistics.\\n            Time complexity is O(n) even at worst case.\\n            \"\"\"\\n            \\n            # handle the part at the end of the recursion\\n            if k==0: return min(lst)\\n            if k==len(lst): return max(lst)\\n            if len(lst)<=10:\\n                return sorted(lst)[k-1]\\n\\n            # select pivot - using median of median to make sure worst case O(n) complexity\\n            medians = [sorted(lst[i*5:i*5+5])[2] for i in range(len(lst)//5)]\\n            pivot = quick_select(medians, len(medians)//2)\\n\\n            # separate lst by values smaller, equal or larger than pivot\\n            # here I don\\'t use in-place swap to make codes easy and clean. \\n            smaller = [i for i in lst if i<pivot]\\n            equal = [i for i in lst if i==pivot]\\n            larger = [i for i in lst if i>pivot]\\n\\n            # recursion\\n            if len(smaller)>=k:\\n                return quick_select(smaller, k)\\n            elif len(smaller)+len(equal) >= k:\\n                return pivot\\n            else:\\n                return quick_select(larger, k-len(smaller)-len(equal))\\n            \\n        distance = [i[0]**2+i[1]**2 for i in points]\\n        kth_order_stat = quick_select(distance, K)\\n        return [points[i] for i in range(len(points)) if distance[i] <= kth_order_stat]\\n```",
                "solutionTags": [
                    "Quickselect"
                ],
                "code": "```\\nclass Solution:\\n    def kClosest(self, points, K):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :type K: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        def quick_select(lst, k):\\n            \"\"\"\\n            This function is to get the k-th order statistics.\\n            Time complexity is O(n) even at worst case.\\n            \"\"\"\\n            \\n            # handle the part at the end of the recursion\\n            if k==0: return min(lst)\\n            if k==len(lst): return max(lst)\\n            if len(lst)<=10:\\n                return sorted(lst)[k-1]\\n\\n            # select pivot - using median of median to make sure worst case O(n) complexity\\n            medians = [sorted(lst[i*5:i*5+5])[2] for i in range(len(lst)//5)]\\n            pivot = quick_select(medians, len(medians)//2)\\n\\n            # separate lst by values smaller, equal or larger than pivot\\n            # here I don\\'t use in-place swap to make codes easy and clean. \\n            smaller = [i for i in lst if i<pivot]\\n            equal = [i for i in lst if i==pivot]\\n            larger = [i for i in lst if i>pivot]\\n\\n            # recursion\\n            if len(smaller)>=k:\\n                return quick_select(smaller, k)\\n            elif len(smaller)+len(equal) >= k:\\n                return pivot\\n            else:\\n                return quick_select(larger, k-len(smaller)-len(equal))\\n            \\n        distance = [i[0]**2+i[1]**2 for i in points]\\n        kth_order_stat = quick_select(distance, K)\\n        return [points[i] for i in range(len(points)) if distance[i] <= kth_order_stat]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 659966,
                "title": "python-easy-heap-o-n-log-k-solution-explained",
                "content": "When you see in the statement of the problem that you need you find k biggest or k smallest elements, you should immediately think about heaps or sort. Here we need to find the k smallest elements, and hence we need to keep **max** heap. Why max and not min? We always keep in the root of our heap the `k`-th smallest element. Let us go through example: `points = [[1,2],[2,3],[0,1]], [3,4]`, `k = 2`. \\n1. First we put points `[1,2]` and `[2,3]` into our heap. In the root of the heap we have maximum element `[2,3]`\\n2. Now, we see new element `[0,1]`, what should we do? We compare it with the root, see, that it is smaller than root, so we need to remove it from our heap and put new element instead, now we have elements `[1,2]` and `[0,1]` in our heap, root is `[1,2]`\\n3. Next element is `[3,4]` and it is greater than our root, it means we do not need to do anything.\\n\\n### Complexity\\nWe process elements one by one, there are `n` of them and push it into heap and pop root from our heap, both have `O(log k)` complexity, so finally we have `O(n log k)` complexity, which is faster than `O(n log n)` algorighm using sorting.\\n\\n### Code:\\nFirst, we create heap (which is by definition **min** heap in python, so we use negative distances). Then we visit all the rest elements one by one and update our heap if needed.\\n\\n```\\nclass Solution:\\n    def kClosest(self, points, K):\\n        heap = [[-i*i-j*j, i, j] for i,j in points[:K]]\\n        rest_elem = [[-i*i-j*j, i, j] for i,j in points[K:]]\\n        heapq.heapify(heap)\\n        for s, x, y in rest_elem:\\n            if s > heap[0][0]:\\n                heapq.heappush(heap, [s,x,y])\\n                heapq.heappop(heap)\\n\\n        return [[x,y] for s,x,y in heap]\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def kClosest(self, points, K):\\n        heap = [[-i*i-j*j, i, j] for i,j in points[:K]]\\n        rest_elem = [[-i*i-j*j, i, j] for i,j in points[K:]]\\n        heapq.heapify(heap)\\n        for s, x, y in rest_elem:\\n            if s > heap[0][0]:\\n                heapq.heappush(heap, [s,x,y])\\n                heapq.heappop(heap)\\n\\n        return [[x,y] for s,x,y in heap]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 411088,
                "title": "java-solutions-with-exp-comments-sorting-heap-quickselect",
                "content": "Reference: [LeetCode](https://leetcode.com/problems/k-closest-points-to-origin/) <span class=\"gray\">EPI 10.4</span>\\nDifficulty: <span class=\"orange\">Medium</span>\\n\\n## Problem\\n\\n> We have a list of `points` on the plane.  Find the `K` closest points to the origin `(0, 0)`.\\n\\n> (Here, the distance between two points on a plane is the Euclidean distance.)\\n\\n> You may return the answer `in any order`.  The answer is guaranteed to be unique (except for the order that it is in.)\\n\\n**Example:** \\n\\n```java\\nInput: points = [[1,3],[-2,2]], K = 1\\nOutput: [[-2,2]]\\n```\\n\\n```java\\nInput: points = [[3,3],[5,-1],[-2,4]], K = 2\\nOutput: [[3,3],[-2,4]]\\n```\\n\\n## Analysis\\n\\n\\n### Sorting\\n\\nFirst let\\'s define the distance calculation method.\\n\\n```java\\nprivate int dis(int[] p) { // square\\n  return p[0] * p[0] + p[1] * p[1];\\n}\\n```\\n\\n\\n```java\\n// input: [[3,3],[5,-1],[-2,4]]\\npublic int[][] kClosest(int[][] points, int K) {\\n  Arrays.sort(points, (p1, p2) -> {  // comparator\\n    return dis(p1) - dis(p2); // <\\n  });\\n  int[][] result = new int[K][];\\n  for (int i = 0; i < K; ++i) {\\n    result[i] = new int[] { points[i][0], points[i][1] };\\n  }\\n  return result;\\n}\\n```\\n\\n**Time:** `O(N\\\\log{N})`\\n**Space:** `O(K)`\\n\\n\\n\\n### Max Heap\\n\\nSince we want K smallest elements, we use a K-size max heap. We repeatedly add elements to the heap. When the size is greater than K, we remove the largest element.\\n\\n\\n```java\\npublic int[][] kClosest(int[][] points, int K) {\\n  PriorityQueue<Integer> pq = new PriorityQueue<>((i1, i2) -> {\\n    return dis(points[i2]) - dis(points[i1]);\\n  });\\n  for (int i = 0; i < points.length; ++i) {\\n    pq.add(i);\\n    if (pq.size() > K) {\\n      pq.remove();\\n    }\\n  }\\n  // result\\n  int[][] result = new int[K][];\\n  for (int i = 0; i < K; ++i) {\\n    int idx = pq.remove();\\n    result[i] = points[idx]; // can be returned in any order\\n  }\\n  return result;\\n}\\n```\\n\\nWe can also write the comparator like this.\\n\\n```java\\nComparator<int[]> comp = (p1, p2) -> (\\n  return dis(p2) - dis(p1);\\n);\\nPriorityQueue<int[]> pq = new PriorityQueue<>(comp);\\n```\\n\\n**Time:** `O(N\\\\log{K})`\\n**Space:** `O(K)`\\n\\n\\n\\n\\n### Quick Select\\n\\nThe idea of Quick Select is to find the K-th element, make elements on the left less than the K-th element, and make elements on the right greater than the K-th element.\\n\\nWe randomly pick an element. If it turns out to be the actual K-th element, we can stop at the first step. So it depends on luck.\\n\\nAfter swapping, if this element turns out to be an element to the left of the K-th element, we recursively solve the subproblem for the right subarray; if it is to the right, we solve it for the left subarray.\\n\\n**Note:** To make code cleaner, after we pick the random index, we place the element at the beginning before doing swapping.\\n\\n\\n```java\\n// quickSelect\\npublic int[][] kClosest(int[][] points, int K) {\\n  int n = points.length;\\n  quickSelect(points, K - 1, 0, n - 1); // index from 0\\n  int[][] result = new int[K][];\\n  for (int i = 0; i < K; ++i) {\\n    result[i] = points[i];\\n  }\\n  return result;\\n}\\n\\n// find the k-th element (from 0 ~ hi - 1)\\nprivate void quickSelect(int[][] points, int k, int lo, int hi) {\\n  if (lo == hi) {\\n    return;\\n  }\\n  Random rand = new Random();\\n  int randIdx = lo + rand.nextInt(hi - lo + 1); // lo + (0 ~ #element)\\n  // place the key to the beginning\\n  swap(points, lo, randIdx);\\n  int key = lo;\\n  int i = lo, j = hi + 1; // one index offset\\n\\n  while (true) {\\n    while (dis(points[++i]) < dis(points[key])) { // move i\\n      if (i == hi) break;\\n    }\\n    while (dis(points[--j]) > dis(points[key])) { // move j\\n      if (j == lo) break;\\n    }\\n    if (i >= j) break;\\n    swap(points, i, j);\\n  }\\n  swap(points, key, j); // put [key] to the correct place [<key] [key] [>key]\\n\\n  // notice that k = K - 1\\n  // j is now where [key] is\\n  if (j > k) quickSelect(points, k, lo, j - 1); // left\\n  if (j < k) quickSelect(points, k, j + 1, hi); // right\\n  // if j == k, finish.\\n}\\n\\nprivate void swap(int[][] points, int i, int j) {\\n  int[] temp = points[i];\\n  points[i] = points[j];\\n  points[j] = temp;\\n}\\n```\\n\\n**Time:** `O(\\\\log{N})` in average; `O(N)` in the worst case.\\n**Space:** `O(\\\\log{N})` in average; `O(N)` in the worst case (call stack).",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)",
                    "Quickselect"
                ],
                "code": "```java\\nInput: points = [[1,3],[-2,2]], K = 1\\nOutput: [[-2,2]]\\n```\n```java\\nInput: points = [[3,3],[5,-1],[-2,4]], K = 2\\nOutput: [[3,3],[-2,4]]\\n```\n```java\\nprivate int dis(int[] p) { // square\\n  return p[0] * p[0] + p[1] * p[1];\\n}\\n```\n```java\\n// input: [[3,3],[5,-1],[-2,4]]\\npublic int[][] kClosest(int[][] points, int K) {\\n  Arrays.sort(points, (p1, p2) -> {  // comparator\\n    return dis(p1) - dis(p2); // <\\n  });\\n  int[][] result = new int[K][];\\n  for (int i = 0; i < K; ++i) {\\n    result[i] = new int[] { points[i][0], points[i][1] };\\n  }\\n  return result;\\n}\\n```\n```java\\npublic int[][] kClosest(int[][] points, int K) {\\n  PriorityQueue<Integer> pq = new PriorityQueue<>((i1, i2) -> {\\n    return dis(points[i2]) - dis(points[i1]);\\n  });\\n  for (int i = 0; i < points.length; ++i) {\\n    pq.add(i);\\n    if (pq.size() > K) {\\n      pq.remove();\\n    }\\n  }\\n  // result\\n  int[][] result = new int[K][];\\n  for (int i = 0; i < K; ++i) {\\n    int idx = pq.remove();\\n    result[i] = points[idx]; // can be returned in any order\\n  }\\n  return result;\\n}\\n```\n```java\\nComparator<int[]> comp = (p1, p2) -> (\\n  return dis(p2) - dis(p1);\\n);\\nPriorityQueue<int[]> pq = new PriorityQueue<>(comp);\\n```\n```java\\n// quickSelect\\npublic int[][] kClosest(int[][] points, int K) {\\n  int n = points.length;\\n  quickSelect(points, K - 1, 0, n - 1); // index from 0\\n  int[][] result = new int[K][];\\n  for (int i = 0; i < K; ++i) {\\n    result[i] = points[i];\\n  }\\n  return result;\\n}\\n\\n// find the k-th element (from 0 ~ hi - 1)\\nprivate void quickSelect(int[][] points, int k, int lo, int hi) {\\n  if (lo == hi) {\\n    return;\\n  }\\n  Random rand = new Random();\\n  int randIdx = lo + rand.nextInt(hi - lo + 1); // lo + (0 ~ #element)\\n  // place the key to the beginning\\n  swap(points, lo, randIdx);\\n  int key = lo;\\n  int i = lo, j = hi + 1; // one index offset\\n\\n  while (true) {\\n    while (dis(points[++i]) < dis(points[key])) { // move i\\n      if (i == hi) break;\\n    }\\n    while (dis(points[--j]) > dis(points[key])) { // move j\\n      if (j == lo) break;\\n    }\\n    if (i >= j) break;\\n    swap(points, i, j);\\n  }\\n  swap(points, key, j); // put [key] to the correct place [<key] [key] [>key]\\n\\n  // notice that k = K - 1\\n  // j is now where [key] is\\n  if (j > k) quickSelect(points, k, lo, j - 1); // left\\n  if (j < k) quickSelect(points, k, j + 1, hi); // right\\n  // if j == k, finish.\\n}\\n\\nprivate void swap(int[][] points, int i, int j) {\\n  int[] temp = points[i];\\n  points[i] = points[j];\\n  points[j] = temp;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 659927,
                "title": "python-sorting-by-distance-w-visualization",
                "content": "Python sorting by distance\\n\\n---\\n\\n**Hint**:\\n\\nRecall the definition of [Euclidean distance](https://en.wikipedia.org/wiki/Euclidean_distance).\\n\\nLaunch customized sorting to sort points by distance to origin.\\n\\n---\\n\\n**Illustration** and **Visualization**:\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1590842183.png)\\n\\n\\n---\\n\\n**Implementation** by sorting with distance:\\n\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        \\n        # sort by the distance to origin, in ascending order\\n        points.sort( key = lambda point: (point[0]**2 + point[1]**2) )\\n        \\n        return points[:K]\\n```\\n\\n---\\n\\n**Implementation** by heap sort with distance:\\n\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        \\n                \\n        # sort by the distance to origin, in ascending order\\n        k_closet = heapq.nsmallest( K, points, key = lambda point: point[0]**2 + point[1]**2  )\\n        \\n        return k_closet\\n```\\n\\n---\\n\\nReference:\\n\\n[1] [Python official docs about sorting as well as customized sorting](https://docs.python.org/3/howto/sorting.html#sorting-how-to)\\n\\n[2] [Python official docs about heap and heap sort](https://docs.python.org/3.8/library/heapq.html)",
                "solutionTags": [
                    "Python",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        \\n        # sort by the distance to origin, in ascending order\\n        points.sort( key = lambda point: (point[0]**2 + point[1]**2) )\\n        \\n        return points[:K]\\n```\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        \\n                \\n        # sort by the distance to origin, in ascending order\\n        k_closet = heapq.nsmallest( K, points, key = lambda point: point[0]**2 + point[1]**2  )\\n        \\n        return k_closet\\n```",
                "codeTag": "Java"
            },
            {
                "id": 218911,
                "title": "two-types-of-python-1-linear-o-n-lgn-and-o-n-lgk",
                "content": "#### *O(N.lgN)*\\n```\\ndef kClosest(self, points, K):\\n\\treturn sorted(points,key=lambda x:x[0]**2+x[1]**2)[:K]\\n```\\n#### *O(N.lgK), 1-Linear* \\nheapq.nsmallest(n, iterable[, key])\\nReturn a list with the n smallest elements from the dataset defined by iterable. key, if provided, specifies a function of one argument that is used to extract a comparison key from each element in the iterable: key=str.lower Equivalent to: sorted(iterable, key=key[:n]\\nResource: https://docs.python.org/2/library/heapq.html\\n```\\ndef kClosest(self, points, K):\\n\\treturn heapq.nsmallest(K, points, lambda x: x[0]**2+x[1]**2)\\n```\\n\\n#### *O(N.lgK), Other type of second type* \\n```\\ndef kClosest(self, points, K):\\n\\theap=[]\\n    for a,b in points:\\n\\t\\td=a*a+b*b\\n\\t\\theapq.heappush(heap,(-d,a,b)) # -d is for inverse value of data ( pop minimum distance instead of maximum )\\n        if len(heap)>K: # Keep length of heap in size K\\n\\t\\t\\theapq.heappop(heap)\\n\\treturn [[b,c] for a,b,c in heap]\\n```\\nWhat\\'s the \"lambda\" ?\\nSmall anonymous functions can be created with the lambda keyword. This function returns the sum of its two arguments: lambda a, b: a+b. Lambda functions can be used wherever function objects are required. They are syntactically restricted to a single expression. Semantically, they are just syntactic sugar for a normal function definition. Like nested function definitions, lambda functions can reference variables from the containing scope:\\n```\\n>> def make_incrementor(n):\\n>> return lambda x: x + n\\n...\\n>> f = make_incrementor(42)\\n>> f(0)\\n42\\n>> f(1)\\n43\\n```\\nResource : https://docs.python.org/3/tutorial/controlflow.html",
                "solutionTags": [],
                "code": "```\\ndef kClosest(self, points, K):\\n\\treturn sorted(points,key=lambda x:x[0]**2+x[1]**2)[:K]\\n```\n```\\ndef kClosest(self, points, K):\\n\\treturn heapq.nsmallest(K, points, lambda x: x[0]**2+x[1]**2)\\n```\n```\\ndef kClosest(self, points, K):\\n\\theap=[]\\n    for a,b in points:\\n\\t\\td=a*a+b*b\\n\\t\\theapq.heappush(heap,(-d,a,b)) # -d is for inverse value of data ( pop minimum distance instead of maximum )\\n        if len(heap)>K: # Keep length of heap in size K\\n\\t\\t\\theapq.heappop(heap)\\n\\treturn [[b,c] for a,b,c in heap]\\n```\n```\\n>> def make_incrementor(n):\\n>> return lambda x: x + n\\n...\\n>> f = make_incrementor(42)\\n>> f(0)\\n42\\n>> f(1)\\n43\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 662072,
                "title": "c-short-and-easy-to-understand-using-vectors",
                "content": "The idea is to find distance of each point from origin and store it in an array of pairs consisting of distance and the point in each pair.Then sort the array according to distance and then store the first K  points in the answer array and return it .\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        vector<vector<int>> answer;\\n        vector<pair<double,vector<int>>> distances;\\n        for(auto i:points){\\n            double distance=sqrt(pow(i[0],2)+pow(i[1],2));\\n            distances.push_back(make_pair(distance,i));\\n        }\\n        sort(distances.begin(),distances.end());\\n        for(int i=0;i<K;i++)answer.push_back(distances[i].second);\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        vector<vector<int>> answer;\\n        vector<pair<double,vector<int>>> distances;\\n        for(auto i:points){\\n            double distance=sqrt(pow(i[0],2)+pow(i[1],2));\\n            distances.push_back(make_pair(distance,i));\\n        }\\n        sort(distances.begin(),distances.end());\\n        for(int i=0;i<K;i++)answer.push_back(distances[i].second);\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 377034,
                "title": "python-sort-heap-divide-and-conquer-solutions",
                "content": "1. Sort the distance, O(nlogn); O(n)\\n```\\nclass Solution(object):\\n    def kClosest(self, points, K):\\n        points.sort(key = lambda p: p[0]**2 + p[1] ** 2)\\n        return points[:K]\\n```\\n2. heapq, O(nlogk); O(k)\\n```\\nclass Solution(object):\\n    def kClosest(self, points, K):\\n        import heapq\\n        heap = []\\n        for p in points:\\n            x, y = p[0], p[1]\\n            dist = -(x*x + y*y)\\n            if len(heap) == K:\\n                heapq.heappushpop(heap, (dist, p))\\n            else:\\n                heapq.heappush(heap, (dist, p))\\n        return [p for (dist, p) in heap]\\n```\\n3. divide and conquer, avg O(n), worst (n^2); O(n), can be further reduced using in-place\\n```\\nclass Solution(object):\\n    def kClosest(self, points, K):\\n\\t\\tdef findK(Points, K):\\n            if K == 0:\\n                return []\\n            if len(Points) <= K:\\n                return [p[1] for p in Points]\\n\\n            pivot, left, right = Points[0], [], []\\n            for p in Points:\\n                if p[0] > pivot[0]:\\n                    right.append(p)\\n                elif p[0] < pivot[0]:\\n                    left.append(p)\\n            \\n            if len(left) >= K:\\n                return findK(left, K)\\n            else:\\n                return [l[1] for l in left] + [pivot[1]] + findK(right, K - 1 - len(left))\\n            \\n        Points = [[p[0]**2 + p[1]**2, p] for p in points]\\n        return findK(Points, K)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def kClosest(self, points, K):\\n        points.sort(key = lambda p: p[0]**2 + p[1] ** 2)\\n        return points[:K]\\n```\n```\\nclass Solution(object):\\n    def kClosest(self, points, K):\\n        import heapq\\n        heap = []\\n        for p in points:\\n            x, y = p[0], p[1]\\n            dist = -(x*x + y*y)\\n            if len(heap) == K:\\n                heapq.heappushpop(heap, (dist, p))\\n            else:\\n                heapq.heappush(heap, (dist, p))\\n        return [p for (dist, p) in heap]\\n```\n```\\nclass Solution(object):\\n    def kClosest(self, points, K):\\n\\t\\tdef findK(Points, K):\\n            if K == 0:\\n                return []\\n            if len(Points) <= K:\\n                return [p[1] for p in Points]\\n\\n            pivot, left, right = Points[0], [], []\\n            for p in Points:\\n                if p[0] > pivot[0]:\\n                    right.append(p)\\n                elif p[0] < pivot[0]:\\n                    left.append(p)\\n            \\n            if len(left) >= K:\\n                return findK(left, K)\\n            else:\\n                return [l[1] for l in left] + [pivot[1]] + findK(right, K - 1 - len(left))\\n            \\n        Points = [[p[0]**2 + p[1]**2, p] for p in points]\\n        return findK(Points, K)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 659955,
                "title": "c-priority-queue-solution",
                "content": "```\\nint dist( vector<int> &point ) {\\n        return point[0]*point[0] + point[1]*point[1];    \\n    }\\n    \\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        typedef pair<int, int> pi;\\n        \\n        int distance;\\n        priority_queue< pi > maxHeap; // <distance, index> pair\\n        for( int i=0; i < points.size(); i++ ) {\\n            distance = dist( points[i] );\\n            if( maxHeap.size() < K )\\n                maxHeap.push( { distance, i } );\\n            else if( distance < maxHeap.top().first ) {\\n                    maxHeap.push( { distance, i } );\\n                    maxHeap.pop();\\n            }\\n        }\\n        \\n        vector<vector<int>> result;\\n        while( !maxHeap.empty() ) {\\n            result.push_back( points[ maxHeap.top().second ] );\\n            maxHeap.pop();\\n        }\\n        return result;\\n    }\\n```\\nUpvotes are encouraging",
                "solutionTags": [],
                "code": "```\\nint dist( vector<int> &point ) {\\n        return point[0]*point[0] + point[1]*point[1];    \\n    }\\n    \\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        typedef pair<int, int> pi;\\n        \\n        int distance;\\n        priority_queue< pi > maxHeap; // <distance, index> pair\\n        for( int i=0; i < points.size(); i++ ) {\\n            distance = dist( points[i] );\\n            if( maxHeap.size() < K )\\n                maxHeap.push( { distance, i } );\\n            else if( distance < maxHeap.top().first ) {\\n                    maxHeap.push( { distance, i } );\\n                    maxHeap.pop();\\n            }\\n        }\\n        \\n        vector<vector<int>> result;\\n        while( !maxHeap.empty() ) {\\n            result.push_back( points[ maxHeap.top().second ] );\\n            maxHeap.pop();\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 375452,
                "title": "javascript-very-simple-and-easy-to-understand",
                "content": "I felt the one liner solution is not how I write actual code. This is much easier to reason about.\\n\\n```javascript\\n/**\\n * @param {number[][]} points\\n * @param {number} K\\n * @return {number[][]}\\n */\\nvar kClosest = function(points, K) {\\n    return points.sort((a, b) => getLength(a) - getLength(b)).slice(0, K);\\n};\\n\\n// we don\\'t need to find square root of c here\\n// squared length is enough to determine order\\nvar getLength = function([a, b]) {\\n    return (a * a) + (b * b);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number[][]} points\\n * @param {number} K\\n * @return {number[][]}\\n */\\nvar kClosest = function(points, K) {\\n    return points.sort((a, b) => getLength(a) - getLength(b)).slice(0, K);\\n};\\n\\n// we don\\'t need to find square root of c here\\n// squared length is enough to determine order\\nvar getLength = function([a, b]) {\\n    return (a * a) + (b * b);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1703675,
                "title": "c-aditya-verma-type-of-code-priority-queue",
                "content": "```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        priority_queue<pair<int,pair<int,int>>> pq;\\n        \\n        int n = points.size();\\n        //ans to contain the answer\\n        vector<vector<int>> ans;\\n        //loop through the matrix\\n        for(int i = 0;i<n;i++){\\n            //Push x^2+y^2 as it is relative\\n            //Push distance, coordinate in max heap\\n         pq.push({(points[i][0]*points[i][0]) + (points[i][1]*points[i][1]),\\n         {points[i][0],points[i][1]}});\\n            //max heap keep the largest value at top \\n            //we can remove the larger values than k until the size is < k\\n                while(pq.size()>k)\\n                    pq.pop(); //pop the > k value\\n            //sorting is done on the basis on distance\\n            \\n        }\\n        \\n        //The left over elements in priority queue is the answer\\n        while(pq.size()>0){\\n        pair<int,int> p = pq.top().second; //store the second value which is coordinate in a pair\\n        ans.push_back({p.first,p.second}); //push the pair\\'s first and second value, basically the coordinates\\n        pq.pop(); //pop then and update the top\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        priority_queue<pair<int,pair<int,int>>> pq;\\n        \\n        int n = points.size();\\n        //ans to contain the answer\\n        vector<vector<int>> ans;\\n        //loop through the matrix\\n        for(int i = 0;i<n;i++){\\n            //Push x^2+y^2 as it is relative\\n            //Push distance, coordinate in max heap\\n         pq.push({(points[i][0]*points[i][0]) + (points[i][1]*points[i][1]),\\n         {points[i][0],points[i][1]}});\\n            //max heap keep the largest value at top \\n            //we can remove the larger values than k until the size is < k\\n                while(pq.size()>k)\\n                    pq.pop(); //pop the > k value\\n            //sorting is done on the basis on distance\\n            \\n        }\\n        \\n        //The left over elements in priority queue is the answer\\n        while(pq.size()>0){\\n        pair<int,int> p = pq.top().second; //store the second value which is coordinate in a pair\\n        ans.push_back({p.first,p.second}); //push the pair\\'s first and second value, basically the coordinates\\n        pq.pop(); //pop then and update the top\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1507637,
                "title": "java-solution-using-priorityqueue",
                "content": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>(\\n        (p1, p2) -> getDistance(p1).compareTo(getDistance(p2)));\\n        \\n        for(int i = 0; i < points.length; i++) {\\n            pq.add(points[i]);\\n        }\\n        \\n        int[][] result = new int[k][2];\\n        \\n        for(int i = 0; i < k; i++) {\\n            result[i] = pq.poll();    \\n        }\\n        \\n        return result;\\n    }\\n    \\n    private Double getDistance(int[] point) {\\n        return Math.sqrt((point[0] * point[0]) + (point[1] * point[1]));\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>(\\n        (p1, p2) -> getDistance(p1).compareTo(getDistance(p2)));\\n        \\n        for(int i = 0; i < points.length; i++) {\\n            pq.add(points[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 218888,
                "title": "java-priority-queue-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n        Queue<int[]> queue=new PriorityQueue<>((a, b) -> (a[0]*a[0]+a[1]*a[1])-(b[0]*b[0]+b[1]*b[1]));\\n        int[][] res=new int[K][2];\\n        int index=0;\\n        for(int[] arr:points) {\\n            queue.add(arr);\\n        }\\n        while(index<K) {\\n            res[index]=queue.poll();\\n            index++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n        Queue<int[]> queue=new PriorityQueue<>((a, b) -> (a[0]*a[0]+a[1]*a[1])-(b[0]*b[0]+b[1]*b[1]));\\n        int[][] res=new int[K][2];\\n        int index=0;\\n        for(int[] arr:points) {\\n            queue.add(arr);\\n        }\\n        while(index<K) {\\n            res[index]=queue.poll();\\n            index++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 661175,
                "title": "java-clean-code-o-n-log-n-solution-hashmap-sorting-and-minheap-approach",
                "content": "### **Approach 1: HashMap **\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n        \\n        HashMap<Integer, Double> map = new HashMap<>();\\n        for(int i = 0; i < points.length; i++) {\\n            double distance = Math.sqrt(points[i][0] * points[i][0] + points[i][1] * points[i][1]);\\n            map.put(i, distance);\\n        }\\n        \\n        List<Map.Entry<Integer, Double>> sortList = new LinkedList<>(map.entrySet());\\n        Collections.sort(sortList, (a, b) -> a.getValue().compareTo(b.getValue()));\\n        \\n        int[][] ans = new int[K][2];\\n        int i = 0;\\n        for(Map.Entry entry : sortList) {\\n            int key = (int) entry.getKey();\\n            ans[i][0] = points[key][0];\\n            ans[i][1] = points[key][1];\\n            i++;\\n            if(i == K) break;\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n\\n## Approach 2: Sorting ****\\n```\\nclass Solution {\\n \\n\\tprivate int calculateDistance(int[] point) {\\n\\t\\treturn point[0] * point[0] + point[1] * point[1];\\n\\t}\\n \\n\\tpublic int[][] kClosest(int[][] points, int K) {\\n \\n\\t\\tint[] distance = new int[points.length];\\n\\t\\tfor(int i = 0; i < points.length; i++) \\n            distance[i] = calculateDistance(points[i]);\\n \\n\\t\\tArrays.sort(distance);\\n\\t\\tint kthDistance = distance[K - 1];\\n\\t\\tint[][] kClosestPoints = new int[K][2];\\n \\n\\t\\tfor(int i = 0, j = 0; i < points.length && j < K; i++) \\n\\t\\t\\tif(calculateDistance(points[i]) <= kthDistance)\\n\\t\\t\\t\\tkClosestPoints[j++] = points[i];\\n \\n\\t\\treturn kClosestPoints;\\n\\t}\\n}\\n\\n```\\n\\n\\n## **Approach 3 : Min Heap **\\n```\\nclass Solution {\\n \\n\\tprivate int calculateDistance(int[] point) {\\n\\t\\treturn point[0] * point[0] + point[1] * point[1];\\n\\t}\\n \\n\\tpublic int[][] kClosest(int[][] points, int K) {\\n \\n\\t\\tPriorityQueue<int[]> minHeap = new PriorityQueue<>((a, b) -> calculateDistance(a) - calculateDistance(b));\\n \\n        for(int[] point : points) \\n            minHeap.offer(point);\\n        \\n\\t\\tint[][] kClosestPoints = new int[K][2];\\n        int i = 0;\\n        while(K-- != 0) \\n            kClosestPoints[i++] = minHeap.poll();\\n\\t\\t\\n\\t\\treturn kClosestPoints;\\n\\t}\\n}\\n\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n        \\n        HashMap<Integer, Double> map = new HashMap<>();\\n        for(int i = 0; i < points.length; i++) {\\n            double distance = Math.sqrt(points[i][0] * points[i][0] + points[i][1] * points[i][1]);\\n            map.put(i, distance);\\n        }\\n        \\n        List<Map.Entry<Integer, Double>> sortList = new LinkedList<>(map.entrySet());\\n        Collections.sort(sortList, (a, b) -> a.getValue().compareTo(b.getValue()));\\n        \\n        int[][] ans = new int[K][2];\\n        int i = 0;\\n        for(Map.Entry entry : sortList) {\\n            int key = (int) entry.getKey();\\n            ans[i][0] = points[key][0];\\n            ans[i][1] = points[key][1];\\n            i++;\\n            if(i == K) break;\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n \\n\\tprivate int calculateDistance(int[] point) {\\n\\t\\treturn point[0] * point[0] + point[1] * point[1];\\n\\t}\\n \\n\\tpublic int[][] kClosest(int[][] points, int K) {\\n \\n\\t\\tint[] distance = new int[points.length];\\n\\t\\tfor(int i = 0; i < points.length; i++) \\n            distance[i] = calculateDistance(points[i]);\\n \\n\\t\\tArrays.sort(distance);\\n\\t\\tint kthDistance = distance[K - 1];\\n\\t\\tint[][] kClosestPoints = new int[K][2];\\n \\n\\t\\tfor(int i = 0, j = 0; i < points.length && j < K; i++) \\n\\t\\t\\tif(calculateDistance(points[i]) <= kthDistance)\\n\\t\\t\\t\\tkClosestPoints[j++] = points[i];\\n \\n\\t\\treturn kClosestPoints;\\n\\t}\\n}\\n\\n```\n```\\nclass Solution {\\n \\n\\tprivate int calculateDistance(int[] point) {\\n\\t\\treturn point[0] * point[0] + point[1] * point[1];\\n\\t}\\n \\n\\tpublic int[][] kClosest(int[][] points, int K) {\\n \\n\\t\\tPriorityQueue<int[]> minHeap = new PriorityQueue<>((a, b) -> calculateDistance(a) - calculateDistance(b));\\n \\n        for(int[] point : points) \\n            minHeap.offer(point);\\n        \\n\\t\\tint[][] kClosestPoints = new int[K][2];\\n        int i = 0;\\n        while(K-- != 0) \\n            kClosestPoints[i++] = minHeap.poll();\\n\\t\\t\\n\\t\\treturn kClosestPoints;\\n\\t}\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 625549,
                "title": "c-quickselect-solution",
                "content": "**Intuition**\\nQuickselect is a selection algorithm to find the Kth smallest/largest element in an unsorted list. \\n\\nQuickselect uses the same overall approach as Quicksort, choosing one element as the pivot and then partition the elements in two parts: numbers smaller than the pivot are in the first group, numbers greater than or equal to the pivot are in the second group. Unlike Quicksort, Quickselect only recurses into one side that has the element it is searching for.\\n\\n**Complexity**\\n- Time: O(n) in average, O(n^2) in the worst case.\\n   - In worst case, each partitioning only excludes one elements, so the time complexity is n + (n-1) + (n-2) + ... + 2 + 1 = n*(n+1)/2, which is O(n^2).\\n  - In average case, each partitioning excludes half of all the elements, so the time complexity is n + n/2 + n/4 + ... + 1 = 2n*[1-(1/2)^n] < 2n, which is O(n).\\n\\n**Implementation**\\n* C#\\n```\\npublic class Solution {\\n    public int[][] KClosest(int[][] points, int k) {\\n        \\n        int m = points.Length, n = points[0].Length;\\n        \\n        int left = 0, right = m - 1;\\n        \\n        while(left < right)\\n        {\\n            int pivotIdx = partition(points, left, right);\\n\\n            // the first k points are sorted in non-decreasing order\\n            if(pivotIdx == k - 1)\\n                break;\\n            else if(pivotIdx < k - 1)\\n                left = pivotIdx + 1;\\n            else\\n                right = pivotIdx - 1;\\n        }\\n                \\n        int[][] res = new int[k][];\\n        // copy the first k points from points to res\\n        Array.Copy(points, res, k);\\n        return res;\\n    }\\n    \\n    private int partition(int[][] points, int left, int right)\\n    {\\n        int pivot = distance(points[right]);\\n        \\n        // ensure all points before j are <= pivot\\n        // j always points at the next-to-be-swapped point\\n        int j = left;\\n        for(int i = left ; i < right; i++)\\n        {\\n            if(distance(points[i]) <= pivot)\\n            {\\n                swap(points, i, j);\\n                j++;\\n            }\\n        }\\n        swap(points, j, right);\\n        return j;\\n    }\\n    \\n    private void swap(int[][] points, int i, int j)\\n    {\\n        var tmp = points[i];\\n        points[i] = points[j];\\n        points[j] = tmp;\\n    }\\n    \\n    private int distance(int[] point)\\n    {\\n        return point[0] * point[0] + point[1] * point[1];\\n    }\\n}\\n```\\n\\n* Java\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        int m = points.length, n = points[0].length;\\n        \\n        int left = 0, right = m - 1;\\n        \\n        while(left < right)\\n        {\\n            int pivotIdx = partition(points, left, right);\\n\\n            // the first k points are sorted in non-decreasing order\\n            if(pivotIdx == k - 1)\\n                break;\\n            else if(pivotIdx < k - 1)\\n                left = pivotIdx + 1;\\n            else\\n                right = pivotIdx - 1;\\n        }\\n                \\n        int[][] res = new int[k][];\\n        // copy the first k points from points to res\\n        // System.arraycopy(points, 0, res, 0, k);\\n        res = Arrays.copyOf(points, k);\\n        return res;\\n    }\\n    \\n    private int partition(int[][] points, int left, int right)\\n    {\\n        int pivot = distance(points[right]);\\n        \\n        // ensure all points before j are <= pivot\\n        // j always points at the next-to-be-swapped point\\n        int j = left;\\n        for(int i = left ; i < right; i++)\\n        {\\n            if(distance(points[i]) <= pivot)\\n            {\\n                swap(points, i, j);\\n                j++;\\n            }\\n        }\\n        swap(points, j, right);\\n        return j;\\n    }\\n    \\n    private void swap(int[][] points, int i, int j)\\n    {\\n        var tmp = points[i];\\n        points[i] = points[j];\\n        points[j] = tmp;\\n    }\\n    \\n    private int distance(int[] point)\\n    {\\n        return point[0] * point[0] + point[1] * point[1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[][] KClosest(int[][] points, int k) {\\n        \\n        int m = points.Length, n = points[0].Length;\\n        \\n        int left = 0, right = m - 1;\\n        \\n        while(left < right)\\n        {\\n            int pivotIdx = partition(points, left, right);\\n\\n            // the first k points are sorted in non-decreasing order\\n            if(pivotIdx == k - 1)\\n                break;\\n            else if(pivotIdx < k - 1)\\n                left = pivotIdx + 1;\\n            else\\n                right = pivotIdx - 1;\\n        }\\n                \\n        int[][] res = new int[k][];\\n        // copy the first k points from points to res\\n        Array.Copy(points, res, k);\\n        return res;\\n    }\\n    \\n    private int partition(int[][] points, int left, int right)\\n    {\\n        int pivot = distance(points[right]);\\n        \\n        // ensure all points before j are <= pivot\\n        // j always points at the next-to-be-swapped point\\n        int j = left;\\n        for(int i = left ; i < right; i++)\\n        {\\n            if(distance(points[i]) <= pivot)\\n            {\\n                swap(points, i, j);\\n                j++;\\n            }\\n        }\\n        swap(points, j, right);\\n        return j;\\n    }\\n    \\n    private void swap(int[][] points, int i, int j)\\n    {\\n        var tmp = points[i];\\n        points[i] = points[j];\\n        points[j] = tmp;\\n    }\\n    \\n    private int distance(int[] point)\\n    {\\n        return point[0] * point[0] + point[1] * point[1];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        int m = points.length, n = points[0].length;\\n        \\n        int left = 0, right = m - 1;\\n        \\n        while(left < right)\\n        {\\n            int pivotIdx = partition(points, left, right);\\n\\n            // the first k points are sorted in non-decreasing order\\n            if(pivotIdx == k - 1)\\n                break;\\n            else if(pivotIdx < k - 1)\\n                left = pivotIdx + 1;\\n            else\\n                right = pivotIdx - 1;\\n        }\\n                \\n        int[][] res = new int[k][];\\n        // copy the first k points from points to res\\n        // System.arraycopy(points, 0, res, 0, k);\\n        res = Arrays.copyOf(points, k);\\n        return res;\\n    }\\n    \\n    private int partition(int[][] points, int left, int right)\\n    {\\n        int pivot = distance(points[right]);\\n        \\n        // ensure all points before j are <= pivot\\n        // j always points at the next-to-be-swapped point\\n        int j = left;\\n        for(int i = left ; i < right; i++)\\n        {\\n            if(distance(points[i]) <= pivot)\\n            {\\n                swap(points, i, j);\\n                j++;\\n            }\\n        }\\n        swap(points, j, right);\\n        return j;\\n    }\\n    \\n    private void swap(int[][] points, int i, int j)\\n    {\\n        var tmp = points[i];\\n        points[i] = points[j];\\n        points[j] = tmp;\\n    }\\n    \\n    private int distance(int[] point)\\n    {\\n        return point[0] * point[0] + point[1] * point[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 224542,
                "title": "python-3-faster-than-100-one-line",
                "content": "```\\nclass Solution:\\n    def kClosest(self, points, K):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :type K: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        return sorted(points, key=lambda e: e[0]**2+e[1]**2)[0:K]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kClosest(self, points, K):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :type K: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        return sorted(points, key=lambda e: e[0]**2+e[1]**2)[0:K]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664669,
                "title": "priority-queue-c-beats-95",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is simple just calculate the distance from the origin and use Priority Queue to store the distance and index value.\\n\\n# Complexity\\n- Time complexity:O(N * Log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N*2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& p, int k) {\\n\\n        priority_queue<pair<int,int>> pq;\\n        for(int i = 0;i<p.size();i++)\\n        {\\n            int dist = p[i][0]*p[i][0]+p[i][1]*p[i][1];\\n            pq.push({-1*dist,i});\\n        }\\n        vector<vector<int>> ans;\\n        while(k--)\\n        {\\n            auto x = pq.top();\\n            pq.pop();\\n            ans.push_back(p[x.second]);\\n        }\\n        return ans;   \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/3a00f256-670c-47a7-bc3b-edbc68341162_1687333025.0930696.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& p, int k) {\\n\\n        priority_queue<pair<int,int>> pq;\\n        for(int i = 0;i<p.size();i++)\\n        {\\n            int dist = p[i][0]*p[i][0]+p[i][1]*p[i][1];\\n            pq.push({-1*dist,i});\\n        }\\n        vector<vector<int>> ans;\\n        while(k--)\\n        {\\n            auto x = pq.top();\\n            pq.pop();\\n            ans.push_back(p[x.second]);\\n        }\\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1648763,
                "title": "python-simple-quick-select-detailed-explanation-beginner-friendly",
                "content": "**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.** \\n* **Standard QuickSelect Algorithm**(like QuickSort)\\n* Given a sequence `seq` and a positive number `k`, we need to find out the top `k` elements from `seq`.\\n\\t* **Randomly** select a `pivot` from the current `seq`\\n\\t\\t* random selection is very important, on average, this can effectively deal with the worst case.\\n\\t* Traverse `seq` one by one, count how many elements less than or greater than or equal to the pivot respectively.\\n\\t* There are 3 different situations\\n\\t\\t* `k <= len(less)`\\n\\t\\t\\t* that means you can find all top `k` elements in `less` recursively.\\n\\t\\t* `len(less) < k <= len(less) + len(equal)`\\n\\t\\t\\t* congratulations! `pivot` is the k-th element, note to handle equal situations carefully.\\n\\t\\t* `k > len(less) + len(equal)`\\n\\t\\t\\t* Not bad. you have already found the top `len(less) + len(equal)` elements.\\n\\t\\t\\t* you can find out the left `k - len(less) + len(equal)` top elements from `greater` recursively.\\n\\n```\\nclass Solution(object):\\n    def kClosest(self, points, k):\\n        def quickSelect(points, k):\\n            less, equal, greater = [], [], []\\n            pivot = random.choice(points)\\n            pivot_l2 = pivot[0] ** 2 + pivot[1] ** 2\\n            for p in points:\\n                p_l2 = p[0] ** 2 + p[1] ** 2\\n                if p_l2 < pivot_l2:\\n                    less.append(p)\\n                elif p_l2 > pivot_l2:\\n                    greater.append(p)\\n                else:\\n                    equal.append(p)\\n            if len(less) < k <= len(less) + len(equal):\\n                return less + equal[:k - len(less)]\\n            elif k <= len(less):\\n                return quickSelect(less, k)\\n            else:\\n                return less + equal + quickSelect(greater, k - len(less) - len(equal))\\n\\t\\t\\t\\t\\n        return quickSelect(points, k)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def kClosest(self, points, k):\\n        def quickSelect(points, k):\\n            less, equal, greater = [], [], []\\n            pivot = random.choice(points)\\n            pivot_l2 = pivot[0] ** 2 + pivot[1] ** 2\\n            for p in points:\\n                p_l2 = p[0] ** 2 + p[1] ** 2\\n                if p_l2 < pivot_l2:\\n                    less.append(p)\\n                elif p_l2 > pivot_l2:\\n                    greater.append(p)\\n                else:\\n                    equal.append(p)\\n            if len(less) < k <= len(less) + len(equal):\\n                return less + equal[:k - len(less)]\\n            elif k <= len(less):\\n                return quickSelect(less, k)\\n            else:\\n                return less + equal + quickSelect(greater, k - len(less) - len(equal))\\n\\t\\t\\t\\t\\n        return quickSelect(points, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 659832,
                "title": "c-presice-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n         vector<vector<int>> kClosest(vector<vector<int>> &p, int k) {\\n         multimap<int,int> m;\\n         for(int i=0; i<p.size();i++)\\n         m.insert({p[i][0]*p[i][0]+p[i][1]*p[i][1],i});\\n         vector<vector<int>>v;\\n         for(auto it=m.begin();k>0;it++,k--) \\n         v.push_back(p[it->second]);\\n         return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n         vector<vector<int>> kClosest(vector<vector<int>> &p, int k) {\\n         multimap<int,int> m;\\n         for(int i=0; i<p.size();i++)\\n         m.insert({p[i][0]*p[i][0]+p[i][1]*p[i][1],i});\\n         vector<vector<int>>v;\\n         for(auto it=m.begin();k>0;it++,k--) \\n         v.push_back(p[it->second]);\\n         return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 218691,
                "title": "o-n-java-using-quick-select-beats-100",
                "content": "Similar to LC 215\\n```\\nclass Solution {\\n    private Random random = new Random();\\n    public int[][] kClosest(int[][] points, int K) {\\n        int start = 0, end = points.length - 1;\\n        int index = 0;\\n        while (start <= end) {\\n            index = partition(points, start, end);\\n            if (index == K) {\\n                break;\\n            }\\n            if (index > K) {\\n                end = index - 1;\\n            } else {\\n                start = index + 1;\\n            }\\n        }\\n        int[][] result = new int[index][2];\\n        for (int i = 0; i < index; i++) {\\n            result[i] = points[i];\\n        }\\n        return result;\\n    }\\n    \\n    private int partition(int[][] points, int start, int end) {\\n        int rd = start + random.nextInt(end - start + 1);\\n        int[] target = points[rd];\\n        swap(points, rd, end);\\n        int left = start, right = end - 1;\\n        while (left <= right) {\\n            while (left <= right && !isLarger(points[left], target)) left++;\\n            while (left <= right && isLarger(points[right], target)) right--;\\n            if (left <= right) {\\n                swap(points, left, right);\\n                left++;\\n                right--;\\n            }\\n        }\\n        swap(points, left, end);\\n        return left;\\n    }\\n    \\n    private void swap(int[][] points, int i1, int i2) {\\n        int[] temp = points[i1];\\n        points[i1] = points[i2];\\n        points[i2] = temp;\\n    }\\n    \\n    // return true if p1 dist is larger than p2\\n    private boolean isLarger(int[] p1, int[] p2) {\\n        return p1[0] * p1[0] + p1[1] * p1[1] > p2[0] * p2[0] + p2[1] * p2[1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private Random random = new Random();\\n    public int[][] kClosest(int[][] points, int K) {\\n        int start = 0, end = points.length - 1;\\n        int index = 0;\\n        while (start <= end) {\\n            index = partition(points, start, end);\\n            if (index == K) {\\n                break;\\n            }\\n            if (index > K) {\\n                end = index - 1;\\n            } else {\\n                start = index + 1;\\n            }\\n        }\\n        int[][] result = new int[index][2];\\n        for (int i = 0; i < index; i++) {\\n            result[i] = points[i];\\n        }\\n        return result;\\n    }\\n    \\n    private int partition(int[][] points, int start, int end) {\\n        int rd = start + random.nextInt(end - start + 1);\\n        int[] target = points[rd];\\n        swap(points, rd, end);\\n        int left = start, right = end - 1;\\n        while (left <= right) {\\n            while (left <= right && !isLarger(points[left], target)) left++;\\n            while (left <= right && isLarger(points[right], target)) right--;\\n            if (left <= right) {\\n                swap(points, left, right);\\n                left++;\\n                right--;\\n            }\\n        }\\n        swap(points, left, end);\\n        return left;\\n    }\\n    \\n    private void swap(int[][] points, int i1, int i2) {\\n        int[] temp = points[i1];\\n        points[i1] = points[i2];\\n        points[i2] = temp;\\n    }\\n    \\n    // return true if p1 dist is larger than p2\\n    private boolean isLarger(int[] p1, int[] p2) {\\n        return p1[0] * p1[0] + p1[1] * p1[1] > p2[0] * p2[0] + p2[1] * p2[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 239208,
                "title": "javascript-solution",
                "content": "```\\nvar kClosest = function(points, K) {\\n    quickSelect(points, K, 0, points.length - 1)\\n    return points.slice(0, K)\\n};\\n\\nfunction quickSelect(points, K, low, high) {\\n    if (low >= high) {\\n        return\\n    }\\n    \\n    const partPoint = partition(points, low, high)\\n    \\n    if (partPoint === K - 1) {\\n        return\\n    }\\n    if (partPoint < K - 1) {\\n        quickSelect(points, K, partPoint + 1, high)\\n    } else {\\n        quickSelect(points, K, low, partPoint - 1)\\n    }\\n}\\n\\nfunction partition(points, low, high) {\\n    const pivot = points[high]\\n    let i = low\\n    let j = low\\n    while (i < high) {\\n        if (getDist(points[i]) < getDist(pivot)) {\\n            swap(points, i, j)\\n            j++\\n        }\\n        i++\\n    }\\n    swap(points, high, j)\\n    return j\\n}\\n\\nfunction getDist(point) {\\n    return point[0] * point[0] + point[1] * point[1]\\n}\\n\\nfunction swap(arr, i, j) {\\n    const temp = arr[i] \\n    arr[i] = arr[j]\\n    arr[j] = temp\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar kClosest = function(points, K) {\\n    quickSelect(points, K, 0, points.length - 1)\\n    return points.slice(0, K)\\n};\\n\\nfunction quickSelect(points, K, low, high) {\\n    if (low >= high) {\\n        return\\n    }\\n    \\n    const partPoint = partition(points, low, high)\\n    \\n    if (partPoint === K - 1) {\\n        return\\n    }\\n    if (partPoint < K - 1) {\\n        quickSelect(points, K, partPoint + 1, high)\\n    } else {\\n        quickSelect(points, K, low, partPoint - 1)\\n    }\\n}\\n\\nfunction partition(points, low, high) {\\n    const pivot = points[high]\\n    let i = low\\n    let j = low\\n    while (i < high) {\\n        if (getDist(points[i]) < getDist(pivot)) {\\n            swap(points, i, j)\\n            j++\\n        }\\n        i++\\n    }\\n    swap(points, high, j)\\n    return j\\n}\\n\\nfunction getDist(point) {\\n    return point[0] * point[0] + point[1] * point[1]\\n}\\n\\nfunction swap(arr, i, j) {\\n    const temp = arr[i] \\n    arr[i] = arr[j]\\n    arr[j] = temp\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 660023,
                "title": "javascript",
                "content": "```\\nvar kClosest = function(points, K) {\\n    points.sort((a,b) => (a[0] ** 2 + a[1] ** 2) - (b[0] ** 2 + b[1] ** 2));\\n    return points.slice(0, K);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar kClosest = function(points, K) {\\n    points.sort((a,b) => (a[0] ** 2 + a[1] ** 2) - (b[0] ** 2 + b[1] ** 2));\\n    return points.slice(0, K);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 482892,
                "title": "c",
                "content": "```\\npublic int[][] KClosest(int[][] points, int K)\\n\\t=> points.OrderBy(p => p[0] * p[0] + p[1] * p[1]).Take(K).ToArray();\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[][] KClosest(int[][] points, int K)\\n\\t=> points.OrderBy(p => p[0] * p[0] + p[1] * p[1]).Take(K).ToArray();\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 218974,
                "title": "c-1-line",
                "content": "```\\npublic class Solution {\\n    public int[][] KClosest(int[][] points, int K) {\\n        return points.OrderBy(p => p[0] * p[0] + p[1] * p[1]).Take(K).ToArray();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[][] KClosest(int[][] points, int K) {\\n        return points.OrderBy(p => p[0] * p[0] + p[1] * p[1]).Take(K).ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556983,
                "title": "python3-maxheap-short-beats-97",
                "content": "```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        maxHeap = []\\n        for id, p in enumerate(points):\\n            d = p[0] * p[0] + p[1] * p[1]\\n            if len(maxHeap) < k:\\n                heappush(maxHeap, (-d, id))\\n            else:\\n                heappushpop(maxHeap, (-d, id))\\n\\n        return [points[id] for _, id in maxHeap]        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        maxHeap = []\\n        for id, p in enumerate(points):\\n            d = p[0] * p[0] + p[1] * p[1]\\n            if len(maxHeap) < k:\\n                heappush(maxHeap, (-d, id))\\n            else:\\n                heappushpop(maxHeap, (-d, id))\\n\\n        return [points[id] for _, id in maxHeap]        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2252785,
                "title": "javascript-min-heap-priorityqueue-east-and-clean",
                "content": "```\\nvar kClosest = function(points, k) {\\n    const res = []\\n    const minHeap = new MinPriorityQueue()\\n    points.forEach(p => {\\n        const distanceFromOrigin = Math.sqrt(p[0] * p[0] + p[1] * p[1])\\n        minHeap.enqueue(p, distanceFromOrigin)\\n    })\\n    while(res.length < k) res.push(minHeap.dequeue().element)\\n    return res\\n    // O(Nlog(K)) time O(N) space\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar kClosest = function(points, k) {\\n    const res = []\\n    const minHeap = new MinPriorityQueue()\\n    points.forEach(p => {\\n        const distanceFromOrigin = Math.sqrt(p[0] * p[0] + p[1] * p[1])\\n        minHeap.enqueue(p, distanceFromOrigin)\\n    })\\n    while(res.length < k) res.push(minHeap.dequeue().element)\\n    return res\\n    // O(Nlog(K)) time O(N) space\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1647325,
                "title": "python3-one-liner-explained",
                "content": "We sort the given list of points by their distance from the origin and then return k first results.\\n\\nTime: **O(NlogN)** - for the sorting\\nSpace: **O(N)** - Python sorting\\n\\nRuntime: 628 ms, faster than **93.32%** of Python3 online submissions for K Closest Points to Origin.\\nMemory Usage: 19.5 MB, less than **99.08%** of Python3 online submissions for K Closest Points to Origin.\\n\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(points, key = lambda p: p[0]**2 + p[1]**2)[0:k]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(points, key = lambda p: p[0]**2 + p[1]**2)[0:k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1271187,
                "title": "easy-c-solution-commented",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        //we will store the distance of each point from the origin with the index in the max heap\\n        priority_queue<pair<int,int>> pq;\\n        \\n        //if sqrt(x) > sqrt(y) then obviously x>y\\n        //so we dont need to do the sqrt operation for finding the distance\\n        for(int i=0;i<points.size();i++)\\n        {\\n            int x=points[i][0];\\n            int y=points[i][1];\\n            int dist=(x*x)+(y*y);\\n            pq.push({dist,i});\\n            //we only need k closest \\n            //so we only consider the k points to store in the pq\\n            //as pq is max heap the longest distance from the origin is popped out\\n            if(pq.size()>k)\\n                pq.pop();\\n        }\\n        vector<vector<int>> res;\\n        while(!pq.empty())\\n        {\\n            auto [val,ind]=pq.top();\\n            pq.pop();\\n            res.push_back(points[ind]);\\n        }\\n        return res;\\n        \\n    }\\n    \\n};\\n```\\n**Please upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        //we will store the distance of each point from the origin with the index in the max heap\\n        priority_queue<pair<int,int>> pq;\\n        \\n        //if sqrt(x) > sqrt(y) then obviously x>y\\n        //so we dont need to do the sqrt operation for finding the distance\\n        for(int i=0;i<points.size();i++)\\n        {\\n            int x=points[i][0];\\n            int y=points[i][1];\\n            int dist=(x*x)+(y*y);\\n            pq.push({dist,i});\\n            //we only need k closest \\n            //so we only consider the k points to store in the pq\\n            //as pq is max heap the longest distance from the origin is popped out\\n            if(pq.size()>k)\\n                pq.pop();\\n        }\\n        vector<vector<int>> res;\\n        while(!pq.empty())\\n        {\\n            auto [val,ind]=pq.top();\\n            pq.pop();\\n            res.push_back(points[ind]);\\n        }\\n        return res;\\n        \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1174480,
                "title": "java-explaining-maxheap-and-quickselect-approaches-with-detailed-comments-and-intuition",
                "content": "First, we need to understand the rationale of using efficient algorithm to solve the problem. An algorithm better than quadratic time is not good enough because in real world, N can be a very large number compared to k. In that case, if we use pure sorting, NlogN time complexity will actually be pretty bad. \\nNow we also need to understand that the problem did not ask us to return all the points in sorted fashion, they just wanted \"k\" closest in *any* order. This is really our biggest clue.\\n\\nAs a first option, we can think of using a **heap** which tracks the min or max element of the set with constant retrieval complexity. The trick here is we need to limit the size of the heap to \\'k\\' again for the above reason, since insertion time is logarithmic to the number of elements in the heap. Rest of the logic is explained in the code.\\n\\nThe runtime of this algorithm is approximately bounded by Nlog(k) since we are doing N heap insertions with the heap size growing to max of k + 1 ~ k.\\nI would say this is our preferred solution if we do not need to know the full data set in advance, like a streaming data set. Also, the output of the solution will be sorted because every time we are retrieving the maximum element from the heap and are adding it to the back of our array. So the sorting is **stable**.\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        if (points.length < k) {\\n            // We can never have a solution since not enough points\\n            return new int[0][0];\\n        }\\n        \\n        // Important: we maintain a maxHeap instead of a minHeap. With max heap, we can\\n        // use an important invariant: the top element of max heap is ALWAYS the largest element\\n        // So as we insert points, and the maxHeap grows larger than k, we can pop off\\n        // the largest element found so far - this signifies the furthest point in our set\\n        // That way we are left with points that are least furthest, or in other words the points\\n        // that are nearest\\n        PriorityQueue<int[]> maxHeap = new PriorityQueue<>(\\n        (p1, p2) -> Double.compare(Math.sqrt(p2[0]*p2[0] + p2[1]*p2[1]), Math.sqrt(p1[0]*p1[0] + p1[1]*p1[1])));\\n        for (int[] point : points) {\\n            maxHeap.offer(point);\\n            if (maxHeap.size() > k) {\\n                maxHeap.poll();\\n            }\\n        }\\n        // Returning the elements from the max heap\\n        int[][] closestPoints = new int[k][];\\n        while (k > 0) {\\n            closestPoints[k - 1] = maxHeap.poll();\\n            k--;\\n        }\\n        return closestPoints;\\n    }\\n}\\n```\\n\\nThe above solution is good, but we can make it better if we consider the returned points need not be in any order and if the whole data set is already available to us for our analysis beforehand. There is a nifty algorithm called QuickSelect which is a variation of QuickSort. I have found wikipedia has a fairly good explanation of the algorithm.\\n\\nThis algorithm runs with O(n) time complexity in average, but like QuickSort has worst case time complexity of O(n^2). This is an **unstable** sort algorithm, but it works well in our case. In LeetCode this approach easily beats 80-84% of other solutions depending on when you are running the solution!\\n\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        if (points.length < k) {\\n            return new int[0][0];\\n        }\\n        Comparator<int[]> comp = (p1, p2) ->\\n            Double.compare(Math.sqrt(p1[0]*p1[0] + p1[1]*p1[1]), Math.sqrt(p2[0]*p2[0] + p2[1]*p2[1]));\\n        int left = 0;\\n        int right = points.length - 1;\\n        \\n        while (left < right) {\\n            int pivot = findPartition(points, left, right, comp);\\n            if (pivot < k) {\\n                // Our answer lies to the right of the pivot\\n                left = pivot + 1;\\n            }\\n            else if (pivot > k) {\\n                // our answer lies to the left of the pivot\\n                right = pivot - 1;\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n        \\n        return Arrays.copyOfRange(points, 0, k);\\n    }\\n    \\n    // Core QuickSelect algorithm\\n    // I found Wikipedia article explains it pretty well, and most\\n    // helpful for me was the GIF explaining the process\\n    // https://en.wikipedia.org/wiki/Quickselect#/media/File:Selecting_quickselect_frames.gif\\n    // Basically, we compare ALL elements in our range with the extreme right element of the range\\n    // This explains why \\'index\\' DOES NOT include \\'right\\'\\n    // After the loop runs, we ensure that every element within our range and to the left\\n    // of the \\'left\\' index are less than the element at the \\'right\\' index\\n    // After the loop, we bring the element of the \\'right\\' index at \\'left\\' index.\\n    // All placements are in-place swapping\\n    // We can use lambda to define a one-line comparator and we can pass this comparator\\n    // every time we call this function. This saves us from defining another function\\n    // Also, better not define an anonymous custom comparator every time this function is called\\n    // as this is not the best use of CPU and memory\\n    public int findPartition(int[][] points, int left, int right, Comparator<int[]> comp) {\\n        for (int index = left; index < right; index++) {\\n            if (comp.compare(points[index], points[right]) < 0) {\\n                // We make sure \\'left\\' is the boundary of all elements which are lesser than\\n                // the element at \\'right\\'\\n                swap(points, left, index);\\n                left++;\\n            }\\n        }\\n        swap(points, left, right);\\n        return left;\\n    }\\n    \\n    // Simple swap function. I still prefer this over the XOR way of swapping\\n    // since this is more explicit and less error prone especially in interview\\n    // context\\n    public void swap(int[][] points, int left, int right) {\\n        int tempx = points[left][0];\\n        int tempy = points[left][1];\\n        \\n        points[left][0] = points[right][0];\\n        points[left][1] = points[right][1];\\n        points[right][0] = tempx;\\n        points[right][1] = tempy;\\n    }\\n}\\n```\\n\\nAnother note: please refrain from using a \"-\" while comparing values in comparator, and rely on standard functions to do so. This is to prevent (unlikely) overflows, and also better readability of the code.\\n\\nLike I explained in some of my other articles, it is important to \"arrive\" at a solution during the interview instead of just memorizing solutions. The thought process is as important to the interviewer as the working code. When I am interviewing, I put more weight on thought process over the working code (or syntactical errors). Hope this article helps!",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)",
                    "Quickselect"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        if (points.length < k) {\\n            // We can never have a solution since not enough points\\n            return new int[0][0];\\n        }\\n        \\n        // Important: we maintain a maxHeap instead of a minHeap. With max heap, we can\\n        // use an important invariant: the top element of max heap is ALWAYS the largest element\\n        // So as we insert points, and the maxHeap grows larger than k, we can pop off\\n        // the largest element found so far - this signifies the furthest point in our set\\n        // That way we are left with points that are least furthest, or in other words the points\\n        // that are nearest\\n        PriorityQueue<int[]> maxHeap = new PriorityQueue<>(\\n        (p1, p2) -> Double.compare(Math.sqrt(p2[0]*p2[0] + p2[1]*p2[1]), Math.sqrt(p1[0]*p1[0] + p1[1]*p1[1])));\\n        for (int[] point : points) {\\n            maxHeap.offer(point);\\n            if (maxHeap.size() > k) {\\n                maxHeap.poll();\\n            }\\n        }\\n        // Returning the elements from the max heap\\n        int[][] closestPoints = new int[k][];\\n        while (k > 0) {\\n            closestPoints[k - 1] = maxHeap.poll();\\n            k--;\\n        }\\n        return closestPoints;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        if (points.length < k) {\\n            return new int[0][0];\\n        }\\n        Comparator<int[]> comp = (p1, p2) ->\\n            Double.compare(Math.sqrt(p1[0]*p1[0] + p1[1]*p1[1]), Math.sqrt(p2[0]*p2[0] + p2[1]*p2[1]));\\n        int left = 0;\\n        int right = points.length - 1;\\n        \\n        while (left < right) {\\n            int pivot = findPartition(points, left, right, comp);\\n            if (pivot < k) {\\n                // Our answer lies to the right of the pivot\\n                left = pivot + 1;\\n            }\\n            else if (pivot > k) {\\n                // our answer lies to the left of the pivot\\n                right = pivot - 1;\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n        \\n        return Arrays.copyOfRange(points, 0, k);\\n    }\\n    \\n    // Core QuickSelect algorithm\\n    // I found Wikipedia article explains it pretty well, and most\\n    // helpful for me was the GIF explaining the process\\n    // https://en.wikipedia.org/wiki/Quickselect#/media/File:Selecting_quickselect_frames.gif\\n    // Basically, we compare ALL elements in our range with the extreme right element of the range\\n    // This explains why \\'index\\' DOES NOT include \\'right\\'\\n    // After the loop runs, we ensure that every element within our range and to the left\\n    // of the \\'left\\' index are less than the element at the \\'right\\' index\\n    // After the loop, we bring the element of the \\'right\\' index at \\'left\\' index.\\n    // All placements are in-place swapping\\n    // We can use lambda to define a one-line comparator and we can pass this comparator\\n    // every time we call this function. This saves us from defining another function\\n    // Also, better not define an anonymous custom comparator every time this function is called\\n    // as this is not the best use of CPU and memory\\n    public int findPartition(int[][] points, int left, int right, Comparator<int[]> comp) {\\n        for (int index = left; index < right; index++) {\\n            if (comp.compare(points[index], points[right]) < 0) {\\n                // We make sure \\'left\\' is the boundary of all elements which are lesser than\\n                // the element at \\'right\\'\\n                swap(points, left, index);\\n                left++;\\n            }\\n        }\\n        swap(points, left, right);\\n        return left;\\n    }\\n    \\n    // Simple swap function. I still prefer this over the XOR way of swapping\\n    // since this is more explicit and less error prone especially in interview\\n    // context\\n    public void swap(int[][] points, int left, int right) {\\n        int tempx = points[left][0];\\n        int tempy = points[left][1];\\n        \\n        points[left][0] = points[right][0];\\n        points[left][1] = points[right][1];\\n        points[right][0] = tempx;\\n        points[right][1] = tempy;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 988655,
                "title": "java-quick-select-o-n-avg-2ms",
                "content": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n        \\n        //one method is to use PQ of size k, O(NlogK)\\n        //other is quick select avg case O(n), worse O(n^2)\\n        \\n        quick(points, 0, points.length - 1,K);   \\n        return Arrays.copyOfRange(points, 0 ,K);\\n    }\\n    \\n\\t//similar to quick sort algo. but we recurse for either left or right side\\n    private void quick(int[][] arr, int l, int h, int k ){\\n        if(l>=h) return;\\n        int p = partition(arr, l, h);\\n        \\n        if(p== (k-1))\\n            return;\\n        else if(p < k-1)\\n            quick(arr, p+1,h,k);\\n        else\\n            quick(arr, l, p-1,k);\\n            \\n    }\\n    \\n    private int partition(int[][] arr, int l, int h){\\n       int pivot = distance(arr[h]);\\n        int i = l-1;\\n        for(int j = l; j<h; j++){\\n            if(distance(arr[j]) < pivot){\\n                swap(arr, ++i, j);\\n            }\\n        }\\n        swap(arr, ++i, h);\\n        return i;\\n    }\\n    \\n    private void swap(int[][] arr, int i, int j){\\n        int[] temp =arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n    \\n    private int distance(int[] x) {\\n        return x[0]*x[0] + x[1]*x[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer",
                    "Quickselect"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n        \\n        //one method is to use PQ of size k, O(NlogK)\\n        //other is quick select avg case O(n), worse O(n^2)\\n        \\n        quick(points, 0, points.length - 1,K);   \\n        return Arrays.copyOfRange(points, 0 ,K);\\n    }\\n    \\n\\t//similar to quick sort algo. but we recurse for either left or right side\\n    private void quick(int[][] arr, int l, int h, int k ){\\n        if(l>=h) return;\\n        int p = partition(arr, l, h);\\n        \\n        if(p== (k-1))\\n            return;\\n        else if(p < k-1)\\n            quick(arr, p+1,h,k);\\n        else\\n            quick(arr, l, p-1,k);\\n            \\n    }\\n    \\n    private int partition(int[][] arr, int l, int h){\\n       int pivot = distance(arr[h]);\\n        int i = l-1;\\n        for(int j = l; j<h; j++){\\n            if(distance(arr[j]) < pivot){\\n                swap(arr, ++i, j);\\n            }\\n        }\\n        swap(arr, ++i, h);\\n        return i;\\n    }\\n    \\n    private void swap(int[][] arr, int i, int j){\\n        int[] temp =arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n    \\n    private int distance(int[] x) {\\n        return x[0]*x[0] + x[1]*x[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 234204,
                "title": "swift-no-brainer",
                "content": "```\\nfinal class Solution {\\n    func kClosest(_ points: [[Int]], _ K: Int) -> [[Int]] {\\n        let sortedPoints = points.sorted {\\n            ($0[0] * $0[0] + $0[1] * $0[1]) < ($1[0] * $1[0] + $1[1] * $1[1])\\n        }\\n        return Array(sortedPoints.prefix(K))\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfinal class Solution {\\n    func kClosest(_ points: [[Int]], _ K: Int) -> [[Int]] {\\n        let sortedPoints = points.sorted {\\n            ($0[0] * $0[0] + $0[1] * $0[1]) < ($1[0] * $1[0] + $1[1] * $1[1])\\n        }\\n        return Array(sortedPoints.prefix(K))\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647721,
                "title": "c-sorting-using-comparator-function-easiest-to-understand",
                "content": "```\\nbool comp(vector<int>&a,vector<int>&b){\\n    int d1=a[0]*a[0]+a[1]*a[1]; \\n    int d2=b[0]*b[0]+b[1]*b[1]; \\n    \\n    return d1<d2; \\n}\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n   \\n        vector<vector<int>>ans; \\n\\t\\t\\n        sort(points.begin(),points.end(),comp); \\n        \\n        for(int i=0;i<k;i++){\\n            ans.push_back(points[i]); \\n        }\\n        \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nbool comp(vector<int>&a,vector<int>&b){\\n    int d1=a[0]*a[0]+a[1]*a[1]; \\n    int d2=b[0]*b[0]+b[1]*b[1]; \\n    \\n    return d1<d2; \\n}\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n   \\n        vector<vector<int>>ans; \\n\\t\\t\\n        sort(points.begin(),points.end(),comp); \\n        \\n        for(int i=0;i<k;i++){\\n            ans.push_back(points[i]); \\n        }\\n        \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461651,
                "title": "python-solutions-in-o-n-o-nlogk-o-klogn-and-o-nlogn",
                "content": "__Solution 1__: Sort array based on distances.\\n```\\ndef kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n\\t # O(nlogn)\\n\\t res = [([x,y], x**2+y**2) for x,y in points]\\n\\t res, _ = zip(*sorted(res, key=lambda x:x[1]))\\n\\t return res[:k]\\t\\t\\n```\\n__Solution 2__: Use a heap of size N and pop the K smallest elements. Time complexity is `O(KlogN)`. This is possible because heapify runs in `O(N)`. \\n```       \\ndef kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n\\t # O(klogn)\\n\\t res = [0]*k\\n\\t q = [(x**2+y**2, [x,y]) for x,y in points]\\n\\t heapq.heapify(q)\\n\\t for i in range(k):\\n\\t\\t _, point = heapq.heappop(q)\\n\\t\\t res[i] = point\\n\\t return res\\n```\\n__Solution 3__: Use a heap of size K and iterate over N. The time complexity is `O(NlogK)`.\\n```   \\ndef kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n\\t # O(nlogk)\\n\\t q = [(-x**2-y**2, [x,y]) for x,y in points]\\n\\t h = q[:k]\\n\\t heapq.heapify(h)\\n\\t for w,point in q[k:]:\\n\\t\\t if w > h[0][0]:\\n\\t\\t\\t heapq.heapreplace(h, (w, point))\\n\\t _, p = zip(*h)\\n\\t return p\\n```\\n__Solution 4__: Standard quickselect algorithm to find nlargest or nsmallest element in an array. Time complexity is `O(N)`. We are on average halving the search space every iteration. \\n```\\t\\ndef kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n\\t # O(n)\\n\\t def quickselect(arr, l, r, k):\\n\\t\\t p = partition(arr, l, r)\\n\\t\\t if p < k: \\n\\t\\t\\t return quickselect(arr, p+1, r, k)\\n\\t\\t elif p > k: \\n\\t\\t\\t return quickselect(arr, l, p-1, k)\\n\\t\\t else:\\n\\t\\t\\t _, ans = zip(*arr[:k+1])\\n\\t\\t\\t return ans\\n\\t \\n\\t def partition(arr, l, r):\\n\\t\\t rand = random.randint(l, r)\\n\\t\\t arr[rand], arr[r] = arr[r], arr[rand]\\n\\t\\t pivot = arr[r]\\n\\t\\t i = l\\n\\t\\t for j in range(l, r):\\n\\t\\t\\t if arr[j][0] <= pivot[0]:\\n\\t\\t\\t\\t arr[j], arr[i] = arr[i], arr[j]\\n\\t\\t\\t\\t i += 1\\n\\t\\t arr[r], arr[i] = arr[i], arr[r]\\n\\t\\t return i\\n\\t q = [(x**2+y**2, [x,y]) for x,y in points]\\n\\t return quickselect(q, 0, len(points)-1, k-1)\\n```\\n",
                "solutionTags": [
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n\\t # O(nlogn)\\n\\t res = [([x,y], x**2+y**2) for x,y in points]\\n\\t res, _ = zip(*sorted(res, key=lambda x:x[1]))\\n\\t return res[:k]\\t\\t\\n```\n```       \\ndef kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n\\t # O(klogn)\\n\\t res = [0]*k\\n\\t q = [(x**2+y**2, [x,y]) for x,y in points]\\n\\t heapq.heapify(q)\\n\\t for i in range(k):\\n\\t\\t _, point = heapq.heappop(q)\\n\\t\\t res[i] = point\\n\\t return res\\n```\n```   \\ndef kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n\\t # O(nlogk)\\n\\t q = [(-x**2-y**2, [x,y]) for x,y in points]\\n\\t h = q[:k]\\n\\t heapq.heapify(h)\\n\\t for w,point in q[k:]:\\n\\t\\t if w > h[0][0]:\\n\\t\\t\\t heapq.heapreplace(h, (w, point))\\n\\t _, p = zip(*h)\\n\\t return p\\n```\n```\\t\\ndef kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n\\t # O(n)\\n\\t def quickselect(arr, l, r, k):\\n\\t\\t p = partition(arr, l, r)\\n\\t\\t if p < k: \\n\\t\\t\\t return quickselect(arr, p+1, r, k)\\n\\t\\t elif p > k: \\n\\t\\t\\t return quickselect(arr, l, p-1, k)\\n\\t\\t else:\\n\\t\\t\\t _, ans = zip(*arr[:k+1])\\n\\t\\t\\t return ans\\n\\t \\n\\t def partition(arr, l, r):\\n\\t\\t rand = random.randint(l, r)\\n\\t\\t arr[rand], arr[r] = arr[r], arr[rand]\\n\\t\\t pivot = arr[r]\\n\\t\\t i = l\\n\\t\\t for j in range(l, r):\\n\\t\\t\\t if arr[j][0] <= pivot[0]:\\n\\t\\t\\t\\t arr[j], arr[i] = arr[i], arr[j]\\n\\t\\t\\t\\t i += 1\\n\\t\\t arr[r], arr[i] = arr[i], arr[r]\\n\\t\\t return i\\n\\t q = [(x**2+y**2, [x,y]) for x,y in points]\\n\\t return quickselect(q, 0, len(points)-1, k-1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1255142,
                "title": "c-easy-production-ready-code-solution-using-priority-queue-and-operator-overloading",
                "content": "Since we can do operator overloading on user defined objects so create a class `Point` and do` <` opeartor overloading to sort elements in priority queue using distance formula. Please read comments for more explanation. \\n```\\n/*\\n* Point class, used to overload \\n* operator< for used defined object of \\n* class Point.\\n*/\\nclass Point {\\n  public:\\n    int x;\\n    int y;\\n    Point(int x, int y) {\\n        this->x = x;\\n        this->y = y;\\n    }\\n};\\n\\n/*\\n* Opeartor< overloading -> when this(<) operator is \\n* used to compare two objects in priority queue\\n* it will compare based on distance formula \\n* if (x1*x1 y1*y1) > (x2*x2 + y2*y2) means first point\\n* is more near to origion than second point\\n*/\\nbool operator<(const Point &v1, const Point &v2){\\n    return (v1.x * v1.x + v1.y * v1.y) > (v2.x * v2.x + v2.y * v2.y);\\n}\\n    \\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        /*\\n        * Put all points in priority queue\\n        */\\n        priority_queue<Point> pq;\\n        for(int i=0;i<points.size();i++){\\n            pq.push(Point(points[i][0], points[i][1]));\\n        }\\n        \\n        /*\\n        * Add top k elements from priority queue to \\n        * ans vector\\n        */\\n        vector<vector<int>>  ans;\\n        int i = 0;\\n        while(i++ < k) {\\n            // Add point to ans vector by constructing a vector\\n            vector<int> temp = {pq.top().x, pq.top().y};\\n            ans.push_back(temp);\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n**Another similar implementation could be as below:**\\n```\\n/*\\n* Define class template to pass in priority queue \\n* constructor, it overrides () operator\\n*/\\nclass Compare {\\npublic:\\n    bool operator()(const vector<int> &v1, const vector<int> &v2) {\\n        return (v1[0] * v1[0] + v1[1] * v1[1]) > (v2[0] * v2[0] + v2[1] * v2[1]);\\n    }\\n};\\n    \\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        /*\\n        * Pass Compare class template\\n        * Note it shouldn\\'t be a function as we use in sort() \\n        * method cause priority queue accepts this last param\\n        * only as class template\\n        */\\n        priority_queue<vector<int>, vector<vector<int>>, Compare> pq;\\n        for(int i=0;i<points.size();i++){\\n            pq.push(points[i]);\\n        }\\n        \\n        // Add top k elements from queue to ans vector\\n        vector<vector<int>>  ans;\\n        int i = 0;\\n        while(i++ < k) {\\n            ans.push_back(pq.top());\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Thanks for reading. Hope it helps. Please hit upvote button if you really find it helpful. Cheers!!**\\n*~Sadul Khod*",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/*\\n* Point class, used to overload \\n* operator< for used defined object of \\n* class Point.\\n*/\\nclass Point {\\n  public:\\n    int x;\\n    int y;\\n    Point(int x, int y) {\\n        this->x = x;\\n        this->y = y;\\n    }\\n};\\n\\n/*\\n* Opeartor< overloading -> when this(<) operator is \\n* used to compare two objects in priority queue\\n* it will compare based on distance formula \\n* if (x1*x1 y1*y1) > (x2*x2 + y2*y2) means first point\\n* is more near to origion than second point\\n*/\\nbool operator<(const Point &v1, const Point &v2){\\n    return (v1.x * v1.x + v1.y * v1.y) > (v2.x * v2.x + v2.y * v2.y);\\n}\\n    \\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        /*\\n        * Put all points in priority queue\\n        */\\n        priority_queue<Point> pq;\\n        for(int i=0;i<points.size();i++){\\n            pq.push(Point(points[i][0], points[i][1]));\\n        }\\n        \\n        /*\\n        * Add top k elements from priority queue to \\n        * ans vector\\n        */\\n        vector<vector<int>>  ans;\\n        int i = 0;\\n        while(i++ < k) {\\n            // Add point to ans vector by constructing a vector\\n            vector<int> temp = {pq.top().x, pq.top().y};\\n            ans.push_back(temp);\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n/*\\n* Define class template to pass in priority queue \\n* constructor, it overrides () operator\\n*/\\nclass Compare {\\npublic:\\n    bool operator()(const vector<int> &v1, const vector<int> &v2) {\\n        return (v1[0] * v1[0] + v1[1] * v1[1]) > (v2[0] * v2[0] + v2[1] * v2[1]);\\n    }\\n};\\n    \\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        /*\\n        * Pass Compare class template\\n        * Note it shouldn\\'t be a function as we use in sort() \\n        * method cause priority queue accepts this last param\\n        * only as class template\\n        */\\n        priority_queue<vector<int>, vector<vector<int>>, Compare> pq;\\n        for(int i=0;i<points.size();i++){\\n            pq.push(points[i]);\\n        }\\n        \\n        // Add top k elements from queue to ans vector\\n        vector<vector<int>>  ans;\\n        int i = 0;\\n        while(i++ < k) {\\n            ans.push_back(pq.top());\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 258395,
                "title": "quickselect-thinking-process",
                "content": "> [Quickselect Selection Algorithm Definition](https://en.wikipedia.org/wiki/Quickselect)\\n\\n> Distance from a point(x, y) to (0, 0) is sqrt(x * x + y * y)\\n\\n> To get K closest points to origin is to find K smallest distance = x * x + y * y.\\n\\n> If we save each point\\'s distance in distances and mapped to its index in points(because we are asked to get the point coordinate finally), the problem becomes find K smallest elements in an array, which can be solved by **Quickselect** algorithm.\\n\\n> In both Quicksort and Quickselect, we specify a pivot element and put it into the right position. The pivot divides the array in half, where elements to the left of pivot is smaller than pivot, elements to the right of pivot is larger than pivot. \\n>\\n> The difference is that we follow the above approach to sort these two halves in Quicksort, but in Quickselect, we choose one half only.\\n****\\n```\\n    public int[][] kClosest(int[][] points, int K) {\\n        int pointsLen = points.length;\\n        // distances[i][0] is distance, distances[i][1] is index in points\\n        int[][] distances = new int[pointsLen][2];\\n        \\n        // Get all distances\\n        for (int i = 0; i < pointsLen; i++) {\\n            int distance = getDistance(points[i]);\\n            distances[i][0] = distance;\\n            distances[i][1] = i;\\n        }\\n        \\n        quickSelect(K, distances, 0, pointsLen - 1);\\n        \\n        // Get first K\\n        int[][] result = new int[K][2];\\n        for (int i = 0; i < K; i++) {\\n            result[i] = points[distances[i][1]];\\n        }\\n        \\n        return result;\\n    }\\n    \\n    // Find smallest K distances\\n    private void quickSelect(int K, int[][] distances, int start, int end) {\\n        if (start >= end) return;\\n        \\n        // Choose the element at start as pivot.\\n        int pivot = distances[start][0];\\n        // Put pivot into right position wall\\n        int wall = end + 1;\\n        for (int i = end; i > start; i--) {\\n            if (distances[i][0] >= pivot) {\\n                wall--;\\n                swap(i, wall, distances);\\n            }\\n        }\\n        wall--;\\n        swap(start, wall, distances);\\n        \\n        if (wall + 1 == K) return;\\n        else if (wall + 1 < K) quickSelect(K, distances, wall + 1, end);\\n        else quickSelect(K, distances, start, wall - 1);\\n    }\\n    \\n    private int getDistance(int[] point) {\\n        return point[0] * point[0] + point[1] * point[1];\\n    }\\n    \\n    private void swap(int i, int j, int[][] distances) {\\n        int[] temp = distances[i];\\n        distances[i] = distances[j];\\n        distances[j] = temp;\\n    }\\n```",
                "solutionTags": [
                    "Quickselect"
                ],
                "code": "```\\n    public int[][] kClosest(int[][] points, int K) {\\n        int pointsLen = points.length;\\n        // distances[i][0] is distance, distances[i][1] is index in points\\n        int[][] distances = new int[pointsLen][2];\\n        \\n        // Get all distances\\n        for (int i = 0; i < pointsLen; i++) {\\n            int distance = getDistance(points[i]);\\n            distances[i][0] = distance;\\n            distances[i][1] = i;\\n        }\\n        \\n        quickSelect(K, distances, 0, pointsLen - 1);\\n        \\n        // Get first K\\n        int[][] result = new int[K][2];\\n        for (int i = 0; i < K; i++) {\\n            result[i] = points[distances[i][1]];\\n        }\\n        \\n        return result;\\n    }\\n    \\n    // Find smallest K distances\\n    private void quickSelect(int K, int[][] distances, int start, int end) {\\n        if (start >= end) return;\\n        \\n        // Choose the element at start as pivot.\\n        int pivot = distances[start][0];\\n        // Put pivot into right position wall\\n        int wall = end + 1;\\n        for (int i = end; i > start; i--) {\\n            if (distances[i][0] >= pivot) {\\n                wall--;\\n                swap(i, wall, distances);\\n            }\\n        }\\n        wall--;\\n        swap(start, wall, distances);\\n        \\n        if (wall + 1 == K) return;\\n        else if (wall + 1 < K) quickSelect(K, distances, wall + 1, end);\\n        else quickSelect(K, distances, start, wall - 1);\\n    }\\n    \\n    private int getDistance(int[] point) {\\n        return point[0] * point[0] + point[1] * point[1];\\n    }\\n    \\n    private void swap(int i, int j, int[][] distances) {\\n        int[] temp = distances[i];\\n        distances[i] = distances[j];\\n        distances[j] = temp;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 217971,
                "title": "java-comparator-sort",
                "content": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n        Arrays.sort(points, new PointCompare());\\n        int[][] res = new int[K][2];\\n        for(int i = 0; i < K; i++) res[i] = points[i];\\n        return res;\\n    }\\n}\\nclass PointCompare implements Comparator<int[]>{\\n   public int compare(int[] a, int[]b){\\n        int distA = a[0]*a[0] + a[1]*a[1];\\n        int distB = b[0]*b[0] + b[1]*b[1];\\n        \\n        return distA < distB ? -1 : 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n        Arrays.sort(points, new PointCompare());\\n        int[][] res = new int[K][2];\\n        for(int i = 0; i < K; i++) res[i] = points[i];\\n        return res;\\n    }\\n}\\nclass PointCompare implements Comparator<int[]>{\\n   public int compare(int[] a, int[]b){\\n        int distA = a[0]*a[0] + a[1]*a[1];\\n        int distB = b[0]*b[0] + b[1]*b[1];\\n        \\n        return distA < distB ? -1 : 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1648338,
                "title": "java-2-line-solution-super-easy-to-understand",
                "content": "```java\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        Arrays.sort(points,  Comparator.comparingInt(o -> o[0] * o[0] + o[1] * o[1]));\\n        return Arrays.copyOfRange(points, 0, k);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        Arrays.sort(points,  Comparator.comparingInt(o -> o[0] * o[0] + o[1] * o[1]));\\n        return Arrays.copyOfRange(points, 0, k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647620,
                "title": "three-different-solutions",
                "content": "Approach 1: Sorting\\nWe need to find **k**-points that are closest to origin.\\nWe sort them in increasing order on the basis of their distances to origin and then return the first **k** points;\\n\\nHere\\'s the code:\\n```\\nbool comp(vector<int> a, vector<int> b){\\n    /* since sqrt(a) < sqrt(b) implies a < b, therefore here we compare square of distance\\n\\t\\tto avoid floating point comparisons\\n\\t*/\\n    return (a[0]*a[0] + a[1]*a[1]) < (b[0]*b[0] + b[1]*b[1]);\\n}\\n\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n\\tsort(points.begin(), points.end(), comp);\\n\\treturn vector<vector<int>>(points.begin(), points.begin()+k);\\n}\\n\\n```\\nTime complexity: O(nlogn)\\nSpace complexity: O(1)\\n\\nApproach 2: Using heaps(priority queues)\\nSince we need to find **k** smallest distances, we can maintain a max heap of **k** elements and insert new element if we found it to be smaller than the largest element of heap. This way, we would get the points with **k** smallest distances with respect to origin.\\n\\nHere\\'s the code.\\n```\\nclass compare{\\n    public:\\n    bool operator()(vector<int> a, vector<int> b){\\n        return (a[0]*a[0] + a[1]*a[1]) < (b[0]*b[0] + b[1]*b[1]);\\n    }\\n};\\n\\nint distance(vector<int> a){\\n    //returns square of distance to avoid floating point comparisons\\n    return a[0]*a[0] + a[1]*a[1];\\n}\\n\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n\\tpriority_queue<vector<int>, vector<vector<int>>, compare> q;\\n\\tfor(int i=0;i<k;++i){\\n\\t\\tq.push(points[i]);\\n\\t}\\n\\tint n = points.size();\\n\\tfor(int i=k;i<n;++i){\\n\\t\\tvector<int> top  = q.top();\\n\\t\\tif(distance(top) > distance(points[i])){\\n\\t\\t\\tq.pop();\\n\\t\\t\\tq.push(points[i]);\\n\\t\\t}\\n\\t}\\n\\tvector<vector<int>>  ans;\\n\\twhile(q.size()){\\n\\t\\tans.push_back(q.top());\\n\\t\\tq.pop();\\n\\t}\\n\\treturn ans;\\n}\\n```\\nTime complexity: O(nlogk)\\nSpace complexity: O(k)\\n\\nApproach 3: Binary search\\nWe can find smallest distance **d** such that that are **exactly k-points** that are strictly less than **d**.\\nWe can find d using binary search.\\n**Again here, we will deal with square of distances.**\\nwe set the lower bound to 0 as 0 is the least possible distance and upper bound to 2 * 100000000 (2*10^8).\\nWe update value of **l** and **r** on the basis of count of points with distances that are strictly less than mid.\\n\\nHere\\'s the code:\\n\\n```\\n int getcount(vector<vector<int>> &points, int dist){\\n        //returns count of points with distance strictly less than dist\\n        int _count = 0;\\n        for(auto point: points){\\n            if(point[0]*point[0] + point[1]*point[1] < dist)\\n                ++_count;\\n        }\\n        return _count;\\n    }\\n\\n vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        int l = 0, r = 200000000;\\n        vector<vector<int>>  ans;\\n        while(l < r){\\n            int mid = l + (r-l+1)/2;\\n            if(getcount(points,mid) > k) r = mid - 1;\\n            else l = mid;\\n        }\\n        for(auto point: points){\\n            if(point[0]*point[0] + point[1]*point[1] < l)\\n                ans.push_back(point);\\n        }\\n        return ans;\\n    }\\n```\\nTime complexity: O(nlog(max(xi)^2 + max(yi)^2) ) \\nSpace complexity: O(1)",
                "solutionTags": [
                    "Sorting",
                    "Heap (Priority Queue)",
                    "Binary Tree"
                ],
                "code": "```\\nbool comp(vector<int> a, vector<int> b){\\n    /* since sqrt(a) < sqrt(b) implies a < b, therefore here we compare square of distance\\n\\t\\tto avoid floating point comparisons\\n\\t*/\\n    return (a[0]*a[0] + a[1]*a[1]) < (b[0]*b[0] + b[1]*b[1]);\\n}\\n\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n\\tsort(points.begin(), points.end(), comp);\\n\\treturn vector<vector<int>>(points.begin(), points.begin()+k);\\n}\\n\\n```\n```\\nclass compare{\\n    public:\\n    bool operator()(vector<int> a, vector<int> b){\\n        return (a[0]*a[0] + a[1]*a[1]) < (b[0]*b[0] + b[1]*b[1]);\\n    }\\n};\\n\\nint distance(vector<int> a){\\n    //returns square of distance to avoid floating point comparisons\\n    return a[0]*a[0] + a[1]*a[1];\\n}\\n\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n\\tpriority_queue<vector<int>, vector<vector<int>>, compare> q;\\n\\tfor(int i=0;i<k;++i){\\n\\t\\tq.push(points[i]);\\n\\t}\\n\\tint n = points.size();\\n\\tfor(int i=k;i<n;++i){\\n\\t\\tvector<int> top  = q.top();\\n\\t\\tif(distance(top) > distance(points[i])){\\n\\t\\t\\tq.pop();\\n\\t\\t\\tq.push(points[i]);\\n\\t\\t}\\n\\t}\\n\\tvector<vector<int>>  ans;\\n\\twhile(q.size()){\\n\\t\\tans.push_back(q.top());\\n\\t\\tq.pop();\\n\\t}\\n\\treturn ans;\\n}\\n```\n```\\n int getcount(vector<vector<int>> &points, int dist){\\n        //returns count of points with distance strictly less than dist\\n        int _count = 0;\\n        for(auto point: points){\\n            if(point[0]*point[0] + point[1]*point[1] < dist)\\n                ++_count;\\n        }\\n        return _count;\\n    }\\n\\n vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        int l = 0, r = 200000000;\\n        vector<vector<int>>  ans;\\n        while(l < r){\\n            int mid = l + (r-l+1)/2;\\n            if(getcount(points,mid) > k) r = mid - 1;\\n            else l = mid;\\n        }\\n        for(auto point: points){\\n            if(point[0]*point[0] + point[1]*point[1] < l)\\n                ans.push_back(point);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 803851,
                "title": "my-java-solution-using-priorityqueue-or-just-a-maxheap",
                "content": "Here we make use of a maxHeap;\\n1. A max heap is initialised which compares the eucledean distance of the points.(It uses a comparator)\\n2. For each of the point from the points array, we just add the distance into the heap.\\n3. If the size of heap become greater than the value of K, we just remove the element, which is the maximum distance.We remove it because we dont want to consider it and we are only interested in the minimum distance, and we only need K number of values.\\n4. At the end, whatever remains in the max heap is moved onto an array of array and returns it.\\n\\n\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> (b[0]*b[0] + b[1]*b[1] - (a[0]*a[0] + a[1]*a[1])));\\n        for (int [] point: points){\\n            heap.add(point);\\n            if (heap.size() > K)\\n                heap.remove();\\n        }\\n        int [][] result = new int[K][2];\\n        while (K-- > 0){\\n            result[K] = heap.remove();\\n        } \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> (b[0]*b[0] + b[1]*b[1] - (a[0]*a[0] + a[1]*a[1])));\\n        for (int [] point: points){\\n            heap.add(point);\\n            if (heap.size() > K)\\n                heap.remove();\\n        }\\n        int [][] result = new int[K][2];\\n        while (K-- > 0){\\n            result[K] = heap.remove();\\n        } \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 661163,
                "title": "python-heap-o-n-log-k-o-k",
                "content": "```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        import heapq\\n        max_heap = []\\n        \\n        find_distance = lambda x,y: x**2 + y**2 \\n\\n        for point in points[:k]:\\n            max_heap.append((-find_distance(*point), point)) #Default heap is a min-heap, making it negative to get a max-heap\\n\\n        heapq.heapify(max_heap)\\n\\n        for point in points[k:]:\\n            heapq.heappushpop(max_heap, (-find_distance(*point), point))  #For the next set of points, push point into the heap, and pop out the top one. Eventually the heap will contain the K closest points to origin\\n\\n        return [point for _,point in max_heap]\\n```\\n\\nTime: O(N log (K)) \\nO(K) for making the initial heap + O((N-K)(log K)) for pushing and popping N-K elements into and from a K-sized heap\\nSpace: O(K) for the heap",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        import heapq\\n        max_heap = []\\n        \\n        find_distance = lambda x,y: x**2 + y**2 \\n\\n        for point in points[:k]:\\n            max_heap.append((-find_distance(*point), point)) #Default heap is a min-heap, making it negative to get a max-heap\\n\\n        heapq.heapify(max_heap)\\n\\n        for point in points[k:]:\\n            heapq.heappushpop(max_heap, (-find_distance(*point), point))  #For the next set of points, push point into the heap, and pop out the top one. Eventually the heap will contain the K closest points to origin\\n\\n        return [point for _,point in max_heap]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 659957,
                "title": "python-1-liner",
                "content": "```\\ndef kClosest(self, points, K):\\n        points.sort(key = lambda K: K[0]**2 + K[1]**2) \\n\\n        return points[:K] \\n```\\n**Upvotes are encouraging**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef kClosest(self, points, K):\\n        points.sort(key = lambda K: K[0]**2 + K[1]**2) \\n\\n        return points[:K] \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 541026,
                "title": "javascript-quickselect",
                "content": "FYI, this is not my original solution. I rewrote the answer from the fastest sample solution.\\n```js\\n/**\\n * @param {number[][]} points\\n * @param {number} K\\n * @return {number[][]}\\n */\\nvar kClosest = function(points, K) {\\n  const swap = (i1, i2) => {\\n    [points[i1], points[i2]] = [points[i2], points[i1]];\\n  };\\n  const distance = point => point[0] ** 2 + point[1] ** 2;\\n\\n  const partition = (lo, hi) => {\\n    // pick last one as pivot\\n    const pivotDist = distance(points[hi]);\\n    let targetPivotIdx = lo,\\n      searchIdx = lo;\\n    // compare from lo to hi\\n    while (searchIdx < hi) {\\n      const dist = distance(points[searchIdx]);\\n      if (dist <= pivotDist) {\\n        swap(searchIdx, targetPivotIdx);\\n        targetPivotIdx += 1;\\n      }\\n      searchIdx += 1;\\n    }\\n\\t// hi goes to target pivot\\n    swap(hi, targetPivotIdx);\\n    return targetPivotIdx;\\n  };\\n\\n  const quickSelect = (lo, hi, target) => {\\n    const pivot = partition(lo, hi);\\n    if (pivot === target - 1) return;\\n    if (pivot < target - 1) {\\n      quickSelect(pivot + 1, hi, target);\\n    } else {\\n      quickSelect(lo, pivot - 1, target);\\n    }\\n  };\\n\\n  quickSelect(0, points.length - 1, K);\\n  return points.slice(0, K);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {number[][]} points\\n * @param {number} K\\n * @return {number[][]}\\n */\\nvar kClosest = function(points, K) {\\n  const swap = (i1, i2) => {\\n    [points[i1], points[i2]] = [points[i2], points[i1]];\\n  };\\n  const distance = point => point[0] ** 2 + point[1] ** 2;\\n\\n  const partition = (lo, hi) => {\\n    // pick last one as pivot\\n    const pivotDist = distance(points[hi]);\\n    let targetPivotIdx = lo,\\n      searchIdx = lo;\\n    // compare from lo to hi\\n    while (searchIdx < hi) {\\n      const dist = distance(points[searchIdx]);\\n      if (dist <= pivotDist) {\\n        swap(searchIdx, targetPivotIdx);\\n        targetPivotIdx += 1;\\n      }\\n      searchIdx += 1;\\n    }\\n\\t// hi goes to target pivot\\n    swap(hi, targetPivotIdx);\\n    return targetPivotIdx;\\n  };\\n\\n  const quickSelect = (lo, hi, target) => {\\n    const pivot = partition(lo, hi);\\n    if (pivot === target - 1) return;\\n    if (pivot < target - 1) {\\n      quickSelect(pivot + 1, hi, target);\\n    } else {\\n      quickSelect(lo, pivot - 1, target);\\n    }\\n  };\\n\\n  quickSelect(0, points.length - 1, K);\\n  return points.slice(0, K);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 506066,
                "title": "multimap-max-heap-nth-element-random-quickselect-solution",
                "content": "Finally cleared my doubt about heaps, I always confused min and max heaps, now I understand, for min k values I should use max heap and max k values min heap, it\\'s a little confusing!!! Of course you could use sort/ partial sort too.\\nI\\'ve written them in order of worst to best.\\nMultimap/ Min heap O(nlgn) + O(n) space:\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n    multimap<int, pair<int, int>> st;\\n    vector<vector<int>> ans;\\n    for(int i = 0; i < points.size(); i++) {\\n        int sq = (points[i][0]) * (points[i][0]) + (points[i][1]) * (points[i][1]);\\n        st.insert({sq, {points[i][0], points[i][1]}});\\n    }\\n    for(const auto &i: st) {\\n        if(K--) ans.push_back({i.second.first, i.second.second});\\n        else break;\\n    }\\n    return ans;\\n}\\n```\\nMax Heap O(nlgk) + O(k) space:\\n```\\npriority_queue<pair<int, int>> pq;\\nvector<vector<int>> ans;\\nfor(int i = 0 ; i != points.size(); i++) {\\n    int sq = points[i][0] * points[i][0] + points[i][1] * points[i][1];\\n    if(pq.size() < K) pq.push({sq, i});\\n    else {\\n        if(sq < pq.top().first) {\\n            pq.pop();\\n            pq.push({sq, i});\\n        }\\n    }\\n}\\nwhile(!pq.empty()) {\\n    ans.push_back(points[pq.top().second]);\\n    pq.pop();\\n}\\nreturn ans;\\n```\\nNth Element O(n) avg:\\n```\\nnth_element(points.begin(), points.begin() + K, points.end(), [] (const auto &a, const auto &b) {\\n    return (a[0] * a[0] + a[1] * a[1] < b[0] * b[0] + b[1] * b[1]);\\n} );\\nreturn {points.begin(), points.begin() + K}; \\n```\\nQuickselect O(n) avg:\\n```\\nint partition(vector<vector<int>> &v, int lo, int hi) {\\n    int pivot = v[hi][0] * v[hi][0] + v[hi][1] * v[hi][1];\\n    int i = lo, j = lo;\\n    for(; j < hi; j++) if(pivot >= v[j][0] * v[j][0] + v[j][1] * v[j][1]) swap(v[i++], v[j]);\\n    swap(v[i], v[hi]);\\n    return i;   \\n}\\n\\nint partitionR(vector<vector<int>> &v, int lo, int hi) {\\n    random_device rd;\\n    default_random_engine gen(rd());\\n    int pivotIdx = uniform_int_distribution<int>{lo, hi}(gen);\\n    swap(v[hi], v[pivotIdx]);\\n    return partition(v, lo, hi);\\n}\\n\\nvoid quickSelect(vector<vector<int>> &v, int K) {\\n    int lo = 0; int hi = v.size() - 1;\\n    for(;;) {\\n        int pivot = partitionR(v, lo, hi);\\n        if(pivot == K) return;\\n        else if(pivot > K) hi = pivot - 1;\\n        else lo = pivot + 1;\\n    }\\n}\\n\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n    quickSelect(points, K - 1);\\n    return {points.begin(), points.begin() + K}; \\n}\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)",
                    "Quickselect"
                ],
                "code": "```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n    multimap<int, pair<int, int>> st;\\n    vector<vector<int>> ans;\\n    for(int i = 0; i < points.size(); i++) {\\n        int sq = (points[i][0]) * (points[i][0]) + (points[i][1]) * (points[i][1]);\\n        st.insert({sq, {points[i][0], points[i][1]}});\\n    }\\n    for(const auto &i: st) {\\n        if(K--) ans.push_back({i.second.first, i.second.second});\\n        else break;\\n    }\\n    return ans;\\n}\\n```\n```\\npriority_queue<pair<int, int>> pq;\\nvector<vector<int>> ans;\\nfor(int i = 0 ; i != points.size(); i++) {\\n    int sq = points[i][0] * points[i][0] + points[i][1] * points[i][1];\\n    if(pq.size() < K) pq.push({sq, i});\\n    else {\\n        if(sq < pq.top().first) {\\n            pq.pop();\\n            pq.push({sq, i});\\n        }\\n    }\\n}\\nwhile(!pq.empty()) {\\n    ans.push_back(points[pq.top().second]);\\n    pq.pop();\\n}\\nreturn ans;\\n```\n```\\nnth_element(points.begin(), points.begin() + K, points.end(), [] (const auto &a, const auto &b) {\\n    return (a[0] * a[0] + a[1] * a[1] < b[0] * b[0] + b[1] * b[1]);\\n} );\\nreturn {points.begin(), points.begin() + K}; \\n```\n```\\nint partition(vector<vector<int>> &v, int lo, int hi) {\\n    int pivot = v[hi][0] * v[hi][0] + v[hi][1] * v[hi][1];\\n    int i = lo, j = lo;\\n    for(; j < hi; j++) if(pivot >= v[j][0] * v[j][0] + v[j][1] * v[j][1]) swap(v[i++], v[j]);\\n    swap(v[i], v[hi]);\\n    return i;   \\n}\\n\\nint partitionR(vector<vector<int>> &v, int lo, int hi) {\\n    random_device rd;\\n    default_random_engine gen(rd());\\n    int pivotIdx = uniform_int_distribution<int>{lo, hi}(gen);\\n    swap(v[hi], v[pivotIdx]);\\n    return partition(v, lo, hi);\\n}\\n\\nvoid quickSelect(vector<vector<int>> &v, int K) {\\n    int lo = 0; int hi = v.size() - 1;\\n    for(;;) {\\n        int pivot = partitionR(v, lo, hi);\\n        if(pivot == K) return;\\n        else if(pivot > K) hi = pivot - 1;\\n        else lo = pivot + 1;\\n    }\\n}\\n\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n    quickSelect(points, K - 1);\\n    return {points.begin(), points.begin() + K}; \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 374652,
                "title": "c-nth-element-concise-solution",
                "content": "**Updated:**\\n* Utilized Lambda expression\\n* Utilized non-member begin/end\\n* Index corrected from ```points.begin() + K```  to ```points.begin() + K - 1```, credit to [@Evg](https://leetcode.com/evg/).\\n\\n```\\nclass Solution {   \\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        auto isCloser = [](const vector<int>& lhs, const vector<int>& rhs){\\n            return lhs[0]*lhs[0] + lhs[1]*lhs[1] < rhs[0]*rhs[0] + rhs[1]*rhs[1];\\n        };\\n\\t\\t\\n        nth_element(begin(points), begin(points) + K - 1, end(points), isCloser);\\n        return vector<vector<int>>(begin(points), begin(points) + K);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```points.begin() + K```\n```points.begin() + K - 1```\n```\\nclass Solution {   \\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        auto isCloser = [](const vector<int>& lhs, const vector<int>& rhs){\\n            return lhs[0]*lhs[0] + lhs[1]*lhs[1] < rhs[0]*rhs[0] + rhs[1]*rhs[1];\\n        };\\n\\t\\t\\n        nth_element(begin(points), begin(points) + K - 1, end(points), isCloser);\\n        return vector<vector<int>>(begin(points), begin(points) + K);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 289200,
                "title": "using-heap-time-o-k-n-k-logk-space-o-k",
                "content": "\\n\\tfrom heapq import heappush, heappop, heappushpop\\n\\timport math \\n\\tclass Solution:\\n    \\n    def getDistanceFromOrigin(self, point: List[int]) -> float:\\n        \\n        return point[0]**2 + point[1]**2\\n    \\n    \\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        \\n        kClosestPointsToOrigin = []\\n        \\n        # add first k points\\n        for i in range(K):  # O(K)\\n            heappush(kClosestPointsToOrigin, (-self.getDistanceFromOrigin(points[i]), points[i]))\\n \\n        \\n        # maintain size of heap to k \\n        for i in range(K, len(points)): #O(N-k)\\n            heappushpop(kClosestPointsToOrigin, (-self.getDistanceFromOrigin(points[i]), points[i])) #O(log k)\\n\\n       \\n        # return each point in the heap\\n        return [heappop(kClosestPointsToOrigin)[1] for _ in range(K)] #O(k)\\n    \\n\\n    \\n\\n        \\n        \\n        \\n                \\n        \\n        \\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "\\n\\tfrom heapq import heappush, heappop, heappushpop\\n\\timport math \\n\\tclass Solution:\\n    \\n    def getDistanceFromOrigin(self, point: List[int]) -> float:\\n        \\n        return point[0]**2 + point[1]**2\\n    \\n    \\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        \\n        kClosestPointsToOrigin = []\\n        \\n        # add first k points\\n        for i in range(K):  # O(K)\\n            heappush(kClosestPointsToOrigin, (-self.getDistanceFromOrigin(points[i]), points[i]))\\n \\n        \\n        # maintain size of heap to k \\n        for i in range(K, len(points)): #O(N-k)\\n            heappushpop(kClosestPointsToOrigin, (-self.getDistanceFromOrigin(points[i]), points[i])) #O(log k)\\n\\n       \\n        # return each point in the heap\\n        return [heappop(kClosestPointsToOrigin)[1] for _ in range(K)] #O(k)\\n    \\n\\n    \\n\\n        \\n        \\n        \\n                \\n        \\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 3586995,
                "title": "using-max-heap-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe word k-closest give us a hint to use heap.Basically if distance between points can be stored and arranged in ascending order then we can easily pick k closest element among them.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInstead of storing square root of ans we directly store the sum of squares i.e x^2 +y^2 instead of sqrt(x^2+y^2) to save complexity of code.\\nA priority queue is maintained which stores pair of dist and the current point. A max heap is created with k elements and as soon as the size of maxheap is greater than k we remove the topmost element because it is of no use as we need the least distance k element only which are already in the heap.\\nThen we pop out elements one by one and pair.second gives us the point from which the dist is stored in pair.first so we pop out the top element and pair.second gives the point which we finally store in the final ans vector that is to be returned.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(nlogk)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)    \\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        priority_queue<pair<int,pair<int,int>>> pq;\\n        vector<vector<int>> ans;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            int dist=pow(points[i][0],2)+pow(points[i][1],2);\\n            pq.push({dist,{points[i][0],points[i][1]}});\\n            if(pq.size()>k)\\n            {\\n                pq.pop();\\n            }\\n        }\\n        while(!pq.empty())\\n        {\\n            auto it=pq.top().second;\\n            pq.pop();\\n            vector<int> temp;\\n            temp.push_back(it.first);\\n            temp.push_back(it.second);\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        priority_queue<pair<int,pair<int,int>>> pq;\\n        vector<vector<int>> ans;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            int dist=pow(points[i][0],2)+pow(points[i][1],2);\\n            pq.push({dist,{points[i][0],points[i][1]}});\\n            if(pq.size()>k)\\n            {\\n                pq.pop();\\n            }\\n        }\\n        while(!pq.empty())\\n        {\\n            auto it=pq.top().second;\\n            pq.pop();\\n            vector<int> temp;\\n            temp.push_back(it.first);\\n            temp.push_back(it.second);\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2364033,
                "title": "java-simple-priorityqueue",
                "content": "```\\nclass Solution {\\n \\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> (b[0]*b[0] + b[1]*b[1]) - (a[0]*a[0] + a[1]*a[1]));\\n    \\n        for(int[] point: points) {\\n            pq.add(point);\\n            if(pq.size() > k) pq.poll();\\n        }\\n        \\n        return pq.toArray(new int[k][2]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n \\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> (b[0]*b[0] + b[1]*b[1]) - (a[0]*a[0] + a[1]*a[1]));\\n    \\n        for(int[] point: points) {\\n            pq.add(point);\\n            if(pq.size() > k) pq.poll();\\n        }\\n        \\n        return pq.toArray(new int[k][2]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 817272,
                "title": "python-clean-and-simple-sort-with-lambda-beat-99",
                "content": "```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        if points is None or len(points[0]) == 0:\\n            return []\\n        \\n        if len(points) <= K:\\n            return points\\n        \\n        points.sort(key=lambda x: x[0]*x[0] + x[1]*x[1])\\n        \\n        return points[0:K]\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        if points is None or len(points[0]) == 0:\\n            return []\\n        \\n        if len(points) <= K:\\n            return points\\n        \\n        points.sort(key=lambda x: x[0]*x[0] + x[1]*x[1])\\n        \\n        return points[0:K]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 508408,
                "title": "simple-java-priorityqueue-minheap-solution-w-comments-clean-code",
                "content": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n\\t\\t// Handle null/empty edge cases\\n        if (points == null || points.length == 0) return new int[0][0];\\n        \\n        /* We\\'re using the Distance formula to calculate the distance of a set of x/y points to another set of x/y points.\\n           Formula: sqrt(x1^2 + x2^2 - y1^2 + y2^2), where x2 and y2 is the origin (0,0) in this case. \\n           So our formula is: sqrt(x1^2 + 0 - y1^2 + 0)\\n           We can ignore the sqrt() part and just simplify to: x1^2 - y1^2. \\n           Now remember that x1^2 is x1 * x1. So our formula for calculating distance becomes: x1 * x1 + y1 * y2\\n        */\\n        \\n        // We use a priorityQueue to implement a minHeap (calculates disatance for a and b and the sorts by shortest to farthest distance)\\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((a, b) -> (a[0] * a[0] + a[1] * a[1]) - (b[0] * b[0] + b[1] * b[1]) );\\n            \\n        // Now load each set of points on to the minHead\\n        for (int i = 0; i < points.length; i++) {\\n            minHeap.offer(points[i]);\\n        }\\n        \\n        // Next we create an array to contain points up to K\\n        int[][] results = new int[K][2];\\n        \\n        // Then iterate and add elements from our minHeap up to K\\n        for (int i = 0; i < K; i++) {\\n            results[i] = minHeap.poll();\\n        }\\n        \\n        return results;\\n    }\\n}\\n```\\nTime Complexity: O(nlogn)\\nSpace Complexity: O(n)",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n\\t\\t// Handle null/empty edge cases\\n        if (points == null || points.length == 0) return new int[0][0];\\n        \\n        /* We\\'re using the Distance formula to calculate the distance of a set of x/y points to another set of x/y points.\\n           Formula: sqrt(x1^2 + x2^2 - y1^2 + y2^2), where x2 and y2 is the origin (0,0) in this case. \\n           So our formula is: sqrt(x1^2 + 0 - y1^2 + 0)\\n           We can ignore the sqrt() part and just simplify to: x1^2 - y1^2. \\n           Now remember that x1^2 is x1 * x1. So our formula for calculating distance becomes: x1 * x1 + y1 * y2\\n        */\\n        \\n        // We use a priorityQueue to implement a minHeap (calculates disatance for a and b and the sorts by shortest to farthest distance)\\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((a, b) -> (a[0] * a[0] + a[1] * a[1]) - (b[0] * b[0] + b[1] * b[1]) );\\n            \\n        // Now load each set of points on to the minHead\\n        for (int i = 0; i < points.length; i++) {\\n            minHeap.offer(points[i]);\\n        }\\n        \\n        // Next we create an array to contain points up to K\\n        int[][] results = new int[K][2];\\n        \\n        // Then iterate and add elements from our minHeap up to K\\n        for (int i = 0; i < K; i++) {\\n            results[i] = minHeap.poll();\\n        }\\n        \\n        return results;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 255165,
                "title": "python-clear-solution-with-heap-and-explanation",
                "content": "1. The distance from origin is the Euclidean distance that is \\'c\\' in  `c^2 = x^2 + y^2` (Pythagorean theorem)\\n2. Create max heap ordered by distance, and fill it with the first K points\\n3. Loop over the rest of the points and check for each one: if its distance is smaller than max in heap, extract_max() from heap and push this point\\n\\nRT: O(K + (P - K) * lg K)\\nK is for creating initial heap\\nFor the remaining (P - K) points, we may do that many calls to extract_Max() (lg K)\\n\\nSpc: O(K)\\n\\n```\\nfrom math import sqrt\\nfrom heapq import heappush, heappop\\n\\nclass HeapElem:\\n    def __init__(self, dist, point):\\n        self.dist = dist\\n        self.point = point\\n        \\n    def __lt__(self, other):\\n        return self.dist < other.dist\\n\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        heap = []\\n        # Put first K elements into heap.\\n        for i in range(0, K):\\n            heappush(heap, HeapElem(-get_dist(points[i]), points[i]))\\n            \\n        for i in range(K, len(points)):\\n            dist = get_dist(points[i])\\n            # If dist is less than the max we have in heap, replace the max\\n            # with this smaller distance.\\n            if dist < -heap[0].dist:\\n                heappop(heap)\\n                heappush(heap, HeapElem(-dist, points[i]))\\n        return [elem.point for elem in heap]\\n                \\ndef get_dist(p):\\n    x = p[0]\\n    y = p[1]\\n    return sqrt(x**2 + y**2)\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom math import sqrt\\nfrom heapq import heappush, heappop\\n\\nclass HeapElem:\\n    def __init__(self, dist, point):\\n        self.dist = dist\\n        self.point = point\\n        \\n    def __lt__(self, other):\\n        return self.dist < other.dist\\n\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        heap = []\\n        # Put first K elements into heap.\\n        for i in range(0, K):\\n            heappush(heap, HeapElem(-get_dist(points[i]), points[i]))\\n            \\n        for i in range(K, len(points)):\\n            dist = get_dist(points[i])\\n            # If dist is less than the max we have in heap, replace the max\\n            # with this smaller distance.\\n            if dist < -heap[0].dist:\\n                heappop(heap)\\n                heappush(heap, HeapElem(-dist, points[i]))\\n        return [elem.point for elem in heap]\\n                \\ndef get_dist(p):\\n    x = p[0]\\n    y = p[1]\\n    return sqrt(x**2 + y**2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 220326,
                "title": "python3-solution-using-quickselect-and-priorityqueue",
                "content": "###  QuickSelect solution:\\n\\nSee classical QuickSort algorithm in  _Data Structures and Algorithm Analysis in C(Second Edition)_ 7.7.  \\n**Shortcut to learn [Slide of FSU\\'s CS](http://www.cs.fsu.edu/~breno/COP-4530/slides/21-anim.pdf)**\\n\\nThe following code is basically the same as the source code in the book.  \\n* *QuickSort algorithm* is faster when dealing with larger arrays.  \\nTime Complexity: Best O(N); Average O(NlogN); Worst O(N^2)\\nSpace Complexity: O(1)\\n\\n* Using *Median-of-Three Partitioning* is the better way to get pivot, eliminating the bad situation of pre-sorting, and reducing the fast sorting by about 5% of the run time.\\n\\n* Using *Insertion Sort* to handle small array(Len < 20) leads to a better submission.\\n\\n```py\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        dist = lambda i: points[i][0]**2 + points[i][1]**2\\n\\t\\t\\n\\t\\t# Median-of-Three Partitioning: \\n\\t\\t# Use the median of the three elements on the left, right, \\n\\t\\t# and middle positions as the pivot element.\\n\\t\\t# Hide pivot finally\\n        def Medium3(left, right):\\n            center = (left + right) // 2\\n            if dist(left) > dist(center):\\n                points[left], points[center] = points[center], points[left]\\n            if dist(left) > dist(right):\\n                points[left], points[right] = points[right], points[left]\\n            if dist(center) > dist(right):\\n                points[center], points[right] = points[right], points[center]\\n            # Invariant: points[left] <= points[center] <= points[right]\\n            points[center], points[right - 1] = points[right - 1], points[center] # Hide pivot in the penultimate position\\n            return dist(right - 1) # Return pivot\\n\\n        def Qselect(k, left, right, cutoff):\\n            if left + cutoff <= right:\\n                if left < right:\\n                    pivot = Medium3(left, right)\\n                    i = left; j = right - 1\\n                    while i < j:\\n                        # plus 1 first to avoid infinite loop\\n                        i += 1\\n                        while dist(i) < pivot: i += 1\\n                        j -= 1\\n                        while dist(j) > pivot: j -= 1\\n                        if i < j:\\n                            points[i], points[j] = points[j], points[i]\\n                    # restore pivot\\n                    points[i], points[right - 1] = points[right - 1], points[i]\\n                    if k <= i:\\n                        Qselect(k, left, i - 1, cutoff)\\n                    elif k > i + 1:\\n                        Qselect(k, i + 1, right, cutoff)\\n            else:\\n                # Do a insertion sort on the subarray(len<cutoff)\\n                InsertionSort(left, right)\\n       \\n        def InsertionSort(left, right):\\n            for i in range(left, right+1):\\n                tmp = points[i]\\n                tmp_dist = dist(i)\\n                j = i\\n                while j > 0:\\n                    if dist(j-1) < tmp_dist: break\\n                    points[j] = points[j-1]\\n                    j -= 1\\n                points[j] = tmp\\n        \\n        # In general, set cutoff 20.    \\n        Qselect(K, 0, len(points) - 1, 20)\\n        return points[:K]\\n```\\n\\n###  PriorityQueue solution:\\nTC: O(N + Nlogk)\\nSC: \\xA0O(k)\\n```py\\nimport queue\\nclass Solution:\\n    def kClosest(self, points, K):\\n        dist = [point[0]**2 + point[1]**2 for point in points]\\n        q = queue.PriorityQueue()\\n        \\n        for i in range(len(points)):\\n            q.put((-dist[i], points[i]))\\n            if q.qsize() > K:\\n                q.get()\\n        \\n\\t\\tres = []\\n        while K > 0:\\n            point = q.get()[1]\\n            res.append(point)\\n            K -= 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        dist = lambda i: points[i][0]**2 + points[i][1]**2\\n\\t\\t\\n\\t\\t# Median-of-Three Partitioning: \\n\\t\\t# Use the median of the three elements on the left, right, \\n\\t\\t# and middle positions as the pivot element.\\n\\t\\t# Hide pivot finally\\n        def Medium3(left, right):\\n            center = (left + right) // 2\\n            if dist(left) > dist(center):\\n                points[left], points[center] = points[center], points[left]\\n            if dist(left) > dist(right):\\n                points[left], points[right] = points[right], points[left]\\n            if dist(center) > dist(right):\\n                points[center], points[right] = points[right], points[center]\\n            # Invariant: points[left] <= points[center] <= points[right]\\n            points[center], points[right - 1] = points[right - 1], points[center] # Hide pivot in the penultimate position\\n            return dist(right - 1) # Return pivot\\n\\n        def Qselect(k, left, right, cutoff):\\n            if left + cutoff <= right:\\n                if left < right:\\n                    pivot = Medium3(left, right)\\n                    i = left; j = right - 1\\n                    while i < j:\\n                        # plus 1 first to avoid infinite loop\\n                        i += 1\\n                        while dist(i) < pivot: i += 1\\n                        j -= 1\\n                        while dist(j) > pivot: j -= 1\\n                        if i < j:\\n                            points[i], points[j] = points[j], points[i]\\n                    # restore pivot\\n                    points[i], points[right - 1] = points[right - 1], points[i]\\n                    if k <= i:\\n                        Qselect(k, left, i - 1, cutoff)\\n                    elif k > i + 1:\\n                        Qselect(k, i + 1, right, cutoff)\\n            else:\\n                # Do a insertion sort on the subarray(len<cutoff)\\n                InsertionSort(left, right)\\n       \\n        def InsertionSort(left, right):\\n            for i in range(left, right+1):\\n                tmp = points[i]\\n                tmp_dist = dist(i)\\n                j = i\\n                while j > 0:\\n                    if dist(j-1) < tmp_dist: break\\n                    points[j] = points[j-1]\\n                    j -= 1\\n                points[j] = tmp\\n        \\n        # In general, set cutoff 20.    \\n        Qselect(K, 0, len(points) - 1, 20)\\n        return points[:K]\\n```\n```py\\nimport queue\\nclass Solution:\\n    def kClosest(self, points, K):\\n        dist = [point[0]**2 + point[1]**2 for point in points]\\n        q = queue.PriorityQueue()\\n        \\n        for i in range(len(points)):\\n            q.put((-dist[i], points[i]))\\n            if q.qsize() > K:\\n                q.get()\\n        \\n\\t\\tres = []\\n        while K > 0:\\n            point = q.get()[1]\\n            res.append(point)\\n            K -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 219115,
                "title": "python-heap-o-nlogk",
                "content": "```\\nfrom heapq import heappush, heappop, heappushpop\\n\\nclass Solution:\\n    def kClosest(self, points, K):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :type K: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        kClosestPointsToOrigin = []\\n        \\n        # add first k points\\n        for i in range(K):\\n            heappush(kClosestPointsToOrigin, (-Solution.getDistanceFromOrigin(points[i]), points[i]))\\n        \\n        # maintain k closest in heap for the remaining points\\n        for i in range(K, len(points)):\\n            heappushpop(kClosestPointsToOrigin, (-Solution.getDistanceFromOrigin(points[i]), points[i]))\\n        \\n        # return each point in the heap\\n        return [heappop(kClosestPointsToOrigin)[1] for _ in range(K)]\\n        \\n    \\n    @staticmethod\\n    def getDistanceFromOrigin(point):\\n        return math.sqrt(point[0]**2 + point[1]**2)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom heapq import heappush, heappop, heappushpop\\n\\nclass Solution:\\n    def kClosest(self, points, K):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :type K: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        kClosestPointsToOrigin = []\\n        \\n        # add first k points\\n        for i in range(K):\\n            heappush(kClosestPointsToOrigin, (-Solution.getDistanceFromOrigin(points[i]), points[i]))\\n        \\n        # maintain k closest in heap for the remaining points\\n        for i in range(K, len(points)):\\n            heappushpop(kClosestPointsToOrigin, (-Solution.getDistanceFromOrigin(points[i]), points[i]))\\n        \\n        # return each point in the heap\\n        return [heappop(kClosestPointsToOrigin)[1] for _ in range(K)]\\n        \\n    \\n    @staticmethod\\n    def getDistanceFromOrigin(point):\\n        return math.sqrt(point[0]**2 + point[1]**2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2968473,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<pair<int, int>> v;\\n        int n=points.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=points[i][0];\\n            int y=points[i][1];\\n            v.push_back({(x*x+y*y),i});\\n        }\\n        sort(v.begin(), v.end());\\n        vector<vector<int>> ans;\\n        for(int i=0;i<k;i++)\\n        {\\n            ans.push_back(points[v[i].second]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<pair<int, int>> v;\\n        int n=points.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=points[i][0];\\n            int y=points[i][1];\\n            v.push_back({(x*x+y*y),i});\\n        }\\n        sort(v.begin(), v.end());\\n        vector<vector<int>> ans;\\n        for(int i=0;i<k;i++)\\n        {\\n            ans.push_back(points[v[i].second]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2617329,
                "title": "c-clean-and-easy-to-understand-code",
                "content": "***\\uD83D\\uDD25\\u2705If u find this useful , please consider to give a upvote!!\\uD83D\\uDD25\\u2705***\\n\\n\\t\\tunordered_map<int,vector<int>>mp; vector<vector<int>>vec;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            int ori=points[i][0]*points[i][0]+points[i][1]*points[i][1];\\n            points[i].push_back(ori);\\n        }\\n        for(int i=0;i<points.size();i++)\\n        {\\n            swap(points[i][0],points[i][2]);\\n        }\\n        sort(points.begin(),points.end()); \\n        for(int i=0;i<k;i++)\\n        {\\n            vec.push_back({points[i][2],points[i][1]});\\n        }\\n        return vec;",
                "solutionTags": [],
                "code": "***\\uD83D\\uDD25\\u2705If u find this useful , please consider to give a upvote!!\\uD83D\\uDD25\\u2705***\\n\\n\\t\\tunordered_map<int,vector<int>>mp; vector<vector<int>>vec;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            int ori=points[i][0]*points[i][0]+points[i][1]*points[i][1];\\n            points[i].push_back(ori);\\n        }\\n        for(int i=0;i<points.size();i++)\\n        {\\n            swap(points[i][0],points[i][2]);\\n        }\\n        sort(points.begin(),points.end()); \\n        for(int i=0;i<k;i++)\\n        {\\n            vec.push_back({points[i][2],points[i][1]});\\n        }\\n        return vec;",
                "codeTag": "Unknown"
            },
            {
                "id": 2252373,
                "title": "java-simple-priority-queue-beats-92",
                "content": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n        if(K == points.length) return points;\\n        \\n        //create a PQ witha comparator that puts the greates Euclid distance at the top so that we can remove it when the PQ size exceeds k.\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> (b[0]*b[0] + b[1]*b[1]) - (a[0]*a[0] + a[1]*a[1]));\\n            \\n       \\n        \\n        for(int[] point: points) {\\n            pq.add(point);\\n            if(pq.size() > K) pq.poll();\\n        }\\n        return pq.toArray(new int[0][0]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n        if(K == points.length) return points;\\n        \\n        //create a PQ witha comparator that puts the greates Euclid distance at the top so that we can remove it when the PQ size exceeds k.\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> (b[0]*b[0] + b[1]*b[1]) - (a[0]*a[0] + a[1]*a[1]));\\n            \\n       \\n        \\n        for(int[] point: points) {\\n            pq.add(point);\\n            if(pq.size() > K) pq.poll();\\n        }\\n        return pq.toArray(new int[0][0]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1838137,
                "title": "c-heap-priorityqueue",
                "content": "\\n\\n\\t public class Solution {\\n    public int[][] KClosest(int[][] points, int k) {\\n        // Result Array initialization\\n        int[][] results = new int[k][];\\n        for(int i = 0 ; i <  k ; i++)\\n        {\\n            results[i] = new int[2];\\n        }\\n        \\n        // Priority Queue initialization\\n        PriorityQueue<int[], double> queue = new PriorityQueue<int[], double>(new ReverseComp());\\n        foreach(int[] point in points)\\n        {\\n            // Adding in heap.\\n            double distance = Math.Sqrt( (point[0] * point[0] ) + (point[1] * point[1]));\\n            queue.Enqueue(point, distance);\\n            if(queue.Count > k)\\n                queue.Dequeue();\\n        }\\n        \\n        // adding in results.\\n        int iter = 0;\\n        while(queue.Count != 0)\\n        {\\n            results[iter++] = queue.Dequeue();\\n        }\\n        return results ;\\n\\t}\\n\\t}\\n\\tpublic class ReverseComp : IComparer<double>\\n\\t{\\n    public int Compare(double x, double y)\\n    {\\n        return y.CompareTo(x);\\n    }\\n\\t}",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    public int[][] KClosest(int[][] points, int k) {\\n        // Result Array initialization\\n        int[][] results = new int[k][];\\n        for(int i = 0 ; i <  k ; i++)\\n        {\\n            results[i] = new int[2];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1647306,
                "title": "python-one-line-code-easy",
                "content": "```\\ndef kClosest(self, points, k):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :type k: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        return sorted(points, key = lambda x : x[0]**2 + x[1]**2 )[:k]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef kClosest(self, points, k):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :type k: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        return sorted(points, key = lambda x : x[0]**2 + x[1]**2 )[:k]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1516061,
                "title": "python3-o-nlogk",
                "content": "```\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:       \\n        heap = []\\n        for x,y in points: # N\\n            \\n            dis = -(x**2 + y**2)\\n            heapq.heappush(heap,(dis,x,y))\\n            \\n            if len(heap) > k:   # logK\\n                heapq.heappop(heap)       \\n                \\n        return [[x,y] for _,x,y in heap]\\n\\t\\t```\\n\\t\\tfeel free to ask Q...\\n\\t\\t#you can find more my solution using #happytohelpu",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:       \\n        heap = []\\n        for x,y in points: # N\\n            \\n            dis = -(x**2 + y**2)\\n            heapq.heappush(heap,(dis,x,y))\\n            \\n            if len(heap) > k:   # logK\\n                heapq.heappop(heap)       \\n                \\n        return [[x,y] for _,x,y in heap]\\n\\t\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 1016100,
                "title": "c-max-heap-solution-faster-than-100-137ms",
                "content": "class Solution {\\npublic:\\n    \\n    float distance(int x2,int y2)\\n    {\\n        float value= sqrt(pow((x2),2)+pow((y2),2));\\n        \\n        return value;\\n    }\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        \\n        priority_queue<pair<float,int>>maxh;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            maxh.push({distance(points[i][0],points[i][1]),i});\\n            \\n            if(maxh.size()>K) maxh.pop();\\n            \\n        }\\n        \\n        vector<vector<int>>ans;\\n        while(maxh.size()!=0)\\n        {\\n            ans.push_back(points[maxh.top().second]);\\n            maxh.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    float distance(int x2,int y2)\\n    {\\n        float value= sqrt(pow((x2),2)+pow((y2),2));\\n        \\n        return value;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 995284,
                "title": "ruby-one-line",
                "content": "```\\ndef k_closest(points, k)\\n  points.sort_by{|x, y| x*x + y*y}[0...k]\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef k_closest(points, k)\\n  points.sort_by{|x, y| x*x + y*y}[0...k]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 887836,
                "title": "cpp-85-min-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        \\n\\t\\t//min priority queue syntax\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq; \\n        vector<vector<int>> answer;\\n        \\n        for (int i = 0; i < points.size(); i++) {\\n            pq.push({points[i][0]*points[i][0] + points[i][1]*points[i][1], i});\\n        }\\n        \\n        while (K--) {\\n            answer.push_back(points[pq.top().second]);\\n            pq.pop();\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        \\n\\t\\t//min priority queue syntax\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq; \\n        vector<vector<int>> answer;\\n        \\n        for (int i = 0; i < points.size(); i++) {\\n            pq.push({points[i][0]*points[i][0] + points[i][1]*points[i][1], i});\\n        }\\n        \\n        while (K--) {\\n            answer.push_back(points[pq.top().second]);\\n            pq.pop();\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 659991,
                "title": "python3-oneliner-using-sorted-and-lambda-which-beats-98",
                "content": "```python\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        return sorted(points, key=lambda p: p[0]*p[0] + p[1]*p[1])[:K]\\n```\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        return sorted(points, key=lambda p: p[0]*p[0] + p[1]*p[1])[:K]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 609013,
                "title": "python-with-heap-explained-o-klogn-o-n",
                "content": "```\\n#how to run start\\n# kClosest([[1,3],[-2,2], [0,8],[7,1]], 2)\\n#how to run end\\n\\n### Time complexity in big O notation:\\n\\n#Algorithm\\tAverage\\t     Worst case\\n#Space\\t\\tO(n)\\t        O(n)\\n#Search\\t\\tO(n)\\t        O(n)\\n#Insert\\t\\tO(1)\\t        O(log n)\\n#Delete\\t\\tO(log n)\\t    O(log n)\\n#Peek\\t\\tO(1)\\t        O(1)\\n\\n\\nimport heapq\\n\\ndef kClosest(points, K):\\n    heap = []\\n    \\n#for every pair in points, find the distance\\n    for point in points:\\n        dist = (point[0]**2+point[1]**2)**0.5\\n#add the -distance, point pair to heap (since this is a min heap, and by addin the \"-\" we make the largest distance to be the min heap, for popping later)         \\n        heapq.heappush(heap,(-dist,point))\\n        if len(heap)>K:\\n#if heap size exceeds the K, then there is no point of keeping them as we only need the Kth closest element, so remove the access by popping.\\n# pop removes the smalles element, so in this case it will remove the larger actual distance as we declared distance as negative above. \\n            heapq.heappop(heap)\\n# return the second elements of the tuple(which is the point pairs, first being the distance), for the K closest elements. \\n# as we deleted the elements that where more than K, when we return everything here it serves the purpose. \\n\\n    print(heap)\\n    \\n#return the point pair of all the elements in the heap, tuple[0] is the -distance so we do not need it for the answer here \\n    return [tuple[1] for tuple in heap]\\n",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n#how to run start\\n# kClosest([[1,3],[-2,2], [0,8],[7,1]], 2)\\n#how to run end\\n\\n### Time complexity in big O notation:\\n\\n#Algorithm\\tAverage\\t     Worst case\\n#Space\\t\\tO(n)\\t        O(n)\\n#Search\\t\\tO(n)\\t        O(n)\\n#Insert\\t\\tO(1)\\t        O(log n)\\n#Delete\\t\\tO(log n)\\t    O(log n)\\n#Peek\\t\\tO(1)\\t        O(1)\\n\\n\\nimport heapq\\n\\ndef kClosest(points, K):\\n    heap = []\\n    \\n#for every pair in points, find the distance\\n    for point in points:\\n        dist = (point[0]**2+point[1]**2)**0.5\\n#add the -distance, point pair to heap (since this is a min heap, and by addin the \"-\" we make the largest distance to be the min heap, for popping later)         \\n        heapq.heappush(heap,(-dist,point))\\n        if len(heap)>K:\\n#if heap size exceeds the K, then there is no point of keeping them as we only need the Kth closest element, so remove the access by popping.\\n# pop removes the smalles element, so in this case it will remove the larger actual distance as we declared distance as negative above. \\n            heapq.heappop(heap)\\n# return the second elements of the tuple(which is the point pairs, first being the distance), for the K closest elements. \\n# as we deleted the elements that where more than K, when we return everything here it serves the purpose. \\n\\n    print(heap)\\n    \\n#return the point pair of all the elements in the heap, tuple[0] is the -distance so we do not need it for the answer here \\n    return [tuple[1] for tuple in heap]\\n",
                "codeTag": "Python3"
            },
            {
                "id": 541208,
                "title": "c-very-short-solution-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\n    static int distance(const vector<int>& p) {\\n        return p[0] * p[0] + p[1] * p[1];\\n    }\\n    \\n    static bool cmp(const vector<int>& p1, const vector<int>& p2) {\\n        return distance(p1) < distance(p2);\\n    }\\n    \\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, const int& K) {\\n        nth_element(points.begin(), points.begin() + K, points.end(), cmp);\\n        return vector(points.begin(), points.begin() + K);\\n    }\\n};\\n```\\nWe use quickselect base on the Euclidean distance to the origin.\\nEditted: we can just use the square of the points to compare.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Quickselect"
                ],
                "code": "```\\nclass Solution {\\n    static int distance(const vector<int>& p) {\\n        return p[0] * p[0] + p[1] * p[1];\\n    }\\n    \\n    static bool cmp(const vector<int>& p1, const vector<int>& p2) {\\n        return distance(p1) < distance(p2);\\n    }\\n    \\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, const int& K) {\\n        nth_element(points.begin(), points.begin() + K, points.end(), cmp);\\n        return vector(points.begin(), points.begin() + K);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 498448,
                "title": "python-maxheap",
                "content": "## 973. K Closest Points to Origin\\n\\n\\n### Problem Solving\\n![image](https://user-images.githubusercontent.com/6414741/73693862-d9ff3100-468b-11ea-947d-54b42feefc7e.png)\\n\\n-----\\n\\n![image](https://user-images.githubusercontent.com/6414741/73693985-0fa41a00-468c-11ea-8cee-38afcdf2a032.png)\\n\\n\\n#### Buggy Code \\n\\nWhy fail: use distance as dictionary key can yields different value pair result, so dictionary here isn\\'t a good idea.\\nafter some research, realize heapify still works for tuple in python.... so let\\'s just use tuple to include x, y information instead\\n\\n\\n```python\\nfrom heapq import heapreplace, heapify\\nclass Solution(object):\\n    def kClosest(self, pairs, k):\\n        nums = []\\n        dic = {}\\n        self.getDist(pairs, nums, dic)\\n        nums = [-num for num in nums]\\n        heap = nums[:k]\\n        heapq.heapify(heap)\\n        \\n              \\n        for i in range(k, len(nums)):\\n            if nums[i] > heap[0]:\\n                heapq.heapreplace(heap, nums[i])\\n        \\n        res = []\\n        for num in heap:\\n            res.append(dic[-num])    \\n        return res\\n        \\n\\n        \\n        \\n    \\n    def getDist(self, pairs, nums, dic):\\n        for pair in pairs:\\n            x, y = pair\\n            dist = (x ** 2 + y ** 2) ** 0.5\\n            dic[dist] = [x, y]\\n            nums.append(dist)\\n            \\nFail:    \\n\\n\\nInput\\n[[0,1],[1,0]]\\n2\\nOutput\\n[[1,0],[1,0]]\\nExpected\\n[[0,1],[1,0]]\\n```\\n\\n\\n### Fixed Code\\n\\n```python\\nfrom heapq import heapreplace, heapify\\nclass Solution(object):\\n    def kClosest(self, pairs, k):\\n        nums = []\\n        self.getDist(pairs, nums)\\n        heap = nums[:k]\\n        heapq.heapify(heap)\\n        \\n        for i in range(k, len(nums)):\\n            if -nums[i][0] < -heap[0][0]:\\n                heapq.heapreplace(heap, nums[i])\\n        \\n        res = []\\n        for num, x, y in heap:\\n            res.append([x, y])    \\n        return res\\n        \\n    def getDist(self, pairs, nums):\\n        for pair in pairs:\\n            x, y = pair\\n            dist = (x ** 2 + y ** 2) ** 0.5\\n            nums.append((-dist, x, y))\\n\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom heapq import heapreplace, heapify\\nclass Solution(object):\\n    def kClosest(self, pairs, k):\\n        nums = []\\n        dic = {}\\n        self.getDist(pairs, nums, dic)\\n        nums = [-num for num in nums]\\n        heap = nums[:k]\\n        heapq.heapify(heap)\\n        \\n              \\n        for i in range(k, len(nums)):\\n            if nums[i] > heap[0]:\\n                heapq.heapreplace(heap, nums[i])\\n        \\n        res = []\\n        for num in heap:\\n            res.append(dic[-num])    \\n        return res\\n        \\n\\n        \\n        \\n    \\n    def getDist(self, pairs, nums, dic):\\n        for pair in pairs:\\n            x, y = pair\\n            dist = (x ** 2 + y ** 2) ** 0.5\\n            dic[dist] = [x, y]\\n            nums.append(dist)\\n            \\nFail:    \\n\\n\\nInput\\n[[0,1],[1,0]]\\n2\\nOutput\\n[[1,0],[1,0]]\\nExpected\\n[[0,1],[1,0]]\\n```\n```python\\nfrom heapq import heapreplace, heapify\\nclass Solution(object):\\n    def kClosest(self, pairs, k):\\n        nums = []\\n        self.getDist(pairs, nums)\\n        heap = nums[:k]\\n        heapq.heapify(heap)\\n        \\n        for i in range(k, len(nums)):\\n            if -nums[i][0] < -heap[0][0]:\\n                heapq.heapreplace(heap, nums[i])\\n        \\n        res = []\\n        for num, x, y in heap:\\n            res.append([x, y])    \\n        return res\\n        \\n    def getDist(self, pairs, nums):\\n        for pair in pairs:\\n            x, y = pair\\n            dist = (x ** 2 + y ** 2) ** 0.5\\n            nums.append((-dist, x, y))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 380195,
                "title": "python-using-quickselect",
                "content": "```\\nclass Solution(object):\\n    def kClosest(self, points, K):\\n        results = []\\n        for i in range(len(points)):\\n            points[i] = (points[i][0]**2 + points[i][1]**2, points[i])  # (distance, point) tuple\\n        self.quickSelectHelper(points, 0, len(points)-1, K)\\n        for i in range(K):\\n            results.append(points[i][1])\\n        return results\\n\\n    def quickSelectHelper(self, arr, start, end, K):\\n        if start >= end: return\\n        mid = (start + end)//2\\n        arr[start], arr[mid] = arr[mid], arr[start]\\n        i, j = start + 1, end\\n        while i <= j:\\n            while i <= j and arr[i][0] <= arr[start][0]:  # compare the first element in tuple (distance)\\n                i += 1\\n            while i <= j and arr[j][0] >= arr[start][0]:  # compare the first element in tuple (distance)\\n                j -= 1\\n            if i < j: arr[i], arr[j] = arr[j], arr[i]\\n        arr[start], arr[j] = arr[j], arr[start]\\n        if K == j:\\n            return\\n        elif K < j:\\n            self.quickSelectHelper(arr, start, j-1, K)\\n        else:\\n            self.quickSelectHelper(arr, j+1, end, K)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def kClosest(self, points, K):\\n        results = []\\n        for i in range(len(points)):\\n            points[i] = (points[i][0]**2 + points[i][1]**2, points[i])  # (distance, point) tuple\\n        self.quickSelectHelper(points, 0, len(points)-1, K)\\n        for i in range(K):\\n            results.append(points[i][1])\\n        return results\\n\\n    def quickSelectHelper(self, arr, start, end, K):\\n        if start >= end: return\\n        mid = (start + end)//2\\n        arr[start], arr[mid] = arr[mid], arr[start]\\n        i, j = start + 1, end\\n        while i <= j:\\n            while i <= j and arr[i][0] <= arr[start][0]:  # compare the first element in tuple (distance)\\n                i += 1\\n            while i <= j and arr[j][0] >= arr[start][0]:  # compare the first element in tuple (distance)\\n                j -= 1\\n            if i < j: arr[i], arr[j] = arr[j], arr[i]\\n        arr[start], arr[j] = arr[j], arr[start]\\n        if K == j:\\n            return\\n        elif K < j:\\n            self.quickSelectHelper(arr, start, j-1, K)\\n        else:\\n            self.quickSelectHelper(arr, j+1, end, K)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 292640,
                "title": "concise-java-heap-solution",
                "content": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n        if(K>=points.length) return points;\\n        PriorityQueue<int[]> heap=new PriorityQueue<>(new Comparator<int[]>(){public int compare(int[] p1,int[] p2){return (p1[0]*p1[0])+(p1[1]*p1[1])-(p2[0]*p2[0])-(p2[1]*p2[1]);}});\\n        for(int[] point:points) heap.offer(point);\\n        int[][] result=new int[K][2];\\n        for(int i=0;i<K;i++) result[i]=heap.poll();\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n        if(K>=points.length) return points;\\n        PriorityQueue<int[]> heap=new PriorityQueue<>(new Comparator<int[]>(){public int compare(int[] p1,int[] p2){return (p1[0]*p1[0])+(p1[1]*p1[1])-(p2[0]*p2[0])-(p2[1]*p2[1]);}});\\n        for(int[] point:points) heap.offer(point);\\n        int[][] result=new int[K][2];\\n        for(int i=0;i<K;i++) result[i]=heap.poll();\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 239271,
                "title": "c-solution",
                "content": "```\\nint cmpFunc(const int** a, const int** b)\\n{\\n    return ((a[0][0]-b[0][0])*(a[0][0]+b[0][0]))+((a[0][1]-b[0][1])*(a[0][1]+b[0][1]));\\n}\\n\\nint** kClosest(int** points, int pointsRowSize, int *pointsColSizes, int K, int** columnSizes, int* returnSize) {\\n    int** ans = malloc(sizeof(int*)*K);\\n    *columnSizes = malloc(sizeof(int)*K);\\n    *returnSize = K;\\n    for (int i = 0; i < K; i++)\\n    {\\n        columnSizes[0][i] = 2;\\n    }\\n    \\n    qsort(points, pointsRowSize, sizeof(int*), cmpFunc);\\n    return points;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint cmpFunc(const int** a, const int** b)\\n{\\n    return ((a[0][0]-b[0][0])*(a[0][0]+b[0][0]))+((a[0][1]-b[0][1])*(a[0][1]+b[0][1]));\\n}\\n\\nint** kClosest(int** points, int pointsRowSize, int *pointsColSizes, int K, int** columnSizes, int* returnSize) {\\n    int** ans = malloc(sizeof(int*)*K);\\n    *columnSizes = malloc(sizeof(int)*K);\\n    *returnSize = K;\\n    for (int i = 0; i < K; i++)\\n    {\\n        columnSizes[0][i] = 2;\\n    }\\n    \\n    qsort(points, pointsRowSize, sizeof(int*), cmpFunc);\\n    return points;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3899440,
                "title": "beats-91-priority-queue-c-solution-c-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    class info{\\n        public:\\n        int x;\\n        int y;\\n        float distance; // int must be avoided as for decimals we will get equall distances for diff points\\n        info(int a , int b)\\n        {\\n            x = a;\\n            y = b;\\n        // as always we are finding the distance from the origin so\\n            distance = sqrt (x*x + y*y);\\n\\n        }\\n    };\\n\\nclass compare{\\n   public:\\n   bool operator()(info* point1 , info* point2)\\n   {\\n       if( point1->distance > point2->distance)\\n       {\\n           return true;\\n       }\\n       else{\\n           return false;\\n       }\\n   }\\n};\\n\\n\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        // as we want the min  distance so we can use the min heap to store the distance of the min points by using the class info\\n        priority_queue<info*,vector<info*>,compare> minheap;\\n\\n        for( int i = 0 ; i < points.size() ; i ++)\\n        {\\n            // current point\\n            int x1 = points[i][0];\\n            int y1 = points[i][1];\\n            info* newinfo = new info(x1,y1);\\n            minheap.push(newinfo);\\n        }\\n        vector<vector<int>> ans;\\n        while(k > 0)\\n        {\\n            // make point of the top element and push it into the ans\\n            info* temp = minheap.top();\\n            minheap.pop();\\n            int xval = temp->x;\\n            int yval = temp->y;\\n            // now push the point into the ans\\n            vector<int> temp2 ;\\n            temp2.push_back(xval);\\n            temp2.push_back(yval);\\n            ans.push_back(temp2);\\n            k--;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    class info{\\n        public:\\n        int x;\\n        int y;\\n        float distance; // int must be avoided as for decimals we will get equall distances for diff points\\n        info(int a , int b)\\n        {\\n            x = a;\\n            y = b;\\n        // as always we are finding the distance from the origin so\\n            distance = sqrt (x*x + y*y);\\n\\n        }\\n    };\\n\\nclass compare{\\n   public:\\n   bool operator()(info* point1 , info* point2)\\n   {\\n       if( point1->distance > point2->distance)\\n       {\\n           return true;\\n       }\\n       else{\\n           return false;\\n       }\\n   }\\n};\\n\\n\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        // as we want the min  distance so we can use the min heap to store the distance of the min points by using the class info\\n        priority_queue<info*,vector<info*>,compare> minheap;\\n\\n        for( int i = 0 ; i < points.size() ; i ++)\\n        {\\n            // current point\\n            int x1 = points[i][0];\\n            int y1 = points[i][1];\\n            info* newinfo = new info(x1,y1);\\n            minheap.push(newinfo);\\n        }\\n        vector<vector<int>> ans;\\n        while(k > 0)\\n        {\\n            // make point of the top element and push it into the ans\\n            info* temp = minheap.top();\\n            minheap.pop();\\n            int xval = temp->x;\\n            int yval = temp->y;\\n            // now push the point into the ans\\n            vector<int> temp2 ;\\n            temp2.push_back(xval);\\n            temp2.push_back(yval);\\n            ans.push_back(temp2);\\n            k--;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852739,
                "title": "clean-code-priority-queue-c-faster-than-100",
                "content": "# Intuition\\nUse of priority_queue<pair<int, pair<int,int>>>pq;\\n\\n# Complexity\\n- Time complexity: O(N+K)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(K)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<vector<int>>ans;\\n        vector<int>v;\\n        priority_queue<pair<int, pair<int,int>>>pq;\\n\\n        for(int i = 0; i<points.size(); i++)\\n        {\\n            pair<int, int>p;\\n            p.first = points[i][0];\\n            p.second = points[i][1];\\n            int sq = ((points[i][0] *points[i][0]) +  (points[i][1]*points[i][1]));\\n            pair<int, pair<int, int>>ppp;\\n            ppp.first = sq;\\n            ppp.second = p;\\n            pq.push(ppp);\\n            if(pq.size()>k)\\n            {\\n                pq.pop();\\n            }\\n        }\\n        while(pq.size()>0)\\n        {\\n            v.push_back(pq.top().second.first);\\n            v.push_back(pq.top().second.second);\\n            ans.push_back(v);\\n            v.clear();\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![c0504eaf-5fb8-4a1d-a769-833262d1b86e_1674433591.3836212.webp](https://assets.leetcode.com/users/images/d48de993-7725-4ff3-b62d-a578253d5673_1690973800.3004334.webp)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<vector<int>>ans;\\n        vector<int>v;\\n        priority_queue<pair<int, pair<int,int>>>pq;\\n\\n        for(int i = 0; i<points.size(); i++)\\n        {\\n            pair<int, int>p;\\n            p.first = points[i][0];\\n            p.second = points[i][1];\\n            int sq = ((points[i][0] *points[i][0]) +  (points[i][1]*points[i][1]));\\n            pair<int, pair<int, int>>ppp;\\n            ppp.first = sq;\\n            ppp.second = p;\\n            pq.push(ppp);\\n            if(pq.size()>k)\\n            {\\n                pq.pop();\\n            }\\n        }\\n        while(pq.size()>0)\\n        {\\n            v.push_back(pq.top().second.first);\\n            v.push_back(pq.top().second.second);\\n            ans.push_back(v);\\n            v.clear();\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3246014,
                "title": "python-code-beats-82",
                "content": "# Code\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n\\n        distances = []\\n        res = []\\n\\n        for i in range(len(points)):\\n            distance =  math.sqrt( ( points[i][0] ) **2 + ( points[i][1] ) **2  )\\n            distances.append([distance,points[i]])\\n        \\n        distances.sort()\\n            \\n        \\n        for i in range(k):\\n            res.append(distances[i][1])\\n\\n        \\n        return res\\n\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n\\n        distances = []\\n        res = []\\n\\n        for i in range(len(points)):\\n            distance =  math.sqrt( ( points[i][0] ) **2 + ( points[i][1] ) **2  )\\n            distances.append([distance,points[i]])\\n        \\n        distances.sort()\\n            \\n        \\n        for i in range(k):\\n            res.append(distances[i][1])\\n\\n        \\n        return res\\n\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200738,
                "title": "c-solution-with-comments-using-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& arr, int k) {\\n        // to store distance with index in sorted order\\n        priority_queue<pair<double,int>> temp;\\n        \\n        for(int i=0;i<arr.size();i++){\\n            temp.push({ sqrt(pow(arr[i][0],2)+pow(arr[i][1],2)) , i});\\n            \\n            // if any point\\'s distance is greater than k smallest\\n            // distances, remove it from priority_queue\\n            if(temp.size()>k) temp.pop();\\n        }\\n        \\n        vector<vector<int>> ans;\\n\\n        while(!temp.empty()) {\\n            ans.push_back(arr[temp.top().second]);\\n            temp.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& arr, int k) {\\n        // to store distance with index in sorted order\\n        priority_queue<pair<double,int>> temp;\\n        \\n        for(int i=0;i<arr.size();i++){\\n            temp.push({ sqrt(pow(arr[i][0],2)+pow(arr[i][1],2)) , i});\\n            \\n            // if any point\\'s distance is greater than k smallest\\n            // distances, remove it from priority_queue\\n            if(temp.size()>k) temp.pop();\\n        }\\n        \\n        vector<vector<int>> ans;\\n\\n        while(!temp.empty()) {\\n            ans.push_back(arr[temp.top().second]);\\n            temp.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3101063,
                "title": "beats-99-90-quickselect-using-hoare-partition-scheme-o-n-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis kind of Kth problem can be solved using quickselect. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is adapted from the quicksort algorithm utilizing the Hoare partition scheme, as outlined in the reputable source, \"Introduction to Algorithms\" written by Thomas H. Cormen, Charles E. Leiserson, and Ronald L. Rivest, specifically in chapter 8, entitled \"Quicksort\".\\n\\nThe key to solving this problem is the Hoare partition scheme (as implemented in the code\\'s partition method). If you are unfamiliar with it, consider reading about it in the book or other online resources.\\n\\nIn simple words, the partition(arr, l, r) method divides the array from indices l to r into two partitions: [l, j] containing elements less than or equal to the pivot, and [j + 1, r] containing elements greater than or equal to the pivot.\\n\\n# Complexity\\n- Time complexity: \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nRuntime: 3 ms (Beats 99.90%). \\n\\nAverage: O(n).\\n![image.png](https://assets.leetcode.com/users/images/7504f19f-d98d-475d-a098-2c1d21fb1d9b_1674944489.971776.png)\\n\\nWorst (it is highly unlikely to occur for a large array when using a random pivot): O(n^2).  \\n![image.png](https://assets.leetcode.com/users/images/964bc6b6-d881-4a10-b004-24d4ab9fcc43_1674723156.3340437.png)\\n\\nAccording to [another online source](https://cs.stackexchange.com/questions/35994/why-does-randomized-quicksort-have-on-log-n-worst-case-runtime-cost). \\n\"Randomized quicksort has a worst-case EXPECTED running time of O(nlogn). But the worst-case may still be O(n^2) time.\\n\\nChoosing the pivot randomly or randomly shuffling the array prior to sorting has the effect of rendering the worst-case very unlikely, particularly for large arrays.\\n\\nThe probability that quicksort will use a quadratic number of compares when sorting a large array on your computer is much less than the probability that your computer will be struck by lightning.\"\\n\\n- Space complexity: \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nMemory: 50.2 MB (Beats 97.75%).\\n\\nO(1). \\n\\n\\n# Code\\n```\\nclass Solution {\\n    private final Random rand = new Random();\\n\\n    public int[][] kClosest(int[][] points, int k) {\\n        quickselect(points, 0, points.length - 1, k - 1);\\n        return Arrays.copyOf(points, k);\\n    }\\n\\n    private void quickselect(int[][] points, int l, int r, int k) {\\n        while (l < r) {\\n            int p = partition(points, l, r);\\n\\n            if (p == k) return;\\n            else if (p > k) r = p;\\n            else l = p + 1;\\n        }\\n    }\\n\\n    private int partition(int[][] points, int l, int r) {\\n        int pivot = getDist( points[ l + rand.nextInt(r - l + 1) ] );\\n        int i = l - 1, j = r + 1;\\n\\n        while (true) {\\n            while (getDist(points[--j]) > pivot);\\n            while (getDist(points[++i]) < pivot);\\n\\n            if (i >= j) return j;\\n\\n            swap(points, i, j);\\n        }\\n    }\\n\\n    private void swap(int[][] points, int i, int j) {\\n        int[] temp = points[i];\\n        points[i] = points[j];\\n        points[j] = temp;\\n    }\\n\\n    private int getDist(int[] p) {\\n        return p[0] * p[0] + p[1] * p[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Quickselect"
                ],
                "code": "```\\nclass Solution {\\n    private final Random rand = new Random();\\n\\n    public int[][] kClosest(int[][] points, int k) {\\n        quickselect(points, 0, points.length - 1, k - 1);\\n        return Arrays.copyOf(points, k);\\n    }\\n\\n    private void quickselect(int[][] points, int l, int r, int k) {\\n        while (l < r) {\\n            int p = partition(points, l, r);\\n\\n            if (p == k) return;\\n            else if (p > k) r = p;\\n            else l = p + 1;\\n        }\\n    }\\n\\n    private int partition(int[][] points, int l, int r) {\\n        int pivot = getDist( points[ l + rand.nextInt(r - l + 1) ] );\\n        int i = l - 1, j = r + 1;\\n\\n        while (true) {\\n            while (getDist(points[--j]) > pivot);\\n            while (getDist(points[++i]) < pivot);\\n\\n            if (i >= j) return j;\\n\\n            swap(points, i, j);\\n        }\\n    }\\n\\n    private void swap(int[][] points, int i, int j) {\\n        int[] temp = points[i];\\n        points[i] = points[j];\\n        points[j] = temp;\\n    }\\n\\n    private int getDist(int[] p) {\\n        return p[0] * p[0] + p[1] * p[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3007186,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        l=[]\\n        heapq.heapify(l)\\n        for i in points:\\n            distance=math.sqrt(i[0]*i[0]+i[1]*i[1])\\n            heapq.heappush(l,[distance,i[0],i[1]])\\n        result=[]\\n        for i in range(k):\\n            dis,x1,y1=heapq.heappop(l)\\n            result.append([x1,y1])\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        l=[]\\n        heapq.heapify(l)\\n        for i in points:\\n            distance=math.sqrt(i[0]*i[0]+i[1]*i[1])\\n            heapq.heappush(l,[distance,i[0],i[1]])\\n        result=[]\\n        for i in range(k):\\n            dis,x1,y1=heapq.heappop(l)\\n            result.append([x1,y1])\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593635,
                "title": "why-do-complications-when-its-simpler-than-you-think-hashmap-sol",
                "content": "```cpp\\nclass Solution {\\nprivate:\\n    double dist(const vector<int> &arr) {\\n        int sq = arr[0]*arr[0] + arr[1]*arr[1];\\n        return sqrt(sq);\\n    }\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>> &points, int k) {\\n        int n = points.size();\\n        if (k == n) return points;\\n        vector<vector<int>> res;\\n        map<double, vector<int>> mp;\\n        // O(n * log(n)) time\\n        for (int i = 0; i < n; i++) {\\n            double d = dist(points[i]);\\n            mp[d].push_back(i);\\n        }\\n        // O(k) time\\n        for (auto it = mp.begin(); it != mp.end(); it++) {\\n            vector<int> vec = it->second;\\n            for (int &x : vec) {\\n                res.push_back(points[x]);\\n                if (k == res.size()) return res;\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```\\n\\nTime Complexity : **O(n * log(n)) + O(k)**\\nSpace Complexity : **O(n) + O(k)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\nprivate:\\n    double dist(const vector<int> &arr) {\\n        int sq = arr[0]*arr[0] + arr[1]*arr[1];\\n        return sqrt(sq);\\n    }\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>> &points, int k) {\\n        int n = points.size();\\n        if (k == n) return points;\\n        vector<vector<int>> res;\\n        map<double, vector<int>> mp;\\n        // O(n * log(n)) time\\n        for (int i = 0; i < n; i++) {\\n            double d = dist(points[i]);\\n            mp[d].push_back(i);\\n        }\\n        // O(k) time\\n        for (auto it = mp.begin(); it != mp.end(); it++) {\\n            vector<int> vec = it->second;\\n            for (int &x : vec) {\\n                res.push_back(points[x]);\\n                if (k == res.size()) return res;\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2566908,
                "title": "python3-1-liner",
                "content": "Upvote if you like it :)\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return [points[i] for d, i in sorted([(math.sqrt(x**2 + y**2), i) for i, [x, y] in enumerate(points)])[:k]]",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "Upvote if you like it :)\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return [points[i] for d, i in sorted([(math.sqrt(x**2 + y**2), i) for i, [x, y] in enumerate(points)])[:k]]",
                "codeTag": "Java"
            },
            {
                "id": 2535780,
                "title": "best-soln-brute-force-to-optimised",
                "content": "# Brute Force : O(N log N) + O(K)\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        ans=[]\\n        temp=[]\\n        for x,y in points:\\n            dist= x**2 + y**2\\n            temp.append([dist,[x,y]])\\n        #print(temp)                                        [[10, [1, 3]], [8, [-2, 2]]]\\n        temp.sort()\\n        #print(temp)                                        [[8, [-2, 2]], [10, [1, 3]]]\\n        for i in range(k):\\n            ans.append(temp[i][1])\\n        return ans\\n```\\n \\n# Optimised : O(K log N) \\n```\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        minheap=[]  \\n        for x,y in points:\\n            dist= x**2 + y**2\\n            minheap.append([dist,[x,y]])     \\n        # print(minheap)                      [[10, 1, 3], [8, -2, 2]]\\n       \\n        heapq.heapify(minheap)\\n        # print(minheap)                      [[8, -2, 2], [10, 1, 3]]\\n        \\n        ans=[]\\n        while k:\\n            dist,points=heapq.heappop(minheap)\\n            ans.append(points)\\n            k-=1\\n        return ans\\n```\\n\\n# Do Upvote If you Liked The Solution .\\uD83D\\uDC4D\\u2705",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        ans=[]\\n        temp=[]\\n        for x,y in points:\\n            dist= x**2 + y**2\\n            temp.append([dist,[x,y]])\\n        #print(temp)                                        [[10, [1, 3]], [8, [-2, 2]]]\\n        temp.sort()\\n        #print(temp)                                        [[8, [-2, 2]], [10, [1, 3]]]\\n        for i in range(k):\\n            ans.append(temp[i][1])\\n        return ans\\n```\n```\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        minheap=[]  \\n        for x,y in points:\\n            dist= x**2 + y**2\\n            minheap.append([dist,[x,y]])     \\n        # print(minheap)                      [[10, 1, 3], [8, -2, 2]]\\n       \\n        heapq.heapify(minheap)\\n        # print(minheap)                      [[8, -2, 2], [10, 1, 3]]\\n        \\n        ans=[]\\n        while k:\\n            dist,points=heapq.heappop(minheap)\\n            ans.append(points)\\n            k-=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2446353,
                "title": "java-min-heap-by-getting-the-first-k-elements",
                "content": "This version is quite fast and beats my original implementation based on a Max-Heap. Instead of pruning the queue for the minimum elements, I simply add the smallest elements to the head of the queue and add the first K elements of the queue into my final array. Any thoughts? I\\'m open to opposing thoughts as I\\'m not sure why one would use a Max-Heap over a natural ordering.\\n\\n    public int[][] kClosest(int[][] points, int k) {\\n\\t\\n        PriorityQueue<int[]> maxHeap = new PriorityQueue<int[]>((a,b) -> (a[0]*a[0] + a[1]*a[1]) - (b[0]*b[0]+b[1]*b[1]));\\n        int[][] ans = new int[k][2];        \\n        \\n        for(int i = 0; i < points.length; i++){\\n            maxHeap.offer(points[i]);\\n        }\\n        \\n         for(int i = 0; i < k; i++){\\n            ans[i] = maxHeap.poll();\\n         }\\n        \\n        return ans;\\n        \\n    }\\n\\t\\n\\n",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "This version is quite fast and beats my original implementation based on a Max-Heap. Instead of pruning the queue for the minimum elements, I simply add the smallest elements to the head of the queue and add the first K elements of the queue into my final array. Any thoughts? I\\'m open to opposing thoughts as I\\'m not sure why one would use a Max-Heap over a natural ordering.\\n\\n    public int[][] kClosest(int[][] points, int k) {\\n\\t\\n        PriorityQueue<int[]> maxHeap = new PriorityQueue<int[]>((a,b) -> (a[0]*a[0] + a[1]*a[1]) - (b[0]*b[0]+b[1]*b[1]));\\n        int[][] ans = new int[k][2];        \\n        \\n        for(int i = 0; i < points.length; i++){\\n            maxHeap.offer(points[i]);\\n        }\\n        \\n         for(int i = 0; i < k; i++){\\n            ans[i] = maxHeap.poll();\\n         }\\n        \\n        return ans;\\n        \\n    }\\n\\t\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2272538,
                "title": "easy-c-sol-naive-efficient-approaches-time-o-nlogn",
                "content": "```\\n// Naive Solution :: Time : O(N) + O(NlogN) :: Aux_Space : O(N)\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n\\n        int n = points.size();\\n\\n        vector<pair<int,pair<int,int>>> v;\\n\\n        for(auto it : points){\\n\\n            int d = it[0] * it[0] + it[1]*it[1];\\n\\n            v.push_back({d,{it[0],it[1]}});\\n\\n        }\\n\\n        sort(v.begin(),v.end());\\n\\n        vector<vector<int>> res(k);\\n\\n        for(int i=0;i<k;i++){\\n\\n            res[i].push_back(v[i].second.first);\\n            res[i].push_back(v[i].second.second);\\n\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n// Approach 2 Using Heap :: Time : O(NlogK) :: Aux_Space : O(K)\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n\\n        int n = points.size();\\n\\n        vector<vector<int>> res(k);\\n\\n        priority_queue<vector<int>> pq;\\n\\n        for(auto p : points){\\n\\n            int x = p[0], y = p[1];\\n\\n            pq.push({x*x + y*y,x,y});\\n\\n            if(pq.size() > k){\\n                pq.pop();\\n            }\\n        }\\n\\n        int i=0;\\n\\n        while(!pq.empty()){\\n\\n            vector<int> v = pq.top();\\n            pq.pop();\\n\\n            res[i] = {v[1],v[2]};\\n            i++;\\n\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n// Approach 3 Using Multi-Map :: Time : O(NlogN) :: Aux_Space : O(N)\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n\\n        int n = points.size();\\n\\n        multimap<int,int> mp;\\n\\n        vector<vector<int>> res;\\n\\n        for(int i=0;i<n;i++){\\n\\n            int x = points[i][0], y = points[i][1];\\n\\n            mp.insert({x*x + y*y, i});\\n\\n        }\\n\\n        int cnt = 0;\\n\\n        for(auto it = mp.begin();cnt<k;cnt++,it++){\\n\\n            res.push_back(points[it->second]);\\n\\n        }\\n\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n\\n        int n = points.size();\\n\\n        vector<pair<int,pair<int,int>>> v;\\n\\n        for(auto it : points){\\n\\n            int d = it[0] * it[0] + it[1]*it[1];\\n\\n            v.push_back({d,{it[0],it[1]}",
                "codeTag": "Java"
            },
            {
                "id": 2243579,
                "title": "java-solution-using-treemap",
                "content": "Add distances to treemap, the keys are sorted in increasing order.\\n\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n          \\n        Map<Double, List<int[]>> map = new TreeMap<>();\\n\\n        for (int[] point : points) {\\n            int x2 = point[0];\\n            int y2 = point[1];\\n\\n            double distance = Math.sqrt(Math.pow((x2), 2) + Math.pow((y2), 2));\\n\\n            if (map.containsKey(distance))\\n                map.get(distance).add(point);\\n            else {\\n                ArrayList<int[]> list = new ArrayList<>();\\n                list.add(point);\\n                map.put(distance, list);\\n            }\\n        }\\n\\n        int[][] answer = new int[k][];\\n        int i = 0;\\n        for (Map.Entry<Double, List<int[]>> entry : map.entrySet()) {\\n            for (int[] values : entry.getValue()) {\\n                answer[i++] = values;\\n                if (i == k)\\n                    return answer;\\n            }\\n        }\\n\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n          \\n        Map<Double, List<int[]>> map = new TreeMap<>();\\n\\n        for (int[] point : points) {\\n            int x2 = point[0];\\n            int y2 = point[1];\\n\\n            double distance = Math.sqrt(Math.pow((x2), 2) + Math.pow((y2), 2));\\n\\n            if (map.containsKey(distance))\\n                map.get(distance).add(point);\\n            else {\\n                ArrayList<int[]> list = new ArrayList<>();\\n                list.add(point);\\n                map.put(distance, list);\\n            }\\n        }\\n\\n        int[][] answer = new int[k][];\\n        int i = 0;\\n        for (Map.Entry<Double, List<int[]>> entry : map.entrySet()) {\\n            for (int[] values : entry.getValue()) {\\n                answer[i++] = values;\\n                if (i == k)\\n                    return answer;\\n            }\\n        }\\n\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2070390,
                "title": "python-quick-select-clean-solution-with-comments",
                "content": "My code is based on the implementation of NeetCode in this [video](https://www.youtube.com/watch?v=XEmy13g1Qxc)\\nIf you are not familiar with the quick select algorithm, I highly recommend that you\\'ll watch it before proceeding to my solution\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:        \\n        def calc_distance(point):\\n            return point[0]**2 + point[1]**2\\n        \\n        def quickselect(l, r):   \\n            # pick pivot at random, swap it to the right (random pivot improves performance substantially)\\n            rand_index = random.randrange(l, r+1)\\n            points[rand_index], points[r] = points[r], points[rand_index]\\n            \\n            # initalize pivot and p\\n            pivot_distance = calc_distance(points[r])\\n            p = l\\n            \\n            # iterate points in the range [l, r] (non inclusive of r)\\n            for i in range(l, r):\\n                # if current point dist <= pivot distance\\n                if calc_distance(points[i]) <= pivot_distance:\\n                    # swap point with current p location\\n                    points[p], points[i] = points[i], points[p]\\n                    p += 1\\n            \\n            # swap our pivot which located in r, to its correct position\\n            points[p], points[r] = points[r], points[p]\\n            \\n            # we want to return closest K points, which means that our p should actually be equal to index of k-1\\n            if p > k-1: return quickselect(l, p - 1)\\n            elif p < k-1: return quickselect(p+1, r)\\n            \\n            # now we return the first k elements\\n            return points[:k]\\n        \\n        return quickselect(0, len(points) - 1)     \\n                \\n        \\n \\n```",
                "solutionTags": [
                    "Python",
                    "Quickselect"
                ],
                "code": "```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:        \\n        def calc_distance(point):\\n            return point[0]**2 + point[1]**2\\n        \\n        def quickselect(l, r):   \\n            # pick pivot at random, swap it to the right (random pivot improves performance substantially)\\n            rand_index = random.randrange(l, r+1)\\n            points[rand_index], points[r] = points[r], points[rand_index]\\n            \\n            # initalize pivot and p\\n            pivot_distance = calc_distance(points[r])\\n            p = l\\n            \\n            # iterate points in the range [l, r] (non inclusive of r)\\n            for i in range(l, r):\\n                # if current point dist <= pivot distance\\n                if calc_distance(points[i]) <= pivot_distance:\\n                    # swap point with current p location\\n                    points[p], points[i] = points[i], points[p]\\n                    p += 1\\n            \\n            # swap our pivot which located in r, to its correct position\\n            points[p], points[r] = points[r], points[p]\\n            \\n            # we want to return closest K points, which means that our p should actually be equal to index of k-1\\n            if p > k-1: return quickselect(l, p - 1)\\n            elif p < k-1: return quickselect(p+1, r)\\n            \\n            # now we return the first k elements\\n            return points[:k]\\n        \\n        return quickselect(0, len(points) - 1)     \\n                \\n        \\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1961268,
                "title": "go-heap-clear-solution",
                "content": "```\\nfunc distance(point []int) int { return point[0]*point[0]+point[1]*point[1] }\\n\\ntype MaxHeap [][]int\\n\\nfunc (h MaxHeap) Len() int              { return len(h) }\\nfunc (h MaxHeap) Less(i, j int) bool    { return distance(h[i]) > distance(h[j]) }\\nfunc (h MaxHeap) Swap(i, j int)         { h[i], h[j] = h[j], h[i] }\\nfunc (h *MaxHeap) Push(x interface{})   { *h = append(*h, x.([]int)) }\\nfunc (h *MaxHeap) Pop() interface{} {\\n    res := (*h)[len(*h)-1]\\n    *h = (*h)[:len(*h)-1]\\n\\treturn res\\n}\\n\\nfunc kClosest(points [][]int, k int) [][]int {\\n    max := MaxHeap{}\\n    for _, point := range points {\\n        heap.Push(&max, point)\\n        if len(max) > k { heap.Pop(&max) }\\n    }\\n    return max\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfunc distance(point []int) int { return point[0]*point[0]+point[1]*point[1] }\\n\\ntype MaxHeap [][]int\\n\\nfunc (h MaxHeap) Len() int              { return len(h) }\\nfunc (h MaxHeap) Less(i, j int) bool    { return distance(h[i]) > distance(h[j]) }\\nfunc (h MaxHeap) Swap(i, j int)         { h[i], h[j] = h[j], h[i] }\\nfunc (h *MaxHeap) Push(x interface{})   { *h = append(*h, x.([]int)) }\\nfunc (h *MaxHeap) Pop() interface{} {\\n    res := (*h)[len(*h)-1]\\n    *h = (*h)[:len(*h)-1]\\n\\treturn res\\n}\\n\\nfunc kClosest(points [][]int, k int) [][]int {\\n    max := MaxHeap{}\\n    for _, point := range points {\\n        heap.Push(&max, point)\\n        if len(max) > k { heap.Pop(&max) }\\n    }\\n    return max\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1649051,
                "title": "2-different-python-solutions-with-min-max-heap",
                "content": "**Short solution using min-heap**\\n\\nThe idea is simple. We construct a min heap and pop the first k nearest points based on euclidean distance.\\n\\nTime complexity: `O(nlogn)` since we\\'re pushing `n` elements consecutively into a heap \\nSpace complexity: `O(n)` to store `n` elements \\n\\n```\\ndef kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        origin = [0, 0]\\n        distances = []\\n        for i, p in enumerate(points):\\n            dist = math.sqrt((p[0] - origin[0]) ** 2 + (p[1] - origin[1]) ** 2)\\n            heapq.heappush(distances, (dist, p))\\n        \\n        return map(lambda x: x[1], heapq.nsmallest(k, distances))\\n```\\n\\t\\t\\n**Better solution using max-heap**\\n\\nInstead of needing to store `n` elements in the heap, we notice that if we first push `k` elements into a max-heap first, the top most element will be the current point furthest from the origin. Thus, we can then iterate down the rest of the `points` array and if any point is closer than the top most element of the heap, we will replace the two points.\\n\\nThe resulting heap then contains `k` closest points to the origin\\n\\nTime complexity: `O(nlogk)` since the depth of the tree is at most `log(k)`\\nSpace complexity: `O(k)` as we only need to store `k` elements\\n\\n```\\n    # Solution utilizing max heap instead of min heap to reduce\\n    # time complexity from O(nlogn) to O(nlogk)\\n    # and space complexity from O(n) to O(k)\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        origin = [0, 0]\\n        distances = []\\n        \\n        # First push the first k items\\n        for i in range(k):\\n            p = points[i]\\n            dist = -math.sqrt((p[0] - origin[0]) ** 2 + (p[1] - origin[1]) ** 2)\\n            heapq.heappush(distances, (dist, p))\\n                 \\n        # If the next point is closer than the current farthest point,\\n        #   we replace the top element of the heap\\n        for i in range(k, len(points)):\\n            p = points[i]\\n            dist = -math.sqrt((p[0] - origin[0]) ** 2 + (p[1] - origin[1]) ** 2)\\n            if dist > distances[0][0]:\\n                heapq.heappop(distances)\\n                heapq.heappush(distances, (dist, p))\\n        \\n        return map(lambda x: x[1], distances)\\n```\\n\\n**With heapify**\\n```\\nclass Solution:\\n    \\n    # Solution utilizing max heap instead of min heap to reduce\\n    # time complexity from O(nlogn) to O(nlogk)\\n    # and space complexity from O(n) to O(k)\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        origin = [0, 0]\\n        distances = []\\n        \\n        # First push the first k items\\n        for i in range(k):\\n            p = points[i]\\n            dist = -math.sqrt((p[0] - origin[0]) ** 2 + (p[1] - origin[1]) ** 2)\\n            distances.append((dist, p))\\n        \\n        # We can also use heapify, which takes O(2k) instead of O(klogk) to construct the initial heap\\n        heapq.heapify(distances)\\n        \\n        # If the next point is closer than the current farthest point,\\n        #   we replace the top element of the heap\\n        for i in range(k, len(points)):\\n            p = points[i]\\n            dist = -math.sqrt((p[0] - origin[0]) ** 2 + (p[1] - origin[1]) ** 2)\\n            if dist > distances[0][0]:\\n                heapq.heappop(distances)\\n                heapq.heappush(distances, (dist, p))\\n        \\n        return map(lambda x: x[1], distances)\\n```\\nPlease upvote if this was helpful :)",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        origin = [0, 0]\\n        distances = []\\n        for i, p in enumerate(points):\\n            dist = math.sqrt((p[0] - origin[0]) ** 2 + (p[1] - origin[1]) ** 2)\\n            heapq.heappush(distances, (dist, p))\\n        \\n        return map(lambda x: x[1], heapq.nsmallest(k, distances))\\n```\n```\\n    # Solution utilizing max heap instead of min heap to reduce\\n    # time complexity from O(nlogn) to O(nlogk)\\n    # and space complexity from O(n) to O(k)\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        origin = [0, 0]\\n        distances = []\\n        \\n        # First push the first k items\\n        for i in range(k):\\n            p = points[i]\\n            dist = -math.sqrt((p[0] - origin[0]) ** 2 + (p[1] - origin[1]) ** 2)\\n            heapq.heappush(distances, (dist, p))\\n                 \\n        # If the next point is closer than the current farthest point,\\n        #   we replace the top element of the heap\\n        for i in range(k, len(points)):\\n            p = points[i]\\n            dist = -math.sqrt((p[0] - origin[0]) ** 2 + (p[1] - origin[1]) ** 2)\\n            if dist > distances[0][0]:\\n                heapq.heappop(distances)\\n                heapq.heappush(distances, (dist, p))\\n        \\n        return map(lambda x: x[1], distances)\\n```\n```\\nclass Solution:\\n    \\n    # Solution utilizing max heap instead of min heap to reduce\\n    # time complexity from O(nlogn) to O(nlogk)\\n    # and space complexity from O(n) to O(k)\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        origin = [0, 0]\\n        distances = []\\n        \\n        # First push the first k items\\n        for i in range(k):\\n            p = points[i]\\n            dist = -math.sqrt((p[0] - origin[0]) ** 2 + (p[1] - origin[1]) ** 2)\\n            distances.append((dist, p))\\n        \\n        # We can also use heapify, which takes O(2k) instead of O(klogk) to construct the initial heap\\n        heapq.heapify(distances)\\n        \\n        # If the next point is closer than the current farthest point,\\n        #   we replace the top element of the heap\\n        for i in range(k, len(points)):\\n            p = points[i]\\n            dist = -math.sqrt((p[0] - origin[0]) ** 2 + (p[1] - origin[1]) ** 2)\\n            if dist > distances[0][0]:\\n                heapq.heappop(distances)\\n                heapq.heappush(distances, (dist, p))\\n        \\n        return map(lambda x: x[1], distances)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1496058,
                "title": "python-5-line-clean-solution",
                "content": "Time Complexity: O(NlogN)\\n```\\n class Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        def compare(pt):\\n            x, y = pt[0], pt[1]\\n            return x ** 2 + y ** 2 \\n        points = sorted(points, key=compare)\\n        return points[:k]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\n class Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        def compare(pt):\\n            x, y = pt[0], pt[1]\\n            return x ** 2 + y ** 2 \\n        points = sorted(points, key=compare)\\n        return points[:k]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1411394,
                "title": "python-1-liner",
                "content": "```\\nreturn sorted(points, key = lambda coor: math.sqrt(math.pow(coor[0],2)+math.pow(coor[1],2)))[:k]\\n```",
                "solutionTags": [],
                "code": "```\\nreturn sorted(points, key = lambda coor: math.sqrt(math.pow(coor[0],2)+math.pow(coor[1],2)))[:k]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1339309,
                "title": "python-one-liner-with-heap-super-easy-barely-an-inconvenience",
                "content": "```\\ndef kClosest(self, points, k):\\n\\treturn heapq.nsmallest(k, points, key=lambda x: x[0] ** 2 + x[1] ** 2)\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef kClosest(self, points, k):\\n\\treturn heapq.nsmallest(k, points, key=lambda x: x[0] ** 2 + x[1] ** 2)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1256189,
                "title": "2-lines-of-code-java-solution",
                "content": "```\\n public int[][] kClosest(int[][] points, int k) {\\n        \\n        Arrays.sort(points,(p1, p2) ->p1[0]*p1[0]+p1[1]*p1[1]-(p2[0]*p2[0]+p2[1]*p2[1]));\\n       \\n        return Arrays.copyOf(points,k);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int[][] kClosest(int[][] points, int k) {\\n        \\n        Arrays.sort(points,(p1, p2) ->p1[0]*p1[0]+p1[1]*p1[1]-(p2[0]*p2[0]+p2[1]*p2[1]));\\n       \\n        return Arrays.copyOf(points,k);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1147308,
                "title": "js-es6-solution-runtime-160-ms-memory-usage-47-1-mb",
                "content": "JS solution using implicit returns / ES6 formatting. Runtime: 160 ms (faster than 93.36% of JavaScript submissions); memory usage: 47.1 MB (less than 97.45% of JavaScript submissions).\\n\\nTime complexity of `sort` is `O(nlogn)`, time complexity of `slice` is `O(n)`, so time complexity for this solution is `O(nlogn)`. \\n\\nBecause we are looking at distances from `(0, 0)`, we can simplify `\\u221A(x1 - x2)**2 + (y1 - y2)**2)` to `\\u221A(x1)**2 + (y1)**2)` to `x1**2 + y1**2`. \\n\\n1. Sort `points` array from smallest distance to largest distance.\\n2. Slice the sorted `points` array to get `k` elements. \\n\\n```\\nconst kClosest = (points, k) => (\\n    points.sort((a, b) => (\\n        (a[0] * a[0] + a[1] * a[1]) - (b[0] * b[0] + b[1] * b[1])\\n    )).slice(0, k)\\n);\\n```\\n\\nThis variation has a slower runtime, but uses array desconstruction and `Math.pow` for an arguably easier-to-read solution:\\n\\n```\\nconst kClosest = (points, k) => (\\n    points.sort(([x1, y1], [x2, y2]) => (\\n        (Math.pow(x1, 2) + Math.pow(y1, 2)) - (Math.pow(x2, 2) + Math.pow(y2, 2))\\n    )).slice(0, k)\\n);\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst kClosest = (points, k) => (\\n    points.sort((a, b) => (\\n        (a[0] * a[0] + a[1] * a[1]) - (b[0] * b[0] + b[1] * b[1])\\n    )).slice(0, k)\\n);\\n```\n```\\nconst kClosest = (points, k) => (\\n    points.sort(([x1, y1], [x2, y2]) => (\\n        (Math.pow(x1, 2) + Math.pow(y1, 2)) - (Math.pow(x2, 2) + Math.pow(y2, 2))\\n    )).slice(0, k)\\n);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1098260,
                "title": "golang-solution-with-explanation-and-images",
                "content": "**Code on The Bottom, If This helps Please Up Vote**\\n\\n**The New Distance Formula:**\\n\\nThe Euclidean Distance Formula equals (I have drawn this in a picture because the symbols don\\'t aline up when writen up in text)\\n\\n![image](https://assets.leetcode.com/users/images/5c63fa2c-9c2a-4c3f-b7f8-03708b8927d1_1615131535.4240034.png)\\n\\n\\nThis can be simplifyed by taking out the square root. We can take out the square root because we are not finding the minimum distance but the point with the minimum distance, and the distance doesn\\'t need to be square rooted. The distance not needing to be square rooted can be shown by doing an experiment, for example let us take the square root of 10 and the square root of 8, we know that the square root of 10 will allways be greater than the square root of 8. We also know that 10 will always be greater than 8. Try this with any two positive numbers. *Note: I said positve numbers because any square number is positive.*\\n\\nSo now our equation for the distance is:\\n\\n![image](https://assets.leetcode.com/users/images/3cd5558c-18dc-4af0-a75b-632193cfd492_1615131556.5738633.png)\\n\\n\\nWe can simplify the equation again by taking out the x2 and the y2 because x2 and y2 will always be `0`. X2 and y2 will always be `0` because the first point is a regular point, but the second point will be `(0, 0)` because the second point will always be the origin. This can by shown by an example:\\n\\n![image](https://assets.leetcode.com/users/images/1fe1f804-189f-42a6-a12c-bceebfc6abc0_1615131571.9960535.png)\\n\\n\\nSo the new distance equation is:\\n\\n![image](https://assets.leetcode.com/users/images/357622dc-0655-4375-b39b-58d8894f54d6_1615131587.1393197.png)\\n\\n\\n****\\n\\n**The Idea Of This Solution:**\\n\\nNow that we know that we know the distance formula for this problem is `x^2 + y^2` we just have to sort the matrix array. \\n\\nThe way we sort the array is we check whether the current distance is smaller than the the previous distance, then if so we switch the two points, then we move back a space, to check whether the previous value is greater than the current value. This can be show by the following example:\\n\\n![image](https://assets.leetcode.com/users/images/69ee2c1b-b4f2-40a1-aa90-4f0c523ff85f_1615131609.5708025.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/9a7190b9-5d5f-4fc0-9a70-c4a0ef0b9baa_1615131625.1433806.png)\\n\\n\\nWe do nothing because `18 < 26`. So we continue:\\n\\n![image](https://assets.leetcode.com/users/images/9317c2ca-416d-4d0b-824a-50dd56ec2af3_1615131644.3956482.png)\\n\\n\\n`26` is greater than `20` so we have to switch them. We also have to subtract `2` from `i`. `i` will only go back by `1` even though we subtract `2` from `i` because the for loop adds `1` to `i`.\\n\\n![image](https://assets.leetcode.com/users/images/758db950-69d1-42a1-b84a-30eb588ae8c1_1615131662.4130182.png)\\n\\n\\n`18` is smaller than `20` so do nothing.\\n\\n![image](https://assets.leetcode.com/users/images/07cb8cda-7942-4242-9153-370ec9e28f83_1615131694.5103717.png)\\n\\n\\n`20` is smaller than `26` so do nothing again.\\n\\n![image](https://assets.leetcode.com/users/images/5319fe29-8ca8-41a3-8c06-f60d10e3336b_1615131709.9442105.png)\\n\\n\\n`26` is smaller than `130` so we do nothing again. Since `i` is at the end `points` is `[[3, 3], [-2, 4], [5, -1], [7, 9]]`.\\n\\n****\\n\\n```  go\\nfunc kClosest(points [][]int, k int) [][]int {\\n    for i := 1; i < len(points); i++ {\\n        if i >= 1 {\\n            distanceOfIMinusOne := square(points[i-1][0]) + square(points[i-1][1])\\n            distanceOfI := square(points[i][0]) + square(points[i][1])\\n            if distanceOfIMinusOne > distanceOfI {\\n                points[i-1], points[i] = points[i], points[i-1]\\n                i -= 2\\n            }\\n        }\\n    }\\n    return points[:k]\\n}\\n\\nfunc square(n int) int {\\n    return n * n\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```  go\\nfunc kClosest(points [][]int, k int) [][]int {\\n    for i := 1; i < len(points); i++ {\\n        if i >= 1 {\\n            distanceOfIMinusOne := square(points[i-1][0]) + square(points[i-1][1])\\n            distanceOfI := square(points[i][0]) + square(points[i][1])\\n            if distanceOfIMinusOne > distanceOfI {\\n                points[i-1], points[i] = points[i], points[i-1]\\n                i -= 2\\n            }\\n        }\\n    }\\n    return points[:k]\\n}\\n\\nfunc square(n int) int {\\n    return n * n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1065685,
                "title": "java-maxheap-solution",
                "content": "Time complexity: O(NlogK)\\nSpace complexity: O(K) we need to store \\u2018K\\u2019 points in the heap\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n        \\n        PriorityQueue<int[]> maxHeap = new PriorityQueue<>((a,b)->( (b[0]*b[0]+b[1]*b[1]) - (a[0]*a[0]+a[1]*a[1])));\\n        //Store first K points in the maxHeap\\n        for(int i = 0; i < K; i++){\\n            maxHeap.add(points[i]);\\n        }\\n        //for the rest of the points in input array, compare each point with the max value in maxHeap, if points[i] distance is smaller than maxHeap.peek() distance, remove the max point in maxHeap and add the points[i] in maxHeap.\\n\\t\\t\\n        for(int i = K; i < points.length; i++){\\n            int pDist = points[i][0]*points[i][0] + points[i][1]*points[i][1];\\n            int[] maxPoint = maxHeap.peek();\\n            int maxDist = maxPoint[0]*maxPoint[0] + maxPoint[1]*maxPoint[1];\\n            if(pDist < maxDist){\\n                maxHeap.poll();\\n                maxHeap.add(points[i]);\\n            }\\n        }\\n     \\n         int[][] res = new int[K][2];\\n            \\n         for(int i = 0; i < K; i++){\\n             res[i] = maxHeap.remove();\\n         }\\n        \\n        return res;\\n          \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n        \\n        PriorityQueue<int[]> maxHeap = new PriorityQueue<>((a,b)->( (b[0]*b[0]+b[1]*b[1]) - (a[0]*a[0]+a[1]*a[1])));\\n        //Store first K points in the maxHeap\\n        for(int i = 0; i < K; i++){\\n            maxHeap.add(points[i]);\\n        }\\n        //for the rest of the points in input array, compare each point with the max value in maxHeap, if points[i] distance is smaller than maxHeap.peek() distance, remove the max point in maxHeap and add the points[i] in maxHeap.\\n\\t\\t\\n        for(int i = K; i < points.length; i++){\\n            int pDist = points[i][0]*points[i][0] + points[i][1]*points[i][1];\\n            int[] maxPoint = maxHeap.peek();\\n            int maxDist = maxPoint[0]*maxPoint[0] + maxPoint[1]*maxPoint[1];\\n            if(pDist < maxDist){\\n                maxHeap.poll();\\n                maxHeap.add(points[i]);\\n            }\\n        }\\n     \\n         int[][] res = new int[K][2];\\n            \\n         for(int i = 0; i < K; i++){\\n             res[i] = maxHeap.remove();\\n         }\\n        \\n        return res;\\n          \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934685,
                "title": "easy-o-klogn-n-solution-better-than-o-nlogk",
                "content": "```\\ndef kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n\\tdist = lambda p: p[0]**2 + p[1]**2\\n\\n\\tdist_list = [ (dist(p), p) for p in points]\\n\\theapq.heapify(dist_list)\\n\\n\\treturn [heapq.heappop(dist_list)[1] for _ in range(K)\\n```\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n\\tdist = lambda p: p[0]**2 + p[1]**2\\n\\n\\tdist_list = [ (dist(p), p) for p in points]\\n\\theapq.heapify(dist_list)\\n\\n\\treturn [heapq.heappop(dist_list)[1] for _ in range(K)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 764117,
                "title": "one-line-js",
                "content": "```\\nvar kClosest = function(points, K) {\\n    return points.sort((a, b) => (a[1] * a[1] + a[0] * a[0]) - (b[1] * b[1] + b[0] * b[0])).slice(0, K)\\n};",
                "solutionTags": [],
                "code": "```\\nvar kClosest = function(points, K) {\\n    return points.sort((a, b) => (a[1] * a[1] + a[0] * a[0]) - (b[1] * b[1] + b[0] * b[0])).slice(0, K)\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 723446,
                "title": "c-one-liner-with-comments",
                "content": "Very simple one liner, explaination:\\n1. OrderBy(x => ((x[0] * x[0]) + (x[1] * x[1]))):\\n* A simple formula ot get an approximation of the distance is Square root of: X^2 + Y^2, for this example we don\\'t need the square root, just the result do the sum of the squares, these ones will result in a distance, like this:\\n* (2, -2) => 2 * 2 + -2 * -2 => 4 * 4 => 8\\n* This result will be used by the lambda function to sort the array, the result is the original array as an ISortedEnumerable. If the further points were required a simple .OrderByDescending will do.\\n2. Take(K)\\n* This will take the requested amount of items out of the list.\\n3. ToArray()\\n* We have an ISortedIEnumerable, we need an array, so we make it an array.\\n\\n```\\npublic class Solution {\\n    public int[][] KClosest(int[][] points, int K) => points.OrderBy(x => ((x[0] * x[0]) + (x[1] * x[1]))).Take(K).ToArray();\\n}\\n```\\n\\nThat\\'s it, this solution was better than 80% in speed and better than 7X% in storage.",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[][] KClosest(int[][] points, int K) => points.OrderBy(x => ((x[0] * x[0]) + (x[1] * x[1]))).Take(K).ToArray();\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 699173,
                "title": "swift-minheap",
                "content": "```\\nclass MinHeap<Point: Comparable> {\\n    var heap: [Point]\\n\\n    init() {\\n        heap = [Point]()\\n    }\\n\\n    func parent(_ i: Int) -> Int { return (i-1)/2 }\\n    func left(_ i: Int) -> Int { return ((2*i)+1) }\\n    func right(_ i: Int) -> Int { return ((2*i)+2) }\\n\\n    func heapify(_ i: Int) {\\n        let n = heap.count\\n        let l = left(i)\\n        let r = right(i)\\n        var smallest = i\\n\\n        // check if left index is within bounds\\n        // check if left child is smaller than the root\\n        if l < n && heap[l] < heap[i] {\\n            smallest = l\\n        }\\n\\n        // check if right index is within bounds\\n        // check if right child is smaller than the root\\n        if r < n && heap[r] < heap[smallest] {\\n            smallest = r\\n        }\\n\\n        // swap the child and the parent only\\n        // if any of the child is smaller\\n        if smallest != i {\\n            heap.swapAt(i, smallest)\\n            heapify(smallest)\\n        }\\n    }\\n\\n    // insert at the end of the list\\n    // and shift up to the root\\n    func insert(item: Point) {\\n        heap.append(item)\\n        var lastIndex = heap.count - 1\\n\\n        while heap[parent(lastIndex)] > item {\\n            heap.swapAt(lastIndex, parent(lastIndex))\\n            lastIndex = parent(lastIndex)\\n        }\\n    }\\n\\n    // swap the first and last item in the list\\n    // and shift down\\n    func extractMin() -> Point? {\\n        if heap.count == 0 {\\n            return nil\\n        }\\n        let root = heap[0]\\n        heap.swapAt(0, heap.count - 1)\\n        heap.removeLast()\\n        heapify(0)\\n        return root\\n    }\\n\\n    func removeItem(at index: Int) {\\n        if heap.isEmpty { return }\\n        heap.swapAt(index, heap.count - 1)\\n        heap.removeLast()\\n        heapify(index)\\n    }\\n    \\n    func peek() -> Point? {\\n        if heap.isEmpty { return nil }\\n        return heap[0]\\n    }\\n    \\n    func kThLargest(_ k: Int) -> Point? {\\n        while heap.count > k {\\n            removeItem(at: 0)\\n        }\\n        return peek()\\n    }\\n}\\n\\nstruct Point {\\n    let x: Int\\n    let y: Int\\n}\\n\\nextension Point: Comparable {\\n    static func < (lhs: Point, rhs: Point) -> Bool {\\n        let x1 = lhs.x * lhs.x;\\n        let y1 = lhs.y * lhs.y;\\n        let x2 = rhs.x * rhs.x;\\n        let y2 = rhs.y * rhs.y;\\n        \\n        return (x1 + y1) < (x2 + y2);\\n    }\\n}\\n\\nclass Solution {\\n    func kClosest(_ points: [[Int]], _ K: Int) -> [[Int]] {\\n\\n        if points.count < K {\\n            return []\\n        }\\n\\n        let minHeap = MinHeap<Point>()\\n\\n        for point in points {\\n            minHeap.insert(item: Point(x: point[0], y: point[1]))\\n        }\\n        var result = [[Int]]()\\n\\n        var i = 0\\n\\n        while i < K {\\n            let n = minHeap.extractMin()!\\n            result.append([n.x,n.y])\\n            i+=1\\n        }\\n    \\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass MinHeap<Point: Comparable> {\\n    var heap: [Point]\\n\\n    init() {\\n        heap = [Point]()\\n    }\\n\\n    func parent(_ i: Int) -> Int { return (i-1)/2 }\\n    func left(_ i: Int) -> Int { return ((2*i)+1) }\\n    func right(_ i: Int) -> Int { return ((2*i)+2) }\\n\\n    func heapify(_ i: Int) {\\n        let n = heap.count\\n        let l = left(i)\\n        let r = right(i)\\n        var smallest = i\\n\\n        // check if left index is within bounds\\n        // check if left child is smaller than the root\\n        if l < n && heap[l] < heap[i] {\\n            smallest = l\\n        }\\n\\n        // check if right index is within bounds\\n        // check if right child is smaller than the root\\n        if r < n && heap[r] < heap[smallest] {\\n            smallest = r\\n        }\\n\\n        // swap the child and the parent only\\n        // if any of the child is smaller\\n        if smallest != i {\\n            heap.swapAt(i, smallest)\\n            heapify(smallest)\\n        }\\n    }\\n\\n    // insert at the end of the list\\n    // and shift up to the root\\n    func insert(item: Point) {\\n        heap.append(item)\\n        var lastIndex = heap.count - 1\\n\\n        while heap[parent(lastIndex)] > item {\\n            heap.swapAt(lastIndex, parent(lastIndex))\\n            lastIndex = parent(lastIndex)\\n        }\\n    }\\n\\n    // swap the first and last item in the list\\n    // and shift down\\n    func extractMin() -> Point? {\\n        if heap.count == 0 {\\n            return nil\\n        }\\n        let root = heap[0]\\n        heap.swapAt(0, heap.count - 1)\\n        heap.removeLast()\\n        heapify(0)\\n        return root\\n    }\\n\\n    func removeItem(at index: Int) {\\n        if heap.isEmpty { return }\\n        heap.swapAt(index, heap.count - 1)\\n        heap.removeLast()\\n        heapify(index)\\n    }\\n    \\n    func peek() -> Point? {\\n        if heap.isEmpty { return nil }\\n        return heap[0]\\n    }\\n    \\n    func kThLargest(_ k: Int) -> Point? {\\n        while heap.count > k {\\n            removeItem(at: 0)\\n        }\\n        return peek()\\n    }\\n}\\n\\nstruct Point {\\n    let x: Int\\n    let y: Int\\n}\\n\\nextension Point: Comparable {\\n    static func < (lhs: Point, rhs: Point) -> Bool {\\n        let x1 = lhs.x * lhs.x;\\n        let y1 = lhs.y * lhs.y;\\n        let x2 = rhs.x * rhs.x;\\n        let y2 = rhs.y * rhs.y;\\n        \\n        return (x1 + y1) < (x2 + y2);\\n    }\\n}\\n\\nclass Solution {\\n    func kClosest(_ points: [[Int]], _ K: Int) -> [[Int]] {\\n\\n        if points.count < K {\\n            return []\\n        }\\n\\n        let minHeap = MinHeap<Point>()\\n\\n        for point in points {\\n            minHeap.insert(item: Point(x: point[0], y: point[1]))\\n        }\\n        var result = [[Int]]()\\n\\n        var i = 0\\n\\n        while i < K {\\n            let n = minHeap.extractMin()!\\n            result.append([n.x,n.y])\\n            i+=1\\n        }\\n    \\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 672813,
                "title": "two-ways-to-solve-the-problem-in-python3-using-heaps-and-sorting",
                "content": "The first method is using heaps\\n```\\nfrom math import sqrt\\nimport heapq\\nclass Solution:\\n    \\n    def distance(self,x1,y1):\\n        return sqrt((x1**2)+(y1**2))\\n    \\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        heap = []\\n        for i in points:\\n            heapq.heappush(heap,(-self.distance(i[0],i[1]),i))\\n            if len(heap)>K:\\n                heapq.heappop(heap)\\n        result = []\\n        for i in heap:\\n            result.append(i[1])\\n        return result\\n```\\n\\nThe second method is to sort the list based on the distance\\n```\\nclass Solution:\\n    \\n    def distance(self,x1,y1):\\n        return sqrt((x1**2)+(y1**2))\\n    \\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        points.sort(key = lambda x:self.distance(x[0],x[1]))\\n        return points[:K]\\n```",
                "solutionTags": [],
                "code": "```\\nfrom math import sqrt\\nimport heapq\\nclass Solution:\\n    \\n    def distance(self,x1,y1):\\n        return sqrt((x1**2)+(y1**2))\\n    \\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        heap = []\\n        for i in points:\\n            heapq.heappush(heap,(-self.distance(i[0],i[1]),i))\\n            if len(heap)>K:\\n                heapq.heappop(heap)\\n        result = []\\n        for i in heap:\\n            result.append(i[1])\\n        return result\\n```\n```\\nclass Solution:\\n    \\n    def distance(self,x1,y1):\\n        return sqrt((x1**2)+(y1**2))\\n    \\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        points.sort(key = lambda x:self.distance(x[0],x[1]))\\n        return points[:K]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 660092,
                "title": "rust-3-idiomatic-solutions-explained-sort-heap-and-quickselect",
                "content": "#### 1. Sorting\\n\\nThis solution is the simplest, but the most expensive with a complexity of `O(n.log(n) + k)`.\\nN.B.: `distance` doesn\\'t need to be the Euclidian distance per-se and use `sqrt`, since the `sqrt` function is monotone and, therefore, wouldn\\'t change the ordering.\\n\\n```rust\\nconst X: usize = 0;\\nconst Y: usize = 1;\\n\\nimpl Solution {\\n    pub fn k_closest(mut points: Vec<Vec<i32>>, k: i32) -> Vec<Vec<i32>> {\\n        let k = k as usize; // Thanks Leetcode -_-\\n        let distance = |p: &Vec<i32>| p[X] * p[X] + p[Y] * p[Y];\\n        points.sort_by(|p1, p2| distance(p1).cmp(&distance(p2)));\\n        points[..k].to_vec()\\n    }\\n}\\n```\\n\\n##### Performance\\n\\n> Runtime: 40 ms, faster than 44.83% of Rust online submissions for K Closest Points to Origin.\\n> Memory Usage: 3 MB, less than 100.00% of Rust online submissions for K Closest Points to Origin.\\n\\n#### 2. Heap\\n\\nAnother approach is to keep adding items to a max heap capped at size `k`, removing the largest item every time the heap is \"full\", and returning the resulting content as a vector. This allows us reduce the complexity to be `O(n.log(k) + k)`.\\n\\nHowever, a `Point` struct and a fair bit of conversions and boilerplate is required to have an idiomatic solution.\\nN.B.: Depending on how idiomatic you want your solution to be, some of that boilerplate can be replaced by explicit conversions.\\n\\n```rust\\nuse std::iter::FromIterator;\\nuse std::cmp::Ordering;\\nuse std::collections::BinaryHeap;\\nuse std::convert::From;\\n\\nimpl Solution {\\n    pub fn k_closest(points: Vec<Vec<i32>>, k: i32) -> Vec<Vec<i32>> {\\n        let k = k as usize; // Thanks Leetcode -_-\\n        let mut heap = BinaryHeap::with_capacity(k + 1);\\n        for point in points.iter() {\\n            heap.push(point.into()); // Enabled by: From<&Vec<i32>> for Point\\n            if heap.len() == k + 1 {\\n                heap.pop(); // Remove the point with largest distance to origin. Enabled by: Ord for Point\\n            } \\n        }\\n        heap.into_sorted_vec().iter().collect::<Vec<Vec<i32>>>() // Enabled by: FromIterator\\n    }\\n}\\n\\n#[derive(Eq, PartialEq)]\\nstruct Point {\\n    x: i32,\\n    y: i32,\\n}\\n\\nimpl Point {\\n    fn distance(&self) -> i32 {\\n        self.x * self.x + self.y * self.y\\n    }    \\n}\\n\\nimpl Ord for Point {\\n    fn cmp(&self, other: &Point) -> Ordering {\\n        self.distance().cmp(&other.distance())\\n    }\\n}\\n\\nimpl PartialOrd for Point {\\n    fn partial_cmp(&self, other: &Point) -> Option<Ordering> {\\n        Some(self.cmp(other))\\n    }\\n}\\n\\nconst X: usize = 0;\\nconst Y: usize = 1;\\n\\nimpl From<&Vec<i32>> for Point {\\n    // Converts from a &Vec<i32> to a Point, which lets us call vec.into() when constructing the heap.\\n    fn from(point: &Vec<i32>) -> Self {\\n        Point{ x: point[X], y: point[Y] }\\n    }\\n}\\n\\nimpl From<&Point> for Vec<i32> {\\n    // Converts from a &Point to a Vec<i32>, which lets us call point.into() when converting from iterator of points into an iterator of Vec<i32>.\\n    fn from(point: &Point) -> Self {\\n        vec![point.x, point.y]\\n    }\\n}\\n\\nimpl<\\'a> FromIterator<&\\'a Point> for Vec<Vec<i32>> {\\n    fn from_iter<I: IntoIterator<Item=&\\'a Point>>(iter: I) -> Self {\\n        let mut points = Vec::new();\\n        for point in iter {\\n            points.push(point.into()); // Enabled by: From<&Point> for Vec<i32>\\n        }\\n        points\\n    }\\n}\\n```\\n\\n##### Performance\\n\\n> Runtime: 36 ms, faster than 82.76% of Rust online submissions for K Closest Points to Origin.\\n> Memory Usage: 3 MB, less than 100.00% of Rust online submissions for K Closest Points to Origin.\\n\\n#### 3. QuickSelect\\n\\nAnother solution is to implement the [QuickSelect](https://en.wikipedia.org/wiki/Quickselect) algorithm, which, in the average case, should give us `O(n + k)`:\\n\\n```rust\\nimpl Solution {\\n    pub fn k_closest(mut points: Vec<Vec<i32>>, k: i32) -> Vec<Vec<i32>> {\\n        let k = k as usize; // Thanks Leetcode -_-\\n        let (mut lo, mut hi) = (0, points.len() - 1);\\n        while lo <= hi {\\n            let pivot = partition(&mut points, lo, hi);\\n            if pivot < k {\\n                lo = pivot + 1;\\n            } else if pivot > k {\\n                hi = pivot - 1;\\n            } else {\\n                break;\\n            }\\n        }\\n        points[..k].to_vec()\\n    }\\n}\\n\\nconst X: usize = 0;\\nconst Y: usize = 1;\\n\\nfn distance(point: &Vec<i32>) -> i32 {\\n    point[X] * point[X] + point[Y] * point[Y]\\n}\\n\\nfn partition(points: &mut Vec<Vec<i32>>, mut lo: usize, mut hi: usize) -> usize {\\n    // Approach: Hoare partitioning.\\n    let pivot = lo;\\n    while lo < hi {\\n        while lo < hi && distance(&points[pivot]) <= distance(&points[hi]) {\\n            hi -= 1;\\n        }\\n        while lo < hi && distance(&points[lo]) <= distance(&points[pivot]) {\\n            lo += 1;\\n        }\\n        points.swap(lo, hi);\\n    }\\n    points.swap(lo, pivot);\\n    lo\\n}\\n```\\n\\nAn alternative partitioning is the following one:\\n```rust\\nfn partition(points: &mut Vec<Vec<i32>>, mut lo: usize, mut hi: usize) -> usize {\\n    // Approach: Lomuto partitioning.\\n    // Partition points so that we end up with:\\n    //   lo            l        r  hi\\n    //   [ point <=, pivot, < point ]\\n    //\\n    // The pivot value can be chosen randomly in [lo, hi],\\n    // but here we just pick points[hi] for convenience.\\n    let mut l = lo;\\n    for r in lo..hi {\\n        if distance(&points[r]) <= distance(&points[hi]) {\\n            points.swap(l, r);\\n            l += 1;\\n        }\\n    }\\n    points.swap(l, hi);\\n    l\\n}\\n```\\n\\n\\n\\n##### Performance\\n\\n> Runtime: 24 ms, faster than 100.00% of Rust online submissions for K Closest Points to Origin.\\n> Memory Usage: 3 MB, less than 100.00% of Rust online submissions for K Closest Points to Origin.",
                "solutionTags": [
                    "Rust",
                    "Sorting",
                    "Heap (Priority Queue)",
                    "Quickselect"
                ],
                "code": "```rust\\nconst X: usize = 0;\\nconst Y: usize = 1;\\n\\nimpl Solution {\\n    pub fn k_closest(mut points: Vec<Vec<i32>>, k: i32) -> Vec<Vec<i32>> {\\n        let k = k as usize; // Thanks Leetcode -_-\\n        let distance = |p: &Vec<i32>| p[X] * p[X] + p[Y] * p[Y];\\n        points.sort_by(|p1, p2| distance(p1).cmp(&distance(p2)));\\n        points[..k].to_vec()\\n    }\\n}\\n```\n```rust\\nuse std::iter::FromIterator;\\nuse std::cmp::Ordering;\\nuse std::collections::BinaryHeap;\\nuse std::convert::From;\\n\\nimpl Solution {\\n    pub fn k_closest(points: Vec<Vec<i32>>, k: i32) -> Vec<Vec<i32>> {\\n        let k = k as usize; // Thanks Leetcode -_-\\n        let mut heap = BinaryHeap::with_capacity(k + 1);\\n        for point in points.iter() {\\n            heap.push(point.into()); // Enabled by: From<&Vec<i32>> for Point\\n            if heap.len() == k + 1 {\\n                heap.pop(); // Remove the point with largest distance to origin. Enabled by: Ord for Point\\n            } \\n        }\\n        heap.into_sorted_vec().iter().collect::<Vec<Vec<i32>>>() // Enabled by: FromIterator\\n    }\\n}\\n\\n#[derive(Eq, PartialEq)]\\nstruct Point {\\n    x: i32,\\n    y: i32,\\n}\\n\\nimpl Point {\\n    fn distance(&self) -> i32 {\\n        self.x * self.x + self.y * self.y\\n    }    \\n}\\n\\nimpl Ord for Point {\\n    fn cmp(&self, other: &Point) -> Ordering {\\n        self.distance().cmp(&other.distance())\\n    }\\n}\\n\\nimpl PartialOrd for Point {\\n    fn partial_cmp(&self, other: &Point) -> Option<Ordering> {\\n        Some(self.cmp(other))\\n    }\\n}\\n\\nconst X: usize = 0;\\nconst Y: usize = 1;\\n\\nimpl From<&Vec<i32>> for Point {\\n    // Converts from a &Vec<i32> to a Point, which lets us call vec.into() when constructing the heap.\\n    fn from(point: &Vec<i32>) -> Self {\\n        Point{ x: point[X], y: point[Y] }\\n    }\\n}\\n\\nimpl From<&Point> for Vec<i32> {\\n    // Converts from a &Point to a Vec<i32>, which lets us call point.into() when converting from iterator of points into an iterator of Vec<i32>.\\n    fn from(point: &Point) -> Self {\\n        vec![point.x, point.y]\\n    }\\n}\\n\\nimpl<\\'a> FromIterator<&\\'a Point> for Vec<Vec<i32>> {\\n    fn from_iter<I: IntoIterator<Item=&\\'a Point>>(iter: I) -> Self {\\n        let mut points = Vec::new();\\n        for point in iter {\\n            points.push(point.into()); // Enabled by: From<&Point> for Vec<i32>\\n        }\\n        points\\n    }\\n}\\n```\n```rust\\nimpl Solution {\\n    pub fn k_closest(mut points: Vec<Vec<i32>>, k: i32) -> Vec<Vec<i32>> {\\n        let k = k as usize; // Thanks Leetcode -_-\\n        let (mut lo, mut hi) = (0, points.len() - 1);\\n        while lo <= hi {\\n            let pivot = partition(&mut points, lo, hi);\\n            if pivot < k {\\n                lo = pivot + 1;\\n            } else if pivot > k {\\n                hi = pivot - 1;\\n            } else {\\n                break;\\n            }\\n        }\\n        points[..k].to_vec()\\n    }\\n}\\n\\nconst X: usize = 0;\\nconst Y: usize = 1;\\n\\nfn distance(point: &Vec<i32>) -> i32 {\\n    point[X] * point[X] + point[Y] * point[Y]\\n}\\n\\nfn partition(points: &mut Vec<Vec<i32>>, mut lo: usize, mut hi: usize) -> usize {\\n    // Approach: Hoare partitioning.\\n    let pivot = lo;\\n    while lo < hi {\\n        while lo < hi && distance(&points[pivot]) <= distance(&points[hi]) {\\n            hi -= 1;\\n        }\\n        while lo < hi && distance(&points[lo]) <= distance(&points[pivot]) {\\n            lo += 1;\\n        }\\n        points.swap(lo, hi);\\n    }\\n    points.swap(lo, pivot);\\n    lo\\n}\\n```\n```rust\\nfn partition(points: &mut Vec<Vec<i32>>, mut lo: usize, mut hi: usize) -> usize {\\n    // Approach: Lomuto partitioning.\\n    // Partition points so that we end up with:\\n    //   lo            l        r  hi\\n    //   [ point <=, pivot, < point ]\\n    //\\n    // The pivot value can be chosen randomly in [lo, hi],\\n    // but here we just pick points[hi] for convenience.\\n    let mut l = lo;\\n    for r in lo..hi {\\n        if distance(&points[r]) <= distance(&points[hi]) {\\n            points.swap(l, r);\\n            l += 1;\\n        }\\n    }\\n    points.swap(l, hi);\\n    l\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 659855,
                "title": "c-sorting-with-lambda-short-and-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        \\n        sort(points.begin(),points.end(),[](vector<int>p1,vector<int>p2) -> bool{ \\n            return (p1[0]*p1[0]+p1[1]*p1[1] <= p2[0]*p2[0]+p2[1]*p2[1]);\\n        });\\n        vector<vector<int>>res;\\n        for(int i = 0; i < K; i++) {\\n             res.push_back(points[i]);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\\n        \\n        sort(points.begin(),points.end(),[](vector<int>p1,vector<int>p2) -> bool{ \\n            return (p1[0]*p1[0]+p1[1]*p1[1] <= p2[0]*p2[0]+p2[1]*p2[1]);\\n        });\\n        vector<vector<int>>res;\\n        for(int i = 0; i < K; i++) {\\n             res.push_back(points[i]);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 609303,
                "title": "python-quickselect-works-with-duplicates",
                "content": "I saw a few python quickselect accepted solutions simply don\\'t pass test cases with duplicates: points=[[2,2],[2,2],[2,2],[2,2],[1,1]]; K=3 \\n\\nTo not panic in the interview, strictly follow this [non in-place quick sort template](https://leetcode.com/problems/sort-an-array/discuss/277127/7-line-quicksort-to-write-in-interviews-(Python)).\\n\\nFor this question, the complete code:\\n```python\\nclass Solution(object):\\n    def kClosest(self, points, K):\\n        if len(points)<=1 or K >= len(points):\\n            return points\\n\\n        def dist(p):\\n            x,y = p\\n            return x*x+y*y\\n        \\n        def quickselect(n, k):\\n            if k == 1:\\n                return [min(n,key = dist)]\\n            \\n            if k == len(n):\\n                return n\\n\\n            pivot = choice(n)\\n            left = [i for i in n if dist(i) < dist(pivot)]\\n            mid = [i for i in n if dist(i) == dist(pivot)]\\n            right = [i for i in n if dist(i) > dist(pivot)]\\n            \\n            if len(left) > k:\\n                return quickselect(left,k)\\n            \\n            if len(left)<=k<=len(left)+len(mid):\\n                return left+mid[:k-len(left)]\\n            \\n            if len(left)+len(mid)<k:\\n                return left+mid+quickselect(right,k-len(left)-len(mid))\\n            \\n        return quickselect(points,K)",
                "solutionTags": [
                    "Python",
                    "Quickselect"
                ],
                "code": "I saw a few python quickselect accepted solutions simply don\\'t pass test cases with duplicates: points=[[2,2],[2,2],[2,2],[2,2],[1,1]]; K=3 \\n\\nTo not panic in the interview, strictly follow this [non in-place quick sort template](https://leetcode.com/problems/sort-an-array/discuss/277127/7-line-quicksort-to-write-in-interviews-(Python)).\\n\\nFor this question, the complete code:\\n```python\\nclass Solution(object):\\n    def kClosest(self, points, K):\\n        if len(points)<=1 or K >= len(points):\\n            return points\\n\\n        def dist(p):\\n            x,y = p\\n            return x*x+y*y\\n        \\n        def quickselect(n, k):\\n            if k == 1:\\n                return [min(n,key = dist)]\\n            \\n            if k == len(n):\\n                return n\\n\\n            pivot = choice(n)\\n            left = [i for i in n if dist(i) < dist(pivot)]\\n            mid = [i for i in n if dist(i) == dist(pivot)]\\n            right = [i for i in n if dist(i) > dist(pivot)]\\n            \\n            if len(left) > k:\\n                return quickselect(left,k)\\n            \\n            if len(left)<=k<=len(left)+len(mid):\\n                return left+mid[:k-len(left)]\\n            \\n            if len(left)+len(mid)<k:\\n                return left+mid+quickselect(right,k-len(left)-len(mid))\\n            \\n        return quickselect(points,K)",
                "codeTag": "Java"
            },
            {
                "id": 453148,
                "title": "javascript-sorting-based",
                "content": "```javascript\\n/**\\n * @param {number[][]} points\\n * @param {number} K\\n * @return {number[][]}\\n */\\nvar kClosest = function(points, K) {\\n    points.sort((a,b) => {\\n       return Math.sqrt(Math.pow(a[0],2) + Math.pow(a[1],2)) - Math.sqrt(Math.pow(b[0],2) + Math.pow(b[1],2));\\n    });\\n        \\n    const res = [];\\n    for (let i = 0; i < K; ++i) {\\n        res.push(points[i]);\\n    }\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\n/**\\n * @param {number[][]} points\\n * @param {number} K\\n * @return {number[][]}\\n */\\nvar kClosest = function(points, K) {\\n    points.sort((a,b) => {\\n       return Math.sqrt(Math.pow(a[0],2) + Math.pow(a[1],2)) - Math.sqrt(Math.pow(b[0],2) + Math.pow(b[1],2));\\n    });\\n        \\n    const res = [];\\n    for (let i = 0; i < K; ++i) {\\n        res.push(points[i]);\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 429927,
                "title": "java-runtime-o-nlogn-memory-o-1-6-lines",
                "content": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n        Arrays.sort(points,(a,b)->{\\n            int distA = a[0]*a[0]+a[1]*a[1];\\n            int distB = b[0]*b[0]+b[1]*b[1];\\n            return distA-distB;\\n        });\\n        return Arrays.copyOfRange(points,0,K);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n        Arrays.sort(points,(a,b)->{\\n            int distA = a[0]*a[0]+a[1]*a[1];\\n            int distB = b[0]*b[0]+b[1]*b[1];\\n            return distA-distB;\\n        });\\n        return Arrays.copyOfRange(points,0,K);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 425375,
                "title": "java-priority-queue",
                "content": "According to the structure of heap, we can easily think of priority queue in solving getting k-max or k-min problems.\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n         PriorityQueue<int[]> pq = new PriorityQueue<>(\\n            (a,b) -> (a[0] * a[0] + a[1] * a[1]) - (b[0] * b[0] + b[1] * b[1]));\\n         for(int i=0;i<points.length;i++){\\n             pq.add(points[i]);\\n         }\\n        int res[][] = new int[K][2];\\n        for(int i=0;i<K;i++){\\n            res[i] = pq.poll();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int K) {\\n         PriorityQueue<int[]> pq = new PriorityQueue<>(\\n            (a,b) -> (a[0] * a[0] + a[1] * a[1]) - (b[0] * b[0] + b[1] * b[1]));\\n         for(int i=0;i<points.length;i++){\\n             pq.add(points[i]);\\n         }\\n        int res[][] = new int[K][2];\\n        for(int i=0;i<K;i++){\\n            res[i] = pq.poll();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 382686,
                "title": "100-priority-queue-pqueue-optimised-partition-median-of-median-java-easy-to-understand",
                "content": "**Priority Queue:**\\n\\n```\\n\\n/**\\n * O(n*log(n))\\n * Runtime: 69 ms, faster than 8.87% of Java online submissions for K Closest Points to Origin.\\n * Memory Usage: 60.2 MB, less than 65.22% of Java online submissions for K Closest Points to Origin.\\n */\\nclass KClosestPointsOriginPriorityQueue {\\n\\n    public int[][] kClosest(int[][] points, int k) {\\n\\n        if (points == null || points.length == 0 || points[0].length == 0)\\n            return points;\\n\\n        if (k == points.length)\\n            return points;\\n\\n        final PriorityQueue<Pair<int[], Double>> pq = new PriorityQueue<>(Comparator.comparingDouble(Pair::getValue));\\n\\n        final List<Pair<int[], Double>> distanceList = new ArrayList<>(points.length);\\n        for (int[] point : points) {\\n            distanceList.add(new Pair<>(point, distance(point[0], point[1])));\\n        }\\n        pq.addAll(distanceList);\\n\\n        final int[][] result = new int[k][2];\\n\\n        while (k > 0 && !pq.isEmpty()) {\\n            int[] point = pq.poll().getKey();\\n            result[k - 1][0] = point[0];\\n            result[k - 1][1] = point[1];\\n\\n            k--;\\n        }\\n\\n        return result;\\n\\n    }\\n\\n    private double distance(int x, int y) {\\n        return Math.sqrt(x * x + y * y);\\n    }\\n}\\n\\n```\\n\\n**Priority Queue optimized: **\\n\\n```\\n\\n/**\\n * O(k*log(n))\\n * Runtime: 66 ms, faster than 10.38% of Java online submissions for K Closest Points to Origin.\\n * Memory Usage: 59.7 MB, less than 73.91% of Java online submissions for K Closest Points to Origin.\\n */\\nclass KClosestPointsOriginPriorityQueueOptimized {\\n\\n    public int[][] kClosest(int[][] points, int k) {\\n\\n        if (points == null || points.length == 0 || points[0].length == 0)\\n            return points;\\n\\n        if (k == points.length)\\n            return points;\\n\\n        final PriorityQueue<int[]> pq = new PriorityQueue<>(((o1, o2) -> {\\n            double d1 = distance(o1[0], o1[1]);\\n            double d2 = distance(o2[0], o2[1]);\\n\\n            return -Double.compare(d1, d2);\\n        }));\\n\\n\\n        for (int[] point : points) {\\n            pq.offer(point);\\n\\n            if (pq.size() > k) pq.poll(); //remove greatest distance from pq\\n        }\\n\\n\\n        final int[][] result = new int[k][2];\\n\\n        while (k > 0 && !pq.isEmpty()) {\\n            result[k - 1] = pq.poll();\\n\\n            k--;\\n        }\\n\\n        return result;\\n\\n    }\\n\\n    private double distance(int x, int y) {\\n        return Math.sqrt(x * x + y * y);\\n    }\\n}\\n\\n```\\n\\n**Partition Algo: Quick select **\\n\\nWorst case : O(n*log(n))\\n\\n```\\n\\n/**\\n * We\\'ll use Quicksort partition logic to partition the array based on \\'k\\' element in the array. This way we\\'ll avoid sorting complete array\\n * <p>\\n * Runtime: 4 ms, faster than 99.69% of Java online submissions for K Closest Points to Origin.\\n * Memory Usage: 61.2 MB, less than 47.21% of Java online submissions for K Closest Points to Origin.\\n */\\nclass KClosestPointsOriginPartition {\\n\\n    public int[][] kClosest(int[][] points, int k) {\\n        int l = 0, r = points.length - 1;\\n\\n\\n        while (l <= r) {\\n\\n            int partitionIndex = partition(points, l, r, points[l]);\\n\\n            if (partitionIndex == k)\\n                break;\\n\\n            if (partitionIndex > k)\\n                r = partitionIndex - 1;\\n            else\\n                l = partitionIndex + 1;\\n\\n        }\\n        return Arrays.copyOfRange(points, 0, k);\\n    }\\n\\n    private int partition(int[][] points, int l, int r, int[] pivot) {\\n        int i;\\n        for (i = l; i < r; i++) {\\n\\n            if (compare(points[i], pivot) == 0)\\n                break;\\n        }\\n        swap(points, i, r);\\n\\n        i = l;\\n        for (int j = l; j < r; j++) {\\n\\n            if (compare(points[j], pivot) <= 0) {\\n                swap(points, i, j);\\n                i++;\\n            }\\n        }\\n        swap(points, i, r);\\n        return i;\\n    }\\n\\n\\n    private int compare(int[] p1, int[] p2) {\\n        int x = p1[0] * p1[0] + p1[1] * p1[1]; //(x1^2 + y1^2)\\n        int y = p2[0] * p2[0] + p2[1] * p2[1]; //(x2^2 + y2^2)\\n        return x - y;\\n    }\\n\\n\\n    private void swap(int[][] points, int i, int j) {\\n\\n        final int[] temp = points[i];\\n        points[i] = points[j];\\n        points[j] = temp;\\n    }\\n}\\n```\\n\\n**Partition : Median of Median.**\\nWorst case O(n)\\n\\n```\\n\\n/**\\n * Avoid below algorithm as though its O(n) but has more computation then needed. Its good for very huge array.\\n * {@link Java.KthLargestElement} #KthSmallest\\n * We\\'ll apply same logic as finding the kthSmallest element. Once we partition the array at index \\'partition\\'\\n * 1. if partition = k then all the element on left side of this index would be lesser than elements on right side of partition\\n * 2. otherwise either we need to go left or right based on partition vs k\\n * <p>\\n * To find partition point efficiently we\\'ll use median of median algorithm\\n * <p>\\n * Runtime: 63 ms, faster than 16.80% of Java online submissions for K Closest Points to Origin.\\n * Memory Usage: 63 MB, less than 34.16% of Java online submissions for K Closest Points to Origin.\\n */\\nclass KClosestPointsOriginPartitionMedianOfMedian {\\n\\n    static class Pair {\\n        int key;\\n        double distance;\\n\\n        public Pair(int key, double distance) {\\n            this.key = key;\\n            this.distance = distance;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \"key=\" + key +\\n                    \", distance=\" + distance +\\n                    \\'}\\';\\n        }\\n    }\\n\\n    public int[][] kClosest(int[][] points, int k) {\\n\\n        if (points == null || points.length == 0 || points[0].length == 0)\\n            return points;\\n\\n        if (k == points.length)\\n            return points;\\n\\n        final Pair[] distanceList = new Pair[points.length];\\n\\n        for (int i = 0; i < points.length; i++) {\\n            int[] point = points[i];\\n            distanceList[i] = new Pair(i, distance(point[0], point[1]));\\n        }\\n\\n        if (distanceList.length <= 5) {\\n            Arrays.sort(distanceList, Comparator.comparingDouble(o -> o.distance));\\n            return getKValues(distanceList, points, k);\\n        }\\n\\n        int n = distanceList.length;\\n        final Double distance = kthLargestElement(distanceList, 0, n - 1, k);\\n\\n        final int[][] result = new int[k][2];\\n        int p = 0;\\n\\n        for (int i = 0; i < n && p < k; i++) {\\n            if (Double.compare(distanceList[i].distance, distance) <= 0)\\n                result[p++] = points[distanceList[i].key];\\n        }\\n\\n        return result;\\n\\n\\n    }\\n\\n    private int[][] getKValues(final Pair[] distanceList, int[][] points, int k) {\\n        final int[][] result = new int[k][2];\\n\\n        int i = 0;\\n        while (k > 0) {\\n            result[k - 1] = points[distanceList[i++].key];\\n            k--;\\n        }\\n\\n        return result;\\n\\n\\n    }\\n\\n    private Double kthLargestElement(Pair[] distanceList, int l, int r, int k) {\\n\\n        final int n = r - l + 1;\\n\\n        if (k > 0 && k <= n) {\\n\\n            final Pair[] median = new Pair[(n + 4) / 5];\\n            int i;\\n            for (i = 0; i < n / 5; i++) {\\n                median[i] = findMedian(distanceList, l + i * 5, 5);\\n            }\\n\\n            if (i * 5 < n) {\\n                median[i] = findMedian(distanceList, l + i * 5, n % 5);\\n                i++;\\n            }\\n\\n            final double medianOfMedian = (i == 1)\\n                    ? median[0].distance\\n                    : kthLargestElement(median, 0, i - 1, i / 2); //find median of median array\\n\\n            final int partitionIndex = partition(distanceList, l, r, medianOfMedian);\\n\\n            if (partitionIndex - l == k - 1)\\n                return distanceList[partitionIndex].distance;\\n            else if (partitionIndex - l > k - 1)\\n                return kthLargestElement(distanceList, l, partitionIndex - 1, k);\\n            else // k-1 > p - l => k > p -l+1 => k < -p+l-1 =>\\n                return kthLargestElement(distanceList, partitionIndex + 1, r, k - partitionIndex + l - 1);\\n        }\\n\\n\\n        return -1.0;\\n    }\\n\\n    private int partition(Pair[] distanceList, int l, int r, double pivot) {\\n\\n        int i;\\n        for (i = l; i < r; i++) {\\n\\n            if (Double.compare(distanceList[i].distance, pivot) == 0) {\\n                break;\\n            }\\n        }\\n\\n        swap(distanceList, i, r);\\n\\n        i = l;\\n        for (int j = l; j < r; j++) {\\n            if (Double.compare(distanceList[j].distance, pivot) <= 0) {\\n                swap(distanceList, i, j);\\n                i++;\\n            }\\n        }\\n        swap(distanceList, i, r);\\n        return i;\\n\\n    }\\n\\n    private void swap(Pair[] distanceList, int i, int j) {\\n\\n        final Pair temp = distanceList[i];\\n        distanceList[i] = distanceList[j];\\n        distanceList[j] = temp;\\n    }\\n\\n    private Pair findMedian(Pair[] distanceList, int i, int n) {\\n        Arrays.sort(distanceList, i, i + n, Comparator.comparingDouble(o -> o.distance));\\n        return distanceList[i + (n / 2)];\\n    }\\n\\n\\n    private double distance(int x, int y) {\\n        return Math.sqrt(x * x + y * y);\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n/**\\n * O(n*log(n))\\n * Runtime: 69 ms, faster than 8.87% of Java online submissions for K Closest Points to Origin.\\n * Memory Usage: 60.2 MB, less than 65.22% of Java online submissions for K Closest Points to Origin.\\n */\\nclass KClosestPointsOriginPriorityQueue {\\n\\n    public int[][] kClosest(int[][] points, int k) {\\n\\n        if (points == null || points.length == 0 || points[0].length == 0)\\n            return points;\\n\\n        if (k == points.length)\\n            return points;\\n\\n        final PriorityQueue<Pair<int[], Double>> pq = new PriorityQueue<>(Comparator.comparingDouble(Pair::getValue));\\n\\n        final List<Pair<int[], Double>> distanceList = new ArrayList<>(points.length);\\n        for (int[] point : points) {\\n            distanceList.add(new Pair<>(point, distance(point[0], point[1])));\\n        }\\n        pq.addAll(distanceList);\\n\\n        final int[][] result = new int[k][2];\\n\\n        while (k > 0 && !pq.isEmpty()) {\\n            int[] point = pq.poll().getKey();\\n            result[k - 1][0] = point[0];\\n            result[k - 1][1] = point[1];\\n\\n            k--;\\n        }\\n\\n        return result;\\n\\n    }\\n\\n    private double distance(int x, int y) {\\n        return Math.sqrt(x * x + y * y);\\n    }\\n}\\n\\n```\n```\\n\\n/**\\n * O(k*log(n))\\n * Runtime: 66 ms, faster than 10.38% of Java online submissions for K Closest Points to Origin.\\n * Memory Usage: 59.7 MB, less than 73.91% of Java online submissions for K Closest Points to Origin.\\n */\\nclass KClosestPointsOriginPriorityQueueOptimized {\\n\\n    public int[][] kClosest(int[][] points, int k) {\\n\\n        if (points == null || points.length == 0 || points[0].length == 0)\\n            return points;\\n\\n        if (k == points.length)\\n            return points;\\n\\n        final PriorityQueue<int[]> pq = new PriorityQueue<>(((o1, o2) -> {\\n            double d1 = distance(o1[0], o1[1]);\\n            double d2 = distance(o2[0], o2[1]);\\n\\n            return -Double.compare(d1, d2);\\n        }));\\n\\n\\n        for (int[] point : points) {\\n            pq.offer(point);\\n\\n            if (pq.size() > k) pq.poll(); //remove greatest distance from pq\\n        }\\n\\n\\n        final int[][] result = new int[k][2];\\n\\n        while (k > 0 && !pq.isEmpty()) {\\n            result[k - 1] = pq.poll();\\n\\n            k--;\\n        }\\n\\n        return result;\\n\\n    }\\n\\n    private double distance(int x, int y) {\\n        return Math.sqrt(x * x + y * y);\\n    }\\n}\\n\\n```\n```\\n\\n/**\\n * We\\'ll use Quicksort partition logic to partition the array based on \\'k\\' element in the array. This way we\\'ll avoid sorting complete array\\n * <p>\\n * Runtime: 4 ms, faster than 99.69% of Java online submissions for K Closest Points to Origin.\\n * Memory Usage: 61.2 MB, less than 47.21% of Java online submissions for K Closest Points to Origin.\\n */\\nclass KClosestPointsOriginPartition {\\n\\n    public int[][] kClosest(int[][] points, int k) {\\n        int l = 0, r = points.length - 1;\\n\\n\\n        while (l <= r) {\\n\\n            int partitionIndex = partition(points, l, r, points[l]);\\n\\n            if (partitionIndex == k)\\n                break;\\n\\n            if (partitionIndex > k)\\n                r = partitionIndex - 1;\\n            else\\n                l = partitionIndex + 1;\\n\\n        }\\n        return Arrays.copyOfRange(points, 0, k);\\n    }\\n\\n    private int partition(int[][] points, int l, int r, int[] pivot) {\\n        int i;\\n        for (i = l; i < r; i++) {\\n\\n            if (compare(points[i], pivot) == 0)\\n                break;\\n        }\\n        swap(points, i, r);\\n\\n        i = l;\\n        for (int j = l; j < r; j++) {\\n\\n            if (compare(points[j], pivot) <= 0) {\\n                swap(points, i, j);\\n                i++;\\n            }\\n        }\\n        swap(points, i, r);\\n        return i;\\n    }\\n\\n\\n    private int compare(int[] p1, int[] p2) {\\n        int x = p1[0] * p1[0] + p1[1] * p1[1]; //(x1^2 + y1^2)\\n        int y = p2[0] * p2[0] + p2[1] * p2[1]; //(x2^2 + y2^2)\\n        return x - y;\\n    }\\n\\n\\n    private void swap(int[][] points, int i, int j) {\\n\\n        final int[] temp = points[i];\\n        points[i] = points[j];\\n        points[j] = temp;\\n    }\\n}\\n```\n```\\n\\n/**\\n * Avoid below algorithm as though its O(n) but has more computation then needed. Its good for very huge array.\\n * {@link Java.KthLargestElement} #KthSmallest\\n * We\\'ll apply same logic as finding the kthSmallest element. Once we partition the array at index \\'partition\\'\\n * 1. if partition = k then all the element on left side of this index would be lesser than elements on right side of partition\\n * 2. otherwise either we need to go left or right based on partition vs k\\n * <p>\\n * To find partition point efficiently we\\'ll use median of median algorithm\\n * <p>\\n * Runtime: 63 ms, faster than 16.80% of Java online submissions for K Closest Points to Origin.\\n * Memory Usage: 63 MB, less than 34.16% of Java online submissions for K Closest Points to Origin.\\n */\\nclass KClosestPointsOriginPartitionMedianOfMedian {\\n\\n    static class Pair {\\n        int key;\\n        double distance;\\n\\n        public Pair(int key, double distance) {\\n            this.key = key;\\n            this.distance = distance;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \"key=\" + key +\\n                    \", distance=\" + distance +\\n                    \\'}\\';\\n        }\\n    }\\n\\n    public int[][] kClosest(int[][] points, int k) {\\n\\n        if (points == null || points.length == 0 || points[0].length == 0)\\n            return points;\\n\\n        if (k == points.length)\\n            return points;\\n\\n        final Pair[] distanceList = new Pair[points.length];\\n\\n        for (int i = 0; i < points.length; i++) {\\n            int[] point = points[i];\\n            distanceList[i] = new Pair(i, distance(point[0], point[1]));\\n        }\\n\\n        if (distanceList.length <= 5) {\\n            Arrays.sort(distanceList, Comparator.comparingDouble(o -> o.distance));\\n            return getKValues(distanceList, points, k);\\n        }\\n\\n        int n = distanceList.length;\\n        final Double distance = kthLargestElement(distanceList, 0, n - 1, k);\\n\\n        final int[][] result = new int[k][2];\\n        int p = 0;\\n\\n        for (int i = 0; i < n && p < k; i++) {\\n            if (Double.compare(distanceList[i].distance, distance) <= 0)\\n                result[p++] = points[distanceList[i].key];\\n        }\\n\\n        return result;\\n\\n\\n    }\\n\\n    private int[][] getKValues(final Pair[] distanceList, int[][] points, int k) {\\n        final int[][] result = new int[k][2];\\n\\n        int i = 0;\\n        while (k > 0) {\\n            result[k - 1] = points[distanceList[i++].key];\\n            k--;\\n        }\\n\\n        return result;\\n\\n\\n    }\\n\\n    private Double kthLargestElement(Pair[] distanceList, int l, int r, int k) {\\n\\n        final int n = r - l + 1;\\n\\n        if (k > 0 && k <= n) {\\n\\n            final Pair[] median = new Pair[(n + 4) / 5];\\n            int i;\\n            for (i = 0; i < n / 5; i++) {\\n                median[i] = findMedian(distanceList, l + i * 5, 5);\\n            }\\n\\n            if (i * 5 < n) {\\n                median[i] = findMedian(distanceList, l + i * 5, n % 5);\\n                i++;\\n            }\\n\\n            final double medianOfMedian = (i == 1)\\n                    ? median[0].distance\\n                    : kthLargestElement(median, 0, i - 1, i / 2); //find median of median array\\n\\n            final int partitionIndex = partition(distanceList, l, r, medianOfMedian);\\n\\n            if (partitionIndex - l == k - 1)\\n                return distanceList[partitionIndex].distance;\\n            else if (partitionIndex - l > k - 1)\\n                return kthLargestElement(distanceList, l, partitionIndex - 1, k);\\n            else // k-1 > p - l => k > p -l+1 => k < -p+l-1 =>\\n                return kthLargestElement(distanceList, partitionIndex + 1, r, k - partitionIndex + l - 1);\\n        }\\n\\n\\n        return -1.0;\\n    }\\n\\n    private int partition(Pair[] distanceList, int l, int r, double pivot) {\\n\\n        int i;\\n        for (i = l; i < r; i++) {\\n\\n            if (Double.compare(distanceList[i].distance, pivot) == 0) {\\n                break;\\n            }\\n        }\\n\\n        swap(distanceList, i, r);\\n\\n        i = l;\\n        for (int j = l; j < r; j++) {\\n            if (Double.compare(distanceList[j].distance, pivot) <= 0) {\\n                swap(distanceList, i, j);\\n                i++;\\n            }\\n        }\\n        swap(distanceList, i, r);\\n        return i;\\n\\n    }\\n\\n    private void swap(Pair[] distanceList, int i, int j) {\\n\\n        final Pair temp = distanceList[i];\\n        distanceList[i] = distanceList[j];\\n        distanceList[j] = temp;\\n    }\\n\\n    private Pair findMedian(Pair[] distanceList, int i, int n) {\\n        Arrays.sort(distanceList, i, i + n, Comparator.comparingDouble(o -> o.distance));\\n        return distanceList[i + (n / 2)];\\n    }\\n\\n\\n    private double distance(int x, int y) {\\n        return Math.sqrt(x * x + y * y);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 376730,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number[][]} points\\n * @param {number} K\\n * @return {number[][]}\\n */\\nvar kClosest = function(points, K) {\\n    // There no difference for sorting between a^2 or a\\n    const getDistanse = point => (point[0] ** 2) + (point[1] ** 2);\\n    return points.sort((a, b) => getDistanse(a) - getDistanse(b)).slice(0, K);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} points\\n * @param {number} K\\n * @return {number[][]}\\n */\\nvar kClosest = function(points, K) {\\n    // There no difference for sorting between a^2 or a\\n    const getDistanse = point => (point[0] ** 2) + (point[1] ** 2);\\n    return points.sort((a, b) => getDistanse(a) - getDistanse(b)).slice(0, K);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 337616,
                "title": "scala-solution-91-speed-100-memory-priorityqueue-solution",
                "content": "```\\nobject Solution {\\n\\n\\tcase class PointObj(c: Double, point: Array[Int])\\n\\n    def kClosest(points: Array[Array[Int]], K: Int): Array[Array[Int]] = {\\n        val pq = scala.collection.mutable.PriorityQueue.empty[PointObj](Ordering.by(_.c))        \\n        \\n        points.foreach { point =>\\n            val a = Math.pow(point.head, 2)\\n            val b = Math.pow(point.last, 2)\\n            val c = Math.sqrt(a + b)\\n            \\n            pq.enqueue(PointObj(c, point))\\n            if (pq.length > K) pq.dequeue\\n        }\\n        \\n        pq.dequeueAll.map(_.point).toArray\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nobject Solution {\\n\\n\\tcase class PointObj(c: Double, point: Array[Int])\\n\\n    def kClosest(points: Array[Array[Int]], K: Int): Array[Array[Int]] = {\\n        val pq = scala.collection.mutable.PriorityQueue.empty[PointObj](Ordering.by(_.c))        \\n        \\n        points.foreach { point =>\\n            val a = Math.pow(point.head, 2)\\n            val b = Math.pow(point.last, 2)\\n            val c = Math.sqrt(a + b)\\n            \\n            pq.enqueue(PointObj(c, point))\\n            if (pq.length > K) pq.dequeue\\n        }\\n        \\n        pq.dequeueAll.map(_.point).toArray\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 261028,
                "title": "python-solution-with-max-heap",
                "content": "Since Python\\'s heapq implementation does not have built in support for max heap, we can just invert the values stored into the heap so it functions as a max heap. Max heap is better than min heap because we don\\'t actually have to store all N points into the heap, we just need to keep K min points.\\n\\nTime Complexity: O(N Log(K))\\nSpace Complexity: O(K)\\n\\n```\\nimport heapq\\n\\nclass Solution:\\n\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        \\n        maxHeap = []\\n        \\n        for (x, y) in points:\\n            distance = math.sqrt(x*x + y*y)\\n            \\n            if len(maxHeap) >= K:\\n                if -1 * distance > maxHeap[0][0]:\\n                    heapq.heappushpop(maxHeap, [-1 * distance, [x, y]])\\n            else:\\n                heapq.heappush(maxHeap, [-1 * distance, [x, y]])\\n        \\n        resList = []\\n        \\n        for _ in range(K):\\n            resList.append(heapq.heappop(maxHeap)[1])\\n        \\n        # Return the list\\n        return resList\\n```",
                "solutionTags": [],
                "code": "```\\nimport heapq\\n\\nclass Solution:\\n\\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        \\n        maxHeap = []\\n        \\n        for (x, y) in points:\\n            distance = math.sqrt(x*x + y*y)\\n            \\n            if len(maxHeap) >= K:\\n                if -1 * distance > maxHeap[0][0]:\\n                    heapq.heappushpop(maxHeap, [-1 * distance, [x, y]])\\n            else:\\n                heapq.heappush(maxHeap, [-1 * distance, [x, y]])\\n        \\n        resList = []\\n        \\n        for _ in range(K):\\n            resList.append(heapq.heappop(maxHeap)[1])\\n        \\n        # Return the list\\n        return resList\\n```",
                "codeTag": "Java"
            },
            {
                "id": 233694,
                "title": "python-1-liner",
                "content": "```\\nclass Solution(object):\\n    def kClosest(self, points, K):\\n        return sorted(points, key=lambda x: x[0]*x[0] + x[1]*x[1])[:K]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def kClosest(self, points, K):\\n        return sorted(points, key=lambda x: x[0]*x[0] + x[1]*x[1])[:K]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 224254,
                "title": "python3-with-o-2n-aux-space-faster-than-100",
                "content": "```\\nimport math\\n\\nclass Solution:\\n    def kClosest(self, points, K):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :type K: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        distanceDict = {}\\n        distanceList = []\\n        for x in points:\\n            u = math.sqrt(x[0]**2 + x[1]**2)\\n            distanceDict[u] = x\\n            distanceList.append(u)\\n        distanceList.sort()\\n        return [distanceDict[ distanceList[i] ] for i in range(K)]\\n```",
                "solutionTags": [],
                "code": "```\\nimport math\\n\\nclass Solution:\\n    def kClosest(self, points, K):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :type K: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        distanceDict = {}\\n        distanceList = []\\n        for x in points:\\n            u = math.sqrt(x[0]**2 + x[1]**2)\\n            distanceDict[u] = x\\n            distanceList.append(u)\\n        distanceList.sort()\\n        return [distanceDict[ distanceList[i] ] for i in range(K)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 219982,
                "title": "javascript-one-liner",
                "content": "```\\nvar kClosest = function(points, K) {\\n    return points.sort((a, b) => a[0]*a[0]+a[1]*a[1] - b[0]*b[0] - b[1]*b[1]).slice(0,K);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar kClosest = function(points, K) {\\n    return points.sort((a, b) => a[0]*a[0]+a[1]*a[1] - b[0]*b[0] - b[1]*b[1]).slice(0,K);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3440705,
                "title": "very-easy-java-solution-o-n-lambda-function",
                "content": "# Intuition\\nsolving the problem using Priority Queue and sorting it with lambda function\\n\\n# Approach\\ncreate a class to store the distance , x coordinate and y coordinate of each points.\\n\\narrange them in ascending order of distance using priority queue.\\n\\nkeep the required no. of points(k).\\n\\n ```\\nex-\\n\\npoints = [1,1] , [2,3] , [0,0] , [2,0]\\n\\ndistance of points from [0,0]\\n \\ndis =     2   ,   13   ,  0    ,    4\\n\\nx   =     1   ,   2    ,  0    ,    2\\n\\nx   =     1   ,   3    ,  0    ,    0\\n```\\nnow arrange them in pq and put the required set in matrix.\\n\\n# Complexity\\n- Time complexity:\\nO(NLogN)\\n\\n- Space complexity:\\nO(Number of points)\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public int[][] kClosest(int[][] p, int k) {\\n        PriorityQueue<node> pq = new PriorityQueue<>((a,b) -> a.dis - b.dis);\\n        for(int i =0;i<p.length;i++){\\n            int total = p[i][0]*p[i][0] + p[i][1]*p[i][1];\\n            node n = new node(total,p[i][0],p[i][1]);\\n            pq.add(n);\\n        }\\n        int[][] ans = new int[k][2];\\n        for(int i =0;i<k && pq.size()>0;i++){\\n            node n = pq.poll();\\n            ans[i][0] = n.x; \\n            ans[i][1] = n.y;\\n        }\\n        return ans;\\n    }\\n}\\n\\nclass node{\\n    node value;\\n    int dis;\\n    int x;\\n    int y;\\n    node(int dis, int x , int y){\\n        this.dis = dis;\\n        this.x = x;\\n        this.y = y;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nex-\\n\\npoints = [1,1] , [2,3] , [0,0] , [2,0]\\n\\ndistance of points from [0,0]\\n \\ndis =     2   ,   13   ,  0    ,    4\\n\\nx   =     1   ,   2    ,  0    ,    2\\n\\nx   =     1   ,   3    ,  0    ,    0\\n```\n```\\nimport java.util.*;\\nclass Solution {\\n    public int[][] kClosest(int[][] p, int k) {\\n        PriorityQueue<node> pq = new PriorityQueue<>((a,b) -> a.dis - b.dis);\\n        for(int i =0;i<p.length;i++){\\n            int total = p[i][0]*p[i][0] + p[i][1]*p[i][1];\\n            node n = new node(total,p[i][0],p[i][1]);\\n            pq.add(n);\\n        }\\n        int[][] ans = new int[k][2];\\n        for(int i =0;i<k && pq.size()>0;i++){\\n            node n = pq.poll();\\n            ans[i][0] = n.x; \\n            ans[i][1] = n.y;\\n        }\\n        return ans;\\n    }\\n}\\n\\nclass node{\\n    node value;\\n    int dis;\\n    int x;\\n    int y;\\n    node(int dis, int x , int y){\\n        this.dis = dis;\\n        this.x = x;\\n        this.y = y;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341366,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<pair<double, vector<int>>> v;\\n        for(auto x: points) {\\n            double dis = sqrt(x[0] * x[0] + x[1] * x[1]);\\n            v.push_back({dis, {x[0], x[1]}});\\n        }\\n        sort(v.begin(), v.end());\\n        vector<vector<int>> ans;\\n        for(int i=0; i<k; i++) ans.push_back(v[i].second);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<pair<double, vector<int>>> v;\\n        for(auto x: points) {\\n            double dis = sqrt(x[0] * x[0] + x[1] * x[1]);\\n            v.push_back({dis, {x[0], x[1]}});\\n        }\\n        sort(v.begin(), v.end());\\n        vector<vector<int>> ans;\\n        for(int i=0; i<k; i++) ans.push_back(v[i].second);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3248328,
                "title": "heapq-maxheap-and-minheap-solution-nlogk",
                "content": "# Intuition\\nWhen thinking about kClosest, heap is most intuitive. Since we are getting the most closest, first solution that came to mind is to use minHeap, and push all elements on to the heap, and then pop each k elements.\\n\\nAfter thinking a bit, solution #2 (maxHeap) was a better solution as it optimize the Time Complexity to O(Nlogk) since we are able to pop from the heap whenever the heap goes above size k. \\n\\n# Complexity\\n- Time complexity: O(NlogN + klogN) where k < N\\n-  = O(NlogN)\\n\\n- Space complexity: O(N) for the heap\\n\\n# Code\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        distance = []\\n        heapq.heapify(distance)\\n        for [x,y] in points:\\n            newDistSq = x**2 + y**2\\n            heapq.heappush(distance,(newDistSq, [x,y]))\\n        res = []\\n        while len(res) < k:\\n            (_, loc) = heapq.heappop(distance)\\n            res.append(loc)\\n        return res\\n```\\n\\nSecond solution (Optimized when k << N)\\nTime complexity: O(Nlogk) where k < N\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        distance = [] # max heap\\n        heapq.heapify(distance)\\n        for [x,y] in points:\\n            newDistSq = x**2 + y**2\\n            heapq.heappush(distance,(-newDistSq, [x,y]))\\n            if len(distance) > k:\\n                heapq.heappop(distance)\\n            \\n        return map(lambda x: x[1], distance)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        distance = []\\n        heapq.heapify(distance)\\n        for [x,y] in points:\\n            newDistSq = x**2 + y**2\\n            heapq.heappush(distance,(newDistSq, [x,y]))\\n        res = []\\n        while len(res) < k:\\n            (_, loc) = heapq.heappop(distance)\\n            res.append(loc)\\n        return res\\n```\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        distance = [] # max heap\\n        heapq.heapify(distance)\\n        for [x,y] in points:\\n            newDistSq = x**2 + y**2\\n            heapq.heappush(distance,(-newDistSq, [x,y]))\\n            if len(distance) > k:\\n                heapq.heappop(distance)\\n            \\n        return map(lambda x: x[1], distance)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060864,
                "title": "c-min-heap-brute-force-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(nlogn)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>>q;\\n        for(auto it: points){\\n            int dis=it[0]*it[0]+it[1]*it[1];\\n            //cout<<dis<<endl;\\n            q.push({dis, {it[0], it[1]}});\\n        }\\n        vector<vector<int>>ans;\\n        while(k--){\\n            ans.push_back({q.top().second.first, q.top().second.second});\\n            q.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Geometry",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>>q;\\n        for(auto it: points){\\n            int dis=it[0]*it[0]+it[1]*it[1];\\n            //cout<<dis<<endl;\\n            q.push({dis, {it[0], it[1]}});\\n        }\\n        vector<vector<int>>ans;\\n        while(k--){\\n            ans.push_back({q.top().second.first, q.top().second.second});\\n            q.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2894395,
                "title": "simplest-3-solution-c-faster-than-85-of-c-online-submissions",
                "content": "****    **using pairs in Priority queue********\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n          vector<vector<int>> ans;\\n        priority_queue<pair<double,pair<int,int>>> st;\\n         for(int i=0;i<points.size();i++)\\n        {\\n            double dis=sqrt(pow(points[i][0],2)+pow(points[i][1],2));\\n            \\n            st.push({-dis,{points[i][0],points[i][1]}});\\n            \\n        }\\n        int j=0;\\n        while(j<k)\\n        {\\n            ans.push_back({st.top().second.first,st.top().second.second});\\n            st.pop();\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n\\n****    **using vectors<int> in Priority queue********\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n          vector<vector<int>> ans;\\n        priority_queue<pair<double,vector<int>>> st;\\n         for(int i=0;i<points.size();i++)\\n        {\\n            double dis=sqrt(pow(points[i][0],2)+pow(points[i][1],2));\\n            \\n            st.push({-dis,points[i]});\\n            \\n        }\\n        int j=0;\\n        while(j<k)\\n        {\\n            ans.push_back(st.top().second);\\n            st.pop();\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n***********using  vector<pair<vector<int>,double>>***********\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(pair<vector<int>,double> a,pair<vector<int>,double> b)\\n    {\\n        return a.second<b.second;\\n    }\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n         vector<vector<int>> ans;\\n         vector<pair<vector<int>,double>> abc;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            double dis=sqrt(pow(points[i][0],2)+pow(points[i][1],2));\\n            \\n            abc.push_back({points[i],dis});\\n            \\n        }\\n        sort(abc.begin(),abc.end(),cmp);\\n        for(auto it:abc)\\n        {\\n            if(k>0){\\n            ans.push_back(it.first);\\n                k--;\\n                }\\n            for(int j=0;j<abc[0].first.size();++j){\\n               //  cout<<it.first[j]<<\" \";\\n        }\\n           // cout<<it.second<<endl;\\n        }\\n          \\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n          vector<vector<int>> ans;\\n        priority_queue<pair<double,pair<int,int>>> st;\\n         for(int i=0;i<points.size();i++)\\n        {\\n            double dis=sqrt(pow(points[i][0],2)+pow(points[i][1],2));\\n            \\n            st.push({-dis,{points[i][0],points[i][1]}});\\n            \\n        }\\n        int j=0;\\n        while(j<k)\\n        {\\n            ans.push_back({st.top().second.first,st.top().second.second});\\n            st.pop();\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n          vector<vector<int>> ans;\\n        priority_queue<pair<double,vector<int>>> st;\\n         for(int i=0;i<points.size();i++)\\n        {\\n            double dis=sqrt(pow(points[i][0],2)+pow(points[i][1],2));\\n            \\n            st.push({-dis,points[i]});\\n            \\n        }\\n        int j=0;\\n        while(j<k)\\n        {\\n            ans.push_back(st.top().second);\\n            st.pop();\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    static bool cmp(pair<vector<int>,double> a,pair<vector<int>,double> b)\\n    {\\n        return a.second<b.second;\\n    }\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n         vector<vector<int>> ans;\\n         vector<pair<vector<int>,double>> abc;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            double dis=sqrt(pow(points[i][0],2)+pow(points[i][1],2));\\n            \\n            abc.push_back({points[i],dis});\\n            \\n        }\\n        sort(abc.begin(),abc.end(),cmp);\\n        for(auto it:abc)\\n        {\\n            if(k>0){\\n            ans.push_back(it.first);\\n                k--;\\n                }\\n            for(int j=0;j<abc[0].first.size();++j){\\n               //  cout<<it.first[j]<<\" \";\\n        }\\n           // cout<<it.second<<endl;\\n        }\\n          \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2844811,
                "title": "easy-java-solution-well-documented",
                "content": "class Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n\\t\\n        //designing max heap using custom comparator with array of coordinates with greatest distance from origin  at top of the heap followed by lower distance \\n        \\n        // PriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>() { \\n        //     @Override\\n        //     public int compare(int[] a, int[] b) {\\n        //         int distA=a[0]*a[0]+a[1]*a[1]; //by formula distanceFromOrigin = (X^2)-(Y^2)\\n        //         int distB=b[0]*b[0]+b[1]*b[1];\\n        //         return (distB-distA); //difference = secondDistance - firstDistance\\n        //     }\\n        // });\\n        \\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b) -> (b[0]*b[0]+b[1]*b[1]) - (a[0]*a[0]+a[1]*a[1])); //lambda version of the same comparator\\n        \\n        for(int[] point:points){\\n            pq.offer(point);\\n            if(pq.size()>k){ //removing untill k closest coordinates  \\n                pq.poll();\\n            }\\n        }\\n        \\n        int[][] res=new int[pq.size()][2]; //or int[][] res=new int[k][2]; //because there are k coordinates each of size 2\\n        \\n        int i=0;\\n        while(!pq.isEmpty()){\\n            res[i]=pq.poll();\\n            i++;\\n        }\\n\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n\\t\\n        //designing max heap using custom comparator with array of coordinates with greatest distance from origin  at top of the heap followed by lower distance \\n        \\n        // PriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>() { \\n        //     @Override\\n        //     public int compare(int[] a, int[] b) {\\n        //         int distA=a[0]*a[0]+a[1]*a[1]; //by formula distanceFromOrigin = (X^2)-(Y^2)\\n        //         int distB=b[0]*b[0]+b[1]*b[1];\\n        //         return (distB-distA); //difference = secondDistance - firstDistance\\n        //     }",
                "codeTag": "Java"
            },
            {
                "id": 2842267,
                "title": "easy-lambda-function-based-solution-o-nlogn-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe needed to sort the array elements according to their respective distances from the origin.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo what we can do is define a separate function (distance here) that takes the x & y coordinates and calculates each point\\'s distance from the origin.\\nwe then pass this distance function as the key parameter of the sort function. The key parameter of the sort function takes a function and sorts the iterable according to the values returned by that function(distance in this case)\\nhence, we obtain the points list sorted according to the points\\' distances from the origin.\\nand at last we return the first k elements of the list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe in-built sort function is based on timsort which takes $$O(nlogn)$$ time for sorting.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nthe space complexity of this code is $$O(1)$$ as we\\'re not using any extra space.\\n\\n# Code\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        def distance(x,y):\\n            return (x**2 + y**2) ** 0.5\\n\\n        points.sort(key = lambda i : distance(i[0], i[1]))\\n\\n        return points[:k]\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        def distance(x,y):\\n            return (x**2 + y**2) ** 0.5\\n\\n        points.sort(key = lambda i : distance(i[0], i[1]))\\n\\n        return points[:k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808360,
                "title": "c-priority-queue-solution",
                "content": "**Please connect with me if u like my solution**\\n**Please Upvote**\\nhttps://www.linkedin.com/in/shubham-roy-0b71a0220/\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<vector<int>>ans;\\n    \\n        priority_queue<pair<int,pair<int,int>>>mxh;\\n        for(int i=0;i<points.size();i++){\\n            \\n            mxh.push({(points[i][0]*points[i][0])+ (points[i][1]*points[i][1]),\\n                      {points[i][0],points[i][1]}});\\n            while(mxh.size()>k){\\n                mxh.pop();\\n            }\\n        }\\n        while(mxh.size()>0){\\n            pair<int,int>p=mxh.top().second;\\n            ans.push_back({p.first,p.second});\\n            mxh.pop();\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<vector<int>>ans;\\n    \\n        priority_queue<pair<int,pair<int,int>>>mxh;\\n        for(int i=0;i<points.size();i++){\\n            \\n            mxh.push({(points[i][0]*points[i][0])+ (points[i][1]*points[i][1]),\\n                      {points[i][0],points[i][1]}});\\n            while(mxh.size()>k){\\n                mxh.pop();\\n            }\\n        }\\n        while(mxh.size()>0){\\n            pair<int,int>p=mxh.top().second;\\n            ans.push_back({p.first,p.second});\\n            mxh.pop();\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2733717,
                "title": "easy-faster-efficient-java-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        PriorityQueue<Double> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        HashMap<Double, List<Integer>> map = new HashMap<>();\\n        for(int i = 0; i < points.length; i++){\\n            int [] point = points[i];\\n            int x = point[0];\\n            int y = point[1];\\n            double square = helper(x, y);\\n            \\n            List<Integer> al = map.getOrDefault(square, new ArrayList<>());\\n            al.add(i);\\n            map.put(square, al);\\n            if(pq.size() < k){\\n                pq.add(square);\\n            } else{\\n                if(pq.peek() > square){\\n                    pq.poll();\\n                    pq.offer(square);\\n                }\\n            }\\n        }\\n        \\n        int [][] ans = new int[k][2];\\n        int i = 0;\\n        while(pq.size() > 0){\\n            double val = pq.poll();\\n            if(map.containsKey(val)){\\n                List<Integer> al = map.get(val);\\n                for(int idx : al){\\n                    int [] point = points[idx];\\n                    ans[i++] = point;\\n                }\\n            }\\n            \\n            map.remove(val);\\n        }\\n        return ans;\\n    }\\n    private double helper(int x, int y){\\n        int x1 = Math.abs(x - 0);\\n        int y1 = Math.abs(y - 0);\\n        x1 *= x1;\\n        y1 *= y1;\\n        double ans = Math.sqrt(x1 + y1);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        PriorityQueue<Double> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        HashMap<Double, List<Integer>> map = new HashMap<>();\\n        for(int i = 0; i < points.length; i++){\\n            int [] point = points[i];\\n            int x = point[0];\\n            int y = point[1];\\n            double square = helper(x, y);\\n            \\n            List<Integer> al = map.getOrDefault(square, new ArrayList<>());\\n            al.add(i);\\n            map.put(square, al);\\n            if(pq.size() < k){\\n                pq.add(square);\\n            } else{\\n                if(pq.peek() > square){\\n                    pq.poll();\\n                    pq.offer(square);\\n                }\\n            }\\n        }\\n        \\n        int [][] ans = new int[k][2];\\n        int i = 0;\\n        while(pq.size() > 0){\\n            double val = pq.poll();\\n            if(map.containsKey(val)){\\n                List<Integer> al = map.get(val);\\n                for(int idx : al){\\n                    int [] point = points[idx];\\n                    ans[i++] = point;\\n                }\\n            }\\n            \\n            map.remove(val);\\n        }\\n        return ans;\\n    }\\n    private double helper(int x, int y){\\n        int x1 = Math.abs(x - 0);\\n        int y1 = Math.abs(y - 0);\\n        x1 *= x1;\\n        y1 *= y1;\\n        double ans = Math.sqrt(x1 + y1);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2732072,
                "title": "c-solution-maxheap",
                "content": "**UPVOTE IF IT HELPS U**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<vector<int>> v;\\n        priority_queue<pair<int,pair<int,int>>> pq;\\n        for(int i=0;i<points.size();i++){\\n            int sq = points[i][0]*points[i][0]  + points[i][1]*points[i][1];\\n            pq.push({sq,{points[i][0],points[i][1]}});\\n        }\\n        int n = points.size()-k;\\n        \\n        while(n--){\\n            pq.pop();\\n        }\\n        while(!pq.empty()){\\n            pair<int,pair<int,int>> p = pq.top();\\n            pq.pop();\\n            vector<int> ans = {p.second.first,p.second.second};\\n            v.push_back(ans);\\n        }\\n        \\n        return v;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<vector<int>> v;\\n        priority_queue<pair<int,pair<int,int>>> pq;\\n        for(int i=0;i<points.size();i++){\\n            int sq = points[i][0]*points[i][0]  + points[i][1]*points[i][1];\\n            pq.push({sq,{points[i][0],points[i][1]}});\\n        }\\n        int n = points.size()-k;\\n        \\n        while(n--){\\n            pq.pop();\\n        }\\n        while(!pq.empty()){\\n            pair<int,pair<int,int>> p = pq.top();\\n            pq.pop();\\n            vector<int> ans = {p.second.first,p.second.second};\\n            v.push_back(ans);\\n        }\\n        \\n        return v;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2721909,
                "title": "c-priority-queue-cleanest-code",
                "content": "```\\n#define pii pair<int,int>\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        priority_queue<pair<int,pii>> pq;//max priority queue so that besi durot thaka point tu agot thake in the priorirty queue\\n        for(int i=0;i<points.size();i++){\\n            int d=points[i][0]*points[i][0]+points[i][1]*points[i][1];\\n            pq.push(make_pair(d,make_pair(points[i][0],points[i][1])));\\n            if(pq.size()>k){\\n                pq.pop();\\n            }\\n        }\\n        vector<vector<int>> res;\\n        while(pq.empty()==false){\\n            auto it=pq.top();\\n            pq.pop();\\n            res.push_back(vector<int> {it.second.first,it.second.second});\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define pii pair<int,int>\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        priority_queue<pair<int,pii>> pq;//max priority queue so that besi durot thaka point tu agot thake in the priorirty queue\\n        for(int i=0;i<points.size();i++){\\n            int d=points[i][0]*points[i][0]+points[i][1]*points[i][1];\\n            pq.push(make_pair(d,make_pair(points[i][0],points[i][1])));\\n            if(pq.size()>k){\\n                pq.pop();\\n            }\\n        }\\n        vector<vector<int>> res;\\n        while(pq.empty()==false){\\n            auto it=pq.top();\\n            pq.pop();\\n            res.push_back(vector<int> {it.second.first,it.second.second});\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661379,
                "title": "typescript-generalized-heap-yields-o-nlogk",
                "content": "# Goal\\nThe goal is to get the K closest points to origin. This means that we need to know two things: the distance of each point from origin, and how the distance of a point compares to distances of other points in the list.\\n\\n# Problem\\nWhat are our potential options?\\n1. Perhaps calculate the distance of each point, and sort the points by the distance? -> We\\'d end up doing unnecessary work when we only care about the first k elements. we don\\'t care about the order of the elements other than the first k elemtns.\\n2. Perhaps calculate the distance of each point, and use a map to associate the distance to each point? -> This won\\'t work because there could be multiple points with the same distance.\\n3. Perhaps calculate the distance of each point, and use a HashMap to keep track of all points and their distance? -> This has the same problem as the sorting case. The entries will need to be sorted by the distance.\\n\\nWhat is the problem? The problem is that we do not want to do unnecessary work when the amount of work is known (K).\\n\\n# Solution\\nWe only want to know the first K ones with the least distance. Given the Min/Max Heap excels at keeping elements in order as data is entered/removed, with some logic a heap can serve the first k mim/max values.\\n\\nThis solution uses a generalized heap. The benefit of a generalized solution is that it is trivial to change the comparison logic (i.e. K farthest points from origin). The comparison logic is injected into the class via the constructor.\\n```typescript\\ninterface IHeap<T> {\\n  get size(): number;\\n  offer(e: T): void;\\n  poll(): T;\\n}\\nclass Heap<T> implements IHeap<T> {\\n  private _items: T[];\\n  private _compare: (t1: T, t2: T) => boolean;\\n  \\n  constructor(compare: (t1: T, t2: T) => boolean) {\\n    this._items = [];\\n    this._compare = compare;\\n  }\\n\\n  public get size() {\\n    return this._items.length;\\n  }\\n\\n  private leftChildIndexOf(parentIndex: number): number { return 2 * parentIndex + 1; }\\n  private rightChildIndexOf(parentIndex: number): number { return 2 * parentIndex + 2; }\\n  private parentIndexOf(childIndex: number): number { return Math.floor((childIndex - 1) / 2); }\\n\\n  private hasLeftChild(index: number): boolean { return this.leftChildIndexOf(index) < this.size; }\\n  private hasRightChild(index: number): boolean { return this.rightChildIndexOf(index) < this.size; }\\n  private hasParent(index: number): boolean { return this.parentIndexOf(index) >= 0; }\\n\\n  private leftChildOf(index: number): T { return this._items[this.leftChildIndexOf(index)]; }\\n  private rightChildOf(index: number): T { return this._items[this.rightChildIndexOf(index)]; }\\n  private parentOf(index: number): T { return this._items[this.parentIndexOf(index)]; }\\n\\n  private swap(indexOne: number, indexTwo: number): void {\\n    const temp = this._items[indexOne];\\n    this._items[indexOne] = this._items[indexTwo];\\n    this._items[indexTwo] = temp;\\n  }\\n\\n  private heapifyDown(): void {\\n    let index = 0;\\n    while (this.hasLeftChild(index)) {\\n      let smallerChildIndex = this.leftChildIndexOf(index);\\n      if (this.hasRightChild(index) && this._compare(this.leftChildOf(index), this.rightChildOf(index))) {\\n        smallerChildIndex = this.rightChildIndexOf(index);\\n      }\\n      if (this._compare(this._items[smallerChildIndex], this._items[index])) {\\n        break;\\n      }\\n      else {\\n        this.swap(index, smallerChildIndex);\\n      }\\n      index = smallerChildIndex;\\n    }\\n  }\\n  public poll(): T {\\n    if (this.size === 0) throw new Error(\"Empty heap.\");\\n    if (this.size === 1) {\\n      return this._items.pop()!; \\n    }\\n    const item = this._items[0];\\n    this._items[0] = this._items.pop()!;\\n    this.heapifyDown();\\n    return item;\\n  }\\n\\n  private heapifyUp(): void {\\n    let index = this.size - 1;\\n    while (this.hasParent(index) && this._compare(this.parentOf(index), this._items[index])) {\\n      this.swap(this.parentIndexOf(index), index);\\n      index = this.parentIndexOf(index);\\n    }\\n  }\\n  public offer(t: T) {\\n    this._items.push(t);\\n    this.heapifyUp();\\n  }\\n};\\n```\\n\\nNow the algorithm can use the above heap to return the K closest points from origin.\\n```typescript\\nconst distance = (p: number[]) => {\\n  return p[0] * p[0] + p[1] * p[1];\\n}\\nconst compare = (p1: number[], p2: number[]) => {\\n  return distance(p2) > distance(p1); // max heap\\n};\\n\\nfunction kClosest(points: number[][], k: number): number[][] {\\n    const result = [];\\n    const minHeap = new Heap(compare);\\n    for (const p of points) {\\n        minHeap.offer(p);\\n        if (minHeap.size > k) {\\n            minHeap.poll();\\n        }\\n    }\\n    while (k > 0) {\\n        result.push(minHeap.poll());\\n        k--;\\n    }\\n    return result;\\n};\\n```\\n\\nThe reason for the max heap and the polling is that the heap\\'s size should never exceed K. As each point is offered to the heap, polling the max distance item if the heap size is greater than K guarantees that the heap will maintain the K least distanced points (closest from origin).",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```typescript\\ninterface IHeap<T> {\\n  get size(): number;\\n  offer(e: T): void;\\n  poll(): T;\\n}\\nclass Heap<T> implements IHeap<T> {\\n  private _items: T[];\\n  private _compare: (t1: T, t2: T) => boolean;\\n  \\n  constructor(compare: (t1: T, t2: T) => boolean) {\\n    this._items = [];\\n    this._compare = compare;\\n  }\\n\\n  public get size() {\\n    return this._items.length;\\n  }\\n\\n  private leftChildIndexOf(parentIndex: number): number { return 2 * parentIndex + 1; }\\n  private rightChildIndexOf(parentIndex: number): number { return 2 * parentIndex + 2; }\\n  private parentIndexOf(childIndex: number): number { return Math.floor((childIndex - 1) / 2); }\\n\\n  private hasLeftChild(index: number): boolean { return this.leftChildIndexOf(index) < this.size; }\\n  private hasRightChild(index: number): boolean { return this.rightChildIndexOf(index) < this.size; }\\n  private hasParent(index: number): boolean { return this.parentIndexOf(index) >= 0; }\\n\\n  private leftChildOf(index: number): T { return this._items[this.leftChildIndexOf(index)]; }\\n  private rightChildOf(index: number): T { return this._items[this.rightChildIndexOf(index)]; }\\n  private parentOf(index: number): T { return this._items[this.parentIndexOf(index)]; }\\n\\n  private swap(indexOne: number, indexTwo: number): void {\\n    const temp = this._items[indexOne];\\n    this._items[indexOne] = this._items[indexTwo];\\n    this._items[indexTwo] = temp;\\n  }\\n\\n  private heapifyDown(): void {\\n    let index = 0;\\n    while (this.hasLeftChild(index)) {\\n      let smallerChildIndex = this.leftChildIndexOf(index);\\n      if (this.hasRightChild(index) && this._compare(this.leftChildOf(index), this.rightChildOf(index))) {\\n        smallerChildIndex = this.rightChildIndexOf(index);\\n      }\\n      if (this._compare(this._items[smallerChildIndex], this._items[index])) {\\n        break;\\n      }\\n      else {\\n        this.swap(index, smallerChildIndex);\\n      }\\n      index = smallerChildIndex;\\n    }\\n  }\\n  public poll(): T {\\n    if (this.size === 0) throw new Error(\"Empty heap.\");\\n    if (this.size === 1) {\\n      return this._items.pop()!; \\n    }\\n    const item = this._items[0];\\n    this._items[0] = this._items.pop()!;\\n    this.heapifyDown();\\n    return item;\\n  }\\n\\n  private heapifyUp(): void {\\n    let index = this.size - 1;\\n    while (this.hasParent(index) && this._compare(this.parentOf(index), this._items[index])) {\\n      this.swap(this.parentIndexOf(index), index);\\n      index = this.parentIndexOf(index);\\n    }\\n  }\\n  public offer(t: T) {\\n    this._items.push(t);\\n    this.heapifyUp();\\n  }\\n};\\n```\n```typescript\\nconst distance = (p: number[]) => {\\n  return p[0] * p[0] + p[1] * p[1];\\n}\\nconst compare = (p1: number[], p2: number[]) => {\\n  return distance(p2) > distance(p1); // max heap\\n};\\n\\nfunction kClosest(points: number[][], k: number): number[][] {\\n    const result = [];\\n    const minHeap = new Heap(compare);\\n    for (const p of points) {\\n        minHeap.offer(p);\\n        if (minHeap.size > k) {\\n            minHeap.poll();\\n        }\\n    }\\n    while (k > 0) {\\n        result.push(minHeap.poll());\\n        k--;\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2581563,
                "title": "sorting-javascript-solution-top-97-speed-200-ms",
                "content": "### Solution:\\n```js\\n/**\\n * @param {number[][]} points\\n * @param {number} k\\n * @return {number[][]}\\n */\\n\\nconst dist = (point) => {\\n  return point[0] * point[0] + point[1] * point[1];\\n}\\n\\nvar kClosest = function(points, k) {\\n  const n = points.length;\\n  let map = [];\\n\\n  for (let i = 0; i < n; ++i) {\\n    map.push({\\n      distance: dist(points[i]),\\n      points: points[i]\\n    })\\n  }\\n  map.sort((a, b) => a.distance - b.distance);\\n    \\n  let ans = [];\\n  for (let j = 0; j < k; j++) {\\n      ans.push(map[j].points)\\n  }\\n  return k === n ? points : ans\\n};\\n```\\n\\n### LeetCode Output\\nRuntime: **200 ms**, faster than **97.15%** of JavaScript online submissions for K Closest Points to Origin.\\nMemory Usage: **55.8 MB**, less than **93.10%** of JavaScript online submissions for K Closest Points to Origin.\\n\\n[Link to Submission](https://leetcode.com/submissions/detail/800873393/)",
                "solutionTags": [
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```js\\n/**\\n * @param {number[][]} points\\n * @param {number} k\\n * @return {number[][]}\\n */\\n\\nconst dist = (point) => {\\n  return point[0] * point[0] + point[1] * point[1];\\n}\\n\\nvar kClosest = function(points, k) {\\n  const n = points.length;\\n  let map = [];\\n\\n  for (let i = 0; i < n; ++i) {\\n    map.push({\\n      distance: dist(points[i]),\\n      points: points[i]\\n    })\\n  }\\n  map.sort((a, b) => a.distance - b.distance);\\n    \\n  let ans = [];\\n  for (let j = 0; j < k; j++) {\\n      ans.push(map[j].points)\\n  }\\n  return k === n ? points : ans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2105274,
                "title": "c-easy-max-heap-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\ttypedef vector<int> v;\\n\\n\\tvector<vector<int>> kClosest(vector<vector<int>>& p, int k) {\\n\\t\\tpriority_queue<pair<int, v>> maxh;\\n\\t\\tfor (auto e : p) {\\n\\t\\t\\tint distance = e[0] * e[0] + e[1] * e[1];\\n\\t\\t\\tmaxh.push({distance, e});\\n\\t\\t\\tif (maxh.size() > k) maxh.pop();\\n\\t\\t}\\n\\t\\tvector<vector<int>> ans;\\n\\t\\twhile (!maxh.empty()) {\\n\\t\\t\\tans.push_back(maxh.top().second);\\n            maxh.pop();\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\ttypedef vector<int> v;\\n\\n\\tvector<vector<int>> kClosest(vector<vector<int>>& p, int k) {\\n\\t\\tpriority_queue<pair<int, v>> maxh;\\n\\t\\tfor (auto e : p) {\\n\\t\\t\\tint distance = e[0] * e[0] + e[1] * e[1];\\n\\t\\t\\tmaxh.push({distance, e});\\n\\t\\t\\tif (maxh.size() > k) maxh.pop();\\n\\t\\t}\\n\\t\\tvector<vector<int>> ans;\\n\\t\\twhile (!maxh.empty()) {\\n\\t\\t\\tans.push_back(maxh.top().second);\\n            maxh.pop();\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2060892,
                "title": "solution-using-map-time-complexity-o-n-log-n-space-complexity-o-n",
                "content": "```\\n vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        map<int, vector<pair<int, int>>> mp;\\n        vector<vector<int>> ans;\\n        for(int i=0; i<points.size(); i++) {\\n            int x = points[i][0];\\n            int y = points[i][1];\\n            int dis = x*x + y*y;\\n            mp[dis].push_back({x, y});\\n        }\\n        for(auto &i:mp) {\\n            for(auto &nu:i.second){\\n               if(!k) break;\\n                vector<int> temp;\\n                temp.push_back(nu.first);\\n                temp.push_back(nu.second);\\n                ans.push_back(temp);\\n                k--; \\n            }\\n            \\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        map<int, vector<pair<int, int>>> mp;\\n        vector<vector<int>> ans;\\n        for(int i=0; i<points.size(); i++) {\\n            int x = points[i][0];\\n            int y = points[i][1];\\n            int dis = x*x + y*y;\\n            mp[dis].push_back({x, y});\\n        }\\n        for(auto &i:mp) {\\n            for(auto &nu:i.second){\\n               if(!k) break;\\n                vector<int> temp;\\n                temp.push_back(nu.first);\\n                temp.push_back(nu.second);\\n                ans.push_back(temp);\\n                k--; \\n            }\\n            \\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1648926,
                "title": "python3-o-n-klogn-time-o-n-space-3-lines-using-heapify-heappop",
                "content": "**Time Complexity Explanation:** We start by iterating through all the points to get the distance, which is O(n). Then we heapify which is in fact an O(n) operation, and more information on the algorithm can be found [here](https://stackoverflow.com/questions/9755721/how-can-building-a-heap-be-on-time-complexity). What heapify does is that it builds the min heap of size n that we\\'re going to need. Every heappop operation is logn since the heap is of size n. But we heappop k times, and thus the time complexity of that would be O(klogn). Overall the time complexity would be O(n + klogn)\\n\\nBelow is the code, please let me know if you have any questions!\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        points = [(p[0]**2 + p[1]**2, p) for p in points]\\n        heapify(points)\\n        return [heappop(points)[1] for _ in range(k)]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        points = [(p[0]**2 + p[1]**2, p) for p in points]\\n        heapify(points)\\n        return [heappop(points)[1] for _ in range(k)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1648102,
                "title": "golang",
                "content": "```\\nfunc kClosest(points [][]int, k int) [][]int {\\n    sort.Slice(points, func(i,j int) bool {\\n\\t\\treturn points[i][0] * points[i][0] + points[i][1] * points[i][1] <\\n\\t\\t\\tpoints[j][0] * points[j][0] + points[j][1] * points[j][1]\\n\\t})\\n\\treturn points[:k]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc kClosest(points [][]int, k int) [][]int {\\n    sort.Slice(points, func(i,j int) bool {\\n\\t\\treturn points[i][0] * points[i][0] + points[i][1] * points[i][1] <\\n\\t\\t\\tpoints[j][0] * points[j][0] + points[j][1] * points[j][1]\\n\\t})\\n\\treturn points[:k]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1590753,
                "title": "concise-modernc-stl",
                "content": "```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        auto sd = [](vector<int>& point){return point[0]*point[0] + point[1]*point[1];};\\n        sort(points.begin(),points.end(),[sd](vector<int>& a,vector<int>& b){return sd(a)<sd(b);});\\n        return vector<vector<int>>(points.begin(),points.begin()+k);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        auto sd = [](vector<int>& point){return point[0]*point[0] + point[1]*point[1];};\\n        sort(points.begin(),points.end(),[sd](vector<int>& a,vector<int>& b){return sd(a)<sd(b);});\\n        return vector<vector<int>>(points.begin(),points.begin()+k);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1567322,
                "title": "python-oneline-quick-and-easy-99-runtime-and-memory",
                "content": "```\\n        return sorted(points, key=lambda x:(x[0]*x[0]+x[1]*x[1]))[:k]\\n",
                "solutionTags": [],
                "code": "```\\n        return sorted(points, key=lambda x:(x[0]*x[0]+x[1]*x[1]))[:k]\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1535036,
                "title": "c-easy-to-understand-fast-and-effiecient",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\nclass Solution {\\npublic:\\n    bool static comp(vector<int> &a,vector<int> &b)\\n    {\\n        return a[2]<b[2];\\n    }\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<vector<int>> ans(k);\\n        for(int i=0;i<points.size();i++)\\n        {\\n            int d=points[i][0]*points[i][0]+points[i][1]*points[i][1];\\n            points[i].push_back(d);\\n        }\\n        sort(points.begin(),points.end(),comp);\\n        for(int i=0;i<k;i++)\\n        {\\n            ans[i].push_back(points[i][0]);\\n            ans[i].push_back(points[i][1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool static comp(vector<int> &a,vector<int> &b)\\n    {\\n        return a[2]<b[2];\\n    }\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<vector<int>> ans(k);\\n        for(int i=0;i<points.size();i++)\\n        {\\n            int d=points[i][0]*points[i][0]+points[i][1]*points[i][1];\\n            points[i].push_back(d);\\n        }\\n        sort(points.begin(),points.end(),comp);\\n        for(int i=0;i<k;i++)\\n        {\\n            ans[i].push_back(points[i][0]);\\n            ans[i].push_back(points[i][1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1489763,
                "title": "java-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        int[][] closest = new int[k][2];\\n        \\n        // If there are no points or k is 0 there are no closest points\\n        if (points.length  == 0 || k == 0 || k > points.length) return closest;\\n        \\n        // Insert into heap based on the distance to the origin (less distance has high priority);\\n        PriorityQueue<int[]> min_heap = new PriorityQueue<>((p1, p2) -> Integer.compare(getDist(p2), getDist(p1)));\\n        \\n        // Start inserting points into heap\\n        for (int[] point: points) {\\n            min_heap.add(point);\\n            \\n            // If the size is greater than k, poll\\n            if (min_heap.size() > k) {\\n                min_heap.poll();\\n            }\\n        }\\n        \\n        // Finally insert k points into the result\\n        for (int i = 0; i < closest.length; i++) {\\n            closest[i] = min_heap.poll();\\n        }\\n        return closest;\\n    }\\n    \\n    public int getDist(int[] point) {\\n        return (point[0] * point[0]) + (point[1] * point[1]);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        int[][] closest = new int[k][2];\\n        \\n        // If there are no points or k is 0 there are no closest points\\n        if (points.length  == 0 || k == 0 || k > points.length) return closest;\\n        \\n        // Insert into heap based on the distance to the origin (less distance has high priority);\\n        PriorityQueue<int[]> min_heap = new PriorityQueue<>((p1, p2) -> Integer.compare(getDist(p2), getDist(p1)));\\n        \\n        // Start inserting points into heap\\n        for (int[] point: points) {\\n            min_heap.add(point);\\n            \\n            // If the size is greater than k, poll\\n            if (min_heap.size() > k) {\\n                min_heap.poll();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1432341,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n\\t\\tvector<vector<int>> kClosest(vector<vector<int>>& A, int k) {\\n        using T = vector<int>;\\n        std::sort(A.begin(), A.end(), [](const T& a, const T& b) {\\n\\t\\t    // Sqrt is redundant, and since we\\'re comparing\\n\\t\\t\\t// with the origin one of the points is always 0,0.\\n\\t\\t\\t// This simplifies the formula to y1^2 + x1^2\\n            int da = a[0]*a[0] + a[1]*a[1];\\n            int db = b[0]*b[0] + b[1]*b[1];\\n            return da < db;\\n        });\\n        \\n        if (k > A.size()) {\\n            return A;\\n        }\\n        A.resize(k);\\n        return A;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\t\\tvector<vector<int>> kClosest(vector<vector<int>>& A, int k) {\\n        using T = vector<int>;\\n        std::sort(A.begin(), A.end(), [](const T& a, const T& b) {\\n\\t\\t    // Sqrt is redundant, and since we\\'re comparing\\n\\t\\t\\t// with the origin one of the points is always 0,0.\\n\\t\\t\\t// This simplifies the formula to y1^2 + x1^2\\n            int da = a[0]*a[0] + a[1]*a[1];\\n            int db = b[0]*b[0] + b[1]*b[1];\\n            return da < db;\\n        });\\n        \\n        if (k > A.size()) {\\n            return A;\\n        }\\n        A.resize(k);\\n        return A;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1428237,
                "title": "using-inbuilt-sort-in-stl-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int> a,vector<int> b){\\n        int c = (a[0]*a[0]) + (a[1]*a[1]);\\n        int d = (b[0]*b[0]) + (b[1]*b[1]);\\n        if(c<d){\\n            return true;\\n        }\\n        return false;\\n    }\\n    vector<vector<int>> kClosest(vector<vector<int>>& v, int k) {\\n        sort(v.begin(),v.end(),cmp);\\n        vector<vector<int>> ans;\\n        for(int i=0;i<k;i++){\\n            ans.push_back(v[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int> a,vector<int> b){\\n        int c = (a[0]*a[0]) + (a[1]*a[1]);\\n        int d = (b[0]*b[0]) + (b[1]*b[1]);\\n        if(c<d){\\n            return true;\\n        }\\n        return false;\\n    }\\n    vector<vector<int>> kClosest(vector<vector<int>>& v, int k) {\\n        sort(v.begin(),v.end(),cmp);\\n        vector<vector<int>> ans;\\n        for(int i=0;i<k;i++){\\n            ans.push_back(v[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1323389,
                "title": "runtime-99-77-of-python3-memory-less-than-88-72",
                "content": "```python\\nfrom math import dist\\n\\n\\nclass Solution:\\n    @staticmethod\\n    def kClosest(points: list[list[int]], k: int) -> list[list[int]]:\\n        if k >= len(points):\\n            return points\\n        return sorted(points, key=lambda i: dist(i, [0, 0]))[:k]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nfrom math import dist\\n\\n\\nclass Solution:\\n    @staticmethod\\n    def kClosest(points: list[list[int]], k: int) -> list[list[int]]:\\n        if k >= len(points):\\n            return points\\n        return sorted(points, key=lambda i: dist(i, [0, 0]))[:k]\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565273,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/k-closest-points-to-origin/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort with Custom Comparator\n\n  \n**Approach 2:** Max Heap or Max Priority Queue\n\n  \n**Approach 3:** Binary Search\n\n  \n**Approach 4:** QuickSelect\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GavinBelson",
                        "content": "For those of you who got asked this question by facebook, do they make you do the quick select solution since it is the best asymptotic O(n) on average, or is a \"sorting\" solution of O(nlogn) acceptable?  I\\'m sure it might vary by interviewer and by the level you\\'re applying to, but I am curious how this situation may play out in real life."
                    },
                    {
                        "username": "neo9729",
                        "content": "Don\\'t rush to solve the problem. Read carefully and euclidean distance should be considered as double"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I just used squares - with an int"
                    },
                    {
                        "username": "delanoi",
                        "content": "nice observation! but if you are only using the value for sorting purpose, we don\\'t really need to do the square root tho, without it, the sorting result should still be correct"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guys who added 85-87 testcases are true gentleman !!"
                    },
                    {
                        "username": "gbiems",
                        "content": "If you\\'re using python and don\\'t about heappushpop, definitely look it up. Greatly simplifies the code. \\n\\nI came across this question when I decided to review some of my early leetcode solutions now that I have a better sense of how to solve these problems. Looks like when I first tried this problem, I processed all points and sorted, a solution which does work, but is much slower.\\n\\nThis time around, I went with a heap, but I didn\\'t know about heappushpop, so my code was kind of complicated. \\n\\nFinally looked at solutions and learned something. I didn\\'t know about heappushpop. Good to know. \\n\\n "
                    },
                    {
                        "username": "cannellajs2",
                        "content": "`\\nstd::ios::sync_with_stdio(false);std::cin.tie(NULL);std::cout.tie(NULL); \\n`\\nWas wondering what this was on the fastest submission. Simply added it at the top of my function and it decreased my runtime.\\nUSER BEWARE:\\nFrom what I just read about this it allows C++ IOs to not have to be Synchronized to C IOs. This can allow it to run faster but can cause real issues if you use both stdio and cin/cout. Also cin and cout will be desynchronized.\\nFor better description look here: https://stackoverflow.com/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull"
                    },
                    {
                        "username": "peterx123",
                        "content": "Using sqrt and casting to int definitly would give wrong answer. The formla given by the description is a bait."
                    },
                    {
                        "username": "Kaltu",
                        "content": "how on earth the sorting solution beats 99.87%\\nI was expecting a TLE, LeetCode\\uD83E\\uDD23\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(points, key=lambda x: x[0] * x[0] + x[1] * x[1])[:k]\\n```"
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "BlackPantha007",
                        "content": "Hi all, please can someone help point out the improvement I need to make to this code to get it to pass all tests cases (it is passing 77/87 tests cases)?\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        // maxHeap to store values base on how close it\\'s distance is from 0.\\n        PriorityQueue<int[]> heap = new PriorityQueue<>(\\n            (arr1, arr2) -> computeDistance(arr2) - computeDistance(arr1)\\n        );\\n            \\n        for (int[] point : points) {\\n            heap.offer(point);\\n            if (heap.size() > k) {\\n                heap.poll();\\n            }\\n        }\\n            \\n        int[][] result = new int[k][2];\\n        \\n        for (int i = 0; i < k; i++) {\\n            result[i][0] = heap.peek()[0];\\n            result[i][1] = heap.poll()[1];\\n        }\\n            \\n        return result;\\n    }\\n    \\n    private int computeDistance(int[] distance) {\\n        return (int) Math.sqrt(distance[0] * distance[0] + distance[1] * distance[1]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "dojoce",
                        "content": "You need to compare the distances as a doube not an int. Using\n\nQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingDouble(point -> computeDistance(point)));"
                    },
                    {
                        "username": "barrett7212",
                        "content": "I think it\\'s because you are computing distance as an `int`, which is truncating your calculated values. Switch to a `double` and it should work."
                    },
                    {
                        "username": "ajinkyaw",
                        "content": "Below is my code and is failing for [[0,1],[1,0]] case which won\\'t satisfy unique answer condition, also when inserted in custom testcase it stands on same claim as me but it\\'s failing while submitting, any help?\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        unordered_map<int,pair<int,int>> hmap;\\n        priority_queue<pair<int,pair<int,int>>> maxh;\\n        int distance,x,y;\\n        pair<int,int> temp;\\n        for(int i=0;i<points.size();i++){\\n            x = points[i][0]; y = points[i][1];\\n            distance=pow(x,2)+pow(y,2);\\n            temp.first=x;\\n            temp.second=y;\\n            hmap.insert({distance,temp});\\n        }\\n        for(auto itr=hmap.begin();itr!=hmap.end();itr++){\\n            maxh.push({itr->first,itr->second});\\n            if(maxh.size()>k)\\n                maxh.pop();\\n        }\\n        vector<vector<int>> ans(maxh.size(), vector<int>(2,0));\\n        int i=0;\\n        while(maxh.empty()!=1){\\n            ans[i][0]=maxh.top().second.first;\\n            ans[i][1]=maxh.top().second.second;\\n            maxh.pop();i++;\\n        }\\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "aman_online67",
                        "content": "[@THEb0ss34](/THEb0ss34)  distances are same in both the vectors. so it can differentiate between them."
                    },
                    {
                        "username": "vicente3j",
                        "content": "[@THEb0ss34](/THEb0ss34) Yeah I got the same problem. I passed 83/87 test cases but this one is giving me trouble"
                    },
                    {
                        "username": "THEb0ss34",
                        "content": "I have the same problem not sure what they mean!"
                    }
                ]
            },
            {
                "id": 1569847,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/k-closest-points-to-origin/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort with Custom Comparator\n\n  \n**Approach 2:** Max Heap or Max Priority Queue\n\n  \n**Approach 3:** Binary Search\n\n  \n**Approach 4:** QuickSelect\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GavinBelson",
                        "content": "For those of you who got asked this question by facebook, do they make you do the quick select solution since it is the best asymptotic O(n) on average, or is a \"sorting\" solution of O(nlogn) acceptable?  I\\'m sure it might vary by interviewer and by the level you\\'re applying to, but I am curious how this situation may play out in real life."
                    },
                    {
                        "username": "neo9729",
                        "content": "Don\\'t rush to solve the problem. Read carefully and euclidean distance should be considered as double"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I just used squares - with an int"
                    },
                    {
                        "username": "delanoi",
                        "content": "nice observation! but if you are only using the value for sorting purpose, we don\\'t really need to do the square root tho, without it, the sorting result should still be correct"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guys who added 85-87 testcases are true gentleman !!"
                    },
                    {
                        "username": "gbiems",
                        "content": "If you\\'re using python and don\\'t about heappushpop, definitely look it up. Greatly simplifies the code. \\n\\nI came across this question when I decided to review some of my early leetcode solutions now that I have a better sense of how to solve these problems. Looks like when I first tried this problem, I processed all points and sorted, a solution which does work, but is much slower.\\n\\nThis time around, I went with a heap, but I didn\\'t know about heappushpop, so my code was kind of complicated. \\n\\nFinally looked at solutions and learned something. I didn\\'t know about heappushpop. Good to know. \\n\\n "
                    },
                    {
                        "username": "cannellajs2",
                        "content": "`\\nstd::ios::sync_with_stdio(false);std::cin.tie(NULL);std::cout.tie(NULL); \\n`\\nWas wondering what this was on the fastest submission. Simply added it at the top of my function and it decreased my runtime.\\nUSER BEWARE:\\nFrom what I just read about this it allows C++ IOs to not have to be Synchronized to C IOs. This can allow it to run faster but can cause real issues if you use both stdio and cin/cout. Also cin and cout will be desynchronized.\\nFor better description look here: https://stackoverflow.com/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull"
                    },
                    {
                        "username": "peterx123",
                        "content": "Using sqrt and casting to int definitly would give wrong answer. The formla given by the description is a bait."
                    },
                    {
                        "username": "Kaltu",
                        "content": "how on earth the sorting solution beats 99.87%\\nI was expecting a TLE, LeetCode\\uD83E\\uDD23\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(points, key=lambda x: x[0] * x[0] + x[1] * x[1])[:k]\\n```"
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "BlackPantha007",
                        "content": "Hi all, please can someone help point out the improvement I need to make to this code to get it to pass all tests cases (it is passing 77/87 tests cases)?\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        // maxHeap to store values base on how close it\\'s distance is from 0.\\n        PriorityQueue<int[]> heap = new PriorityQueue<>(\\n            (arr1, arr2) -> computeDistance(arr2) - computeDistance(arr1)\\n        );\\n            \\n        for (int[] point : points) {\\n            heap.offer(point);\\n            if (heap.size() > k) {\\n                heap.poll();\\n            }\\n        }\\n            \\n        int[][] result = new int[k][2];\\n        \\n        for (int i = 0; i < k; i++) {\\n            result[i][0] = heap.peek()[0];\\n            result[i][1] = heap.poll()[1];\\n        }\\n            \\n        return result;\\n    }\\n    \\n    private int computeDistance(int[] distance) {\\n        return (int) Math.sqrt(distance[0] * distance[0] + distance[1] * distance[1]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "dojoce",
                        "content": "You need to compare the distances as a doube not an int. Using\n\nQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingDouble(point -> computeDistance(point)));"
                    },
                    {
                        "username": "barrett7212",
                        "content": "I think it\\'s because you are computing distance as an `int`, which is truncating your calculated values. Switch to a `double` and it should work."
                    },
                    {
                        "username": "ajinkyaw",
                        "content": "Below is my code and is failing for [[0,1],[1,0]] case which won\\'t satisfy unique answer condition, also when inserted in custom testcase it stands on same claim as me but it\\'s failing while submitting, any help?\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        unordered_map<int,pair<int,int>> hmap;\\n        priority_queue<pair<int,pair<int,int>>> maxh;\\n        int distance,x,y;\\n        pair<int,int> temp;\\n        for(int i=0;i<points.size();i++){\\n            x = points[i][0]; y = points[i][1];\\n            distance=pow(x,2)+pow(y,2);\\n            temp.first=x;\\n            temp.second=y;\\n            hmap.insert({distance,temp});\\n        }\\n        for(auto itr=hmap.begin();itr!=hmap.end();itr++){\\n            maxh.push({itr->first,itr->second});\\n            if(maxh.size()>k)\\n                maxh.pop();\\n        }\\n        vector<vector<int>> ans(maxh.size(), vector<int>(2,0));\\n        int i=0;\\n        while(maxh.empty()!=1){\\n            ans[i][0]=maxh.top().second.first;\\n            ans[i][1]=maxh.top().second.second;\\n            maxh.pop();i++;\\n        }\\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "aman_online67",
                        "content": "[@THEb0ss34](/THEb0ss34)  distances are same in both the vectors. so it can differentiate between them."
                    },
                    {
                        "username": "vicente3j",
                        "content": "[@THEb0ss34](/THEb0ss34) Yeah I got the same problem. I passed 83/87 test cases but this one is giving me trouble"
                    },
                    {
                        "username": "THEb0ss34",
                        "content": "I have the same problem not sure what they mean!"
                    }
                ]
            },
            {
                "id": 1736193,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/k-closest-points-to-origin/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort with Custom Comparator\n\n  \n**Approach 2:** Max Heap or Max Priority Queue\n\n  \n**Approach 3:** Binary Search\n\n  \n**Approach 4:** QuickSelect\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GavinBelson",
                        "content": "For those of you who got asked this question by facebook, do they make you do the quick select solution since it is the best asymptotic O(n) on average, or is a \"sorting\" solution of O(nlogn) acceptable?  I\\'m sure it might vary by interviewer and by the level you\\'re applying to, but I am curious how this situation may play out in real life."
                    },
                    {
                        "username": "neo9729",
                        "content": "Don\\'t rush to solve the problem. Read carefully and euclidean distance should be considered as double"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I just used squares - with an int"
                    },
                    {
                        "username": "delanoi",
                        "content": "nice observation! but if you are only using the value for sorting purpose, we don\\'t really need to do the square root tho, without it, the sorting result should still be correct"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guys who added 85-87 testcases are true gentleman !!"
                    },
                    {
                        "username": "gbiems",
                        "content": "If you\\'re using python and don\\'t about heappushpop, definitely look it up. Greatly simplifies the code. \\n\\nI came across this question when I decided to review some of my early leetcode solutions now that I have a better sense of how to solve these problems. Looks like when I first tried this problem, I processed all points and sorted, a solution which does work, but is much slower.\\n\\nThis time around, I went with a heap, but I didn\\'t know about heappushpop, so my code was kind of complicated. \\n\\nFinally looked at solutions and learned something. I didn\\'t know about heappushpop. Good to know. \\n\\n "
                    },
                    {
                        "username": "cannellajs2",
                        "content": "`\\nstd::ios::sync_with_stdio(false);std::cin.tie(NULL);std::cout.tie(NULL); \\n`\\nWas wondering what this was on the fastest submission. Simply added it at the top of my function and it decreased my runtime.\\nUSER BEWARE:\\nFrom what I just read about this it allows C++ IOs to not have to be Synchronized to C IOs. This can allow it to run faster but can cause real issues if you use both stdio and cin/cout. Also cin and cout will be desynchronized.\\nFor better description look here: https://stackoverflow.com/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull"
                    },
                    {
                        "username": "peterx123",
                        "content": "Using sqrt and casting to int definitly would give wrong answer. The formla given by the description is a bait."
                    },
                    {
                        "username": "Kaltu",
                        "content": "how on earth the sorting solution beats 99.87%\\nI was expecting a TLE, LeetCode\\uD83E\\uDD23\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(points, key=lambda x: x[0] * x[0] + x[1] * x[1])[:k]\\n```"
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "BlackPantha007",
                        "content": "Hi all, please can someone help point out the improvement I need to make to this code to get it to pass all tests cases (it is passing 77/87 tests cases)?\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        // maxHeap to store values base on how close it\\'s distance is from 0.\\n        PriorityQueue<int[]> heap = new PriorityQueue<>(\\n            (arr1, arr2) -> computeDistance(arr2) - computeDistance(arr1)\\n        );\\n            \\n        for (int[] point : points) {\\n            heap.offer(point);\\n            if (heap.size() > k) {\\n                heap.poll();\\n            }\\n        }\\n            \\n        int[][] result = new int[k][2];\\n        \\n        for (int i = 0; i < k; i++) {\\n            result[i][0] = heap.peek()[0];\\n            result[i][1] = heap.poll()[1];\\n        }\\n            \\n        return result;\\n    }\\n    \\n    private int computeDistance(int[] distance) {\\n        return (int) Math.sqrt(distance[0] * distance[0] + distance[1] * distance[1]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "dojoce",
                        "content": "You need to compare the distances as a doube not an int. Using\n\nQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingDouble(point -> computeDistance(point)));"
                    },
                    {
                        "username": "barrett7212",
                        "content": "I think it\\'s because you are computing distance as an `int`, which is truncating your calculated values. Switch to a `double` and it should work."
                    },
                    {
                        "username": "ajinkyaw",
                        "content": "Below is my code and is failing for [[0,1],[1,0]] case which won\\'t satisfy unique answer condition, also when inserted in custom testcase it stands on same claim as me but it\\'s failing while submitting, any help?\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        unordered_map<int,pair<int,int>> hmap;\\n        priority_queue<pair<int,pair<int,int>>> maxh;\\n        int distance,x,y;\\n        pair<int,int> temp;\\n        for(int i=0;i<points.size();i++){\\n            x = points[i][0]; y = points[i][1];\\n            distance=pow(x,2)+pow(y,2);\\n            temp.first=x;\\n            temp.second=y;\\n            hmap.insert({distance,temp});\\n        }\\n        for(auto itr=hmap.begin();itr!=hmap.end();itr++){\\n            maxh.push({itr->first,itr->second});\\n            if(maxh.size()>k)\\n                maxh.pop();\\n        }\\n        vector<vector<int>> ans(maxh.size(), vector<int>(2,0));\\n        int i=0;\\n        while(maxh.empty()!=1){\\n            ans[i][0]=maxh.top().second.first;\\n            ans[i][1]=maxh.top().second.second;\\n            maxh.pop();i++;\\n        }\\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "aman_online67",
                        "content": "[@THEb0ss34](/THEb0ss34)  distances are same in both the vectors. so it can differentiate between them."
                    },
                    {
                        "username": "vicente3j",
                        "content": "[@THEb0ss34](/THEb0ss34) Yeah I got the same problem. I passed 83/87 test cases but this one is giving me trouble"
                    },
                    {
                        "username": "THEb0ss34",
                        "content": "I have the same problem not sure what they mean!"
                    }
                ]
            },
            {
                "id": 1805030,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/k-closest-points-to-origin/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort with Custom Comparator\n\n  \n**Approach 2:** Max Heap or Max Priority Queue\n\n  \n**Approach 3:** Binary Search\n\n  \n**Approach 4:** QuickSelect\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GavinBelson",
                        "content": "For those of you who got asked this question by facebook, do they make you do the quick select solution since it is the best asymptotic O(n) on average, or is a \"sorting\" solution of O(nlogn) acceptable?  I\\'m sure it might vary by interviewer and by the level you\\'re applying to, but I am curious how this situation may play out in real life."
                    },
                    {
                        "username": "neo9729",
                        "content": "Don\\'t rush to solve the problem. Read carefully and euclidean distance should be considered as double"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I just used squares - with an int"
                    },
                    {
                        "username": "delanoi",
                        "content": "nice observation! but if you are only using the value for sorting purpose, we don\\'t really need to do the square root tho, without it, the sorting result should still be correct"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guys who added 85-87 testcases are true gentleman !!"
                    },
                    {
                        "username": "gbiems",
                        "content": "If you\\'re using python and don\\'t about heappushpop, definitely look it up. Greatly simplifies the code. \\n\\nI came across this question when I decided to review some of my early leetcode solutions now that I have a better sense of how to solve these problems. Looks like when I first tried this problem, I processed all points and sorted, a solution which does work, but is much slower.\\n\\nThis time around, I went with a heap, but I didn\\'t know about heappushpop, so my code was kind of complicated. \\n\\nFinally looked at solutions and learned something. I didn\\'t know about heappushpop. Good to know. \\n\\n "
                    },
                    {
                        "username": "cannellajs2",
                        "content": "`\\nstd::ios::sync_with_stdio(false);std::cin.tie(NULL);std::cout.tie(NULL); \\n`\\nWas wondering what this was on the fastest submission. Simply added it at the top of my function and it decreased my runtime.\\nUSER BEWARE:\\nFrom what I just read about this it allows C++ IOs to not have to be Synchronized to C IOs. This can allow it to run faster but can cause real issues if you use both stdio and cin/cout. Also cin and cout will be desynchronized.\\nFor better description look here: https://stackoverflow.com/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull"
                    },
                    {
                        "username": "peterx123",
                        "content": "Using sqrt and casting to int definitly would give wrong answer. The formla given by the description is a bait."
                    },
                    {
                        "username": "Kaltu",
                        "content": "how on earth the sorting solution beats 99.87%\\nI was expecting a TLE, LeetCode\\uD83E\\uDD23\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(points, key=lambda x: x[0] * x[0] + x[1] * x[1])[:k]\\n```"
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "BlackPantha007",
                        "content": "Hi all, please can someone help point out the improvement I need to make to this code to get it to pass all tests cases (it is passing 77/87 tests cases)?\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        // maxHeap to store values base on how close it\\'s distance is from 0.\\n        PriorityQueue<int[]> heap = new PriorityQueue<>(\\n            (arr1, arr2) -> computeDistance(arr2) - computeDistance(arr1)\\n        );\\n            \\n        for (int[] point : points) {\\n            heap.offer(point);\\n            if (heap.size() > k) {\\n                heap.poll();\\n            }\\n        }\\n            \\n        int[][] result = new int[k][2];\\n        \\n        for (int i = 0; i < k; i++) {\\n            result[i][0] = heap.peek()[0];\\n            result[i][1] = heap.poll()[1];\\n        }\\n            \\n        return result;\\n    }\\n    \\n    private int computeDistance(int[] distance) {\\n        return (int) Math.sqrt(distance[0] * distance[0] + distance[1] * distance[1]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "dojoce",
                        "content": "You need to compare the distances as a doube not an int. Using\n\nQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingDouble(point -> computeDistance(point)));"
                    },
                    {
                        "username": "barrett7212",
                        "content": "I think it\\'s because you are computing distance as an `int`, which is truncating your calculated values. Switch to a `double` and it should work."
                    },
                    {
                        "username": "ajinkyaw",
                        "content": "Below is my code and is failing for [[0,1],[1,0]] case which won\\'t satisfy unique answer condition, also when inserted in custom testcase it stands on same claim as me but it\\'s failing while submitting, any help?\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        unordered_map<int,pair<int,int>> hmap;\\n        priority_queue<pair<int,pair<int,int>>> maxh;\\n        int distance,x,y;\\n        pair<int,int> temp;\\n        for(int i=0;i<points.size();i++){\\n            x = points[i][0]; y = points[i][1];\\n            distance=pow(x,2)+pow(y,2);\\n            temp.first=x;\\n            temp.second=y;\\n            hmap.insert({distance,temp});\\n        }\\n        for(auto itr=hmap.begin();itr!=hmap.end();itr++){\\n            maxh.push({itr->first,itr->second});\\n            if(maxh.size()>k)\\n                maxh.pop();\\n        }\\n        vector<vector<int>> ans(maxh.size(), vector<int>(2,0));\\n        int i=0;\\n        while(maxh.empty()!=1){\\n            ans[i][0]=maxh.top().second.first;\\n            ans[i][1]=maxh.top().second.second;\\n            maxh.pop();i++;\\n        }\\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "aman_online67",
                        "content": "[@THEb0ss34](/THEb0ss34)  distances are same in both the vectors. so it can differentiate between them."
                    },
                    {
                        "username": "vicente3j",
                        "content": "[@THEb0ss34](/THEb0ss34) Yeah I got the same problem. I passed 83/87 test cases but this one is giving me trouble"
                    },
                    {
                        "username": "THEb0ss34",
                        "content": "I have the same problem not sure what they mean!"
                    }
                ]
            },
            {
                "id": 1881393,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/k-closest-points-to-origin/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort with Custom Comparator\n\n  \n**Approach 2:** Max Heap or Max Priority Queue\n\n  \n**Approach 3:** Binary Search\n\n  \n**Approach 4:** QuickSelect\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GavinBelson",
                        "content": "For those of you who got asked this question by facebook, do they make you do the quick select solution since it is the best asymptotic O(n) on average, or is a \"sorting\" solution of O(nlogn) acceptable?  I\\'m sure it might vary by interviewer and by the level you\\'re applying to, but I am curious how this situation may play out in real life."
                    },
                    {
                        "username": "neo9729",
                        "content": "Don\\'t rush to solve the problem. Read carefully and euclidean distance should be considered as double"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I just used squares - with an int"
                    },
                    {
                        "username": "delanoi",
                        "content": "nice observation! but if you are only using the value for sorting purpose, we don\\'t really need to do the square root tho, without it, the sorting result should still be correct"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guys who added 85-87 testcases are true gentleman !!"
                    },
                    {
                        "username": "gbiems",
                        "content": "If you\\'re using python and don\\'t about heappushpop, definitely look it up. Greatly simplifies the code. \\n\\nI came across this question when I decided to review some of my early leetcode solutions now that I have a better sense of how to solve these problems. Looks like when I first tried this problem, I processed all points and sorted, a solution which does work, but is much slower.\\n\\nThis time around, I went with a heap, but I didn\\'t know about heappushpop, so my code was kind of complicated. \\n\\nFinally looked at solutions and learned something. I didn\\'t know about heappushpop. Good to know. \\n\\n "
                    },
                    {
                        "username": "cannellajs2",
                        "content": "`\\nstd::ios::sync_with_stdio(false);std::cin.tie(NULL);std::cout.tie(NULL); \\n`\\nWas wondering what this was on the fastest submission. Simply added it at the top of my function and it decreased my runtime.\\nUSER BEWARE:\\nFrom what I just read about this it allows C++ IOs to not have to be Synchronized to C IOs. This can allow it to run faster but can cause real issues if you use both stdio and cin/cout. Also cin and cout will be desynchronized.\\nFor better description look here: https://stackoverflow.com/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull"
                    },
                    {
                        "username": "peterx123",
                        "content": "Using sqrt and casting to int definitly would give wrong answer. The formla given by the description is a bait."
                    },
                    {
                        "username": "Kaltu",
                        "content": "how on earth the sorting solution beats 99.87%\\nI was expecting a TLE, LeetCode\\uD83E\\uDD23\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(points, key=lambda x: x[0] * x[0] + x[1] * x[1])[:k]\\n```"
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "BlackPantha007",
                        "content": "Hi all, please can someone help point out the improvement I need to make to this code to get it to pass all tests cases (it is passing 77/87 tests cases)?\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        // maxHeap to store values base on how close it\\'s distance is from 0.\\n        PriorityQueue<int[]> heap = new PriorityQueue<>(\\n            (arr1, arr2) -> computeDistance(arr2) - computeDistance(arr1)\\n        );\\n            \\n        for (int[] point : points) {\\n            heap.offer(point);\\n            if (heap.size() > k) {\\n                heap.poll();\\n            }\\n        }\\n            \\n        int[][] result = new int[k][2];\\n        \\n        for (int i = 0; i < k; i++) {\\n            result[i][0] = heap.peek()[0];\\n            result[i][1] = heap.poll()[1];\\n        }\\n            \\n        return result;\\n    }\\n    \\n    private int computeDistance(int[] distance) {\\n        return (int) Math.sqrt(distance[0] * distance[0] + distance[1] * distance[1]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "dojoce",
                        "content": "You need to compare the distances as a doube not an int. Using\n\nQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingDouble(point -> computeDistance(point)));"
                    },
                    {
                        "username": "barrett7212",
                        "content": "I think it\\'s because you are computing distance as an `int`, which is truncating your calculated values. Switch to a `double` and it should work."
                    },
                    {
                        "username": "ajinkyaw",
                        "content": "Below is my code and is failing for [[0,1],[1,0]] case which won\\'t satisfy unique answer condition, also when inserted in custom testcase it stands on same claim as me but it\\'s failing while submitting, any help?\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        unordered_map<int,pair<int,int>> hmap;\\n        priority_queue<pair<int,pair<int,int>>> maxh;\\n        int distance,x,y;\\n        pair<int,int> temp;\\n        for(int i=0;i<points.size();i++){\\n            x = points[i][0]; y = points[i][1];\\n            distance=pow(x,2)+pow(y,2);\\n            temp.first=x;\\n            temp.second=y;\\n            hmap.insert({distance,temp});\\n        }\\n        for(auto itr=hmap.begin();itr!=hmap.end();itr++){\\n            maxh.push({itr->first,itr->second});\\n            if(maxh.size()>k)\\n                maxh.pop();\\n        }\\n        vector<vector<int>> ans(maxh.size(), vector<int>(2,0));\\n        int i=0;\\n        while(maxh.empty()!=1){\\n            ans[i][0]=maxh.top().second.first;\\n            ans[i][1]=maxh.top().second.second;\\n            maxh.pop();i++;\\n        }\\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "aman_online67",
                        "content": "[@THEb0ss34](/THEb0ss34)  distances are same in both the vectors. so it can differentiate between them."
                    },
                    {
                        "username": "vicente3j",
                        "content": "[@THEb0ss34](/THEb0ss34) Yeah I got the same problem. I passed 83/87 test cases but this one is giving me trouble"
                    },
                    {
                        "username": "THEb0ss34",
                        "content": "I have the same problem not sure what they mean!"
                    }
                ]
            },
            {
                "id": 1569500,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/k-closest-points-to-origin/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort with Custom Comparator\n\n  \n**Approach 2:** Max Heap or Max Priority Queue\n\n  \n**Approach 3:** Binary Search\n\n  \n**Approach 4:** QuickSelect\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GavinBelson",
                        "content": "For those of you who got asked this question by facebook, do they make you do the quick select solution since it is the best asymptotic O(n) on average, or is a \"sorting\" solution of O(nlogn) acceptable?  I\\'m sure it might vary by interviewer and by the level you\\'re applying to, but I am curious how this situation may play out in real life."
                    },
                    {
                        "username": "neo9729",
                        "content": "Don\\'t rush to solve the problem. Read carefully and euclidean distance should be considered as double"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I just used squares - with an int"
                    },
                    {
                        "username": "delanoi",
                        "content": "nice observation! but if you are only using the value for sorting purpose, we don\\'t really need to do the square root tho, without it, the sorting result should still be correct"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guys who added 85-87 testcases are true gentleman !!"
                    },
                    {
                        "username": "gbiems",
                        "content": "If you\\'re using python and don\\'t about heappushpop, definitely look it up. Greatly simplifies the code. \\n\\nI came across this question when I decided to review some of my early leetcode solutions now that I have a better sense of how to solve these problems. Looks like when I first tried this problem, I processed all points and sorted, a solution which does work, but is much slower.\\n\\nThis time around, I went with a heap, but I didn\\'t know about heappushpop, so my code was kind of complicated. \\n\\nFinally looked at solutions and learned something. I didn\\'t know about heappushpop. Good to know. \\n\\n "
                    },
                    {
                        "username": "cannellajs2",
                        "content": "`\\nstd::ios::sync_with_stdio(false);std::cin.tie(NULL);std::cout.tie(NULL); \\n`\\nWas wondering what this was on the fastest submission. Simply added it at the top of my function and it decreased my runtime.\\nUSER BEWARE:\\nFrom what I just read about this it allows C++ IOs to not have to be Synchronized to C IOs. This can allow it to run faster but can cause real issues if you use both stdio and cin/cout. Also cin and cout will be desynchronized.\\nFor better description look here: https://stackoverflow.com/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull"
                    },
                    {
                        "username": "peterx123",
                        "content": "Using sqrt and casting to int definitly would give wrong answer. The formla given by the description is a bait."
                    },
                    {
                        "username": "Kaltu",
                        "content": "how on earth the sorting solution beats 99.87%\\nI was expecting a TLE, LeetCode\\uD83E\\uDD23\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(points, key=lambda x: x[0] * x[0] + x[1] * x[1])[:k]\\n```"
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "BlackPantha007",
                        "content": "Hi all, please can someone help point out the improvement I need to make to this code to get it to pass all tests cases (it is passing 77/87 tests cases)?\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        // maxHeap to store values base on how close it\\'s distance is from 0.\\n        PriorityQueue<int[]> heap = new PriorityQueue<>(\\n            (arr1, arr2) -> computeDistance(arr2) - computeDistance(arr1)\\n        );\\n            \\n        for (int[] point : points) {\\n            heap.offer(point);\\n            if (heap.size() > k) {\\n                heap.poll();\\n            }\\n        }\\n            \\n        int[][] result = new int[k][2];\\n        \\n        for (int i = 0; i < k; i++) {\\n            result[i][0] = heap.peek()[0];\\n            result[i][1] = heap.poll()[1];\\n        }\\n            \\n        return result;\\n    }\\n    \\n    private int computeDistance(int[] distance) {\\n        return (int) Math.sqrt(distance[0] * distance[0] + distance[1] * distance[1]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "dojoce",
                        "content": "You need to compare the distances as a doube not an int. Using\n\nQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingDouble(point -> computeDistance(point)));"
                    },
                    {
                        "username": "barrett7212",
                        "content": "I think it\\'s because you are computing distance as an `int`, which is truncating your calculated values. Switch to a `double` and it should work."
                    },
                    {
                        "username": "ajinkyaw",
                        "content": "Below is my code and is failing for [[0,1],[1,0]] case which won\\'t satisfy unique answer condition, also when inserted in custom testcase it stands on same claim as me but it\\'s failing while submitting, any help?\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        unordered_map<int,pair<int,int>> hmap;\\n        priority_queue<pair<int,pair<int,int>>> maxh;\\n        int distance,x,y;\\n        pair<int,int> temp;\\n        for(int i=0;i<points.size();i++){\\n            x = points[i][0]; y = points[i][1];\\n            distance=pow(x,2)+pow(y,2);\\n            temp.first=x;\\n            temp.second=y;\\n            hmap.insert({distance,temp});\\n        }\\n        for(auto itr=hmap.begin();itr!=hmap.end();itr++){\\n            maxh.push({itr->first,itr->second});\\n            if(maxh.size()>k)\\n                maxh.pop();\\n        }\\n        vector<vector<int>> ans(maxh.size(), vector<int>(2,0));\\n        int i=0;\\n        while(maxh.empty()!=1){\\n            ans[i][0]=maxh.top().second.first;\\n            ans[i][1]=maxh.top().second.second;\\n            maxh.pop();i++;\\n        }\\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "aman_online67",
                        "content": "[@THEb0ss34](/THEb0ss34)  distances are same in both the vectors. so it can differentiate between them."
                    },
                    {
                        "username": "vicente3j",
                        "content": "[@THEb0ss34](/THEb0ss34) Yeah I got the same problem. I passed 83/87 test cases but this one is giving me trouble"
                    },
                    {
                        "username": "THEb0ss34",
                        "content": "I have the same problem not sure what they mean!"
                    }
                ]
            },
            {
                "id": 1575541,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/k-closest-points-to-origin/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort with Custom Comparator\n\n  \n**Approach 2:** Max Heap or Max Priority Queue\n\n  \n**Approach 3:** Binary Search\n\n  \n**Approach 4:** QuickSelect\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GavinBelson",
                        "content": "For those of you who got asked this question by facebook, do they make you do the quick select solution since it is the best asymptotic O(n) on average, or is a \"sorting\" solution of O(nlogn) acceptable?  I\\'m sure it might vary by interviewer and by the level you\\'re applying to, but I am curious how this situation may play out in real life."
                    },
                    {
                        "username": "neo9729",
                        "content": "Don\\'t rush to solve the problem. Read carefully and euclidean distance should be considered as double"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I just used squares - with an int"
                    },
                    {
                        "username": "delanoi",
                        "content": "nice observation! but if you are only using the value for sorting purpose, we don\\'t really need to do the square root tho, without it, the sorting result should still be correct"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guys who added 85-87 testcases are true gentleman !!"
                    },
                    {
                        "username": "gbiems",
                        "content": "If you\\'re using python and don\\'t about heappushpop, definitely look it up. Greatly simplifies the code. \\n\\nI came across this question when I decided to review some of my early leetcode solutions now that I have a better sense of how to solve these problems. Looks like when I first tried this problem, I processed all points and sorted, a solution which does work, but is much slower.\\n\\nThis time around, I went with a heap, but I didn\\'t know about heappushpop, so my code was kind of complicated. \\n\\nFinally looked at solutions and learned something. I didn\\'t know about heappushpop. Good to know. \\n\\n "
                    },
                    {
                        "username": "cannellajs2",
                        "content": "`\\nstd::ios::sync_with_stdio(false);std::cin.tie(NULL);std::cout.tie(NULL); \\n`\\nWas wondering what this was on the fastest submission. Simply added it at the top of my function and it decreased my runtime.\\nUSER BEWARE:\\nFrom what I just read about this it allows C++ IOs to not have to be Synchronized to C IOs. This can allow it to run faster but can cause real issues if you use both stdio and cin/cout. Also cin and cout will be desynchronized.\\nFor better description look here: https://stackoverflow.com/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull"
                    },
                    {
                        "username": "peterx123",
                        "content": "Using sqrt and casting to int definitly would give wrong answer. The formla given by the description is a bait."
                    },
                    {
                        "username": "Kaltu",
                        "content": "how on earth the sorting solution beats 99.87%\\nI was expecting a TLE, LeetCode\\uD83E\\uDD23\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(points, key=lambda x: x[0] * x[0] + x[1] * x[1])[:k]\\n```"
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "BlackPantha007",
                        "content": "Hi all, please can someone help point out the improvement I need to make to this code to get it to pass all tests cases (it is passing 77/87 tests cases)?\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        // maxHeap to store values base on how close it\\'s distance is from 0.\\n        PriorityQueue<int[]> heap = new PriorityQueue<>(\\n            (arr1, arr2) -> computeDistance(arr2) - computeDistance(arr1)\\n        );\\n            \\n        for (int[] point : points) {\\n            heap.offer(point);\\n            if (heap.size() > k) {\\n                heap.poll();\\n            }\\n        }\\n            \\n        int[][] result = new int[k][2];\\n        \\n        for (int i = 0; i < k; i++) {\\n            result[i][0] = heap.peek()[0];\\n            result[i][1] = heap.poll()[1];\\n        }\\n            \\n        return result;\\n    }\\n    \\n    private int computeDistance(int[] distance) {\\n        return (int) Math.sqrt(distance[0] * distance[0] + distance[1] * distance[1]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "dojoce",
                        "content": "You need to compare the distances as a doube not an int. Using\n\nQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingDouble(point -> computeDistance(point)));"
                    },
                    {
                        "username": "barrett7212",
                        "content": "I think it\\'s because you are computing distance as an `int`, which is truncating your calculated values. Switch to a `double` and it should work."
                    },
                    {
                        "username": "ajinkyaw",
                        "content": "Below is my code and is failing for [[0,1],[1,0]] case which won\\'t satisfy unique answer condition, also when inserted in custom testcase it stands on same claim as me but it\\'s failing while submitting, any help?\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        unordered_map<int,pair<int,int>> hmap;\\n        priority_queue<pair<int,pair<int,int>>> maxh;\\n        int distance,x,y;\\n        pair<int,int> temp;\\n        for(int i=0;i<points.size();i++){\\n            x = points[i][0]; y = points[i][1];\\n            distance=pow(x,2)+pow(y,2);\\n            temp.first=x;\\n            temp.second=y;\\n            hmap.insert({distance,temp});\\n        }\\n        for(auto itr=hmap.begin();itr!=hmap.end();itr++){\\n            maxh.push({itr->first,itr->second});\\n            if(maxh.size()>k)\\n                maxh.pop();\\n        }\\n        vector<vector<int>> ans(maxh.size(), vector<int>(2,0));\\n        int i=0;\\n        while(maxh.empty()!=1){\\n            ans[i][0]=maxh.top().second.first;\\n            ans[i][1]=maxh.top().second.second;\\n            maxh.pop();i++;\\n        }\\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "aman_online67",
                        "content": "[@THEb0ss34](/THEb0ss34)  distances are same in both the vectors. so it can differentiate between them."
                    },
                    {
                        "username": "vicente3j",
                        "content": "[@THEb0ss34](/THEb0ss34) Yeah I got the same problem. I passed 83/87 test cases but this one is giving me trouble"
                    },
                    {
                        "username": "THEb0ss34",
                        "content": "I have the same problem not sure what they mean!"
                    }
                ]
            },
            {
                "id": 1954278,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/k-closest-points-to-origin/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort with Custom Comparator\n\n  \n**Approach 2:** Max Heap or Max Priority Queue\n\n  \n**Approach 3:** Binary Search\n\n  \n**Approach 4:** QuickSelect\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GavinBelson",
                        "content": "For those of you who got asked this question by facebook, do they make you do the quick select solution since it is the best asymptotic O(n) on average, or is a \"sorting\" solution of O(nlogn) acceptable?  I\\'m sure it might vary by interviewer and by the level you\\'re applying to, but I am curious how this situation may play out in real life."
                    },
                    {
                        "username": "neo9729",
                        "content": "Don\\'t rush to solve the problem. Read carefully and euclidean distance should be considered as double"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I just used squares - with an int"
                    },
                    {
                        "username": "delanoi",
                        "content": "nice observation! but if you are only using the value for sorting purpose, we don\\'t really need to do the square root tho, without it, the sorting result should still be correct"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guys who added 85-87 testcases are true gentleman !!"
                    },
                    {
                        "username": "gbiems",
                        "content": "If you\\'re using python and don\\'t about heappushpop, definitely look it up. Greatly simplifies the code. \\n\\nI came across this question when I decided to review some of my early leetcode solutions now that I have a better sense of how to solve these problems. Looks like when I first tried this problem, I processed all points and sorted, a solution which does work, but is much slower.\\n\\nThis time around, I went with a heap, but I didn\\'t know about heappushpop, so my code was kind of complicated. \\n\\nFinally looked at solutions and learned something. I didn\\'t know about heappushpop. Good to know. \\n\\n "
                    },
                    {
                        "username": "cannellajs2",
                        "content": "`\\nstd::ios::sync_with_stdio(false);std::cin.tie(NULL);std::cout.tie(NULL); \\n`\\nWas wondering what this was on the fastest submission. Simply added it at the top of my function and it decreased my runtime.\\nUSER BEWARE:\\nFrom what I just read about this it allows C++ IOs to not have to be Synchronized to C IOs. This can allow it to run faster but can cause real issues if you use both stdio and cin/cout. Also cin and cout will be desynchronized.\\nFor better description look here: https://stackoverflow.com/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull"
                    },
                    {
                        "username": "peterx123",
                        "content": "Using sqrt and casting to int definitly would give wrong answer. The formla given by the description is a bait."
                    },
                    {
                        "username": "Kaltu",
                        "content": "how on earth the sorting solution beats 99.87%\\nI was expecting a TLE, LeetCode\\uD83E\\uDD23\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(points, key=lambda x: x[0] * x[0] + x[1] * x[1])[:k]\\n```"
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "BlackPantha007",
                        "content": "Hi all, please can someone help point out the improvement I need to make to this code to get it to pass all tests cases (it is passing 77/87 tests cases)?\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        // maxHeap to store values base on how close it\\'s distance is from 0.\\n        PriorityQueue<int[]> heap = new PriorityQueue<>(\\n            (arr1, arr2) -> computeDistance(arr2) - computeDistance(arr1)\\n        );\\n            \\n        for (int[] point : points) {\\n            heap.offer(point);\\n            if (heap.size() > k) {\\n                heap.poll();\\n            }\\n        }\\n            \\n        int[][] result = new int[k][2];\\n        \\n        for (int i = 0; i < k; i++) {\\n            result[i][0] = heap.peek()[0];\\n            result[i][1] = heap.poll()[1];\\n        }\\n            \\n        return result;\\n    }\\n    \\n    private int computeDistance(int[] distance) {\\n        return (int) Math.sqrt(distance[0] * distance[0] + distance[1] * distance[1]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "dojoce",
                        "content": "You need to compare the distances as a doube not an int. Using\n\nQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingDouble(point -> computeDistance(point)));"
                    },
                    {
                        "username": "barrett7212",
                        "content": "I think it\\'s because you are computing distance as an `int`, which is truncating your calculated values. Switch to a `double` and it should work."
                    },
                    {
                        "username": "ajinkyaw",
                        "content": "Below is my code and is failing for [[0,1],[1,0]] case which won\\'t satisfy unique answer condition, also when inserted in custom testcase it stands on same claim as me but it\\'s failing while submitting, any help?\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        unordered_map<int,pair<int,int>> hmap;\\n        priority_queue<pair<int,pair<int,int>>> maxh;\\n        int distance,x,y;\\n        pair<int,int> temp;\\n        for(int i=0;i<points.size();i++){\\n            x = points[i][0]; y = points[i][1];\\n            distance=pow(x,2)+pow(y,2);\\n            temp.first=x;\\n            temp.second=y;\\n            hmap.insert({distance,temp});\\n        }\\n        for(auto itr=hmap.begin();itr!=hmap.end();itr++){\\n            maxh.push({itr->first,itr->second});\\n            if(maxh.size()>k)\\n                maxh.pop();\\n        }\\n        vector<vector<int>> ans(maxh.size(), vector<int>(2,0));\\n        int i=0;\\n        while(maxh.empty()!=1){\\n            ans[i][0]=maxh.top().second.first;\\n            ans[i][1]=maxh.top().second.second;\\n            maxh.pop();i++;\\n        }\\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "aman_online67",
                        "content": "[@THEb0ss34](/THEb0ss34)  distances are same in both the vectors. so it can differentiate between them."
                    },
                    {
                        "username": "vicente3j",
                        "content": "[@THEb0ss34](/THEb0ss34) Yeah I got the same problem. I passed 83/87 test cases but this one is giving me trouble"
                    },
                    {
                        "username": "THEb0ss34",
                        "content": "I have the same problem not sure what they mean!"
                    }
                ]
            },
            {
                "id": 1717589,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/k-closest-points-to-origin/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort with Custom Comparator\n\n  \n**Approach 2:** Max Heap or Max Priority Queue\n\n  \n**Approach 3:** Binary Search\n\n  \n**Approach 4:** QuickSelect\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GavinBelson",
                        "content": "For those of you who got asked this question by facebook, do they make you do the quick select solution since it is the best asymptotic O(n) on average, or is a \"sorting\" solution of O(nlogn) acceptable?  I\\'m sure it might vary by interviewer and by the level you\\'re applying to, but I am curious how this situation may play out in real life."
                    },
                    {
                        "username": "neo9729",
                        "content": "Don\\'t rush to solve the problem. Read carefully and euclidean distance should be considered as double"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I just used squares - with an int"
                    },
                    {
                        "username": "delanoi",
                        "content": "nice observation! but if you are only using the value for sorting purpose, we don\\'t really need to do the square root tho, without it, the sorting result should still be correct"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guys who added 85-87 testcases are true gentleman !!"
                    },
                    {
                        "username": "gbiems",
                        "content": "If you\\'re using python and don\\'t about heappushpop, definitely look it up. Greatly simplifies the code. \\n\\nI came across this question when I decided to review some of my early leetcode solutions now that I have a better sense of how to solve these problems. Looks like when I first tried this problem, I processed all points and sorted, a solution which does work, but is much slower.\\n\\nThis time around, I went with a heap, but I didn\\'t know about heappushpop, so my code was kind of complicated. \\n\\nFinally looked at solutions and learned something. I didn\\'t know about heappushpop. Good to know. \\n\\n "
                    },
                    {
                        "username": "cannellajs2",
                        "content": "`\\nstd::ios::sync_with_stdio(false);std::cin.tie(NULL);std::cout.tie(NULL); \\n`\\nWas wondering what this was on the fastest submission. Simply added it at the top of my function and it decreased my runtime.\\nUSER BEWARE:\\nFrom what I just read about this it allows C++ IOs to not have to be Synchronized to C IOs. This can allow it to run faster but can cause real issues if you use both stdio and cin/cout. Also cin and cout will be desynchronized.\\nFor better description look here: https://stackoverflow.com/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull"
                    },
                    {
                        "username": "peterx123",
                        "content": "Using sqrt and casting to int definitly would give wrong answer. The formla given by the description is a bait."
                    },
                    {
                        "username": "Kaltu",
                        "content": "how on earth the sorting solution beats 99.87%\\nI was expecting a TLE, LeetCode\\uD83E\\uDD23\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(points, key=lambda x: x[0] * x[0] + x[1] * x[1])[:k]\\n```"
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "BlackPantha007",
                        "content": "Hi all, please can someone help point out the improvement I need to make to this code to get it to pass all tests cases (it is passing 77/87 tests cases)?\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        // maxHeap to store values base on how close it\\'s distance is from 0.\\n        PriorityQueue<int[]> heap = new PriorityQueue<>(\\n            (arr1, arr2) -> computeDistance(arr2) - computeDistance(arr1)\\n        );\\n            \\n        for (int[] point : points) {\\n            heap.offer(point);\\n            if (heap.size() > k) {\\n                heap.poll();\\n            }\\n        }\\n            \\n        int[][] result = new int[k][2];\\n        \\n        for (int i = 0; i < k; i++) {\\n            result[i][0] = heap.peek()[0];\\n            result[i][1] = heap.poll()[1];\\n        }\\n            \\n        return result;\\n    }\\n    \\n    private int computeDistance(int[] distance) {\\n        return (int) Math.sqrt(distance[0] * distance[0] + distance[1] * distance[1]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "dojoce",
                        "content": "You need to compare the distances as a doube not an int. Using\n\nQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingDouble(point -> computeDistance(point)));"
                    },
                    {
                        "username": "barrett7212",
                        "content": "I think it\\'s because you are computing distance as an `int`, which is truncating your calculated values. Switch to a `double` and it should work."
                    },
                    {
                        "username": "ajinkyaw",
                        "content": "Below is my code and is failing for [[0,1],[1,0]] case which won\\'t satisfy unique answer condition, also when inserted in custom testcase it stands on same claim as me but it\\'s failing while submitting, any help?\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        unordered_map<int,pair<int,int>> hmap;\\n        priority_queue<pair<int,pair<int,int>>> maxh;\\n        int distance,x,y;\\n        pair<int,int> temp;\\n        for(int i=0;i<points.size();i++){\\n            x = points[i][0]; y = points[i][1];\\n            distance=pow(x,2)+pow(y,2);\\n            temp.first=x;\\n            temp.second=y;\\n            hmap.insert({distance,temp});\\n        }\\n        for(auto itr=hmap.begin();itr!=hmap.end();itr++){\\n            maxh.push({itr->first,itr->second});\\n            if(maxh.size()>k)\\n                maxh.pop();\\n        }\\n        vector<vector<int>> ans(maxh.size(), vector<int>(2,0));\\n        int i=0;\\n        while(maxh.empty()!=1){\\n            ans[i][0]=maxh.top().second.first;\\n            ans[i][1]=maxh.top().second.second;\\n            maxh.pop();i++;\\n        }\\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "aman_online67",
                        "content": "[@THEb0ss34](/THEb0ss34)  distances are same in both the vectors. so it can differentiate between them."
                    },
                    {
                        "username": "vicente3j",
                        "content": "[@THEb0ss34](/THEb0ss34) Yeah I got the same problem. I passed 83/87 test cases but this one is giving me trouble"
                    },
                    {
                        "username": "THEb0ss34",
                        "content": "I have the same problem not sure what they mean!"
                    }
                ]
            },
            {
                "id": 1639872,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/k-closest-points-to-origin/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort with Custom Comparator\n\n  \n**Approach 2:** Max Heap or Max Priority Queue\n\n  \n**Approach 3:** Binary Search\n\n  \n**Approach 4:** QuickSelect\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GavinBelson",
                        "content": "For those of you who got asked this question by facebook, do they make you do the quick select solution since it is the best asymptotic O(n) on average, or is a \"sorting\" solution of O(nlogn) acceptable?  I\\'m sure it might vary by interviewer and by the level you\\'re applying to, but I am curious how this situation may play out in real life."
                    },
                    {
                        "username": "neo9729",
                        "content": "Don\\'t rush to solve the problem. Read carefully and euclidean distance should be considered as double"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I just used squares - with an int"
                    },
                    {
                        "username": "delanoi",
                        "content": "nice observation! but if you are only using the value for sorting purpose, we don\\'t really need to do the square root tho, without it, the sorting result should still be correct"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guys who added 85-87 testcases are true gentleman !!"
                    },
                    {
                        "username": "gbiems",
                        "content": "If you\\'re using python and don\\'t about heappushpop, definitely look it up. Greatly simplifies the code. \\n\\nI came across this question when I decided to review some of my early leetcode solutions now that I have a better sense of how to solve these problems. Looks like when I first tried this problem, I processed all points and sorted, a solution which does work, but is much slower.\\n\\nThis time around, I went with a heap, but I didn\\'t know about heappushpop, so my code was kind of complicated. \\n\\nFinally looked at solutions and learned something. I didn\\'t know about heappushpop. Good to know. \\n\\n "
                    },
                    {
                        "username": "cannellajs2",
                        "content": "`\\nstd::ios::sync_with_stdio(false);std::cin.tie(NULL);std::cout.tie(NULL); \\n`\\nWas wondering what this was on the fastest submission. Simply added it at the top of my function and it decreased my runtime.\\nUSER BEWARE:\\nFrom what I just read about this it allows C++ IOs to not have to be Synchronized to C IOs. This can allow it to run faster but can cause real issues if you use both stdio and cin/cout. Also cin and cout will be desynchronized.\\nFor better description look here: https://stackoverflow.com/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull"
                    },
                    {
                        "username": "peterx123",
                        "content": "Using sqrt and casting to int definitly would give wrong answer. The formla given by the description is a bait."
                    },
                    {
                        "username": "Kaltu",
                        "content": "how on earth the sorting solution beats 99.87%\\nI was expecting a TLE, LeetCode\\uD83E\\uDD23\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(points, key=lambda x: x[0] * x[0] + x[1] * x[1])[:k]\\n```"
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "BlackPantha007",
                        "content": "Hi all, please can someone help point out the improvement I need to make to this code to get it to pass all tests cases (it is passing 77/87 tests cases)?\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        // maxHeap to store values base on how close it\\'s distance is from 0.\\n        PriorityQueue<int[]> heap = new PriorityQueue<>(\\n            (arr1, arr2) -> computeDistance(arr2) - computeDistance(arr1)\\n        );\\n            \\n        for (int[] point : points) {\\n            heap.offer(point);\\n            if (heap.size() > k) {\\n                heap.poll();\\n            }\\n        }\\n            \\n        int[][] result = new int[k][2];\\n        \\n        for (int i = 0; i < k; i++) {\\n            result[i][0] = heap.peek()[0];\\n            result[i][1] = heap.poll()[1];\\n        }\\n            \\n        return result;\\n    }\\n    \\n    private int computeDistance(int[] distance) {\\n        return (int) Math.sqrt(distance[0] * distance[0] + distance[1] * distance[1]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "dojoce",
                        "content": "You need to compare the distances as a doube not an int. Using\n\nQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingDouble(point -> computeDistance(point)));"
                    },
                    {
                        "username": "barrett7212",
                        "content": "I think it\\'s because you are computing distance as an `int`, which is truncating your calculated values. Switch to a `double` and it should work."
                    },
                    {
                        "username": "ajinkyaw",
                        "content": "Below is my code and is failing for [[0,1],[1,0]] case which won\\'t satisfy unique answer condition, also when inserted in custom testcase it stands on same claim as me but it\\'s failing while submitting, any help?\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        unordered_map<int,pair<int,int>> hmap;\\n        priority_queue<pair<int,pair<int,int>>> maxh;\\n        int distance,x,y;\\n        pair<int,int> temp;\\n        for(int i=0;i<points.size();i++){\\n            x = points[i][0]; y = points[i][1];\\n            distance=pow(x,2)+pow(y,2);\\n            temp.first=x;\\n            temp.second=y;\\n            hmap.insert({distance,temp});\\n        }\\n        for(auto itr=hmap.begin();itr!=hmap.end();itr++){\\n            maxh.push({itr->first,itr->second});\\n            if(maxh.size()>k)\\n                maxh.pop();\\n        }\\n        vector<vector<int>> ans(maxh.size(), vector<int>(2,0));\\n        int i=0;\\n        while(maxh.empty()!=1){\\n            ans[i][0]=maxh.top().second.first;\\n            ans[i][1]=maxh.top().second.second;\\n            maxh.pop();i++;\\n        }\\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "aman_online67",
                        "content": "[@THEb0ss34](/THEb0ss34)  distances are same in both the vectors. so it can differentiate between them."
                    },
                    {
                        "username": "vicente3j",
                        "content": "[@THEb0ss34](/THEb0ss34) Yeah I got the same problem. I passed 83/87 test cases but this one is giving me trouble"
                    },
                    {
                        "username": "THEb0ss34",
                        "content": "I have the same problem not sure what they mean!"
                    }
                ]
            },
            {
                "id": 1565273,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/k-closest-points-to-origin/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort with Custom Comparator\n\n  \n**Approach 2:** Max Heap or Max Priority Queue\n\n  \n**Approach 3:** Binary Search\n\n  \n**Approach 4:** QuickSelect\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GavinBelson",
                        "content": "For those of you who got asked this question by facebook, do they make you do the quick select solution since it is the best asymptotic O(n) on average, or is a \"sorting\" solution of O(nlogn) acceptable?  I\\'m sure it might vary by interviewer and by the level you\\'re applying to, but I am curious how this situation may play out in real life."
                    },
                    {
                        "username": "neo9729",
                        "content": "Don\\'t rush to solve the problem. Read carefully and euclidean distance should be considered as double"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I just used squares - with an int"
                    },
                    {
                        "username": "delanoi",
                        "content": "nice observation! but if you are only using the value for sorting purpose, we don\\'t really need to do the square root tho, without it, the sorting result should still be correct"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guys who added 85-87 testcases are true gentleman !!"
                    },
                    {
                        "username": "gbiems",
                        "content": "If you\\'re using python and don\\'t about heappushpop, definitely look it up. Greatly simplifies the code. \\n\\nI came across this question when I decided to review some of my early leetcode solutions now that I have a better sense of how to solve these problems. Looks like when I first tried this problem, I processed all points and sorted, a solution which does work, but is much slower.\\n\\nThis time around, I went with a heap, but I didn\\'t know about heappushpop, so my code was kind of complicated. \\n\\nFinally looked at solutions and learned something. I didn\\'t know about heappushpop. Good to know. \\n\\n "
                    },
                    {
                        "username": "cannellajs2",
                        "content": "`\\nstd::ios::sync_with_stdio(false);std::cin.tie(NULL);std::cout.tie(NULL); \\n`\\nWas wondering what this was on the fastest submission. Simply added it at the top of my function and it decreased my runtime.\\nUSER BEWARE:\\nFrom what I just read about this it allows C++ IOs to not have to be Synchronized to C IOs. This can allow it to run faster but can cause real issues if you use both stdio and cin/cout. Also cin and cout will be desynchronized.\\nFor better description look here: https://stackoverflow.com/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull"
                    },
                    {
                        "username": "peterx123",
                        "content": "Using sqrt and casting to int definitly would give wrong answer. The formla given by the description is a bait."
                    },
                    {
                        "username": "Kaltu",
                        "content": "how on earth the sorting solution beats 99.87%\\nI was expecting a TLE, LeetCode\\uD83E\\uDD23\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(points, key=lambda x: x[0] * x[0] + x[1] * x[1])[:k]\\n```"
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "BlackPantha007",
                        "content": "Hi all, please can someone help point out the improvement I need to make to this code to get it to pass all tests cases (it is passing 77/87 tests cases)?\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        // maxHeap to store values base on how close it\\'s distance is from 0.\\n        PriorityQueue<int[]> heap = new PriorityQueue<>(\\n            (arr1, arr2) -> computeDistance(arr2) - computeDistance(arr1)\\n        );\\n            \\n        for (int[] point : points) {\\n            heap.offer(point);\\n            if (heap.size() > k) {\\n                heap.poll();\\n            }\\n        }\\n            \\n        int[][] result = new int[k][2];\\n        \\n        for (int i = 0; i < k; i++) {\\n            result[i][0] = heap.peek()[0];\\n            result[i][1] = heap.poll()[1];\\n        }\\n            \\n        return result;\\n    }\\n    \\n    private int computeDistance(int[] distance) {\\n        return (int) Math.sqrt(distance[0] * distance[0] + distance[1] * distance[1]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "dojoce",
                        "content": "You need to compare the distances as a doube not an int. Using\n\nQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingDouble(point -> computeDistance(point)));"
                    },
                    {
                        "username": "barrett7212",
                        "content": "I think it\\'s because you are computing distance as an `int`, which is truncating your calculated values. Switch to a `double` and it should work."
                    },
                    {
                        "username": "ajinkyaw",
                        "content": "Below is my code and is failing for [[0,1],[1,0]] case which won\\'t satisfy unique answer condition, also when inserted in custom testcase it stands on same claim as me but it\\'s failing while submitting, any help?\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        unordered_map<int,pair<int,int>> hmap;\\n        priority_queue<pair<int,pair<int,int>>> maxh;\\n        int distance,x,y;\\n        pair<int,int> temp;\\n        for(int i=0;i<points.size();i++){\\n            x = points[i][0]; y = points[i][1];\\n            distance=pow(x,2)+pow(y,2);\\n            temp.first=x;\\n            temp.second=y;\\n            hmap.insert({distance,temp});\\n        }\\n        for(auto itr=hmap.begin();itr!=hmap.end();itr++){\\n            maxh.push({itr->first,itr->second});\\n            if(maxh.size()>k)\\n                maxh.pop();\\n        }\\n        vector<vector<int>> ans(maxh.size(), vector<int>(2,0));\\n        int i=0;\\n        while(maxh.empty()!=1){\\n            ans[i][0]=maxh.top().second.first;\\n            ans[i][1]=maxh.top().second.second;\\n            maxh.pop();i++;\\n        }\\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "aman_online67",
                        "content": "[@THEb0ss34](/THEb0ss34)  distances are same in both the vectors. so it can differentiate between them."
                    },
                    {
                        "username": "vicente3j",
                        "content": "[@THEb0ss34](/THEb0ss34) Yeah I got the same problem. I passed 83/87 test cases but this one is giving me trouble"
                    },
                    {
                        "username": "THEb0ss34",
                        "content": "I have the same problem not sure what they mean!"
                    }
                ]
            },
            {
                "id": 1569847,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/k-closest-points-to-origin/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort with Custom Comparator\n\n  \n**Approach 2:** Max Heap or Max Priority Queue\n\n  \n**Approach 3:** Binary Search\n\n  \n**Approach 4:** QuickSelect\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GavinBelson",
                        "content": "For those of you who got asked this question by facebook, do they make you do the quick select solution since it is the best asymptotic O(n) on average, or is a \"sorting\" solution of O(nlogn) acceptable?  I\\'m sure it might vary by interviewer and by the level you\\'re applying to, but I am curious how this situation may play out in real life."
                    },
                    {
                        "username": "neo9729",
                        "content": "Don\\'t rush to solve the problem. Read carefully and euclidean distance should be considered as double"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I just used squares - with an int"
                    },
                    {
                        "username": "delanoi",
                        "content": "nice observation! but if you are only using the value for sorting purpose, we don\\'t really need to do the square root tho, without it, the sorting result should still be correct"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guys who added 85-87 testcases are true gentleman !!"
                    },
                    {
                        "username": "gbiems",
                        "content": "If you\\'re using python and don\\'t about heappushpop, definitely look it up. Greatly simplifies the code. \\n\\nI came across this question when I decided to review some of my early leetcode solutions now that I have a better sense of how to solve these problems. Looks like when I first tried this problem, I processed all points and sorted, a solution which does work, but is much slower.\\n\\nThis time around, I went with a heap, but I didn\\'t know about heappushpop, so my code was kind of complicated. \\n\\nFinally looked at solutions and learned something. I didn\\'t know about heappushpop. Good to know. \\n\\n "
                    },
                    {
                        "username": "cannellajs2",
                        "content": "`\\nstd::ios::sync_with_stdio(false);std::cin.tie(NULL);std::cout.tie(NULL); \\n`\\nWas wondering what this was on the fastest submission. Simply added it at the top of my function and it decreased my runtime.\\nUSER BEWARE:\\nFrom what I just read about this it allows C++ IOs to not have to be Synchronized to C IOs. This can allow it to run faster but can cause real issues if you use both stdio and cin/cout. Also cin and cout will be desynchronized.\\nFor better description look here: https://stackoverflow.com/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull"
                    },
                    {
                        "username": "peterx123",
                        "content": "Using sqrt and casting to int definitly would give wrong answer. The formla given by the description is a bait."
                    },
                    {
                        "username": "Kaltu",
                        "content": "how on earth the sorting solution beats 99.87%\\nI was expecting a TLE, LeetCode\\uD83E\\uDD23\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(points, key=lambda x: x[0] * x[0] + x[1] * x[1])[:k]\\n```"
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "BlackPantha007",
                        "content": "Hi all, please can someone help point out the improvement I need to make to this code to get it to pass all tests cases (it is passing 77/87 tests cases)?\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        // maxHeap to store values base on how close it\\'s distance is from 0.\\n        PriorityQueue<int[]> heap = new PriorityQueue<>(\\n            (arr1, arr2) -> computeDistance(arr2) - computeDistance(arr1)\\n        );\\n            \\n        for (int[] point : points) {\\n            heap.offer(point);\\n            if (heap.size() > k) {\\n                heap.poll();\\n            }\\n        }\\n            \\n        int[][] result = new int[k][2];\\n        \\n        for (int i = 0; i < k; i++) {\\n            result[i][0] = heap.peek()[0];\\n            result[i][1] = heap.poll()[1];\\n        }\\n            \\n        return result;\\n    }\\n    \\n    private int computeDistance(int[] distance) {\\n        return (int) Math.sqrt(distance[0] * distance[0] + distance[1] * distance[1]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "dojoce",
                        "content": "You need to compare the distances as a doube not an int. Using\n\nQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingDouble(point -> computeDistance(point)));"
                    },
                    {
                        "username": "barrett7212",
                        "content": "I think it\\'s because you are computing distance as an `int`, which is truncating your calculated values. Switch to a `double` and it should work."
                    },
                    {
                        "username": "ajinkyaw",
                        "content": "Below is my code and is failing for [[0,1],[1,0]] case which won\\'t satisfy unique answer condition, also when inserted in custom testcase it stands on same claim as me but it\\'s failing while submitting, any help?\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        unordered_map<int,pair<int,int>> hmap;\\n        priority_queue<pair<int,pair<int,int>>> maxh;\\n        int distance,x,y;\\n        pair<int,int> temp;\\n        for(int i=0;i<points.size();i++){\\n            x = points[i][0]; y = points[i][1];\\n            distance=pow(x,2)+pow(y,2);\\n            temp.first=x;\\n            temp.second=y;\\n            hmap.insert({distance,temp});\\n        }\\n        for(auto itr=hmap.begin();itr!=hmap.end();itr++){\\n            maxh.push({itr->first,itr->second});\\n            if(maxh.size()>k)\\n                maxh.pop();\\n        }\\n        vector<vector<int>> ans(maxh.size(), vector<int>(2,0));\\n        int i=0;\\n        while(maxh.empty()!=1){\\n            ans[i][0]=maxh.top().second.first;\\n            ans[i][1]=maxh.top().second.second;\\n            maxh.pop();i++;\\n        }\\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "aman_online67",
                        "content": "[@THEb0ss34](/THEb0ss34)  distances are same in both the vectors. so it can differentiate between them."
                    },
                    {
                        "username": "vicente3j",
                        "content": "[@THEb0ss34](/THEb0ss34) Yeah I got the same problem. I passed 83/87 test cases but this one is giving me trouble"
                    },
                    {
                        "username": "THEb0ss34",
                        "content": "I have the same problem not sure what they mean!"
                    }
                ]
            },
            {
                "id": 1736193,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/k-closest-points-to-origin/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort with Custom Comparator\n\n  \n**Approach 2:** Max Heap or Max Priority Queue\n\n  \n**Approach 3:** Binary Search\n\n  \n**Approach 4:** QuickSelect\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GavinBelson",
                        "content": "For those of you who got asked this question by facebook, do they make you do the quick select solution since it is the best asymptotic O(n) on average, or is a \"sorting\" solution of O(nlogn) acceptable?  I\\'m sure it might vary by interviewer and by the level you\\'re applying to, but I am curious how this situation may play out in real life."
                    },
                    {
                        "username": "neo9729",
                        "content": "Don\\'t rush to solve the problem. Read carefully and euclidean distance should be considered as double"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I just used squares - with an int"
                    },
                    {
                        "username": "delanoi",
                        "content": "nice observation! but if you are only using the value for sorting purpose, we don\\'t really need to do the square root tho, without it, the sorting result should still be correct"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guys who added 85-87 testcases are true gentleman !!"
                    },
                    {
                        "username": "gbiems",
                        "content": "If you\\'re using python and don\\'t about heappushpop, definitely look it up. Greatly simplifies the code. \\n\\nI came across this question when I decided to review some of my early leetcode solutions now that I have a better sense of how to solve these problems. Looks like when I first tried this problem, I processed all points and sorted, a solution which does work, but is much slower.\\n\\nThis time around, I went with a heap, but I didn\\'t know about heappushpop, so my code was kind of complicated. \\n\\nFinally looked at solutions and learned something. I didn\\'t know about heappushpop. Good to know. \\n\\n "
                    },
                    {
                        "username": "cannellajs2",
                        "content": "`\\nstd::ios::sync_with_stdio(false);std::cin.tie(NULL);std::cout.tie(NULL); \\n`\\nWas wondering what this was on the fastest submission. Simply added it at the top of my function and it decreased my runtime.\\nUSER BEWARE:\\nFrom what I just read about this it allows C++ IOs to not have to be Synchronized to C IOs. This can allow it to run faster but can cause real issues if you use both stdio and cin/cout. Also cin and cout will be desynchronized.\\nFor better description look here: https://stackoverflow.com/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull"
                    },
                    {
                        "username": "peterx123",
                        "content": "Using sqrt and casting to int definitly would give wrong answer. The formla given by the description is a bait."
                    },
                    {
                        "username": "Kaltu",
                        "content": "how on earth the sorting solution beats 99.87%\\nI was expecting a TLE, LeetCode\\uD83E\\uDD23\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(points, key=lambda x: x[0] * x[0] + x[1] * x[1])[:k]\\n```"
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "BlackPantha007",
                        "content": "Hi all, please can someone help point out the improvement I need to make to this code to get it to pass all tests cases (it is passing 77/87 tests cases)?\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        // maxHeap to store values base on how close it\\'s distance is from 0.\\n        PriorityQueue<int[]> heap = new PriorityQueue<>(\\n            (arr1, arr2) -> computeDistance(arr2) - computeDistance(arr1)\\n        );\\n            \\n        for (int[] point : points) {\\n            heap.offer(point);\\n            if (heap.size() > k) {\\n                heap.poll();\\n            }\\n        }\\n            \\n        int[][] result = new int[k][2];\\n        \\n        for (int i = 0; i < k; i++) {\\n            result[i][0] = heap.peek()[0];\\n            result[i][1] = heap.poll()[1];\\n        }\\n            \\n        return result;\\n    }\\n    \\n    private int computeDistance(int[] distance) {\\n        return (int) Math.sqrt(distance[0] * distance[0] + distance[1] * distance[1]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "dojoce",
                        "content": "You need to compare the distances as a doube not an int. Using\n\nQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingDouble(point -> computeDistance(point)));"
                    },
                    {
                        "username": "barrett7212",
                        "content": "I think it\\'s because you are computing distance as an `int`, which is truncating your calculated values. Switch to a `double` and it should work."
                    },
                    {
                        "username": "ajinkyaw",
                        "content": "Below is my code and is failing for [[0,1],[1,0]] case which won\\'t satisfy unique answer condition, also when inserted in custom testcase it stands on same claim as me but it\\'s failing while submitting, any help?\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        unordered_map<int,pair<int,int>> hmap;\\n        priority_queue<pair<int,pair<int,int>>> maxh;\\n        int distance,x,y;\\n        pair<int,int> temp;\\n        for(int i=0;i<points.size();i++){\\n            x = points[i][0]; y = points[i][1];\\n            distance=pow(x,2)+pow(y,2);\\n            temp.first=x;\\n            temp.second=y;\\n            hmap.insert({distance,temp});\\n        }\\n        for(auto itr=hmap.begin();itr!=hmap.end();itr++){\\n            maxh.push({itr->first,itr->second});\\n            if(maxh.size()>k)\\n                maxh.pop();\\n        }\\n        vector<vector<int>> ans(maxh.size(), vector<int>(2,0));\\n        int i=0;\\n        while(maxh.empty()!=1){\\n            ans[i][0]=maxh.top().second.first;\\n            ans[i][1]=maxh.top().second.second;\\n            maxh.pop();i++;\\n        }\\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "aman_online67",
                        "content": "[@THEb0ss34](/THEb0ss34)  distances are same in both the vectors. so it can differentiate between them."
                    },
                    {
                        "username": "vicente3j",
                        "content": "[@THEb0ss34](/THEb0ss34) Yeah I got the same problem. I passed 83/87 test cases but this one is giving me trouble"
                    },
                    {
                        "username": "THEb0ss34",
                        "content": "I have the same problem not sure what they mean!"
                    }
                ]
            },
            {
                "id": 1805030,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/k-closest-points-to-origin/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort with Custom Comparator\n\n  \n**Approach 2:** Max Heap or Max Priority Queue\n\n  \n**Approach 3:** Binary Search\n\n  \n**Approach 4:** QuickSelect\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GavinBelson",
                        "content": "For those of you who got asked this question by facebook, do they make you do the quick select solution since it is the best asymptotic O(n) on average, or is a \"sorting\" solution of O(nlogn) acceptable?  I\\'m sure it might vary by interviewer and by the level you\\'re applying to, but I am curious how this situation may play out in real life."
                    },
                    {
                        "username": "neo9729",
                        "content": "Don\\'t rush to solve the problem. Read carefully and euclidean distance should be considered as double"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I just used squares - with an int"
                    },
                    {
                        "username": "delanoi",
                        "content": "nice observation! but if you are only using the value for sorting purpose, we don\\'t really need to do the square root tho, without it, the sorting result should still be correct"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guys who added 85-87 testcases are true gentleman !!"
                    },
                    {
                        "username": "gbiems",
                        "content": "If you\\'re using python and don\\'t about heappushpop, definitely look it up. Greatly simplifies the code. \\n\\nI came across this question when I decided to review some of my early leetcode solutions now that I have a better sense of how to solve these problems. Looks like when I first tried this problem, I processed all points and sorted, a solution which does work, but is much slower.\\n\\nThis time around, I went with a heap, but I didn\\'t know about heappushpop, so my code was kind of complicated. \\n\\nFinally looked at solutions and learned something. I didn\\'t know about heappushpop. Good to know. \\n\\n "
                    },
                    {
                        "username": "cannellajs2",
                        "content": "`\\nstd::ios::sync_with_stdio(false);std::cin.tie(NULL);std::cout.tie(NULL); \\n`\\nWas wondering what this was on the fastest submission. Simply added it at the top of my function and it decreased my runtime.\\nUSER BEWARE:\\nFrom what I just read about this it allows C++ IOs to not have to be Synchronized to C IOs. This can allow it to run faster but can cause real issues if you use both stdio and cin/cout. Also cin and cout will be desynchronized.\\nFor better description look here: https://stackoverflow.com/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull"
                    },
                    {
                        "username": "peterx123",
                        "content": "Using sqrt and casting to int definitly would give wrong answer. The formla given by the description is a bait."
                    },
                    {
                        "username": "Kaltu",
                        "content": "how on earth the sorting solution beats 99.87%\\nI was expecting a TLE, LeetCode\\uD83E\\uDD23\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(points, key=lambda x: x[0] * x[0] + x[1] * x[1])[:k]\\n```"
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "BlackPantha007",
                        "content": "Hi all, please can someone help point out the improvement I need to make to this code to get it to pass all tests cases (it is passing 77/87 tests cases)?\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        // maxHeap to store values base on how close it\\'s distance is from 0.\\n        PriorityQueue<int[]> heap = new PriorityQueue<>(\\n            (arr1, arr2) -> computeDistance(arr2) - computeDistance(arr1)\\n        );\\n            \\n        for (int[] point : points) {\\n            heap.offer(point);\\n            if (heap.size() > k) {\\n                heap.poll();\\n            }\\n        }\\n            \\n        int[][] result = new int[k][2];\\n        \\n        for (int i = 0; i < k; i++) {\\n            result[i][0] = heap.peek()[0];\\n            result[i][1] = heap.poll()[1];\\n        }\\n            \\n        return result;\\n    }\\n    \\n    private int computeDistance(int[] distance) {\\n        return (int) Math.sqrt(distance[0] * distance[0] + distance[1] * distance[1]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "dojoce",
                        "content": "You need to compare the distances as a doube not an int. Using\n\nQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingDouble(point -> computeDistance(point)));"
                    },
                    {
                        "username": "barrett7212",
                        "content": "I think it\\'s because you are computing distance as an `int`, which is truncating your calculated values. Switch to a `double` and it should work."
                    },
                    {
                        "username": "ajinkyaw",
                        "content": "Below is my code and is failing for [[0,1],[1,0]] case which won\\'t satisfy unique answer condition, also when inserted in custom testcase it stands on same claim as me but it\\'s failing while submitting, any help?\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        unordered_map<int,pair<int,int>> hmap;\\n        priority_queue<pair<int,pair<int,int>>> maxh;\\n        int distance,x,y;\\n        pair<int,int> temp;\\n        for(int i=0;i<points.size();i++){\\n            x = points[i][0]; y = points[i][1];\\n            distance=pow(x,2)+pow(y,2);\\n            temp.first=x;\\n            temp.second=y;\\n            hmap.insert({distance,temp});\\n        }\\n        for(auto itr=hmap.begin();itr!=hmap.end();itr++){\\n            maxh.push({itr->first,itr->second});\\n            if(maxh.size()>k)\\n                maxh.pop();\\n        }\\n        vector<vector<int>> ans(maxh.size(), vector<int>(2,0));\\n        int i=0;\\n        while(maxh.empty()!=1){\\n            ans[i][0]=maxh.top().second.first;\\n            ans[i][1]=maxh.top().second.second;\\n            maxh.pop();i++;\\n        }\\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "aman_online67",
                        "content": "[@THEb0ss34](/THEb0ss34)  distances are same in both the vectors. so it can differentiate between them."
                    },
                    {
                        "username": "vicente3j",
                        "content": "[@THEb0ss34](/THEb0ss34) Yeah I got the same problem. I passed 83/87 test cases but this one is giving me trouble"
                    },
                    {
                        "username": "THEb0ss34",
                        "content": "I have the same problem not sure what they mean!"
                    }
                ]
            },
            {
                "id": 1881393,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/k-closest-points-to-origin/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort with Custom Comparator\n\n  \n**Approach 2:** Max Heap or Max Priority Queue\n\n  \n**Approach 3:** Binary Search\n\n  \n**Approach 4:** QuickSelect\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GavinBelson",
                        "content": "For those of you who got asked this question by facebook, do they make you do the quick select solution since it is the best asymptotic O(n) on average, or is a \"sorting\" solution of O(nlogn) acceptable?  I\\'m sure it might vary by interviewer and by the level you\\'re applying to, but I am curious how this situation may play out in real life."
                    },
                    {
                        "username": "neo9729",
                        "content": "Don\\'t rush to solve the problem. Read carefully and euclidean distance should be considered as double"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I just used squares - with an int"
                    },
                    {
                        "username": "delanoi",
                        "content": "nice observation! but if you are only using the value for sorting purpose, we don\\'t really need to do the square root tho, without it, the sorting result should still be correct"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guys who added 85-87 testcases are true gentleman !!"
                    },
                    {
                        "username": "gbiems",
                        "content": "If you\\'re using python and don\\'t about heappushpop, definitely look it up. Greatly simplifies the code. \\n\\nI came across this question when I decided to review some of my early leetcode solutions now that I have a better sense of how to solve these problems. Looks like when I first tried this problem, I processed all points and sorted, a solution which does work, but is much slower.\\n\\nThis time around, I went with a heap, but I didn\\'t know about heappushpop, so my code was kind of complicated. \\n\\nFinally looked at solutions and learned something. I didn\\'t know about heappushpop. Good to know. \\n\\n "
                    },
                    {
                        "username": "cannellajs2",
                        "content": "`\\nstd::ios::sync_with_stdio(false);std::cin.tie(NULL);std::cout.tie(NULL); \\n`\\nWas wondering what this was on the fastest submission. Simply added it at the top of my function and it decreased my runtime.\\nUSER BEWARE:\\nFrom what I just read about this it allows C++ IOs to not have to be Synchronized to C IOs. This can allow it to run faster but can cause real issues if you use both stdio and cin/cout. Also cin and cout will be desynchronized.\\nFor better description look here: https://stackoverflow.com/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull"
                    },
                    {
                        "username": "peterx123",
                        "content": "Using sqrt and casting to int definitly would give wrong answer. The formla given by the description is a bait."
                    },
                    {
                        "username": "Kaltu",
                        "content": "how on earth the sorting solution beats 99.87%\\nI was expecting a TLE, LeetCode\\uD83E\\uDD23\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(points, key=lambda x: x[0] * x[0] + x[1] * x[1])[:k]\\n```"
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "BlackPantha007",
                        "content": "Hi all, please can someone help point out the improvement I need to make to this code to get it to pass all tests cases (it is passing 77/87 tests cases)?\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        // maxHeap to store values base on how close it\\'s distance is from 0.\\n        PriorityQueue<int[]> heap = new PriorityQueue<>(\\n            (arr1, arr2) -> computeDistance(arr2) - computeDistance(arr1)\\n        );\\n            \\n        for (int[] point : points) {\\n            heap.offer(point);\\n            if (heap.size() > k) {\\n                heap.poll();\\n            }\\n        }\\n            \\n        int[][] result = new int[k][2];\\n        \\n        for (int i = 0; i < k; i++) {\\n            result[i][0] = heap.peek()[0];\\n            result[i][1] = heap.poll()[1];\\n        }\\n            \\n        return result;\\n    }\\n    \\n    private int computeDistance(int[] distance) {\\n        return (int) Math.sqrt(distance[0] * distance[0] + distance[1] * distance[1]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "dojoce",
                        "content": "You need to compare the distances as a doube not an int. Using\n\nQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingDouble(point -> computeDistance(point)));"
                    },
                    {
                        "username": "barrett7212",
                        "content": "I think it\\'s because you are computing distance as an `int`, which is truncating your calculated values. Switch to a `double` and it should work."
                    },
                    {
                        "username": "ajinkyaw",
                        "content": "Below is my code and is failing for [[0,1],[1,0]] case which won\\'t satisfy unique answer condition, also when inserted in custom testcase it stands on same claim as me but it\\'s failing while submitting, any help?\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        unordered_map<int,pair<int,int>> hmap;\\n        priority_queue<pair<int,pair<int,int>>> maxh;\\n        int distance,x,y;\\n        pair<int,int> temp;\\n        for(int i=0;i<points.size();i++){\\n            x = points[i][0]; y = points[i][1];\\n            distance=pow(x,2)+pow(y,2);\\n            temp.first=x;\\n            temp.second=y;\\n            hmap.insert({distance,temp});\\n        }\\n        for(auto itr=hmap.begin();itr!=hmap.end();itr++){\\n            maxh.push({itr->first,itr->second});\\n            if(maxh.size()>k)\\n                maxh.pop();\\n        }\\n        vector<vector<int>> ans(maxh.size(), vector<int>(2,0));\\n        int i=0;\\n        while(maxh.empty()!=1){\\n            ans[i][0]=maxh.top().second.first;\\n            ans[i][1]=maxh.top().second.second;\\n            maxh.pop();i++;\\n        }\\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "aman_online67",
                        "content": "[@THEb0ss34](/THEb0ss34)  distances are same in both the vectors. so it can differentiate between them."
                    },
                    {
                        "username": "vicente3j",
                        "content": "[@THEb0ss34](/THEb0ss34) Yeah I got the same problem. I passed 83/87 test cases but this one is giving me trouble"
                    },
                    {
                        "username": "THEb0ss34",
                        "content": "I have the same problem not sure what they mean!"
                    }
                ]
            },
            {
                "id": 1569500,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/k-closest-points-to-origin/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort with Custom Comparator\n\n  \n**Approach 2:** Max Heap or Max Priority Queue\n\n  \n**Approach 3:** Binary Search\n\n  \n**Approach 4:** QuickSelect\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GavinBelson",
                        "content": "For those of you who got asked this question by facebook, do they make you do the quick select solution since it is the best asymptotic O(n) on average, or is a \"sorting\" solution of O(nlogn) acceptable?  I\\'m sure it might vary by interviewer and by the level you\\'re applying to, but I am curious how this situation may play out in real life."
                    },
                    {
                        "username": "neo9729",
                        "content": "Don\\'t rush to solve the problem. Read carefully and euclidean distance should be considered as double"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I just used squares - with an int"
                    },
                    {
                        "username": "delanoi",
                        "content": "nice observation! but if you are only using the value for sorting purpose, we don\\'t really need to do the square root tho, without it, the sorting result should still be correct"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guys who added 85-87 testcases are true gentleman !!"
                    },
                    {
                        "username": "gbiems",
                        "content": "If you\\'re using python and don\\'t about heappushpop, definitely look it up. Greatly simplifies the code. \\n\\nI came across this question when I decided to review some of my early leetcode solutions now that I have a better sense of how to solve these problems. Looks like when I first tried this problem, I processed all points and sorted, a solution which does work, but is much slower.\\n\\nThis time around, I went with a heap, but I didn\\'t know about heappushpop, so my code was kind of complicated. \\n\\nFinally looked at solutions and learned something. I didn\\'t know about heappushpop. Good to know. \\n\\n "
                    },
                    {
                        "username": "cannellajs2",
                        "content": "`\\nstd::ios::sync_with_stdio(false);std::cin.tie(NULL);std::cout.tie(NULL); \\n`\\nWas wondering what this was on the fastest submission. Simply added it at the top of my function and it decreased my runtime.\\nUSER BEWARE:\\nFrom what I just read about this it allows C++ IOs to not have to be Synchronized to C IOs. This can allow it to run faster but can cause real issues if you use both stdio and cin/cout. Also cin and cout will be desynchronized.\\nFor better description look here: https://stackoverflow.com/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull"
                    },
                    {
                        "username": "peterx123",
                        "content": "Using sqrt and casting to int definitly would give wrong answer. The formla given by the description is a bait."
                    },
                    {
                        "username": "Kaltu",
                        "content": "how on earth the sorting solution beats 99.87%\\nI was expecting a TLE, LeetCode\\uD83E\\uDD23\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(points, key=lambda x: x[0] * x[0] + x[1] * x[1])[:k]\\n```"
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "BlackPantha007",
                        "content": "Hi all, please can someone help point out the improvement I need to make to this code to get it to pass all tests cases (it is passing 77/87 tests cases)?\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        // maxHeap to store values base on how close it\\'s distance is from 0.\\n        PriorityQueue<int[]> heap = new PriorityQueue<>(\\n            (arr1, arr2) -> computeDistance(arr2) - computeDistance(arr1)\\n        );\\n            \\n        for (int[] point : points) {\\n            heap.offer(point);\\n            if (heap.size() > k) {\\n                heap.poll();\\n            }\\n        }\\n            \\n        int[][] result = new int[k][2];\\n        \\n        for (int i = 0; i < k; i++) {\\n            result[i][0] = heap.peek()[0];\\n            result[i][1] = heap.poll()[1];\\n        }\\n            \\n        return result;\\n    }\\n    \\n    private int computeDistance(int[] distance) {\\n        return (int) Math.sqrt(distance[0] * distance[0] + distance[1] * distance[1]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "dojoce",
                        "content": "You need to compare the distances as a doube not an int. Using\n\nQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingDouble(point -> computeDistance(point)));"
                    },
                    {
                        "username": "barrett7212",
                        "content": "I think it\\'s because you are computing distance as an `int`, which is truncating your calculated values. Switch to a `double` and it should work."
                    },
                    {
                        "username": "ajinkyaw",
                        "content": "Below is my code and is failing for [[0,1],[1,0]] case which won\\'t satisfy unique answer condition, also when inserted in custom testcase it stands on same claim as me but it\\'s failing while submitting, any help?\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        unordered_map<int,pair<int,int>> hmap;\\n        priority_queue<pair<int,pair<int,int>>> maxh;\\n        int distance,x,y;\\n        pair<int,int> temp;\\n        for(int i=0;i<points.size();i++){\\n            x = points[i][0]; y = points[i][1];\\n            distance=pow(x,2)+pow(y,2);\\n            temp.first=x;\\n            temp.second=y;\\n            hmap.insert({distance,temp});\\n        }\\n        for(auto itr=hmap.begin();itr!=hmap.end();itr++){\\n            maxh.push({itr->first,itr->second});\\n            if(maxh.size()>k)\\n                maxh.pop();\\n        }\\n        vector<vector<int>> ans(maxh.size(), vector<int>(2,0));\\n        int i=0;\\n        while(maxh.empty()!=1){\\n            ans[i][0]=maxh.top().second.first;\\n            ans[i][1]=maxh.top().second.second;\\n            maxh.pop();i++;\\n        }\\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "aman_online67",
                        "content": "[@THEb0ss34](/THEb0ss34)  distances are same in both the vectors. so it can differentiate between them."
                    },
                    {
                        "username": "vicente3j",
                        "content": "[@THEb0ss34](/THEb0ss34) Yeah I got the same problem. I passed 83/87 test cases but this one is giving me trouble"
                    },
                    {
                        "username": "THEb0ss34",
                        "content": "I have the same problem not sure what they mean!"
                    }
                ]
            },
            {
                "id": 1575541,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/k-closest-points-to-origin/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort with Custom Comparator\n\n  \n**Approach 2:** Max Heap or Max Priority Queue\n\n  \n**Approach 3:** Binary Search\n\n  \n**Approach 4:** QuickSelect\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GavinBelson",
                        "content": "For those of you who got asked this question by facebook, do they make you do the quick select solution since it is the best asymptotic O(n) on average, or is a \"sorting\" solution of O(nlogn) acceptable?  I\\'m sure it might vary by interviewer and by the level you\\'re applying to, but I am curious how this situation may play out in real life."
                    },
                    {
                        "username": "neo9729",
                        "content": "Don\\'t rush to solve the problem. Read carefully and euclidean distance should be considered as double"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I just used squares - with an int"
                    },
                    {
                        "username": "delanoi",
                        "content": "nice observation! but if you are only using the value for sorting purpose, we don\\'t really need to do the square root tho, without it, the sorting result should still be correct"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guys who added 85-87 testcases are true gentleman !!"
                    },
                    {
                        "username": "gbiems",
                        "content": "If you\\'re using python and don\\'t about heappushpop, definitely look it up. Greatly simplifies the code. \\n\\nI came across this question when I decided to review some of my early leetcode solutions now that I have a better sense of how to solve these problems. Looks like when I first tried this problem, I processed all points and sorted, a solution which does work, but is much slower.\\n\\nThis time around, I went with a heap, but I didn\\'t know about heappushpop, so my code was kind of complicated. \\n\\nFinally looked at solutions and learned something. I didn\\'t know about heappushpop. Good to know. \\n\\n "
                    },
                    {
                        "username": "cannellajs2",
                        "content": "`\\nstd::ios::sync_with_stdio(false);std::cin.tie(NULL);std::cout.tie(NULL); \\n`\\nWas wondering what this was on the fastest submission. Simply added it at the top of my function and it decreased my runtime.\\nUSER BEWARE:\\nFrom what I just read about this it allows C++ IOs to not have to be Synchronized to C IOs. This can allow it to run faster but can cause real issues if you use both stdio and cin/cout. Also cin and cout will be desynchronized.\\nFor better description look here: https://stackoverflow.com/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull"
                    },
                    {
                        "username": "peterx123",
                        "content": "Using sqrt and casting to int definitly would give wrong answer. The formla given by the description is a bait."
                    },
                    {
                        "username": "Kaltu",
                        "content": "how on earth the sorting solution beats 99.87%\\nI was expecting a TLE, LeetCode\\uD83E\\uDD23\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(points, key=lambda x: x[0] * x[0] + x[1] * x[1])[:k]\\n```"
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "BlackPantha007",
                        "content": "Hi all, please can someone help point out the improvement I need to make to this code to get it to pass all tests cases (it is passing 77/87 tests cases)?\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        // maxHeap to store values base on how close it\\'s distance is from 0.\\n        PriorityQueue<int[]> heap = new PriorityQueue<>(\\n            (arr1, arr2) -> computeDistance(arr2) - computeDistance(arr1)\\n        );\\n            \\n        for (int[] point : points) {\\n            heap.offer(point);\\n            if (heap.size() > k) {\\n                heap.poll();\\n            }\\n        }\\n            \\n        int[][] result = new int[k][2];\\n        \\n        for (int i = 0; i < k; i++) {\\n            result[i][0] = heap.peek()[0];\\n            result[i][1] = heap.poll()[1];\\n        }\\n            \\n        return result;\\n    }\\n    \\n    private int computeDistance(int[] distance) {\\n        return (int) Math.sqrt(distance[0] * distance[0] + distance[1] * distance[1]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "dojoce",
                        "content": "You need to compare the distances as a doube not an int. Using\n\nQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingDouble(point -> computeDistance(point)));"
                    },
                    {
                        "username": "barrett7212",
                        "content": "I think it\\'s because you are computing distance as an `int`, which is truncating your calculated values. Switch to a `double` and it should work."
                    },
                    {
                        "username": "ajinkyaw",
                        "content": "Below is my code and is failing for [[0,1],[1,0]] case which won\\'t satisfy unique answer condition, also when inserted in custom testcase it stands on same claim as me but it\\'s failing while submitting, any help?\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        unordered_map<int,pair<int,int>> hmap;\\n        priority_queue<pair<int,pair<int,int>>> maxh;\\n        int distance,x,y;\\n        pair<int,int> temp;\\n        for(int i=0;i<points.size();i++){\\n            x = points[i][0]; y = points[i][1];\\n            distance=pow(x,2)+pow(y,2);\\n            temp.first=x;\\n            temp.second=y;\\n            hmap.insert({distance,temp});\\n        }\\n        for(auto itr=hmap.begin();itr!=hmap.end();itr++){\\n            maxh.push({itr->first,itr->second});\\n            if(maxh.size()>k)\\n                maxh.pop();\\n        }\\n        vector<vector<int>> ans(maxh.size(), vector<int>(2,0));\\n        int i=0;\\n        while(maxh.empty()!=1){\\n            ans[i][0]=maxh.top().second.first;\\n            ans[i][1]=maxh.top().second.second;\\n            maxh.pop();i++;\\n        }\\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "aman_online67",
                        "content": "[@THEb0ss34](/THEb0ss34)  distances are same in both the vectors. so it can differentiate between them."
                    },
                    {
                        "username": "vicente3j",
                        "content": "[@THEb0ss34](/THEb0ss34) Yeah I got the same problem. I passed 83/87 test cases but this one is giving me trouble"
                    },
                    {
                        "username": "THEb0ss34",
                        "content": "I have the same problem not sure what they mean!"
                    }
                ]
            },
            {
                "id": 1954278,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/k-closest-points-to-origin/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort with Custom Comparator\n\n  \n**Approach 2:** Max Heap or Max Priority Queue\n\n  \n**Approach 3:** Binary Search\n\n  \n**Approach 4:** QuickSelect\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GavinBelson",
                        "content": "For those of you who got asked this question by facebook, do they make you do the quick select solution since it is the best asymptotic O(n) on average, or is a \"sorting\" solution of O(nlogn) acceptable?  I\\'m sure it might vary by interviewer and by the level you\\'re applying to, but I am curious how this situation may play out in real life."
                    },
                    {
                        "username": "neo9729",
                        "content": "Don\\'t rush to solve the problem. Read carefully and euclidean distance should be considered as double"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I just used squares - with an int"
                    },
                    {
                        "username": "delanoi",
                        "content": "nice observation! but if you are only using the value for sorting purpose, we don\\'t really need to do the square root tho, without it, the sorting result should still be correct"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guys who added 85-87 testcases are true gentleman !!"
                    },
                    {
                        "username": "gbiems",
                        "content": "If you\\'re using python and don\\'t about heappushpop, definitely look it up. Greatly simplifies the code. \\n\\nI came across this question when I decided to review some of my early leetcode solutions now that I have a better sense of how to solve these problems. Looks like when I first tried this problem, I processed all points and sorted, a solution which does work, but is much slower.\\n\\nThis time around, I went with a heap, but I didn\\'t know about heappushpop, so my code was kind of complicated. \\n\\nFinally looked at solutions and learned something. I didn\\'t know about heappushpop. Good to know. \\n\\n "
                    },
                    {
                        "username": "cannellajs2",
                        "content": "`\\nstd::ios::sync_with_stdio(false);std::cin.tie(NULL);std::cout.tie(NULL); \\n`\\nWas wondering what this was on the fastest submission. Simply added it at the top of my function and it decreased my runtime.\\nUSER BEWARE:\\nFrom what I just read about this it allows C++ IOs to not have to be Synchronized to C IOs. This can allow it to run faster but can cause real issues if you use both stdio and cin/cout. Also cin and cout will be desynchronized.\\nFor better description look here: https://stackoverflow.com/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull"
                    },
                    {
                        "username": "peterx123",
                        "content": "Using sqrt and casting to int definitly would give wrong answer. The formla given by the description is a bait."
                    },
                    {
                        "username": "Kaltu",
                        "content": "how on earth the sorting solution beats 99.87%\\nI was expecting a TLE, LeetCode\\uD83E\\uDD23\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(points, key=lambda x: x[0] * x[0] + x[1] * x[1])[:k]\\n```"
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "BlackPantha007",
                        "content": "Hi all, please can someone help point out the improvement I need to make to this code to get it to pass all tests cases (it is passing 77/87 tests cases)?\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        // maxHeap to store values base on how close it\\'s distance is from 0.\\n        PriorityQueue<int[]> heap = new PriorityQueue<>(\\n            (arr1, arr2) -> computeDistance(arr2) - computeDistance(arr1)\\n        );\\n            \\n        for (int[] point : points) {\\n            heap.offer(point);\\n            if (heap.size() > k) {\\n                heap.poll();\\n            }\\n        }\\n            \\n        int[][] result = new int[k][2];\\n        \\n        for (int i = 0; i < k; i++) {\\n            result[i][0] = heap.peek()[0];\\n            result[i][1] = heap.poll()[1];\\n        }\\n            \\n        return result;\\n    }\\n    \\n    private int computeDistance(int[] distance) {\\n        return (int) Math.sqrt(distance[0] * distance[0] + distance[1] * distance[1]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "dojoce",
                        "content": "You need to compare the distances as a doube not an int. Using\n\nQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingDouble(point -> computeDistance(point)));"
                    },
                    {
                        "username": "barrett7212",
                        "content": "I think it\\'s because you are computing distance as an `int`, which is truncating your calculated values. Switch to a `double` and it should work."
                    },
                    {
                        "username": "ajinkyaw",
                        "content": "Below is my code and is failing for [[0,1],[1,0]] case which won\\'t satisfy unique answer condition, also when inserted in custom testcase it stands on same claim as me but it\\'s failing while submitting, any help?\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        unordered_map<int,pair<int,int>> hmap;\\n        priority_queue<pair<int,pair<int,int>>> maxh;\\n        int distance,x,y;\\n        pair<int,int> temp;\\n        for(int i=0;i<points.size();i++){\\n            x = points[i][0]; y = points[i][1];\\n            distance=pow(x,2)+pow(y,2);\\n            temp.first=x;\\n            temp.second=y;\\n            hmap.insert({distance,temp});\\n        }\\n        for(auto itr=hmap.begin();itr!=hmap.end();itr++){\\n            maxh.push({itr->first,itr->second});\\n            if(maxh.size()>k)\\n                maxh.pop();\\n        }\\n        vector<vector<int>> ans(maxh.size(), vector<int>(2,0));\\n        int i=0;\\n        while(maxh.empty()!=1){\\n            ans[i][0]=maxh.top().second.first;\\n            ans[i][1]=maxh.top().second.second;\\n            maxh.pop();i++;\\n        }\\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "aman_online67",
                        "content": "[@THEb0ss34](/THEb0ss34)  distances are same in both the vectors. so it can differentiate between them."
                    },
                    {
                        "username": "vicente3j",
                        "content": "[@THEb0ss34](/THEb0ss34) Yeah I got the same problem. I passed 83/87 test cases but this one is giving me trouble"
                    },
                    {
                        "username": "THEb0ss34",
                        "content": "I have the same problem not sure what they mean!"
                    }
                ]
            },
            {
                "id": 1717589,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/k-closest-points-to-origin/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort with Custom Comparator\n\n  \n**Approach 2:** Max Heap or Max Priority Queue\n\n  \n**Approach 3:** Binary Search\n\n  \n**Approach 4:** QuickSelect\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GavinBelson",
                        "content": "For those of you who got asked this question by facebook, do they make you do the quick select solution since it is the best asymptotic O(n) on average, or is a \"sorting\" solution of O(nlogn) acceptable?  I\\'m sure it might vary by interviewer and by the level you\\'re applying to, but I am curious how this situation may play out in real life."
                    },
                    {
                        "username": "neo9729",
                        "content": "Don\\'t rush to solve the problem. Read carefully and euclidean distance should be considered as double"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I just used squares - with an int"
                    },
                    {
                        "username": "delanoi",
                        "content": "nice observation! but if you are only using the value for sorting purpose, we don\\'t really need to do the square root tho, without it, the sorting result should still be correct"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guys who added 85-87 testcases are true gentleman !!"
                    },
                    {
                        "username": "gbiems",
                        "content": "If you\\'re using python and don\\'t about heappushpop, definitely look it up. Greatly simplifies the code. \\n\\nI came across this question when I decided to review some of my early leetcode solutions now that I have a better sense of how to solve these problems. Looks like when I first tried this problem, I processed all points and sorted, a solution which does work, but is much slower.\\n\\nThis time around, I went with a heap, but I didn\\'t know about heappushpop, so my code was kind of complicated. \\n\\nFinally looked at solutions and learned something. I didn\\'t know about heappushpop. Good to know. \\n\\n "
                    },
                    {
                        "username": "cannellajs2",
                        "content": "`\\nstd::ios::sync_with_stdio(false);std::cin.tie(NULL);std::cout.tie(NULL); \\n`\\nWas wondering what this was on the fastest submission. Simply added it at the top of my function and it decreased my runtime.\\nUSER BEWARE:\\nFrom what I just read about this it allows C++ IOs to not have to be Synchronized to C IOs. This can allow it to run faster but can cause real issues if you use both stdio and cin/cout. Also cin and cout will be desynchronized.\\nFor better description look here: https://stackoverflow.com/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull"
                    },
                    {
                        "username": "peterx123",
                        "content": "Using sqrt and casting to int definitly would give wrong answer. The formla given by the description is a bait."
                    },
                    {
                        "username": "Kaltu",
                        "content": "how on earth the sorting solution beats 99.87%\\nI was expecting a TLE, LeetCode\\uD83E\\uDD23\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(points, key=lambda x: x[0] * x[0] + x[1] * x[1])[:k]\\n```"
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "BlackPantha007",
                        "content": "Hi all, please can someone help point out the improvement I need to make to this code to get it to pass all tests cases (it is passing 77/87 tests cases)?\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        // maxHeap to store values base on how close it\\'s distance is from 0.\\n        PriorityQueue<int[]> heap = new PriorityQueue<>(\\n            (arr1, arr2) -> computeDistance(arr2) - computeDistance(arr1)\\n        );\\n            \\n        for (int[] point : points) {\\n            heap.offer(point);\\n            if (heap.size() > k) {\\n                heap.poll();\\n            }\\n        }\\n            \\n        int[][] result = new int[k][2];\\n        \\n        for (int i = 0; i < k; i++) {\\n            result[i][0] = heap.peek()[0];\\n            result[i][1] = heap.poll()[1];\\n        }\\n            \\n        return result;\\n    }\\n    \\n    private int computeDistance(int[] distance) {\\n        return (int) Math.sqrt(distance[0] * distance[0] + distance[1] * distance[1]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "dojoce",
                        "content": "You need to compare the distances as a doube not an int. Using\n\nQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingDouble(point -> computeDistance(point)));"
                    },
                    {
                        "username": "barrett7212",
                        "content": "I think it\\'s because you are computing distance as an `int`, which is truncating your calculated values. Switch to a `double` and it should work."
                    },
                    {
                        "username": "ajinkyaw",
                        "content": "Below is my code and is failing for [[0,1],[1,0]] case which won\\'t satisfy unique answer condition, also when inserted in custom testcase it stands on same claim as me but it\\'s failing while submitting, any help?\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        unordered_map<int,pair<int,int>> hmap;\\n        priority_queue<pair<int,pair<int,int>>> maxh;\\n        int distance,x,y;\\n        pair<int,int> temp;\\n        for(int i=0;i<points.size();i++){\\n            x = points[i][0]; y = points[i][1];\\n            distance=pow(x,2)+pow(y,2);\\n            temp.first=x;\\n            temp.second=y;\\n            hmap.insert({distance,temp});\\n        }\\n        for(auto itr=hmap.begin();itr!=hmap.end();itr++){\\n            maxh.push({itr->first,itr->second});\\n            if(maxh.size()>k)\\n                maxh.pop();\\n        }\\n        vector<vector<int>> ans(maxh.size(), vector<int>(2,0));\\n        int i=0;\\n        while(maxh.empty()!=1){\\n            ans[i][0]=maxh.top().second.first;\\n            ans[i][1]=maxh.top().second.second;\\n            maxh.pop();i++;\\n        }\\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "aman_online67",
                        "content": "[@THEb0ss34](/THEb0ss34)  distances are same in both the vectors. so it can differentiate between them."
                    },
                    {
                        "username": "vicente3j",
                        "content": "[@THEb0ss34](/THEb0ss34) Yeah I got the same problem. I passed 83/87 test cases but this one is giving me trouble"
                    },
                    {
                        "username": "THEb0ss34",
                        "content": "I have the same problem not sure what they mean!"
                    }
                ]
            },
            {
                "id": 1639872,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/k-closest-points-to-origin/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort with Custom Comparator\n\n  \n**Approach 2:** Max Heap or Max Priority Queue\n\n  \n**Approach 3:** Binary Search\n\n  \n**Approach 4:** QuickSelect\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GavinBelson",
                        "content": "For those of you who got asked this question by facebook, do they make you do the quick select solution since it is the best asymptotic O(n) on average, or is a \"sorting\" solution of O(nlogn) acceptable?  I\\'m sure it might vary by interviewer and by the level you\\'re applying to, but I am curious how this situation may play out in real life."
                    },
                    {
                        "username": "neo9729",
                        "content": "Don\\'t rush to solve the problem. Read carefully and euclidean distance should be considered as double"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "I just used squares - with an int"
                    },
                    {
                        "username": "delanoi",
                        "content": "nice observation! but if you are only using the value for sorting purpose, we don\\'t really need to do the square root tho, without it, the sorting result should still be correct"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guys who added 85-87 testcases are true gentleman !!"
                    },
                    {
                        "username": "gbiems",
                        "content": "If you\\'re using python and don\\'t about heappushpop, definitely look it up. Greatly simplifies the code. \\n\\nI came across this question when I decided to review some of my early leetcode solutions now that I have a better sense of how to solve these problems. Looks like when I first tried this problem, I processed all points and sorted, a solution which does work, but is much slower.\\n\\nThis time around, I went with a heap, but I didn\\'t know about heappushpop, so my code was kind of complicated. \\n\\nFinally looked at solutions and learned something. I didn\\'t know about heappushpop. Good to know. \\n\\n "
                    },
                    {
                        "username": "cannellajs2",
                        "content": "`\\nstd::ios::sync_with_stdio(false);std::cin.tie(NULL);std::cout.tie(NULL); \\n`\\nWas wondering what this was on the fastest submission. Simply added it at the top of my function and it decreased my runtime.\\nUSER BEWARE:\\nFrom what I just read about this it allows C++ IOs to not have to be Synchronized to C IOs. This can allow it to run faster but can cause real issues if you use both stdio and cin/cout. Also cin and cout will be desynchronized.\\nFor better description look here: https://stackoverflow.com/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull"
                    },
                    {
                        "username": "peterx123",
                        "content": "Using sqrt and casting to int definitly would give wrong answer. The formla given by the description is a bait."
                    },
                    {
                        "username": "Kaltu",
                        "content": "how on earth the sorting solution beats 99.87%\\nI was expecting a TLE, LeetCode\\uD83E\\uDD23\\n```\\nclass Solution:\\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(points, key=lambda x: x[0] * x[0] + x[1] * x[1])[:k]\\n```"
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "BlackPantha007",
                        "content": "Hi all, please can someone help point out the improvement I need to make to this code to get it to pass all tests cases (it is passing 77/87 tests cases)?\\n```\\nclass Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        \\n        // maxHeap to store values base on how close it\\'s distance is from 0.\\n        PriorityQueue<int[]> heap = new PriorityQueue<>(\\n            (arr1, arr2) -> computeDistance(arr2) - computeDistance(arr1)\\n        );\\n            \\n        for (int[] point : points) {\\n            heap.offer(point);\\n            if (heap.size() > k) {\\n                heap.poll();\\n            }\\n        }\\n            \\n        int[][] result = new int[k][2];\\n        \\n        for (int i = 0; i < k; i++) {\\n            result[i][0] = heap.peek()[0];\\n            result[i][1] = heap.poll()[1];\\n        }\\n            \\n        return result;\\n    }\\n    \\n    private int computeDistance(int[] distance) {\\n        return (int) Math.sqrt(distance[0] * distance[0] + distance[1] * distance[1]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "dojoce",
                        "content": "You need to compare the distances as a doube not an int. Using\n\nQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingDouble(point -> computeDistance(point)));"
                    },
                    {
                        "username": "barrett7212",
                        "content": "I think it\\'s because you are computing distance as an `int`, which is truncating your calculated values. Switch to a `double` and it should work."
                    },
                    {
                        "username": "ajinkyaw",
                        "content": "Below is my code and is failing for [[0,1],[1,0]] case which won\\'t satisfy unique answer condition, also when inserted in custom testcase it stands on same claim as me but it\\'s failing while submitting, any help?\\n```\\nvector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        unordered_map<int,pair<int,int>> hmap;\\n        priority_queue<pair<int,pair<int,int>>> maxh;\\n        int distance,x,y;\\n        pair<int,int> temp;\\n        for(int i=0;i<points.size();i++){\\n            x = points[i][0]; y = points[i][1];\\n            distance=pow(x,2)+pow(y,2);\\n            temp.first=x;\\n            temp.second=y;\\n            hmap.insert({distance,temp});\\n        }\\n        for(auto itr=hmap.begin();itr!=hmap.end();itr++){\\n            maxh.push({itr->first,itr->second});\\n            if(maxh.size()>k)\\n                maxh.pop();\\n        }\\n        vector<vector<int>> ans(maxh.size(), vector<int>(2,0));\\n        int i=0;\\n        while(maxh.empty()!=1){\\n            ans[i][0]=maxh.top().second.first;\\n            ans[i][1]=maxh.top().second.second;\\n            maxh.pop();i++;\\n        }\\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "aman_online67",
                        "content": "[@THEb0ss34](/THEb0ss34)  distances are same in both the vectors. so it can differentiate between them."
                    },
                    {
                        "username": "vicente3j",
                        "content": "[@THEb0ss34](/THEb0ss34) Yeah I got the same problem. I passed 83/87 test cases but this one is giving me trouble"
                    },
                    {
                        "username": "THEb0ss34",
                        "content": "I have the same problem not sure what they mean!"
                    }
                ]
            },
            {
                "id": 1576576,
                "content": [
                    {
                        "username": "singhjp006",
                        "content": "I am wondering if the same/ similar question comes in the interview, which approach we should start/discuss with? Because depends on person to person the interviewer may argue that min-heap has better complexity O(nlogk) for all cases and maybe the interviewer may argue that O(n) average for quickSelect is better. Please help me."
                    },
                    {
                        "username": "Dags",
                        "content": "you should use MaxHeap instead of MinHeap"
                    },
                    {
                        "username": "chaselal",
                        "content": "You should propose both solutions and explain the tradeoffs"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "It should be in easy category"
                    },
                    {
                        "username": "Fly_ing__Rhi_no",
                        "content": "![image](https://assets.leetcode.com/users/images/fe73ff2a-b074-44f5-bcff-aff836ada2a5_1640501483.248622.png)\\nAny corrections, suggestions or optimizations to code are welcomed. :)\\nIf you found this post helpful then please like and comment to incerase it\\'s reach. :)"
                    },
                    {
                        "username": "sk4142",
                        "content": "use Euclidian distance squared so you don\\'t have to deal with type casting. i.e., ignore the square root."
                    },
                    {
                        "username": "ephemer1s",
                        "content": "Are there any answer that implemented their own heap?"
                    },
                    {
                        "username": "Douglas_C",
                        "content": "Can somebody explain why the following solution does not work?\\nMy distance calculation for the case [[9997, 9997],[9996, 9998]] gives the same distance:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<vector<int>> res;\\n        priority_queue<tuple<float, vector<int>>> pq = {};\\n        for (vector<int> pt : points) {\\n            float d = dist(pt); // dist({9997, 9997}), dist({9996, 9998}) has identical values which is not true\\n            pq.push({d, pt});\\n            if (pq.size() > k) {\\n                pq.pop();\\n            }\\n        }\\n\\n        while (!pq.empty()) {\\n            auto [d, pt] = pq.top();\\n            pq.pop();\\n            res.push_back(pt);\\n        }\\n        return res;\\n    }\\n\\n    float dist(vector<int> &point) {\\n        return sqrt(pow(point[0], 2) + pow(point[1], 2));\\n    }\\n};\\n```"
                    },
                    {
                        "username": "adddy20",
                        "content": "hi what is wrong in this - \\nclass Solution {\\npublic:\\n\\n    bool comp(vector<int>& points1,vector<int>& points2)\\n    {\\n       return points1[2] < points2[2];\\n    }\\n\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        int n = points.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int ans = points[i][0]*points[i][0] + points[i][1]*points[i][1];\\n            points[i].push_back(ans);\\n        }\\n        sort(points.begin(),points.end(),comp);\\n        vector<vector<int>> ans;\\n        for(int i=0;i<k;i++)\\n        {\\n            vector<int> look;\\n            look.push_back(points[i][0]);\\n            look.push_back(points[i][1]);\\n            ans.push_back(look);\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Testcase generator\\n\\n```\\nans = []\\nfor _ in range(10000):\\n    ans.append([random.randint(-9999, 9999), random.randint(-9999, 9999)])\\nprint(json.dumps(ans))\\npyperclip.copy(json.dumps(ans))\\n```"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "maintain `max heap` for only `k` smaller distances.\\npop from heap `(largest distance)` when heap length exceeds k `len(heap)>k`"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I think the case designed to TLE a standard quickselect (I believe its 85 or 86) is bad to include. 90% of interviewers giving this question are likely seeing if you can implement quickselect, not if you can import a heap or multiset. Its understandable that one should know the very spesific case thats bad for quick select where it becomes n^2, but its way too specific to just be breaking the intended algorithm for this problem."
                    }
                ]
            },
            {
                "id": 1974835,
                "content": [
                    {
                        "username": "singhjp006",
                        "content": "I am wondering if the same/ similar question comes in the interview, which approach we should start/discuss with? Because depends on person to person the interviewer may argue that min-heap has better complexity O(nlogk) for all cases and maybe the interviewer may argue that O(n) average for quickSelect is better. Please help me."
                    },
                    {
                        "username": "Dags",
                        "content": "you should use MaxHeap instead of MinHeap"
                    },
                    {
                        "username": "chaselal",
                        "content": "You should propose both solutions and explain the tradeoffs"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "It should be in easy category"
                    },
                    {
                        "username": "Fly_ing__Rhi_no",
                        "content": "![image](https://assets.leetcode.com/users/images/fe73ff2a-b074-44f5-bcff-aff836ada2a5_1640501483.248622.png)\\nAny corrections, suggestions or optimizations to code are welcomed. :)\\nIf you found this post helpful then please like and comment to incerase it\\'s reach. :)"
                    },
                    {
                        "username": "sk4142",
                        "content": "use Euclidian distance squared so you don\\'t have to deal with type casting. i.e., ignore the square root."
                    },
                    {
                        "username": "ephemer1s",
                        "content": "Are there any answer that implemented their own heap?"
                    },
                    {
                        "username": "Douglas_C",
                        "content": "Can somebody explain why the following solution does not work?\\nMy distance calculation for the case [[9997, 9997],[9996, 9998]] gives the same distance:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<vector<int>> res;\\n        priority_queue<tuple<float, vector<int>>> pq = {};\\n        for (vector<int> pt : points) {\\n            float d = dist(pt); // dist({9997, 9997}), dist({9996, 9998}) has identical values which is not true\\n            pq.push({d, pt});\\n            if (pq.size() > k) {\\n                pq.pop();\\n            }\\n        }\\n\\n        while (!pq.empty()) {\\n            auto [d, pt] = pq.top();\\n            pq.pop();\\n            res.push_back(pt);\\n        }\\n        return res;\\n    }\\n\\n    float dist(vector<int> &point) {\\n        return sqrt(pow(point[0], 2) + pow(point[1], 2));\\n    }\\n};\\n```"
                    },
                    {
                        "username": "adddy20",
                        "content": "hi what is wrong in this - \\nclass Solution {\\npublic:\\n\\n    bool comp(vector<int>& points1,vector<int>& points2)\\n    {\\n       return points1[2] < points2[2];\\n    }\\n\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        int n = points.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int ans = points[i][0]*points[i][0] + points[i][1]*points[i][1];\\n            points[i].push_back(ans);\\n        }\\n        sort(points.begin(),points.end(),comp);\\n        vector<vector<int>> ans;\\n        for(int i=0;i<k;i++)\\n        {\\n            vector<int> look;\\n            look.push_back(points[i][0]);\\n            look.push_back(points[i][1]);\\n            ans.push_back(look);\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Testcase generator\\n\\n```\\nans = []\\nfor _ in range(10000):\\n    ans.append([random.randint(-9999, 9999), random.randint(-9999, 9999)])\\nprint(json.dumps(ans))\\npyperclip.copy(json.dumps(ans))\\n```"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "maintain `max heap` for only `k` smaller distances.\\npop from heap `(largest distance)` when heap length exceeds k `len(heap)>k`"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I think the case designed to TLE a standard quickselect (I believe its 85 or 86) is bad to include. 90% of interviewers giving this question are likely seeing if you can implement quickselect, not if you can import a heap or multiset. Its understandable that one should know the very spesific case thats bad for quick select where it becomes n^2, but its way too specific to just be breaking the intended algorithm for this problem."
                    }
                ]
            },
            {
                "id": 1576125,
                "content": [
                    {
                        "username": "singhjp006",
                        "content": "I am wondering if the same/ similar question comes in the interview, which approach we should start/discuss with? Because depends on person to person the interviewer may argue that min-heap has better complexity O(nlogk) for all cases and maybe the interviewer may argue that O(n) average for quickSelect is better. Please help me."
                    },
                    {
                        "username": "Dags",
                        "content": "you should use MaxHeap instead of MinHeap"
                    },
                    {
                        "username": "chaselal",
                        "content": "You should propose both solutions and explain the tradeoffs"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "It should be in easy category"
                    },
                    {
                        "username": "Fly_ing__Rhi_no",
                        "content": "![image](https://assets.leetcode.com/users/images/fe73ff2a-b074-44f5-bcff-aff836ada2a5_1640501483.248622.png)\\nAny corrections, suggestions or optimizations to code are welcomed. :)\\nIf you found this post helpful then please like and comment to incerase it\\'s reach. :)"
                    },
                    {
                        "username": "sk4142",
                        "content": "use Euclidian distance squared so you don\\'t have to deal with type casting. i.e., ignore the square root."
                    },
                    {
                        "username": "ephemer1s",
                        "content": "Are there any answer that implemented their own heap?"
                    },
                    {
                        "username": "Douglas_C",
                        "content": "Can somebody explain why the following solution does not work?\\nMy distance calculation for the case [[9997, 9997],[9996, 9998]] gives the same distance:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<vector<int>> res;\\n        priority_queue<tuple<float, vector<int>>> pq = {};\\n        for (vector<int> pt : points) {\\n            float d = dist(pt); // dist({9997, 9997}), dist({9996, 9998}) has identical values which is not true\\n            pq.push({d, pt});\\n            if (pq.size() > k) {\\n                pq.pop();\\n            }\\n        }\\n\\n        while (!pq.empty()) {\\n            auto [d, pt] = pq.top();\\n            pq.pop();\\n            res.push_back(pt);\\n        }\\n        return res;\\n    }\\n\\n    float dist(vector<int> &point) {\\n        return sqrt(pow(point[0], 2) + pow(point[1], 2));\\n    }\\n};\\n```"
                    },
                    {
                        "username": "adddy20",
                        "content": "hi what is wrong in this - \\nclass Solution {\\npublic:\\n\\n    bool comp(vector<int>& points1,vector<int>& points2)\\n    {\\n       return points1[2] < points2[2];\\n    }\\n\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        int n = points.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int ans = points[i][0]*points[i][0] + points[i][1]*points[i][1];\\n            points[i].push_back(ans);\\n        }\\n        sort(points.begin(),points.end(),comp);\\n        vector<vector<int>> ans;\\n        for(int i=0;i<k;i++)\\n        {\\n            vector<int> look;\\n            look.push_back(points[i][0]);\\n            look.push_back(points[i][1]);\\n            ans.push_back(look);\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Testcase generator\\n\\n```\\nans = []\\nfor _ in range(10000):\\n    ans.append([random.randint(-9999, 9999), random.randint(-9999, 9999)])\\nprint(json.dumps(ans))\\npyperclip.copy(json.dumps(ans))\\n```"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "maintain `max heap` for only `k` smaller distances.\\npop from heap `(largest distance)` when heap length exceeds k `len(heap)>k`"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I think the case designed to TLE a standard quickselect (I believe its 85 or 86) is bad to include. 90% of interviewers giving this question are likely seeing if you can implement quickselect, not if you can import a heap or multiset. Its understandable that one should know the very spesific case thats bad for quick select where it becomes n^2, but its way too specific to just be breaking the intended algorithm for this problem."
                    }
                ]
            },
            {
                "id": 2060816,
                "content": [
                    {
                        "username": "singhjp006",
                        "content": "I am wondering if the same/ similar question comes in the interview, which approach we should start/discuss with? Because depends on person to person the interviewer may argue that min-heap has better complexity O(nlogk) for all cases and maybe the interviewer may argue that O(n) average for quickSelect is better. Please help me."
                    },
                    {
                        "username": "Dags",
                        "content": "you should use MaxHeap instead of MinHeap"
                    },
                    {
                        "username": "chaselal",
                        "content": "You should propose both solutions and explain the tradeoffs"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "It should be in easy category"
                    },
                    {
                        "username": "Fly_ing__Rhi_no",
                        "content": "![image](https://assets.leetcode.com/users/images/fe73ff2a-b074-44f5-bcff-aff836ada2a5_1640501483.248622.png)\\nAny corrections, suggestions or optimizations to code are welcomed. :)\\nIf you found this post helpful then please like and comment to incerase it\\'s reach. :)"
                    },
                    {
                        "username": "sk4142",
                        "content": "use Euclidian distance squared so you don\\'t have to deal with type casting. i.e., ignore the square root."
                    },
                    {
                        "username": "ephemer1s",
                        "content": "Are there any answer that implemented their own heap?"
                    },
                    {
                        "username": "Douglas_C",
                        "content": "Can somebody explain why the following solution does not work?\\nMy distance calculation for the case [[9997, 9997],[9996, 9998]] gives the same distance:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<vector<int>> res;\\n        priority_queue<tuple<float, vector<int>>> pq = {};\\n        for (vector<int> pt : points) {\\n            float d = dist(pt); // dist({9997, 9997}), dist({9996, 9998}) has identical values which is not true\\n            pq.push({d, pt});\\n            if (pq.size() > k) {\\n                pq.pop();\\n            }\\n        }\\n\\n        while (!pq.empty()) {\\n            auto [d, pt] = pq.top();\\n            pq.pop();\\n            res.push_back(pt);\\n        }\\n        return res;\\n    }\\n\\n    float dist(vector<int> &point) {\\n        return sqrt(pow(point[0], 2) + pow(point[1], 2));\\n    }\\n};\\n```"
                    },
                    {
                        "username": "adddy20",
                        "content": "hi what is wrong in this - \\nclass Solution {\\npublic:\\n\\n    bool comp(vector<int>& points1,vector<int>& points2)\\n    {\\n       return points1[2] < points2[2];\\n    }\\n\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        int n = points.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int ans = points[i][0]*points[i][0] + points[i][1]*points[i][1];\\n            points[i].push_back(ans);\\n        }\\n        sort(points.begin(),points.end(),comp);\\n        vector<vector<int>> ans;\\n        for(int i=0;i<k;i++)\\n        {\\n            vector<int> look;\\n            look.push_back(points[i][0]);\\n            look.push_back(points[i][1]);\\n            ans.push_back(look);\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Testcase generator\\n\\n```\\nans = []\\nfor _ in range(10000):\\n    ans.append([random.randint(-9999, 9999), random.randint(-9999, 9999)])\\nprint(json.dumps(ans))\\npyperclip.copy(json.dumps(ans))\\n```"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "maintain `max heap` for only `k` smaller distances.\\npop from heap `(largest distance)` when heap length exceeds k `len(heap)>k`"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I think the case designed to TLE a standard quickselect (I believe its 85 or 86) is bad to include. 90% of interviewers giving this question are likely seeing if you can implement quickselect, not if you can import a heap or multiset. Its understandable that one should know the very spesific case thats bad for quick select where it becomes n^2, but its way too specific to just be breaking the intended algorithm for this problem."
                    }
                ]
            },
            {
                "id": 2045762,
                "content": [
                    {
                        "username": "singhjp006",
                        "content": "I am wondering if the same/ similar question comes in the interview, which approach we should start/discuss with? Because depends on person to person the interviewer may argue that min-heap has better complexity O(nlogk) for all cases and maybe the interviewer may argue that O(n) average for quickSelect is better. Please help me."
                    },
                    {
                        "username": "Dags",
                        "content": "you should use MaxHeap instead of MinHeap"
                    },
                    {
                        "username": "chaselal",
                        "content": "You should propose both solutions and explain the tradeoffs"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "It should be in easy category"
                    },
                    {
                        "username": "Fly_ing__Rhi_no",
                        "content": "![image](https://assets.leetcode.com/users/images/fe73ff2a-b074-44f5-bcff-aff836ada2a5_1640501483.248622.png)\\nAny corrections, suggestions or optimizations to code are welcomed. :)\\nIf you found this post helpful then please like and comment to incerase it\\'s reach. :)"
                    },
                    {
                        "username": "sk4142",
                        "content": "use Euclidian distance squared so you don\\'t have to deal with type casting. i.e., ignore the square root."
                    },
                    {
                        "username": "ephemer1s",
                        "content": "Are there any answer that implemented their own heap?"
                    },
                    {
                        "username": "Douglas_C",
                        "content": "Can somebody explain why the following solution does not work?\\nMy distance calculation for the case [[9997, 9997],[9996, 9998]] gives the same distance:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<vector<int>> res;\\n        priority_queue<tuple<float, vector<int>>> pq = {};\\n        for (vector<int> pt : points) {\\n            float d = dist(pt); // dist({9997, 9997}), dist({9996, 9998}) has identical values which is not true\\n            pq.push({d, pt});\\n            if (pq.size() > k) {\\n                pq.pop();\\n            }\\n        }\\n\\n        while (!pq.empty()) {\\n            auto [d, pt] = pq.top();\\n            pq.pop();\\n            res.push_back(pt);\\n        }\\n        return res;\\n    }\\n\\n    float dist(vector<int> &point) {\\n        return sqrt(pow(point[0], 2) + pow(point[1], 2));\\n    }\\n};\\n```"
                    },
                    {
                        "username": "adddy20",
                        "content": "hi what is wrong in this - \\nclass Solution {\\npublic:\\n\\n    bool comp(vector<int>& points1,vector<int>& points2)\\n    {\\n       return points1[2] < points2[2];\\n    }\\n\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        int n = points.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int ans = points[i][0]*points[i][0] + points[i][1]*points[i][1];\\n            points[i].push_back(ans);\\n        }\\n        sort(points.begin(),points.end(),comp);\\n        vector<vector<int>> ans;\\n        for(int i=0;i<k;i++)\\n        {\\n            vector<int> look;\\n            look.push_back(points[i][0]);\\n            look.push_back(points[i][1]);\\n            ans.push_back(look);\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Testcase generator\\n\\n```\\nans = []\\nfor _ in range(10000):\\n    ans.append([random.randint(-9999, 9999), random.randint(-9999, 9999)])\\nprint(json.dumps(ans))\\npyperclip.copy(json.dumps(ans))\\n```"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "maintain `max heap` for only `k` smaller distances.\\npop from heap `(largest distance)` when heap length exceeds k `len(heap)>k`"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I think the case designed to TLE a standard quickselect (I believe its 85 or 86) is bad to include. 90% of interviewers giving this question are likely seeing if you can implement quickselect, not if you can import a heap or multiset. Its understandable that one should know the very spesific case thats bad for quick select where it becomes n^2, but its way too specific to just be breaking the intended algorithm for this problem."
                    }
                ]
            },
            {
                "id": 2039487,
                "content": [
                    {
                        "username": "singhjp006",
                        "content": "I am wondering if the same/ similar question comes in the interview, which approach we should start/discuss with? Because depends on person to person the interviewer may argue that min-heap has better complexity O(nlogk) for all cases and maybe the interviewer may argue that O(n) average for quickSelect is better. Please help me."
                    },
                    {
                        "username": "Dags",
                        "content": "you should use MaxHeap instead of MinHeap"
                    },
                    {
                        "username": "chaselal",
                        "content": "You should propose both solutions and explain the tradeoffs"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "It should be in easy category"
                    },
                    {
                        "username": "Fly_ing__Rhi_no",
                        "content": "![image](https://assets.leetcode.com/users/images/fe73ff2a-b074-44f5-bcff-aff836ada2a5_1640501483.248622.png)\\nAny corrections, suggestions or optimizations to code are welcomed. :)\\nIf you found this post helpful then please like and comment to incerase it\\'s reach. :)"
                    },
                    {
                        "username": "sk4142",
                        "content": "use Euclidian distance squared so you don\\'t have to deal with type casting. i.e., ignore the square root."
                    },
                    {
                        "username": "ephemer1s",
                        "content": "Are there any answer that implemented their own heap?"
                    },
                    {
                        "username": "Douglas_C",
                        "content": "Can somebody explain why the following solution does not work?\\nMy distance calculation for the case [[9997, 9997],[9996, 9998]] gives the same distance:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<vector<int>> res;\\n        priority_queue<tuple<float, vector<int>>> pq = {};\\n        for (vector<int> pt : points) {\\n            float d = dist(pt); // dist({9997, 9997}), dist({9996, 9998}) has identical values which is not true\\n            pq.push({d, pt});\\n            if (pq.size() > k) {\\n                pq.pop();\\n            }\\n        }\\n\\n        while (!pq.empty()) {\\n            auto [d, pt] = pq.top();\\n            pq.pop();\\n            res.push_back(pt);\\n        }\\n        return res;\\n    }\\n\\n    float dist(vector<int> &point) {\\n        return sqrt(pow(point[0], 2) + pow(point[1], 2));\\n    }\\n};\\n```"
                    },
                    {
                        "username": "adddy20",
                        "content": "hi what is wrong in this - \\nclass Solution {\\npublic:\\n\\n    bool comp(vector<int>& points1,vector<int>& points2)\\n    {\\n       return points1[2] < points2[2];\\n    }\\n\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        int n = points.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int ans = points[i][0]*points[i][0] + points[i][1]*points[i][1];\\n            points[i].push_back(ans);\\n        }\\n        sort(points.begin(),points.end(),comp);\\n        vector<vector<int>> ans;\\n        for(int i=0;i<k;i++)\\n        {\\n            vector<int> look;\\n            look.push_back(points[i][0]);\\n            look.push_back(points[i][1]);\\n            ans.push_back(look);\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Testcase generator\\n\\n```\\nans = []\\nfor _ in range(10000):\\n    ans.append([random.randint(-9999, 9999), random.randint(-9999, 9999)])\\nprint(json.dumps(ans))\\npyperclip.copy(json.dumps(ans))\\n```"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "maintain `max heap` for only `k` smaller distances.\\npop from heap `(largest distance)` when heap length exceeds k `len(heap)>k`"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I think the case designed to TLE a standard quickselect (I believe its 85 or 86) is bad to include. 90% of interviewers giving this question are likely seeing if you can implement quickselect, not if you can import a heap or multiset. Its understandable that one should know the very spesific case thats bad for quick select where it becomes n^2, but its way too specific to just be breaking the intended algorithm for this problem."
                    }
                ]
            },
            {
                "id": 1998977,
                "content": [
                    {
                        "username": "singhjp006",
                        "content": "I am wondering if the same/ similar question comes in the interview, which approach we should start/discuss with? Because depends on person to person the interviewer may argue that min-heap has better complexity O(nlogk) for all cases and maybe the interviewer may argue that O(n) average for quickSelect is better. Please help me."
                    },
                    {
                        "username": "Dags",
                        "content": "you should use MaxHeap instead of MinHeap"
                    },
                    {
                        "username": "chaselal",
                        "content": "You should propose both solutions and explain the tradeoffs"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "It should be in easy category"
                    },
                    {
                        "username": "Fly_ing__Rhi_no",
                        "content": "![image](https://assets.leetcode.com/users/images/fe73ff2a-b074-44f5-bcff-aff836ada2a5_1640501483.248622.png)\\nAny corrections, suggestions or optimizations to code are welcomed. :)\\nIf you found this post helpful then please like and comment to incerase it\\'s reach. :)"
                    },
                    {
                        "username": "sk4142",
                        "content": "use Euclidian distance squared so you don\\'t have to deal with type casting. i.e., ignore the square root."
                    },
                    {
                        "username": "ephemer1s",
                        "content": "Are there any answer that implemented their own heap?"
                    },
                    {
                        "username": "Douglas_C",
                        "content": "Can somebody explain why the following solution does not work?\\nMy distance calculation for the case [[9997, 9997],[9996, 9998]] gives the same distance:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<vector<int>> res;\\n        priority_queue<tuple<float, vector<int>>> pq = {};\\n        for (vector<int> pt : points) {\\n            float d = dist(pt); // dist({9997, 9997}), dist({9996, 9998}) has identical values which is not true\\n            pq.push({d, pt});\\n            if (pq.size() > k) {\\n                pq.pop();\\n            }\\n        }\\n\\n        while (!pq.empty()) {\\n            auto [d, pt] = pq.top();\\n            pq.pop();\\n            res.push_back(pt);\\n        }\\n        return res;\\n    }\\n\\n    float dist(vector<int> &point) {\\n        return sqrt(pow(point[0], 2) + pow(point[1], 2));\\n    }\\n};\\n```"
                    },
                    {
                        "username": "adddy20",
                        "content": "hi what is wrong in this - \\nclass Solution {\\npublic:\\n\\n    bool comp(vector<int>& points1,vector<int>& points2)\\n    {\\n       return points1[2] < points2[2];\\n    }\\n\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        int n = points.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int ans = points[i][0]*points[i][0] + points[i][1]*points[i][1];\\n            points[i].push_back(ans);\\n        }\\n        sort(points.begin(),points.end(),comp);\\n        vector<vector<int>> ans;\\n        for(int i=0;i<k;i++)\\n        {\\n            vector<int> look;\\n            look.push_back(points[i][0]);\\n            look.push_back(points[i][1]);\\n            ans.push_back(look);\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Testcase generator\\n\\n```\\nans = []\\nfor _ in range(10000):\\n    ans.append([random.randint(-9999, 9999), random.randint(-9999, 9999)])\\nprint(json.dumps(ans))\\npyperclip.copy(json.dumps(ans))\\n```"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "maintain `max heap` for only `k` smaller distances.\\npop from heap `(largest distance)` when heap length exceeds k `len(heap)>k`"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I think the case designed to TLE a standard quickselect (I believe its 85 or 86) is bad to include. 90% of interviewers giving this question are likely seeing if you can implement quickselect, not if you can import a heap or multiset. Its understandable that one should know the very spesific case thats bad for quick select where it becomes n^2, but its way too specific to just be breaking the intended algorithm for this problem."
                    }
                ]
            },
            {
                "id": 1982259,
                "content": [
                    {
                        "username": "singhjp006",
                        "content": "I am wondering if the same/ similar question comes in the interview, which approach we should start/discuss with? Because depends on person to person the interviewer may argue that min-heap has better complexity O(nlogk) for all cases and maybe the interviewer may argue that O(n) average for quickSelect is better. Please help me."
                    },
                    {
                        "username": "Dags",
                        "content": "you should use MaxHeap instead of MinHeap"
                    },
                    {
                        "username": "chaselal",
                        "content": "You should propose both solutions and explain the tradeoffs"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "It should be in easy category"
                    },
                    {
                        "username": "Fly_ing__Rhi_no",
                        "content": "![image](https://assets.leetcode.com/users/images/fe73ff2a-b074-44f5-bcff-aff836ada2a5_1640501483.248622.png)\\nAny corrections, suggestions or optimizations to code are welcomed. :)\\nIf you found this post helpful then please like and comment to incerase it\\'s reach. :)"
                    },
                    {
                        "username": "sk4142",
                        "content": "use Euclidian distance squared so you don\\'t have to deal with type casting. i.e., ignore the square root."
                    },
                    {
                        "username": "ephemer1s",
                        "content": "Are there any answer that implemented their own heap?"
                    },
                    {
                        "username": "Douglas_C",
                        "content": "Can somebody explain why the following solution does not work?\\nMy distance calculation for the case [[9997, 9997],[9996, 9998]] gives the same distance:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<vector<int>> res;\\n        priority_queue<tuple<float, vector<int>>> pq = {};\\n        for (vector<int> pt : points) {\\n            float d = dist(pt); // dist({9997, 9997}), dist({9996, 9998}) has identical values which is not true\\n            pq.push({d, pt});\\n            if (pq.size() > k) {\\n                pq.pop();\\n            }\\n        }\\n\\n        while (!pq.empty()) {\\n            auto [d, pt] = pq.top();\\n            pq.pop();\\n            res.push_back(pt);\\n        }\\n        return res;\\n    }\\n\\n    float dist(vector<int> &point) {\\n        return sqrt(pow(point[0], 2) + pow(point[1], 2));\\n    }\\n};\\n```"
                    },
                    {
                        "username": "adddy20",
                        "content": "hi what is wrong in this - \\nclass Solution {\\npublic:\\n\\n    bool comp(vector<int>& points1,vector<int>& points2)\\n    {\\n       return points1[2] < points2[2];\\n    }\\n\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        int n = points.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int ans = points[i][0]*points[i][0] + points[i][1]*points[i][1];\\n            points[i].push_back(ans);\\n        }\\n        sort(points.begin(),points.end(),comp);\\n        vector<vector<int>> ans;\\n        for(int i=0;i<k;i++)\\n        {\\n            vector<int> look;\\n            look.push_back(points[i][0]);\\n            look.push_back(points[i][1]);\\n            ans.push_back(look);\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Testcase generator\\n\\n```\\nans = []\\nfor _ in range(10000):\\n    ans.append([random.randint(-9999, 9999), random.randint(-9999, 9999)])\\nprint(json.dumps(ans))\\npyperclip.copy(json.dumps(ans))\\n```"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "maintain `max heap` for only `k` smaller distances.\\npop from heap `(largest distance)` when heap length exceeds k `len(heap)>k`"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I think the case designed to TLE a standard quickselect (I believe its 85 or 86) is bad to include. 90% of interviewers giving this question are likely seeing if you can implement quickselect, not if you can import a heap or multiset. Its understandable that one should know the very spesific case thats bad for quick select where it becomes n^2, but its way too specific to just be breaking the intended algorithm for this problem."
                    }
                ]
            },
            {
                "id": 1944032,
                "content": [
                    {
                        "username": "singhjp006",
                        "content": "I am wondering if the same/ similar question comes in the interview, which approach we should start/discuss with? Because depends on person to person the interviewer may argue that min-heap has better complexity O(nlogk) for all cases and maybe the interviewer may argue that O(n) average for quickSelect is better. Please help me."
                    },
                    {
                        "username": "Dags",
                        "content": "you should use MaxHeap instead of MinHeap"
                    },
                    {
                        "username": "chaselal",
                        "content": "You should propose both solutions and explain the tradeoffs"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "It should be in easy category"
                    },
                    {
                        "username": "Fly_ing__Rhi_no",
                        "content": "![image](https://assets.leetcode.com/users/images/fe73ff2a-b074-44f5-bcff-aff836ada2a5_1640501483.248622.png)\\nAny corrections, suggestions or optimizations to code are welcomed. :)\\nIf you found this post helpful then please like and comment to incerase it\\'s reach. :)"
                    },
                    {
                        "username": "sk4142",
                        "content": "use Euclidian distance squared so you don\\'t have to deal with type casting. i.e., ignore the square root."
                    },
                    {
                        "username": "ephemer1s",
                        "content": "Are there any answer that implemented their own heap?"
                    },
                    {
                        "username": "Douglas_C",
                        "content": "Can somebody explain why the following solution does not work?\\nMy distance calculation for the case [[9997, 9997],[9996, 9998]] gives the same distance:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<vector<int>> res;\\n        priority_queue<tuple<float, vector<int>>> pq = {};\\n        for (vector<int> pt : points) {\\n            float d = dist(pt); // dist({9997, 9997}), dist({9996, 9998}) has identical values which is not true\\n            pq.push({d, pt});\\n            if (pq.size() > k) {\\n                pq.pop();\\n            }\\n        }\\n\\n        while (!pq.empty()) {\\n            auto [d, pt] = pq.top();\\n            pq.pop();\\n            res.push_back(pt);\\n        }\\n        return res;\\n    }\\n\\n    float dist(vector<int> &point) {\\n        return sqrt(pow(point[0], 2) + pow(point[1], 2));\\n    }\\n};\\n```"
                    },
                    {
                        "username": "adddy20",
                        "content": "hi what is wrong in this - \\nclass Solution {\\npublic:\\n\\n    bool comp(vector<int>& points1,vector<int>& points2)\\n    {\\n       return points1[2] < points2[2];\\n    }\\n\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        int n = points.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int ans = points[i][0]*points[i][0] + points[i][1]*points[i][1];\\n            points[i].push_back(ans);\\n        }\\n        sort(points.begin(),points.end(),comp);\\n        vector<vector<int>> ans;\\n        for(int i=0;i<k;i++)\\n        {\\n            vector<int> look;\\n            look.push_back(points[i][0]);\\n            look.push_back(points[i][1]);\\n            ans.push_back(look);\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Testcase generator\\n\\n```\\nans = []\\nfor _ in range(10000):\\n    ans.append([random.randint(-9999, 9999), random.randint(-9999, 9999)])\\nprint(json.dumps(ans))\\npyperclip.copy(json.dumps(ans))\\n```"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "maintain `max heap` for only `k` smaller distances.\\npop from heap `(largest distance)` when heap length exceeds k `len(heap)>k`"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I think the case designed to TLE a standard quickselect (I believe its 85 or 86) is bad to include. 90% of interviewers giving this question are likely seeing if you can implement quickselect, not if you can import a heap or multiset. Its understandable that one should know the very spesific case thats bad for quick select where it becomes n^2, but its way too specific to just be breaking the intended algorithm for this problem."
                    }
                ]
            },
            {
                "id": 1738803,
                "content": [
                    {
                        "username": "singhjp006",
                        "content": "I am wondering if the same/ similar question comes in the interview, which approach we should start/discuss with? Because depends on person to person the interviewer may argue that min-heap has better complexity O(nlogk) for all cases and maybe the interviewer may argue that O(n) average for quickSelect is better. Please help me."
                    },
                    {
                        "username": "Dags",
                        "content": "you should use MaxHeap instead of MinHeap"
                    },
                    {
                        "username": "chaselal",
                        "content": "You should propose both solutions and explain the tradeoffs"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "It should be in easy category"
                    },
                    {
                        "username": "Fly_ing__Rhi_no",
                        "content": "![image](https://assets.leetcode.com/users/images/fe73ff2a-b074-44f5-bcff-aff836ada2a5_1640501483.248622.png)\\nAny corrections, suggestions or optimizations to code are welcomed. :)\\nIf you found this post helpful then please like and comment to incerase it\\'s reach. :)"
                    },
                    {
                        "username": "sk4142",
                        "content": "use Euclidian distance squared so you don\\'t have to deal with type casting. i.e., ignore the square root."
                    },
                    {
                        "username": "ephemer1s",
                        "content": "Are there any answer that implemented their own heap?"
                    },
                    {
                        "username": "Douglas_C",
                        "content": "Can somebody explain why the following solution does not work?\\nMy distance calculation for the case [[9997, 9997],[9996, 9998]] gives the same distance:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        vector<vector<int>> res;\\n        priority_queue<tuple<float, vector<int>>> pq = {};\\n        for (vector<int> pt : points) {\\n            float d = dist(pt); // dist({9997, 9997}), dist({9996, 9998}) has identical values which is not true\\n            pq.push({d, pt});\\n            if (pq.size() > k) {\\n                pq.pop();\\n            }\\n        }\\n\\n        while (!pq.empty()) {\\n            auto [d, pt] = pq.top();\\n            pq.pop();\\n            res.push_back(pt);\\n        }\\n        return res;\\n    }\\n\\n    float dist(vector<int> &point) {\\n        return sqrt(pow(point[0], 2) + pow(point[1], 2));\\n    }\\n};\\n```"
                    },
                    {
                        "username": "adddy20",
                        "content": "hi what is wrong in this - \\nclass Solution {\\npublic:\\n\\n    bool comp(vector<int>& points1,vector<int>& points2)\\n    {\\n       return points1[2] < points2[2];\\n    }\\n\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        int n = points.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int ans = points[i][0]*points[i][0] + points[i][1]*points[i][1];\\n            points[i].push_back(ans);\\n        }\\n        sort(points.begin(),points.end(),comp);\\n        vector<vector<int>> ans;\\n        for(int i=0;i<k;i++)\\n        {\\n            vector<int> look;\\n            look.push_back(points[i][0]);\\n            look.push_back(points[i][1]);\\n            ans.push_back(look);\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Testcase generator\\n\\n```\\nans = []\\nfor _ in range(10000):\\n    ans.append([random.randint(-9999, 9999), random.randint(-9999, 9999)])\\nprint(json.dumps(ans))\\npyperclip.copy(json.dumps(ans))\\n```"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "maintain `max heap` for only `k` smaller distances.\\npop from heap `(largest distance)` when heap length exceeds k `len(heap)>k`"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I think the case designed to TLE a standard quickselect (I believe its 85 or 86) is bad to include. 90% of interviewers giving this question are likely seeing if you can implement quickselect, not if you can import a heap or multiset. Its understandable that one should know the very spesific case thats bad for quick select where it becomes n^2, but its way too specific to just be breaking the intended algorithm for this problem."
                    }
                ]
            }
        ]
    },
    {
        "title": "The k-th Lexicographical String of All Happy Strings of Length n",
        "question_content": "<p>A <strong>happy string</strong> is a string that:</p>\n\n<ul>\n\t<li>consists only of letters of the set <code>[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code>.</li>\n\t<li><code>s[i] != s[i + 1]</code> for all values of <code>i</code> from <code>1</code> to <code>s.length - 1</code> (string is 1-indexed).</li>\n</ul>\n\n<p>For example, strings <strong>&quot;abc&quot;, &quot;ac&quot;, &quot;b&quot;</strong> and <strong>&quot;abcbabcbcb&quot;</strong> are all happy strings and strings <strong>&quot;aa&quot;, &quot;baa&quot;</strong> and <strong>&quot;ababbc&quot;</strong> are not happy strings.</p>\n\n<p>Given two integers <code>n</code> and <code>k</code>, consider a list of all happy strings of length <code>n</code> sorted in lexicographical order.</p>\n\n<p>Return <em>the kth string</em> of this list or return an <strong>empty string</strong> if there are less than <code>k</code> happy strings of length <code>n</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1, k = 3\n<strong>Output:</strong> &quot;c&quot;\n<strong>Explanation:</strong> The list [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] contains all happy strings of length 1. The third string is &quot;c&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1, k = 4\n<strong>Output:</strong> &quot;&quot;\n<strong>Explanation:</strong> There are only 3 happy strings of length 1.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3, k = 9\n<strong>Output:</strong> &quot;cab&quot;\n<strong>Explanation:</strong> There are 12 different happy string of length 3 [&quot;aba&quot;, &quot;abc&quot;, &quot;aca&quot;, &quot;acb&quot;, &quot;bab&quot;, &quot;bac&quot;, &quot;bca&quot;, &quot;bcb&quot;, &quot;cab&quot;, &quot;cac&quot;, &quot;cba&quot;, &quot;cbc&quot;]. You will find the 9<sup>th</sup> string = &quot;cab&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10</code></li>\n\t<li><code>1 &lt;= k &lt;= 100</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 586165,
                "title": "python3-easy-python3-bfs-graph-like",
                "content": "` nextLetter ` is like a graph. `a -> bc`, `b -> ac`, `c -> ab`. \\nSince we are doing BFS with the next node in the graph already sorted, \\nwe are guaranteed to have a sorted queue with all the element of the \\nsame length.\\n\\nBreak when the first string in the queue is length `n` and find the `k`th value in the queue.\\n\\n```\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n        nextLetter = {\\'a\\': \\'bc\\', \\'b\\': \\'ac\\', \\'c\\': \\'ab\\'} \\n        q = collections.deque([\\'a\\', \\'b\\', \\'c\\'])\\n        while len(q[0]) != n:\\n            u = q.popleft()    \\n            for v in nextLetter[u[-1]]:\\n                q.append(u + v)\\n        return q[k - 1] if len(q) >= k else \\'\\'     \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n        nextLetter = {\\'a\\': \\'bc\\', \\'b\\': \\'ac\\', \\'c\\': \\'ab\\'} \\n        q = collections.deque([\\'a\\', \\'b\\', \\'c\\'])\\n        while len(q[0]) != n:\\n            u = q.popleft()    \\n            for v in nextLetter[u[-1]]:\\n                q.append(u + v)\\n        return q[k - 1] if len(q) >= k else \\'\\'     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 585590,
                "title": "c-java-dfs-and-math",
                "content": "#### Aproach 1: DFS\\nHere, DFS builds all possible strings in a lexicographical order. Each time a string is built, we decrease the global counter `k`. When `k` reaches zero, we short-circut DFS and build the resulting string right-to-left. \\n\\n> Exploring references and optional parameters for a concise code.\\n\\n```cpp\\nstring getHappyString(int n, int &k, int p = 0, char last_ch = 0) {\\n    if (p == n)\\n        --k;\\n    else\\n        for (char ch = \\'a\\'; ch <= \\'c\\'; ++ch) {\\n            if (ch != last_ch) {\\n                auto res = getHappyString(n, k, p + 1, ch);\\n                if (k == 0)\\n                    return string(1, ch) + res;\\n            }\\n        }\\n    return \"\";\\n}\\n```\\n**Complexity Analysis**\\n- Time: O(n * k); we evaluate `k` strings of the size `n`.\\n- Memory: O(n) for the stack (not including the output).\\n\\n#### Aproach 2: Math\\nFor the string of size `n`, we can build `3 * pow(2, n - 1)` strings. So, if `k <= pow(2, n - 1)`, then the first letter is `a`, `k <= 2 * pow(2, n - 1)` - then `b`, otherwise `c`. We can also return empty string right away if `k > 3 * pow(2, n - 1)`.\\n\\nWe continue building the string using the same approach but now with two choices.\\n\\n**C++**\\n```cpp\\nstring getHappyString(int n, int k) {\\n    auto prem = 1 << (n - 1);\\n    if (k > 3 * prem)\\n        return \"\";\\n    string s = string(1, \\'a\\' + (k - 1) / prem);\\n    while (prem > 1) {\\n        k = (k - 1) % prem + 1;\\n        prem >>= 1;\\n        s += (k - 1) / prem == 0 ? \\'a\\' + (s.back() == \\'a\\') : \\'b\\' + (s.back() != \\'c\\');\\n    }\\n    return s;\\n}\\n```\\n\\n**Java**\\n```java\\npublic String getHappyString(int n, int k) {\\n    int prem = 1 << (n - 1);\\n    if (k > 3 * prem)\\n        return \"\";\\n    int ch = \\'a\\' + (k - 1) / prem;\\n    StringBuilder sb = new StringBuilder(Character.toString(ch));\\n    while (prem > 1) {\\n        k = (k - 1) % prem + 1;\\n        prem >>= 1;\\n        ch = (k - 1) / prem == 0 ? \\'a\\' + (ch == \\'a\\' ? 1 : 0) : \\'b\\' + (ch != \\'c\\' ? 1 : 0);\\n        sb.append((char)ch);\\n    }\\n    return sb.toString();\\n}  \\n```\\n\\n**Complexity Analysis**\\n- Time: O(n); we build one string of the size `n`.\\n- Memory: O(1) - not considering output.",
                "solutionTags": [],
                "code": "```cpp\\nstring getHappyString(int n, int &k, int p = 0, char last_ch = 0) {\\n    if (p == n)\\n        --k;\\n    else\\n        for (char ch = \\'a\\'; ch <= \\'c\\'; ++ch) {\\n            if (ch != last_ch) {\\n                auto res = getHappyString(n, k, p + 1, ch);\\n                if (k == 0)\\n                    return string(1, ch) + res;\\n            }\\n        }\\n    return \"\";\\n}\\n```\n```cpp\\nstring getHappyString(int n, int k) {\\n    auto prem = 1 << (n - 1);\\n    if (k > 3 * prem)\\n        return \"\";\\n    string s = string(1, \\'a\\' + (k - 1) / prem);\\n    while (prem > 1) {\\n        k = (k - 1) % prem + 1;\\n        prem >>= 1;\\n        s += (k - 1) / prem == 0 ? \\'a\\' + (s.back() == \\'a\\') : \\'b\\' + (s.back() != \\'c\\');\\n    }\\n    return s;\\n}\\n```\n```java\\npublic String getHappyString(int n, int k) {\\n    int prem = 1 << (n - 1);\\n    if (k > 3 * prem)\\n        return \"\";\\n    int ch = \\'a\\' + (k - 1) / prem;\\n    StringBuilder sb = new StringBuilder(Character.toString(ch));\\n    while (prem > 1) {\\n        k = (k - 1) % prem + 1;\\n        prem >>= 1;\\n        ch = (k - 1) / prem == 0 ? \\'a\\' + (ch == \\'a\\' ? 1 : 0) : \\'b\\' + (ch != \\'c\\' ? 1 : 0);\\n        sb.append((char)ch);\\n    }\\n    return sb.toString();\\n}  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 586460,
                "title": "c-recursive-fully-explained-solution",
                "content": "```\\n//This is my first try to put code into discussion part hope you like it and if like please upvote :)\\n\\nclass Solution {\\npublic:\\n    \\n    void solve(vector<string>& ans,string& cur,int n,int& k,vector<char>& v){\\n        //before base cases please refer lower part :)\\n        if(ans.size()==k){\\n            //if size of answer vector is equal to k that means I found kth string with n length\\n            return;\\n        }\\n        if(cur.size()==n){\\n            //length of cur is equal to n means cur is part of ans and after that no further recursive call required so I  have returned\\n            ans.push_back(cur);\\n            return;\\n        }\\n        //here I\\'m iterate over all three elements of v if possible, it is possible if cur\\'s length is equal to zero otherwise I have to check if last element of cur shouldn\\'t equal to v[i]\\n        for(int i=0;i<3;i++){\\n            if(cur.size()==0 || cur[cur.size()-1]!=v[i]){\\n                //if condition satisifed then I should append that character to cur\\n                cur+=v[i];\\n                //call solve() with new value of cur\\n                solve(ans,cur,n,k,v);\\n                //after calling we should remove that character and try for other character for same length of cur for example after calling for \"ab\" I should call for \"ac\" calls are obviously in lexicogrphic order now you can see base cases :)\\n                cur.pop_back();\\n            }\\n        }\\n    }\\n    \\n    string getHappyString(int n, int k) {\\n        string cur=\"\"; //cur string with no characters\\n        vector<string> ans; //ans is vector of string which is going to store all string of length of cur string\\n        vector<char> v={\\'a\\',\\'b\\',\\'c\\'}; //vector of character in which characters \\'a\\',\\'b\\',\\'c\\' are stored\\n        solve(ans,cur,n,k,v); //firs function call with empty string with empty vector of string ans and n,k now, please refer implementation of solve :)\\n        if(ans.size()==k){\\n            //if program reach here from base case 1 which is ans\\'s size equals to k that means I should return last element of ans\\n            return ans.back();\\n        }\\n        else{\\n            //else I should return empty string\\n            return \"\";\\n        }\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n//This is my first try to put code into discussion part hope you like it and if like please upvote :)\\n\\nclass Solution {\\npublic:\\n    \\n    void solve(vector<string>& ans,string& cur,int n,int& k,vector<char>& v){\\n        //before base cases please refer lower part :)\\n        if(ans.size()==k){\\n            //if size of answer vector is equal to k that means I found kth string with n length\\n            return;\\n        }\\n        if(cur.size()==n){\\n            //length of cur is equal to n means cur is part of ans and after that no further recursive call required so I  have returned\\n            ans.push_back(cur);\\n            return;\\n        }\\n        //here I\\'m iterate over all three elements of v if possible, it is possible if cur\\'s length is equal to zero otherwise I have to check if last element of cur shouldn\\'t equal to v[i]\\n        for(int i=0;i<3;i++){\\n            if(cur.size()==0 || cur[cur.size()-1]!=v[i]){\\n                //if condition satisifed then I should append that character to cur\\n                cur+=v[i];\\n                //call solve() with new value of cur\\n                solve(ans,cur,n,k,v);\\n                //after calling we should remove that character and try for other character for same length of cur for example after calling for \"ab\" I should call for \"ac\" calls are obviously in lexicogrphic order now you can see base cases :)\\n                cur.pop_back();\\n            }\\n        }\\n    }\\n    \\n    string getHappyString(int n, int k) {\\n        string cur=\"\"; //cur string with no characters\\n        vector<string> ans; //ans is vector of string which is going to store all string of length of cur string\\n        vector<char> v={\\'a\\',\\'b\\',\\'c\\'}; //vector of character in which characters \\'a\\',\\'b\\',\\'c\\' are stored\\n        solve(ans,cur,n,k,v); //firs function call with empty string with empty vector of string ans and n,k now, please refer implementation of solve :)\\n        if(ans.size()==k){\\n            //if program reach here from base case 1 which is ans\\'s size equals to k that means I should return last element of ans\\n            return ans.back();\\n        }\\n        else{\\n            //else I should return empty string\\n            return \"\";\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 585569,
                "title": "easiest-solution-using-bfs-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string getHappyString(int n, int k) {\\n        vector<string> ans;\\n        queue<string> q;\\n        q.push(\"a\");\\n        q.push(\"b\");\\n        q.push(\"c\");\\n        while(!q.empty())\\n        {\\n            string x=q.front();\\n            q.pop();\\n            if(x.length()==n)\\n            {\\n                ans.push_back(x);\\n            }\\n            string s1=\"\",s2=\"\";\\n            if(x[x.length()-1]==\\'a\\')\\n            {\\n                s1=x+\"b\";\\n                s2=x+\"c\";\\n                \\n            }\\n            if(x[x.length()-1]==\\'b\\')\\n            {\\n                s1=x+\"a\";\\n                s2=x+\"c\";\\n                \\n            }\\n            if(x[x.length()-1]==\\'c\\')\\n            {\\n                s1=x+\"a\";\\n                s2=x+\"b\";\\n                \\n            }\\n            \\n            //push only when less than n\\n            \\n            if(s1.length()<=n)\\n            {\\n                q.push(s1);\\n            }\\n            if(s2.length()<=n)\\n            {\\n                q.push(s2);\\n            }\\n        }\\n   \\n        string s=\"\";\\n        if(k-1>=ans.size())\\n        {\\n            s=\"\";\\n        }\\n        else\\n        {\\n            s=ans[k-1];\\n        }\\n        return s;\\n        \\n    \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string getHappyString(int n, int k) {\\n        vector<string> ans;\\n        queue<string> q;\\n        q.push(\"a\");\\n        q.push(\"b\");\\n        q.push(\"c\");\\n        while(!q.empty())\\n        {\\n            string x=q.front();\\n            q.pop();\\n            if(x.length()==n)\\n            {\\n                ans.push_back(x);\\n            }\\n            string s1=\"\",s2=\"\";\\n            if(x[x.length()-1]==\\'a\\')\\n            {\\n                s1=x+\"b\";\\n                s2=x+\"c\";\\n                \\n            }\\n            if(x[x.length()-1]==\\'b\\')\\n            {\\n                s1=x+\"a\";\\n                s2=x+\"c\";\\n                \\n            }\\n            if(x[x.length()-1]==\\'c\\')\\n            {\\n                s1=x+\"a\";\\n                s2=x+\"b\";\\n                \\n            }\\n            \\n            //push only when less than n\\n            \\n            if(s1.length()<=n)\\n            {\\n                q.push(s1);\\n            }\\n            if(s2.length()<=n)\\n            {\\n                q.push(s2);\\n            }\\n        }\\n   \\n        string s=\"\";\\n        if(k-1>=ans.size())\\n        {\\n            s=\"\";\\n        }\\n        else\\n        {\\n            s=ans[k-1];\\n        }\\n        return s;\\n        \\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 585684,
                "title": "java-short-and-understandable-nooverdoing",
                "content": "**I am relatively new to this, so trust me if I am able to figure this one out, you can too :)!**\\n\\nI basically generate all permutations with s[i] != s[i+1] using this check as I append my next permutation\\n```\\nres.charAt(res.length()-1) != arr[i]\\n```\\n\\n\\n```\\nclass Solution {\\n    public String getHappyString(int n, int k) {\\n        char[] arr = {\\'a\\', \\'b\\', \\'c\\'};\\n        String res=\"\";\\n        List<String> l=new ArrayList<>();\\n        generatePerm(arr, n, res, l);\\n        if(l.size() >= k)\\n            res=l.get(k-1);\\n        return res;\\n    }\\n    \\n    private void generatePerm(char[] arr, int n, String res, List<String> l){\\n        if(n == 0){\\n            l.add(res);\\n            return;\\n        }\\n        \\n        for(int i=0; i<arr.length; i++){\\n           if(res == \"\" || res.charAt(res.length()-1) != arr[i]){\\n                String pre=res+arr[i];\\n                generatePerm(arr, n-1, pre, l);\\n            }\\n        }\\n        \\n    }\\n}\\n```\\n\\nIf you have any enhancements or comments please let me know. Still learning :)!",
                "solutionTags": [],
                "code": "```\\nres.charAt(res.length()-1) != arr[i]\\n```\n```\\nclass Solution {\\n    public String getHappyString(int n, int k) {\\n        char[] arr = {\\'a\\', \\'b\\', \\'c\\'};\\n        String res=\"\";\\n        List<String> l=new ArrayList<>();\\n        generatePerm(arr, n, res, l);\\n        if(l.size() >= k)\\n            res=l.get(k-1);\\n        return res;\\n    }\\n    \\n    private void generatePerm(char[] arr, int n, String res, List<String> l){\\n        if(n == 0){\\n            l.add(res);\\n            return;\\n        }\\n        \\n        for(int i=0; i<arr.length; i++){\\n           if(res == \"\" || res.charAt(res.length()-1) != arr[i]){\\n                String pre=res+arr[i];\\n                generatePerm(arr, n-1, pre, l);\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 585561,
                "title": "python-7-line-dfs-with-yield",
                "content": "**Idea**\\nThe property of DFS helps us iterate through all the possibilities in ascending order automatically. All we need to do is to output the kth result.\\n\\n**Python**\\n```\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n        def generate(prev):\\n            if len(prev) == n:\\n                yield prev; return\\n            yield from (res for c in \\'abc\\' if not prev or c != prev[-1] for res in generate(prev + c))\\n            \\n        for i, res in enumerate(generate(\\'\\'), 1):            \\n            if i == k: return res\\n        return \\'\\'     \\n```\\n\\n**Python, more readable**\\n```\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n        def generate(prev):\\n            if len(prev) == n:\\n                yield prev\\n                return\\n            for c in \\'abc\\':\\n                if not prev or c != prev[-1]:\\n                    yield from generate(prev + c)\\n            \\n        for i, res in enumerate(generate(\\'\\'), 1):            \\n            if i == k:\\n                return res\\n        return \\'\\'  \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n        def generate(prev):\\n            if len(prev) == n:\\n                yield prev; return\\n            yield from (res for c in \\'abc\\' if not prev or c != prev[-1] for res in generate(prev + c))\\n            \\n        for i, res in enumerate(generate(\\'\\'), 1):            \\n            if i == k: return res\\n        return \\'\\'     \\n```\n```\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n        def generate(prev):\\n            if len(prev) == n:\\n                yield prev\\n                return\\n            for c in \\'abc\\':\\n                if not prev or c != prev[-1]:\\n                    yield from generate(prev + c)\\n            \\n        for i, res in enumerate(generate(\\'\\'), 1):            \\n            if i == k:\\n                return res\\n        return \\'\\'  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 676440,
                "title": "python3-o-n-solution-using-math-with-clear-explanation",
                "content": "let\\'s consider n=3 and k=9\\nThe lexicographical order of the strings are [\"aba\", \"abc\", \"aca\", \"acb\", \"bab\", \"bac\", \"bca\", \"bcb\", \"cab\", \"cac\", \"cba\", \"cbc\"]\\n\\nWe can observe that each element a,b,c has repeated 2**(n-1)  times as the first character which is 4 in our case they are [\"aba\", \"abc\", \"aca\", \"acb\"], [\"bab\", \"bac\", \"bca\", \"bcb\"], [\"cab\", \"cac\", \"cba\", \"cbc\"]\\n\\nWe can also observe that total number of permutations are 3*(2**(n-1)) which 12 in our case.\\n\\n\\n```\\nfrom math import ceil\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n        single_ele = 2**(n-1)\\n        if k>3*single_ele:\\n            return \"\"\\n        result = [\\'a\\',\\'b\\',\\'c\\'][ceil(k/single_ele)-1]\\n        while single_ele>1:\\n            k = (k-1)%single_ele +1\\n            single_ele = single_ele//2\\n            if result[-1]==\\'a\\':\\n                result+=[\\'b\\',\\'c\\'][ceil(k/single_ele)-1]\\n            elif result[-1]==\\'b\\':\\n                result+=[\\'a\\',\\'c\\'][ceil(k/single_ele)-1]\\n            else:\\n                result+=[\\'a\\',\\'b\\'][ceil(k/single_ele)-1]\\n        return result\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nfrom math import ceil\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n        single_ele = 2**(n-1)\\n        if k>3*single_ele:\\n            return \"\"\\n        result = [\\'a\\',\\'b\\',\\'c\\'][ceil(k/single_ele)-1]\\n        while single_ele>1:\\n            k = (k-1)%single_ele +1\\n            single_ele = single_ele//2\\n            if result[-1]==\\'a\\':\\n                result+=[\\'b\\',\\'c\\'][ceil(k/single_ele)-1]\\n            elif result[-1]==\\'b\\':\\n                result+=[\\'a\\',\\'c\\'][ceil(k/single_ele)-1]\\n            else:\\n                result+=[\\'a\\',\\'b\\'][ceil(k/single_ele)-1]\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 585725,
                "title": "java-o-n-solution",
                "content": "```\\nclass Solution {\\n    public String getHappyString(int n, int k) {\\n        if(n == 0) {\\n            return \"\";\\n        }\\n        \\n        // K is too large\\n        if(k > (int)3 * Math.pow(2, n - 1)) {\\n            return \"\";\\n        }\\n        \\n        // Make K start from 0\\n        k--;\\n        \\n        StringBuilder sb = new StringBuilder();\\n        Map<Character, char[]> map = new HashMap<>();\\n        map.put(\\' \\', new char[]{\\'a\\', \\'b\\', \\'c\\'});\\n        map.put(\\'a\\', new char[]{\\'b\\', \\'c\\'});\\n        map.put(\\'b\\', new char[]{\\'a\\', \\'c\\'});\\n        map.put(\\'c\\', new char[]{\\'a\\', \\'b\\'});\\n        \\n        char prev = \\' \\';\\n        while(n > 1) {\\n            int nextAmount = (int)Math.pow(2, n - 1);\\n            int rank = k / nextAmount;\\n            \\n            sb.append(map.get(prev)[rank]);\\n            prev = map.get(prev)[rank];\\n            k = k % nextAmount;\\n            \\n            n--;\\n        }\\n        \\n        // n == 1\\n        sb.append(map.get(prev)[k]);\\n        return sb.toString();  \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String getHappyString(int n, int k) {\\n        if(n == 0) {\\n            return \"\";\\n        }\\n        \\n        // K is too large\\n        if(k > (int)3 * Math.pow(2, n - 1)) {\\n            return \"\";\\n        }\\n        \\n        // Make K start from 0\\n        k--;\\n        \\n        StringBuilder sb = new StringBuilder();\\n        Map<Character, char[]> map = new HashMap<>();\\n        map.put(\\' \\', new char[]{\\'a\\', \\'b\\', \\'c\\'});\\n        map.put(\\'a\\', new char[]{\\'b\\', \\'c\\'});\\n        map.put(\\'b\\', new char[]{\\'a\\', \\'c\\'});\\n        map.put(\\'c\\', new char[]{\\'a\\', \\'b\\'});\\n        \\n        char prev = \\' \\';\\n        while(n > 1) {\\n            int nextAmount = (int)Math.pow(2, n - 1);\\n            int rank = k / nextAmount;\\n            \\n            sb.append(map.get(prev)[rank]);\\n            prev = map.get(prev)[rank];\\n            k = k % nextAmount;\\n            \\n            n--;\\n        }\\n        \\n        // n == 1\\n        sb.append(map.get(prev)[k]);\\n        return sb.toString();  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 585557,
                "title": "c-straightforward-dfs-skip-appending-same-char",
                "content": "\\n***UPDATE:***\\n\\nAfter contest, I think we can avoid storing all the strings in the vector, but only keep the pontential result string(cur).\\nScroll down to check first solution.\\n```\\nclass Solution {\\npublic:\\n    string getHappyString(int n, int k) {\\n        string cur = \"\";\\n        left = k;\\n        dfs(cur, n);\\n        return res;\\n    }\\n    \\n    void dfs(string& cur, int n) {\\n       if(res.size() || cur.size() == n) {\\n            if(--left == 0)\\n                res = cur;\\n            return;\\n        }\\n        \\n        for(int i = 0; i < 3; ++i) {\\n            if(cur.empty() || cur.back() != abc[i]) {\\n                cur.push_back(abc[i]);\\n                dfs(cur, n);\\n                cur.pop_back();\\n            }\\n        }\\n    }\\nprivate:\\n    string res = \"\";\\n    int left;\\n    vector<char> abc{\\'a\\', \\'b\\', \\'c\\'};  \\n};\\n```\\n\\nSince k is not large, use DFS to generate all string.\\nIn this question , we need to avoid appending a same char as the last one in current string. And we can stop when we have k strings generated.\\n\\n```\\nclass Solution {\\npublic:\\n    string getHappyString(int n, int k) {\\n        string cur = \"\";\\n        vector<char> chars{\\'a\\', \\'b\\', \\'c\\'};\\n        dfs(cur, chars, n, k);\\n        \\n        return res.size() == k ? res.back() : \"\";\\n    }\\n\\n    void dfs(string& cur, vector<char>& chars, int n, int k) {\\n        if(res.size() == k)\\n            return;\\n        if(cur.size() == n) {\\n            res.push_back(cur);\\n            return;\\n        }\\n        \\n        for(int i = 0; i < 3; ++i) {\\n            //only append different char\\n            if(cur.empty() || (cur.back() != chars[i])) {\\n                cur.push_back(chars[i]);\\n                dfs(cur, chars, n, k);\\n                cur.pop_back();\\n            }\\n        }\\n    }\\n    \\nprivate:\\n    vector<string> res;\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string getHappyString(int n, int k) {\\n        string cur = \"\";\\n        left = k;\\n        dfs(cur, n);\\n        return res;\\n    }\\n    \\n    void dfs(string& cur, int n) {\\n       if(res.size() || cur.size() == n) {\\n            if(--left == 0)\\n                res = cur;\\n            return;\\n        }\\n        \\n        for(int i = 0; i < 3; ++i) {\\n            if(cur.empty() || cur.back() != abc[i]) {\\n                cur.push_back(abc[i]);\\n                dfs(cur, n);\\n                cur.pop_back();\\n            }\\n        }\\n    }\\nprivate:\\n    string res = \"\";\\n    int left;\\n    vector<char> abc{\\'a\\', \\'b\\', \\'c\\'};  \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string getHappyString(int n, int k) {\\n        string cur = \"\";\\n        vector<char> chars{\\'a\\', \\'b\\', \\'c\\'};\\n        dfs(cur, chars, n, k);\\n        \\n        return res.size() == k ? res.back() : \"\";\\n    }\\n\\n    void dfs(string& cur, vector<char>& chars, int n, int k) {\\n        if(res.size() == k)\\n            return;\\n        if(cur.size() == n) {\\n            res.push_back(cur);\\n            return;\\n        }\\n        \\n        for(int i = 0; i < 3; ++i) {\\n            //only append different char\\n            if(cur.empty() || (cur.back() != chars[i])) {\\n                cur.push_back(chars[i]);\\n                dfs(cur, chars, n, k);\\n                cur.pop_back();\\n            }\\n        }\\n    }\\n    \\nprivate:\\n    vector<string> res;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1251853,
                "title": "simple-java-solution-backtracking",
                "content": "DO UPVOTE INCASE YOU FIND IT HELPFUL!\\n```\\nclass Solution {\\n    List<String> list=new ArrayList<>();\\n    StringBuilder sb = new StringBuilder();\\n    public String getHappyString(int n, int k) {\\n        backtrack(n,\\' \\');\\n        Collections.sort(list);\\n        if(list.size()<k) return \"\";\\n        else return list.get(k-1);\\n    }\\n    void backtrack(int n, char prev){\\n        if(sb.length()==n){\\n            list.add(sb.toString());\\n            return;\\n        }\\n        else{\\n            for(char  ch=\\'a\\';ch<=\\'c\\';ch++){\\n              if(ch!=prev){\\n                sb.append(ch);\\n                backtrack(n,ch);\\n                sb.delete(sb.length()-1,sb.length());\\n              }\\n                \\n            }\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "class Solution {\\n    List<String> list=new ArrayList<>();\\n    StringBuilder sb = new StringBuilder();\\n    public String getHappyString(int n, int k) {\\n        backtrack(n,\\' \\');\\n        Collections.sort(list);\\n        if(list.size()<k) return \"\";\\n        else return list.get(k-1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 587093,
                "title": "java-concise-and-clean-solution-imagine-problem-as-a-tree-0ms",
                "content": "### Update\\nChanged string concatenation to `StringBuilder`. Performance gain from `11ms` to `0ms`.\\n\\n### Solution\\n\\nMy idea was to imagine the problem as a tree:\\n1. On the first step we have three branches: `a`, `b` and `c`.\\n2. On each next step we have two branches: if node is `a`: `b` and `c`, for `b`: `a` and `c` and for `c`: `a` and `b`.\\n\\nWe can see that number of solutions is evenly distributed among all branches on each step. What we can also say is that each branch has `2^(n-1)` elements in total, as each branch is perfect binary tree, you can easily see it when you will draw the problem on the paper.\\n\\nGIven this, our problem is converted to the more understandable one: find the number in perfect binary tree with one small difference that the very first node has three branches.\\n\\n```java\\nclass Solution {\\n    private static final char[] CHARS = new char[] { \\'a\\', \\'b\\', \\'c\\' };\\n    public String getHappyString(int n, int k) {\\n\\t    StringBuilder sb = new StringBuilder();\\n\\t    build(n, \\'-\\', k, sb); // first we have fake `-` as parameter, so all `a`, `b` and `c` are valid as a first letter\\n\\t    return sb.toString();\\n    }\\n    \\n    private static void build(int n, char last, int k, StringBuilder sb) {\\n        if (n == 0) {\\n            return; // we have reached the leaf\\n        }\\n        int step = 1 << (n - 1); // number of elements in each branch, which is perfect binary tree\\n        int to = step;\\n        for (char c : CHARS) {\\n            if (c == last) continue; // we can\\'t have two same letters in row\\n            if (k <= to) {\\n                build(n - 1, c, k - (to - step), sb.append(c)); // get the child tree and deduct the number of elements in left branch from k, if `to` is the right boundary of current branch, then (to-step) is the right boundary of the left branch, which is the number of all elements in it\\n\\t\\t\\t\\treturn;\\n            }\\n            to += step;\\n        }\\n    }\\n}\\n```\\n\\nWith this approach the problem could easily be extended to larger number of characters. Then you will have to change the `CHARS` array and line `int step = 1 << (n - 1);` to calculate the number of elements in perfect tree with more branches, which is basically `(CHARS.length-1)^(n-1)`, cause each node can have all other characters except the current one.",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```java\\nclass Solution {\\n    private static final char[] CHARS = new char[] { \\'a\\', \\'b\\', \\'c\\' };\\n    public String getHappyString(int n, int k) {\\n\\t    StringBuilder sb = new StringBuilder();\\n\\t    build(n, \\'-\\', k, sb); // first we have fake `-` as parameter, so all `a`, `b` and `c` are valid as a first letter\\n\\t    return sb.toString();\\n    }\\n    \\n    private static void build(int n, char last, int k, StringBuilder sb) {\\n        if (n == 0) {\\n            return; // we have reached the leaf\\n        }\\n        int step = 1 << (n - 1); // number of elements in each branch, which is perfect binary tree\\n        int to = step;\\n        for (char c : CHARS) {\\n            if (c == last) continue; // we can\\'t have two same letters in row\\n            if (k <= to) {\\n                build(n - 1, c, k - (to - step), sb.append(c)); // get the child tree and deduct the number of elements in left branch from k, if `to` is the right boundary of current branch, then (to-step) is the right boundary of the left branch, which is the number of all elements in it\\n\\t\\t\\t\\treturn;\\n            }\\n            to += step;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 586060,
                "title": "c-bfs-without-using-sort",
                "content": "```\\n    string getHappyString(int n, int k) {\\n        vector<string> all;\\n        queue<string> q;\\n        q.push(\"a\");\\n        q.push(\"b\");\\n        q.push(\"c\");\\n        int t = n;\\n        while(t--){\\n            int sz = q.size();\\n            while(sz--){\\n                string s = q.front();\\n                q.pop();\\n                if(s.size()==n)\\n                    all.push_back(s);\\n                for(auto i = \\'a\\';i<=\\'c\\';i++){\\n                    if(s.back()!=i){\\n                        s += i;\\n                        q.push(s);\\n                        s.pop_back();\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        if(k>all.size())\\n            return {};\\n        return all[k-1];\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    string getHappyString(int n, int k) {\\n        vector<string> all;\\n        queue<string> q;\\n        q.push(\"a\");\\n        q.push(\"b\");\\n        q.push(\"c\");\\n        int t = n;\\n        while(t--){\\n            int sz = q.size();\\n            while(sz--){\\n                string s = q.front();\\n                q.pop();\\n                if(s.size()==n)\\n                    all.push_back(s);\\n                for(auto i = \\'a\\';i<=\\'c\\';i++){\\n                    if(s.back()!=i){\\n                        s += i;\\n                        q.push(s);\\n                        s.pop_back();\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        if(k>all.size())\\n            return {};\\n        return all[k-1];\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1354945,
                "title": "easy-to-understand-cpp-solution",
                "content": "we will check if our previous character is not the same as the current one. If not, we will push the current character. This is the same condition as the happy string.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    void helper(int n,string check,vector<string>& ans)\\n    {\\n        if(n == 0){\\n            ans.push_back(check);\\n            return;\\n        }\\n        \\n        if(check.back() != \\'a\\')  helper(n - 1, check + \\'a\\', ans);\\n        if(check.back() != \\'b\\')  helper(n - 1, check + \\'b\\', ans);\\n        if(check.back() != \\'c\\')  helper(n - 1, check + \\'c\\', ans);\\n    }\\n    \\n    string getHappyString(int n, int k)\\n    {\\n        vector<string> ans;\\n        \\n        helper(n, \"\", ans);\\n        \\n        if(k > ans.size())  return \"\";\\n        \\n        return ans[--k];\\n    }\\n};\\n```\\n\\nFeel free to give your suggestions or correct me in the comments. Thanks for reading.\\uD83D\\uDE43",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    void helper(int n,string check,vector<string>& ans)\\n    {\\n        if(n == 0){\\n            ans.push_back(check);\\n            return;\\n        }\\n        \\n        if(check.back() != \\'a\\')  helper(n - 1, check + \\'a\\', ans);\\n        if(check.back() != \\'b\\')  helper(n - 1, check + \\'b\\', ans);\\n        if(check.back() != \\'c\\')  helper(n - 1, check + \\'c\\', ans);\\n    }\\n    \\n    string getHappyString(int n, int k)\\n    {\\n        vector<string> ans;\\n        \\n        helper(n, \"\", ans);\\n        \\n        if(k > ans.size())  return \"\";\\n        \\n        return ans[--k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211998,
                "title": "backtracking-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<char> v={\\'a\\',\\'b\\',\\'c\\'};\\n    \\n    void helper(vector<string> &ans,string t,int n,char prev)\\n    {\\n        if(n==0)\\n        {\\n            ans.push_back(t);\\n            return ;\\n        }\\n        \\n        for(int i=0;i<v.size();i++)\\n        {\\n            if(prev!=v[i])\\n            {\\n                t.push_back(v[i]);\\n                helper(ans,t,n-1,v[i]);\\n                t.pop_back();\\n            }\\n        }\\n    }\\n    \\n    string getHappyString(int n, int k) {\\n        \\n        vector<string> ans;\\n        string t=\"\";\\n        helper(ans,t,n,\\'#\\');\\n        \\n        //sort(ans.begin(),ans.end());\\n        \\n        if(ans.size()<k)\\n        {\\n            return \"\";\\n        }\\n        return ans[k-1];\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    vector<char> v={\\'a\\',\\'b\\',\\'c\\'}",
                "codeTag": "Java"
            },
            {
                "id": 1127062,
                "title": "fast-and-simple-c",
                "content": "```\\nvoid find_all(int n,string &curr,vector<string> &v)\\n{\\n\\tif(curr.size()==n)\\n\\t{\\n\\t\\tv.push_back(curr);\\n\\t\\treturn ;\\n\\t}\\n\\tfor(char i=\\'a\\';i<=\\'c\\';i++)\\n\\t{\\n\\t\\tif(curr.size()==0||i!=curr.back())\\n\\t\\t{\\n\\t\\t\\tcurr.push_back(i);\\n\\t\\t\\tfind_all(n,curr,v);\\n\\t\\t\\tcurr.pop_back();\\n\\t\\t}\\n\\t}\\n}\\nstring getHappyString(int n, int k) {\\n\\tvector<string> v;\\n\\tstring curr;\\n\\tfind_all(n,curr,v);\\n\\tsort(v.begin(),v.end());\\n\\tif(k>v.size())\\n\\t\\treturn \"\";\\n\\treturn v[k-1];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvoid find_all(int n,string &curr,vector<string> &v)\\n{\\n\\tif(curr.size()==n)\\n\\t{\\n\\t\\tv.push_back(curr);\\n\\t\\treturn ;\\n\\t}\\n\\tfor(char i=\\'a\\';i<=\\'c\\';i++)\\n\\t{\\n\\t\\tif(curr.size()==0||i!=curr.back())\\n\\t\\t{\\n\\t\\t\\tcurr.push_back(i);\\n\\t\\t\\tfind_all(n,curr,v);\\n\\t\\t\\tcurr.pop_back();\\n\\t\\t}\\n\\t}\\n}\\nstring getHappyString(int n, int k) {\\n\\tvector<string> v;\\n\\tstring curr;\\n\\tfind_all(n,curr,v);\\n\\tsort(v.begin(),v.end());\\n\\tif(k>v.size())\\n\\t\\treturn \"\";\\n\\treturn v[k-1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 589572,
                "title": "python-o-n-faster-than-99-memory-usage-less-than-100",
                "content": "We calculate how many possible happy substrings of given length minus one exist \\u2013 using this number, `k`, a list of possible letters and the last used letter we easily calculate what would be the letter at the current index.\\n\\nThis solution has O(n) runtime complexity and O(1) space complexity (result not counted).\\nEven though we\\'re using `sorted(chars - set(last))` in the loop, it\\'s safe to estimate the runtime complexity as linear, since the sorted list consist only of 3 elements for the first iteration and afterward always 2 elements. Could have replaced it with manual rearrangement, but `sorted` is much more concise.\\n\\n```python\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n        # calculate total number of happy strings of length n\\n        total = 3 * 2**(n-1)\\n        if k > total:\\n            return \"\"\\n\\n        # alphabet:\\n        chars = set(\\'abc\\')\\n        # last used letter (begin with empty):\\n        last = \\'\\'\\n\\n        result = [\\'\\']*n\\n        for i in range(n):\\n            # list of possible letters after the last used one:\\n            choice = sorted(chars - set(last))\\n            # how many substrings of length (n-i-1) are possible:\\n            total //= len(choice)\\n            # pick the letter at index i:\\n            last = choice[(k-1)//total]\\n            result[i] = last\\n            # reduce k to pick from substrings:\\n            k %= total\\n\\n        return \\'\\'.join(result)\\n```\\n\\nExample: we\\'re given n = 3, k = 9.\\nThe total number of happy strings of length 3 is 12 (3\\\\*2^(n-1)).\\nLet\\'s find first letter: we can choose from a list of letters `[a, b, c]`, and after we pick one of them, there will be 4 possible happy substrings of length 2 (since we\\'re reducing the number of possibilities by 3 by picking one of three letters). `(k-1) // total substrings = (9-1) // 4 = 2` is the index in our list of possible letters, so the first letter is `c`. We also need to set `k = 9 % 4 = 1` (as `k` needs to be smaller than the number of possible substrings).\\nSecond letter: now we choose only from `[a, b]` and after we pick one of them, we\\'ll have only 2 possible happy substrings of length 1 left. `(k-1) // total substrings = (1-1) // 2 = 0` is the index in our list of possible letters, so our second letter is `a`. Now `k = 2 % 1 = 1`.\\nThird letter: a list of possible letters now is `[b,c]`, and there\\'s only one possible happy substring of length 1 - an empty string. After repeating our calculations, we get the index of the third letter equal to 0 - which correspons to letter `b`.\\nSo, the resulting string would be `cab`.\\n\\nThe same code without comments:\\n```python\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n        total = 3 * 2**(n-1)\\n        if k > total:\\n            return \\'\\'\\n        chars, last, result = set(\\'abc\\'), \\'\\', [\\'\\']*n\\n        for i in range(n):\\n            choice = sorted(chars - set(last))\\n            total //= len(choice)\\n            last = choice[(k-1)//total]\\n            result[i], k = last, k % total\\n        return \\'\\'.join(result)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Combinatorics"
                ],
                "code": "```python\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n        # calculate total number of happy strings of length n\\n        total = 3 * 2**(n-1)\\n        if k > total:\\n            return \"\"\\n\\n        # alphabet:\\n        chars = set(\\'abc\\')\\n        # last used letter (begin with empty):\\n        last = \\'\\'\\n\\n        result = [\\'\\']*n\\n        for i in range(n):\\n            # list of possible letters after the last used one:\\n            choice = sorted(chars - set(last))\\n            # how many substrings of length (n-i-1) are possible:\\n            total //= len(choice)\\n            # pick the letter at index i:\\n            last = choice[(k-1)//total]\\n            result[i] = last\\n            # reduce k to pick from substrings:\\n            k %= total\\n\\n        return \\'\\'.join(result)\\n```\n```python\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n        total = 3 * 2**(n-1)\\n        if k > total:\\n            return \\'\\'\\n        chars, last, result = set(\\'abc\\'), \\'\\', [\\'\\']*n\\n        for i in range(n):\\n            choice = sorted(chars - set(last))\\n            total //= len(choice)\\n            last = choice[(k-1)//total]\\n            result[i], k = last, k % total\\n        return \\'\\'.join(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 585645,
                "title": "easy-python-recursive-sorting-lexicographically-heap",
                "content": "Approach 1 . Generating all the strings of length n (252 ms).\\n```\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n        res=[]     # list storing all the strings of size n  \\n        def fun(s, curr, n):  # recurisve function for finding all strings\\n            if n==0 :                  \\n                res.append(curr)\\n                return\\n            for i in range(3):  #checking whether the currently buildup string\\'s last charachter matches to the new charachter we are appending\\n                if curr and curr[-1]==s[i]:   \\n                    continue\\n                modify_curr=curr+s[i]       # modify current string       \\n                fun(s, modify_curr, n-1)  \\n        fun([\\'a\\',\\'b\\',\\'c\\'],\"\",n)\\n        res=sorted(res)      #lexicographically sorted\\n        return res[k-1] if k <= len(res) else \"\"         \\n```\\n\\nApproach 2 : Another approcah using heap (Much faster , 180ms)\\n                     Need only to use heapify once . (min_heap)\\n```\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n        heap=[]\\n        def fun(s, curr, n): \\n            if n==0 : \\n                heapq.heappush(heap, curr)\\n                return\\n            for i in range(3): \\n                if curr and curr[-1]==s[i]:\\n                    continue\\n                new_curr = curr + s[i] \\n                fun(s, new_curr, n-1) \\n        fun([\\'a\\',\\'b\\',\\'c\\'],\"\",n)\\n        # res=sorted(res)\\n        result=\"\"\\n        heapq.heapify(heap)\\n        for i in range(k-1):                        #pop till k-2 th element\\n            heapq.heappop(heap)\\n            if not heap:\\n                break\\n        return heapq.heappop(heap) if heap else \"\"  # pop k-1 the element if exits\\n        \\n        \\n```\\n\\n        \\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n        res=[]     # list storing all the strings of size n  \\n        def fun(s, curr, n):  # recurisve function for finding all strings\\n            if n==0 :                  \\n                res.append(curr)\\n                return\\n            for i in range(3):  #checking whether the currently buildup string\\'s last charachter matches to the new charachter we are appending\\n                if curr and curr[-1]==s[i]:   \\n                    continue\\n                modify_curr=curr+s[i]       # modify current string       \\n                fun(s, modify_curr, n-1)  \\n        fun([\\'a\\',\\'b\\',\\'c\\'],\"\",n)\\n        res=sorted(res)      #lexicographically sorted\\n        return res[k-1] if k <= len(res) else \"\"         \\n```\n```\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n        heap=[]\\n        def fun(s, curr, n): \\n            if n==0 : \\n                heapq.heappush(heap, curr)\\n                return\\n            for i in range(3): \\n                if curr and curr[-1]==s[i]:\\n                    continue\\n                new_curr = curr + s[i] \\n                fun(s, new_curr, n-1) \\n        fun([\\'a\\',\\'b\\',\\'c\\'],\"\",n)\\n        # res=sorted(res)\\n        result=\"\"\\n        heapq.heapify(heap)\\n        for i in range(k-1):                        #pop till k-2 th element\\n            heapq.heappop(heap)\\n            if not heap:\\n                break\\n        return heapq.heappop(heap) if heap else \"\"  # pop k-1 the element if exits\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3438901,
                "title": "python-3-9-lines-binary-map-w-example-t-m-99-87",
                "content": "```\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n\\n        d = {\\'a\\':\\'bc\\',\\'b\\':\\'ac\\',\\'c\\':\\'ab\\'}                #  Example: n = 5, k = 20\\n\\n        div,r = divmod(k-1,2**(n-1))                    # div,r = divmod(19,16) = 1,3\\n\\n        if div > 2: return \\'\\'\\n        prev = ans = \\'abc\\'[div]                         # prev = ans = \\'b\\'\\n   \\n        r = list(map(int,bin(r)[2:].rjust(n-1,\\'0\\')))    # r = map(int, \\'0011\\') = [0,0,1,1]\\n  \\n        for i in range(n-1):                           #  i   r[i]  d[prev][r[i]]   ans\\n            prev = d[prev][r[i]]                         ---   ---  ---------       ------\\n            ans+= prev                                 #                             \\'b\\'\\n                                                       #  0     0   d[\\'b\\'][0] = \\'a\\'  \\'ba\\'       \\n        return ans                                     #  1     0   d[\\'a\\'][0] = \\'b\\'  \\'bab\\'\\n                                                       #  2     1   d[\\'b\\'][1] = \\'c\\'  \\'babc\\'\\n                                                       #  3     1   d[\\'c\\'][1] = \\'b\\'  \\'babcb\\'\\n```\\n[https://leetcode.com/problems/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n/submissions/937031498/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n\\n        d = {\\'a\\':\\'bc\\',\\'b\\':\\'ac\\',\\'c\\':\\'ab\\'}                #  Example: n = 5, k = 20\\n\\n        div,r = divmod(k-1,2**(n-1))                    # div,r = divmod(19,16) = 1,3\\n\\n        if div > 2: return \\'\\'\\n        prev = ans = \\'abc\\'[div]                         # prev = ans = \\'b\\'\\n   \\n        r = list(map(int,bin(r)[2:].rjust(n-1,\\'0\\')))    # r = map(int, \\'0011\\') = [0,0,1,1]\\n  \\n        for i in range(n-1):                           #  i   r[i]  d[prev][r[i]]   ans\\n            prev = d[prev][r[i]]                         ---   ---  ---------       ------\\n            ans+= prev                                 #                             \\'b\\'\\n                                                       #  0     0   d[\\'b\\'][0] = \\'a\\'  \\'ba\\'       \\n        return ans                                     #  1     0   d[\\'a\\'][0] = \\'b\\'  \\'bab\\'\\n                                                       #  2     1   d[\\'b\\'][1] = \\'c\\'  \\'babc\\'\\n                                                       #  3     1   d[\\'c\\'][1] = \\'b\\'  \\'babcb\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 585907,
                "title": "javascript-solution-construct-possible-strings-sort-and-return-kth-string",
                "content": "```\\n//contructs an array of all possible unique strings possible with \\'a\\', \\'b\\', \\'c\\' of length n\\nvar formArray = function(res, s, pre, l, n){\\n    if (n == 0) \\n    { \\n        res.push(pre);\\n        return; \\n    } \\n    for (var i = 0; i < l; i++) \\n    { \\n        var newPre; \\n          \\n        // Next character of input added. check for last character of prefix \\n        if(pre[pre.length-1] !== s[i])\\n        { \\n            newPre = pre + s[i];\\n            formSet(res, s, newPre, l, n - 1); \\n        }\\n        \\n    } \\n}\\nvar getHappyString = function(n, k) {\\n    var res = []\\n    formArray(res, [\\'a\\',\\'b\\',\\'c\\'], \"\", 3,  n);\\n    res.sort();\\n    if(res.length<k){\\n        return \"\";\\n    }\\n    return res[k-1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n//contructs an array of all possible unique strings possible with \\'a\\', \\'b\\', \\'c\\' of length n\\nvar formArray = function(res, s, pre, l, n){\\n    if (n == 0) \\n    { \\n        res.push(pre);\\n        return; \\n    } \\n    for (var i = 0; i < l; i++) \\n    { \\n        var newPre; \\n          \\n        // Next character of input added. check for last character of prefix \\n        if(pre[pre.length-1] !== s[i])\\n        { \\n            newPre = pre + s[i];\\n            formSet(res, s, newPre, l, n - 1); \\n        }\\n        \\n    } \\n}\\nvar getHappyString = function(n, k) {\\n    var res = []\\n    formArray(res, [\\'a\\',\\'b\\',\\'c\\'], \"\", 3,  n);\\n    res.sort();\\n    if(res.length<k){\\n        return \"\";\\n    }\\n    return res[k-1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2630491,
                "title": "working-explained-using-permutation-concept-complete-walkthrough",
                "content": "```\\n/*\\n    3 Key Important things to know to solve any Backtracking problem\\n    ----------------------------------------------------------------\\n\\n    1.) Choices [Search Space from which we\\'ve to choose items]\\n    ==========================================================\\n        search_space = {\\'a\\', \\'b\\', \\'c\\'} only 3 chars\\n    \\n    2.) Constraints [To apply on chosen items]\\n    ==========================================\\n       Two adjacent characters should NOT be equal. i.e. s[i] != s[i + 1]\\n       for all 0 <= i < len(s) (string \\'s\\' is 0-indexed).\\n       \\n    3.) Goal [What problem is demanding/asking for]\\n    ===============================================\\n        Return kth lexicographically sorted strings(having only a/b or c) of length n.\\n        \\n    ======================================================================================\\n    \\n    \\n    Let\\'s see how many strings are there for n = 3\\n      \\n    \\n    __a__, ____, ____\\n            ^      \\n            |       \\n         {b, c} ----> \\'a\\' can\\'t in our possible choices because previous character is also \\'a\\'\\n         two choices\\n         for this empty\\n         block to fill.\\n         \\n    __a__, __b__, ___\\n            ^      ^\\n            |      | \\n            |      +-----------------------------------after placing \\'b\\' at second position\\n        placing \\'b\\' first to make                       we\\'ve two possible choices for third empty block\\n        sure that the generated string(of length n)     {\\'a\\', \\'c\\'}\\n        is lexicographically sorted order.\\n        \\n        \\n    __a__, __b__, __a__     => first string of length 3, if we place \\'a\\' at third empty block\\n    \\n    \\n    __a__, __b__, __c__     => second generated string(remember lexicographically larger than previous)\\n                    ^\\n                    |\\n                    |\\n                   all choices for third position exhausted\\n                   try other left choices at second position.\\n                   \\n    \\n    __a__, __c__, ____\\n             ^      ^\\n             |      |________ two choices for third position {\\'a\\', \\'b\\'}    \\n        if we place \\'c\\'\\n        at second place\\n     \\n    \\n    __a__, __c__, __a___    => third generated string\\n    \\n    __a__, __c__, __b__     => fourth generated string\\n    \\n    \\n    Look the above, there are 4 different strings we got starting with letter\\n    \\'a\\' i.e. {\"aba\", \"abc\", \"aca\", \"acb\"}. All of them in lexicographically sorted order.\\n    \\n    NOTE: Since, we\\'re always placing the smallest possible character at first, hence it gives\\n            us guaranteed that geneated strings are in lexicographically sorted order.\\n    \\n    similarly, there are 4 different strings starting with letter \\'b\\' & \\'c\\'\\n    \\n    starting with letter \\'b\\' : {\"bab\", \"bac\", \"bca\", \"bcb\"}\\n    \\n    starting with letter \\'c\\' : {\"cab\", \"cac\", \"cba\", \"cbc\"}\\n    \\n    Total 12 strings are possible of length 3.\\n    \\n    _3__, __2__, __2__\\n     ^      ^      ^ \\n     |      |      +------ {for each previous two choices, we\\'ve two choices to fill it}  \\n     |      +--- {2 different choices to fill}\\n    {3 different choices to fill}\\n    \\n    Hence, total count of strings with length 3 can be given by : 3 * 2 * 2 = 12\\n    \\n    \\n    Similarly, If we\\'ve to generate all possible strings of length 4 then count\\n    of total such strings can be given by : 3 * 2 * 2 * 2 = 24\\n    \\n    Total count of n length strings is : 3 * (2^(n - 1))\\n    \\n    ===================================================================================================\\n    \\n    \\n    Approach:\\n    ========\\n        1. Generate all possible lexicographically sorted strings of length n.\\n        2. Return kth strings out of them. {if we enough at least k strings}.\\n        \\n    \\n    Learning Factor\\n    ==============\\n        Look at the solution, how we used \\'Permutation\\' type template to solve this question.\\n        and how we\\'re maintaing the lexicographically sorted strings just by picking\\n        the smallest character to fill any empty position.\\n            + No sorting is required at all.\\n    \\n*/\\nclass Solution {\\n    public String getHappyString(int n, int k) {\\n        int totalStringCount = 3 * (1 << (n - 1)); //1 << (n - 1) : 2^(n - 1)\\n        if(k > totalStringCount) return \"\";\\n        List<String> sortedStrings = new ArrayList<>();\\n        generateAllNLengthStrings(n, \\'\\\\0\\', sortedStrings, new StringBuilder());\\n        return sortedStrings.get(k - 1);\\n    }\\n    \\n    private void generateAllNLengthStrings(int n, char previousChar, List<String> sortedStrings,\\n                                          StringBuilder runningString) {\\n        if(runningString.length() == n) {\\n            sortedStrings.add(runningString.toString());\\n            return;\\n        }\\n        \\n        for(char ch = \\'a\\'; ch <= \\'c\\'; ch += 1) {\\n            if(ch != previousChar) {\\n                runningString.append(ch);\\n                generateAllNLengthStrings(n, ch, sortedStrings, runningString);\\n                runningString.deleteCharAt(runningString.length() - 1);\\n            }\\n        }\\n    }\\n}\\n```\\n\\n```\\nGenerating Exactly k strings [No need to store all strings at all]\\n```\\n\\n```\\nclass Solution {\\n    public String getHappyString(int n, int k) {\\n        int totalStringCount = 3 * (1 << (n - 1)); \\n        if(k > totalStringCount) return \"\";\\n        return generateAllNLengthStrings(n, new int[]{k}, \\'\\\\0\\', new StringBuilder());\\n    }\\n    \\n    private String generateAllNLengthStrings(int n, int[] cnt, char previousChar, StringBuilder runningString) {\\n        if(runningString.length() == n) {\\n            return --cnt[0] == 0 ? runningString.toString() : \"\";\\n        }\\n        \\n        for(char ch = \\'a\\'; ch <= \\'c\\'; ch += 1) {\\n            if(ch != previousChar) {\\n                runningString.append(ch);\\n                String kthString = generateAllNLengthStrings(n, cnt, ch, runningString);\\n                //found our required kth lexicographically sorted string.\\n                if(kthString.length() != 0) return kthString;\\n                runningString.deleteCharAt(runningString.length() - 1);\\n            }\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n    3 Key Important things to know to solve any Backtracking problem\\n    ----------------------------------------------------------------\\n\\n    1.) Choices [Search Space from which we\\'ve to choose items]\\n    ==========================================================\\n        search_space = {\\'a\\', \\'b\\', \\'c\\'} only 3 chars\\n    \\n    2.) Constraints [To apply on chosen items]\\n    ==========================================\\n       Two adjacent characters should NOT be equal. i.e. s[i] != s[i + 1]\\n       for all 0 <= i < len(s) (string \\'s\\' is 0-indexed).\\n       \\n    3.) Goal [What problem is demanding/asking for]\\n    ===============================================\\n        Return kth lexicographically sorted strings(having only a/b or c) of length n.\\n        \\n    ======================================================================================\\n    \\n    \\n    Let\\'s see how many strings are there for n = 3\\n      \\n    \\n    __a__, ____, ____\\n            ^      \\n            |       \\n         {b, c} ----> \\'a\\' can\\'t in our possible choices because previous character is also \\'a\\'\\n         two choices\\n         for this empty\\n         block to fill.\\n         \\n    __a__, __b__, ___\\n            ^      ^\\n            |      | \\n            |      +-----------------------------------after placing \\'b\\' at second position\\n        placing \\'b\\' first to make                       we\\'ve two possible choices for third empty block\\n        sure that the generated string(of length n)     {\\'a\\', \\'c\\'}\\n        is lexicographically sorted order.\\n        \\n        \\n    __a__, __b__, __a__     => first string of length 3, if we place \\'a\\' at third empty block\\n    \\n    \\n    __a__, __b__, __c__     => second generated string(remember lexicographically larger than previous)\\n                    ^\\n                    |\\n                    |\\n                   all choices for third position exhausted\\n                   try other left choices at second position.\\n                   \\n    \\n    __a__, __c__, ____\\n             ^      ^\\n             |      |________ two choices for third position {\\'a\\', \\'b\\'}    \\n        if we place \\'c\\'\\n        at second place\\n     \\n    \\n    __a__, __c__, __a___    => third generated string\\n    \\n    __a__, __c__, __b__     => fourth generated string\\n    \\n    \\n    Look the above, there are 4 different strings we got starting with letter\\n    \\'a\\' i.e. {\"aba\", \"abc\", \"aca\", \"acb\"}. All of them in lexicographically sorted order.\\n    \\n    NOTE: Since, we\\'re always placing the smallest possible character at first, hence it gives\\n            us guaranteed that geneated strings are in lexicographically sorted order.\\n    \\n    similarly, there are 4 different strings starting with letter \\'b\\' & \\'c\\'\\n    \\n    starting with letter \\'b\\' : {\"bab\", \"bac\", \"bca\", \"bcb\"}\\n    \\n    starting with letter \\'c\\' : {\"cab\", \"cac\", \"cba\", \"cbc\"}\\n    \\n    Total 12 strings are possible of length 3.\\n    \\n    _3__, __2__, __2__\\n     ^      ^      ^ \\n     |      |      +------ {for each previous two choices, we\\'ve two choices to fill it}  \\n     |      +--- {2 different choices to fill}\\n    {3 different choices to fill}\\n    \\n    Hence, total count of strings with length 3 can be given by : 3 * 2 * 2 = 12\\n    \\n    \\n    Similarly, If we\\'ve to generate all possible strings of length 4 then count\\n    of total such strings can be given by : 3 * 2 * 2 * 2 = 24\\n    \\n    Total count of n length strings is : 3 * (2^(n - 1))\\n    \\n    ===================================================================================================\\n    \\n    \\n    Approach:\\n    ========\\n        1. Generate all possible lexicographically sorted strings of length n.\\n        2. Return kth strings out of them. {if we enough at least k strings}.\\n        \\n    \\n    Learning Factor\\n    ==============\\n        Look at the solution, how we used \\'Permutation\\' type template to solve this question.\\n        and how we\\'re maintaing the lexicographically sorted strings just by picking\\n        the smallest character to fill any empty position.\\n            + No sorting is required at all.\\n    \\n*/\\nclass Solution {\\n    public String getHappyString(int n, int k) {\\n        int totalStringCount = 3 * (1 << (n - 1)); //1 << (n - 1) : 2^(n - 1)\\n        if(k > totalStringCount) return \"\";\\n        List<String> sortedStrings = new ArrayList<>();\\n        generateAllNLengthStrings(n, \\'\\\\0\\', sortedStrings, new StringBuilder());\\n        return sortedStrings.get(k - 1);\\n    }\\n    \\n    private void generateAllNLengthStrings(int n, char previousChar, List<String> sortedStrings,\\n                                          StringBuilder runningString) {\\n        if(runningString.length() == n) {\\n            sortedStrings.add(runningString.toString());\\n            return;\\n        }\\n        \\n        for(char ch = \\'a\\'; ch <= \\'c\\'; ch += 1) {\\n            if(ch != previousChar) {\\n                runningString.append(ch);\\n                generateAllNLengthStrings(n, ch, sortedStrings, runningString);\\n                runningString.deleteCharAt(runningString.length() - 1);\\n            }\\n        }\\n    }\\n}\\n```\n```\\nGenerating Exactly k strings [No need to store all strings at all]\\n```\n```\\nclass Solution {\\n    public String getHappyString(int n, int k) {\\n        int totalStringCount = 3 * (1 << (n - 1)); \\n        if(k > totalStringCount) return \"\";\\n        return generateAllNLengthStrings(n, new int[]{k}, \\'\\\\0\\', new StringBuilder());\\n    }\\n    \\n    private String generateAllNLengthStrings(int n, int[] cnt, char previousChar, StringBuilder runningString) {\\n        if(runningString.length() == n) {\\n            return --cnt[0] == 0 ? runningString.toString() : \"\";\\n        }\\n        \\n        for(char ch = \\'a\\'; ch <= \\'c\\'; ch += 1) {\\n            if(ch != previousChar) {\\n                runningString.append(ch);\\n                String kthString = generateAllNLengthStrings(n, cnt, ch, runningString);\\n                //found our required kth lexicographically sorted string.\\n                if(kthString.length() != 0) return kthString;\\n                runningString.deleteCharAt(runningString.length() - 1);\\n            }\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 588218,
                "title": "python-bruteforce-and-optimized-solution",
                "content": "**Brute force solution by generating all possible combinations and selecting the kth entry. O(2^n) [580ms]**\\n```\\nclass Solution(object):\\n    def getHappyString(self, n, k):\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        result = self.listCombinations(n, \\'\\')\\n        if k > len(result):\\n            return \\'\\'\\n        return \\'\\'.join(result[k-1])\\n        \\n    def listCombinations(self, n, ignoreLetter):\\n        if n == 0:\\n            return [[]]\\n        \\n        allLetters = \\'abc\\'\\n        result = []\\n        for letter in allLetters:\\n            if letter == ignoreLetter:\\n                continue\\n            result.extend(map(lambda x: [letter] + x, self.listCombinations(n-1, letter)))\\n        return result\\n```\\n\\n**Instead of generating all combinations we figure out the next letter one by one. O(n) [20ms]**\\n```\\nimport math\\n\\nclass Solution(object):\\n    def getHappyString(self, n, k):\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        letters = [\\'a\\', \\'b\\', \\'c\\']\\n        \\n        result = \\'\\'\\n        prevLetter = None\\n        while n > 0:\\n            nextLetters =  filter(lambda x: x != prevLetter, letters)\\n            selection = int(math.ceil((k-1) / (2**(n-1))))\\n            if selection >= len(nextLetters):\\n                return \\'\\'\\n            \\n            result += nextLetters[selection]\\n            prevLetter = nextLetters[selection]\\n            k = k - (selection * 2**(n-1))\\n            n -= 1\\n        return result",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def getHappyString(self, n, k):\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        result = self.listCombinations(n, \\'\\')\\n        if k > len(result):\\n            return \\'\\'\\n        return \\'\\'.join(result[k-1])\\n        \\n    def listCombinations(self, n, ignoreLetter):\\n        if n == 0:\\n            return [[]]\\n        \\n        allLetters = \\'abc\\'\\n        result = []\\n        for letter in allLetters:\\n            if letter == ignoreLetter:\\n                continue\\n            result.extend(map(lambda x: [letter] + x, self.listCombinations(n-1, letter)))\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 585773,
                "title": "java-simple-backtracking",
                "content": "Just backtrack to generate all the strings and store them in a list. Return the appropriate element from list.\\n```\\nclass Solution {\\n    \\n    List<String> list = new ArrayList<>();\\n    \\n    void rec(int n, StringBuilder sb) {\\n        if (n == 0) {\\n            list.add(sb.toString());\\n            return;\\n        }\\n        \\n        char c = sb.charAt(sb.length()-1);\\n        if (c == \\'a\\') {\\n            sb.append(\\'b\\');\\n            rec(n-1, sb);\\n            sb.setLength(sb.length() - 1);\\n            sb.append(\\'c\\');\\n            rec(n-1, sb);\\n            sb.setLength(sb.length() - 1);\\n        }\\n        \\n        if (c == \\'b\\') {\\n            sb.append(\\'a\\');\\n            rec(n-1, sb);\\n            sb.setLength(sb.length() - 1);\\n            sb.append(\\'c\\');\\n            rec(n-1, sb);\\n            sb.setLength(sb.length() - 1);\\n        }\\n        \\n        if (c == \\'c\\') {\\n            sb.append(\\'a\\');\\n            rec(n-1, sb);\\n            sb.setLength(sb.length() - 1);\\n            sb.append(\\'b\\');\\n            rec(n-1, sb);\\n            sb.setLength(sb.length() - 1);\\n        }\\n    }\\n    \\n    public String getHappyString(int n, int k) {\\n        \\n        StringBuilder sb = new StringBuilder();\\n        sb.append(\\'a\\');\\n        rec(n-1, sb);\\n        sb.setLength(sb.length() - 1);\\n        \\n        sb.append(\\'b\\');\\n        rec(n-1, sb);\\n        sb.setLength(sb.length() - 1);\\n        \\n        sb.append(\\'c\\');        \\n        rec(n-1, sb);\\n        sb.setLength(sb.length() - 1);\\n        return k > list.size() ? \"\" : list.get(k-1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    List<String> list = new ArrayList<>();\\n    \\n    void rec(int n, StringBuilder sb) {\\n        if (n == 0) {\\n            list.add(sb.toString());\\n            return;\\n        }\\n        \\n        char c = sb.charAt(sb.length()-1);\\n        if (c == \\'a\\') {\\n            sb.append(\\'b\\');\\n            rec(n-1, sb);\\n            sb.setLength(sb.length() - 1);\\n            sb.append(\\'c\\');\\n            rec(n-1, sb);\\n            sb.setLength(sb.length() - 1);\\n        }\\n        \\n        if (c == \\'b\\') {\\n            sb.append(\\'a\\');\\n            rec(n-1, sb);\\n            sb.setLength(sb.length() - 1);\\n            sb.append(\\'c\\');\\n            rec(n-1, sb);\\n            sb.setLength(sb.length() - 1);\\n        }\\n        \\n        if (c == \\'c\\') {\\n            sb.append(\\'a\\');\\n            rec(n-1, sb);\\n            sb.setLength(sb.length() - 1);\\n            sb.append(\\'b\\');\\n            rec(n-1, sb);\\n            sb.setLength(sb.length() - 1);\\n        }\\n    }\\n    \\n    public String getHappyString(int n, int k) {\\n        \\n        StringBuilder sb = new StringBuilder();\\n        sb.append(\\'a\\');\\n        rec(n-1, sb);\\n        sb.setLength(sb.length() - 1);\\n        \\n        sb.append(\\'b\\');\\n        rec(n-1, sb);\\n        sb.setLength(sb.length() - 1);\\n        \\n        sb.append(\\'c\\');        \\n        rec(n-1, sb);\\n        sb.setLength(sb.length() - 1);\\n        return k > list.size() ? \"\" : list.get(k-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 585703,
                "title": "java-o-n-solution",
                "content": "The solution is based on the fact that there are 3 choices for the first character and 2 for each subsequent one.\\nOn each step, I append the corresponding character based on k.\\n\\n```\\n    public String getHappyString(int n, int k) {\\n        \\n        k--;  // this is to make arithmetic a bit easier\\n        int power = 1 << (n-1);\\n        \\n\\t\\t// the total number of happy strings is 3*2^(n-1), so the first character is:\\n\\t\\t// \\'a\\' if k < 2^(n-1)\\n\\t\\t// \\'b\\' if 2^(n-1) <= k < 2*2^(n-1)\\n\\t\\t// \\'c\\' if 2*2^(n-1) <= k < 3*2^(n-1)\\n\\t\\t\\n        char current = (char)(k/power + \\'a\\');\\n        if (current > \\'c\\')  return \"\";\\n        StringBuilder ans = new StringBuilder();\\n        ans.append(current);    \\n\\n        for (int i = 1; i <= n - 1;  i++){\\n            k = k % power;\\n            power = power >> 1;\\n            \\n\\t\\t\\t// there are two possibilities for the next character\\n            // if the current k is >= than the 2^(n-i-1), append the greater possible character\\n            // otherwise append the smaller one\\n\\t\\t\\t\\n            char newChar = \\'a\\';\\n            if (current == \\'a\\')  newChar++;\\n            if (k >= power)  newChar++;\\n            if (current == newChar)  newChar++;            \\n            ans.append(newChar);\\n            \\n            current = newChar;\\n        }\\n        \\n        return ans.toString();            \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "The solution is based on the fact that there are 3 choices for the first character and 2 for each subsequent one.\\nOn each step, I append the corresponding character based on k.\\n\\n```\\n    public String getHappyString(int n, int k) {\\n        \\n        k--;  // this is to make arithmetic a bit easier\\n        int power = 1 << (n-1);\\n        \\n\\t\\t// the total number of happy strings is 3*2^(n-1), so the first character is:\\n\\t\\t// \\'a\\' if k < 2^(n-1)\\n\\t\\t// \\'b\\' if 2^(n-1) <= k < 2*2^(n-1)\\n\\t\\t// \\'c\\' if 2*2^(n-1) <= k < 3*2^(n-1)\\n\\t\\t\\n        char current = (char)(k/power + \\'a\\');\\n        if (current > \\'c\\')  return \"\";\\n        StringBuilder ans = new StringBuilder();\\n        ans.append(current);    \\n\\n        for (int i = 1; i <= n - 1;  i++){\\n            k = k % power;\\n            power = power >> 1;\\n            \\n\\t\\t\\t// there are two possibilities for the next character\\n            // if the current k is >= than the 2^(n-i-1), append the greater possible character\\n            // otherwise append the smaller one\\n\\t\\t\\t\\n            char newChar = \\'a\\';\\n            if (current == \\'a\\')  newChar++;\\n            if (k >= power)  newChar++;\\n            if (current == newChar)  newChar++;            \\n            ans.append(newChar);\\n            \\n            current = newChar;\\n        }\\n        \\n        return ans.toString();            \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 585682,
                "title": "python-fast-solution-using-divmod-no-dfs-100-100",
                "content": "The idea of this solution comes from [60. Permutation Sequence](https://leetcode.com/problems/permutation-sequence/). \\n\\n```\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n        # now k starting from index 0\\n        k -= 1\\n        \\n        bucket_size = (2 ** (n - 1))\\n        bucket_index, k = divmod(k, bucket_size)\\n        \\n        # edge case\\n        if bucket_index >= 3:\\n            return \\'\\'\\n        \\n        self.mapping = {\\'a\\': \\'bc\\', \\'b\\': \\'ac\\', \\'c\\': \\'ab\\'}\\n        return self.get_happy_string_recu(n - 1, k, bucket_size, chr(ord(\\'a\\') + bucket_index))\\n    \\n        \\n    def get_happy_string_recu(self, n, k, bucket_size, s):\\n        # base\\n        if n == 0:\\n            return s\\n        \\n        bucket_size = bucket_size // 2\\n        bucket, index = divmod(k, bucket_size)\\n        \\n        curr_char = self.mapping[s[-1]][bucket]\\n        return self.get_happy_string_recu(n - 1, index, bucket_size, s + curr_char)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n        # now k starting from index 0\\n        k -= 1\\n        \\n        bucket_size = (2 ** (n - 1))\\n        bucket_index, k = divmod(k, bucket_size)\\n        \\n        # edge case\\n        if bucket_index >= 3:\\n            return \\'\\'\\n        \\n        self.mapping = {\\'a\\': \\'bc\\', \\'b\\': \\'ac\\', \\'c\\': \\'ab\\'}\\n        return self.get_happy_string_recu(n - 1, k, bucket_size, chr(ord(\\'a\\') + bucket_index))\\n    \\n        \\n    def get_happy_string_recu(self, n, k, bucket_size, s):\\n        # base\\n        if n == 0:\\n            return s\\n        \\n        bucket_size = bucket_size // 2\\n        bucket, index = divmod(k, bucket_size)\\n        \\n        curr_char = self.mapping[s[-1]][bucket]\\n        return self.get_happy_string_recu(n - 1, index, bucket_size, s + curr_char)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 585678,
                "title": "c-c-backtracking-dfs",
                "content": "C++\\n```\\nstring result;\\nstring getHappyString(int n, int k) {\\n\\tstd::vector<char> str;\\n\\tdfs(str, n, k);\\n\\treturn result;\\n}\\n\\nvoid dfs(std::vector<char>& str, int n, int& k) {\\n\\tif (n == 0) {\\n\\t\\tif (--k == 0) result = string(str.begin(), str.end());\\n\\t} else {\\n\\t\\tfor(char ch = \\'a\\'; ch <= \\'c\\'; ++ch) {\\n\\t\\t\\tif (str.size() > 0 && ch == str[str.size() - 1]) continue;\\n\\t\\t\\tstr.push_back(ch);\\n\\t\\t\\tdfs(str, n - 1, k);\\n\\t\\t\\tstr.pop_back();\\n\\t\\t}\\n\\t}\\n}\\n```\\n\\nC#\\n```\\n    char[] ch = new char[3] { \\'a\\', \\'b\\', \\'c\\' };\\n    int kk = 0; string result = \"\";\\n\\t\\n    public string GetHappyString(int n, int k) {\\n        kk = k;\\n        backtrack(new List<char>(), n);\\n        return result;\\n    }\\n    \\n    void backtrack(List<char> str, int n) {\\n        if (n == 0) {\\n            if (--kk == 0)  { result = new string(str.ToArray()); return;};\\n        } else {\\n            for(var i = 0; i < ch.Length; i++) {\\n                if (str.Count > 0 && ch[i] == str[str.Count - 1]) continue;\\n                str.Add(ch[i]);\\n                backtrack(str, n - 1);\\n                str.RemoveAt(str.Count - 1);\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nstring result;\\nstring getHappyString(int n, int k) {\\n\\tstd::vector<char> str;\\n\\tdfs(str, n, k);\\n\\treturn result;\\n}\\n\\nvoid dfs(std::vector<char>& str, int n, int& k) {\\n\\tif (n == 0) {\\n\\t\\tif (--k == 0) result = string(str.begin(), str.end());\\n\\t} else {\\n\\t\\tfor(char ch = \\'a\\'; ch <= \\'c\\'; ++ch) {\\n\\t\\t\\tif (str.size() > 0 && ch == str[str.size() - 1]) continue;\\n\\t\\t\\tstr.push_back(ch);\\n\\t\\t\\tdfs(str, n - 1, k);\\n\\t\\t\\tstr.pop_back();\\n\\t\\t}\\n\\t}\\n}\\n```\n```\\n    char[] ch = new char[3] { \\'a\\', \\'b\\', \\'c\\' };\\n    int kk = 0; string result = \"\";\\n\\t\\n    public string GetHappyString(int n, int k) {\\n        kk = k;\\n        backtrack(new List<char>(), n);\\n        return result;\\n    }\\n    \\n    void backtrack(List<char> str, int n) {\\n        if (n == 0) {\\n            if (--kk == 0)  { result = new string(str.ToArray()); return;};\\n        } else {\\n            for(var i = 0; i < ch.Length; i++) {\\n                if (str.Count > 0 && ch[i] == str[str.Count - 1]) continue;\\n                str.Add(ch[i]);\\n                backtrack(str, n - 1);\\n                str.RemoveAt(str.Count - 1);\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3238929,
                "title": "c-solution-dfs",
                "content": "# Dfs Solution\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getHappyString(int n, int k) {\\n        string res=\"\";\\n        vector<char> ch(n);\\n\\n        auto Dfs=[&](auto Dfs,vector<char> &ch,int ind){\\n            if(ind==n){\\n                k--;\\n                return (k==0);\\n            }\\n            if(ind==0 or ch[ind-1]!=\\'a\\'){\\n                ch[ind]=\\'a\\';;\\n                if(Dfs(Dfs,ch,ind+1)){\\n                    return true;\\n                }\\n            }\\n            if(ind==0 or ch[ind-1]!=\\'b\\'){\\n                ch[ind]=\\'b\\';\\n                if(Dfs(Dfs,ch,ind+1)){\\n                    return true;\\n                }\\n            }\\n            if(ind==0 or ch[ind-1]!=\\'c\\'){\\n                ch[ind]=\\'c\\';\\n                if(Dfs(Dfs,ch,ind+1)){\\n                    return true;\\n                }\\n            }\\n            return false;\\n        };Dfs(Dfs,ch,0);\\n\\n        if(k!=0){\\n            return \"\";\\n        }\\n        for(int i=0;i<n;i++){\\n            res+=ch[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getHappyString(int n, int k) {\\n        string res=\"\";\\n        vector<char> ch(n);\\n\\n        auto Dfs=[&](auto Dfs,vector<char> &ch,int ind){\\n            if(ind==n){\\n                k--;\\n                return (k==0);\\n            }\\n            if(ind==0 or ch[ind-1]!=\\'a\\'){\\n                ch[ind]=\\'a\\';;\\n                if(Dfs(Dfs,ch,ind+1)){\\n                    return true;\\n                }\\n            }\\n            if(ind==0 or ch[ind-1]!=\\'b\\'){\\n                ch[ind]=\\'b\\';\\n                if(Dfs(Dfs,ch,ind+1)){\\n                    return true;\\n                }\\n            }\\n            if(ind==0 or ch[ind-1]!=\\'c\\'){\\n                ch[ind]=\\'c\\';\\n                if(Dfs(Dfs,ch,ind+1)){\\n                    return true;\\n                }\\n            }\\n            return false;\\n        };Dfs(Dfs,ch,0);\\n\\n        if(k!=0){\\n            return \"\";\\n        }\\n        for(int i=0;i<n;i++){\\n            res+=ch[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3037659,
                "title": "simple-clean-code-with-description-and-recursive-tree-diagram",
                "content": "# Intuition\\nBased on the recursive tree below we want to push the values into vector v.\\n![IMG_861342F1F6CB-1.jpeg](https://assets.leetcode.com/users/images/afdad033-764e-4f7a-9942-a14604560723_1673473286.9111812.jpeg)\\n\\n# Approach\\nWe are going to save the current string in op and iterate over and over until the current string size is equal to n.\\n\\n# Complexity\\n- Time complexity:\\nTime complexity of this approach is 3^N.\\n\\n- Space complexity:\\nSpace complexity of this approach is N.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<string> v;\\n    string getHappyString(int n, int k) {\\n        string op = \"\";\\n        solve(op, n, v);\\n        if ((k-1) >= v.size()) return \"\";\\n        return v[k-1];\\n    }\\n    void solve(string op, int n, vector<string> &v){\\n        if (n == 0){\\n            v.push_back(op);\\n            return;\\n        }\\n        for(int i = 0; i < 3;i++){\\n            char ch = \\'a\\' + i;\\n            if (op.size() == 0 or (op[op.size()-1] != ch)){\\n                solve(op+ch, n-1, v);\\n            }\\n        }\\n        return;\\n    }\\n};\\n```\\n# Upvote if this helps.",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<string> v;\\n    string getHappyString(int n, int k) {\\n        string op = \"\";\\n        solve(op, n, v);\\n        if ((k-1) >= v.size()) return \"\";\\n        return v[k-1];\\n    }\\n    void solve(string op, int n, vector<string> &v){\\n        if (n == 0){\\n            v.push_back(op);\\n            return;\\n        }\\n        for(int i = 0; i < 3;i++){\\n            char ch = \\'a\\' + i;\\n            if (op.size() == 0 or (op[op.size()-1] != ch)){\\n                solve(op+ch, n-1, v);\\n            }\\n        }\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790335,
                "title": "c-easy-backtracking-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    void backtrack(int ind,vector<char>&nums,vector<string>&ans,string &str,int n, char prevchar)\\n    {\\n        if(ind==n)\\n        {\\n            ans.push_back(str);\\n            return;\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(prevchar!=nums[i])\\n            {\\n                str.push_back(nums[i]);\\n                backtrack(ind+1,nums,ans,str,n,nums[i]);\\n                str.pop_back();\\n            }\\n            \\n        }\\n        \\n    }\\n    string getHappyString(int n, int k) {\\n        vector<string>ans;\\n        string str=\"\";\\n        vector<char>nums={\\'a\\',\\'b\\',\\'c\\'};\\n        char prevchar=\\' \\';\\n        backtrack(0,nums,ans,str,n,prevchar);\\n        return k>ans.size()?\"\":ans[k-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void backtrack(int ind,vector<char>&nums,vector<string>&ans,string &str,int n, char prevchar)\\n    {\\n        if(ind==n)\\n        {\\n            ans.push_back(str);\\n            return;\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(prevchar!=nums[i])\\n            {\\n                str.push_back(nums[i]);\\n                backtrack(ind+1,nums,ans,str,n,nums[i]);\\n                str.pop_back();\\n            }\\n            \\n        }\\n        \\n    }\\n    string getHappyString(int n, int k) {\\n        vector<string>ans;\\n        string str=\"\";\\n        vector<char>nums={\\'a\\',\\'b\\',\\'c\\'};\\n        char prevchar=\\' \\';\\n        backtrack(0,nums,ans,str,n,prevchar);\\n        return k>ans.size()?\"\":ans[k-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720843,
                "title": "easiest-solution-simple-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    string ans;\\nvector<string>v;\\nstring getHappyString(int n, int k) \\n{ \\n    ans=\"\";\\n    string str=\"\";\\n    fun(n,k,str);\\n    if((k-1)>=v.size())\\n    {\\n    \\treturn \"\";\\n\\t}\\n    return v[k-1];\\n}\\nvoid fun(int n,int &k,string str)\\n{\\n\\tif(n==0)\\n\\t{\\n        v.push_back(str);\\n\\t\\treturn ;\\n\\t}\\n\\tfor(int i=0;i<3;i++)\\n\\t{ \\n\\t    char ch = \\'a\\' + i;\\n\\t\\tif(str.length()==0)\\n\\t\\t{\\n          fun(n-1,k,str+ch);\\n\\t\\t}\\n\\t\\telse if(str.length()>0)\\n\\t\\t{\\n\\t\\t\\tif(str[str.length()-1]==ch)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tfun(n-1,k,str+ch);\\n\\t\\t}\\n\\t}\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string ans;\\nvector<string>v;\\nstring getHappyString(int n, int k) \\n{ \\n    ans=\"\";\\n    string str=\"\";\\n    fun(n,k,str);\\n    if((k-1)>=v.size())\\n    {\\n    \\treturn \"\";\\n\\t}\\n    return v[k-1];\\n}\\nvoid fun(int n,int &k,string str)\\n{\\n\\tif(n==0)\\n\\t{\\n        v.push_back(str);\\n\\t\\treturn ;\\n\\t}\\n\\tfor(int i=0;i<3;i++)\\n\\t{ \\n\\t    char ch = \\'a\\' + i;\\n\\t\\tif(str.length()==0)\\n\\t\\t{\\n          fun(n-1,k,str+ch);\\n\\t\\t}\\n\\t\\telse if(str.length()>0)\\n\\t\\t{\\n\\t\\t\\tif(str[str.length()-1]==ch)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tfun(n-1,k,str+ch);\\n\\t\\t}\\n\\t}\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2452027,
                "title": "c-same-as-cobination-sum-1-backtracking",
                "content": "![image](https://assets.leetcode.com/users/images/a1a7ca26-61a4-4647-8677-a7a15090f216_1660976933.5065818.png)\\n\\n***This Que is same as Leetcode Combination sum-1***\\n\\n**T->O(2^n) && S->O(n) [Recursion Stack Space]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<string> v;\\n\\t\\tvoid f(int i,string& s,int n){\\n\\t\\t\\tif(i==n){\\n\\t\\t\\t\\tv.push_back(s);\\n\\t\\t\\t\\treturn ;\\n\\t\\t\\t}\\n\\t\\t\\tfor(char j=\\'a\\';j!=\\'d\\';j++){\\n\\t\\t\\t\\tif(i>0 && j==s[i-1]) continue;\\n\\t\\t\\t\\ts.push_back(j);\\n\\t\\t\\t\\tf(i+1,s,n);\\n\\t\\t\\t\\ts.pop_back();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tstring getHappyString(int n, int k) {\\n\\t\\t\\tstring s=\"\";\\n\\t\\t\\tf(0,s,n);\\n\\t\\t\\tsort(v.begin(),v.end());\\n\\t\\t\\tif(k>v.size()) return \"\";\\n\\t\\t\\treturn v[k-1];\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<string> v;\\n\\t\\tvoid f(int i,string& s,int n){\\n\\t\\t\\tif(i==n){\\n\\t\\t\\t\\tv.push_back(s);\\n\\t\\t\\t\\treturn ;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2271133,
                "title": "c-backtracking-recursion-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void backtrack( int n,string curr,vector<char> &v,int k)\\n    {\\n        if(ans.size()==k)\\n            return ;\\n        if(curr.size()==n)\\n        {\\n            ans.push_back(curr);\\n                return;\\n        }\\n        for(int i=0;i<3;i++)\\n        {\\n            if(curr.size()==0||curr[curr.size()-1]!=v[i])\\n            {\\n                curr+=v[i];\\n                backtrack(n,curr,v,k);\\n                curr.pop_back();\\n            }\\n        }\\n    }\\n    string getHappyString(int n, int k) \\n    {\\n        vector<char> v={\\'a\\',\\'b\\',\\'c\\'};\\n        backtrack(n,\"\",v,k);\\n        if(ans.size()==k)\\n            return ans.back();\\n        else\\n            return \"\";\\n        \\n        \\n    }\\n};\\n// if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    vector<string> ans;\\n    void backtrack( int n,string curr,vector<char> &v,int k)\\n    {\\n        if(ans.size()==k)\\n            return ;\\n        if(curr.size()==n)\\n        {\\n            ans.push_back(curr);\\n                return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2251994,
                "title": "c-backtracking-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    void generate(int n, string cur,vector<string>& vec){\\n        if(cur.length()==n){\\n            vec.push_back(cur); return;\\n        }\\n        \\n        for(int i=0; i<3; i++){\\n            int len = cur.length(); \\n            char x = \\'a\\'+i;\\n            \\n            if(len==0) \\n                generate(n,cur+x,vec);\\n            else if(len-1>=0 && cur[len-1]!= x) \\n                generate(n,cur+x,vec);\\n        }\\n    }\\n    \\n    string getHappyString(int n, int k) {\\n        \\n        vector<string> vec;\\n        \\n        generate(n,\"\",vec);\\n        \\n        if(vec.size()<k) return \"\";\\n        return vec[k-1];\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void generate(int n, string cur,vector<string>& vec){\\n        if(cur.length()==n){\\n            vec.push_back(cur); return;\\n        }\\n        \\n        for(int i=0; i<3; i++){\\n            int len = cur.length(); \\n            char x = \\'a\\'+i;\\n            \\n            if(len==0) \\n                generate(n,cur+x,vec);\\n            else if(len-1>=0 && cur[len-1]!= x) \\n                generate(n,cur+x,vec);\\n        }\\n    }\\n    \\n    string getHappyString(int n, int k) {\\n        \\n        vector<string> vec;\\n        \\n        generate(n,\"\",vec);\\n        \\n        if(vec.size()<k) return \"\";\\n        return vec[k-1];\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2097836,
                "title": "c-beats-100-maths-easy-simple",
                "content": "Simple observation that how the strings are grouped can lead us to the solution.\\nFirst of all, total number of happy strings of length ```n``` can be: ``` 3*2*2*...*2 (n-1) times. ```\\n``` 3 ``` for there can be 3 alphabets as first character: ``` {a, b, c}```\\nBut for a given character at the previous index, let\\'s say ``` \\'b\\' ```, we can either have ``` \\'a\\' ``` or ``` \\'c\\' ``` _(because no 2 consecutive characters can be same)_\\nNow this property divides the set of happy strings of length ``` n ```, into ``` 3 ``` groups on the basis of the first character and further into groups of ``` 2 ```\\n\\nLet\\'s take the examples of ```n=3```:\\n\\n```\\naba abc aca acb bab bac bca bcb cab cac cba cbc\\n1   2   3   4   5   6   7   8   9   10  11  12    k\\n0   1   2   3   4   5   6   7   8   9   10  11    k-1\\n0   0   0   0   1   1   1   1   2   2   2   2     char1 (k/4)\\n0   1   2   3   0   1   2   3   0   1   2   3     k = k % 4\\n0   0   1   1   0   0   1   1   0   0   1   1     char2 (k/2)\\n0   1   0   1   0   1   0   1   0   1   0   1     char3 (k % 2 or k/1)\\n```\\nHere\\'s the code that beats 100% of the C++ submission:\\n\\n```\\nstring getHappyString(int n, int k) {\\n        if(3*pow(2,n-1) < k) return \"\";\\n        string ret=\"\";\\n        k--;\\n        int counter = pow(2,n-1);\\n        ret += (\\'a\\' + k/counter);\\n        k %= counter;\\n        counter /= 2;\\n        for(int i=1; i<n; i++){\\n            if(k/counter)\\n                ret += ret[i-1]==\\'a\\'?\\'c\\':ret[i-1]==\\'b\\'?\\'c\\':\\'b\\';\\n            else\\n                ret += ret[i-1]==\\'a\\'?\\'b\\':ret[i-1]==\\'b\\'?\\'a\\':\\'a\\';\\n            k %= counter;\\n            counter/=2;\\n        }\\n        return ret;\\n    }\\n};\\n```\\n\\uD83D\\uDE01\\u270C\\n\\n![image](https://assets.leetcode.com/users/images/07b0f88c-b9d9-42f5-a351-04beac0627b5_1654078130.0179589.png)\\n",
                "solutionTags": [],
                "code": "```n```\n``` 3*2*2*...*2 (n-1) times. ```\n``` 3 ```\n``` {a, b, c}```\n``` \\'b\\' ```\n``` \\'a\\' ```\n``` \\'c\\' ```\n``` n ```\n``` 3 ```\n``` 2 ```\n```n=3```\n```\\naba abc aca acb bab bac bca bcb cab cac cba cbc\\n1   2   3   4   5   6   7   8   9   10  11  12    k\\n0   1   2   3   4   5   6   7   8   9   10  11    k-1\\n0   0   0   0   1   1   1   1   2   2   2   2     char1 (k/4)\\n0   1   2   3   0   1   2   3   0   1   2   3     k = k % 4\\n0   0   1   1   0   0   1   1   0   0   1   1     char2 (k/2)\\n0   1   0   1   0   1   0   1   0   1   0   1     char3 (k % 2 or k/1)\\n```\n```\\nstring getHappyString(int n, int k) {\\n        if(3*pow(2,n-1) < k) return \"\";\\n        string ret=\"\";\\n        k--;\\n        int counter = pow(2,n-1);\\n        ret += (\\'a\\' + k/counter);\\n        k %= counter;\\n        counter /= 2;\\n        for(int i=1; i<n; i++){\\n            if(k/counter)\\n                ret += ret[i-1]==\\'a\\'?\\'c\\':ret[i-1]==\\'b\\'?\\'c\\':\\'b\\';\\n            else\\n                ret += ret[i-1]==\\'a\\'?\\'b\\':ret[i-1]==\\'b\\'?\\'a\\':\\'a\\';\\n            k %= counter;\\n            counter/=2;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2068930,
                "title": "c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    void track(int ind,int n,vector<string>&ans,string s){\\n        if(ind==n){\\n            ans.push_back(s);\\n            return;\\n        }\\n        for(int i=0;i<3;i++){\\n            if(s.back()!=\\'a\\'+i){\\n                string str=s;\\n                 str.push_back(\\'a\\'+i);\\n                track(ind+1,n,ans,str); \\n            }\\n        }\\n    }\\n    string getHappyString(int n, int k) {\\n        vector<string>ans;\\n        track(0,n,ans,\"\");\\n        if(k>ans.size()){\\n            return \"\";\\n        }\\n        return ans[k-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void track(int ind,int n,vector<string>&ans,string s){\\n        if(ind==n){\\n            ans.push_back(s);\\n            return;\\n        }\\n        for(int i=0;i<3;i++){\\n            if(s.back()!=\\'a\\'+i){\\n                string str=s;\\n                 str.push_back(\\'a\\'+i);\\n                track(ind+1,n,ans,str); \\n            }\\n        }\\n    }\\n    string getHappyString(int n, int k) {\\n        vector<string>ans;\\n        track(0,n,ans,\"\");\\n        if(k>ans.size()){\\n            return \"\";\\n        }\\n        return ans[k-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1778124,
                "title": "simple-java-bakctracking-solution",
                "content": "class Solution {\\n    \\n\\tint k;\\n    String res;\\n    boolean hasFound;\\n    \\n    public void dfs(StringBuilder s, char p, int n) {\\n        if(n == 0){\\n            if(k == 1){\\n                res = s.toString();\\n                hasFound = true;\\n            }\\n            else k--;\\n        }\\n        \\n        else{\\n            for(char ch = \\'a\\'; ch <= \\'c\\' && !hasFound; ch++){\\n                if(ch != p){\\n                    s.append(ch);\\n                    dfs(s, ch, n - 1);\\n                    s.deleteCharAt(s.length() - 1);\\n                }\\n            }\\n        }\\n    }\\n    \\n    public String getHappyString(int n, int k) {\\n        this.res = \"\";\\n        this.k = k;\\n        this.hasFound = false;\\n        \\n        dfs(new StringBuilder(), \\'z\\', n);\\n        \\n        return this.res;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n    \\n\\tint k;\\n    String res;\\n    boolean hasFound;\\n    \\n    public void dfs(StringBuilder s, char p, int n) {\\n        if(n == 0){\\n            if(k == 1){\\n                res = s.toString();\\n                hasFound = true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1641518,
                "title": "c-backtracking-recursion-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(int &n,int &k,string temp,string &happy){\\n        if(k<=0)return;\\n        if(temp.size()==n){\\n            k--;\\n            if(k==0)happy=temp;\\n            return;\\n        }\\n        if(temp.back()!=\\'a\\')solve(n,k,temp+\\'a\\',happy);\\n        if(temp.back()!=\\'b\\')solve(n,k,temp+\\'b\\',happy);\\n        if(temp.back()!=\\'c\\')solve(n,k,temp+\\'c\\',happy);\\n\\n    }\\n    string getHappyString(int n, int k) {\\n        string happy;\\n        solve(n,k,\"\",happy);\\n        return happy;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    void solve(int &n,int &k,string temp,string &happy){\\n        if(k<=0)return;\\n        if(temp.size()==n){\\n            k--;\\n            if(k==0)happy=temp;\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1569558,
                "title": "c-backtracking-tc-o-2-n-sc-o-2-n-aux-o-2-n",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(vector<string>& ans, string curr, string ltrs, int reqLen) {\\n        if(curr.length() == reqLen) {\\n            ans.push_back(curr);\\n            return ;\\n        } \\n        \\n        for(int i = 0; i < 3; i++) {\\n            if(curr == \"\" || curr.back() != ltrs[i]) {\\n                curr.push_back(ltrs[i]);\\n                solve(ans,curr,ltrs,reqLen);\\n                curr.pop_back();\\n            }\\n        }\\n    }\\n    \\n    string getHappyString(int n, int k) {\\n        vector<string> ans;\\n        string ltrs = \"abc\";\\n        string curr = \"\";\\n        solve(ans,curr,ltrs,n);\\n        sort(ans.begin(),ans.end());\\n        if(ans.size() < k)\\n            return \"\";\\n        return ans[k-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<string>& ans, string curr, string ltrs, int reqLen) {\\n        if(curr.length() == reqLen) {\\n            ans.push_back(curr);\\n            return ;\\n        } \\n        \\n        for(int i = 0; i < 3; i++) {\\n            if(curr == \"\" || curr.back() != ltrs[i]) {\\n                curr.push_back(ltrs[i]);\\n                solve(ans,curr,ltrs,reqLen);\\n                curr.pop_back();\\n            }\\n        }\\n    }\\n    \\n    string getHappyString(int n, int k) {\\n        vector<string> ans;\\n        string ltrs = \"abc\";\\n        string curr = \"\";\\n        solve(ans,curr,ltrs,n);\\n        sort(ans.begin(),ans.end());\\n        if(ans.size() < k)\\n            return \"\";\\n        return ans[k-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1469287,
                "title": "backtracking-my-dog-passed-away-recently-beats-90-vegetable-hulk",
                "content": "\\n    char s[3] = {\\'a\\',\\'b\\',\\'c\\'};\\n    vector<string> ans;\\n    void helper(int n, int k, string res){\\n        if(k == ans.size()){\\n            return;\\n        }\\n        if(n == res.size()){\\n            ans.push_back(res);\\n            return;\\n        }\\n        \\n        for(int i=0; i<3; i++){\\n            if(res.length() == 0 || res[res.size()-1] != s[i]){\\n                res.push_back(s[i]);\\n                helper(n, k, res);\\n                res.pop_back();\\n            } \\n        }\\n    }\\n    \\n    string getHappyString(int n, int k) {\\n        string res;\\n        helper(n, k, res);\\n        if(ans.size() == k){\\n            return ans.back();\\n        }\\n        return \"\";\\n    }\\n######",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n    char s[3] = {\\'a\\',\\'b\\',\\'c\\'};\\n    vector<string> ans;\\n    void helper(int n, int k, string res){\\n        if(k == ans.size()){\\n            return;\\n        }\\n        if(n == res.size()){\\n            ans.push_back(res);\\n            return;\\n        }\\n        \\n        for(int i=0; i<3; i++){\\n            if(res.length() == 0 || res[res.size()-1] != s[i]){\\n                res.push_back(s[i]);\\n                helper(n, k, res);\\n                res.pop_back();\\n            } \\n        }\\n    }\\n    \\n    string getHappyString(int n, int k) {\\n        string res;\\n        helper(n, k, res);\\n        if(ans.size() == k){\\n            return ans.back();\\n        }\\n        return \"\";\\n    }\\n######",
                "codeTag": "Unknown"
            },
            {
                "id": 1420200,
                "title": "python3-ez-for-loop-solves-all-with-detailed-comments-and-graphical-examples",
                "content": "Runtime: 32 ms, faster than 89.30% of Python3 online submissions for The k-th Lexicographical String of All Happy Strings of Length n.\\nMemory Usage: 14.2 MB, less than 74.06% of Python3 online submissions for The k-th Lexicographical String of All Happy Strings of Length n.\\n\\n```\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n        \\n        char = [\"a\", \"b\", \"c\"]  \\n        \\n        # Edge case, n = 1\\n        if n == 1: return char[k - 1] if k <= 3 else \"\"\\n        \\n        # There will be $part$ number of strings starting with each character (a, b, c)\\n        part = 2 ** (n - 1)\\n        \\n        # If k is too large\\n        if k > part * 3: return \"\"\\n        \\n        res = []\\n        \\n        # Edge case is k = n * i, where i is an integer in range [1, 3]\\n        res.append(char[k // part if k % part != 0 else k // part - 1])\\n        k = k % part if k % part != 0 else part\\n        \\n        for i in range(n - 2, -1, -1):\\n            char = [\"a\", \"b\", \"c\"]  \\n            char.remove(res[-1])        # Make sure the adjacent characters will be different\\n            \\n            if len(res) + 1 == n:       # Edge case, assigning the last element\\n                if k == 1: res.append(char[0])\\n                elif k == 2: res.append(char[-1])\\n            elif k > 2 ** i:            # Go to the right side\\n                res.append(char[-1])\\n                k -= 2 ** i       \\n            else: res.append(char[0])   # Go to the left side\\n        \\n        return \"\".join(res)\\n```\\n\\t\\n\\nExplanations and examples:\\nTaking n = 4 as an example here.\\n\\nThe general case will be:\\n![image](https://assets.leetcode.com/users/images/2f24b63e-b81b-427c-a382-3a08283c97e5_1629670252.6504102.png)\\n\\nWhen k = 2:\\n![image](https://assets.leetcode.com/users/images/1625022d-c711-46d8-9d63-56912f6dbf79_1629670775.5862274.png)\\n\\nFrom floor 1 to floor 2, k is less than the value on floor 2 (k < 4). The path goes to the left side, ```res``` appends b, k stays the same. \\n\\nFrom floor 2 to floor 3, k equals to the value on floor 3 (k = 2), the path goes to the left side, ```res``` appends a, k stays the same. \\n\\nFrom floor 3 to floor 4, since floor 4 is the last floor, so this is the edge case. k equals to 2, thus ```res``` appends ```char[-1]```.\\n\\nWhen k = 7:\\n![image](https://assets.leetcode.com/users/images/10e094f9-deed-4103-8d44-c0d57f9d4d54_1629670896.6669524.png)\\n\\nFrom floor 1 to floor 2, k is larger than the value on floor 2 (k > 4). The path goes to the right side, ```res``` appends c, ```k -= 4```. \\n\\nFrom floor 2 to floor 3, k is larger to the value on floor 3 (k > 2), the path goes to the right side, ```res``` appends b, ```k -= 2```. \\n\\nFrom floor 3 to floor 4, since floor 4 is the last floor, so this is the edge case. k equals to 1, thus ```res``` appends ```char[0]```.\\n\\n\\nLet me know if you have any ideas for optimization. **UPVOTE** if this is helpful!",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n        \\n        char = [\"a\", \"b\", \"c\"]  \\n        \\n        # Edge case, n = 1\\n        if n == 1: return char[k - 1] if k <= 3 else \"\"\\n        \\n        # There will be $part$ number of strings starting with each character (a, b, c)\\n        part = 2 ** (n - 1)\\n        \\n        # If k is too large\\n        if k > part * 3: return \"\"\\n        \\n        res = []\\n        \\n        # Edge case is k = n * i, where i is an integer in range [1, 3]\\n        res.append(char[k // part if k % part != 0 else k // part - 1])\\n        k = k % part if k % part != 0 else part\\n        \\n        for i in range(n - 2, -1, -1):\\n            char = [\"a\", \"b\", \"c\"]  \\n            char.remove(res[-1])        # Make sure the adjacent characters will be different\\n            \\n            if len(res) + 1 == n:       # Edge case, assigning the last element\\n                if k == 1: res.append(char[0])\\n                elif k == 2: res.append(char[-1])\\n            elif k > 2 ** i:            # Go to the right side\\n                res.append(char[-1])\\n                k -= 2 ** i       \\n            else: res.append(char[0])   # Go to the left side\\n        \\n        return \"\".join(res)\\n```\n```res```\n```res```\n```res```\n```char[-1]```\n```res```\n```k -= 4```\n```res```\n```k -= 2```\n```res```\n```char[0]```",
                "codeTag": "Java"
            },
            {
                "id": 1059573,
                "title": "java-simple-and-concise-solution-using-recursion",
                "content": "```\\nclass Solution {\\n     List<String> list=new ArrayList<>();\\n    public String getHappyString(int n, int k) {\\n       String str=\"abc\";\\n       prepareElem(str,n,0,\"\");\\n        return list.size()>=k?list.get(k-1):\"\";\\n    }\\n    \\n       private  void prepareElem(String str,int len,int index,String cur){\\n        if(cur.length()==len){\\n            list.add(cur);\\n            return;\\n        }\\n        for(int i=0;i<str.length();i++){\\n            if(cur.length()>0 && cur.charAt(cur.length()-1)==str.charAt(i)){\\n                continue;\\n            }\\n            prepareElem(str,len,0,cur+ str.charAt(i));\\n        }\\n      }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n     List<String> list=new ArrayList<>();\\n    public String getHappyString(int n, int k) {\\n       String str=\"abc\";\\n       prepareElem(str,n,0,\"\");\\n        return list.size()>=k?list.get(k-1):\"\";\\n    }\\n    \\n       private  void prepareElem(String str,int len,int index,String cur){\\n        if(cur.length()==len){\\n            list.add(cur);\\n            return;\\n        }\\n        for(int i=0;i<str.length();i++){\\n            if(cur.length()>0 && cur.charAt(cur.length()-1)==str.charAt(i)){\\n                continue;\\n            }\\n            prepareElem(str,len,0,cur+ str.charAt(i));\\n        }\\n      }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1052425,
                "title": "python-easy-6-line-recursive-solution",
                "content": "* recursive: use quotient of (k+1)//2 to decide the prefix string with (n-1) length\\n* why k+1: for example, k=1 or k=2 both lead to the 1st prefix string with (n-1) length\\n* there are only 3 happy strings of length 1,  so when n =1, if k > 3, empty string\\n* chr(96+k): k=1, return chr(97)=\\'a\\', similar with k=2,3 to get \\'b\\',\\'c\\'\\n* the remainder of k//2 will decide the last string; reverse_order to make 0 get larger letter, 1 smaller\\n```\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n        reverse_order = {\\'a\\':\\'cb\\', \\'b\\':\\'ca\\', \\'c\\':\\'ba\\'}\\n        if n == 1:\\n            return chr(96+k) if k<=3 else \\'\\'\\n        else:\\n            tmp = self.getHappyString(n-1,(k+1)//2)\\n            return tmp if not tmp else tmp+reverse_order[tmp[-1]][k%2]\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n        reverse_order = {\\'a\\':\\'cb\\', \\'b\\':\\'ca\\', \\'c\\':\\'ba\\'}\\n        if n == 1:\\n            return chr(96+k) if k<=3 else \\'\\'\\n        else:\\n            tmp = self.getHappyString(n-1,(k+1)//2)\\n            return tmp if not tmp else tmp+reverse_order[tmp[-1]][k%2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 964674,
                "title": "c-solution-using-mathematical-approach",
                "content": "```class Solution {\\npublic:\\n    string getHappyString(int n, int k) {\\n        int total=3*pow(2,n-1);\\n        string ans;\\n        char laschar;\\n        int period=total/3;\\n        if((k/period==0 && k%period!=0)|| (k%period==0 && k/period==1)){ans+=\\'a\\';laschar=\\'a\\';} //if this condition is satisfied then first character of the string will be \\'a\\'\\n        else if((k/period==1 && k%period!=0 )|| (k%period==0 && k/period==2)){ans+=\\'b\\';laschar=\\'b\\';} //if this condition is satisfied then first character of the string will be \\'b\\'\\n        else if((k/period==2 && k%period!=0) || (k%period==0 && k/period==3)){ans+=\\'c\\';laschar=\\'c\\';} //if this condition is satisfied then first character of the string will be \\'c\\'\\n        else{\\n            return ans;  // This condition implies there is no solution i.e. no. of substring in < k\\n        }\\n        k=k-((k/period)*period);\\n        period/=2;\\n        while(period>0){\\n            if((k/period==0 && k%period!=0)|| (k%period==0 && k/period==1)){\\n                if(laschar==\\'a\\'){  // checking the previous char and deciding the next one\\n                    ans+=\\'b\\';\\n                    laschar=\\'b\\';\\n                }else{\\n                    ans+=\\'a\\';\\n                    laschar=\\'a\\';\\n                }\\n            }else{\\n                if(laschar==\\'c\\'){\\n                    ans+=\\'b\\';\\n                    laschar=\\'b\\';\\n                }else{\\n                    ans+=\\'c\\';\\n                    laschar=\\'c\\';\\n                }\\n            }\\n            k=k-((k/period)*period);\\n            period/=2;\\n        }\\n        return ans;\\n    }\\n};```\\n\\nAccording to me the best way of approach is using Maths. Just follow the patten it occurs.",
                "solutionTags": [],
                "code": "```class Solution {\\npublic:\\n    string getHappyString(int n, int k) {\\n        int total=3*pow(2,n-1);\\n        string ans;\\n        char laschar;\\n        int period=total/3;\\n        if((k/period==0 && k%period!=0)|| (k%period==0 && k/period==1)){ans+=\\'a\\';laschar=\\'a\\';} //if this condition is satisfied then first character of the string will be \\'a\\'\\n        else if((k/period==1 && k%period!=0 )|| (k%period==0 && k/period==2)){ans+=\\'b\\';laschar=\\'b\\';} //if this condition is satisfied then first character of the string will be \\'b\\'\\n        else if((k/period==2 && k%period!=0) || (k%period==0 && k/period==3)){ans+=\\'c\\';laschar=\\'c\\';} //if this condition is satisfied then first character of the string will be \\'c\\'\\n        else{\\n            return ans;  // This condition implies there is no solution i.e. no. of substring in < k\\n        }\\n        k=k-((k/period)*period);\\n        period/=2;\\n        while(period>0){\\n            if((k/period==0 && k%period!=0)|| (k%period==0 && k/period==1)){\\n                if(laschar==\\'a\\'){  // checking the previous char and deciding the next one\\n                    ans+=\\'b\\';\\n                    laschar=\\'b\\';\\n                }else{\\n                    ans+=\\'a\\';\\n                    laschar=\\'a\\';\\n                }\\n            }else{\\n                if(laschar==\\'c\\'){\\n                    ans+=\\'b\\';\\n                    laschar=\\'b\\';\\n                }else{\\n                    ans+=\\'c\\';\\n                    laschar=\\'c\\';\\n                }\\n            }\\n            k=k-((k/period)*period);\\n            period/=2;\\n        }\\n        return ans;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 792126,
                "title": "javascript-clean-and-short-backtracking-no-arrays",
                "content": "```javascript\\nvar getHappyString = function(n, k) {\\n    \\n    function permute(str) {\\n        if(str.length === n) return --k ? false : str;\\n        \\n        for(let c of \\'abc\\') {\\n            if(c === str[str.length-1]) continue;\\n            const val = permute(str+c);\\n            if(val) return val;\\n        }\\n        return false;\\n    }\\n    return permute(\\'\\') || \\'\\';\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```javascript\\nvar getHappyString = function(n, k) {\\n    \\n    function permute(str) {\\n        if(str.length === n) return --k ? false : str;\\n        \\n        for(let c of \\'abc\\') {\\n            if(c === str[str.length-1]) continue;\\n            const val = permute(str+c);\\n            if(val) return val;\\n        }\\n        return false;\\n    }\\n    return permute(\\'\\') || \\'\\';\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 677145,
                "title": "simple-solution-using-backtracking-c",
                "content": "```\\nclass Solution {\\n    \\nset<string> ans;\\n\\nvoid happy(vector<char> ss,string a,int cnt,int n)\\n{\\n    if(cnt==n) {ans.insert(a); return;}\\n        \\n    for(int i=0;i<3;i++)\\n    {\\n        if(!a.empty()&&a.back()==ss[i]) continue;\\n        else happy(ss,a+ss[i],cnt+1,n);\\n    }\\n        \\n    return;\\n        \\n}\\n    \\npublic:\\n    string getHappyString(int n, int k) {\\n        vector<char> ss;\\n        ss.push_back(\\'a\\'); ss.push_back(\\'b\\'); ss.push_back(\\'c\\');\\n        \\n        happy(ss,\"\",0,n);\\n        \\n        int cnt=0;\\n        vector<string> v;\\n        for(auto it=ans.begin();it!=ans.end();it++)\\n        {\\n           v.push_back(*it);\\n        }\\n        \\n        if(k>v.size()) return \"\";\\n        return v[k-1];\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\nset<string> ans;\\n\\nvoid happy(vector<char> ss,string a,int cnt,int n)\\n{\\n    if(cnt==n) {ans.insert(a); return;}\\n        \\n    for(int i=0;i<3;i++)\\n    {\\n        if(!a.empty()&&a.back()==ss[i]) continue;\\n        else happy(ss,a+ss[i],cnt+1,n);\\n    }\\n        \\n    return;\\n        \\n}\\n    \\npublic:\\n    string getHappyString(int n, int k) {\\n        vector<char> ss;\\n        ss.push_back(\\'a\\'); ss.push_back(\\'b\\'); ss.push_back(\\'c\\');\\n        \\n        happy(ss,\"\",0,n);\\n        \\n        int cnt=0;\\n        vector<string> v;\\n        for(auto it=ans.begin();it!=ans.end();it++)\\n        {\\n           v.push_back(*it);\\n        }\\n        \\n        if(k>v.size()) return \"\";\\n        return v[k-1];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 670965,
                "title": "java-transfer-to-binary-integer",
                "content": "This is actuallya \"String\" version of binary numbers, except the first digit is 3-base;\\nthe kth, is actualy k -1, if starts from \"0\";\\n```\\npublic String getHappyString(int n, int k) {\\n        int base = 1, idx = 0, prev = 4;  // prev init \\n        char[] arr = new char[]{\\'a\\', \\'b\\', \\'c\\'}, res = new char[n];\\n        for (int i = 1; i < n; i++) base *= 2;\\n        if (--k / base > 2) return \"\";  // say 2, 6, transfer to 2,  5. \"ca\";\\n        for (int i = 0, idx = 0, prev = 4; i < n; i++) {\\n            idx = k / base;\\n            k %= base;\\n            base /= 2;\\n            if (idx >= prev) idx = (idx + 4) % 3;\\n            res[i] = arr[idx];\\n            prev = idx;\\n        }\\n        return String.valueOf(res);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String getHappyString(int n, int k) {\\n        int base = 1, idx = 0, prev = 4;  // prev init \\n        char[] arr = new char[]{\\'a\\', \\'b\\', \\'c\\'}, res = new char[n];\\n        for (int i = 1; i < n; i++) base *= 2;\\n        if (--k / base > 2) return \"\";  // say 2, 6, transfer to 2,  5. \"ca\";\\n        for (int i = 0, idx = 0, prev = 4; i < n; i++) {\\n            idx = k / base;\\n            k %= base;\\n            base /= 2;\\n            if (idx >= prev) idx = (idx + 4) % 3;\\n            res[i] = arr[idx];\\n            prev = idx;\\n        }\\n        return String.valueOf(res);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 669778,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string>v;\\n    void recur(string s,int n){\\n        if(s.size()==n){v.push_back(s);return;}\\n        else{\\n            int a=s.size();\\n            for(auto i=\\'a\\';i<=\\'c\\';i++){\\n                if(s[a-1]==i)continue;\\n                else {s+=i;recur(s,n);\\n                     s.erase(a);}\\n            }\\n        }\\n        \\n    }\\n    string getHappyString(int n, int k) {\\n        recur(\"a\",n);\\n        recur(\"b\",n);\\n        recur(\"c\",n);\\n        sort(v.begin(),v.end());\\n        if(v.size()>=k)return v[k-1];\\n        else return \"\";\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string>v;\\n    void recur(string s,int n){\\n        if(s.size()==n){v.push_back(s);return;}\\n        else{\\n            int a=s.size();\\n            for(auto i=\\'a\\';i<=\\'c\\';i++){\\n                if(s[a-1]==i)continue;\\n                else {s+=i;recur(s,n);\\n                     s.erase(a);}\\n            }\\n        }\\n        \\n    }\\n    string getHappyString(int n, int k) {\\n        recur(\"a\",n);\\n        recur(\"b\",n);\\n        recur(\"c\",n);\\n        sort(v.begin(),v.end());\\n        if(v.size()>=k)return v[k-1];\\n        else return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 607512,
                "title": "1415-the-k-th-lexicographical-string-of-all-happy-strings-of-length-n-py-all-in-one-by-talse",
                "content": "**Get it Done, Make it Better, Share the Best -- Talse**\\n**I). Backtracking**\\n| O(T): O() | O(S): O() | Rt: 136ms | \\n```python\\n    def getHappyString(self, n: int, k: int) -> str:\\n        def dfs(path, n, rst):\\n            if len(path) == n: rst.append(path); return \\n            for i in \\'abc\\':\\n                if path and i == path[-1]: continue\\n                dfs(path+i, n, rst)\\n                    \\n        arr = []\\n        dfs(\\'\\', n, arr)\\n        if len(arr) < k: return \\'\\'\\n        return arr[k-1]\\n```\\n\\n\\n**II). Iterative**\\n| O(T): O() | O(S): O() | Rt: 92ms | \\n```python\\n    def getHappyString(self, n: int, k: int) -> str:\\n        stack = [\\'\\']\\n        for _ in range(n):\\n            stack = [i+j for i in stack for j in \\'abc\\' if not i or j != i[-1]]\\n        if len(stack) < k: return \\'\\'\\n        return stack[k-1]\\n```\\n\\nAlternative: no need to generate all happy strings. | Rt: 72ms |\\n```python\\n    def getHappyString(self, n: int, k: int) -> str:\\n        q = collections.deque([\\'\\'])\\n        for i in range(n):\\n            size = len(q)\\n            for _ in range(size):\\n                s = q.popleft()\\n                for c in \\'abc\\':\\n                    if s and s[-1] == c: continue\\n                    q.append(s+c)\\n                    if i == n-1: \\n                        k -= 1\\n                        if k == 0: return s+c\\n        return \\'\\'\\n```\\n\\n\\n**III). Generator**\\n| O(T): O() | O(S): O() | Rt: 36ms | \\n```python\\n    def getHappyString(self, n: int, k: int) -> str:\\n        def gen(path, n):\\n            if len(path) == n: yield path; return\\n            for c in \\'abc\\':\\n                if path and path[-1] == c: continue\\n                yield from gen(path+c, n)\\n                \\n        for happy in gen(\\'\\', n):\\n            k -= 1\\n            if k == 0: return happy\\n        return \\'\\'\\n```\\nReferrence: using generator - https://leetcode.com/problems/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n/discuss/585561/Python-7-line-DFS-with-yield",
                "solutionTags": [],
                "code": "```python\\n    def getHappyString(self, n: int, k: int) -> str:\\n        def dfs(path, n, rst):\\n            if len(path) == n: rst.append(path); return \\n            for i in \\'abc\\':\\n                if path and i == path[-1]: continue\\n                dfs(path+i, n, rst)\\n                    \\n        arr = []\\n        dfs(\\'\\', n, arr)\\n        if len(arr) < k: return \\'\\'\\n        return arr[k-1]\\n```\n```python\\n    def getHappyString(self, n: int, k: int) -> str:\\n        stack = [\\'\\']\\n        for _ in range(n):\\n            stack = [i+j for i in stack for j in \\'abc\\' if not i or j != i[-1]]\\n        if len(stack) < k: return \\'\\'\\n        return stack[k-1]\\n```\n```python\\n    def getHappyString(self, n: int, k: int) -> str:\\n        q = collections.deque([\\'\\'])\\n        for i in range(n):\\n            size = len(q)\\n            for _ in range(size):\\n                s = q.popleft()\\n                for c in \\'abc\\':\\n                    if s and s[-1] == c: continue\\n                    q.append(s+c)\\n                    if i == n-1: \\n                        k -= 1\\n                        if k == 0: return s+c\\n        return \\'\\'\\n```\n```python\\n    def getHappyString(self, n: int, k: int) -> str:\\n        def gen(path, n):\\n            if len(path) == n: yield path; return\\n            for c in \\'abc\\':\\n                if path and path[-1] == c: continue\\n                yield from gen(path+c, n)\\n                \\n        for happy in gen(\\'\\', n):\\n            k -= 1\\n            if k == 0: return happy\\n        return \\'\\'\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 585837,
                "title": "java-with-stack-and-bit-reading-o-n-solution",
                "content": "Bit  reading wouldn\\'t be very accurate, but in some sense this solution uses bits as solution.\\n\\n**Intuition**\\n\\nWe look at imaginary tree where root has three values: \\'a\\' , \\'b\\' and \\'c\\'\\nEvery next level has double number of values as a previous one 3->6->12->...\\nNow we start with last level where our value is. Every values parent is on ceiling(k/2) or (k+1)/2 position.\\n\\nWe travel through n-levels of tree and we memorize from what position we came from ( (k+1)%2 ) and put it in the Stack.\\nWhet we get to the root we find out what is first char of solution with (k-1)%3, this is because k can be 1-3 and we need 0-2 index.\\n\\nWe also memorize what chars can come after previous one in toolMat matrix.\\n\\nNow we travel again from root to value we looked for, and build it.\\n\\n```\\npublic String getHappyString(int n, int k) {\\n        int pov=(int)Math.pow(2,n-1);\\n        if(pov*3<k) return \"\";\\n        \\n        char[][] toolMat=new char[][]{{\\'b\\',\\'c\\'},{\\'a\\',\\'c\\'},{\\'a\\',\\'b\\'}};\\n        Stack<Integer> stack=new Stack<>();\\n        StringBuilder sb=new StringBuilder();\\n        \\n        for(int i=1;i<n;i++){\\n            stack.add((1+k)%2);\\n            k=(k+1)/2;\\n        }\\n        int pos=(k-1)%3;\\n        char bad=(char)(\\'a\\'+pos);\\n        \\n        sb.append(bad);\\n        while(!stack.isEmpty()){\\n            char curr=toolMat[pos][stack.pop()];\\n            sb.append(curr);\\n            pos=(int)(curr-\\'a\\');\\n        }\\n            \\n        \\n        \\n        return sb.toString();\\n    }\\n\\n```\\n\\n**Complexity**\\n\\tTime: O(n) first and second for is happaning n times \\n\\tMemory : O(log k) stack size\\n\\n\\nHopefully I helped someone with this problem :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String getHappyString(int n, int k) {\\n        int pov=(int)Math.pow(2,n-1);\\n        if(pov*3<k) return \"\";\\n        \\n        char[][] toolMat=new char[][]{{\\'b\\',\\'c\\'},{\\'a\\',\\'c\\'},{\\'a\\',\\'b\\'}};\\n        Stack<Integer> stack=new Stack<>();\\n        StringBuilder sb=new StringBuilder();\\n        \\n        for(int i=1;i<n;i++){\\n            stack.add((1+k)%2);\\n            k=(k+1)/2;\\n        }\\n        int pos=(k-1)%3;\\n        char bad=(char)(\\'a\\'+pos);\\n        \\n        sb.append(bad);\\n        while(!stack.isEmpty()){\\n            char curr=toolMat[pos][stack.pop()];\\n            sb.append(curr);\\n            pos=(int)(curr-\\'a\\');\\n        }\\n            \\n        \\n        \\n        return sb.toString();\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 585787,
                "title": "o-n-time-o-n-memory",
                "content": "```\\npublic String getHappyString(int n, int k) {\\n  // initialization\\n  char[] alphabet = new char[]{\\'a\\', \\'b\\', \\'c\\'};\\n  int base = 1 << (n - 1);\\n  StringBuilder b = new StringBuilder(\"\");\\n\\n  // processing\\n  while (base > 0) {\\n\\t  char prev = (b.length() == 0 ? \\'x\\' : b.charAt(b.length() - 1));\\n\\t  int accum = base;\\n\\t  for (char c : alphabet) {\\n\\t\\tif (c == prev) continue;\\n\\t\\tif (accum >= k) {\\n\\t\\t\\tb.append(c); \\n\\t\\t\\tk -= (accum - base);\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\taccum += base;\\n\\t  }\\n\\t  base /= 2;\\n  }\\n  return b.toString();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic String getHappyString(int n, int k) {\\n  // initialization\\n  char[] alphabet = new char[]{\\'a\\', \\'b\\', \\'c\\'};\\n  int base = 1 << (n - 1);\\n  StringBuilder b = new StringBuilder(\"\");\\n\\n  // processing\\n  while (base > 0) {\\n\\t  char prev = (b.length() == 0 ? \\'x\\' : b.charAt(b.length() - 1));\\n\\t  int accum = base;\\n\\t  for (char c : alphabet) {\\n\\t\\tif (c == prev) continue;\\n\\t\\tif (accum >= k) {\\n\\t\\t\\tb.append(c); \\n\\t\\t\\tk -= (accum - base);\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\taccum += base;\\n\\t  }\\n\\t  base /= 2;\\n  }\\n  return b.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 585731,
                "title": "python-easy-solution-grouping",
                "content": "for example: n=3, k =9 (index=8)\\n```\\nstring: [\"aba\", \"abc\", \"aca\", \"acb\", \"bab\", \"bac\", \"bca\", \"bcb\", \"cab\", \"cac\", \"cba\", \"cbc\"]\\nindex:     0      1      2      3      4      5      6      7      8      9      10     11 \\n```\\nfirst we can seperate into 3 groups\\ngroup_num: number in each group = 4\\n\\n```\\ngroup                    0             |              1             |              2\\nstring    : \"aba\", \"abc\", \"aca\", \"acb\",| \"bab\", \"bac\", \"bca\", \"bcb\",| \"cab\", \"cac\", \"cba\", \"cbc\"\\nnew_index:     0      1      2      3  |   0      1      2      3   |   0      1      2      3 \\n```\\nwe can know that index:8 is in group 2 (8//4)\\nnew_index = index%group_num\\ngroup_num = group_num/2\\nand so on....\\n\\n\\n```\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n        group_num = 2**(n-1)\\n        wow = \"\"\\n        if k>group_num*3: return wow\\n        character = [\\'a\\', \\'b\\', \\'c\\']\\n        k -= 1     #index\\n        wow += character[k//group_num]\\n        k %= group_num\\n        group_num //= 2\\n        while group_num:\\n            if wow[-1] == \\'a\\': character = [\\'b\\', \\'c\\']\\n            elif wow[-1] == \\'b\\': character = [\\'a\\', \\'c\\']\\n            else: character = [\\'a\\', \\'b\\']\\n            wow += character[k//group_num]\\n            k %= group_num\\n            group_num //= 2\\n        return wow\\n```",
                "solutionTags": [],
                "code": "```\\nstring: [\"aba\", \"abc\", \"aca\", \"acb\", \"bab\", \"bac\", \"bca\", \"bcb\", \"cab\", \"cac\", \"cba\", \"cbc\"]\\nindex:     0      1      2      3      4      5      6      7      8      9      10     11 \\n```\n```\\ngroup                    0             |              1             |              2\\nstring    : \"aba\", \"abc\", \"aca\", \"acb\",| \"bab\", \"bac\", \"bca\", \"bcb\",| \"cab\", \"cac\", \"cba\", \"cbc\"\\nnew_index:     0      1      2      3  |   0      1      2      3   |   0      1      2      3 \\n```\n```\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n        group_num = 2**(n-1)\\n        wow = \"\"\\n        if k>group_num*3: return wow\\n        character = [\\'a\\', \\'b\\', \\'c\\']\\n        k -= 1     #index\\n        wow += character[k//group_num]\\n        k %= group_num\\n        group_num //= 2\\n        while group_num:\\n            if wow[-1] == \\'a\\': character = [\\'b\\', \\'c\\']\\n            elif wow[-1] == \\'b\\': character = [\\'a\\', \\'c\\']\\n            else: character = [\\'a\\', \\'b\\']\\n            wow += character[k//group_num]\\n            k %= group_num\\n            group_num //= 2\\n        return wow\\n```",
                "codeTag": "Java"
            },
            {
                "id": 585655,
                "title": "python-solution-using-product",
                "content": "```\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n\\t\\tres = []\\n        for c in product(\\'abc\\', repeat=n):\\n            flag = True\\n            for i in range(1, len(c)):\\n\\t\\t\\t    # Check if c[i] is not equal c[i-1] as mentioned in the problem\\n                if c[i] == c[i-1]:\\n                    flag = False\\n            if flag:\\n                res.append(\\'\\'.join(f for f in c))\\n\\t\\t\\t\\t\\n\\t\\t# Check for boundary conditions\\n        if k > len(res):\\n            return \"\"\\n        else:\\n            return res[k-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n\\t\\tres = []\\n        for c in product(\\'abc\\', repeat=n):\\n            flag = True\\n            for i in range(1, len(c)):\\n\\t\\t\\t    # Check if c[i] is not equal c[i-1] as mentioned in the problem\\n                if c[i] == c[i-1]:\\n                    flag = False\\n            if flag:\\n                res.append(\\'\\'.join(f for f in c))\\n\\t\\t\\t\\t\\n\\t\\t# Check for boundary conditions\\n        if k > len(res):\\n            return \"\"\\n        else:\\n            return res[k-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 585584,
                "title": "c-simple-search-for-k-th-string-o-n",
                "content": "Here we always keep a count of strings starting with a, b, and c .i.e. `ca, cb, cc` respectively.\\nWe maintain these counts and for every index we see what character needs to come here. This is similar to dictionary idea.\\n```\\nclass Solution {\\npublic:\\n    int f(int n)\\n    {\\n        if(n == 0)\\n            return 0;\\n        if(n == 1)\\n            return 3;\\n        return 3 * pow(2, n - 1);\\n    }\\n    string getHappyString(int n, int k) {\\n        int c = f(n);\\n        if(c < k)\\n            return \"\";\\n        string s;\\n        int ca = pow(2, n - 1);\\n        int cb = 2*ca, cc = 3*ca;\\n        while(n--)\\n        {\\n            // cout << k << \" \";\\n            if(k <= ca)\\n            {\\n                s.push_back(\\'a\\');\\n            }\\n            else if(k <= cb)\\n            {\\n                if(s.empty())\\n                    k -= ca;\\n                else\\n                {\\n                    if(s.back() == \\'a\\')\\n                    {}\\n                    else\\n                        k -= ca;\\n                }\\n                s.push_back(\\'b\\');\\n            }\\n            else if(k <= cc)\\n            {\\n                if(s.empty())\\n                    k -= cb;\\n                else\\n                {\\n                    if(s.back() == \\'b\\')\\n                        k -= ca;\\n                    else\\n                        k -= cb;\\n                }\\n                s.push_back(\\'c\\');\\n            }\\n            if(s.back() == \\'a\\')\\n            {\\n                ca = 0;\\n                cb = pow(2, n - 1);\\n                cc = 2*cb;\\n            }\\n            else if(s.back() == \\'c\\')\\n            {\\n                ca = pow(2, n - 1);\\n                cb = 2*ca;\\n                cc = 0; \\n            }\\n            else if(s.back() == \\'b\\')\\n            {\\n                ca = pow(2, n - 1);\\n                cc = 2*ca;\\n                cb = 0; \\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int n)\\n    {\\n        if(n == 0)\\n            return 0;\\n        if(n == 1)\\n            return 3;\\n        return 3 * pow(2, n - 1);\\n    }\\n    string getHappyString(int n, int k) {\\n        int c = f(n);\\n        if(c < k)\\n            return \"\";\\n        string s;\\n        int ca = pow(2, n - 1);\\n        int cb = 2*ca, cc = 3*ca;\\n        while(n--)\\n        {\\n            // cout << k << \" \";\\n            if(k <= ca)\\n            {\\n                s.push_back(\\'a\\');\\n            }\\n            else if(k <= cb)\\n            {\\n                if(s.empty())\\n                    k -= ca;\\n                else\\n                {\\n                    if(s.back() == \\'a\\')\\n                    {}\\n                    else\\n                        k -= ca;\\n                }\\n                s.push_back(\\'b\\');\\n            }\\n            else if(k <= cc)\\n            {\\n                if(s.empty())\\n                    k -= cb;\\n                else\\n                {\\n                    if(s.back() == \\'b\\')\\n                        k -= ca;\\n                    else\\n                        k -= cb;\\n                }\\n                s.push_back(\\'c\\');\\n            }\\n            if(s.back() == \\'a\\')\\n            {\\n                ca = 0;\\n                cb = pow(2, n - 1);\\n                cc = 2*cb;\\n            }\\n            else if(s.back() == \\'c\\')\\n            {\\n                ca = pow(2, n - 1);\\n                cb = 2*ca;\\n                cc = 0; \\n            }\\n            else if(s.back() == \\'b\\')\\n            {\\n                ca = pow(2, n - 1);\\n                cc = 2*ca;\\n                cb = 0; \\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3856096,
                "title": "simple-intuitive-solution-with-no-backtracking-in-c",
                "content": "# Approach\\nWe have just mapped the string \"abc\" and traverse through every position so that to place appropriate letter at given word.\\n\\nWe can observe the pattern we will get after arranging in  lexicographically order. For example n = 4:\\n\\n<\"abab\", \"abac\", \"abca\", \"abcb\">, <\"acab\", \"acac\", \"acba\", \"acbc\">,\\n<\"baba\", \"babc\", \"baca\", \"bacb\">, <\"bcab\", \"bcac\", \"bcba\", \"bcbc\">,\\n<\"caba\", \"cabc\", \"caca\", \"cacb\">, <\"cbab\", \"cbac\", \"cbca\", \"cbcb\">\\n\\nWe can observw the pattern changing at 2\\'s power.\\n\\nWe are trying to get the index of the mapping which we could easily get by modulus of remainder with 2^(position) and if previously the letter has already taken then we will add one to answer to get next letter.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getHappyString(int n, int k) {\\n\\n        // Out of bound condition\\n        if(k>3*pow(2,n-1)) return \"\";\\n        string s = \"\";\\n        int prev = 4;\\n        string mapping = \"abc\";\\n\\n        int m = n - 1, i = k - 1;\\n        while(m >= 0){\\n            int power = pow(2, m);\\n            int q = i / power;\\n            i %= power;\\n            m -= 1;\\n\\n            if(prev <= q) q += 1;\\n            s += mapping[q];\\n            prev = q;\\n        }\\n        return s;\\n    }\\n};\\n```\\n\\n## !!! PLEASE UPVOTE !!!\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Brainteaser",
                    "Ordered Map",
                    "Suffix Array",
                    "Combinatorics",
                    "Interactive",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getHappyString(int n, int k) {\\n\\n        // Out of bound condition\\n        if(k>3*pow(2,n-1)) return \"\";\\n        string s = \"\";\\n        int prev = 4;\\n        string mapping = \"abc\";\\n\\n        int m = n - 1, i = k - 1;\\n        while(m >= 0){\\n            int power = pow(2, m);\\n            int q = i / power;\\n            i %= power;\\n            m -= 1;\\n\\n            if(prev <= q) q += 1;\\n            s += mapping[q];\\n            prev = q;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567912,
                "title": "java-easy-backtracking-runtime-2-ms-beats-78-5",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int cnt = 0;\\n    String res = \"\";\\n    public String getHappyString(int n, int k) {\\n        StringBuilder sb = new StringBuilder();\\n\\n        dfs(sb,n,k);\\n\\n        return res;\\n    }\\n    public void dfs(StringBuilder sb, int n,int k){\\n\\n        if (res.length() > 0) return;\\n\\n        if (sb.length() == n){\\n            cnt++;\\n            if (cnt == k) res = sb.toString();\\n            return;\\n        }\\n        char[] ch = {\\'a\\',\\'b\\',\\'c\\'};\\n\\n        for(char c : ch){\\n            if (sb.length() == 0 || sb.charAt(sb.length() - 1) != c){\\n                sb.append(c);\\n                dfs(sb,n,k);\\n                sb.deleteCharAt(sb.length() - 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int cnt = 0;\\n    String res = \"\";\\n    public String getHappyString(int n, int k) {\\n        StringBuilder sb = new StringBuilder();\\n\\n        dfs(sb,n,k);\\n\\n        return res;\\n    }\\n    public void dfs(StringBuilder sb, int n,int k){\\n\\n        if (res.length() > 0) return;\\n\\n        if (sb.length() == n){\\n            cnt++;\\n            if (cnt == k) res = sb.toString();\\n            return;\\n        }\\n        char[] ch = {\\'a\\',\\'b\\',\\'c\\'};\\n\\n        for(char c : ch){\\n            if (sb.length() == 0 || sb.charAt(sb.length() - 1) != c){\\n                sb.append(c);\\n                dfs(sb,n,k);\\n                sb.deleteCharAt(sb.length() - 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113562,
                "title": "simplest-solution-using-queue",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getHappyString(int n, int k) {\\n        //idea is to use queue data structure to store all the lexicographically sorted strig till length n & at last we will get the kth string if present else we will return empty string\\n\\n        queue<string>q;\\n        q.push(\"a\");\\n        q.push(\"b\");\\n        q.push(\"c\");\\n        while(q.front().length()<n){\\n            string temp=q.front();\\n            q.pop();\\n            if(temp[temp.length()-1]!=\\'a\\'){\\n                q.push(temp+\"a\");\\n            }\\n            if(temp[temp.length()-1]!=\\'b\\'){\\n                q.push(temp+\"b\");\\n            }\\n            if(temp[temp.length()-1]!=\\'c\\'){\\n                q.push(temp+\"c\");\\n            }\\n        }\\n\\n        string res=\"\";\\n        while(!q.empty() && k){\\n            if(k==1){\\n                res=q.front();break;\\n            }\\n            q.pop();\\n            k--;\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getHappyString(int n, int k) {\\n        //idea is to use queue data structure to store all the lexicographically sorted strig till length n & at last we will get the kth string if present else we will return empty string\\n\\n        queue<string>q;\\n        q.push(\"a\");\\n        q.push(\"b\");\\n        q.push(\"c\");\\n        while(q.front().length()<n){\\n            string temp=q.front();\\n            q.pop();\\n            if(temp[temp.length()-1]!=\\'a\\'){\\n                q.push(temp+\"a\");\\n            }\\n            if(temp[temp.length()-1]!=\\'b\\'){\\n                q.push(temp+\"b\");\\n            }\\n            if(temp[temp.length()-1]!=\\'c\\'){\\n                q.push(temp+\"c\");\\n            }\\n        }\\n\\n        string res=\"\";\\n        while(!q.empty() && k){\\n            if(k==1){\\n                res=q.front();break;\\n            }\\n            q.pop();\\n            k--;\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2605421,
                "title": "70-fast-easy-backtracking-python-solution-explained",
                "content": "For every recursive level we can choose [\\'a\\', \\'b\\', \\'c\\'] and append it to the current array only if either thr current array is empty or the last character in the array is not the same as the current character. \\n\\nSo we build the array and once the length of the array == n we add it to the final list. If the length of final list has reached k, we know we already have our result (the last item). In case the length of final res never reaches k, we send empty string.\\n\\nUpvote if you understood the approach :)\\n\\nIt can be optimized further if we only keep count of list size and not the entire final list, so it will consume less memory.\\n```\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n        res = []\\n        \\n        def solve(curr, n, k):\\n            if len(res) == k:\\n                return\\n            \\n            if len(curr) == n:\\n                res.append(\\'\\'.join(curr))\\n                return\\n                        \\n            for x in [\\'a\\', \\'b\\', \\'c\\']:    \\n                if not curr or curr[-1] != x:\\n                    curr.append(x)\\n                    solve(curr, n, k)\\n                    curr.pop()\\n        \\n        solve([], n, k)\\n        \\n        if len(res) < k:\\n            return \\'\\'\\n        \\n        return res[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n        res = []\\n        \\n        def solve(curr, n, k):\\n            if len(res) == k:\\n                return\\n            \\n            if len(curr) == n:\\n                res.append(\\'\\'.join(curr))\\n                return\\n                        \\n            for x in [\\'a\\', \\'b\\', \\'c\\']:    \\n                if not curr or curr[-1] != x:\\n                    curr.append(x)\\n                    solve(curr, n, k)\\n                    curr.pop()\\n        \\n        solve([], n, k)\\n        \\n        if len(res) < k:\\n            return \\'\\'\\n        \\n        return res[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2479436,
                "title": "c-easiest-one-without-storing-k-1-strings",
                "content": "```\\n\\tstring ans;\\n    void solve(int i, string &s, int &cn, int k, int n)\\n    {\\n        if(i == n)\\n        {\\n            cn++;\\n            if(cn == k) ans = s;\\n            return;\\n        }\\n        for(char j=\\'a\\';j!=\\'d\\';j++)\\n        {\\n            if(i>0 && s[i-1]==j) continue;\\n            \\n            s.push_back(j);\\n            solve(i+1, s, cn, k, n);\\n            s.pop_back();\\n        }\\n    }\\n    string getHappyString(int n, int k) {\\n        string s = \"\";\\n        int cn = 0;\\n        solve(0, s, cn, k, n);\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n\\tstring ans;\\n    void solve(int i, string &s, int &cn, int k, int n)\\n    {\\n        if(i == n)\\n        {\\n            cn++;\\n            if(cn == k) ans = s;\\n            return;\\n        }\\n        for(char j=\\'a\\';j!=\\'d\\';j++)\\n        {\\n            if(i>0 && s[i-1]==j) continue;\\n            \\n            s.push_back(j);\\n            solve(i+1, s, cn, k, n);\\n            s.pop_back();\\n        }\\n    }\\n    string getHappyString(int n, int k) {\\n        string s = \"\";\\n        int cn = 0;\\n        solve(0, s, cn, k, n);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2347865,
                "title": "c-backtracking-solution-optimised",
                "content": "\\t\\n\\t\\n\\tclass Solution {\\n\\t\\n\\tpublic:\\n\\t\\tvoid solve(int n,int &k,string &res,string str,string &op)\\n\\t\\t{\\n\\n\\t\\t\\tif(op.size()==n){\\n\\t\\t\\t\\tk--;\\n\\t\\t\\t\\tif(k==0){\\n\\t\\t\\t\\t\\tres=op;\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(op.size()>n)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tif(k==0)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tfor(int i=0;i<str.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(op.size()>0 and op.back()==str[i])\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\top.push_back(str[i]);\\n\\t\\t\\t\\tsolve(n,k,res,str,op);\\n\\t\\t\\t\\top.pop_back();\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\tstring getHappyString(int n, int k) {\\n\\n\\t\\t\\tstring res=\"\";\\n\\t\\t\\tstring str=\"abc\";\\n\\t\\t\\tstring op=\"\";\\n\\n\\t\\t\\tsolve(n,k,res,str,op);\\n\\t\\t\\treturn res;\\n\\t\\t}\\n};",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "class Solution {\\n\\t\\n\\tpublic:\\n\\t\\tvoid solve(int n,int &k,string &res,string str,string &op)\\n\\t\\t{\\n\\n\\t\\t\\tif(op.size()==n){\\n\\t\\t\\t\\tk--;\\n\\t\\t\\t\\tif(k==0){\\n\\t\\t\\t\\t\\tres=op;\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2213796,
                "title": "backtracking-c",
                "content": "class Solution {\\npublic:\\n    vector<string> happystring(int n)\\n    {\\n      if(n==1)\\n          return {\"a\",\"b\",\"c\"};\\n        \\n      vector<string> ans;\\n      vector<string> temp = happystring(n-1);\\n      \\n      for(int i=0;i<temp.size();i++)\\n      {\\n          string t1=temp[i];\\n          int a=t1.size();\\n          char ch=t1[a-1];\\n          \\n          if(ch == \\'a\\')\\n          {\\n              t1.push_back(\\'b\\');\\n              ans.push_back(t1);\\n              t1.pop_back();\\n              t1.push_back(\\'c\\');\\n              ans.push_back(t1);\\n              t1.pop_back();\\n          }\\n          else if(ch == \\'b\\')\\n          {\\n              t1.push_back(\\'a\\');\\n              ans.push_back(t1);\\n              t1.pop_back();\\n              t1.push_back(\\'c\\');\\n              ans.push_back(t1);\\n              t1.pop_back();\\n          }\\n          else\\n          {\\n              t1.push_back(\\'a\\');\\n              ans.push_back(t1);\\n              t1.pop_back();\\n              t1.push_back(\\'b\\');\\n              ans.push_back(t1);\\n              t1.pop_back();\\n          }\\n      }\\n        return ans;\\n        \\n    }\\n    string getHappyString(int n, int k) {\\n        vector<string> happy = happystring(n);\\n        sort(happy.begin(),happy.end());\\n        if(k>happy.size())\\n            return \"\";\\n        return happy[k-1];\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    vector<string> happystring(int n)\\n    {\\n      if(n==1)\\n          return {\"a\",\"b\",\"c\"}",
                "codeTag": "Java"
            },
            {
                "id": 2184620,
                "title": "java-tc-o-n-space-o-1-no-backtracking",
                "content": "```\\nclass Solution {\\n    public String getHappyString(int n, int k) {\\n        int total = 3*(int)Math.pow(2, n-1);\\n        if(k>total) return \"\";\\n        \\n        String res = \"\";\\n        for(int i=0; i<n; i++){\\n            int a = (int)Math.pow(2,n-i-1);\\n            \\n            if(i==0){\\n                if(k<=a) res+=\\'a\\';\\n                else if(k<=2*a) res+=\\'b\\';\\n                else res+=\\'c\\';\\n                \\n                if(k<=2*a && k>a) k-=a;\\n                else if(k>2*a) k-=2*a;\\n            }\\n            else{\\n                if(res.charAt(i-1)==\\'a\\'){\\n                    if(k<=a) res+=\\'b\\';\\n                    else res+=\\'c\\';\\n                }\\n                else if(res.charAt(i-1)==\\'b\\'){\\n                    if(k<=a) res+=\\'a\\';\\n                    else res+=\\'c\\';\\n                }\\n                else{\\n                    if(k<=a) res+=\\'a\\';\\n                    else res+=\\'b\\';\\n                }\\n                \\n                if(k>a && k<=2*a) k-=a;\\n                else if(k>2*a) k-=2*a;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String getHappyString(int n, int k) {\\n        int total = 3*(int)Math.pow(2, n-1);\\n        if(k>total) return \"\";\\n        \\n        String res = \"\";\\n        for(int i=0; i<n; i++){\\n            int a = (int)Math.pow(2,n-i-1);\\n            \\n            if(i==0){\\n                if(k<=a) res+=\\'a\\';\\n                else if(k<=2*a) res+=\\'b\\';\\n                else res+=\\'c\\';\\n                \\n                if(k<=2*a && k>a) k-=a;\\n                else if(k>2*a) k-=2*a;\\n            }\\n            else{\\n                if(res.charAt(i-1)==\\'a\\'){\\n                    if(k<=a) res+=\\'b\\';\\n                    else res+=\\'c\\';\\n                }\\n                else if(res.charAt(i-1)==\\'b\\'){\\n                    if(k<=a) res+=\\'a\\';\\n                    else res+=\\'c\\';\\n                }\\n                else{\\n                    if(k<=a) res+=\\'a\\';\\n                    else res+=\\'b\\';\\n                }\\n                \\n                if(k>a && k<=2*a) k-=a;\\n                else if(k>2*a) k-=2*a;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2126317,
                "title": "c-0-ms-solution-using-math",
                "content": "Here by p&c we can see their  can be 3* pow(2,n-1) valid strings as we have 3 options for 1st place and 2 options for all other places.\\nIn this code way is number of different happy strings can be made by n-1 sized string.\\n\\'\\'\\'class Solution {\\npublic:\\n    \\n    void formit(string &s,int n,int k){    //makes next part of the string of size n with lexographical position k\\n        if(n==0)\\n            return ;\\n        \\n        int way=pow(2,n-1);\\n        if(way>=k && k!=0){\\n            if(s[s.length()-1]==\\'a\\')\\n            s+=\\'b\\';\\n            else\\n            s+=\\'a\\';\\n        }\\n        else{\\n            if(s[s.length()-1]==\\'c\\')\\n            s+=\\'b\\';\\n            else\\n            s+=\\'c\\';\\n        }\\n\\n        formit(s,n-1,k%way);\\n        return;     \\n    }\\n    \\n    string getHappyString(int n, int k) {\\n        string s;\\n        int way=pow(2,n-1);\\n        \\n        if(k>3*way)\\n            return s;\\n        if(n==1){\\n            s+=\\'a\\'+k-1;\\n        return s;\\n        }\\n    \\n        if(k<=way)\\n            s+=\\'a\\';\\n        else if(k>way && k<=2*way)\\n            s+=\\'b\\';\\n        else\\n            s+=\\'c\\';\\n       \\n        formit(s,n-1,k%way);\\n        return s;\\n        \\n    }\\n};\\'\\'\\'\\nHope this helps",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    void formit(string &s,int n,int k){    //makes next part of the string of size n with lexographical position k\\n        if(n==0)\\n            return ;\\n        \\n        int way=pow(2,n-1);\\n        if(way>=k && k!=0){\\n            if(s[s.length()-1]==\\'a\\')\\n            s+=\\'b\\';\\n            else\\n            s+=\\'a\\';\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2121724,
                "title": "super-easy-self-explenatery",
                "content": "```\\nclass Solution {\\npublic:\\n    string ans;\\n    void f(int n,int &k,string &t,char pr_char = \\'5\\'){\\n        if(t.size() > n){\\n            return;\\n        }\\n        if(t.size() == n){\\n            k--;\\n            \\n            if(k == 0){\\n                ans = t;\\n                return;\\n            }\\n        }\\n        for(char c = \\'a\\'; c <=\\'c\\';c++){\\n            if(c!=pr_char){\\n                t.push_back(c);\\n                f(n,k,t,c);\\n                t.pop_back();\\n            }\\n        }\\n    }\\n    string getHappyString(int n, int k) {\\n        string t;\\n        f(n,k,t);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string ans;\\n    void f(int n,int &k,string &t,char pr_char = \\'5\\'){\\n        if(t.size() > n){\\n            return;\\n        }\\n        if(t.size() == n){\\n            k--;\\n            \\n            if(k == 0){\\n                ans = t;\\n                return;\\n            }\\n        }\\n        for(char c = \\'a\\'; c <=\\'c\\';c++){\\n            if(c!=pr_char){\\n                t.push_back(c);\\n                f(n,k,t,c);\\n                t.pop_back();\\n            }\\n        }\\n    }\\n    string getHappyString(int n, int k) {\\n        string t;\\n        f(n,k,t);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2118727,
                "title": "easy-explanations-intution",
                "content": "**!!!!Always think about the options we can take at a particular index in recursive problems**\\n1. string contains only [a, b, c] traverse through these as given in question\\n2. In string prev_character != curr_character so take all characters from start excluding current character, Why take characters from start ?? because we want Lexicographically sorted order make character array according to that array [c, a, b] will not work !!\\n3. We want kth string of \"n\" size so check on start if we get size == n, decrement \"k\".\\n4. Last step, if we got k == 0 after decrement, store it as ans and return. Also take care that string having size > n is of no use for us, So return from there also.\\n\\n```\\nclass Solution {\\npublic:\\n    string result;\\n    void f(int n, int &k, string &temp, char prev_char = \\'0\\') {\\n        //size > n of no use return\\n        if (temp.size() > n) return;\\n        \\n        //if found size == n decrement k and chk for k == 0\\n        if (temp.size() == n) {\\n            k --;\\n            if (k == 0) {\\n                result = temp;\\n                return;\\n            }\\n        }\\n        \\n        \\n        char options[] = {\\'a\\', \\'b\\', \\'c\\'};\\n        //traverse through evey option and take which is != prev_char\\n        for (char &ele : options) {\\n            if (ele != prev_char) {\\n                temp.push_back(ele);\\n                f (n, k, temp, ele);\\n                temp.pop_back();\\n            }\\n        }        \\n    }\\n    string getHappyString(int n, int k) {\\n        string temp;\\n        f(n, k, temp);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string result;\\n    void f(int n, int &k, string &temp, char prev_char = \\'0\\') {\\n        //size > n of no use return\\n        if (temp.size() > n) return;\\n        \\n        //if found size == n decrement k and chk for k == 0\\n        if (temp.size() == n) {\\n            k --;\\n            if (k == 0) {\\n                result = temp;\\n                return;\\n            }\\n        }\\n        \\n        \\n        char options[] = {\\'a\\', \\'b\\', \\'c\\'};\\n        //traverse through evey option and take which is != prev_char\\n        for (char &ele : options) {\\n            if (ele != prev_char) {\\n                temp.push_back(ele);\\n                f (n, k, temp, ele);\\n                temp.pop_back();\\n            }\\n        }        \\n    }\\n    string getHappyString(int n, int k) {\\n        string temp;\\n        f(n, k, temp);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2067805,
                "title": "java-with-tree-drawing-easy-dfs-backtracking-ttt-explained",
                "content": "![image](https://assets.leetcode.com/users/images/b8991de5-3de3-4568-bac2-deb8ac2bed54_1653334429.0760443.png)\\n\\n\\n```\\nclass Solution {\\n    \\n    List<String> res = new ArrayList<>();\\n    //to store all the happy strings\\n    public String getHappyString(int n, int k) {\\n        solve(n, new StringBuilder());\\n        \\n        Collections.sort(res);\\n        \\n        if(k > res.size())return \"\";\\n        return res.get(k-1);\\n    }\\n    \\n    public void solve(int len, StringBuilder ssf){\\n        \\n        if(ssf.length() == len){\\n            res.add(ssf.toString());\\n            return;\\n        }\\n        \\n        for(char ch = \\'a\\'; ch <= \\'c\\'; ++ch){\\n            if(ssf.length() > 0 && ssf.charAt(ssf.length() - 1) == ch)continue;\\n            ssf.append(ch);\\n            solve(len, ssf);\\n            ssf.deleteCharAt(ssf.length() - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    List<String> res = new ArrayList<>();\\n    //to store all the happy strings\\n    public String getHappyString(int n, int k) {\\n        solve(n, new StringBuilder());\\n        \\n        Collections.sort(res);\\n        \\n        if(k > res.size())return \"\";\\n        return res.get(k-1);\\n    }\\n    \\n    public void solve(int len, StringBuilder ssf){\\n        \\n        if(ssf.length() == len){\\n            res.add(ssf.toString());\\n            return;\\n        }\\n        \\n        for(char ch = \\'a\\'; ch <= \\'c\\'; ++ch){\\n            if(ssf.length() > 0 && ssf.charAt(ssf.length() - 1) == ch)continue;\\n            ssf.append(ch);\\n            solve(len, ssf);\\n            ssf.deleteCharAt(ssf.length() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2007011,
                "title": "easy-simple-o-1-space-c-solution",
                "content": "```\\nclass Solution{\\n    public:\\n        string generateAllHappyStrings(string str, int n, int &k){\\n            if (n == 0){\\n                k--;\\n                if(k == 0)return str;\\n                return \"\";\\n            }\\n            for (int i = 0; i < 3; i++)\\n                if (!str.length() || str.back() != (\\'a\\' + i)){\\n                    string res = generateAllHappyStrings(str + char(\\'a\\' + i), n - 1, k);\\n                    if(res.length()>0)return res;\\n                }\\n            return \"\";\\n        }\\n        string getHappyString(int n, int k){\\n            return generateAllHappyStrings(\"\", n, k);\\n        }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution{\\n    public:\\n        string generateAllHappyStrings(string str, int n, int &k){\\n            if (n == 0){\\n                k--;\\n                if(k == 0)return str;\\n                return \"\";\\n            }\\n            for (int i = 0; i < 3; i++)\\n                if (!str.length() || str.back() != (\\'a\\' + i)){\\n                    string res = generateAllHappyStrings(str + char(\\'a\\' + i), n - 1, k);\\n                    if(res.length()>0)return res;\\n                }\\n            return \"\";\\n        }\\n        string getHappyString(int n, int k){\\n            return generateAllHappyStrings(\"\", n, k);\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967806,
                "title": "c-simple-backtracking-constraints-were-low-simple-brute-approach-worked",
                "content": "**Solution 1: Using the ans vector of string to store each string we generate in the whole journey**\\n```\\nclass Solution {\\npublic:\\n    \\n    void func(int n, string str, vector<string>&ans){\\n        if(str.size() == n){\\n            ans.push_back(str);\\n            return;\\n        }\\n        \\n        for(int i = 0; i<3;i++){\\n            if(str.empty()==false and \\'a\\'+i == str.back()){\\n                continue;\\n            }\\n            else{\\n                str.push_back(\\'a\\'+i);\\n                func(n, str, ans);\\n                str.pop_back();\\n            }\\n        }\\n    }\\n    \\n    string getHappyString(int n, int k) {\\n        vector<string>ans;\\n        string str;\\n        func(n, str,ans);\\n        \\n        if(ans.size()>=k){\\n            return ans[k-1];\\n        }\\n        \\n        return \"\";\\n    }\\n};\\n```\\n\\n**Solution 2: When we hit an answer we reduce the k by 1 and when k == 0, we have our result and we store it into result string**\\n```\\nclass Solution {\\npublic:\\n    \\n    void func(int n, string str, string &res, int &k){\\n        if(str.size() == n){\\n            k--;\\n            if(k==0){\\n                res = str;\\n            }\\n            return;\\n        }\\n        \\n        if(k == 0){\\n            return;\\n        }\\n        \\n        for(int i = 0; i<3;i++){\\n            if(str.empty()==false and \\'a\\'+i == str.back()){\\n                continue;\\n            }\\n            else{\\n                str.push_back(\\'a\\'+i);\\n                func(n, str, res, k);\\n                str.pop_back();\\n            }\\n        }\\n    }\\n    \\n    string getHappyString(int n, int k) {\\n        string res = \"\";\\n        string str;\\n        func(n, str,res, k);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void func(int n, string str, vector<string>&ans){\\n        if(str.size() == n){\\n            ans.push_back(str);\\n            return;\\n        }\\n        \\n        for(int i = 0; i<3;i++){\\n            if(str.empty()==false and \\'a\\'+i == str.back()){\\n                continue;\\n            }\\n            else{\\n                str.push_back(\\'a\\'+i);\\n                func(n, str, ans);\\n                str.pop_back();\\n            }\\n        }\\n    }\\n    \\n    string getHappyString(int n, int k) {\\n        vector<string>ans;\\n        string str;\\n        func(n, str,ans);\\n        \\n        if(ans.size()>=k){\\n            return ans[k-1];\\n        }\\n        \\n        return \"\";\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    void func(int n, string str, string &res, int &k){\\n        if(str.size() == n){\\n            k--;\\n            if(k==0){\\n                res = str;\\n            }\\n            return;\\n        }\\n        \\n        if(k == 0){\\n            return;\\n        }\\n        \\n        for(int i = 0; i<3;i++){\\n            if(str.empty()==false and \\'a\\'+i == str.back()){\\n                continue;\\n            }\\n            else{\\n                str.push_back(\\'a\\'+i);\\n                func(n, str, res, k);\\n                str.pop_back();\\n            }\\n        }\\n    }\\n    \\n    string getHappyString(int n, int k) {\\n        string res = \"\";\\n        string str;\\n        func(n, str,res, k);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1900374,
                "title": "easiest-backtracking-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    void check(int n, vector <char> &init, char prevchar, vector <string> &v, string temp)\\n    {\\n        if( n == 0)\\n        {\\n            v.push_back(temp);\\n            return;\\n        }\\n        for(int i = 0; i < init.size(); ++i)\\n        {\\n            if(prevchar != init[i])\\n            {\\n                temp.push_back(init[i]);\\n                char tempchar = init[i];\\n                check(n - 1, init, tempchar, v, temp);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    string getHappyString(int n, int k) {\\n        vector <string> v;\\n        vector <char> init{\\'a\\', \\'b\\', \\'c\\'};\\n        check(n, init, \\' \\', v, \"\");\\n        return v.size() >= k? v[k - 1] : \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void check(int n, vector <char> &init, char prevchar, vector <string> &v, string temp)\\n    {\\n        if( n == 0)\\n        {\\n            v.push_back(temp);\\n            return;\\n        }\\n        for(int i = 0; i < init.size(); ++i)\\n        {\\n            if(prevchar != init[i])\\n            {\\n                temp.push_back(init[i]);\\n                char tempchar = init[i];\\n                check(n - 1, init, tempchar, v, temp);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    string getHappyString(int n, int k) {\\n        vector <string> v;\\n        vector <char> init{\\'a\\', \\'b\\', \\'c\\'};\\n        check(n, init, \\' \\', v, \"\");\\n        return v.size() >= k? v[k - 1] : \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1821589,
                "title": "simple-o-n-time-and-o-1-space-c-solution",
                "content": "```\\n\\nclass Solution\\n{\\n    public:\\n    \\n    char lef(char ch){\\n        \\n        if(ch==\\'a\\') return \\'b\\';\\n        else return \\'a\\';\\n        \\n    }\\n    \\n    char rig(char ch){\\n        \\n        if(ch==\\'c\\') return \\'b\\';\\n        else return \\'c\\';\\n        \\n    }\\n    \\n        string getHappyString(int n, int k)\\n        {\\n\\n            if (k > 3 *(1 << (n - 1))) return \"\";\\n\\n            string ans = \"\";\\n\\n            int part = (1 << (n - 1));\\n            int l,r;\\n            \\n            if (k <= part){\\n                ans += \"a\";\\n                l = 1, r = part;\\n            }\\n            else if (k > part && k <= 2 *part)\\n            {\\n                ans += \"b\";\\n                l = part+1,r = 2*part;\\n                \\n            }\\n            else\\n            {\\n                ans += \"c\";\\n                l = 2*part+1,r = 3*part;\\n            }\\n            \\n            \\n            for(int i=0;i<n-1;i++){\\n                \\n                int tot = r-l+1;\\n                tot/=2;\\n                int nl = l , nr = (l+tot-1);\\n                if(k>=nl && k<=nr){\\n                    \\n                    ans.push_back(lef(ans[i]));\\n                    r = nr;\\n                    \\n                }else{\\n                    l = (l+tot);\\n                    ans.push_back(rig(ans[i]));\\n                }\\n                \\n            }\\n            \\n            return ans;\\n            \\n            \\n        }\\n};\\n\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\n\\nclass Solution\\n{\\n    public:\\n    \\n    char lef(char ch){\\n        \\n        if(ch==\\'a\\') return \\'b\\';\\n        else return \\'a\\';\\n        \\n    }\\n    \\n    char rig(char ch){\\n        \\n        if(ch==\\'c\\') return \\'b\\';\\n        else return \\'c\\';\\n        \\n    }\\n    \\n        string getHappyString(int n, int k)\\n        {\\n\\n            if (k > 3 *(1 << (n - 1))) return \"\";\\n\\n            string ans = \"\";\\n\\n            int part = (1 << (n - 1));\\n            int l,r;\\n            \\n            if (k <= part){\\n                ans += \"a\";\\n                l = 1, r = part;\\n            }\\n            else if (k > part && k <= 2 *part)\\n            {\\n                ans += \"b\";\\n                l = part+1,r = 2*part;\\n                \\n            }\\n            else\\n            {\\n                ans += \"c\";\\n                l = 2*part+1,r = 3*part;\\n            }\\n            \\n            \\n            for(int i=0;i<n-1;i++){\\n                \\n                int tot = r-l+1;\\n                tot/=2;\\n                int nl = l , nr = (l+tot-1);\\n                if(k>=nl && k<=nr){\\n                    \\n                    ans.push_back(lef(ans[i]));\\n                    r = nr;\\n                    \\n                }else{\\n                    l = (l+tot);\\n                    ans.push_back(rig(ans[i]));\\n                }\\n                \\n            }\\n            \\n            return ans;\\n            \\n            \\n        }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1809156,
                "title": "easiest-backtracking-solution",
                "content": "class Solution {\\n```\\nvector<string>res;\\n```\\npublic:\\n```\\n    void backtracking(string &a,int n,vector<char>og)\\n    {\\n        if(a.size()==n)\\n        {res.push_back(a);\\n         return;}\\n        for(int i=0;i<og.size();i++)\\n        {\\n            if(a.back()!=og[i])\\n            {\\n                a.push_back(og[i]);\\n                backtracking(a,n,og);\\n                a.pop_back();\\n            }\\n        }\\n    }\\n    string getHappyString(int n, int k) {\\n        string a=\"\";\\n        vector<char>og;\\n        og.push_back(\\'a\\');\\n        og.push_back(\\'b\\');\\n        og.push_back(\\'c\\');\\n        backtracking(a,n,og);\\n        sort(res.begin(),res.end());\\n        string ans=\"\";\\n        if(k>res.size())\\n            return ans;\\n        return res[k-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nvector<string>res;\\n```\n```\\n    void backtracking(string &a,int n,vector<char>og)\\n    {\\n        if(a.size()==n)\\n        {res.push_back(a);\\n         return;}\\n        for(int i=0;i<og.size();i++)\\n        {\\n            if(a.back()!=og[i])\\n            {\\n                a.push_back(og[i]);\\n                backtracking(a,n,og);\\n                a.pop_back();\\n            }\\n        }\\n    }\\n    string getHappyString(int n, int k) {\\n        string a=\"\";\\n        vector<char>og;\\n        og.push_back(\\'a\\');\\n        og.push_back(\\'b\\');\\n        og.push_back(\\'c\\');\\n        backtracking(a,n,og);\\n        sort(res.begin(),res.end());\\n        string ans=\"\";\\n        if(k>res.size())\\n            return ans;\\n        return res[k-1];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1798662,
                "title": "0ms-c-solution-by-bitwise-operation",
                "content": "Not very obvious, but fast. \\n```\\nchar * getHappyString(int n, int k){\\n    char* s = (char*)malloc(n+1);\\n    int l = 3<<(n-1); //how many different happy strings\\n    \\n    if(k>l){\\n        s[0] = 0;\\n        return s;\\n    }\\n    //if k is more than l, return \"\"\\n    \\n    k--; \\n    s[0] = \\'a\\' + (k>>(n-1));\\n    //first two bits represents the first character 00 = \\'a\\' 01 = \\'b\\' 10 = \\'c\\' \\n    //not possible to be 11, or it will be k > l\\n    \\n    //with the previous character, each following bit of k-1 can be convert into certain character\\n    for(int i = 1; i<n;i++)\\n    {\\n        s[i] = k>>(n-i-1) & 1;\\n        if(s[i-1] == \\'a\\')\\n        {\\n            if (s[i] == 0) s[i] =\\'b\\';\\n            if (s[i] == 1) s[i] =\\'c\\';\\n        }\\n        else if(s[i-1] == \\'b\\')\\n        {\\n            if (s[i] == 0) s[i] =\\'a\\';\\n            if (s[i] == 1) s[i] =\\'c\\';\\n        }\\n        else\\n        {\\n            if (s[i] == 0) s[i] =\\'a\\';\\n            if (s[i] == 1) s[i] =\\'b\\';\\n        }\\n    }\\n    s[n] = 0;//end the string\\n    return s;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nchar * getHappyString(int n, int k){\\n    char* s = (char*)malloc(n+1);\\n    int l = 3<<(n-1); //how many different happy strings\\n    \\n    if(k>l){\\n        s[0] = 0;\\n        return s;\\n    }\\n    //if k is more than l, return \"\"\\n    \\n    k--; \\n    s[0] = \\'a\\' + (k>>(n-1));\\n    //first two bits represents the first character 00 = \\'a\\' 01 = \\'b\\' 10 = \\'c\\' \\n    //not possible to be 11, or it will be k > l\\n    \\n    //with the previous character, each following bit of k-1 can be convert into certain character\\n    for(int i = 1; i<n;i++)\\n    {\\n        s[i] = k>>(n-i-1) & 1;\\n        if(s[i-1] == \\'a\\')\\n        {\\n            if (s[i] == 0) s[i] =\\'b\\';\\n            if (s[i] == 1) s[i] =\\'c\\';\\n        }\\n        else if(s[i-1] == \\'b\\')\\n        {\\n            if (s[i] == 0) s[i] =\\'a\\';\\n            if (s[i] == 1) s[i] =\\'c\\';\\n        }\\n        else\\n        {\\n            if (s[i] == 0) s[i] =\\'a\\';\\n            if (s[i] == 1) s[i] =\\'b\\';\\n        }\\n    }\\n    s[n] = 0;//end the string\\n    return s;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1659494,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    List<String> list = new ArrayList<>();\\n\\tpublic void formStrings(char arr[],int n,String current) {\\n\\t\\tif(current.length() == n) {\\n\\t\\t\\tlist.add(current);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tfor(int i =0;i<arr.length;i++)\\n\\t\\t{\\n\\t\\t\\tif(current.length()!=0 && current.charAt(current.length()-1) == arr[i])\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\telse {\\n\\t\\t\\t\\tcurrent += arr[i];\\n\\t\\t\\t\\tformStrings(arr,n,current);\\n\\t\\t\\t\\tcurrent = current.substring(0,current.length()-1);\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t}\\n\\t}\\n\\tpublic String getHappyString(int n, int k) {\\n        if(k > (int)3 * Math.pow(2, n - 1)) {\\n            return \"\";\\n        }\\n\\t\\tchar arr[] = {\\'a\\',\\'b\\',\\'c\\'};\\n\\t\\t// forming all the strings of length n\\n\\t\\tformStrings(arr,n,\"\");\\n\\t\\tint x = 0;\\n\\t\\tString output[] = new String[list.size()];\\n\\t\\tfor(String i:list)output[x++] = i;\\n        \\n\\t\\tArrays.sort(output);\\n\\t\\tSystem.out.println(list);\\n        return output[k-1];\\n\\t    }\\n}\\n\\n\\n    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    List<String> list = new ArrayList<>();\\n\\tpublic void formStrings(char arr[],int n,String current) {\\n\\t\\tif(current.length() == n) {\\n\\t\\t\\tlist.add(current);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tfor(int i =0;i<arr.length;i++)\\n\\t\\t{\\n\\t\\t\\tif(current.length()!=0 && current.charAt(current.length()-1) == arr[i])\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\telse {\\n\\t\\t\\t\\tcurrent += arr[i];\\n\\t\\t\\t\\tformStrings(arr,n,current);\\n\\t\\t\\t\\tcurrent = current.substring(0,current.length()-1);\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t}\\n\\t}\\n\\tpublic String getHappyString(int n, int k) {\\n        if(k > (int)3 * Math.pow(2, n - 1)) {\\n            return \"\";\\n        }\\n\\t\\tchar arr[] = {\\'a\\',\\'b\\',\\'c\\'};\\n\\t\\t// forming all the strings of length n\\n\\t\\tformStrings(arr,n,\"\");\\n\\t\\tint x = 0;\\n\\t\\tString output[] = new String[list.size()];\\n\\t\\tfor(String i:list)output[x++] = i;\\n        \\n\\t\\tArrays.sort(output);\\n\\t\\tSystem.out.println(list);\\n        return output[k-1];\\n\\t    }\\n}\\n\\n\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1641674,
                "title": "java-easy-solution-1-ms-time-complexity-o-n",
                "content": "```\\nclass Solution {\\n    public String getHappyString(int n, int k) {\\n        int total=3*(int)(Math.pow(2,n-1));\\n        if(k>total){\\n            return \"\";\\n        }\\n        StringBuilder str=new StringBuilder();\\n        int rangeLength=total/3;\\n        int start=0;\\n        k--;\\n        if( k <= rangeLength-1 && k>=0){\\n            str.append(\\'a\\');\\n            start=0;\\n        }else if( k>=rangeLength && k<= 2*rangeLength-1 ){\\n            str.append(\\'b\\');\\n            start=rangeLength;\\n        }else{\\n            str.append(\\'c\\');\\n            start=rangeLength*2;\\n        } \\n        \\n        if(n==1){\\n            return str.toString();\\n        }\\n        \\n        while(str.length()<n){\\n            rangeLength/=2;\\n            if(k<=(start+rangeLength-1) &&  k>=start){\\n                if(str.charAt(str.length()-1)==\\'a\\'){\\n                    str.append(\\'b\\');\\n                }else if(str.charAt(str.length()-1)==\\'b\\'){\\n                    str.append(\\'a\\');\\n                }else{\\n                    str.append(\\'a\\');\\n                }\\n            }else if(k<=(start+(2*rangeLength)-1)  && k>=(start+rangeLength)){\\n                if(str.charAt(str.length()-1)==\\'a\\'){\\n                    str.append(\\'c\\');\\n                }else if(str.charAt(str.length()-1)==\\'b\\'){\\n                    str.append(\\'c\\');\\n                }else{\\n                    str.append(\\'b\\');\\n                }\\n                start+=rangeLength;\\n            }\\n        }\\n        \\n        return str.toString();\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String getHappyString(int n, int k) {\\n        int total=3*(int)(Math.pow(2,n-1));\\n        if(k>total){\\n            return \"\";\\n        }\\n        StringBuilder str=new StringBuilder();\\n        int rangeLength=total/3;\\n        int start=0;\\n        k--;\\n        if( k <= rangeLength-1 && k>=0){\\n            str.append(\\'a\\');\\n            start=0;\\n        }else if( k>=rangeLength && k<= 2*rangeLength-1 ){\\n            str.append(\\'b\\');\\n            start=rangeLength;\\n        }else{\\n            str.append(\\'c\\');\\n            start=rangeLength*2;\\n        } \\n        \\n        if(n==1){\\n            return str.toString();\\n        }\\n        \\n        while(str.length()<n){\\n            rangeLength/=2;\\n            if(k<=(start+rangeLength-1) &&  k>=start){\\n                if(str.charAt(str.length()-1)==\\'a\\'){\\n                    str.append(\\'b\\');\\n                }else if(str.charAt(str.length()-1)==\\'b\\'){\\n                    str.append(\\'a\\');\\n                }else{\\n                    str.append(\\'a\\');\\n                }\\n            }else if(k<=(start+(2*rangeLength)-1)  && k>=(start+rangeLength)){\\n                if(str.charAt(str.length()-1)==\\'a\\'){\\n                    str.append(\\'c\\');\\n                }else if(str.charAt(str.length()-1)==\\'b\\'){\\n                    str.append(\\'c\\');\\n                }else{\\n                    str.append(\\'b\\');\\n                }\\n                start+=rangeLength;\\n            }\\n        }\\n        \\n        return str.toString();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1628379,
                "title": "java-o-n-solution-easy-to-understand-code",
                "content": "\\n\\'\\'\\'\\n   public String getHappyString(int n, int k) {\\n    \\n         int prem =1;\\n\\t\\t  \\n\\t\\t  for(int i=1;i<n;i++)\\n\\t\\t  {\\n\\t\\t\\t  prem=prem*2;\\n\\t\\t  }\\n    \\n         if (k > 3 * prem)return \"\";\\n            \\n           k = k-1; \\n        \\n        int ch = \\'a\\' + (k) / prem;\\n        \\n        char c= (char)ch;\\n    \\n        StringBuilder sb = new StringBuilder(c+\"\");\\n        \\n      while (prem > 1) {\\n        k = (k) % prem;\\n        prem = prem/2;\\n          \\n        ch = (k) / prem == 0 ? \\'a\\' + (ch == \\'a\\' ? 1 : 0) : \\'b\\' + (ch != \\'c\\' ? 1 : 0);\\n        \\n          sb.append((char)ch);\\n          }\\n        \\n    return sb.toString();\\n   \\n    }\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\n\\'\\'\\'\\n   public String getHappyString(int n, int k) {\\n    \\n         int prem =1;\\n\\t\\t  \\n\\t\\t  for(int i=1;i<n;i++)\\n\\t\\t  {\\n\\t\\t\\t  prem=prem*2;\\n\\t\\t  }\\n    \\n         if (k > 3 * prem)return \"\";\\n            \\n           k = k-1; \\n        \\n        int ch = \\'a\\' + (k) / prem;\\n        \\n        char c= (char)ch;\\n    \\n        StringBuilder sb = new StringBuilder(c+\"\");\\n        \\n      while (prem > 1) {\\n        k = (k) % prem;\\n        prem = prem/2;\\n          \\n        ch = (k) / prem == 0 ? \\'a\\' + (ch == \\'a\\' ? 1 : 0) : \\'b\\' + (ch != \\'c\\' ? 1 : 0);\\n        \\n          sb.append((char)ch);\\n          }\\n        \\n    return sb.toString();\\n   \\n    }\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1623924,
                "title": "c-backtracking-with-pruning-easy-to-understand-0-ms-beats-100",
                "content": "Basically you have to iterate over all the valid happy strings of length N and return the Kth string.\\n\\nThis is my backtracking solution - \\n\\n```\\nclass Solution {\\npublic:\\n    char arr[3] = {\\'a\\', \\'b\\', \\'c\\'};\\n    vector<string>res;\\n    \\n    void generate(int n, int k, string s, int prev){\\n        if(s.size() > n) return;\\n        if(s.size() == n){\\n            res.push_back(s);\\n            return;\\n        }\\n        for(int i=0; i<3 && res.size()<k; i++){\\n            if(i!=prev){\\n                generate(n, k, s+arr[i], i);\\n            }\\n        }\\n    }\\n    \\n    string getHappyString(int n, int k) {\\n        generate(n, k, \"\", -1);\\n        return res.size()>=k ? res[k-1] : \"\";\\n    }\\n};\\n```\\n\\n\\nSpace optimised solution - \\n\\n```\\nclass Solution {\\npublic:\\n    char arr[3] = {\\'a\\', \\'b\\', \\'c\\'};\\n    string res = \"\";\\n    int global;\\n    \\n    void generate(int n, string s, int prev){\\n        if(s.size() > n) return;\\n        if(s.size() == n){\\n            global--;\\n            res = s; return;\\n        }\\n        for(int i=0; i<3 && global; i++){\\n            if(i!=prev) generate(n, s+arr[i], i);\\n        }\\n    }\\n    \\n    string getHappyString(int n, int k) {\\n        global = k;\\n        generate(n, \"\", -1);\\n        return global == 0 ? res : \"\";\\n    }\\n};\\n```\\n\\nThanks for reading \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char arr[3] = {\\'a\\', \\'b\\', \\'c\\'};\\n    vector<string>res;\\n    \\n    void generate(int n, int k, string s, int prev){\\n        if(s.size() > n) return;\\n        if(s.size() == n){\\n            res.push_back(s);\\n            return;\\n        }\\n        for(int i=0; i<3 && res.size()<k; i++){\\n            if(i!=prev){\\n                generate(n, k, s+arr[i], i);\\n            }\\n        }\\n    }\\n    \\n    string getHappyString(int n, int k) {\\n        generate(n, k, \"\", -1);\\n        return res.size()>=k ? res[k-1] : \"\";\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    char arr[3] = {\\'a\\', \\'b\\', \\'c\\'};\\n    string res = \"\";\\n    int global;\\n    \\n    void generate(int n, string s, int prev){\\n        if(s.size() > n) return;\\n        if(s.size() == n){\\n            global--;\\n            res = s; return;\\n        }\\n        for(int i=0; i<3 && global; i++){\\n            if(i!=prev) generate(n, s+arr[i], i);\\n        }\\n    }\\n    \\n    string getHappyString(int n, int k) {\\n        global = k;\\n        generate(n, \"\", -1);\\n        return global == 0 ? res : \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1607700,
                "title": "simple-c-solution-0-ms-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    string ans;\\n    \\n    void solve(int n, int &k, string asf){\\n        \\n        if(k<0)\\n            return;\\n        \\n        if(asf.size()==n){\\n            \\n            k--;\\n            if(k == 0)\\n                ans = asf;\\n            \\n            return ;\\n        }\\n        \\n        if(asf.size() == 0){\\n            \\n            solve(n,k,asf+\\'a\\');\\n            solve(n,k,asf+\\'b\\');\\n            solve(n,k,asf+\\'c\\');\\n        \\n        }else{\\n            \\n            int m = asf.size();\\n            \\n            if(\\'a\\'!=asf[m-1]){\\n                solve(n,k,asf+\\'a\\');\\n            }\\n            \\n            if(\\'b\\'!=asf[m-1]){\\n                solve(n,k,asf+\\'b\\');\\n            }\\n            \\n            if(\\'c\\'!=asf[m-1]){\\n                solve(n,k,asf+\\'c\\');\\n            }\\n            \\n        }\\n    }\\n    \\n    string getHappyString(int n, int k) {\\n        \\n        solve(n,k,\"\");\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string ans;\\n    \\n    void solve(int n, int &k, string asf){\\n        \\n        if(k<0)\\n            return;\\n        \\n        if(asf.size()==n){\\n            \\n            k--;\\n            if(k == 0)\\n                ans = asf;\\n            \\n            return ;\\n        }\\n        \\n        if(asf.size() == 0){\\n            \\n            solve(n,k,asf+\\'a\\');\\n            solve(n,k,asf+\\'b\\');\\n            solve(n,k,asf+\\'c\\');\\n        \\n        }else{\\n            \\n            int m = asf.size();\\n            \\n            if(\\'a\\'!=asf[m-1]){\\n                solve(n,k,asf+\\'a\\');\\n            }\\n            \\n            if(\\'b\\'!=asf[m-1]){\\n                solve(n,k,asf+\\'b\\');\\n            }\\n            \\n            if(\\'c\\'!=asf[m-1]){\\n                solve(n,k,asf+\\'c\\');\\n            }\\n            \\n        }\\n    }\\n    \\n    string getHappyString(int n, int k) {\\n        \\n        solve(n,k,\"\");\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1528146,
                "title": "easy-to-understand",
                "content": "```\\nclass Solution:\\n    def helper(self,s , l , letters , n ):\\n        if(len(s) == n):\\n            l.append(s)\\n            return 0\\n        for i in letters :\\n            if(s[-1] != i ):\\n                self.helper(s + i , l , letters , n)\\n            \\n        \\n            \\n    def getHappyString(self, n: int, k: int) -> str:\\n        letters = [\"a\" , \"b\" , \"c\"]\\n        l = []\\n        for i in letters :\\n            self.helper(i,l,letters , n)\\n            if(len(l) >= k):\\n                return l[k-1]\\n        return \"\"       \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def helper(self,s , l , letters , n ):\\n        if(len(s) == n):\\n            l.append(s)\\n            return 0\\n        for i in letters :\\n            if(s[-1] != i ):\\n                self.helper(s + i , l , letters , n)\\n            \\n        \\n            \\n    def getHappyString(self, n: int, k: int) -> str:\\n        letters = [\"a\" , \"b\" , \"c\"]\\n        l = []\\n        for i in letters :\\n            self.helper(i,l,letters , n)\\n            if(len(l) >= k):\\n                return l[k-1]\\n        return \"\"       \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1518462,
                "title": "easy-c-solution-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    set<string> ss;\\n    string getHappyString(int n, int k) {\\n         solve(0,n,\"\",k);\\n         for(string s : ss) {\\n             k--;\\n             if(k==0) return s;\\n         }\\n        return \"\";\\n    }\\n    void solve(int pos,int n,string path,int k) {\\n        if(pos>=n) {\\n            ss.insert(path);\\n            path.clear();\\n            return;\\n        }\\n        if(ss.size()>=k) return;\\n        for(int i=pos; i<n; i++) {\\n            for(char ch=\\'a\\'; ch<=\\'c\\'; ch++) {\\n                 if(path.empty() || path.back()!=ch) {\\n                     path+=ch;\\n                     solve(pos+1,n,path,k);\\n                     path.pop_back();\\n                 }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    set<string> ss;\\n    string getHappyString(int n, int k) {\\n         solve(0,n,\"\",k);\\n         for(string s : ss) {\\n             k--;\\n             if(k==0) return s;\\n         }\\n        return \"\";\\n    }\\n    void solve(int pos,int n,string path,int k) {\\n        if(pos>=n) {\\n            ss.insert(path);\\n            path.clear();\\n            return;\\n        }\\n        if(ss.size()>=k) return;\\n        for(int i=pos; i<n; i++) {\\n            for(char ch=\\'a\\'; ch<=\\'c\\'; ch++) {\\n                 if(path.empty() || path.back()!=ch) {\\n                     path+=ch;\\n                     solve(pos+1,n,path,k);\\n                     path.pop_back();\\n                 }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1497221,
                "title": "c-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    set<string>s;\\n    void solve(char a , string t , int l,int n)\\n    {\\n        // base case\\n        if(l == n)\\n        {\\n            s.insert(t);\\n            return;\\n        }\\n        if(t.back()!=\\'a\\')\\n            solve(a,t+\"a\" , l+1,n);\\n        if(t.back()!=\\'b\\')\\n            solve(a,t+\"b\",l+1,n);\\n        if(t.back()!=\\'c\\')\\n            solve(a,t+\"c\",l+1,n);\\n        \\n        //backtrack\\n        t.pop_back();\\n    }\\n    string getHappyString(int n, int k) {\\n        \\n        for(char a = \\'a\\' ; a <= \\'c\\';a++){\\n            string t = string(1,a);\\n            //cout<<t;\\n            solve(a , t , 1,n);\\n            }\\n        if(k > s.size())\\n            return \"\";\\n        string ans;\\n        int u = 0 ; \\n        for(auto i : s)\\n        {\\n            u++;\\n            if(u == k)\\n            {\\n                ans = i ; \\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    set<string>s;\\n    void solve(char a , string t , int l,int n)\\n    {\\n        // base case\\n        if(l == n)\\n        {\\n            s.insert(t);\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1474243,
                "title": "python-3-backtracking-self-explanatory-easy-understading",
                "content": "```\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n        res=[]\\n        inp_string=[\\'a\\',\\'b\\',\\'c\\']\\n   \\n        def happy_string(index,string):\\n            if len(string)==n:\\n                res.append(string)\\n                return\\n            for i in range(len(inp_string)):\\n                if len(string)==0:\\n                    happy_string(i,string+inp_string[i])\\n                else:\\n                    if string[-1]==inp_string[i]:\\n                        continue\\n                    happy_string(i,string+inp_string[i])\\n           \\n        happy_string(0,\\'\\')\\n        if k<=len(res):\\n            return res[k-1]\\n        else:\\n            return \\'\\'\\n            \\n```\\n\\n\\n***Please do upvote if you found my solution helpful :)***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n        res=[]\\n        inp_string=[\\'a\\',\\'b\\',\\'c\\']\\n   \\n        def happy_string(index,string):\\n            if len(string)==n:\\n                res.append(string)\\n                return\\n            for i in range(len(inp_string)):\\n                if len(string)==0:\\n                    happy_string(i,string+inp_string[i])\\n                else:\\n                    if string[-1]==inp_string[i]:\\n                        continue\\n                    happy_string(i,string+inp_string[i])\\n           \\n        happy_string(0,\\'\\')\\n        if k<=len(res):\\n            return res[k-1]\\n        else:\\n            return \\'\\'\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1469282,
                "title": "mathematical-solution-running-in-o-n-100-speed-90-memory-c",
                "content": "for a given (n,k) , 3*(2^(n-1)) combinations are possible.\\n2^(n-1) for each character.\\n\\nnow if k is 1 <= k <= 2^(n-1) then first char is a\\nk is 2^(n-1) < k <= 2*2^(n-1) then first char is b\\nk is 22^(n-1) < k <= 32^(n-1) then first char is c \\n\\nthen I recursively sent the function to calculate other possible combinations with the updated k, while tracking prev char\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    string getAns(int n, int k, char last){\\n        if(n == 0)               // added this base case for n == 1 case\\n            return \"\" ;\\n        \\n        string pos ;             // pos is the string of size 2 containing possible letters from a,b,c\\n        if(last == \\'a\\')          // which I can use ;\\n            pos = \"bc\" ;\\n        else if(last == \\'b\\')\\n            pos = \"ac\" ;\\n        else\\n            pos = \"ab\" ;\\n            \\n        if(n == 1){              // base case: if len is 1 then return the appropriate character ;\\n            string p(1,pos[k-1]) ;\\n            return p ;\\n        }\\n        \\n        int x = (int)pow(2,n-1) ; // for given n,k we can have 2^n possible combinations\\n                                  // 2^(n-1) for each possible character.\\n        if(k <= x)\\n            return pos[0] + getAns(n-1,k,pos[0]) ; // if k <= x then k remains same\\n        else\\n            return pos[1] + getAns(n-1,k-x,pos[1]) ; // if k > x then decrease k by 2^(n-1)\\n    }\\n    \\n    string getHappyString(int n, int k) {\\n        int x = (int)pow(2,n-1) ; // precomputing 2^(n-1) as its used again and again\\n        \\n        if(3*x < k)           // only 3*2^(n-1) combinations are possible\\n            return \"\" ;\\n                                // out of this 3*(2^(n-1)) combinations 2^(n-1) combinations are possible\\n                                // for each character\\n        char f ;                //first character of the string\\n        int nk ;                // new K \\n        if(1 <= k && k <= x)    \\n            f = \\'a\\', nk = k ;   // if 1 <= k <= 2^(n-1) then k lies in the first 1/3rd possible perms.\\n                                // so k remains the same.\\n        else if(x<k && k<=2*x)   // if 2^(n-1) < k <= 2*2^(n-1) then k lies between the first 1/3rd possible\\n            f = \\'b\\', nk = k-x ; // perms and the last 1/3rd possible perms \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// so k remains the same.\\n        else                    \\n            f = \\'c\\', nk = k-2*x ; // if 2*2^(n-1) < k <= 3*2^(n-1) then k lies in the last 1/3rd possible perms\\n        \\n        return f + getAns(n-1,nk,f) ; // add the first character and now recursively find possible\\n                                      // combinations for the remaining n-1 positions of the string.\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string getAns(int n, int k, char last){\\n        if(n == 0)               // added this base case for n == 1 case\\n            return \"\" ;\\n        \\n        string pos ;             // pos is the string of size 2 containing possible letters from a,b,c\\n        if(last == \\'a\\')          // which I can use ;\\n            pos = \"bc\" ;\\n        else if(last == \\'b\\')\\n            pos = \"ac\" ;\\n        else\\n            pos = \"ab\" ;\\n            \\n        if(n == 1){              // base case: if len is 1 then return the appropriate character ;\\n            string p(1,pos[k-1]) ;\\n            return p ;\\n        }\\n        \\n        int x = (int)pow(2,n-1) ; // for given n,k we can have 2^n possible combinations\\n                                  // 2^(n-1) for each possible character.\\n        if(k <= x)\\n            return pos[0] + getAns(n-1,k,pos[0]) ; // if k <= x then k remains same\\n        else\\n            return pos[1] + getAns(n-1,k-x,pos[1]) ; // if k > x then decrease k by 2^(n-1)\\n    }\\n    \\n    string getHappyString(int n, int k) {\\n        int x = (int)pow(2,n-1) ; // precomputing 2^(n-1) as its used again and again\\n        \\n        if(3*x < k)           // only 3*2^(n-1) combinations are possible\\n            return \"\" ;\\n                                // out of this 3*(2^(n-1)) combinations 2^(n-1) combinations are possible\\n                                // for each character\\n        char f ;                //first character of the string\\n        int nk ;                // new K \\n        if(1 <= k && k <= x)    \\n            f = \\'a\\', nk = k ;   // if 1 <= k <= 2^(n-1) then k lies in the first 1/3rd possible perms.\\n                                // so k remains the same.\\n        else if(x<k && k<=2*x)   // if 2^(n-1) < k <= 2*2^(n-1) then k lies between the first 1/3rd possible\\n            f = \\'b\\', nk = k-x ; // perms and the last 1/3rd possible perms \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// so k remains the same.\\n        else                    \\n            f = \\'c\\', nk = k-2*x ; // if 2*2^(n-1) < k <= 3*2^(n-1) then k lies in the last 1/3rd possible perms\\n        \\n        return f + getAns(n-1,nk,f) ; // add the first character and now recursively find possible\\n                                      // combinations for the remaining n-1 positions of the string.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1435003,
                "title": "intuitive-solution-but-not-the-most-efficient",
                "content": "There exists better solutions than this but in my opinion this is way more intuitive and easy to come up. Basically what I did here was just generate all the happy strings lexicographically and return the kth string. This can be optimized further to print only the kth happy string, but I guess I am too lazy to do that XD\\n```\\nclass Solution {\\npublic:\\n    vector<string> happy;\\n    \\n    string getHappyString(int n, int k) {\\n        solve(n,\"\");\\n        return k<=happy.size()?happy[k-1]:\"\";\\n    }\\n    \\n    void solve(int n,string s){\\n        if(s.length()==n){\\n            happy.push_back(s);\\n            return;\\n        }\\n        int l=s.length();\\n        for(int i=0;i<3;i++){\\n            char c=97+i;\\n            \\n            if(l==0){\\n                solve(n,s+c);\\n                continue;\\n            }\\n            \\n            if(c!=s[l-1]){\\n                solve(n,s+c);\\n            }\\n        }\\n    }\\n};\\n```\\n**UPDATE**\\nTo print only the kth happy string use:\\n```\\nclass Solution {\\npublic:\\n    string happy=\"\";\\n    int counter=0;\\n    string getHappyString(int n, int k) {\\n        solve(n,\"\",k);\\n        return happy;\\n    }\\n    \\n    void solve(int n,string s,int k){\\n        if(s.length()==n){\\n            counter++;\\n            if(counter==k){\\n                happy=s;\\n            }\\n            return;\\n        }\\n        \\n        for(int i=0;i<3;i++){\\n            char c=97+i;\\n            if(s.length()==0){\\n                solve(n,s+c,k);\\n                continue;\\n            }\\n            \\n            if(c!=s[s.length()-1]){\\n                solve(n,s+c,k);\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> happy;\\n    \\n    string getHappyString(int n, int k) {\\n        solve(n,\"\");\\n        return k<=happy.size()?happy[k-1]:\"\";\\n    }\\n    \\n    void solve(int n,string s){\\n        if(s.length()==n){\\n            happy.push_back(s);\\n            return;\\n        }\\n        int l=s.length();\\n        for(int i=0;i<3;i++){\\n            char c=97+i;\\n            \\n            if(l==0){\\n                solve(n,s+c);\\n                continue;\\n            }\\n            \\n            if(c!=s[l-1]){\\n                solve(n,s+c);\\n            }\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string happy=\"\";\\n    int counter=0;\\n    string getHappyString(int n, int k) {\\n        solve(n,\"\",k);\\n        return happy;\\n    }\\n    \\n    void solve(int n,string s,int k){\\n        if(s.length()==n){\\n            counter++;\\n            if(counter==k){\\n                happy=s;\\n            }\\n            return;\\n        }\\n        \\n        for(int i=0;i<3;i++){\\n            char c=97+i;\\n            if(s.length()==0){\\n                solve(n,s+c,k);\\n                continue;\\n            }\\n            \\n            if(c!=s[s.length()-1]){\\n                solve(n,s+c,k);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1414677,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    set<string> sans;\\n    string ans = \"\";\\n    void Util(char *arr, int n, string s, int k)\\n    {\\n        if(s.length()==n)\\n        {\\n            sans.insert(s);\\n            if(sans.size()==k)\\n                ans = s;\\n            return;\\n        }\\n        for(int i = 0;i<3;i++)\\n        {\\n            if(s.length()==0 || s[s.length()-1]!=arr[i])\\n            {\\n                s.push_back(arr[i]);\\n                Util(arr,n,s,k);\\n                s.pop_back();\\n            }\\n        }\\n        return;\\n    }\\n    string getHappyString(int n, int k) {\\n        char arr[] = {\\'a\\',\\'b\\',\\'c\\'};\\n        Util(arr,n,\"\",k);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    set<string> sans;\\n    string ans = \"\";\\n    void Util(char *arr, int n, string s, int k)\\n    {\\n        if(s.length()==n)\\n        {\\n            sans.insert(s);\\n            if(sans.size()==k)\\n                ans = s;\\n            return;\\n        }\\n        for(int i = 0;i<3;i++)\\n        {\\n            if(s.length()==0 || s[s.length()-1]!=arr[i])\\n            {\\n                s.push_back(arr[i]);\\n                Util(arr,n,s,k);\\n                s.pop_back();\\n            }\\n        }\\n        return;\\n    }\\n    string getHappyString(int n, int k) {\\n        char arr[] = {\\'a\\',\\'b\\',\\'c\\'};\\n        Util(arr,n,\"\",k);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1371249,
                "title": "c-easy-short-recursive-approach",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\n\\t\\tvoid helper(int n, int k, vector<string>&ans, vector<char>&alpha, string currStr){\\n\\t\\t\\tif(ans.size()==k) //base case, if kth string found\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(currStr.size()==n){   //if found a n-sized string, then store it\\n\\t\\t\\t\\tans.push_back(currStr);\\n\\t\\t\\t\\tcurrStr.pop_back(); //remove the last char and backtrack \\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0;i<alpha.size();i++){\\n\\t\\t\\t\\tif(currStr.size()==0 || currStr[currStr.size()-1]!=alpha[i]){ //condition check\\n\\t\\t\\t\\t\\thelper(n,k,ans,alpha,currStr+alpha[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\n\\t\\tstring getHappyString(int n, int k) {\\n\\t\\t\\tvector<string>ans;\\n\\t\\t\\tvector<char>alpha={\\'a\\',\\'b\\',\\'c\\'};\\n\\t\\t\\thelper(n, k, ans, alpha, \"\"); \\n\\t\\t\\tif(k==ans.size())\\n\\t\\t\\t\\treturn ans.back();\\n\\t\\t\\treturn \"\";\\n\\t\\t}\\n\\t};\\n\\t/*If any doubts, please comment and ask :)*/",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\t\\tvoid helper(int n, int k, vector<string>&ans, vector<char>&alpha, string currStr){\\n\\t\\t\\tif(ans.size()==k) //base case, if kth string found\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(currStr.size()==n){   //if found a n-sized string, then store it\\n\\t\\t\\t\\tans.push_back(currStr);\\n\\t\\t\\t\\tcurrStr.pop_back(); //remove the last char and backtrack \\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1346279,
                "title": "1ms-share-my-o-n-code-with-annotation-java",
                "content": "Explanation: \\nRecord the change bit\\' index, and construct the result from 0-index.\\nSee the annotation :)\\n\\n```java\\n// AC: Runtime: 1 ms, faster than 98.85% of Java online submissions for The k-th Lexicographical String of All Happy Strings of Length n.\\n// Memory Usage: 36.4 MB, less than 91.92% of Java online submissions for The k-th Lexicographical String of All Happy Strings of Length n.\\n// Record the change bit\\' index, and construct the result from 0-index\\n// T:O(n), S:O(logn)\\n// \\nclass Solution {\\n    public String getHappyString(int n, int k) {\\n        int total = 3 * (int) Math.pow(2, n - 1);\\n        if (k > total) {\\n            return \"\";\\n        }\\n        // record the bit from end to start that have to rise on the base of its original char, for example, \\'a\\' -> \\'b\\',  \\'b\\' -> \\'c\\'\\n        k = k - 1;\\n        int exp = 1;\\n        List<Integer> expIndex = new LinkedList<>();\\n        while (k > 0) {\\n            int modRemain = k % 2;\\n            if (modRemain == 1) {\\n                expIndex.add(exp);\\n            }\\n            k /= 2;\\n            exp++;\\n        }\\n        \\n        int inserted = expIndex.size() - 1;\\n        StringBuilder ret = new StringBuilder();\\n        char lastChar = \\' \\', c;\\n        for (int i = 0; i < n; i++) {\\n\\t\\t\\t// the first char will have 3-choices (a, b, c), while the left position only have 2 choices, (a, b), (b, c), or (a, c)\\n            if (inserted >= 0 && expIndex.get(inserted) == n + 1) {\\n                inserted--;\\n                lastChar = \\'c\\';\\n                ret.append(lastChar);\\n                continue;\\n            }\\n            if (inserted >= 0 && i == n - expIndex.get(inserted)) {\\n                if (i == 0) {\\n                    c = \\'b\\';\\n                } else {\\n                    if (lastChar == \\'a\\' || lastChar == \\'b\\') {\\n                        c = \\'c\\';\\n                    } else {\\n                        c = \\'b\\';\\n                    }\\n                }\\n                inserted--;\\n            } else {\\n                if (i == 0) {\\n                    c = \\'a\\';\\n                } else {\\n                    if (lastChar == \\'b\\' || lastChar == \\'c\\') {\\n                        c = \\'a\\';\\n                    } else {\\n                        c = \\'b\\';\\n                    }\\n                }\\n            }\\n            lastChar = c;\\n            ret.append(lastChar);\\n        }\\n\\n        return ret.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Probability and Statistics"
                ],
                "code": "```java\\n// AC: Runtime: 1 ms, faster than 98.85% of Java online submissions for The k-th Lexicographical String of All Happy Strings of Length n.\\n// Memory Usage: 36.4 MB, less than 91.92% of Java online submissions for The k-th Lexicographical String of All Happy Strings of Length n.\\n// Record the change bit\\' index, and construct the result from 0-index\\n// T:O(n), S:O(logn)\\n// \\nclass Solution {\\n    public String getHappyString(int n, int k) {\\n        int total = 3 * (int) Math.pow(2, n - 1);\\n        if (k > total) {\\n            return \"\";\\n        }\\n        // record the bit from end to start that have to rise on the base of its original char, for example, \\'a\\' -> \\'b\\',  \\'b\\' -> \\'c\\'\\n        k = k - 1;\\n        int exp = 1;\\n        List<Integer> expIndex = new LinkedList<>();\\n        while (k > 0) {\\n            int modRemain = k % 2;\\n            if (modRemain == 1) {\\n                expIndex.add(exp);\\n            }\\n            k /= 2;\\n            exp++;\\n        }\\n        \\n        int inserted = expIndex.size() - 1;\\n        StringBuilder ret = new StringBuilder();\\n        char lastChar = \\' \\', c;\\n        for (int i = 0; i < n; i++) {\\n\\t\\t\\t// the first char will have 3-choices (a, b, c), while the left position only have 2 choices, (a, b), (b, c), or (a, c)\\n            if (inserted >= 0 && expIndex.get(inserted) == n + 1) {\\n                inserted--;\\n                lastChar = \\'c\\';\\n                ret.append(lastChar);\\n                continue;\\n            }\\n            if (inserted >= 0 && i == n - expIndex.get(inserted)) {\\n                if (i == 0) {\\n                    c = \\'b\\';\\n                } else {\\n                    if (lastChar == \\'a\\' || lastChar == \\'b\\') {\\n                        c = \\'c\\';\\n                    } else {\\n                        c = \\'b\\';\\n                    }\\n                }\\n                inserted--;\\n            } else {\\n                if (i == 0) {\\n                    c = \\'a\\';\\n                } else {\\n                    if (lastChar == \\'b\\' || lastChar == \\'c\\') {\\n                        c = \\'a\\';\\n                    } else {\\n                        c = \\'b\\';\\n                    }\\n                }\\n            }\\n            lastChar = c;\\n            ret.append(lastChar);\\n        }\\n\\n        return ret.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339142,
                "title": "c-backtracking",
                "content": "**Solution 1**\\n```\\nclass Solution {\\npublic:\\n    void generate(vector<string> &allStrings, int n, string word)\\n    {\\n        if (word.length() == n) {\\n            allStrings.push_back(word);\\n            cout << word << \"\\\\n\";\\n            return;\\n        }\\n        \\n        if (word[word.length() - 1] == \\'a\\') {\\n            generate(allStrings, n, word + \\'b\\');\\n            generate(allStrings, n, word + \\'c\\');\\n        }\\n        else if (word[word.length() - 1] == \\'b\\') {\\n            generate(allStrings, n, word + \\'a\\');\\n            generate(allStrings, n, word + \\'c\\');\\n        }\\n        else {\\n            generate(allStrings, n, word + \\'a\\');\\n            generate(allStrings, n, word + \\'b\\');\\n        }\\n    }\\n    \\n    string getHappyString(int n, int k) \\n    {\\n        vector<string> allStrings;\\n        \\n        generate(allStrings, n, \"a\");\\n        generate(allStrings, n, \"b\");\\n        generate(allStrings, n, \"c\");\\n        \\n        if (k > allStrings.size())\\n            return {};\\n        else\\n            return allStrings[k - 1];\\n    }\\n};\\n```\\n\\n**Solution 2**\\n```\\nclass Solution {\\npublic:\\n    vector<char> vals = {\\'a\\', \\'b\\', \\'c\\'};\\n    \\n    void generate(vector<string> &allStrings, int n, string word)\\n    {\\n        if (word.length() == n) {\\n            allStrings.push_back(word);\\n            return;\\n        }\\n        \\n        for (char ch : vals)\\n            if (ch != word[word.length() - 1])\\n                generate(allStrings, n, word + ch);\\n    }\\n    \\n    string getHappyString(int n, int k) \\n    {\\n        vector<string> allStrings;\\n        \\n        for (char ch : vals) {\\n            string word(1, ch);\\n            generate(allStrings, n, word);\\n        }\\n                    \\n        if (k > allStrings.size())\\n            return {};\\n        else\\n            return allStrings[k - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void generate(vector<string> &allStrings, int n, string word)\\n    {\\n        if (word.length() == n) {\\n            allStrings.push_back(word);\\n            cout << word << \"\\\\n\";\\n            return;\\n        }\\n        \\n        if (word[word.length() - 1] == \\'a\\') {\\n            generate(allStrings, n, word + \\'b\\');\\n            generate(allStrings, n, word + \\'c\\');\\n        }\\n        else if (word[word.length() - 1] == \\'b\\') {\\n            generate(allStrings, n, word + \\'a\\');\\n            generate(allStrings, n, word + \\'c\\');\\n        }\\n        else {\\n            generate(allStrings, n, word + \\'a\\');\\n            generate(allStrings, n, word + \\'b\\');\\n        }\\n    }\\n    \\n    string getHappyString(int n, int k) \\n    {\\n        vector<string> allStrings;\\n        \\n        generate(allStrings, n, \"a\");\\n        generate(allStrings, n, \"b\");\\n        generate(allStrings, n, \"c\");\\n        \\n        if (k > allStrings.size())\\n            return {};\\n        else\\n            return allStrings[k - 1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<char> vals = {\\'a\\', \\'b\\', \\'c\\'};\\n    \\n    void generate(vector<string> &allStrings, int n, string word)\\n    {\\n        if (word.length() == n) {\\n            allStrings.push_back(word);\\n            return;\\n        }\\n        \\n        for (char ch : vals)\\n            if (ch != word[word.length() - 1])\\n                generate(allStrings, n, word + ch);\\n    }\\n    \\n    string getHappyString(int n, int k) \\n    {\\n        vector<string> allStrings;\\n        \\n        for (char ch : vals) {\\n            string word(1, ch);\\n            generate(allStrings, n, word);\\n        }\\n                    \\n        if (k > allStrings.size())\\n            return {};\\n        else\\n            return allStrings[k - 1];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1324068,
                "title": "c-0ms-100-faster-backtracking-with-optimization",
                "content": "![image](https://assets.leetcode.com/users/images/9c887deb-b83c-42ff-9d8c-e150740b3dd7_1625724533.368737.png)\\n\\n```\\nclass Solution {\\npublic:\\n    string getHappyString(int n, int k) {\\n        \\n        vector<char> happy = {\\'a\\', \\'b\\', \\'c\\'}; \\n    \\n        vector<string> answer; \\n        \\n        backtrack(happy, answer, \"\", k, n); \\n        \\n        if (k > answer.size()) { \\n            return \"\";\\n        } \\n        \\n        return answer[k-1]; \\n    } \\n    \\n    void backtrack(vector<char> &happy, vector<string> &answer, string path, int k, int n) { \\n        \\n        if (answer.size() == k) { \\n            return;\\n        } \\n        \\n        if (path.length() == n) { \\n            answer.push_back(path); \\n            return;\\n        } \\n        \\n        for (int i = 0; i < happy.size(); i++) { \\n            \\n            if (path.length() > 0 && happy[i] == path[path.size()-1]) { \\n                continue;\\n            }\\n            \\n            path.push_back(happy[i]); \\n            \\n            backtrack(happy, answer, path, k, n);   \\n            \\n            path.pop_back();    \\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getHappyString(int n, int k) {\\n        \\n        vector<char> happy = {\\'a\\', \\'b\\', \\'c\\'}; \\n    \\n        vector<string> answer; \\n        \\n        backtrack(happy, answer, \"\", k, n); \\n        \\n        if (k > answer.size()) { \\n            return \"\";\\n        } \\n        \\n        return answer[k-1]; \\n    } \\n    \\n    void backtrack(vector<char> &happy, vector<string> &answer, string path, int k, int n) { \\n        \\n        if (answer.size() == k) { \\n            return;\\n        } \\n        \\n        if (path.length() == n) { \\n            answer.push_back(path); \\n            return;\\n        } \\n        \\n        for (int i = 0; i < happy.size(); i++) { \\n            \\n            if (path.length() > 0 && happy[i] == path[path.size()-1]) { \\n                continue;\\n            }\\n            \\n            path.push_back(happy[i]); \\n            \\n            backtrack(happy, answer, path, k, n);   \\n            \\n            path.pop_back();    \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1304979,
                "title": "java-easy-recursive",
                "content": "```\\nclass Solution {\\n    public String getHappyString(int n, int k) {\\n        back(\"\",n,0,k);\\n      \\n       return ans;\\n       \\n    }\\n  String ans = \"\";\\n  int count = 0;\\n   private void back(String s,int n,int cs,int k){\\n      \\n      if(cs == n){\\n        count++;\\n       \\n        if(count == k) ans = s;\\n        return;\\n      }\\n      //Choices i.e \\'a\\',\\'b\\' & \\'c\\' (will generate strings according to the lexicographical order)\\n      for(int i = 0;i < 3; i++){\\n         char c = (char)(i + \\'a\\');\\n        //Avoid the previous used character\\n         if(s.length() > 0 && s.charAt(s.length() - 1) == c) continue;\\n          back(s + c,n,cs + 1,k);\\n      }\\n      \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String getHappyString(int n, int k) {\\n        back(\"\",n,0,k);\\n      \\n       return ans;\\n       \\n    }\\n  String ans = \"\";\\n  int count = 0;\\n   private void back(String s,int n,int cs,int k){\\n      \\n      if(cs == n){\\n        count++;\\n       \\n        if(count == k) ans = s;\\n        return;\\n      }\\n      //Choices i.e \\'a\\',\\'b\\' & \\'c\\' (will generate strings according to the lexicographical order)\\n      for(int i = 0;i < 3; i++){\\n         char c = (char)(i + \\'a\\');\\n        //Avoid the previous used character\\n         if(s.length() > 0 && s.charAt(s.length() - 1) == c) continue;\\n          back(s + c,n,cs + 1,k);\\n      }\\n      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1257050,
                "title": "1415-ps-c-easy-solution-backtracking",
                "content": "class Solution {\\npublic:\\n    \\n\\t//-----------------global variables to make it easily accessible\\n\\t\\n\\tvector<char> v1{\\'a\\',\\'b\\',\\'c\\'};\\n    string pairs;\\n    vector<string> result;\\n    \\n\\t//----------- main function ---------\\n\\n    string getHappyString(int n, int k) {\\n        solve(n);\\n        return (result.size() >= k) ? result[k-1] : \"\";\\n    }\\n    \\n\\t//------------------- backtrack function ---------\\n\\n    void solve(int n){\\n\\t\\n        if(pairs.size() == n)  result.push_back(pairs);   // if the length of string is equal to n\\n\\t\\t\\n        else{\\n            for(int i = 0; i < v1.size(); i++){           // for all (\\'a\\', \\'b\\', \\'c\\') \\n                if(v1[i] == pairs.back()){               // to check the last element inserted, if it is same, ignore it...\\n                    continue;\\n                }\\n\\n                pairs.push_back(v1[i]);           // if it is not same then push the alphabet into string\\n                solve(n);                         // call function until the length becomes n\\n                pairs.pop_back();                 // permutation logic used\\n\\n            }\\n\\n        }\\n}\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    \\n\\t//-----------------global variables to make it easily accessible\\n\\t\\n\\tvector<char> v1{\\'a\\',\\'b\\',\\'c\\'}",
                "codeTag": "Java"
            },
            {
                "id": 1244350,
                "title": "c-easy-to-understand-backtrack-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    set<string>st;\\n    \\n   void recurs(char prev,int n,string res)\\n    {\\n        \\n        if(n<=0)\\n        {\\n            st.insert(res);\\n            return ;\\n        }\\n        \\n        \\n        string s=res;\\n        if(prev!=\\'a\\')\\n        {\\n            s+=\\'a\\';\\n            recurs(\\'a\\',n-1,s);\\n        }\\n        s=res;//backtracking step\\n        if(prev!=\\'b\\')\\n        {\\n              s+=\\'b\\';\\n              recurs(\\'b\\',n-1,s);\\n            \\n        }\\n        s=res;//backtracking step\\n        if(prev!=\\'c\\')\\n        {\\n              s+=\\'c\\';\\n              recurs(\\'c\\',n-1,s);\\n        }\\n    }\\n    \\n    \\n    \\n    \\n    string getHappyString(int n, int k) {\\n        string a=\"\";\\n        recurs(\\'\\\\0\\',n,a);\\n        \\n        if(k>st.size())\\n        {\\n            return \"\";\\n        }\\n        \\n        for(auto x:st)\\n        {\\n            if(k==1)\\n            {\\n                return x;\\n            }\\n            k--;\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    set<string>st;\\n    \\n   void recurs(char prev,int n,string res)\\n    {\\n        \\n        if(n<=0)\\n        {\\n            st.insert(res);\\n            return ;\\n        }\\n        \\n        \\n        string s=res;\\n        if(prev!=\\'a\\')\\n        {\\n            s+=\\'a\\';\\n            recurs(\\'a\\',n-1,s);\\n        }\\n        s=res;//backtracking step\\n        if(prev!=\\'b\\')\\n        {\\n              s+=\\'b\\';\\n              recurs(\\'b\\',n-1,s);\\n            \\n        }\\n        s=res;//backtracking step\\n        if(prev!=\\'c\\')\\n        {\\n              s+=\\'c\\';\\n              recurs(\\'c\\',n-1,s);\\n        }\\n    }\\n    \\n    \\n    \\n    \\n    string getHappyString(int n, int k) {\\n        string a=\"\";\\n        recurs(\\'\\\\0\\',n,a);\\n        \\n        if(k>st.size())\\n        {\\n            return \"\";\\n        }\\n        \\n        for(auto x:st)\\n        {\\n            if(k==1)\\n            {\\n                return x;\\n            }\\n            k--;\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1210921,
                "title": "python-simple-solution-no-recursion",
                "content": "```\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n        pos, k = 2 ** (n - 1), k -1\\n        if k >= pos * 3:\\n            return \\'\\'\\n        letters = {\\n            (\\'\\' , 0): \\'a\\',\\n            (\\'\\' , 1): \\'b\\',\\n            (\\'\\' , 2): \\'c\\',\\n            (\\'a\\', 0): \\'b\\',\\n            (\\'a\\', 1): \\'c\\',\\n            (\\'b\\', 0): \\'a\\',\\n            (\\'b\\', 1): \\'c\\',\\n            (\\'c\\', 0): \\'a\\',\\n            (\\'c\\', 1): \\'b\\'\\n        }\\n        result = [\\'\\']\\n        while pos > 0:\\n            result.append(letters[(result[-1], k // pos)])\\n            k = k % pos\\n            pos = pos // 2\\n        return \\'\\'.join(result)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n        pos, k = 2 ** (n - 1), k -1\\n        if k >= pos * 3:\\n            return \\'\\'\\n        letters = {\\n            (\\'\\' , 0): \\'a\\',\\n            (\\'\\' , 1): \\'b\\',\\n            (\\'\\' , 2): \\'c\\',\\n            (\\'a\\', 0): \\'b\\',\\n            (\\'a\\', 1): \\'c\\',\\n            (\\'b\\', 0): \\'a\\',\\n            (\\'b\\', 1): \\'c\\',\\n            (\\'c\\', 0): \\'a\\',\\n            (\\'c\\', 1): \\'b\\'\\n        }\\n        result = [\\'\\']\\n        while pos > 0:\\n            result.append(letters[(result[-1], k // pos)])\\n            k = k % pos\\n            pos = pos // 2\\n        return \\'\\'.join(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1199478,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<string> res;\\n    \\n    void dfs(int dig, int k, char last, string str) {\\n        \\n        if(dig == 0) {\\n            res.push_back(str);\\n            return;\\n        }\\n        \\n        if(last == \\'a\\') {\\n            dfs(dig - 1, k, \\'b\\', str + \\'b\\');\\n            dfs(dig - 1, k, \\'c\\', str + \\'c\\');            \\n        }\\n        \\n        if(last == \\'b\\') {\\n            dfs(dig - 1, k, \\'a\\', str + \\'a\\');\\n            dfs(dig - 1, k, \\'c\\', str + \\'c\\');            \\n        }\\n        \\n        if(last == \\'c\\') {\\n            dfs(dig - 1, k, \\'a\\', str + \\'a\\');\\n            dfs(dig - 1, k, \\'b\\', str + \\'b\\');            \\n        }\\n        \\n    }\\n    \\n    string getHappyString(int n, int k) {\\n        \\n        for(char ch = \\'a\\'; ch <= \\'c\\'; ch++) {\\n            string str = \"\";\\n            str += ch;\\n            \\n            dfs(n - 1, k, ch, str);\\n        }\\n        \\n        if(res.size() < k) {\\n            return \"\";\\n        };\\n\\n        return res[k - 1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<string> res;\\n    \\n    void dfs(int dig, int k, char last, string str) {\\n        \\n        if(dig == 0) {\\n            res.push_back(str);\\n            return;\\n        }\\n        \\n        if(last == \\'a\\') {\\n            dfs(dig - 1, k, \\'b\\', str + \\'b\\');\\n            dfs(dig - 1, k, \\'c\\', str + \\'c\\');            \\n        }\\n        \\n        if(last == \\'b\\') {\\n            dfs(dig - 1, k, \\'a\\', str + \\'a\\');\\n            dfs(dig - 1, k, \\'c\\', str + \\'c\\');            \\n        }\\n        \\n        if(last == \\'c\\') {\\n            dfs(dig - 1, k, \\'a\\', str + \\'a\\');\\n            dfs(dig - 1, k, \\'b\\', str + \\'b\\');            \\n        }\\n        \\n    }\\n    \\n    string getHappyString(int n, int k) {\\n        \\n        for(char ch = \\'a\\'; ch <= \\'c\\'; ch++) {\\n            string str = \"\";\\n            str += ch;\\n            \\n            dfs(n - 1, k, ch, str);\\n        }\\n        \\n        if(res.size() < k) {\\n            return \"\";\\n        };\\n\\n        return res[k - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1172898,
                "title": "simple-c-code-backtracking-few-lines-of-code",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<string>v;\\n\\t\\tvoid check(int n,string s)\\n\\t\\t{\\n\\t\\t\\tif(s.size()==n)\\n\\t\\t\\t{\\n\\t\\t\\t\\tv.push_back(s);\\n\\t\\t\\t\\treturn ;\\n\\t\\t\\t}\\n\\t\\t\\tfor(char i=\\'a\\';i<=\\'c\\';i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(s.size()==0||i!=s.back())// checking if last character is not equal to the current character\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ts.push_back(i);\\n\\t\\t\\t\\t\\t\\tcheck(n,s);\\n\\t\\t\\t\\t\\t\\ts.pop_back();\\n\\t\\t\\t\\t}\\n\\t\\t\\t }  \\t     \\n\\t\\t}\\n\\t\\tstring getHappyString(int n, int k) {\\n\\t\\t   string s=\"\";\\n\\t\\t\\tcheck(n,s);\\n\\t\\t\\tsort(v.begin(),v.end());\\n\\t\\t\\tif(k>v.size())\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn \"\";\\n\\t\\t\\t}\\n\\t\\t\\treturn v[k-1];\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<string>v;\\n\\t\\tvoid check(int n,string s)\\n\\t\\t{\\n\\t\\t\\tif(s.size()==n)\\n\\t\\t\\t{\\n\\t\\t\\t\\tv.push_back(s);\\n\\t\\t\\t\\treturn ;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1164429,
                "title": "simple-dfs-python-solution",
                "content": "```\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n        \\'\\'\\'\\n                    \"\"\\n                a       b\\n            aba         ba ...\\n        ....\\n        \\'\\'\\'\\n        chars = [\\'a\\',\\'b\\',\\'c\\']\\n        chars_len = len(chars)\\n        ans = []\\n        def recur(path):\\n            if len(path) == n:\\n                ans.append(path)\\n                return\\n            for i in range(chars_len):\\n                if path[-1] != chars[i]:\\n                    recur(path+chars[i])\\n        for c in chars:\\n            recur(c)\\n            \\n        if k-1<len(ans):\\n            return ans[k-1]\\n        return \"\"\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n        \\'\\'\\'\\n                    \"\"\\n                a       b\\n            aba         ba ...\\n        ....\\n        \\'\\'\\'\\n        chars = [\\'a\\',\\'b\\',\\'c\\']\\n        chars_len = len(chars)\\n        ans = []\\n        def recur(path):\\n            if len(path) == n:\\n                ans.append(path)\\n                return\\n            for i in range(chars_len):\\n                if path[-1] != chars[i]:\\n                    recur(path+chars[i])\\n        for c in chars:\\n            recur(c)\\n            \\n        if k-1<len(ans):\\n            return ans[k-1]\\n        return \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1102903,
                "title": "detail-explained-o-logn-o-1-non-recursion-solution",
                "content": "Commented inline.\\n\\n```\\nclass Solution {\\n    // Math O(logN), N is all possible string\\n    public String getHappyString(int n, int k) {\\n        // 1. Count Total\\n        // Count of n is twice of count of n-1.\\n        // As for each string with length n-1, can append another char at the end 2 ways.\\n        // C(1) = 3, C(2) = 6, C(n) = 3*2^(n-1)\\n        int total = 3 * (int) Math.pow(2, n - 1);\\n        if (k > total) return \"\";\\n        \\n        // 2. Classify Total\\n        // Total/3 of strings starts with each char \\'a\\', \\'b\\' or \\'c\\'.\\n        // Then again there are 2 ways to append to increase the length by 1.\\n        int bucketSize = total / 3;\\n        char lastChar = (k > bucketSize * 2) ? \\'c\\' : (k > bucketSize) ? \\'b\\' : \\'a\\'; // 1st char\\n        \\n        StringBuilder sb = new StringBuilder();\\n        sb.append(lastChar);\\n        // It is tempting to use k %= bucketSize; below, that will miss the boundary case when k=bucketSize\\n        while (k > bucketSize) k -= bucketSize;\\n        n--;\\n        \\n        char[][] nextChar = new char[][] {{\\'b\\', \\'c\\'}, {\\'a\\', \\'c\\'}, {\\'a\\', \\'b\\'}};\\n        \\n        // the rest of the chars\\n        while (n > 0) {\\n            bucketSize /= 2;\\n            lastChar = nextChar[lastChar - \\'a\\'][k > bucketSize ? 1 : 0];\\n            sb.append(lastChar);\\n            if (k > bucketSize) k -= bucketSize;\\n            n--;\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // Math O(logN), N is all possible string\\n    public String getHappyString(int n, int k) {\\n        // 1. Count Total\\n        // Count of n is twice of count of n-1.\\n        // As for each string with length n-1, can append another char at the end 2 ways.\\n        // C(1) = 3, C(2) = 6, C(n) = 3*2^(n-1)\\n        int total = 3 * (int) Math.pow(2, n - 1);\\n        if (k > total) return \"\";\\n        \\n        // 2. Classify Total\\n        // Total/3 of strings starts with each char \\'a\\', \\'b\\' or \\'c\\'.\\n        // Then again there are 2 ways to append to increase the length by 1.\\n        int bucketSize = total / 3;\\n        char lastChar = (k > bucketSize * 2) ? \\'c\\' : (k > bucketSize) ? \\'b\\' : \\'a\\'; // 1st char\\n        \\n        StringBuilder sb = new StringBuilder();\\n        sb.append(lastChar);\\n        // It is tempting to use k %= bucketSize; below, that will miss the boundary case when k=bucketSize\\n        while (k > bucketSize) k -= bucketSize;\\n        n--;\\n        \\n        char[][] nextChar = new char[][] {{\\'b\\', \\'c\\'}, {\\'a\\', \\'c\\'}, {\\'a\\', \\'b\\'}};\\n        \\n        // the rest of the chars\\n        while (n > 0) {\\n            bucketSize /= 2;\\n            lastChar = nextChar[lastChar - \\'a\\'][k > bucketSize ? 1 : 0];\\n            sb.append(lastChar);\\n            if (k > bucketSize) k -= bucketSize;\\n            n--;\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1057320,
                "title": "c-backtracking-100-clean-code",
                "content": "```\\nclass Solution {\\n    string result = \"\";\\n    \\n    void dfs(string cur, int n, int& k) {\\n        if (cur.length() == n) {           \\n            if (--k == 0)\\n                result = cur;\\n            \\n            return;\\n        }\\n        \\n        if (k <= 0)\\n            return;\\n        \\n        for (char ch = \\'a\\'; ch <= \\'c\\'; ch++) {\\n            if (not cur.empty() and ch == cur.back())\\n                continue;\\n            \\n            cur += ch;\\n            dfs(cur, n, k);\\n            cur.pop_back();\\n        }\\n    }\\n    \\npublic:\\n    string getHappyString(int n, int k) {        \\n        dfs(\"\", n, k);\\n        \\n        return result;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    string result = \"\";\\n    \\n    void dfs(string cur, int n, int& k) {\\n        if (cur.length() == n) {           \\n            if (--k == 0)\\n                result = cur;\\n            \\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1043632,
                "title": "c-solution-using-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<char> letters{\\'a\\',\\'b\\',\\'c\\'};\\n    vector<string > resultstring ;\\n    \\n    void solve(int n  , string& s , char last){\\n        if( s.size()>n)\\n            return ;\\n        if(s.size()==n){\\n             resultstring.push_back(s);\\n             return;\\n        }\\n       for(int i = 0 ; i<3;i++){\\n           if(letters[i] != last){\\n               s+=letters[i];\\n               solve(n ,s , letters[i]);\\n               s.pop_back();\\n           }\\n       }\\n        \\n    }\\n    \\n    string getHappyString(int n, int k) {\\n        string s=\"\";\\n        solve(n ,s ,\\'0\\');\\n        if(k>resultstring.size())\\n            return \"\";\\n        return resultstring[k-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<char> letters{\\'a\\',\\'b\\',\\'c\\'};\\n    vector<string > resultstring ;\\n    \\n    void solve(int n  , string& s , char last){\\n        if( s.size()>n)\\n            return ;\\n        if(s.size()==n){\\n             resultstring.push_back(s);\\n             return;\\n        }\\n       for(int i = 0 ; i<3;i++){\\n           if(letters[i] != last){\\n               s+=letters[i];\\n               solve(n ,s , letters[i]);\\n               s.pop_back();\\n           }\\n       }\\n        \\n    }\\n    \\n    string getHappyString(int n, int k) {\\n        string s=\"\";\\n        solve(n ,s ,\\'0\\');\\n        if(k>resultstring.size())\\n            return \"\";\\n        return resultstring[k-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1022856,
                "title": "recursion-maxheap",
                "content": "```\\nclass Solution {\\n    private PriorityQueue<String> maxHeap = new PriorityQueue<>(Comparator.reverseOrder());\\n    private int limit;\\n    public String getHappyString(int n, int k) {\\n        limit = k;\\n        getAllHappyStrings(n, new ArrayDeque<Character>());\\n        return maxHeap.size() < k ? \"\" : maxHeap.peek();\\n    }\\n\\n    private void getAllHappyStrings(int len, Deque<Character> deque) {\\n\\n        if(deque.size() == len){\\n            List<Character> list = new ArrayList<>(deque);\\n\\t\\t\\t\\n\\t\\t\\t//this could be costly operation for large string sizes....so instead of deque approach use a char[] array \\n\\t\\t\\t//itself in the recursive call and modify the char array itself in the recusrive call so that you do not have to\\n\\t\\t\\t//construct when the recusrion ends, but i think even in that case new String(charArray) would still take 0(n) to initalise the             //string \\n            String str = list.stream().map(String:: valueOf).collect(Collectors.joining());\\n            addToMaxHeap(str);\\n            return;\\n        }\\n\\n        if(deque.isEmpty() || (!deque.isEmpty() && deque.peekLast() != \\'a\\')){\\n            deque.addLast(\\'a\\');\\n            getAllHappyStrings(len, deque);\\n            deque.removeLast();\\n        }\\n\\n        if(deque.isEmpty() || (!deque.isEmpty() && deque.peekLast() != \\'b\\')){\\n            deque.addLast(\\'b\\');\\n            getAllHappyStrings(len, deque);\\n            deque.removeLast();\\n        }\\n\\n\\n        if (deque.isEmpty() || (!deque.isEmpty() && deque.peekLast() != \\'c\\')) {\\n            deque.addLast(\\'c\\');\\n            getAllHappyStrings(len, deque);\\n            deque.removeLast();\\n        }\\n    }\\n\\n    private void addToMaxHeap(String s) {\\n        maxHeap.add(s);\\n        if(maxHeap.size() > limit)\\n            maxHeap.poll();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private PriorityQueue<String> maxHeap = new PriorityQueue<>(Comparator.reverseOrder());\\n    private int limit;\\n    public String getHappyString(int n, int k) {\\n        limit = k;\\n        getAllHappyStrings(n, new ArrayDeque<Character>());\\n        return maxHeap.size() < k ? \"\" : maxHeap.peek();\\n    }\\n\\n    private void getAllHappyStrings(int len, Deque<Character> deque) {\\n\\n        if(deque.size() == len){\\n            List<Character> list = new ArrayList<>(deque);\\n\\t\\t\\t\\n\\t\\t\\t//this could be costly operation for large string sizes....so instead of deque approach use a char[] array \\n\\t\\t\\t//itself in the recursive call and modify the char array itself in the recusrive call so that you do not have to\\n\\t\\t\\t//construct when the recusrion ends, but i think even in that case new String(charArray) would still take 0(n) to initalise the             //string \\n            String str = list.stream().map(String:: valueOf).collect(Collectors.joining());\\n            addToMaxHeap(str);\\n            return;\\n        }\\n\\n        if(deque.isEmpty() || (!deque.isEmpty() && deque.peekLast() != \\'a\\')){\\n            deque.addLast(\\'a\\');\\n            getAllHappyStrings(len, deque);\\n            deque.removeLast();\\n        }\\n\\n        if(deque.isEmpty() || (!deque.isEmpty() && deque.peekLast() != \\'b\\')){\\n            deque.addLast(\\'b\\');\\n            getAllHappyStrings(len, deque);\\n            deque.removeLast();\\n        }\\n\\n\\n        if (deque.isEmpty() || (!deque.isEmpty() && deque.peekLast() != \\'c\\')) {\\n            deque.addLast(\\'c\\');\\n            getAllHappyStrings(len, deque);\\n            deque.removeLast();\\n        }\\n    }\\n\\n    private void addToMaxHeap(String s) {\\n        maxHeap.add(s);\\n        if(maxHeap.size() > limit)\\n            maxHeap.poll();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 993570,
                "title": "c-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n//Helper function\\n    void stringBuilder(vector<string> &res,string str, int n, int k){\\n//Abort if kth string is already built\\n        if (res.size() == k)\\n            return;\\n// Check if current string is of size n, if yes then push to vector and return\\n        if (str.size() == n){\\n            res.push_back(str);\\n            return;\\n        }\\n// In Lexicographical  order, iterate over all the letters\\n        for (char c : {\\'a\\',\\'b\\',\\'c\\'}){\\n            if (str.back() != c) {\\n                stringBuilder(res,str+c,n,k);\\n            }\\n        }\\n    } \\n    string getHappyString(int n, int k) {\\n        vector<string> res;\\n        string str;\\n        stringBuilder(res,str,n,k);\\n//Check if k is bigger than maximum possible string\\n        if(res.size() < k){\\n            return \"\";   \\n        }\\n        return res[k-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n//Helper function\\n    void stringBuilder(vector<string> &res,string str, int n, int k){\\n//Abort if kth string is already built\\n        if (res.size() == k)\\n            return;\\n// Check if current string is of size n, if yes then push to vector and return\\n        if (str.size() == n){\\n            res.push_back(str);\\n            return;\\n        }\\n// In Lexicographical  order, iterate over all the letters\\n        for (char c : {\\'a\\',\\'b\\',\\'c\\'}){\\n            if (str.back() != c) {\\n                stringBuilder(res,str+c,n,k);\\n            }\\n        }\\n    } \\n    string getHappyString(int n, int k) {\\n        vector<string> res;\\n        string str;\\n        stringBuilder(res,str,n,k);\\n//Check if k is bigger than maximum possible string\\n        if(res.size() < k){\\n            return \"\";   \\n        }\\n        return res[k-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 974438,
                "title": "python-dfs-with-yield-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n        letters = [\\'a\\', \\'b\\', \\'c\\']\\n        def dfs(curr):\\n            if len(curr) == n:\\n                yield curr\\n            else:\\n                for i in range(len(letters)):\\n                    if not curr or curr and curr[-1] != letters[i]:\\n                        yield from dfs(curr + letters[i])\\n        for i, ans in enumerate(dfs(\\'\\')):   \\n            if i == k - 1: \\n                return ans\\n        return \\'\\'\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n        letters = [\\'a\\', \\'b\\', \\'c\\']\\n        def dfs(curr):\\n            if len(curr) == n:\\n                yield curr\\n            else:\\n                for i in range(len(letters)):\\n                    if not curr or curr and curr[-1] != letters[i]:\\n                        yield from dfs(curr + letters[i])\\n        for i, ans in enumerate(dfs(\\'\\')):   \\n            if i == k - 1: \\n                return ans\\n        return \\'\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961194,
                "title": "c-backtracking-solution-faster-than-100-runtime",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> V;\\n    void helper(string s, int n, int k) {\\n    if(V.size()==k){\\n        return;\\n    }\\n    else if(s.size()==n){\\n        V.push_back(s);\\n        return;\\n    }\\n    for(auto c:{\\'a\\',\\'b\\',\\'c\\'}){\\n        if(s.size()==0 or s.back()!=c){\\n            helper(s+c,n,k);\\n        }\\n    }\\n}\\n    string getHappyString(int n, int k) {\\n            helper(\"\",n,k);\\n            if(V.size()<k){return \"\";}\\n            return V[k-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> V;\\n    void helper(string s, int n, int k) {\\n    if(V.size()==k){\\n        return;\\n    }\\n    else if(s.size()==n){\\n        V.push_back(s);\\n        return;\\n    }\\n    for(auto c:{\\'a\\',\\'b\\',\\'c\\'}){\\n        if(s.size()==0 or s.back()!=c){\\n            helper(s+c,n,k);\\n        }\\n    }\\n}\\n    string getHappyString(int n, int k) {\\n            helper(\"\",n,k);\\n            if(V.size()<k){return \"\";}\\n            return V[k-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 950906,
                "title": "c-end-early-simple-0ms-solution-no-math",
                "content": "We  build the strings in lex. order and  stop calculating once reach the kth one.\\nThe implementation uses a recursion.\\n```\\nclass Solution {\\n \\n         vector<string> happy;\\n       \\n        void make_happy(const string s, const int n, const int k) {\\n                if (happy.size() == k)\\n                        return;\\n                if (s.size() < n) {\\n                        for (auto c : {\\'a\\',\\'b\\',\\'c\\'}) {\\n                                if (s.back() != c) {\\n                                        make_happy(s + c, n, k );\\n                                }\\n                        }\\n                } else\\n                        happy.push_back(s);\\n        }\\n        \\npublic:\\n    string getHappyString(int n, int k) {\\n       \\n                    make_happy(\"\", n, k);\\n           \\n            return (k > happy.size())? \"\" : happy[k - 1];\\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n \\n         vector<string> happy;\\n       \\n        void make_happy(const string s, const int n, const int k) {\\n                if (happy.size() == k)\\n                        return;\\n                if (s.size() < n) {\\n                        for (auto c : {\\'a\\',\\'b\\',\\'c\\'}",
                "codeTag": "Java"
            },
            {
                "id": 937712,
                "title": "java-2ms-maxheap-w-o-maxheap-2-approaches-easy-to-understand",
                "content": "**tc - O(nlogm)  , i wanted to write o(nlogk) as we will only have k string at max , but the comparison b/w strings in the maxheap are not o(1) so... future me pls solve for m pls **\\n\\n```\\nclass Solution {\\n    private static void generate(PriorityQueue<String> maxHeap, StringBuilder sb , int len , int n,char[] set,int k){\\n        if(sb.length() > n || maxHeap.size() >= k)\\n            return ;\\n        if(sb.length() == n){\\n            maxHeap.add(sb.toString());\\n            return ;\\n        }\\n        for(int i = 0 ; i < 3 ; i++){\\n            if(sb.length() > 0 && sb.charAt(sb.length() - 1) == set[i])\\n                continue ;\\n            if(sb.length() == 0 || sb.charAt(sb.length() - 1) != set[i]){\\n                sb.append(set[i]);\\n                generate(maxHeap , sb , sb.length() , n , set , k);\\n                sb.deleteCharAt(sb.length() - 1);\\n            }\\n        }\\n    }\\n    public String getHappyString(int n, int k) {\\n        PriorityQueue<String> maxHeap = new PriorityQueue<>((a ,b) ->{\\n            return b.compareTo(a);\\n        });\\n        generate(maxHeap , new StringBuilder() , 0 , n,new char []{\\'a\\',\\'b\\',\\'c\\'} , k);\\n        if(maxHeap.size() < k)\\n            return \"\";\\n        return maxHeap.poll();\\n    }\\n}\\n```\\n\\n**2nd approach w/o priority queue  , tc - O(nk)**   \\n```\\nclass Solution {\\n    private String ans ;\\n    private void generate(StringBuilder sb ,int cnt[] , int len , int n,char[] set,int k){\\n        if(sb.length() > n || cnt[0] >= k) // no need to generate after the K th happy string or a string with size > n \\n            return ;\\n        // found a happy string , incr position cnt and record the current happy string \\n        if(sb.length() == n){\\n            cnt[0]++;\\n            ans = sb.toString();\\n            return ;\\n        }\\n        \\n        for(int i = 0 ; i < 3 ; i++){\\n            // we should satisfy the condition of s[i] != s[i + 1] \\n            if(sb.length() > 0 && sb.charAt(sb.length() - 1) == set[i])\\n                continue ;\\n            \\n            // append the curr char and recurse \\n            if(sb.length() == 0 || sb.charAt(sb.length() - 1) != set[i]){\\n                sb.append(set[i]);\\n                generate(sb,cnt ,sb.length() , n , set , k);\\n                sb.deleteCharAt(sb.length() - 1);\\n            }\\n        }\\n    }\\n    public String getHappyString(int n, int k) {\\n        int cnt[] = new int[]{0}; //counter to keep track of the current happy string\\'s position \\n        ans = \"\";\\n        \\n        // important observation is that the character set is sorted , then as we recurse and backtrack and \\n        // create happy strings, the strings will automatically be sorted in lexicographical order\\n        // please draw a recursion tree with a example to better understand why as we generate strings \\n        // they will already be in sorted order \\n        \\n        generate(new StringBuilder() ,cnt, 0 , n,new char []{\\'a\\',\\'b\\',\\'c\\'} , k);\\n        \\n        if(cnt[0] < k) \\n            return \"\";\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static void generate(PriorityQueue<String> maxHeap, StringBuilder sb , int len , int n,char[] set,int k){\\n        if(sb.length() > n || maxHeap.size() >= k)\\n            return ;\\n        if(sb.length() == n){\\n            maxHeap.add(sb.toString());\\n            return ;\\n        }\\n        for(int i = 0 ; i < 3 ; i++){\\n            if(sb.length() > 0 && sb.charAt(sb.length() - 1) == set[i])\\n                continue ;\\n            if(sb.length() == 0 || sb.charAt(sb.length() - 1) != set[i]){\\n                sb.append(set[i]);\\n                generate(maxHeap , sb , sb.length() , n , set , k);\\n                sb.deleteCharAt(sb.length() - 1);\\n            }\\n        }\\n    }\\n    public String getHappyString(int n, int k) {\\n        PriorityQueue<String> maxHeap = new PriorityQueue<>((a ,b) ->{\\n            return b.compareTo(a);\\n        });\\n        generate(maxHeap , new StringBuilder() , 0 , n,new char []{\\'a\\',\\'b\\',\\'c\\'} , k);\\n        if(maxHeap.size() < k)\\n            return \"\";\\n        return maxHeap.poll();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private String ans ;\\n    private void generate(StringBuilder sb ,int cnt[] , int len , int n,char[] set,int k){\\n        if(sb.length() > n || cnt[0] >= k) // no need to generate after the K th happy string or a string with size > n \\n            return ;\\n        // found a happy string , incr position cnt and record the current happy string \\n        if(sb.length() == n){\\n            cnt[0]++;\\n            ans = sb.toString();\\n            return ;\\n        }\\n        \\n        for(int i = 0 ; i < 3 ; i++){\\n            // we should satisfy the condition of s[i] != s[i + 1] \\n            if(sb.length() > 0 && sb.charAt(sb.length() - 1) == set[i])\\n                continue ;\\n            \\n            // append the curr char and recurse \\n            if(sb.length() == 0 || sb.charAt(sb.length() - 1) != set[i]){\\n                sb.append(set[i]);\\n                generate(sb,cnt ,sb.length() , n , set , k);\\n                sb.deleteCharAt(sb.length() - 1);\\n            }\\n        }\\n    }\\n    public String getHappyString(int n, int k) {\\n        int cnt[] = new int[]{0}; //counter to keep track of the current happy string\\'s position \\n        ans = \"\";\\n        \\n        // important observation is that the character set is sorted , then as we recurse and backtrack and \\n        // create happy strings, the strings will automatically be sorted in lexicographical order\\n        // please draw a recursion tree with a example to better understand why as we generate strings \\n        // they will already be in sorted order \\n        \\n        generate(new StringBuilder() ,cnt, 0 , n,new char []{\\'a\\',\\'b\\',\\'c\\'} , k);\\n        \\n        if(cnt[0] < k) \\n            return \"\";\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 924941,
                "title": "c-math",
                "content": "Similiar with solution https://leetcode.com/problems/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n/discuss/585590/C%2B%2BJava-DFS-and-Math\\n\\nwe can treat the index as a binary number to figure out which letter should be used.\\nFor example, n = 3, the combinations start with c\\n[0] cab  => 00\\n[1] cac  => 01\\n[2] cba  => 10\\n[3] cbc  => 11\\n\\n0 mean choose the front letter, 1 mean choose the later letter\\n\\n```\\n    string getHappyString(int n, int k) {\\n        int m = 1 << (n-1); //combination for starting with a,b or c\\n        if(k > 3*m)\\n            return \"\";\\n        \\n        string s = string(1, \\'a\\' + (k-1)/m); //starting letter\\n        int idx = (k-1)%m; //index in the combination\\n        while(m>1) {\\n            m = m >>1; \\n            if(idx & m) { //check if it is front half\\n                s += s.back() != \\'c\\'? \\'c\\':\\'b\\';\\n            } else {\\n                s += s.back() != \\'a\\'? \\'a\\':\\'b\\';\\n            }\\n        }\\n        \\n        return s;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    string getHappyString(int n, int k) {\\n        int m = 1 << (n-1); //combination for starting with a,b or c\\n        if(k > 3*m)\\n            return \"\";\\n        \\n        string s = string(1, \\'a\\' + (k-1)/m); //starting letter\\n        int idx = (k-1)%m; //index in the combination\\n        while(m>1) {\\n            m = m >>1; \\n            if(idx & m) { //check if it is front half\\n                s += s.back() != \\'c\\'? \\'c\\':\\'b\\';\\n            } else {\\n                s += s.back() != \\'a\\'? \\'a\\':\\'b\\';\\n            }\\n        }\\n        \\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 919478,
                "title": "python-backtracking-solution-what-is-the-time-complexity-of-that",
                "content": "Hello, I have written the code below and I am wondering what is the time complexity of it. I would say it is O(c), where, c, when generalized, is a number of all possible combinations. Any thoughts?\\n\\n\\tclass Solution:\\n\\t\\tdef getHappyString(self, n: int, k: int) -> str:\\n\\t\\t\\tif k < 1 or n < 1:\\n\\t\\t\\t\\treturn \"\"\\n\\n\\t\\t\\tfound = 0\\n\\t\\t\\tdef backtrack(candidate, last):\\n\\t\\t\\t\\tif len(candidate) == n:\\n\\t\\t\\t\\t\\tnonlocal found\\n\\t\\t\\t\\t\\tfound += 1\\n\\t\\t\\t\\t\\treturn candidate if found == k else None\\n\\n\\t\\t\\t\\tfor letter in \"abc\":\\n\\t\\t\\t\\t\\tif letter != last:\\n\\t\\t\\t\\t\\t\\tcandidate.append(letter)\\n\\t\\t\\t\\t\\t\\tans = backtrack(candidate, letter)\\n\\t\\t\\t\\t\\t\\tif ans:\\n\\t\\t\\t\\t\\t\\t\\treturn ans\\n\\t\\t\\t\\t\\t\\tcandidate.pop()\\n\\t\\t\\t\\treturn None\\n\\n\\t\\t\\tans = backtrack([], None)\\n\\t\\t\\treturn \"\".join(ans) if ans else \"\"",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "Hello, I have written the code below and I am wondering what is the time complexity of it. I would say it is O(c), where, c, when generalized, is a number of all possible combinations. Any thoughts?\\n\\n\\tclass Solution:\\n\\t\\tdef getHappyString(self, n: int, k: int) -> str:\\n\\t\\t\\tif k < 1 or n < 1:\\n\\t\\t\\t\\treturn \"\"\\n\\n\\t\\t\\tfound = 0\\n\\t\\t\\tdef backtrack(candidate, last):\\n\\t\\t\\t\\tif len(candidate) == n:\\n\\t\\t\\t\\t\\tnonlocal found\\n\\t\\t\\t\\t\\tfound += 1\\n\\t\\t\\t\\t\\treturn candidate if found == k else None\\n\\n\\t\\t\\t\\tfor letter in \"abc\":\\n\\t\\t\\t\\t\\tif letter != last:\\n\\t\\t\\t\\t\\t\\tcandidate.append(letter)\\n\\t\\t\\t\\t\\t\\tans = backtrack(candidate, letter)\\n\\t\\t\\t\\t\\t\\tif ans:\\n\\t\\t\\t\\t\\t\\t\\treturn ans\\n\\t\\t\\t\\t\\t\\tcandidate.pop()\\n\\t\\t\\t\\treturn None\\n\\n\\t\\t\\tans = backtrack([], None)\\n\\t\\t\\treturn \"\".join(ans) if ans else \"\"",
                "codeTag": "Java"
            },
            {
                "id": 903563,
                "title": "python-3-direct-calculation-solution-faster-than-99",
                "content": "This solution could be generalized to letters of any size. \\nHere the solution used the fact that, if allowed string length is ``n``, then the total qualified string will be ``3*(2**(n-1))``. (The first element of string has ``3`` choices, however the rest locations all have ``2`` choices. ) Given ``k``, if ``k`` is larger than the number it will go out of bounds. Now the purpose is to identify the proper index at each location, which is similar to convert an integer to base-3 number. \\nFor example, if ``n=3`` and ``k=9``, all possible index strings are: ``010, 012, 020, 021, 101, 102, 120, 121, 201, 202, 210, 212``. ``k=9`` would be divided by ``2**2=4`` to identify the first index, then ``2**1=2`` for the second, and ``1`` at last. \\n* Special case: if ``k`` could be divided without remainders, then the index should minus 1, and remainder reset to the divisor, to keep going.  \\n* To avoid current letter is the same as previous one, it should be picked from an alternative string, which excludes previous letter. This is what dictionary ``S`` is about. \\n\\n```python\\n    def getHappyString(self, n: int, k: int) -> str:\\n        S = {\"#\":\\'abc\\', \\'a\\':\\'bc\\', \\'b\\':\\'ac\\', \\'c\\':\\'ab\\'}\\n        res = \"#\"\\n        maxK = 2**(n-1)\\n        if maxK*3 < k: return \"\"\\n        while maxK > 0:\\n            d, k = divmod(k, maxK)\\n            if k==0:\\n                d -= 1\\n                k = maxK\\n            res += S[res[-1]][d]\\n            maxK //= 2\\n        return res[1:]\\n```",
                "solutionTags": [],
                "code": "```python\\n    def getHappyString(self, n: int, k: int) -> str:\\n        S = {\"#\":\\'abc\\', \\'a\\':\\'bc\\', \\'b\\':\\'ac\\', \\'c\\':\\'ab\\'}\\n        res = \"#\"\\n        maxK = 2**(n-1)\\n        if maxK*3 < k: return \"\"\\n        while maxK > 0:\\n            d, k = divmod(k, maxK)\\n            if k==0:\\n                d -= 1\\n                k = maxK\\n            res += S[res[-1]][d]\\n            maxK //= 2\\n        return res[1:]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 870649,
                "title": "python-o-n-solution-beats-97",
                "content": "This solution is based on the observation that\\n1. the first character has three different choices;\\n2. each of the rest has two different choices.\\n```python\\ndef getHappyString(self, n: int, k: int) -> str:\\n    m = 1 << (n-1)\\n    l = []\\n    if k <= m:\\n        l.append(\\'a\\')\\n    elif k <= 2 * m:\\n        l.append(\\'b\\')\\n        k -= m\\n    elif k <= 3 * m:\\n        l.append(\\'c\\')\\n        k -= 2 * m\\n    else:\\n        return \\'\\'\\n    m >>= 1\\n\\n    while m:\\n        if k <= m:\\n            l.append(\\'b\\' if l[-1] == \\'a\\' else \\'a\\')\\n        else:\\n            l.append(\\'b\\' if l[-1] == \\'c\\' else \\'c\\')\\n            k -= m\\n        m >>= 1\\n\\n    return \\'\\'.join(l)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\ndef getHappyString(self, n: int, k: int) -> str:\\n    m = 1 << (n-1)\\n    l = []\\n    if k <= m:\\n        l.append(\\'a\\')\\n    elif k <= 2 * m:\\n        l.append(\\'b\\')\\n        k -= m\\n    elif k <= 3 * m:\\n        l.append(\\'c\\')\\n        k -= 2 * m\\n    else:\\n        return \\'\\'\\n    m >>= 1\\n\\n    while m:\\n        if k <= m:\\n            l.append(\\'b\\' if l[-1] == \\'a\\' else \\'a\\')\\n        else:\\n            l.append(\\'b\\' if l[-1] == \\'c\\' else \\'c\\')\\n            k -= m\\n        m >>= 1\\n\\n    return \\'\\'.join(l)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 854340,
                "title": "easy-c-solution-with-dfs-without-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSafe(int index, string& pattern, string& result) {\\n        if(result.size() == 0) return true;\\n        if(pattern[index] != result[result.size()-1]) return true;\\n        return false;\\n    }\\n    void dfs(int n, string& pattern, string result, vector<string>& ans){\\n        if(n==0) {\\n            ans.push_back(result);\\n            return;\\n        }\\n        \\n        for(int i=0; i<pattern.length(); i++) {\\n            if(isSafe(i,pattern, result)) {\\n                dfs(n-1, pattern, result+pattern[i], ans);\\n            }\\n        }\\n        \\n    }\\n    \\n    string getHappyString(int n, int k) {\\n        vector<string> ans;\\n        string pattern = \"abc\";\\n        string result = \"\";\\n        dfs(n, pattern, result, ans);\\n       // sort(ans.begin(), ans.end());\\n        if(ans.size() < k) return \"\";\\n        return ans[k-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSafe(int index, string& pattern, string& result) {\\n        if(result.size() == 0) return true;\\n        if(pattern[index] != result[result.size()-1]) return true;\\n        return false;\\n    }\\n    void dfs(int n, string& pattern, string result, vector<string>& ans){\\n        if(n==0) {\\n            ans.push_back(result);\\n            return;\\n        }\\n        \\n        for(int i=0; i<pattern.length(); i++) {\\n            if(isSafe(i,pattern, result)) {\\n                dfs(n-1, pattern, result+pattern[i], ans);\\n            }\\n        }\\n        \\n    }\\n    \\n    string getHappyString(int n, int k) {\\n        vector<string> ans;\\n        string pattern = \"abc\";\\n        string result = \"\";\\n        dfs(n, pattern, result, ans);\\n       // sort(ans.begin(), ans.end());\\n        if(ans.size() < k) return \"\";\\n        return ans[k-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843354,
                "title": "c-dfs-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    string getHappyString(int n, int k) {\\n        string cur;\\n        char pre = \\'*\\';\\n        dfs(cur, pre, n, k);\\n        return res;\\n    }\\n    \\n    void dfs(string& cur, char pre, int n, int k){\\n        if(count == k) return;\\n        if(cur.size() == n){\\n            if(++count == k) res = cur;\\n            return;\\n        }\\n        for(char c : {\\'a\\', \\'b\\', \\'c\\'}){\\n            if(c == pre) continue;\\n            cur+=c;\\n            dfs(cur, c, n, k);\\n            cur.pop_back();\\n        }\\n    }    \\n    \\n    string res;\\n    int count = 0;\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string getHappyString(int n, int k) {\\n        string cur;\\n        char pre = \\'*\\';\\n        dfs(cur, pre, n, k);\\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 767550,
                "title": "c-o-n-faster-than-100-using-math-and-buckets",
                "content": "We can build the string from the given k value based on the total number of possible combinations and the properties of lexographical ordering. \\n\\nFirst, understand how many total strings there are. You have 3 choices for the first character, and 2 choices for each succeeding character which makes 3 * 2 ^ (n-1). Because you are looking for a certain string in lexographical order, you can divide this number into buckets to build the string. The first character will be an \\'a\\', \\'b\\', or \\'c\\' based on what third of the total k falls into. For the remaining part of the string, we check whether the relative k falls into the first half or second half, and pick a character from a sorted map based on this.\\n\\'\\'\\' \\n`string getHappyString(int n, int k) {`\\n       \\n\\t   string res;\\n        \\n        int factor = pow(2,(n-1));\\n        // cout << factor << \"\\\\n\";\\n        int total = 3*factor;\\n        \\n        if (k <= factor) {\\n            res.push_back(\\'a\\');\\n        } else if (k <= 2*factor) {\\n            res.push_back(\\'b\\');\\n            k-= factor;\\n        } else if (k <= 3*factor) {\\n            res.push_back(\\'c\\');\\n            k-= 2*factor;\\n        } else {\\n            return res;\\n        }\\n        \\n        char prev = res[0];\\n        unordered_map<char, int> index ({{\\'a\\',0}, {\\'b\\',1}, {\\'c\\',2}});\\n        while (res.size() < n) {\\n            vector<char> possible {\\'a\\',\\'b\\',\\'c\\'};\\n            possible.erase(possible.begin() + index[prev]);\\n            //cout << \"possible: \" << possible[0] << \" \" << possible[1] << \" \";\\n            //cout << \"k \" << k << \" factor \" << factor << \"\\\\n\";\\n            \\n            if (k <= factor / 2) {\\n                res.push_back(possible[0]);\\n                prev = possible[0];\\n            } else {\\n                k-= factor / 2;\\n                res.push_back(possible[1]);\\n                prev = possible[1];\\n            }\\n            \\n            factor = factor/2;\\n        }\\n        \\n        return res;\\n        \\n    }\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "We can build the string from the given k value based on the total number of possible combinations and the properties of lexographical ordering. \\n\\nFirst, understand how many total strings there are. You have 3 choices for the first character, and 2 choices for each succeeding character which makes 3 * 2 ^ (n-1). Because you are looking for a certain string in lexographical order, you can divide this number into buckets to build the string. The first character will be an \\'a\\', \\'b\\', or \\'c\\' based on what third of the total k falls into. For the remaining part of the string, we check whether the relative k falls into the first half or second half, and pick a character from a sorted map based on this.\\n\\'\\'\\' \\n`string getHappyString(int n, int k) {`\\n       \\n\\t   string res;\\n        \\n        int factor = pow(2,(n-1));\\n        // cout << factor << \"\\\\n\";\\n        int total = 3*factor;\\n        \\n        if (k <= factor) {\\n            res.push_back(\\'a\\');\\n        } else if (k <= 2*factor) {\\n            res.push_back(\\'b\\');\\n            k-= factor;\\n        } else if (k <= 3*factor) {\\n            res.push_back(\\'c\\');\\n            k-= 2*factor;\\n        } else {\\n            return res;\\n        }\\n        \\n        char prev = res[0];\\n        unordered_map<char, int> index ({{\\'a\\',0}, {\\'b\\',1}, {\\'c\\',2}});\\n        while (res.size() < n) {\\n            vector<char> possible {\\'a\\',\\'b\\',\\'c\\'};\\n            possible.erase(possible.begin() + index[prev]);\\n            //cout << \"possible: \" << possible[0] << \" \" << possible[1] << \" \";\\n            //cout << \"k \" << k << \" factor \" << factor << \"\\\\n\";\\n            \\n            if (k <= factor / 2) {\\n                res.push_back(possible[0]);\\n                prev = possible[0];\\n            } else {\\n                k-= factor / 2;\\n                res.push_back(possible[1]);\\n                prev = possible[1];\\n            }\\n            \\n            factor = factor/2;\\n        }\\n        \\n        return res;\\n        \\n    }\\n\\'\\'\\'",
                "codeTag": "C++"
            },
            {
                "id": 746697,
                "title": "java-dfs-backtracking-4ms",
                "content": "Here the approach is nothing but trying all the possibilities(loop through \\'a\\' to \\'c\\' strictly to make the string lexographically ordered) with a given condition that no adjust characters are same\\n```\\nclass Solution {\\n    int count=0;\\n    String ans=\"\";\\n    \\n    void solve(StringBuilder sb,int n, char[] arr,int k){\\n       \\n        if(count > k) return;\\n        if(n==0){ \\n            count++;\\n            if(count == k) ans = sb.toString();\\n            return;\\n        }\\n    \\n        for(int i=0;i<3;i++){\\n            if(sb.length()>0 && arr[i] == sb.charAt(sb.length()-1)) continue;\\n            sb.append(arr[i]);\\n            solve(sb,n-1,arr,k);\\n            sb.setLength(sb.length()-1); //backtrack\\n        }\\n    }\\n    \\n    public String getHappyString(int n, int k) {\\n       char[] arr = {\\'a\\',\\'b\\',\\'c\\'};\\n       solve(new StringBuilder(\"\"),n,arr,k);\\n       return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int count=0;\\n    String ans=\"\";\\n    \\n    void solve(StringBuilder sb,int n, char[] arr,int k){\\n       \\n        if(count > k) return;\\n        if(n==0){ \\n            count++;\\n            if(count == k) ans = sb.toString();\\n            return;\\n        }\\n    \\n        for(int i=0;i<3;i++){\\n            if(sb.length()>0 && arr[i] == sb.charAt(sb.length()-1)) continue;\\n            sb.append(arr[i]);\\n            solve(sb,n-1,arr,k);\\n            sb.setLength(sb.length()-1); //backtrack\\n        }\\n    }\\n    \\n    public String getHappyString(int n, int k) {\\n       char[] arr = {\\'a\\',\\'b\\',\\'c\\'};\\n       solve(new StringBuilder(\"\"),n,arr,k);\\n       return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 734068,
                "title": "super-simple-and-easy-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void helper(int k,int n,vector<string> &v,  string current,string d){\\n        \\n        \\n        if(k==v.size()){\\n            return;\\n        }\\n        if(current.size()==n){\\n            v.push_back(current);\\n            return;\\n        }\\n        for(int i=0;i<3;i++){\\n            if(current.size()==0 || current[current.size()-1]!=d[i]){\\n                current+=d[i];\\n                helper(k,n,v,current,d);\\n                current.pop_back();\\n            }\\n        }\\n        \\n        \\n        \\n    }\\n    \\n    string getHappyString(int n, int k) {\\n\\n        \\n        string d=\"abc\";\\n        vector<string> v;\\n        helper(k,n,v,\"\",d);\\n        if(v.size()==k){\\n            return v[v.size()-1];\\n        }\\n        \\n        return \"\";\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void helper(int k,int n,vector<string> &v,  string current,string d){\\n        \\n        \\n        if(k==v.size()){\\n            return;\\n        }\\n        if(current.size()==n){\\n            v.push_back(current);\\n            return;\\n        }\\n        for(int i=0;i<3;i++){\\n            if(current.size()==0 || current[current.size()-1]!=d[i]){\\n                current+=d[i];\\n                helper(k,n,v,current,d);\\n                current.pop_back();\\n            }\\n        }\\n        \\n        \\n        \\n    }\\n    \\n    string getHappyString(int n, int k) {\\n\\n        \\n        string d=\"abc\";\\n        vector<string> v;\\n        helper(k,n,v,\"\",d);\\n        if(v.size()==k){\\n            return v[v.size()-1];\\n        }\\n        \\n        return \"\";\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 718022,
                "title": "c-o-n-explained-simple-maths",
                "content": "The total possibilities are calculated using value *possibilities*= 3* 2* 2* 2* ....(upto length n).. Consider the fact that the first character has 3 possibilites=(a,b,c) but from the 2nd character, due to restrictions of creating happy strings, we have only 2 possbilities for every leftover place.. Now, if k>total possibilities, we return blank string, but if k < *possibilities*, we calculate a variable quanta which denotes what is the character to be placed at current index.  For example, if  the string length is 3, there exist 3* 2* 2 =12 possibilities. If keep \\'a\\' at 1st place then there exist 4 (=12/3) variations of happy strings for the leftover 2 places. Moving forward,  if we keep \\'b\\' at 2nd place  (as it is the lowest possible lexographical value), there exist 2 more variations after it for the leftover place. This quanta represents how much variations of happy strings we will cover for every increment in current position. As an example, for n=3, and calculating quanta for 1st position, if we move from a->b at index 1, we cover 4 variations=(\"aba\",abc,\"aca\"\"acb\") and if we move from a->c at index 1, we cover 8 variations=(\"aba\",abc,\"aca\"\"acb\",\"bab\",\"bac\",\"bca\",\"bcb\"). Hence we calculate quanta for every position and choose a  a character for that place. After choosing, we update the possible sequence of characters for next position. this is done in vector<string> *S*.\\n  ```  \\n    string getHappyString(int n, int k) {\\n     int possibilities=3;\\n        \\n     string ans=\"\";\\n\\n        for(int i=1;i<n;i++)   \\n            possibilities=possibilities*2;\\n        if(k>possibilities)\\n            return ans;\\n        else\\n        {\\n            vector<string>S={\"a\",\"b\",\"c\"};\\n            int leftover=k-1;  // -1 is to make it 0 index.\\n            int i=0;\\n            while(ans.length()<n)\\n            {\\n                int quanta=possibilities/(i==0?3:2);  //GEt QUANTA\\n                ans=ans+S[(leftover/quanta)];    //APPEND CHARACTER TO ANS\\n                \\n                /* UPDATE POSSIBLE VECTOR FOR CHOOSING OF NEXT CHARACTER.*/\\n                if(ans[ans.length()-1]==\\'a\\')\\n                    S={\"b\",\"c\"};\\n                else if(ans[ans.length()-1]==\\'b\\')\\n                    S={\"a\",\"c\"};\\n                else if(ans[ans.length()-1]==\\'c\\')\\n                    S={\"a\",\"b\"};\\n                \\n                leftover=leftover%quanta;      \\n                possibilities=possibilities/(i==0?3:2);  //UPDATING LEFTOVER POSSIBILITIES\\n                i++;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n\\t",
                "solutionTags": [],
                "code": "The total possibilities are calculated using value *possibilities*= 3* 2* 2* 2* ....(upto length n).. Consider the fact that the first character has 3 possibilites=(a,b,c) but from the 2nd character, due to restrictions of creating happy strings, we have only 2 possbilities for every leftover place.. Now, if k>total possibilities, we return blank string, but if k < *possibilities*, we calculate a variable quanta which denotes what is the character to be placed at current index.  For example, if  the string length is 3, there exist 3* 2* 2 =12 possibilities. If keep \\'a\\' at 1st place then there exist 4 (=12/3) variations of happy strings for the leftover 2 places. Moving forward,  if we keep \\'b\\' at 2nd place  (as it is the lowest possible lexographical value), there exist 2 more variations after it for the leftover place. This quanta represents how much variations of happy strings we will cover for every increment in current position. As an example, for n=3, and calculating quanta for 1st position, if we move from a->b at index 1, we cover 4 variations=(\"aba\",abc,\"aca\"\"acb\") and if we move from a->c at index 1, we cover 8 variations=(\"aba\",abc,\"aca\"\"acb\",\"bab\",\"bac\",\"bca\",\"bcb\"). Hence we calculate quanta for every position and choose a  a character for that place. After choosing, we update the possible sequence of characters for next position. this is done in vector<string> *S*.\\n  ```  \\n    string getHappyString(int n, int k) {\\n     int possibilities=3;\\n        \\n     string ans=\"\";\\n\\n        for(int i=1;i<n;i++)   \\n            possibilities=possibilities*2;\\n        if(k>possibilities)\\n            return ans;\\n        else\\n        {\\n            vector<string>S={\"a\",\"b\",\"c\"};\\n            int leftover=k-1;  // -1 is to make it 0 index.\\n            int i=0;\\n            while(ans.length()<n)\\n            {\\n                int quanta=possibilities/(i==0?3:2);  //GEt QUANTA\\n                ans=ans+S[(leftover/quanta)];    //APPEND CHARACTER TO ANS\\n                \\n                /* UPDATE POSSIBLE VECTOR FOR CHOOSING OF NEXT CHARACTER.*/\\n                if(ans[ans.length()-1]==\\'a\\')\\n                    S={\"b\",\"c\"};\\n                else if(ans[ans.length()-1]==\\'b\\')\\n                    S={\"a\",\"c\"};\\n                else if(ans[ans.length()-1]==\\'c\\')\\n                    S={\"a\",\"b\"};\\n                \\n                leftover=leftover%quanta;      \\n                possibilities=possibilities/(i==0?3:2);  //UPDATING LEFTOVER POSSIBILITIES\\n                i++;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 704660,
                "title": "straightforward-java-solution",
                "content": "```\\nclass Solution {\\n    public String getHappyString(int n, int k) {\\n        List<String> happyStrings = new ArrayList<>();\\n        char[] dict = new char[]{\\'a\\', \\'b\\', \\'c\\'};\\n        helper(dict, n, happyStrings, new ArrayList<>());\\n        Collections.sort(happyStrings, new Comparator<String>(){\\n            @Override\\n            public int compare(String a, String b) {\\n                return a.compareTo(b);\\n            }\\n        });\\n        return happyStrings.size() < k ? \"\" : happyStrings.get(k - 1);\\n    }\\n    \\n    public void helper(char[] dict, int n, List<String> happyStrings, List<Character> curr) {\\n        if (curr.size() == n) {\\n            StringBuilder sb = new StringBuilder();\\n            for (int i = 0; i < curr.size(); i++) {\\n                sb.append(curr.get(i));\\n            }\\n            happyStrings.add(sb.toString());\\n            return;\\n        }\\n        for (int i = 0; i < 3; i++) {\\n            if (curr.size() == 0 || dict[i] != curr.get(curr.size() - 1)) {\\n                curr.add(dict[i]);\\n                helper(dict, n, happyStrings, curr);\\n                curr.remove(curr.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String getHappyString(int n, int k) {\\n        List<String> happyStrings = new ArrayList<>();\\n        char[] dict = new char[]{\\'a\\', \\'b\\', \\'c\\'};\\n        helper(dict, n, happyStrings, new ArrayList<>());\\n        Collections.sort(happyStrings, new Comparator<String>(){\\n            @Override\\n            public int compare(String a, String b) {\\n                return a.compareTo(b);\\n            }\\n        });\\n        return happyStrings.size() < k ? \"\" : happyStrings.get(k - 1);\\n    }\\n    \\n    public void helper(char[] dict, int n, List<String> happyStrings, List<Character> curr) {\\n        if (curr.size() == n) {\\n            StringBuilder sb = new StringBuilder();\\n            for (int i = 0; i < curr.size(); i++) {\\n                sb.append(curr.get(i));\\n            }\\n            happyStrings.add(sb.toString());\\n            return;\\n        }\\n        for (int i = 0; i < 3; i++) {\\n            if (curr.size() == 0 || dict[i] != curr.get(curr.size() - 1)) {\\n                curr.add(dict[i]);\\n                helper(dict, n, happyStrings, curr);\\n                curr.remove(curr.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 666045,
                "title": "java-easy-to-understand",
                "content": "\\tpublic String getHappyString(int n, int k) {\\n\\t\\tList<String> happyStrings = new ArrayList<>();\\n\\t\\tbuildHappyStrings(happyStrings, new char[]{\\'a\\', \\'b\\', \\'c\\'}, n, \"\");\\n\\t\\treturn happyStrings.size() >= k ? happyStrings.get(k - 1) : \"\";\\n\\t}\\n\\t\\n\\tprivate void buildHappyStrings(List<String> happyStrings, char[] chars, int n, String s) {\\n\\t\\tif (n == s.length()) {\\n\\t\\t\\thappyStrings.add(s);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (char c : chars) {\\n\\t\\t\\tif (s.isEmpty() || c != s.charAt(s.length() - 1)) {\\n\\t\\t\\t\\tbuildHappyStrings(happyStrings, chars, n, s + c);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "\\tpublic String getHappyString(int n, int k) {\\n\\t\\tList<String> happyStrings = new ArrayList<>();\\n\\t\\tbuildHappyStrings(happyStrings, new char[]{\\'a\\', \\'b\\', \\'c\\'}, n, \"\");\\n\\t\\treturn happyStrings.size() >= k ? happyStrings.get(k - 1) : \"\";\\n\\t}\\n\\t\\n\\tprivate void buildHappyStrings(List<String> happyStrings, char[] chars, int n, String s) {\\n\\t\\tif (n == s.length()) {\\n\\t\\t\\thappyStrings.add(s);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (char c : chars) {\\n\\t\\t\\tif (s.isEmpty() || c != s.charAt(s.length() - 1)) {\\n\\t\\t\\t\\tbuildHappyStrings(happyStrings, chars, n, s + c);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 598856,
                "title": "java-dfs-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String getHappyString(int n, int k) {\\n        List<String> result = new ArrayList<>();\\n        dfs(result,  \"\", n, k);\\n        if(k > result.size()) \\n            return \"\";\\n        return result.get(k-1);\\n    }\\n    void dfs(List<String> result, String cur, int n, int k) {\\n        if(result.size() > k + 1) \\n            return;\\n        if(cur.length() == n)  {\\n            result.add(cur);\\n            return;\\n        }\\n        char [] chars = \"abc\".toCharArray();\\n        for(char c : chars) {\\n            if(cur.length() > 0 && c == cur.charAt(cur.length() -1)) \\n                continue;\\n            dfs(result, cur + String.valueOf(c), n,k);\\n        }\\n        return ; \\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String getHappyString(int n, int k) {\\n        List<String> result = new ArrayList<>();\\n        dfs(result,  \"\", n, k);\\n        if(k > result.size()) \\n            return \"\";\\n        return result.get(k-1);\\n    }\\n    void dfs(List<String> result, String cur, int n, int k) {\\n        if(result.size() > k + 1) \\n            return;\\n        if(cur.length() == n)  {\\n            result.add(cur);\\n            return;\\n        }\\n        char [] chars = \"abc\".toCharArray();\\n        for(char c : chars) {\\n            if(cur.length() > 0 && c == cur.charAt(cur.length() -1)) \\n                continue;\\n            dfs(result, cur + String.valueOf(c), n,k);\\n        }\\n        return ; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 593727,
                "title": "classical-backtrack-with-o-n-k-time-complexity-in-c",
                "content": "```\\n// time complexity : O(n * k) \\n// space complexity : O(n)\\nclass Solution {\\npublic:\\n    string getHappyString(int n, int k) {\\n        string res, s;\\n        backtrack(n, k, s, res);\\n        return res;\\n    }\\n    \\nprivate:\\n    void backtrack(int n, int& k, string& s, string& res) {\\n        if (!res.empty()) return;  // prune\\n        if (n == 0) {  // a solution\\n            if (k-- == 1) res = s; // the kth solution\\n            return;\\n        }\\n        for (char ch = \\'a\\'; ch <= \\'c\\'; ++ch) {\\n            if (!s.empty() && s.back() == ch) continue;\\n            s += ch;\\n            backtrack(n - 1, k, s, res);\\n            s.pop_back();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// time complexity : O(n * k) \\n// space complexity : O(n)\\nclass Solution {\\npublic:\\n    string getHappyString(int n, int k) {\\n        string res, s;\\n        backtrack(n, k, s, res);\\n        return res;\\n    }\\n    \\nprivate:\\n    void backtrack(int n, int& k, string& s, string& res) {\\n        if (!res.empty()) return;  // prune\\n        if (n == 0) {  // a solution\\n            if (k-- == 1) res = s; // the kth solution\\n            return;\\n        }\\n        for (char ch = \\'a\\'; ch <= \\'c\\'; ++ch) {\\n            if (!s.empty() && s.back() == ch) continue;\\n            s += ch;\\n            backtrack(n - 1, k, s, res);\\n            s.pop_back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 592559,
                "title": "javascript-solution",
                "content": "```\\nvar getHappyString = function(n, k) {\\n    const res = [];\\n    const letters = [\\'a\\', \\'b\\', \\'c\\'];\\n    \\n    backtrack(n, res, letters, \"\", \"\");\\n    if (res.length < k) return \"\";\\n    return res[k - 1];\\n};\\n\\nfunction backtrack(n, res, letters, prefix, prev) {\\n    if (prefix.length === n) {\\n        res.push(prefix);\\n        return;\\n    }\\n    \\n    for (let i = 0; i < 3; i++) {\\n        if (prev === letters[i]) continue;\\n        backtrack(n, res, letters, prefix + letters[i], letters[i]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getHappyString = function(n, k) {\\n    const res = [];\\n    const letters = [\\'a\\', \\'b\\', \\'c\\'];\\n    \\n    backtrack(n, res, letters, \"\", \"\");\\n    if (res.length < k) return \"\";\\n    return res[k - 1];\\n};\\n\\nfunction backtrack(n, res, letters, prefix, prev) {\\n    if (prefix.length === n) {\\n        res.push(prefix);\\n        return;\\n    }\\n    \\n    for (let i = 0; i < 3; i++) {\\n        if (prev === letters[i]) continue;\\n        backtrack(n, res, letters, prefix + letters[i], letters[i]);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 590119,
                "title": "c-dumb-solution",
                "content": "Nothing smart about this solution but you can pass the probleme quickly in a contest or be a first solution to improve on during interview\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> all;\\n    void generate(string pre, int n){\\n        if(pre.size()==n){\\n            all.push_back(pre);\\n            return;\\n        }\\n        if(!pre.size() || pre.back()!=\\'a\\') generate(pre+\"a\",n);\\n        if(!pre.size() || pre.back()!=\\'b\\') generate(pre+\"b\",n);\\n        if(!pre.size() || pre.back()!=\\'c\\') generate(pre+\"c\",n);\\n    }\\n    string getHappyString(int n, int k) {\\n        generate(\"\", n);\\n        return all.size() < k ? \"\" : all[k-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> all;\\n    void generate(string pre, int n){\\n        if(pre.size()==n){\\n            all.push_back(pre);\\n            return;\\n        }\\n        if(!pre.size() || pre.back()!=\\'a\\') generate(pre+\"a\",n);\\n        if(!pre.size() || pre.back()!=\\'b\\') generate(pre+\"b\",n);\\n        if(!pre.size() || pre.back()!=\\'c\\') generate(pre+\"c\",n);\\n    }\\n    string getHappyString(int n, int k) {\\n        generate(\"\", n);\\n        return all.size() < k ? \"\" : all[k-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 589380,
                "title": "javascript-python3-c-dfs-bt",
                "content": "**Synopsis:**\\n\\nNaive DFS + BT algorithm to find all happy strings in lexicographical order.  Return the K-th happy string if it exists, otherwise, return an empty string.\\n\\n---\\n\\n*Javascript*\\n```\\nlet getHappyString = (N, K, ans = \\'\\') => {\\n    let go = (i = 0, path = []) => {\\n        if (!K)\\n            return;\\n        if (i == N) {\\n            if (!--K)\\n                ans = path.join(\\'\\'); // \\uD83C\\uDFAF K-th happy string\\n            return;\\n        }\\n        for (let c of [\\'a\\', \\'b\\', \\'c\\'])\\n            if (!path.length || c != path[path.length - 1])\\n                go(i + 1, path.concat(c)); // \\uD83D\\uDE80 DFS explore path \\u2B50\\uFE0F with implicit path forward/back-tracking \\uD83D\\uDC40\\n    };\\n    go();\\n    return ans;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def getHappyString(self, N: int, K: int, ans = \\'\\') -> str:\\n        def go(i = 0, path = []):\\n            nonlocal ans, K\\n            if not K:\\n                return\\n            if i == N:\\n                K -= 1\\n                if not K:\\n                    ans = \\'\\'.join(path) # \\uD83C\\uDFAF K-th happy string\\n                return\\n            for c in [\\'a\\', \\'b\\', \\'c\\']:\\n                if not len(path) or c != path[-1]:\\n                    path.append(c)  # \\uD83D\\uDC40 \\u2705 path forward-tracking\\n                    go(i + 1, path) # \\uD83D\\uDE80 DFS explore path\\n                    path.pop()      # \\uD83D\\uDC40 \\uD83D\\uDEAB path back-tracking\\n        go()\\n        return ans\\n```\\n\\n*C++*\\n```\\nclass Solution {\\n    string ans;\\n    int N, K;\\n    void go(int i = 0, string&& path = {}) {\\n        if (!K)\\n            return;\\n        if (i == N) {\\n            if (!--K)\\n                ans = path; // \\uD83C\\uDFAF K-th happy string\\n            return;\\n        }\\n        for (auto c: string{ \"abc\" })\\n            if (path.empty() || c != path.back())\\n                path.push_back(c),     // \\uD83D\\uDC40 \\u2705 path forward-tracking\\n                go(i + 1, move(path)), // \\uD83D\\uDE80 DFS explore path\\n                path.pop_back();       // \\uD83D\\uDC40 \\uD83D\\uDEAB path back-tracking\\n    }\\npublic:\\n    string getHappyString(int N_, int K_) {\\n        N = N_;\\n        K = K_;\\n        go();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet getHappyString = (N, K, ans = \\'\\') => {\\n    let go = (i = 0, path = []) => {\\n        if (!K)\\n            return;\\n        if (i == N) {\\n            if (!--K)\\n                ans = path.join(\\'\\'); // \\uD83C\\uDFAF K-th happy string\\n            return;\\n        }\\n        for (let c of [\\'a\\', \\'b\\', \\'c\\'])\\n            if (!path.length || c != path[path.length - 1])\\n                go(i + 1, path.concat(c)); // \\uD83D\\uDE80 DFS explore path \\u2B50\\uFE0F with implicit path forward/back-tracking \\uD83D\\uDC40\\n    };\\n    go();\\n    return ans;\\n};\\n```\n```\\nclass Solution:\\n    def getHappyString(self, N: int, K: int, ans = \\'\\') -> str:\\n        def go(i = 0, path = []):\\n            nonlocal ans, K\\n            if not K:\\n                return\\n            if i == N:\\n                K -= 1\\n                if not K:\\n                    ans = \\'\\'.join(path) # \\uD83C\\uDFAF K-th happy string\\n                return\\n            for c in [\\'a\\', \\'b\\', \\'c\\']:\\n                if not len(path) or c != path[-1]:\\n                    path.append(c)  # \\uD83D\\uDC40 \\u2705 path forward-tracking\\n                    go(i + 1, path) # \\uD83D\\uDE80 DFS explore path\\n                    path.pop()      # \\uD83D\\uDC40 \\uD83D\\uDEAB path back-tracking\\n        go()\\n        return ans\\n```\n```\\nclass Solution {\\n    string ans;\\n    int N, K;\\n    void go(int i = 0, string&& path = {}) {\\n        if (!K)\\n            return;\\n        if (i == N) {\\n            if (!--K)\\n                ans = path; // \\uD83C\\uDFAF K-th happy string\\n            return;\\n        }\\n        for (auto c: string{ \"abc\" })\\n            if (path.empty() || c != path.back())\\n                path.push_back(c),     // \\uD83D\\uDC40 \\u2705 path forward-tracking\\n                go(i + 1, move(path)), // \\uD83D\\uDE80 DFS explore path\\n                path.pop_back();       // \\uD83D\\uDC40 \\uD83D\\uDEAB path back-tracking\\n    }\\npublic:\\n    string getHappyString(int N_, int K_) {\\n        N = N_;\\n        K = K_;\\n        go();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 587403,
                "title": "rust-solution-with-vecdeque",
                "content": "```rust\\nimpl Solution {\\n    pub fn get_happy_string(n: i32, k: i32) -> String {\\n        let mut cc: VecDeque<Vec<char>> = VecDeque::from(vec![vec![\\'a\\'], vec![\\'b\\'], vec![\\'c\\']]);\\n\\t\\t\\n\\t\\t// break the loop when all vec in cc has length n \\n        while cc.front().unwrap().len() < n as usize {\\n            let vc = cc.pop_front().unwrap();\\n            for nc in \"abc\".chars() {\\n                if vc.last().unwrap() != &nc {\\n                    let mut x = vc.clone();\\n                    x.push(nc);\\n                    cc.push_back(x);\\n                }\\n            }\\n        }\\n        if cc.len() < k as usize { \"\".to_string() } else { cc[k as usize - 1].iter().collect::<String>()}\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn get_happy_string(n: i32, k: i32) -> String {\\n        let mut cc: VecDeque<Vec<char>> = VecDeque::from(vec![vec![\\'a\\'], vec![\\'b\\'], vec![\\'c\\']]);\\n\\t\\t\\n\\t\\t// break the loop when all vec in cc has length n \\n        while cc.front().unwrap().len() < n as usize {\\n            let vc = cc.pop_front().unwrap();\\n            for nc in \"abc\".chars() {\\n                if vc.last().unwrap() != &nc {\\n                    let mut x = vc.clone();\\n                    x.push(nc);\\n                    cc.push_back(x);\\n                }\\n            }\\n        }\\n        if cc.len() < k as usize { \"\".to_string() } else { cc[k as usize - 1].iter().collect::<String>()}\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 586345,
                "title": "easy-to-understand-java-backtracking-choices-constraints-and-goal",
                "content": "```\\n\\n\\n\\n\\n//choice:- we can a,b,c to add;\\n//constraint; we cant put two alphabets together;\\n//goal: to generate strings till k;\\n\\n\\n\\n\\nclass Solution {\\n    List<String> list=new ArrayList<>();\\n    public String getHappyString(int n, int k) {\\n        \\n        //\"\" current string;\\n        //size\\n        //k\\n        //last digit;\\n        \\n        backtrack(\"\",null,n,k);  \\n        \\n        System.out.println(Arrays.toString(list.toArray()));\\n        if(list.size()>=k)\\n        {\\n            return list.get(k-1);\\n        }\\n        else\\n        {\\n            return \"\";\\n        }\\n    }\\n    \\n    public void backtrack(String s,Character last,int n,int k)\\n    {\\n        //When length becomes equal to required length, add it to list;\\n        if(s.length()==n)\\n        {\\n            list.add(s);\\n            if(list.size()==k)\\n            {\\n                return;\\n            }\\n            return;\\n        }\\n        \\n        //now decisions; \\n        //if last character is null can add all;\\n        \\n        //now we have decisions or choices;\\n        //if last character is null, we can add all a,b,c. Add lexo;\\n        \\n        // if last character is \\'a\\', we can only add b and c;\\n        // if last character is \\'b\\', we can only add a and c;\\n        // if last character is \\'c\\', we can only add a and b;\\n        if(last==null)\\n        {\\n            backtrack(s+\\'a\\',\\'a\\',n,k);\\n            backtrack(s+\\'b\\',\\'b\\',n,k);\\n            backtrack(s+\\'c\\',\\'c\\',n,k);\\n        }\\n        else if(last==\\'a\\')\\n        {\\n            backtrack(s+\\'b\\',\\'b\\',n,k);\\n            backtrack(s+\\'c\\',\\'c\\',n,k);\\n        }\\n        else if(last==\\'b\\')\\n        {\\n            backtrack(s+\\'a\\',\\'a\\',n,k);\\n            backtrack(s+\\'c\\',\\'c\\',n,k);\\n        }\\n        else\\n        {\\n            backtrack(s+\\'a\\',\\'a\\',n,k);\\n            backtrack(s+\\'b\\',\\'b\\',n,k);\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\n\\n\\n//choice:- we can a,b,c to add;\\n//constraint; we cant put two alphabets together;\\n//goal: to generate strings till k;\\n\\n\\n\\n\\nclass Solution {\\n    List<String> list=new ArrayList<>();\\n    public String getHappyString(int n, int k) {\\n        \\n        //\"\" current string;\\n        //size\\n        //k\\n        //last digit;\\n        \\n        backtrack(\"\",null,n,k);  \\n        \\n        System.out.println(Arrays.toString(list.toArray()));\\n        if(list.size()>=k)\\n        {\\n            return list.get(k-1);\\n        }\\n        else\\n        {\\n            return \"\";\\n        }\\n    }\\n    \\n    public void backtrack(String s,Character last,int n,int k)\\n    {\\n        //When length becomes equal to required length, add it to list;\\n        if(s.length()==n)\\n        {\\n            list.add(s);\\n            if(list.size()==k)\\n            {\\n                return;\\n            }\\n            return;\\n        }\\n        \\n        //now decisions; \\n        //if last character is null can add all;\\n        \\n        //now we have decisions or choices;\\n        //if last character is null, we can add all a,b,c. Add lexo;\\n        \\n        // if last character is \\'a\\', we can only add b and c;\\n        // if last character is \\'b\\', we can only add a and c;\\n        // if last character is \\'c\\', we can only add a and b;\\n        if(last==null)\\n        {\\n            backtrack(s+\\'a\\',\\'a\\',n,k);\\n            backtrack(s+\\'b\\',\\'b\\',n,k);\\n            backtrack(s+\\'c\\',\\'c\\',n,k);\\n        }\\n        else if(last==\\'a\\')\\n        {\\n            backtrack(s+\\'b\\',\\'b\\',n,k);\\n            backtrack(s+\\'c\\',\\'c\\',n,k);\\n        }\\n        else if(last==\\'b\\')\\n        {\\n            backtrack(s+\\'a\\',\\'a\\',n,k);\\n            backtrack(s+\\'c\\',\\'c\\',n,k);\\n        }\\n        else\\n        {\\n            backtrack(s+\\'a\\',\\'a\\',n,k);\\n            backtrack(s+\\'b\\',\\'b\\',n,k);\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 586315,
                "title": "c-brute-force-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    string ans;\\n    string getHappyString(int n, int k) {\\n        string s;\\n        h(s, n, k);\\n        return ans;\\n    }\\n    \\n    bool h(string &s, int n, int &k) {\\n        \\n        if(s.size() >= n) {\\n            --k;\\n            if(k == 0){\\n                ans = s;\\n                return true;\\n            }\\n            return false;\\n        }\\n        for(int i = \\'a\\'; i <= \\'c\\'; ++i) {\\n            if(s.size() == 0 || s.back() != i) {\\n                s += i;\\n                if(h(s, n, k))\\n                    return true;\\n                s.pop_back();\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string ans;\\n    string getHappyString(int n, int k) {\\n        string s;\\n        h(s, n, k);\\n        return ans;\\n    }\\n    \\n    bool h(string &s, int n, int &k) {\\n        \\n        if(s.size() >= n) {\\n            --k;\\n            if(k == 0){\\n                ans = s;\\n                return true;\\n            }\\n            return false;\\n        }\\n        for(int i = \\'a\\'; i <= \\'c\\'; ++i) {\\n            if(s.size() == 0 || s.back() != i) {\\n                s += i;\\n                if(h(s, n, k))\\n                    return true;\\n                s.pop_back();\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 586154,
                "title": "python3-tree-traversal-with-explanation-o-n-time-o-1-memory",
                "content": "Note: \\n* Time Complexity is O(N) where N is length of the output string\\n* Space Complexity is O(1) without considering output string\\n\\n![image](https://assets.leetcode.com/users/yelmurat/image_1587245282.png)\\n\\nFrom the image above you could see that:\\n* Number of strings with length *n* is equal to 3*2^(n-1) =1.5*2^n # imagine three binary trees of depth *n-1* with  root as one of [\\'a\\', \\'b\\', \\'c\\']\\n* We do not need to generate all combinations as we could traverse by imaginary binary tree and construct(?) output string\\n\\n```\\n    def getHappyString(self, n: int, k: int) -> str:\\n        num = 1.5*2**n # number of strings with length n\\n        if k > num:\\n            return \\'\\'\\n\\n\\t\\tlo = 0 if k <= num//3 else num//3 if k <= 2*num//3 else 2*num//3 # lower bound of binary tree to which *k*th index belongs\\n        hi = lo+num//3                                                   # upper bougnd\\n        prev = \\'a\\' if k <= num//3 else \\'b\\' if k <= 2*num//3 else \\'c\\'  # first letter of output string\\n        ret = prev                                                    # start with first letter\\n\\t\\t\\n        combs = {\\'a\\':[\\'b\\', \\'c\\'], \\'b\\': [\\'a\\', \\'c\\'], \\'c\\':[\\'a\\',\\'b\\']}\\n        \\n        while lo+1 < hi:\\n            mid = (lo+hi)//2\\n            sub_comb_ind = k > mid                # 0 if k is going to the left subtree and 1 else\\n            curr = combs[prev][sub_comb_ind]      #  get corresponding *left *or *right* value considering *prev* \\n            ret += curr\\n            prev = curr\\n            if sub_comb_ind:\\n                lo = mid\\n            else:\\n                hi = mid\\n                \\n        return ret\\n```",
                "solutionTags": [
                    "Math",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n    def getHappyString(self, n: int, k: int) -> str:\\n        num = 1.5*2**n # number of strings with length n\\n        if k > num:\\n            return \\'\\'\\n\\n\\t\\tlo = 0 if k <= num//3 else num//3 if k <= 2*num//3 else 2*num//3 # lower bound of binary tree to which *k*th index belongs\\n        hi = lo+num//3                                                   # upper bougnd\\n        prev = \\'a\\' if k <= num//3 else \\'b\\' if k <= 2*num//3 else \\'c\\'  # first letter of output string\\n        ret = prev                                                    # start with first letter\\n\\t\\t\\n        combs = {\\'a\\':[\\'b\\', \\'c\\'], \\'b\\': [\\'a\\', \\'c\\'], \\'c\\':[\\'a\\',\\'b\\']}\\n        \\n        while lo+1 < hi:\\n            mid = (lo+hi)//2\\n            sub_comb_ind = k > mid                # 0 if k is going to the left subtree and 1 else\\n            curr = combs[prev][sub_comb_ind]      #  get corresponding *left *or *right* value considering *prev* \\n            ret += curr\\n            prev = curr\\n            if sub_comb_ind:\\n                lo = mid\\n            else:\\n                hi = mid\\n                \\n        return ret\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 585968,
                "title": "simple-java-recurssion",
                "content": "```\\nclass Solution {\\n    int count = 0;\\n    String ss = \"\";\\n     public String getHappyString(int n, int k) {\\n \\xA0 \\xA0 \\xA0 \\xA0 helper(\"\",, n, k);\\n         return ss;\\n    }\\n\\n \\xA0 \\xA0public void helper(String s, int n, int k) {\\n        if(s.length() == n){\\n            if(++count==k) ss = s;\\n            return;\\n        }\\n        for (int j = 0; j < 3; j++) {\\n               char c = (char) (\\'a\\' + j);\\n                int l = s.length();\\n                if (l==0 || s.charAt(l - 1) != c) {\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0helper(s + c, n, k);\\n                \\n            }\\n        }\\n\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int count = 0;\\n    String ss = \"\";\\n     public String getHappyString(int n, int k) {\\n \\xA0 \\xA0 \\xA0 \\xA0 helper(\"\",, n, k);\\n         return ss;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 585964,
                "title": "java-solution-easy-method-for-kth-lexicographical-string",
                "content": "```\\nclass Solution {\\n  public String getHappyString(int n, int k) {\\n\\n       char arr[] = new char[] {\\'a\\',\\'b\\',\\'c\\'};\\n       ArrayList<String> list = new ArrayList<String>();\\n       String str =\"\";\\n       findPerm(n,str,list,arr);\\n\\t   if(list.size()>=k)\\n\\t\\t   str =list.get(k-1);\\n\\t   return str;\\n       \\n}\\n\\npublic void findPerm(int n,String str,ArrayList<String> list,char arr[])\\n\\t{\\n\\t\\tif (n == 0) {\\n\\t\\t\\tlist.add(str);\\n\\t\\t\\treturn;\\n\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\t\\tif (str == \"\" || str.charAt(str.length() - 1) != arr[i]) {\\n\\t\\t\\t\\tString tr = str + arr[i];\\n\\t\\t\\t\\tfindPerm(n - 1, tr, list, arr);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  public String getHappyString(int n, int k) {\\n\\n       char arr[] = new char[] {\\'a\\',\\'b\\',\\'c\\'};\\n       ArrayList<String> list = new ArrayList<String>();\\n       String str =\"\";\\n       findPerm(n,str,list,arr);\\n\\t   if(list.size()>=k)\\n\\t\\t   str =list.get(k-1);\\n\\t   return str;\\n       \\n}\\n\\npublic void findPerm(int n,String str,ArrayList<String> list,char arr[])\\n\\t{\\n\\t\\tif (n == 0) {\\n\\t\\t\\tlist.add(str);\\n\\t\\t\\treturn;\\n\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\t\\tif (str == \"\" || str.charAt(str.length() - 1) != arr[i]) {\\n\\t\\t\\t\\tString tr = str + arr[i];\\n\\t\\t\\t\\tfindPerm(n - 1, tr, list, arr);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 585827,
                "title": "python-straightforward-dfs",
                "content": "Since DFS is going to preserve the order, no sorting is necessary. Instead, keep building a path by adding \\'a\\',\\'b\\',\\'c\\'. When the length of path is n, increment a count. When a count reaches k, we found a result.\\n\\n```py\\n    def getHappyString(self, n: int, k: int) -> str:\\n        choice = \\'abc\\'\\n        def dfs(path):\\n            if len(path) == n:\\n                self.cnt += 1\\n                if self.cnt == k:\\n                    self.res = path\\n                return\\n\\n            for i in range(len(choice)):\\n                if path and path[-1] == choice[i]: continue\\n                dfs(path + choice[i])\\n        \\n        self.res = \\'\\'\\n        self.cnt = 0\\n        dfs(\\'\\')\\n        return self.res\\n```\\t\\t",
                "solutionTags": [],
                "code": "```py\\n    def getHappyString(self, n: int, k: int) -> str:\\n        choice = \\'abc\\'\\n        def dfs(path):\\n            if len(path) == n:\\n                self.cnt += 1\\n                if self.cnt == k:\\n                    self.res = path\\n                return\\n\\n            for i in range(len(choice)):\\n                if path and path[-1] == choice[i]: continue\\n                dfs(path + choice[i])\\n        \\n        self.res = \\'\\'\\n        self.cnt = 0\\n        dfs(\\'\\')\\n        return self.res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 585811,
                "title": "dfs-solution",
                "content": "Simple DFS solution. I feel there definitly have a solution by using mathematical way... Please point me out if there\\'s any math way to solve this problem.\\n\\n```\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n        \\n        cache = []\\n        def dfs(prev_string):\\n            if len(prev_string) == n:\\n                cache.append(prev_string)\\n                return\\n            \\n            for char in [\\'a\\', \\'b\\', \\'c\\']:\\n                if not prev_string:\\n                    dfs(char)\\n                else:\\n                    if prev_string[-1] == char:\\n                        continue\\n                    else:\\n                        dfs(prev_string + char)\\n        dfs(\"\")\\n        if len(cache) <= k -1:\\n            return \"\"\\n        \\n        return cache[k-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n        \\n        cache = []\\n        def dfs(prev_string):\\n            if len(prev_string) == n:\\n                cache.append(prev_string)\\n                return\\n            \\n            for char in [\\'a\\', \\'b\\', \\'c\\']:\\n                if not prev_string:\\n                    dfs(char)\\n                else:\\n                    if prev_string[-1] == char:\\n                        continue\\n                    else:\\n                        dfs(prev_string + char)\\n        dfs(\"\")\\n        if len(cache) <= k -1:\\n            return \"\"\\n        \\n        return cache[k-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 585810,
                "title": "java-generating-happy-strings-using-recursion",
                "content": "```\\nclass Solution {\\n    List<String> list ;\\n    String happy = \"abc\";\\n    private void generateHappyString(int n, String curr, int indexToExclude){\\n        if(curr.length()==n){\\n             list.add(curr);\\n            return;\\n        }    \\n        for(int i = 0;i<happy.length();i++){\\n            if(i!=indexToExclude){\\n                 char c = happy.charAt(i);\\n                 generateHappyString(n, curr+c, i);     \\n            }  \\n        }\\n    }\\n    public String getHappyString(int n, int k) {\\n        list= new ArrayList<>();\\n        generateHappyString(n,\"\",-1);\\n        Collections.sort(list);\\n        return (k>list.size())?\"\":list.get(k-1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    List<String> list ;\\n    String happy = \"abc\";\\n    private void generateHappyString(int n, String curr, int indexToExclude){\\n        if(curr.length()==n){\\n             list.add(curr);\\n            return;\\n        }    \\n        for(int i = 0;i<happy.length();i++){\\n            if(i!=indexToExclude){\\n                 char c = happy.charAt(i);\\n                 generateHappyString(n, curr+c, i);     \\n            }  \\n        }\\n    }\\n    public String getHappyString(int n, int k) {\\n        list= new ArrayList<>();\\n        generateHappyString(n,\"\",-1);\\n        Collections.sort(list);\\n        return (k>list.size())?\"\":list.get(k-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 585720,
                "title": "java-backtrack",
                "content": "```\\nclass Solution {\\n    char[] dict = new char[]{\\'a\\',\\'b\\',\\'c\\'};\\n    public String getHappyString(int n, int k) {\\n        List<String> l = new ArrayList<>();\\n        backtrack(l, \"\", n);\\n        return (k <= l.size()) ? l.get(k-1) : \"\";\\n    }\\n    \\n    private void backtrack(List<String> list, String str, int n) {\\n        if (str.length() == n) {\\n            list.add(str);\\n            return;\\n        }\\n        char z = str.length() > 0 ? str.charAt(str.length() - 1) : \\' \\'; // check last char\\n        for (char x : dict) { // for next possible char\\n            if (x != z) {\\n                backtrack(list, str + x, n);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    char[] dict = new char[]{\\'a\\',\\'b\\',\\'c\\'};\\n    public String getHappyString(int n, int k) {\\n        List<String> l = new ArrayList<>();\\n        backtrack(l, \"\", n);\\n        return (k <= l.size()) ? l.get(k-1) : \"\";\\n    }\\n    \\n    private void backtrack(List<String> list, String str, int n) {\\n        if (str.length() == n) {\\n            list.add(str);\\n            return;\\n        }\\n        char z = str.length() > 0 ? str.charAt(str.length() - 1) : \\' \\'; // check last char\\n        for (char x : dict) { // for next possible char\\n            if (x != z) {\\n                backtrack(list, str + x, n);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 585687,
                "title": "c-bfs-lexicographically-sorted",
                "content": "####  The solution is based on BFS approach.\\n\\n1. I perform a BFS and I store all the lexicographically sorted string in a map. Map\\'s key is size of string and value is all the sorted strings that are happy.\\n2. In the BFS we can terminate when we have processed all strings of size N ( done by maintaining a level variable in the code) \\n3. After doing the BFS, there are two conditions:\\n\\ti. Either K is greater than the number of possible strings that are happy of size N\\n\\tii. The string exists, so directly return the string at index K of size N strings.\\n\\t\\n\\n#### Code:\\n```\\nclass Solution {\\n    unordered_map<int, vector<string>> Mp; // Maps all lexicographically sorted strings with its string size\\npublic:\\n    vector<char> C = {\\'a\\',\\'b\\',\\'c\\'};\\n    void BFS(int n)\\n    {\\n        int level = 0; // levels also represent the size of string that is processed\\n        queue<string> Q;\\n        for(char ch=\\'a\\'; ch<=\\'c\\'; ch++)\\n            Q.push(string(1, ch));\\n        \\n        while(!Q.empty())\\n        {\\n            int sz = Q.size();\\n            while(sz--)\\n            {\\n                string s = Q.front();\\n                Q.pop();\\n                Mp[s.size()].push_back(s); // push this string into Map of size s.size()\\n                for(int i=0; i<3; i++)\\n                    if(s.back() != C[i]) // should not be same as previous character to make it happy\\n                        Q.push(s + C[i]);\\n            }\\n            level++;\\n            if(level > n) // if done with all strings of size n\\n                return;\\n        }\\n    }\\n    string getHappyString(int n, int k) {\\n        BFS(n);        \\n        return k > Mp[n].size() ? \"\" : Mp[n][k-1];\\n    }\\n};\\n```\\n\\n#### Optimizations:\\n1. Memory utilized can be optimized as we do not need to store all strings of size < N\\n\\n```\\nclass Solution {\\n    vector<string> result; // Maps all lexicographically sorted strings of size N asked in question\\npublic:\\n    vector<char> C = {\\'a\\',\\'b\\',\\'c\\'};\\n    void BFS(int n)\\n    {\\n        int level = 0; // levels also represent the size of string that is processed\\n        queue<string> Q;\\n        for(char ch=\\'a\\'; ch<=\\'c\\'; ch++)\\n            Q.push(string(1, ch));\\n        \\n        while(!Q.empty())\\n        {\\n            int sz = Q.size();\\n            while(sz--)\\n            {\\n                string s = Q.front();\\n                Q.pop();\\n                if(s.size() == n)\\n                    result.push_back(s);\\n                for(int i=0; i<3; i++)\\n                    if(s.back() != C[i]) // should not be same as previous character to make it happy\\n                        Q.push(s + C[i]);\\n            }\\n            level++;\\n            if(level > n) // if done with all strings of size n\\n                return;\\n        }\\n    }\\n    string getHappyString(int n, int k) {\\n        BFS(n);        \\n        return k > result.size() ? \"\" : result[k-1];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    unordered_map<int, vector<string>> Mp; // Maps all lexicographically sorted strings with its string size\\npublic:\\n    vector<char> C = {\\'a\\',\\'b\\',\\'c\\'};\\n    void BFS(int n)\\n    {\\n        int level = 0; // levels also represent the size of string that is processed\\n        queue<string> Q;\\n        for(char ch=\\'a\\'; ch<=\\'c\\'; ch++)\\n            Q.push(string(1, ch));\\n        \\n        while(!Q.empty())\\n        {\\n            int sz = Q.size();\\n            while(sz--)\\n            {\\n                string s = Q.front();\\n                Q.pop();\\n                Mp[s.size()].push_back(s); // push this string into Map of size s.size()\\n                for(int i=0; i<3; i++)\\n                    if(s.back() != C[i]) // should not be same as previous character to make it happy\\n                        Q.push(s + C[i]);\\n            }\\n            level++;\\n            if(level > n) // if done with all strings of size n\\n                return;\\n        }\\n    }\\n    string getHappyString(int n, int k) {\\n        BFS(n);        \\n        return k > Mp[n].size() ? \"\" : Mp[n][k-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\n    vector<string> result; // Maps all lexicographically sorted strings of size N asked in question\\npublic:\\n    vector<char> C = {\\'a\\',\\'b\\',\\'c\\'};\\n    void BFS(int n)\\n    {\\n        int level = 0; // levels also represent the size of string that is processed\\n        queue<string> Q;\\n        for(char ch=\\'a\\'; ch<=\\'c\\'; ch++)\\n            Q.push(string(1, ch));\\n        \\n        while(!Q.empty())\\n        {\\n            int sz = Q.size();\\n            while(sz--)\\n            {\\n                string s = Q.front();\\n                Q.pop();\\n                if(s.size() == n)\\n                    result.push_back(s);\\n                for(int i=0; i<3; i++)\\n                    if(s.back() != C[i]) // should not be same as previous character to make it happy\\n                        Q.push(s + C[i]);\\n            }\\n            level++;\\n            if(level > n) // if done with all strings of size n\\n                return;\\n        }\\n    }\\n    string getHappyString(int n, int k) {\\n        BFS(n);        \\n        return k > result.size() ? \"\" : result[k-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 585646,
                "title": "c-using-map-recursion-easy-to-understand",
                "content": "\\n\\n\\' \\' \\'\\n\\t\\n\\t vector<string> v;\\n    map<string,int> m;\\n    \\n    string getHappyString(int n, int k) {\\n        v.clear();\\n        abc(n,\"\",\\'a\\');  //string started with a\\n        abc(n,\"\",\\'b\\');  //string started with b\\n        abc(n,\"\",\\'c\\');  //string started with c\\n        \\n        if(k>v.size())return \"\";\\n        \\n        sort(v.begin(),v.end());\\n        return v[k-1];\\n    }\\n    \\n    void abc(int n,string s,char ch)\\n    {\\n        if(n==0){\\n           if(m[s]==0) v.push_back(s);\\n            m[s]=1;\\n            return;\\n        }\\n        \\n        if(ch==\\'a\\')\\n        {\\n            abc(n-1,s+ch,\\'b\\');\\n            abc(n-1,s+ch,\\'c\\');\\n            return ;\\n        }\\n        else if(ch==\\'b\\')\\n        {\\n            abc(n-1,s+ch,\\'a\\');\\n            abc(n-1,s+ch,\\'c\\');\\n            return ;\\n        }\\n        else\\n        {\\n           abc(n-1,s+ch,\\'a\\');\\n            abc(n-1,s+ch,\\'b\\');\\n            return ; \\n        }\\n        return ;\\n        \\n    }\\n\\t\\n\\n\\' \\' \\'",
                "solutionTags": [],
                "code": "\\n\\n\\' \\' \\'\\n\\t\\n\\t vector<string> v;\\n    map<string,int> m;\\n    \\n    string getHappyString(int n, int k) {\\n        v.clear();\\n        abc(n,\"\",\\'a\\');  //string started with a\\n        abc(n,\"\",\\'b\\');  //string started with b\\n        abc(n,\"\",\\'c\\');  //string started with c\\n        \\n        if(k>v.size())return \"\";\\n        \\n        sort(v.begin(),v.end());\\n        return v[k-1];\\n    }\\n    \\n    void abc(int n,string s,char ch)\\n    {\\n        if(n==0){\\n           if(m[s]==0) v.push_back(s);\\n            m[s]=1;\\n            return;\\n        }\\n        \\n        if(ch==\\'a\\')\\n        {\\n            abc(n-1,s+ch,\\'b\\');\\n            abc(n-1,s+ch,\\'c\\');\\n            return ;\\n        }\\n        else if(ch==\\'b\\')\\n        {\\n            abc(n-1,s+ch,\\'a\\');\\n            abc(n-1,s+ch,\\'c\\');\\n            return ;\\n        }\\n        else\\n        {\\n           abc(n-1,s+ch,\\'a\\');\\n            abc(n-1,s+ch,\\'b\\');\\n            return ; \\n        }\\n        return ;\\n        \\n    }\\n\\t\\n\\n\\' \\' \\'",
                "codeTag": "Unknown"
            },
            {
                "id": 585581,
                "title": "simple-python-solution",
                "content": "```\\ndef getHappyString(self, n: int, k: int) -> str:\\n        def dfs(prev, res, curk):\\n            if len(res) == n: return curk+1\\n            for ch in nextchar[prev]:\\n                res.append(ch)\\n                curk = dfs(res[-1], res, curk)\\n                if curk == k: break\\n                res.pop()\\n            return curk\\n        \\n        nextchar, res = {\\'z\\': \\'abc\\',\\'a\\':\\'bc\\', \\'b\\':\\'ac\\', \\'c\\':\\'ab\\'}, []\\n        dfs(\\'z\\', res, 0)\\n        return \\'\\'.join(res)\\n```",
                "solutionTags": [],
                "code": "```\\ndef getHappyString(self, n: int, k: int) -> str:\\n        def dfs(prev, res, curk):\\n            if len(res) == n: return curk+1\\n            for ch in nextchar[prev]:\\n                res.append(ch)\\n                curk = dfs(res[-1], res, curk)\\n                if curk == k: break\\n                res.pop()\\n            return curk\\n        \\n        nextchar, res = {\\'z\\': \\'abc\\',\\'a\\':\\'bc\\', \\'b\\':\\'ac\\', \\'c\\':\\'ab\\'}, []\\n        dfs(\\'z\\', res, 0)\\n        return \\'\\'.join(res)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 585572,
                "title": "java-dp-recursive-heap",
                "content": "```\\nclass Solution {\\n    public static List<String> func(int n, int i, int prev, HashMap<Integer, List<String>> map) {\\n        if(i == n) {\\n            List<String> ans = new ArrayList<>();\\n            ans.add(\"\");\\n            return ans;\\n        }\\n        if(map.containsKey(i * 10 + prev)) return map.get(i * 10 + prev);\\n        List<String> curr = new ArrayList<>();\\n        for(int l = 0; l < 3; l++) {\\n            if(prev != l) {\\n                char ch = (char)(l + 97);\\n                List<String> small = func(n, i + 1, l, map);\\n                for(int j = 0; j < small.size(); j++) curr.add(ch + small.get(j));\\n            }\\n        }\\n        map.put(i * 10 + prev, curr);\\n        return curr;\\n    }\\n    public String getHappyString(int n, int k) {\\n        List<String> ans = func(n, 0, 3, new HashMap<>());\\n        if(ans.size() < k) return \"\";\\n        PriorityQueue<String> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i = 0; i < k; i++) pq.add(ans.get(i));\\n        for(int i = k; i < n; i++) {\\n            if(ans.get(i).compareTo(pq.peek()) < 0) {\\n                pq.poll();\\n                pq.add(ans.get(i));\\n            }\\n        }\\n        return pq.peek();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public static List<String> func(int n, int i, int prev, HashMap<Integer, List<String>> map) {\\n        if(i == n) {\\n            List<String> ans = new ArrayList<>();\\n            ans.add(\"\");\\n            return ans;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4096963,
                "title": "python3-simple-recursion",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n        \\n        def f(s):\\n            if len(s)==n:\\n                strs.append(s)\\n                return \\n            \\n            if s[-1]==\"a\":\\n                f(s+\"b\")\\n                f(s+\"c\")\\n            elif s[-1]==\"b\":\\n                f(s+\"a\")\\n                f(s+\"c\")\\n            else:\\n                f(s+\"a\")\\n                f(s+\"b\")\\n        \\n        strs=[]\\n        f(\"a\")\\n        f(\"b\")\\n        f(\"c\")\\n    \\n        return strs[k-1] if len(strs)>=k else \"\"\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n        \\n        def f(s):\\n            if len(s)==n:\\n                strs.append(s)\\n                return \\n            \\n            if s[-1]==\"a\":\\n                f(s+\"b\")\\n                f(s+\"c\")\\n            elif s[-1]==\"b\":\\n                f(s+\"a\")\\n                f(s+\"c\")\\n            else:\\n                f(s+\"a\")\\n                f(s+\"b\")\\n        \\n        strs=[]\\n        f(\"a\")\\n        f(\"b\")\\n        f(\"c\")\\n    \\n        return strs[k-1] if len(strs)>=k else \"\"\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4096491,
                "title": "simple-solution-using-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void solve(int n,vector<string>& per,string& s){\\n    if(s.length() == n){\\n        per.push_back(s);\\n        return;\\n    }\\n\\n    for(int i=0;i<3;i++){\\n            char c = char(97+i);\\n             if(s.length() >0 && s[s.length()-1] == c) continue;\\n             s+=c;\\n            solve(n,per,s);\\n            s.pop_back();  \\n    }\\n\\n}\\n    string getHappyString(int n, int k) {\\n        vector<string> permutation;\\n        string s = \"\";\\n        solve(n,permutation,s);\\n        sort(permutation.begin(),permutation.end());\\n        return k>permutation.size() ? \"\" : permutation[k-1];      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void solve(int n,vector<string>& per,string& s){\\n    if(s.length() == n){\\n        per.push_back(s);\\n        return;\\n    }\\n\\n    for(int i=0;i<3;i++){\\n            char c = char(97+i);\\n             if(s.length() >0 && s[s.length()-1] == c) continue;\\n             s+=c;\\n            solve(n,per,s);\\n            s.pop_back();  \\n    }\\n\\n}\\n    string getHappyString(int n, int k) {\\n        vector<string> permutation;\\n        string s = \"\";\\n        solve(n,permutation,s);\\n        sort(permutation.begin(),permutation.end());\\n        return k>permutation.size() ? \"\" : permutation[k-1];      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071196,
                "title": "java-brute-force-dfs-simplest-intuitive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA happy string is a string that:\\nconsists only of letters of the set ```[\\'a\\', \\'b\\', \\'c\\']```.\\nand ```n < 10```\\nSo, we can **generate all the possible happy strings**.\\n\\n**The strings generated using DFS will be in Lexicagraphical Order**.\\nSo we can just keep track for the k-th string.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBasic Brute Force DFS Approach.\\n\\n\\n# Complexity\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Time complexity: ```O(3^n)```\\nBranching Factor ^ Depth\\nBranching for each character [ a, b, c] \\nDepth will be the length of the generated string.\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: ```O(n)```\\nFor generating the string of length n.\\n\\n# Code\\n```\\nclass Solution {\\n    private void dfs(int n, int k, String chars, int index, int[] count, StringBuilder s, String[] res) {\\n        if (s.length() == n) {\\n            if (count[0] == k)\\n                res[0] = s.toString();\\n            return;\\n        }\\n\\n        for (int i = 0; i < 3; i++) {\\n            if (s.length() != 0 && s.charAt(index - 1) == chars.charAt(i))\\n                continue;\\n\\n            s.append(chars.charAt(i));\\n            if (s.length() == n)\\n                count[0]++;\\n            dfs(n, k, chars, index + 1, count, s, res);\\n            if (!res[0].isEmpty())\\n                return;\\n            s.deleteCharAt(s.length() - 1);\\n        }\\n    }\\n\\n    public String getHappyString(int n, int k) {\\n        String chars = \"abc\";\\n        StringBuilder s = new StringBuilder();\\n        String[] res = new String[] { \"\" };\\n        int[] count = new int[] { 0 };\\n\\n        dfs(n, k, chars, 0, count, s, res);\\n\\n        if(count[0] < k)\\n            return \"\";\\n\\n        return res[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```[\\'a\\', \\'b\\', \\'c\\']```\n```n < 10```\n```O(3^n)```\n```O(n)```\n```\\nclass Solution {\\n    private void dfs(int n, int k, String chars, int index, int[] count, StringBuilder s, String[] res) {\\n        if (s.length() == n) {\\n            if (count[0] == k)\\n                res[0] = s.toString();\\n            return;\\n        }\\n\\n        for (int i = 0; i < 3; i++) {\\n            if (s.length() != 0 && s.charAt(index - 1) == chars.charAt(i))\\n                continue;\\n\\n            s.append(chars.charAt(i));\\n            if (s.length() == n)\\n                count[0]++;\\n            dfs(n, k, chars, index + 1, count, s, res);\\n            if (!res[0].isEmpty())\\n                return;\\n            s.deleteCharAt(s.length() - 1);\\n        }\\n    }\\n\\n    public String getHappyString(int n, int k) {\\n        String chars = \"abc\";\\n        StringBuilder s = new StringBuilder();\\n        String[] res = new String[] { \"\" };\\n        int[] count = new int[] { 0 };\\n\\n        dfs(n, k, chars, 0, count, s, res);\\n\\n        if(count[0] < k)\\n            return \"\";\\n\\n        return res[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065369,
                "title": "java-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    List<String> list = new ArrayList<>();\\n    public String getHappyString(int n, int k) {\\n        \\n        rec(n, \"\", \"\");\\n        if(k > list.size())\\n            return \"\";\\n        // list.sort((a,b) -> a.compareTo(b));\\n        return list.get(k-1);\\n    }\\n\\n    private void rec(int n, String prev, String sb){\\n        if(sb.length() == n){\\n            list.add(sb.toString());\\n            return;\\n        }\\n        switch(prev){\\n            case \"\":  rec(n, \"a\", sb+\"a\");\\n                rec(n, \"b\", sb+\"b\");\\n                rec(n, \"c\", sb+\"c\");\\n                break;\\n            case \"a\": rec(n, \"b\", sb+\"b\");\\n                rec(n, \"c\", sb+\"c\");\\n                break;\\n            case \"b\": rec(n, \"a\", sb+\"a\");\\n                rec(n, \"c\", sb+\"c\");\\n                break;\\n            case \"c\": rec(n, \"a\", sb+\"a\");\\n                rec(n, \"b\", sb+\"b\");\\n                break;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    List<String> list = new ArrayList<>();\\n    public String getHappyString(int n, int k) {\\n        \\n        rec(n, \"\", \"\");\\n        if(k > list.size())\\n            return \"\";\\n        // list.sort((a,b) -> a.compareTo(b));\\n        return list.get(k-1);\\n    }\\n\\n    private void rec(int n, String prev, String sb){\\n        if(sb.length() == n){\\n            list.add(sb.toString());\\n            return;\\n        }\\n        switch(prev){\\n            case \"\":  rec(n, \"a\", sb+\"a\");\\n                rec(n, \"b\", sb+\"b\");\\n                rec(n, \"c\", sb+\"c\");\\n                break;\\n            case \"a\": rec(n, \"b\", sb+\"b\");\\n                rec(n, \"c\", sb+\"c\");\\n                break;\\n            case \"b\": rec(n, \"a\", sb+\"a\");\\n                rec(n, \"c\", sb+\"c\");\\n                break;\\n            case \"c\": rec(n, \"a\", sb+\"a\");\\n                rec(n, \"b\", sb+\"b\");\\n                break;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050950,
                "title": "the-k-th-lexicographical-string-of-all-happy-strings-of-length-n",
                "content": "# Code\\n```\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n        l = [\"a\",\"b\",\"c\"]\\n        for i in range(n-1):\\n            p = []\\n            for j in l:\\n                if j[-1]== \"a\":\\n                    p.append(j + \"b\")\\n                    p.append(j + \"c\")\\n                elif j[-1]== \"b\":\\n                    p.append(j + \"a\")\\n                    p.append(j + \"c\")\\n                else:\\n                    p.append(j + \"a\")\\n                    p.append(j + \"b\")\\n            l = p\\n        l.sort()\\n        if len(l)>=k:\\n            return l[k-1]\\n        return \"\"\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n        l = [\"a\",\"b\",\"c\"]\\n        for i in range(n-1):\\n            p = []\\n            for j in l:\\n                if j[-1]== \"a\":\\n                    p.append(j + \"b\")\\n                    p.append(j + \"c\")\\n                elif j[-1]== \"b\":\\n                    p.append(j + \"a\")\\n                    p.append(j + \"c\")\\n                else:\\n                    p.append(j + \"a\")\\n                    p.append(j + \"b\")\\n            l = p\\n        l.sort()\\n        if len(l)>=k:\\n            return l[k-1]\\n        return \"\"\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4028072,
                "title": "c-simple-backtracking-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid generate(int n, string ds, vector<string> &ans, vector<char> &arr){\\n    if(ds.size()==n){\\n        ans.push_back(ds);\\n        return;\\n    }\\n\\n    for(int i=0;i<3;i++){\\n        if(ds.empty() || ds.back()!=arr[i]){\\n            ds.push_back(arr[i]);\\n            generate(n, ds, ans, arr);\\n            ds.pop_back();\\n        }\\n    }\\n}\\n    string getHappyString(int n, int k) {\\n        vector<string> ans;\\n        string ds;\\n        vector<char> arr;\\n        arr.push_back(\\'a\\');\\n        arr.push_back(\\'b\\');\\n        arr.push_back(\\'c\\');\\n        generate(n, ds, ans, arr);\\n        for(auto it: ans){\\n            cout<<it<<\" \";\\n        }\\n        if(ans.size()<k) return \"\";\\n\\n        \\n        return ans[k-1];\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid generate(int n, string ds, vector<string> &ans, vector<char> &arr){\\n    if(ds.size()==n){\\n        ans.push_back(ds);\\n        return;\\n    }\\n\\n    for(int i=0;i<3;i++){\\n        if(ds.empty() || ds.back()!=arr[i]){\\n            ds.push_back(arr[i]);\\n            generate(n, ds, ans, arr);\\n            ds.pop_back();\\n        }\\n    }\\n}\\n    string getHappyString(int n, int k) {\\n        vector<string> ans;\\n        string ds;\\n        vector<char> arr;\\n        arr.push_back(\\'a\\');\\n        arr.push_back(\\'b\\');\\n        arr.push_back(\\'c\\');\\n        generate(n, ds, ans, arr);\\n        for(auto it: ans){\\n            cout<<it<<\" \";\\n        }\\n        if(ans.size()<k) return \"\";\\n\\n        \\n        return ans[k-1];\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4025213,
                "title": "recursion-greedy-easy-to-understand-c-g",
                "content": "# Intuition\\nIt\\'s a greedy + recursion problem.\\n\\n# Approach\\nAt each recursion call we start with the lowest possible alphabet such that current alphabet is not equal to previous (greedy). Keep pushing to the result as long as size is less than k.\\n\\nVery similar problem: https://leetcode.com/problems/lexicographical-numbers/\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<string> result;\\n    void rec(string cur, int &k, int &n){\\n        if(cur.size() == n){\\n            result.push_back(cur); return;\\n        }\\n        for(int i = 0; i < 3; i++){\\n            if((cur.empty() || cur.back() != (\\'a\\' + i)) && cur.size() < n && result.size() < k){\\n                cur+= (\\'a\\' +  i);\\n                rec(cur, k, n);\\n                cur.pop_back();\\n            }\\n        }\\n    }\\n    string getHappyString(int n, int k) {\\n        rec(\"\", k, n);\\n        if(result.size() < k) return \"\";\\n        return result[k - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<string> result;\\n    void rec(string cur, int &k, int &n){\\n        if(cur.size() == n){\\n            result.push_back(cur); return;\\n        }\\n        for(int i = 0; i < 3; i++){\\n            if((cur.empty() || cur.back() != (\\'a\\' + i)) && cur.size() < n && result.size() < k){\\n                cur+= (\\'a\\' +  i);\\n                rec(cur, k, n);\\n                cur.pop_back();\\n            }\\n        }\\n    }\\n    string getHappyString(int n, int k) {\\n        rec(\"\", k, n);\\n        if(result.size() < k) return \"\";\\n        return result[k - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023355,
                "title": "beats-90-memory-simple-solution-backtracking",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n        d=\\'abc\\'\\n        a=[]\\n        def back(a,d,n,path):\\n            if len(path)==n:\\n                a.append(path)\\n                return\\n                \\n            for i in range(len(d)):\\n                if len(path)>0:\\n                    if path[-1]==d[i]:\\n                        continue\\n                back(a,d,n,path+d[i])\\n        back(a,d,n,\\'\\')\\n        a.sort()\\n        if len(a)<k:\\n            return \"\"\\n        else:\\n            return a[k-1]\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n        d=\\'abc\\'\\n        a=[]\\n        def back(a,d,n,path):\\n            if len(path)==n:\\n                a.append(path)\\n                return\\n                \\n            for i in range(len(d)):\\n                if len(path)>0:\\n                    if path[-1]==d[i]:\\n                        continue\\n                back(a,d,n,path+d[i])\\n        back(a,d,n,\\'\\')\\n        a.sort()\\n        if len(a)<k:\\n            return \"\"\\n        else:\\n            return a[k-1]\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4015357,
                "title": "easy-backtracking-solution-c-recursive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGenerate happy substrings with a backtracking-based approach until the kth happy substring and return the kth happy substring if found.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe vector chars stores the alphabets `\"a\"`, `\"b\"` and `\"c\"`.\\nUse a recursive backtracking algorithm to generate the happy substrings.\\nStart with empty string.\\nIn each recursive call, first check if kth string is found.\\nIf found, return;\\nIf not, check if the string is complete i.e. length == n.\\nIf yes, increment the count and if count == k, update the kth string (indicating that you have found it).\\nThe above steps of keeping track of the kth string avoids the need to generate all the happy strings - thereby improving computational speed for lower k.\\n\\nIf current string length is less than n,\\nIterate through the set of chars and add it the char to the string if the char is not equal to previous index char (tracked by the prev variable).\\nBacktrack with updated parameters.\\n\\nFinally, return the kth string if found, \"\" otherwise.\\n\\n\\n# Complexity\\n- Time complexity: $$O(3^n)$$ (worst-case)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Upvote if helpful!\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void backtrack(int n, string prev, string& cur, int& count, int k, string& kth, vector<string> chars)\\n    {\\n        if (kth != \"\")\\n            return;\\n        \\n        if (cur.length() == n)\\n        {\\n            count++;\\n            if (count == k)\\n                kth = cur;\\n            return;\\n        }\\n\\n        for (auto c:chars)\\n        {\\n            if (c != prev)\\n            {\\n                cur = cur+c;\\n                backtrack(n, c, cur, count, k, kth, chars);\\n                cur = cur.substr(0, cur.length()-1);\\n            }\\n        }\\n    }\\n    string getHappyString(int n, int k) {\\n        int count = 0;\\n        string res = \"\", cur=\"\", prev=\"\";\\n        vector<string> chars = {\"a\", \"b\", \"c\"};\\n        backtrack(n, prev, cur, count, k, res, chars);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void backtrack(int n, string prev, string& cur, int& count, int k, string& kth, vector<string> chars)\\n    {\\n        if (kth != \"\")\\n            return;\\n        \\n        if (cur.length() == n)\\n        {\\n            count++;\\n            if (count == k)\\n                kth = cur;\\n            return;\\n        }\\n\\n        for (auto c:chars)\\n        {\\n            if (c != prev)\\n            {\\n                cur = cur+c;\\n                backtrack(n, c, cur, count, k, kth, chars);\\n                cur = cur.substr(0, cur.length()-1);\\n            }\\n        }\\n    }\\n    string getHappyString(int n, int k) {\\n        int count = 0;\\n        string res = \"\", cur=\"\", prev=\"\";\\n        vector<string> chars = {\"a\", \"b\", \"c\"};\\n        backtrack(n, prev, cur, count, k, res, chars);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010214,
                "title": "backtrack-solution-with-constant-extra-space",
                "content": "# Approach\\n- We need a variable prev to store the previous character of the string. I have initialized it with \\'d\\' since we will have only a, b, c in the result string.\\n- We need a count variable to track the count of string formed in the lexicographical order.\\n- Now we will start the recursion call for 0 index.\\n- We will iterate from char \\'a\\' to char \\'c\\' and if the current char is not the prev char then we can add this to the string and we will increase the index.\\n- If the index becomes equal to the required string length, we\\'ll update the ans string to str and increase the count. \\n- Since we are iterating from \\'a\\' to \\'c\\' in lexicographical order, so if we reach at count=k then the present stored value of str would be our desired ans.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(2^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int cnt = 0;\\n    string ans = \"\";\\n    void recursion(string str, int n, int i, char prev, int k){\\n        if(cnt==k){\\n            return;\\n        }\\n        if(i>=n){\\n            ans = str;\\n            cnt++;\\n            return;\\n        }\\n        for(char ch = \\'a\\';ch<=\\'c\\';ch++){\\n            if(ch!=prev){\\n                recursion(str+ch, n, i+1, ch, k);\\n            }\\n        }\\n    }\\n    string getHappyString(int n, int k) {\\n        string str = \"\";\\n        char c = \\'d\\';\\n        recursion(str, n, 0, c, k);\\n        if(k<=cnt)\\n            return ans;\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int cnt = 0;\\n    string ans = \"\";\\n    void recursion(string str, int n, int i, char prev, int k){\\n        if(cnt==k){\\n            return;\\n        }\\n        if(i>=n){\\n            ans = str;\\n            cnt++;\\n            return;\\n        }\\n        for(char ch = \\'a\\';ch<=\\'c\\';ch++){\\n            if(ch!=prev){\\n                recursion(str+ch, n, i+1, ch, k);\\n            }\\n        }\\n    }\\n    string getHappyString(int n, int k) {\\n        string str = \"\";\\n        char c = \\'d\\';\\n        recursion(str, n, 0, c, k);\\n        if(k<=cnt)\\n            return ans;\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992054,
                "title": "c-backtracking-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    private char[] _letters = new[] { \\'a\\', \\'b\\', \\'c\\' };\\n    private HashSet<string> _uniqueCombinations = new HashSet<string>();\\n    \\n    public string GetHappyString(int n, int k)\\n    {\\n        var result = new List<string>();\\n        Backtrack(n, result, new StringBuilder());\\n        return result.Count >= k ? result[k - 1] : string.Empty;\\n    }\\n\\n    void Backtrack(int n, List<string> result, StringBuilder combination)\\n    {\\n        if (combination.Length == n)\\n        {\\n            var currentCombination = combination.ToString();\\n            if (_uniqueCombinations.Contains(currentCombination))\\n            {\\n                return;\\n            }\\n\\n            result.Add(currentCombination);\\n            _uniqueCombinations.Add(currentCombination);\\n            return;\\n        }\\n\\n        for (int j = 0; j < _letters.Length; j++)\\n        {\\n            if (combination.Length == 0 || _letters[j] != combination[^1])\\n            {\\n                combination.Append(_letters[j]);\\n                Backtrack(n, result, combination);\\n                combination.Remove(combination.Length - 1, 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    private char[] _letters = new[] { \\'a\\', \\'b\\', \\'c\\' };\\n    private HashSet<string> _uniqueCombinations = new HashSet<string>();\\n    \\n    public string GetHappyString(int n, int k)\\n    {\\n        var result = new List<string>();\\n        Backtrack(n, result, new StringBuilder());\\n        return result.Count >= k ? result[k - 1] : string.Empty;\\n    }\\n\\n    void Backtrack(int n, List<string> result, StringBuilder combination)\\n    {\\n        if (combination.Length == n)\\n        {\\n            var currentCombination = combination.ToString();\\n            if (_uniqueCombinations.Contains(currentCombination))\\n            {\\n                return;\\n            }\\n\\n            result.Add(currentCombination);\\n            _uniqueCombinations.Add(currentCombination);\\n            return;\\n        }\\n\\n        for (int j = 0; j < _letters.Length; j++)\\n        {\\n            if (combination.Length == 0 || _letters[j] != combination[^1])\\n            {\\n                combination.Append(_letters[j]);\\n                Backtrack(n, result, combination);\\n                combination.Remove(combination.Length - 1, 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968175,
                "title": "python-backtracking-solution",
                "content": "```\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n        alpha = [\"a\", \"b\", \"c\"]\\n        def backtracking(first = 0, cur = []):\\n            if len(cur) == n:\\n                return result.append(\"\".join(cur[:]))\\n            \\n            for i in range(3):\\n                if len(cur) > 0 and alpha[i % 3] == cur[-1]:\\n                    continue\\n                cur.append(alpha[i % 3])\\n                backtracking(cur)\\n                cur.pop()\\n        \\n        result = []\\n        backtracking()\\n        print(result)\\n        return result[k - 1] if k <= len(result) else \"\"\\n        ```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getHappyString(self, n: int, k: int) -> str:\\n        alpha = [\"a\", \"b\", \"c\"]\\n        def backtracking(first = 0, cur = []):\\n            if len(cur) == n:\\n                return result.append(\"\".join(cur[:]))\\n            \\n            for i in range(3):\\n                if len(cur) > 0 and alpha[i % 3] == cur[-1]:\\n                    continue\\n                cur.append(alpha[i % 3])\\n                backtracking(cur)\\n                cur.pop()\\n        \\n        result = []\\n        backtracking()\\n        print(result)\\n        return result[k - 1] if k <= len(result) else \"\"\\n        ```",
                "codeTag": "Java"
            },
            {
                "id": 3966540,
                "title": "java-easy-solution-explained-with-diagram-recursion-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn my approach i\\'m generating all the possible lexicographical order strings and then finding the k\\'th one.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince we are given that String consists only of letters of the set [\\'a\\', \\'b\\', \\'c\\'], so i saved them in an array.\\nThen I have created an ArrayList ans which stores all the generated Strings of lexicographical order.\\n\\nThe recursive tree is - \\n\\n    Suppose:\\n    allowed letters - [\\'a\\', \\'b\\', \\'c\\']\\n\\n                 a\\n            /    |    \\\\\\n           b     a     c\\n         / | \\\\  (X)   / | \\\\\\n        a  b  c      a  b  c\\n          (X)              (X)\\n\\n    (x) - denotes that we can\\'t continue down that path\\n\\nAt each instance we have three letters to choose from, `a` `b` & `c`.\\n\\nSuppose we start with letter`a`then we again have three options to choose from, since it\\'s given that adjacent lettes can\\'t be same, then we have the option to pick either`b`or`c`.\\n\\nSuppose we choose letter`b`then again at this instance we have three options`a` `b` & `c`, but we can\\'t pick `b`, so we have two paths `a b a` and `a b c` (this can also be seen from the above diagram).\\n\\nThe Base condition is if the size of our picked path is same as that of the allowed letters, that means we have picked all the letters.\\n\\nIn this example we started with`a`letter, if we start with the rest of allowed letters one at a time we get all the possible strings that follow lexicographical order.\\n\\n# Complexity\\n- Time complexity:\\n$$O(2^n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public String getHappyString(int n, int k) {\\n        // Allowed letters\\n        char[] letters = new char[3];\\n        letters[0] = \\'a\\';\\n        letters[1] = \\'b\\';\\n        letters[2] = \\'c\\';\\n\\n        // List storing all the generated Strings\\n        ArrayList<String> ans = new ArrayList<>();\\n\\n        getCombination(n, ans, letters, new StringBuilder());\\n\\n        // Checking if the k\\'th String exists or not\\n        if(k > ans.size()) {\\n            return \"\";\\n        } \\n\\n        // Returning the k\\'th String\\n        return ans.get(k - 1);\\n    }\\n\\n    public static void getCombination(int n, ArrayList<String> ans, char[] letters, StringBuilder sc) {\\n        \\n        // Used all the allowed Letters\\n        if(sc.length() == n) {\\n            ans.add(new String(sc.toString()));\\n            return;\\n        }\\n\\n        for(int i = 0; i < letters.length; i++) {\\n            // Condition to check if the adjacent letters are not the same\\n            if(sc.length() == 0 || sc.charAt(sc.length() - 1) != letters[i]) {\\n                sc.append(letters[i]);\\n                getCombination(n, ans, letters, sc);\\n                sc.deleteCharAt(sc.length() - 1);\\n            }\\n        }        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String getHappyString(int n, int k) {\\n        // Allowed letters\\n        char[] letters = new char[3];\\n        letters[0] = \\'a\\';\\n        letters[1] = \\'b\\';\\n        letters[2] = \\'c\\';\\n\\n        // List storing all the generated Strings\\n        ArrayList<String> ans = new ArrayList<>();\\n\\n        getCombination(n, ans, letters, new StringBuilder());\\n\\n        // Checking if the k\\'th String exists or not\\n        if(k > ans.size()) {\\n            return \"\";\\n        } \\n\\n        // Returning the k\\'th String\\n        return ans.get(k - 1);\\n    }\\n\\n    public static void getCombination(int n, ArrayList<String> ans, char[] letters, StringBuilder sc) {\\n        \\n        // Used all the allowed Letters\\n        if(sc.length() == n) {\\n            ans.add(new String(sc.toString()));\\n            return;\\n        }\\n\\n        for(int i = 0; i < letters.length; i++) {\\n            // Condition to check if the adjacent letters are not the same\\n            if(sc.length() == 0 || sc.charAt(sc.length() - 1) != letters[i]) {\\n                sc.append(letters[i]);\\n                getCombination(n, ans, letters, sc);\\n                sc.deleteCharAt(sc.length() - 1);\\n            }\\n        }        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949381,
                "title": "python-simple-recursive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def getHappyString(self, n, k):\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n\\n        res = []\\n        letters = [\\'a\\', \\'b\\', \\'c\\']\\n        def dfs(s):\\n            \\n            if len(s) == n:\\n                res.append(s)\\n                return\\n            \\n            for c in letters:\\n                if len(s) == 0:\\n                    dfs(s + c)\\n                else:\\n                    if c != s[-1]:\\n                        dfs(s+c)\\n\\n        dfs(\"\")\\n\\n        if k > len(res):\\n            return \"\"\\n        else:\\n            return res[k-1]\\n            \\n                \\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def getHappyString(self, n, k):\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n\\n        res = []\\n        letters = [\\'a\\', \\'b\\', \\'c\\']\\n        def dfs(s):\\n            \\n            if len(s) == n:\\n                res.append(s)\\n                return\\n            \\n            for c in letters:\\n                if len(s) == 0:\\n                    dfs(s + c)\\n                else:\\n                    if c != s[-1]:\\n                        dfs(s+c)\\n\\n        dfs(\"\")\\n\\n        if k > len(res):\\n            return \"\"\\n        else:\\n            return res[k-1]\\n            \\n                \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938102,
                "title": "cpp-backtrack-fastest-and-efficient-usage",
                "content": "# Intuition\\nusing backtrack approach\\nstop when the k-th string has generated\\n\\nRuntime\\n3ms\\n\\nMemory\\n7.92MB\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getHappyString(int n, int k) \\n    {        \\n        if (1 == n)\\n        {\\n            switch (k)\\n            {\\n                case 1:\\n                    return \"a\";\\n                case 2:\\n                    return \"b\";\\n                case 3:\\n                    return \"c\";\\n                default:\\n                    return \"\";\\n            }\\n        }                        \\n\\n        stopIndex = k-1;\\n        backtrackFunc(n, \"\");\\n        \\n        if ( happyStrings.size() < k) return \"\";\\n        return happyStrings[k-1];\\n    }\\n\\nprivate:\\n    vector<char> LETTERs = {\\'a\\', \\'b\\', \\'c\\'};\\n    vector<string> happyStrings;\\n    int stopIndex = -1;\\n\\n    void backtrackFunc(const int& n, string bufString)\\n    {\\n        if (n == bufString.size()) \\n        {\\n            happyStrings.push_back(bufString);\\n            return;\\n        }\\n        \\n        for (char k : LETTERs)\\n        {\\n            if ( stopIndex == happyStrings.size()-1 ) break;\\n            if (0 == bufString.size()) bufString.push_back(k);\\n            else\\n            {\\n                if (k != bufString.back()) bufString.push_back(k);\\n                else continue;\\n            }\\n            backtrackFunc(n, bufString);\\n            bufString.pop_back();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getHappyString(int n, int k) \\n    {        \\n        if (1 == n)\\n        {\\n            switch (k)\\n            {\\n                case 1:\\n                    return \"a\";\\n                case 2:\\n                    return \"b\";\\n                case 3:\\n                    return \"c\";\\n                default:\\n                    return \"\";\\n            }\\n        }                        \\n\\n        stopIndex = k-1;\\n        backtrackFunc(n, \"\");\\n        \\n        if ( happyStrings.size() < k) return \"\";\\n        return happyStrings[k-1];\\n    }\\n\\nprivate:\\n    vector<char> LETTERs = {\\'a\\', \\'b\\', \\'c\\'};\\n    vector<string> happyStrings;\\n    int stopIndex = -1;\\n\\n    void backtrackFunc(const int& n, string bufString)\\n    {\\n        if (n == bufString.size()) \\n        {\\n            happyStrings.push_back(bufString);\\n            return;\\n        }\\n        \\n        for (char k : LETTERs)\\n        {\\n            if ( stopIndex == happyStrings.size()-1 ) break;\\n            if (0 == bufString.size()) bufString.push_back(k);\\n            else\\n            {\\n                if (k != bufString.back()) bufString.push_back(k);\\n                else continue;\\n            }\\n            backtrackFunc(n, bufString);\\n            bufString.pop_back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937043,
                "title": "java-best-solution-using-permutation-concept-backtracking",
                "content": "It seems like you\\'re providing a code snippet for a solution to a problem, but you\\'ve left some parts incomplete. Let me help you fill in the missing details based on the provided code snippet:\\n\\n## Intuition\\nBased on the code snippet, the problem appears to involve generating the k-th lexicographically smallest \"happy string\" of length n. A happy string is a string where no two adjacent characters are the same. The code seems to use a recursive approach to generate these strings and find the k-th happy string of length n.\\n\\n## Approach\\nThe approach used in the code is a recursive depth-first search (DFS) to generate all possible happy strings of length n using characters \\'a\\', \\'b\\', and \\'c\\'. The helper function `help` is responsible for constructing the strings while maintaining the constraint of non-repeating adjacent characters. The base case is reached when a string of length n is formed. At this point, the value of k is decremented, and if k becomes zero, the current string is stored as the answer.\\n\\n## Complexity\\n- Time complexity: The code generates all possible happy strings of length n. Since there are three choices for each position in the string (\\'a\\', \\'b\\', or \\'c\\'), the time complexity is O(3^n) in the worst case.\\n- Space complexity: The space complexity of the code is determined by the depth of the recursive calls. In the worst case, the maximum depth of recursion is n, resulting in a space complexity of O(n).\\n\\n## Code\\n```java\\nclass Solution {\\n\\n    String ans = \"\";\\n    int k = 0;\\n\\n    public void help(int n, char[] ss, String s) {\\n        if (s.length() == n) {\\n            k--;\\n            if (k == 0) {\\n                ans = s;\\n            }\\n            return;\\n        }\\n\\n        for (int i = 0; i < ss.length; i++) {\\n            try {\\n                if (s.charAt(s.length() - 1) == ss[i]) {\\n                    // Skip if the current character is the same as the last character\\n                } else {\\n                    help(n, ss, s + ss[i]);\\n                }\\n            } catch (Exception e) {\\n                help(n, ss, s + ss[i]);\\n            }\\n        }\\n    }\\n\\n    public String getHappyString(int n, int k) {\\n        char ss[] = {\\'a\\', \\'b\\', \\'c\\'};\\n        this.k = k;\\n        help(n, ss, \"\");\\n        return ans;\\n    }\\n}\\n```\\n\\nPlease note that the provided code might need further debugging and optimization to work correctly and efficiently.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n\\n    String ans = \"\";\\n    int k = 0;\\n\\n    public void help(int n, char[] ss, String s) {\\n        if (s.length() == n) {\\n            k--;\\n            if (k == 0) {\\n                ans = s;\\n            }\\n            return;\\n        }\\n\\n        for (int i = 0; i < ss.length; i++) {\\n            try {\\n                if (s.charAt(s.length() - 1) == ss[i]) {\\n                    // Skip if the current character is the same as the last character\\n                } else {\\n                    help(n, ss, s + ss[i]);\\n                }\\n            } catch (Exception e) {\\n                help(n, ss, s + ss[i]);\\n            }\\n        }\\n    }\\n\\n    public String getHappyString(int n, int k) {\\n        char ss[] = {\\'a\\', \\'b\\', \\'c\\'};\\n        this.k = k;\\n        help(n, ss, \"\");\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929039,
                "title": "backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBacktrack and set the answer if k-th combination is reached. To achieve the ordering constraint, just iterate over [a, b, c] candidates in order and skip a letter if it was used last in the current combination.\\n\\n# Complexity\\n- Time complexity: $O(3*2^{N-1})$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(N)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfn backtrack(n: usize, k: &mut i32, cur: &mut Vec<u8>, ans: &mut String) {\\n    if n == 0 {\\n        *k -= 1;\\n        if *k == 0 { *ans = String::from_utf8(cur.clone()).unwrap() }\\n        return;\\n    }\\n    for letter in [b\\'a\\', b\\'b\\', b\\'c\\'] {\\n        if !cur.is_empty() && *cur.last().unwrap() == letter { continue }\\n        if *k == 0 { break; }\\n\\n        cur.push(letter);\\n        backtrack(n - 1, k, cur, ans);\\n        cur.pop();\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn get_happy_string(n: i32, mut k: i32) -> String {\\n        let mut ans = String::new();\\n        backtrack(n as usize, &mut k, &mut Vec::new(), &mut ans);\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nfn backtrack(n: usize, k: &mut i32, cur: &mut Vec<u8>, ans: &mut String) {\\n    if n == 0 {\\n        *k -= 1;\\n        if *k == 0 { *ans = String::from_utf8(cur.clone()).unwrap() }\\n        return;\\n    }\\n    for letter in [b\\'a\\', b\\'b\\', b\\'c\\'] {\\n        if !cur.is_empty() && *cur.last().unwrap() == letter { continue }\\n        if *k == 0 { break; }\\n\\n        cur.push(letter);\\n        backtrack(n - 1, k, cur, ans);\\n        cur.pop();\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn get_happy_string(n: i32, mut k: i32) -> String {\\n        let mut ans = String::new();\\n        backtrack(n as usize, &mut k, &mut Vec::new(), &mut ans);\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1823234,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is a basic Approach: -\\n\\nInitialize an empty string result to store the kth happy string.\\n\\nDefine a fixed array of characters containing \\'a\\', \\'b\\', and \\'c\\'.\\n\\nCall the backtrack function with the input parameters n, k, and an empty string.\\n\\nIn the backtrack function, if the length of the current string s is equal to n, decrement k by 1, check if k is 0, and if so, set result equal to s and return 0 to stop further backtracking.\\n\\nIf the length of s is not equal to n, iterate through the characters in the fixed array and check if the last character in s is not equal to the current character c or if s is empty. If this condition is satisfied, call backtrack recursively with the updated string s+c and decrement k.\\n\\nIf k becomes 0, return 0 to stop further backtracking.\\n\\nReturn the final value of result."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link for Reference: -\\nhttps://leetcode.com/problems/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n/solutions/3261366/beginner-friendly-solution-with-steps-inside/ "
                    },
                    {
                        "username": "code__HARD",
                        "content": "At looking at constraints we can analyze this is an backtracking solution.\\nEasy question."
                    }
                ]
            },
            {
                "id": 2069111,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is a basic Approach: -\\n\\nInitialize an empty string result to store the kth happy string.\\n\\nDefine a fixed array of characters containing \\'a\\', \\'b\\', and \\'c\\'.\\n\\nCall the backtrack function with the input parameters n, k, and an empty string.\\n\\nIn the backtrack function, if the length of the current string s is equal to n, decrement k by 1, check if k is 0, and if so, set result equal to s and return 0 to stop further backtracking.\\n\\nIf the length of s is not equal to n, iterate through the characters in the fixed array and check if the last character in s is not equal to the current character c or if s is empty. If this condition is satisfied, call backtrack recursively with the updated string s+c and decrement k.\\n\\nIf k becomes 0, return 0 to stop further backtracking.\\n\\nReturn the final value of result."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link for Reference: -\\nhttps://leetcode.com/problems/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n/solutions/3261366/beginner-friendly-solution-with-steps-inside/ "
                    },
                    {
                        "username": "code__HARD",
                        "content": "At looking at constraints we can analyze this is an backtracking solution.\\nEasy question."
                    }
                ]
            }
        ]
    },
    {
        "title": "Design Authentication Manager",
        "question_content": "<p>There is an authentication system that works with authentication tokens. For each session, the user will receive a new authentication token that will expire <code>timeToLive</code> seconds after the <code>currentTime</code>. If the token is renewed, the expiry time will be <b>extended</b> to expire <code>timeToLive</code> seconds after the (potentially different) <code>currentTime</code>.</p>\n\n<p>Implement the <code>AuthenticationManager</code> class:</p>\n\n<ul>\n\t<li><code>AuthenticationManager(int timeToLive)</code> constructs the <code>AuthenticationManager</code> and sets the <code>timeToLive</code>.</li>\n\t<li><code>generate(string tokenId, int currentTime)</code> generates a new token with the given <code>tokenId</code> at the given <code>currentTime</code> in seconds.</li>\n\t<li><code>renew(string tokenId, int currentTime)</code> renews the <strong>unexpired</strong> token with the given <code>tokenId</code> at the given <code>currentTime</code> in seconds. If there are no unexpired tokens with the given <code>tokenId</code>, the request is ignored, and nothing happens.</li>\n\t<li><code>countUnexpiredTokens(int currentTime)</code> returns the number of <strong>unexpired</strong> tokens at the given currentTime.</li>\n</ul>\n\n<p>Note that if a token expires at time <code>t</code>, and another action happens on time <code>t</code> (<code>renew</code> or <code>countUnexpiredTokens</code>), the expiration takes place <strong>before</strong> the other actions.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/25/copy-of-pc68_q2.png\" style=\"width: 500px; height: 287px;\" />\n<pre>\n<strong>Input</strong>\n[&quot;AuthenticationManager&quot;, &quot;<code>renew</code>&quot;, &quot;generate&quot;, &quot;<code>countUnexpiredTokens</code>&quot;, &quot;generate&quot;, &quot;<code>renew</code>&quot;, &quot;<code>renew</code>&quot;, &quot;<code>countUnexpiredTokens</code>&quot;]\n[[5], [&quot;aaa&quot;, 1], [&quot;aaa&quot;, 2], [6], [&quot;bbb&quot;, 7], [&quot;aaa&quot;, 8], [&quot;bbb&quot;, 10], [15]]\n<strong>Output</strong>\n[null, null, null, 1, null, null, null, 0]\n\n<strong>Explanation</strong>\nAuthenticationManager authenticationManager = new AuthenticationManager(5); // Constructs the AuthenticationManager with <code>timeToLive</code> = 5 seconds.\nauthenticationManager.<code>renew</code>(&quot;aaa&quot;, 1); // No token exists with tokenId &quot;aaa&quot; at time 1, so nothing happens.\nauthenticationManager.generate(&quot;aaa&quot;, 2); // Generates a new token with tokenId &quot;aaa&quot; at time 2.\nauthenticationManager.<code>countUnexpiredTokens</code>(6); // The token with tokenId &quot;aaa&quot; is the only unexpired one at time 6, so return 1.\nauthenticationManager.generate(&quot;bbb&quot;, 7); // Generates a new token with tokenId &quot;bbb&quot; at time 7.\nauthenticationManager.<code>renew</code>(&quot;aaa&quot;, 8); // The token with tokenId &quot;aaa&quot; expired at time 7, and 8 &gt;= 7, so at time 8 the <code>renew</code> request is ignored, and nothing happens.\nauthenticationManager.<code>renew</code>(&quot;bbb&quot;, 10); // The token with tokenId &quot;bbb&quot; is unexpired at time 10, so the <code>renew</code> request is fulfilled and now the token will expire at time 15.\nauthenticationManager.<code>countUnexpiredTokens</code>(15); // The token with tokenId &quot;bbb&quot; expires at time 15, and the token with tokenId &quot;aaa&quot; expired at time 7, so currently no token is unexpired, so return 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= timeToLive &lt;= 10<sup>8</sup></code></li>\n\t<li><code>1 &lt;= currentTime &lt;= 10<sup>8</sup></code></li>\n\t<li><code>1 &lt;= tokenId.length &lt;= 5</code></li>\n\t<li><code>tokenId</code> consists only of lowercase letters.</li>\n\t<li>All calls to <code>generate</code> will contain unique values of <code>tokenId</code>.</li>\n\t<li>The values of <code>currentTime</code> across all the function calls will be <strong>strictly increasing</strong>.</li>\n\t<li>At most <code>2000</code> calls will be made to all functions combined.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1118798,
                "title": "c-time-map-and-token-map",
                "content": "A naive single-map solution is accepted (and that\\'s why this problem is only 4 points). For an interivew, however, it won\\'t cut it. If you add 1000 tokens, and query 1000 times, the overal complexity will be quadratic. The test cases here are weak, so the difference between two-map and single-map solution is small (60 ms vs. 78 ms). \\n\\nYou can make this more efficient by adding `time_map`, where tokens are ordered by time. That way, we can identify expired tokens.\\n\\nThe `token_map` maps tokens to their current expiration times.\\n\\n```cpp\\nclass AuthenticationManager {\\npublic:\\n    int ttl = 0;\\n    set<pair<int, string>> time_map;\\n    unordered_map<string, int> token_map;\\n    AuthenticationManager(int timeToLive) : ttl(timeToLive) {}\\n    void clean(int currentTime) {\\n        while(!time_map.empty() && begin(time_map)->first <= currentTime) {\\n            token_map.erase(begin(time_map)->second);\\n            time_map.erase(begin(time_map));\\n        }\\n    }\\n    void generate(string tokenId, int currentTime) {\\n        token_map[tokenId] = currentTime + ttl;\\n        time_map.insert({currentTime + ttl, tokenId});\\n    }\\n    void renew(string tokenId, int currentTime) {\\n        clean(currentTime);\\n        auto it = token_map.find(tokenId);\\n        if (it != end(token_map)) {\\n            time_map.erase({it->second, it->first});\\n            it->second = currentTime + ttl;\\n            time_map.insert({currentTime + ttl, tokenId});\\n        }\\n    }\\n    int countUnexpiredTokens(int currentTime) {\\n        clean(currentTime);\\n        return token_map.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass AuthenticationManager {\\npublic:\\n    int ttl = 0;\\n    set<pair<int, string>> time_map;\\n    unordered_map<string, int> token_map;\\n    AuthenticationManager(int timeToLive) : ttl(timeToLive) {}\\n    void clean(int currentTime) {\\n        while(!time_map.empty() && begin(time_map)->first <= currentTime) {\\n            token_map.erase(begin(time_map)->second);\\n            time_map.erase(begin(time_map));\\n        }\\n    }\\n    void generate(string tokenId, int currentTime) {\\n        token_map[tokenId] = currentTime + ttl;\\n        time_map.insert({currentTime + ttl, tokenId});\\n    }\\n    void renew(string tokenId, int currentTime) {\\n        clean(currentTime);\\n        auto it = token_map.find(tokenId);\\n        if (it != end(token_map)) {\\n            time_map.erase({it->second, it->first});\\n            it->second = currentTime + ttl;\\n            time_map.insert({currentTime + ttl, tokenId});\\n        }\\n    }\\n    int countUnexpiredTokens(int currentTime) {\\n        clean(currentTime);\\n        return token_map.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1118796,
                "title": "java-python-3-two-codes-hashmap-dict-and-linkedhashmap-ordereddict",
                "content": "**Method 1: HashMap**\\n\\nUse `tailMap` to skip expired tokens.\\n```java\\n    private TreeMap<Integer, String> tm = new TreeMap<>();\\n    private Map<String, Integer> expireTime = new HashMap<>();\\n    private int life;\\n    \\n    public AuthenticationManager(int timeToLive) {\\n        life = timeToLive;\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        expireTime.put(tokenId, life + currentTime);\\n        tm.put(life + currentTime, tokenId);         \\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        int expire = expireTime.getOrDefault(tokenId, -1);\\n        var tail = tm.tailMap(currentTime + 1);\\n        if (!tail.isEmpty() && expire >= tail.firstKey()) {\\n            tm.remove(expire);\\n            tm.put(life + currentTime, tokenId);\\n            expireTime.put(tokenId, life + currentTime);\\n        }\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        return tm.tailMap(currentTime + 1).size();\\n    }\\n```\\nOr simplified as the following: -- credit to **@OPyrohov**\\n```java\\n    private Map<String, Integer> expiry = new HashMap<>();\\n    private int life;\\n    \\n    public AuthenticationManager(int timeToLive) {\\n        life = timeToLive;\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        expiry.put(tokenId, life + currentTime);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        if (expiry.getOrDefault(tokenId, -1) > currentTime) {\\n            expiry.put(tokenId, life + currentTime);\\n        }\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        expiry.entrySet().removeIf(e -> e.getValue() <= currentTime);\\n        return expiry.size();\\n    }\\n```\\n**Analysis:**\\nTime complexity of ` countUnexpiredTokens`: `O(n)`\\nOther methods cost time: `O(1)`\\n\\n----\\n\\nNot sure if we can use LinkedHashMap/OrderedDict for the problem, ask interviewer first during interview.\\n\\n**Method 2: LinkedHashMap**\\n\\n```java\\n    private Map<String, Integer> expiry = new LinkedHashMap<>(16, 0.75F, true); // here true indicates the map entries are in access order.\\n    private int life;\\n    \\n    public AuthenticationManager(int timeToLive) {\\n        life = timeToLive;\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        evictExpired(currentTime);\\n        expiry.put(tokenId, life + currentTime);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        evictExpired(currentTime);\\n        if (expiry.containsKey(tokenId)) {\\n            expiry.put(tokenId, life + currentTime);\\n        }\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        evictExpired(currentTime);\\n        return expiry.size();\\n    }\\n    \\n    private void evictExpired(int currentTime) {\\n        var iter = expiry.entrySet().iterator();\\n        while (iter.hasNext() && iter.next().getValue() <= currentTime) {\\n            iter.remove();\\n        }\\n    }\\n```\\n```python\\n    def __init__(self, timeToLive: int):\\n        self.expiry = OrderedDict()\\n        self.life = timeToLive\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self.evict_expired(currentTime)\\n        self.expiry[tokenId] = self.life + currentTime\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        self.evict_expired(currentTime)\\n        if tokenId in self.expiry:\\n            self.expiry.move_to_end(tokenId) # necessary to move to the end to keep expiry time in ascending order.\\n            self.expiry[tokenId] = self.life + currentTime\\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        self.evict_expired(currentTime)\\n        return len(self.expiry)    \\n    \\n    def evict_expired(self, currentTime: int) -> None:\\n        while self.expiry and next(iter(self.expiry.values())) <= currentTime:\\n            self.expiry.popitem(last=False)\\n```\\n**Analysis:**\\nAll methods cost amortized time `O(1)`.",
                "solutionTags": [],
                "code": "```java\\n    private TreeMap<Integer, String> tm = new TreeMap<>();\\n    private Map<String, Integer> expireTime = new HashMap<>();\\n    private int life;\\n    \\n    public AuthenticationManager(int timeToLive) {\\n        life = timeToLive;\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        expireTime.put(tokenId, life + currentTime);\\n        tm.put(life + currentTime, tokenId);         \\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        int expire = expireTime.getOrDefault(tokenId, -1);\\n        var tail = tm.tailMap(currentTime + 1);\\n        if (!tail.isEmpty() && expire >= tail.firstKey()) {\\n            tm.remove(expire);\\n            tm.put(life + currentTime, tokenId);\\n            expireTime.put(tokenId, life + currentTime);\\n        }\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        return tm.tailMap(currentTime + 1).size();\\n    }\\n```\n```java\\n    private Map<String, Integer> expiry = new HashMap<>();\\n    private int life;\\n    \\n    public AuthenticationManager(int timeToLive) {\\n        life = timeToLive;\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        expiry.put(tokenId, life + currentTime);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        if (expiry.getOrDefault(tokenId, -1) > currentTime) {\\n            expiry.put(tokenId, life + currentTime);\\n        }\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        expiry.entrySet().removeIf(e -> e.getValue() <= currentTime);\\n        return expiry.size();\\n    }\\n```\n```java\\n    private Map<String, Integer> expiry = new LinkedHashMap<>(16, 0.75F, true); // here true indicates the map entries are in access order.\\n    private int life;\\n    \\n    public AuthenticationManager(int timeToLive) {\\n        life = timeToLive;\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        evictExpired(currentTime);\\n        expiry.put(tokenId, life + currentTime);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        evictExpired(currentTime);\\n        if (expiry.containsKey(tokenId)) {\\n            expiry.put(tokenId, life + currentTime);\\n        }\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        evictExpired(currentTime);\\n        return expiry.size();\\n    }\\n    \\n    private void evictExpired(int currentTime) {\\n        var iter = expiry.entrySet().iterator();\\n        while (iter.hasNext() && iter.next().getValue() <= currentTime) {\\n            iter.remove();\\n        }\\n    }\\n```\n```python\\n    def __init__(self, timeToLive: int):\\n        self.expiry = OrderedDict()\\n        self.life = timeToLive\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self.evict_expired(currentTime)\\n        self.expiry[tokenId] = self.life + currentTime\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        self.evict_expired(currentTime)\\n        if tokenId in self.expiry:\\n            self.expiry.move_to_end(tokenId) # necessary to move to the end to keep expiry time in ascending order.\\n            self.expiry[tokenId] = self.life + currentTime\\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        self.evict_expired(currentTime)\\n        return len(self.expiry)    \\n    \\n    def evict_expired(self, currentTime: int) -> None:\\n        while self.expiry and next(iter(self.expiry.values())) <= currentTime:\\n            self.expiry.popitem(last=False)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1118899,
                "title": "short-easy-w-explanation-clean-code-with-comments",
                "content": "```\\nclass AuthenticationManager {\\npublic:\\n\\t// used for mapping tokenId with generation time\\n    unordered_map<string, int >mp;\\n    int ttl;\\n    AuthenticationManager(int timeToLive) : ttl(timeToLive){}\\n    \\t\\n    void generate(string tokenId, int currentTime) {\\n\\t\\t// store tokenId mapped with time of generation\\n        mp[tokenId] = currentTime;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n\\t\\t// tokenId must be already created and time since generation should be less than TTL\\n        if(mp.count(tokenId) && currentTime - mp[tokenId] < ttl)\\n            mp[tokenId] = currentTime; // renew if condition is satisfied\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int cnt = 0;\\n        for(auto& token:mp)\\n\\t\\t\\t// count all tokens which time since generation less than TTL\\n            if(currentTime - token.second < ttl) cnt++;\\n        return cnt;\\n    }\\n};\\n```\\n\\n**Time Complexity** : **`O(1)`** for generation and renewal and **`O(N)`** for counting unexpired tokens, where `N` is the total number of generated tokens.\\n\\n**Space Complexity** : **`O(N)`**\\n\\n\\n----------\\n----------",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass AuthenticationManager {\\npublic:\\n\\t// used for mapping tokenId with generation time\\n    unordered_map<string, int >mp;\\n    int ttl;\\n    AuthenticationManager(int timeToLive) : ttl(timeToLive){}\\n    \\t\\n    void generate(string tokenId, int currentTime) {\\n\\t\\t// store tokenId mapped with time of generation\\n        mp[tokenId] = currentTime;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n\\t\\t// tokenId must be already created and time since generation should be less than TTL\\n        if(mp.count(tokenId) && currentTime - mp[tokenId] < ttl)\\n            mp[tokenId] = currentTime; // renew if condition is satisfied\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int cnt = 0;\\n        for(auto& token:mp)\\n\\t\\t\\t// count all tokens which time since generation less than TTL\\n            if(currentTime - token.second < ttl) cnt++;\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119001,
                "title": "java-linkedhashmap",
                "content": "Clean expired item for each operation. Use LinkedHashMap to keep the order as also can get item in constant time.\\n```\\nclass AuthenticationManager {\\n    private int timeToLive;\\n    private Map<String, Integer> map = new LinkedHashMap<String, Integer>(); \\n\\n    public AuthenticationManager(int timeToLive) {\\n        this.timeToLive = timeToLive;\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        clean(currentTime);\\n        map.put(tokenId, currentTime + timeToLive);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        clean(currentTime);\\n        \\n        if(map.get(tokenId) != null) {\\n            map.remove(tokenId);\\n            map.put(tokenId, currentTime + timeToLive);\\n        }\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        clean(currentTime);\\n        \\n        return map.size();\\n    }\\n    \\n    private void clean(int currentTime) {\\n        for(Iterator<String> it = map.keySet().iterator(); it.hasNext(); ) {\\n            String key = it.next();\\n            if(map.get(key) <= currentTime) {\\n                it.remove();\\n            }else{\\n                break;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass AuthenticationManager {\\n    private int timeToLive;\\n    private Map<String, Integer> map = new LinkedHashMap<String, Integer>(); \\n\\n    public AuthenticationManager(int timeToLive) {\\n        this.timeToLive = timeToLive;\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        clean(currentTime);\\n        map.put(tokenId, currentTime + timeToLive);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        clean(currentTime);\\n        \\n        if(map.get(tokenId) != null) {\\n            map.remove(tokenId);\\n            map.put(tokenId, currentTime + timeToLive);\\n        }\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        clean(currentTime);\\n        \\n        return map.size();\\n    }\\n    \\n    private void clean(int currentTime) {\\n        for(Iterator<String> it = map.keySet().iterator(); it.hasNext(); ) {\\n            String key = it.next();\\n            if(map.get(key) <= currentTime) {\\n                it.remove();\\n            }else{\\n                break;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1118827,
                "title": "clean-python-with-explanation",
                "content": "```\\nclass AuthenticationManager(object):\\n\\n    def __init__(self, timeToLive):\\n        self.token = dict()\\n        self.time = timeToLive    # store timeToLive and create dictionary\\n\\n    def generate(self, tokenId, currentTime):\\n        self.token[tokenId] = currentTime    # store tokenId with currentTime\\n\\n    def renew(self, tokenId, currentTime):\\n        limit = currentTime-self.time        # calculate limit time to filter unexpired tokens\\n        if tokenId in self.token and self.token[tokenId]>limit:    # filter tokens and renew its time\\n            self.token[tokenId] = currentTime\\n\\n    def countUnexpiredTokens(self, currentTime):\\n        limit = currentTime-self.time       # calculate limit time to filter unexpired tokens\\n        c = 0\\n        for i in self.token:\\n            if self.token[i]>limit:         # count unexpired tokens\\n                c+=1\\n        return c\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass AuthenticationManager(object):\\n\\n    def __init__(self, timeToLive):\\n        self.token = dict()\\n        self.time = timeToLive    # store timeToLive and create dictionary\\n\\n    def generate(self, tokenId, currentTime):\\n        self.token[tokenId] = currentTime    # store tokenId with currentTime\\n\\n    def renew(self, tokenId, currentTime):\\n        limit = currentTime-self.time        # calculate limit time to filter unexpired tokens\\n        if tokenId in self.token and self.token[tokenId]>limit:    # filter tokens and renew its time\\n            self.token[tokenId] = currentTime\\n\\n    def countUnexpiredTokens(self, currentTime):\\n        limit = currentTime-self.time       # calculate limit time to filter unexpired tokens\\n        c = 0\\n        for i in self.token:\\n            if self.token[i]>limit:         # count unexpired tokens\\n                c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1118956,
                "title": "c-clean-code-single-map-solution-explained",
                "content": "The problem is pretty straightforward, so the real challenge is just to get things working as efficiently, scalably and cleanly as possible.\\n\\nI gave it a shot by first of all defining to class variables:\\n* `ttl` will store the supplied `timeToLive`;\\n* `tokens` is a `unordered_map` with the `{tokenId => expiryTime}` logic.\\n\\nOur constructor will just set `ttl` - nothing more, nothing less.\\n\\n`generate` is also pretty straightforward, adding a new key => value mapping to `tokens`, with the value (the expiry time) set to be `currentTime + ttl`.\\n\\n`renew` starts to we a slightly more complex logic: we will first of all try to find if we have already a mapping for that specific `tokenId` and, only if we have it and its expiry time was below `currentTime`, update it to be `currentTime + ttl`.\\n\\nFinally `countUnexpiredTokens` will trivially iterate through all the current elements of `tokens` and increase the counter `res` for each one that is not expired yet, right before returning `res` itself.\\n\\nThe code:\\n\\n```cpp\\nclass AuthenticationManager {\\n    int ttl;\\n    unordered_map<string, int> tokens;\\npublic:\\n    AuthenticationManager(int timeToLive) {\\n        ttl = timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        tokens[tokenId] = currentTime + ttl;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        auto tokenIt = tokens.find(tokenId);\\n        if (tokenIt != end(tokens) && tokenIt->second > currentTime) {\\n            tokenIt->second = currentTime + ttl;\\n        }\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int res = 0;\\n        for (auto token: tokens) {\\n            if (token.second > currentTime) res++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nI tried to get marginally better performance by removing expired tokens, so to reduce the elements we are going to loop through when counting, with little to no gains:\\n\\n```cpp\\n    void renew(string tokenId, int currentTime) {\\n        auto tokenIt = tokens.find(tokenId);\\n        if (tokenIt != end(tokens)) {\\n            // updating if still valid\\n            if (tokenIt->second > currentTime) tokenIt->second = currentTime + ttl;\\n            // erasing if expired\\n            else tokens.erase(tokenIt);\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass AuthenticationManager {\\n    int ttl;\\n    unordered_map<string, int> tokens;\\npublic:\\n    AuthenticationManager(int timeToLive) {\\n        ttl = timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        tokens[tokenId] = currentTime + ttl;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        auto tokenIt = tokens.find(tokenId);\\n        if (tokenIt != end(tokens) && tokenIt->second > currentTime) {\\n            tokenIt->second = currentTime + ttl;\\n        }\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int res = 0;\\n        for (auto token: tokens) {\\n            if (token.second > currentTime) res++;\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\n    void renew(string tokenId, int currentTime) {\\n        auto tokenIt = tokens.find(tokenId);\\n        if (tokenIt != end(tokens)) {\\n            // updating if still valid\\n            if (tokenIt->second > currentTime) tokenIt->second = currentTime + ttl;\\n            // erasing if expired\\n            else tokens.erase(tokenIt);\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1118878,
                "title": "python3-java-ordereddict-linkedhashmap-o-1-with-detailed-explanation",
                "content": "Suppose we have a dict where the key is `tokenId` and value is `expireTime`, how can we know the order of the `expireTime` such that we can easily remove the outdated entry everytime?\\n\\nHere is a specific data structure coming to rescue!\\n\\nPython\\'s `OrderedDict` and Java\\'s `LinkedHashMap` can preserve the **key insertion order** while keep providing HashMap\\'s O(1) insert and delete, and also can move any key to the front or the back of the dict in O(1). \\n\\nThis data structure is actually a combination of  **doubly linked list + hash map** , which is usually used for [LRU cache](https://leetcode.com/problems/lru-cache/) or [LFU cache](https://leetcode.com/problems/lfu-cache/). These two problems are very good use cases for `OrderedDict`\\n\\nNow we know that the `currentTime` is in strict increasing order! If we use an `OrderedDict` to keep the increasing timestamp order (because we always push new items at tail), we can easily know that every keys we want to remove is at the front of the dict.\\n\\nPython\\n\\n```python\\nclass AuthenticationManager:\\n    def __init__(self, timeToLive: int):\\n        self._time = timeToLive\\n        self._dict = collections.OrderedDict()\\n    \\n\\t# remove all outdated keys if there is any\\n    def _evict(self, currentTime):\\n        while self._dict and next(iter(self._dict.values())) <= currentTime:\\n            self._dict.popitem(last=False)\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self._evict(currentTime)\\n        self._dict[tokenId] = currentTime + self._time # put new keys at the tail (the newest)\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        self._evict(currentTime)\\n            \\n        if tokenId not in self._dict:\\n            return\\n\\t\\t# move new item to the end of the OrderedDict\\n        self._dict.move_to_end(tokenId) # the renew key must be the newest, so move to tail\\n        self._dict[tokenId] = currentTime + self._time\\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        self._evict(currentTime)\\n        return len(self._dict)\\n\\n```\\n\\nJava\\n\\nNote that Java `LinkedHashMap`\\'s constructor has an argument to define whether **access an element causing the element to be put at the tail automatically**, which is the third argument in the constructor. In this case, we want this feature exactly when we are calling `renew`, thus we set it to `true`. More information can be referred to [Java doc](https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html)\\n\\n```java\\nclass AuthenticationManager {\\n    private int time;\\n\\t// true means accessing an existing element will change the order of that element too\\n    private Map<String, Integer> dict = new LinkedHashMap<>(16, 0.75f, true);\\n\\n    public AuthenticationManager(int timeToLive) {\\n        time = timeToLive;\\n    }\\n    \\n    private void evict(int currentTime) {\\n        Iterator<Map.Entry<String, Integer>> it;\\n        while (!dict.isEmpty() && (it = dict.entrySet().iterator()).next().getValue() <= currentTime) {\\n            it.remove();\\n        }\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        evict(currentTime);\\n        dict.put(tokenId, currentTime + time);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        evict(currentTime);\\n        if (dict.containsKey(tokenId)) {\\n            dict.put(tokenId, currentTime + time); // entry will be automatically set as the newest one\\n        }\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        evict(currentTime);\\n        return dict.size();\\n    }\\n}\\n```\\n\\nTime complexity analysis:\\n\\nAlthough we may need to evict multiple keys during a call, but considered that the every key will only be popped out once, therefore the amortized time complexity of all the three APIs are O(1)\\n",
                "solutionTags": [],
                "code": "```python\\nclass AuthenticationManager:\\n    def __init__(self, timeToLive: int):\\n        self._time = timeToLive\\n        self._dict = collections.OrderedDict()\\n    \\n\\t# remove all outdated keys if there is any\\n    def _evict(self, currentTime):\\n        while self._dict and next(iter(self._dict.values())) <= currentTime:\\n            self._dict.popitem(last=False)\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self._evict(currentTime)\\n        self._dict[tokenId] = currentTime + self._time # put new keys at the tail (the newest)\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        self._evict(currentTime)\\n            \\n        if tokenId not in self._dict:\\n            return\\n\\t\\t# move new item to the end of the OrderedDict\\n        self._dict.move_to_end(tokenId) # the renew key must be the newest, so move to tail\\n        self._dict[tokenId] = currentTime + self._time\\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        self._evict(currentTime)\\n        return len(self._dict)\\n\\n```\n```java\\nclass AuthenticationManager {\\n    private int time;\\n\\t// true means accessing an existing element will change the order of that element too\\n    private Map<String, Integer> dict = new LinkedHashMap<>(16, 0.75f, true);\\n\\n    public AuthenticationManager(int timeToLive) {\\n        time = timeToLive;\\n    }\\n    \\n    private void evict(int currentTime) {\\n        Iterator<Map.Entry<String, Integer>> it;\\n        while (!dict.isEmpty() && (it = dict.entrySet().iterator()).next().getValue() <= currentTime) {\\n            it.remove();\\n        }\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        evict(currentTime);\\n        dict.put(tokenId, currentTime + time);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        evict(currentTime);\\n        if (dict.containsKey(tokenId)) {\\n            dict.put(tokenId, currentTime + time); // entry will be automatically set as the newest one\\n        }\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        evict(currentTime);\\n        return dict.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1118881,
                "title": "clean-python-3-hashmap",
                "content": "Time: `O(max unexpired)` for `countUnexpiredTokens`, `O(1)` for others\\nSpace: `O(max unexpired)`\\n```\\nclass AuthenticationManager:\\n    def __init__(self, timeToLive: int):\\n        self.time = timeToLive\\n        self.unexpired = {}\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self.unexpired[tokenId] = currentTime + self.time\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if self.unexpired.get(tokenId, 0) > currentTime:\\n            self.unexpired[tokenId] = currentTime + self.time\\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        for token in tuple(self.unexpired.keys()):\\n            if self.unexpired[token] <= currentTime:\\n                self.unexpired.pop(token)\\n        return len(self.unexpired)\\n```",
                "solutionTags": [],
                "code": "```\\nclass AuthenticationManager:\\n    def __init__(self, timeToLive: int):\\n        self.time = timeToLive\\n        self.unexpired = {}\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self.unexpired[tokenId] = currentTime + self.time\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if self.unexpired.get(tokenId, 0) > currentTime:\\n            self.unexpired[tokenId] = currentTime + self.time\\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        for token in tuple(self.unexpired.keys()):\\n            if self.unexpired[token] <= currentTime:\\n                self.unexpired.pop(token)\\n        return len(self.unexpired)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899713,
                "title": "in-javascript-using-hashmap",
                "content": "```\\n/**\\n * @param {number} timeToLive\\n */\\nvar AuthenticationManager = function(timeToLive) {\\n    this.timeToLive=timeToLive;\\n    this.tokens=new Map();\\n};\\n\\n/** \\n * @param {string} tokenId \\n * @param {number} currentTime\\n * @return {void}\\n */\\nAuthenticationManager.prototype.generate = function(tokenId, currentTime) {\\n    if(!this.tokens.has(tokenId)){\\n        let tokenInfo={\\n            tokenId:tokenId,\\n            expiresAt:currentTime+this.timeToLive\\n        }\\n        this.tokens.set(tokenId,tokenInfo);\\n    }\\n};\\n\\n/** \\n * @param {string} tokenId \\n * @param {number} currentTime\\n * @return {void}\\n */\\nAuthenticationManager.prototype.renew = function(tokenId, currentTime) {\\n    if(!this.tokens.has(tokenId)) return;\\n    \\n    let token=this.tokens.get(tokenId);\\n    if(token.expiresAt>currentTime){\\n        this.tokens.set(tokenId,{...token,expiresAt:currentTime+this.timeToLive})\\n    }else{\\n        this.tokens.delete(tokenId);\\n    }\\n};\\n\\n/** \\n * @param {number} currentTime\\n * @return {number}\\n */\\nAuthenticationManager.prototype.countUnexpiredTokens = function(currentTime) {\\n    let activeTokensCount=0;\\n    for(let [key,token] of this.tokens.entries()){\\n        if(token.expiresAt>currentTime) activeTokensCount++;\\n    }\\n    return activeTokensCount;\\n};\\n\\n/** \\n * Your AuthenticationManager object will be instantiated and called as such:\\n * var obj = new AuthenticationManager(timeToLive)\\n * obj.generate(tokenId,currentTime)\\n * obj.renew(tokenId,currentTime)\\n * var param_3 = obj.countUnexpiredTokens(currentTime)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} timeToLive\\n */\\nvar AuthenticationManager = function(timeToLive) {\\n    this.timeToLive=timeToLive;\\n    this.tokens=new Map();\\n};\\n\\n/** \\n * @param {string} tokenId \\n * @param {number} currentTime\\n * @return {void}\\n */\\nAuthenticationManager.prototype.generate = function(tokenId, currentTime) {\\n    if(!this.tokens.has(tokenId)){\\n        let tokenInfo={\\n            tokenId:tokenId,\\n            expiresAt:currentTime+this.timeToLive\\n        }\\n        this.tokens.set(tokenId,tokenInfo);\\n    }\\n};\\n\\n/** \\n * @param {string} tokenId \\n * @param {number} currentTime\\n * @return {void}\\n */\\nAuthenticationManager.prototype.renew = function(tokenId, currentTime) {\\n    if(!this.tokens.has(tokenId)) return;\\n    \\n    let token=this.tokens.get(tokenId);\\n    if(token.expiresAt>currentTime){\\n        this.tokens.set(tokenId,{...token,expiresAt:currentTime+this.timeToLive})\\n    }else{\\n        this.tokens.delete(tokenId);\\n    }\\n};\\n\\n/** \\n * @param {number} currentTime\\n * @return {number}\\n */\\nAuthenticationManager.prototype.countUnexpiredTokens = function(currentTime) {\\n    let activeTokensCount=0;\\n    for(let [key,token] of this.tokens.entries()){\\n        if(token.expiresAt>currentTime) activeTokensCount++;\\n    }\\n    return activeTokensCount;\\n};\\n\\n/** \\n * Your AuthenticationManager object will be instantiated and called as such:\\n * var obj = new AuthenticationManager(timeToLive)\\n * obj.generate(tokenId,currentTime)\\n * obj.renew(tokenId,currentTime)\\n * var param_3 = obj.countUnexpiredTokens(currentTime)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1118923,
                "title": "c-unordered-map-queue-faster-than-100",
                "content": "```\\nclass AuthenticationManager {\\n    queue<pair<string, int>> q;\\n    unordered_map<string,int> mp;\\n    int ttl;\\n    \\n\\t//remove all the expired tokens in queue\\n    void removeExpired(int t){\\n        while(!q.empty() && q.front().second <= t){\\n            string id = q.front().first;\\n            if(mp[id] == q.front().second)\\n                mp.erase(id);\\n            q.pop();\\n        }\\n    }\\npublic:\\n    AuthenticationManager(int timeToLive) {\\n        ttl = timeToLive;\\n    }\\n    \\n    void generate(string id, int t) {\\n        removeExpired(t);\\n        mp[id] = t + ttl;\\n        q.emplace(id, t+ttl);\\n    }\\n    \\n    void renew(string id, int t) {\\n        removeExpired(t);\\n        if(mp.find(id) == mp.end())\\n            return;\\n\\t\\t//update new time in map and insert this item in queue\\n\\t\\t//we can ignore multiple items in queue for same element since older item will anyways be removed\\n        q.emplace(id,t+ttl);\\n        mp[id] = t + ttl;\\n    }\\n    \\n    int countUnexpiredTokens(int t) {\\n        removeExpired(t);\\n        return mp.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass AuthenticationManager {\\n    queue<pair<string, int>> q;\\n    unordered_map<string,int> mp;\\n    int ttl;\\n    \\n\\t//remove all the expired tokens in queue\\n    void removeExpired(int t){\\n        while(!q.empty() && q.front().second <= t){\\n            string id = q.front().first;\\n            if(mp[id] == q.front().second)\\n                mp.erase(id);\\n            q.pop();\\n        }\\n    }\\npublic:\\n    AuthenticationManager(int timeToLive) {\\n        ttl = timeToLive;\\n    }\\n    \\n    void generate(string id, int t) {\\n        removeExpired(t);\\n        mp[id] = t + ttl;\\n        q.emplace(id, t+ttl);\\n    }\\n    \\n    void renew(string id, int t) {\\n        removeExpired(t);\\n        if(mp.find(id) == mp.end())\\n            return;\\n\\t\\t//update new time in map and insert this item in queue\\n\\t\\t//we can ignore multiple items in queue for same element since older item will anyways be removed\\n        q.emplace(id,t+ttl);\\n        mp[id] = t + ttl;\\n    }\\n    \\n    int countUnexpiredTokens(int t) {\\n        removeExpired(t);\\n        return mp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3993831,
                "title": "c-solution-hash-map-fully-commented",
                "content": "\\n# Code\\n```\\nclass AuthenticationManager {\\npublic:\\n    unordered_map<string, int>mp;\\n    int time= 0;\\n    AuthenticationManager(int timeToLive) {\\n        time= timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        mp[tokenId]= currentTime + time;// This will give you our expiry time at which we will be logged out from the site.\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        auto it= mp.find(tokenId); //check if the token is available or not, if it\\'s not available return.\\n        if(it==mp.end())\\n        return;\\n        else{\\n        if(mp[tokenId]>currentTime) // if the token is available and it\\'s expiry time is greater than current time renew and update the expiry time\\n        {\\n            mp[tokenId]= currentTime + time;  // update the expiry time by adding the current time with timeToLive value i.e 5 here.\\n        }\\n        }\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int total=0;\\n        for(auto x:mp) // iterate through every token and check if any token has it\\'s expiry time greater than currentTime, if yes do total= total+1, it is simply calculating the remaining time here.\\n        {\\n            // cout<<x.second<<\" \";\\n            if(x.second>currentTime)\\n            total++;\\n        }\\n        return total;\\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass AuthenticationManager {\\npublic:\\n    unordered_map<string, int>mp;\\n    int time= 0;\\n    AuthenticationManager(int timeToLive) {\\n        time= timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        mp[tokenId]= currentTime + time;// This will give you our expiry time at which we will be logged out from the site.\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        auto it= mp.find(tokenId); //check if the token is available or not, if it\\'s not available return.\\n        if(it==mp.end())\\n        return;\\n        else{\\n        if(mp[tokenId]>currentTime) // if the token is available and it\\'s expiry time is greater than current time renew and update the expiry time\\n        {\\n            mp[tokenId]= currentTime + time;  // update the expiry time by adding the current time with timeToLive value i.e 5 here.\\n        }\\n        }\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int total=0;\\n        for(auto x:mp) // iterate through every token and check if any token has it\\'s expiry time greater than currentTime, if yes do total= total+1, it is simply calculating the remaining time here.\\n        {\\n            // cout<<x.second<<\" \";\\n            if(x.second>currentTime)\\n            total++;\\n        }\\n        return total;\\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1121429,
                "title": "python3-bruth-force-hash-map",
                "content": "```\\nclass AuthenticationManager:\\n\\n    def __init__(self, timeToLive: int):\\n        self.ttl = timeToLive\\n        self.record = {}\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self.record[tokenId] = currentTime\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if tokenId in self.record:\\n            if self.record[tokenId] + self.ttl > currentTime:\\n                self.record[tokenId] = currentTime\\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        return sum(1 for time in self.record.values() if time <= currentTime < time + self.ttl)\\n```",
                "solutionTags": [],
                "code": "```\\nclass AuthenticationManager:\\n\\n    def __init__(self, timeToLive: int):\\n        self.ttl = timeToLive\\n        self.record = {}\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self.record[tokenId] = currentTime\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if tokenId in self.record:\\n            if self.record[tokenId] + self.ttl > currentTime:\\n                self.record[tokenId] = currentTime\\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        return sum(1 for time in self.record.values() if time <= currentTime < time + self.ttl)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837676,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Map\\n\\n\\n# Code\\n```\\nclass AuthenticationManager {\\npublic:\\n    int timeToLive;\\n    unordered_map<string, int> mp;\\n    \\n    AuthenticationManager(int timeToLive) {\\n        this->timeToLive = timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        mp[tokenId] = currentTime + timeToLive;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if (mp[tokenId] > currentTime) mp[tokenId] = currentTime + timeToLive;\\n        else mp[tokenId] = 0;\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int ans = 0;\\n        for (auto x: mp) {\\n            if (x.second > currentTime) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass AuthenticationManager {\\npublic:\\n    int timeToLive;\\n    unordered_map<string, int> mp;\\n    \\n    AuthenticationManager(int timeToLive) {\\n        this->timeToLive = timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        mp[tokenId] = currentTime + timeToLive;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if (mp[tokenId] > currentTime) mp[tokenId] = currentTime + timeToLive;\\n        else mp[tokenId] = 0;\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int ans = 0;\\n        for (auto x: mp) {\\n            if (x.second > currentTime) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3036045,
                "title": "easiest-java-solution-for-beginners",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass AuthenticationManager {\\n\\n    int time=0;\\n\\n    HashMap<String,Integer>mp=new HashMap<>();\\n\\n    public AuthenticationManager(int timeToLive) {\\n        \\n    time=timeToLive;\\n\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        \\n    mp.put(tokenId,currentTime+time);\\n\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        \\n    if(!mp.containsKey(tokenId)||mp.get(tokenId)<=currentTime)\\n    {\\n    return;\\n    }\\n\\n    mp.put(tokenId,currentTime+time);\\n\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n    \\n    List<String>lr=new ArrayList<>(mp.keySet());\\n    \\n    for(int i=0;i<lr.size();i++){\\n    \\n    if(mp.get(lr.get(i))<=currentTime)mp.remove(lr.get(i));\\n\\n    }\\n\\n    return mp.size();\\n    \\n    }\\n}\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager obj = new AuthenticationManager(timeToLive);\\n * obj.generate(tokenId,currentTime);\\n * obj.renew(tokenId,currentTime);\\n * int param_3 = obj.countUnexpiredTokens(currentTime);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Design"
                ],
                "code": "```\\nclass AuthenticationManager {\\n\\n    int time=0;\\n\\n    HashMap<String,Integer>mp=new HashMap<>();\\n\\n    public AuthenticationManager(int timeToLive) {\\n        \\n    time=timeToLive;\\n\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        \\n    mp.put(tokenId,currentTime+time);\\n\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        \\n    if(!mp.containsKey(tokenId)||mp.get(tokenId)<=currentTime)\\n    {\\n    return;\\n    }\\n\\n    mp.put(tokenId,currentTime+time);\\n\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n    \\n    List<String>lr=new ArrayList<>(mp.keySet());\\n    \\n    for(int i=0;i<lr.size();i++){\\n    \\n    if(mp.get(lr.get(i))<=currentTime)mp.remove(lr.get(i));\\n\\n    }\\n\\n    return mp.size();\\n    \\n    }\\n}\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager obj = new AuthenticationManager(timeToLive);\\n * obj.generate(tokenId,currentTime);\\n * obj.renew(tokenId,currentTime);\\n * int param_3 = obj.countUnexpiredTokens(currentTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2000854,
                "title": "c-easiest-solution-clean-code-single-map",
                "content": "Pls upvote if you like the solution!\\n```\\nclass AuthenticationManager {\\npublic:\\n    int time;\\n    unordered_map <string,int> m;\\n    AuthenticationManager(int timeToLive) {\\n        time = timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        m[tokenId] = currentTime;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if(m.find(tokenId) != m.end() && (currentTime - m[tokenId]) < time)\\n            m[tokenId] = currentTime;\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int res=0;\\n        for(auto i:m)\\n            if((currentTime - i.second) < time) res++;\\n\\t\\t\\t\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass AuthenticationManager {\\npublic:\\n    int time;\\n    unordered_map <string,int> m;\\n    AuthenticationManager(int timeToLive) {\\n        time = timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        m[tokenId] = currentTime;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if(m.find(tokenId) != m.end() && (currentTime - m[tokenId]) < time)\\n            m[tokenId] = currentTime;\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int res=0;\\n        for(auto i:m)\\n            if((currentTime - i.second) < time) res++;\\n\\t\\t\\t\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1880527,
                "title": "python-doubly-linkedlist-all-o-1-tc",
                "content": "```\\nclass Node:\\n    def __init__(self, key, exp):\\n        self.key = key\\n        self.exp = exp\\n        self.prev = None\\n        self.next = None\\n    \\nclass AuthenticationManager:\\n\\n    \\'\\'\\'\\n    create Dobuly linked list\\n    unexpired tokens are on right  \\n    expired will be on left , which is removed before any actions can happen\\n    \\n    on each operation \\n    remove element from left of the node which has exp time exceeds current time\\n    \\n    on add :\\n    add node to hash map and add node to end of DLL \\n    \\n    (inf,inf) -> node -> (inf,inf)\\n    \\n    on renew :\\n    check if node in DLL , then remove from first place add it to last because its renewed now\\n    before renwewal : (inf,inf) -> first -> node-a -> node-b -> (inf,inf)\\n    after renwewal  : (inf,inf) -> node-a -> node-b -> first -> (inf,inf)\\n    \\n    \\n    on count :\\n    return length of hashmap because it can only have unexpired tokens \\n    \\'\\'\\'\\n    \\n    \\n    def __init__(self, timeToLive: int):\\n        self.ttl = timeToLive\\n        self.head = Node(float(\\'inf\\'),float(\\'inf\\'))\\n        self.tail = Node(float(\\'inf\\'),float(\\'inf\\'))\\n        \\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n        \\n        self.lookup = {}\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self.cleanup(currentTime)\\n        \\n        self.lookup[tokenId] = Node(tokenId, currentTime + self.ttl)\\n        self.addNode(self.lookup[tokenId])\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        self.cleanup(currentTime)\\n        \\n        if tokenId in self.lookup:\\n            self.deleteNode(tokenId)\\n            del self.lookup[tokenId] \\n            \\n            self.lookup[tokenId] = Node(tokenId, currentTime + self.ttl)\\n            self.addNode(self.lookup[tokenId])\\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        self.cleanup(currentTime)\\n        \\n        return len(self.lookup)\\n    \\n    def cleanup(self, currentTime):\\n        \\n        head = self.head.next\\n        \\n        while head and head.key != float(\\'inf\\') and head.exp <= currentTime:\\n            \\n            node = head\\n            head = head.next\\n            \\n            self.deleteNode(node.key)\\n            del self.lookup[node.key]\\n                \\n    def addNode(self,node):\\n        \\n        prev = self.tail.prev\\n        \\n        prev.next = node\\n        node.next = self.tail\\n        \\n        self.tail.prev = node\\n        node.prev = prev\\n    \\n    def deleteNode(self,key):\\n        \\n        node = self.lookup[key]\\n        \\n        next = node.next\\n        prev = node.prev\\n        \\n        prev.next = next\\n        next.prev = prev\\n        \\n# Your AuthenticationManager object will be instantiated and called as such:\\n# obj = AuthenticationManager(timeToLive)\\n# obj.generate(tokenId,currentTime)\\n# obj.renew(tokenId,currentTime)\\n# param_3 = obj.countUnexpiredTokens(currentTime)\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List",
                    "Doubly-Linked List"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self, key, exp):\\n        self.key = key\\n        self.exp = exp\\n        self.prev = None\\n        self.next = None\\n    \\nclass AuthenticationManager:\\n\\n    \\'\\'\\'\\n    create Dobuly linked list\\n    unexpired tokens are on right  \\n    expired will be on left , which is removed before any actions can happen\\n    \\n    on each operation \\n    remove element from left of the node which has exp time exceeds current time\\n    \\n    on add :\\n    add node to hash map and add node to end of DLL \\n    \\n    (inf,inf) -> node -> (inf,inf)\\n    \\n    on renew :\\n    check if node in DLL , then remove from first place add it to last because its renewed now\\n    before renwewal : (inf,inf) -> first -> node-a -> node-b -> (inf,inf)\\n    after renwewal  : (inf,inf) -> node-a -> node-b -> first -> (inf,inf)\\n    \\n    \\n    on count :\\n    return length of hashmap because it can only have unexpired tokens \\n    \\'\\'\\'\\n    \\n    \\n    def __init__(self, timeToLive: int):\\n        self.ttl = timeToLive\\n        self.head = Node(float(\\'inf\\'),float(\\'inf\\'))\\n        self.tail = Node(float(\\'inf\\'),float(\\'inf\\'))\\n        \\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n        \\n        self.lookup = {}\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self.cleanup(currentTime)\\n        \\n        self.lookup[tokenId] = Node(tokenId, currentTime + self.ttl)\\n        self.addNode(self.lookup[tokenId])\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        self.cleanup(currentTime)\\n        \\n        if tokenId in self.lookup:\\n            self.deleteNode(tokenId)\\n            del self.lookup[tokenId] \\n            \\n            self.lookup[tokenId] = Node(tokenId, currentTime + self.ttl)\\n            self.addNode(self.lookup[tokenId])\\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        self.cleanup(currentTime)\\n        \\n        return len(self.lookup)\\n    \\n    def cleanup(self, currentTime):\\n        \\n        head = self.head.next\\n        \\n        while head and head.key != float(\\'inf\\') and head.exp <= currentTime:\\n            \\n            node = head\\n            head = head.next\\n            \\n            self.deleteNode(node.key)\\n            del self.lookup[node.key]\\n                \\n    def addNode(self,node):\\n        \\n        prev = self.tail.prev\\n        \\n        prev.next = node\\n        node.next = self.tail\\n        \\n        self.tail.prev = node\\n        node.prev = prev\\n    \\n    def deleteNode(self,key):\\n        \\n        node = self.lookup[key]\\n        \\n        next = node.next\\n        prev = node.prev\\n        \\n        prev.next = next\\n        next.prev = prev\\n        \\n# Your AuthenticationManager object will be instantiated and called as such:\\n# obj = AuthenticationManager(timeToLive)\\n# obj.generate(tokenId,currentTime)\\n# obj.renew(tokenId,currentTime)\\n# param_3 = obj.countUnexpiredTokens(currentTime)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1869335,
                "title": "easy-c-solution",
                "content": "```\\nclass AuthenticationManager {\\npublic:\\n    int timeToLive;\\n    unordered_map<string,int>m;\\n    AuthenticationManager(int timeToLive) {\\n        this->timeToLive=timeToLive;\\n        m.clear();\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        m[tokenId]=currentTime;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if(m.find(tokenId)==m.end() || currentTime-m[tokenId]>=timeToLive) {\\n            return;\\n        }\\n        m[tokenId]=currentTime;\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int count=0;\\n        for(auto it:m) {\\n            if(currentTime-it.second<timeToLive) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass AuthenticationManager {\\npublic:\\n    int timeToLive;\\n    unordered_map<string,int>m;\\n    AuthenticationManager(int timeToLive) {\\n        this->timeToLive=timeToLive;\\n        m.clear();\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        m[tokenId]=currentTime;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if(m.find(tokenId)==m.end() || currentTime-m[tokenId]>=timeToLive) {\\n            return;\\n        }\\n        m[tokenId]=currentTime;\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int count=0;\\n        for(auto it:m) {\\n            if(currentTime-it.second<timeToLive) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1719247,
                "title": "python3-dictionary-easy-understanding",
                "content": "Time: O(max unexpired) for countUnexpiredTokens, O(1) for others\\nSpace: O(max unexpired)\\n\\n```\\nclass AuthenticationManager:\\n\\n    def __init__(self, timeToLive: int):\\n        self.ttl = timeToLive\\n        self.exp_at = dict()\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self.exp_at[tokenId] = currentTime + self.ttl\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if tokenId not in self.exp_at:\\n            return\\n        if currentTime < self.exp_at[tokenId]:\\n            self.exp_at[tokenId] = currentTime + self.ttl\\n        else:\\n            del self.token[tokenId]\\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        res = 0\\n        for token in self.exp_at:\\n            if self.exp_at[token] > currentTime:\\n                res += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass AuthenticationManager:\\n\\n    def __init__(self, timeToLive: int):\\n        self.ttl = timeToLive\\n        self.exp_at = dict()\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self.exp_at[tokenId] = currentTime + self.ttl\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if tokenId not in self.exp_at:\\n            return\\n        if currentTime < self.exp_at[tokenId]:\\n            self.exp_at[tokenId] = currentTime + self.ttl\\n        else:\\n            del self.token[tokenId]\\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        res = 0\\n        for token in self.exp_at:\\n            if self.exp_at[token] > currentTime:\\n                res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1168641,
                "title": "brute-force-c",
                "content": "```\\nclass AuthenticationManager {\\npublic:\\n    map<string,int>M;\\n    multiset<int>S;\\n    int T;\\n    \\n    AuthenticationManager(int timeToLive) {\\n        T=timeToLive;        \\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        M[tokenId]=currentTime+T;\\n        S.insert(M[tokenId]);\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if(M.find(tokenId)==M.end())     \\n            return ;\\n        if(M[tokenId]<=currentTime)\\n            return ;\\n        S.erase(S.find(M[tokenId]));\\n        M[tokenId]=currentTime+T;\\n        S.insert(M[tokenId]);\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int ans=0;\\n        for(int v:S){\\n            if(v>currentTime)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass AuthenticationManager {\\npublic:\\n    map<string,int>M;\\n    multiset<int>S;\\n    int T;\\n    \\n    AuthenticationManager(int timeToLive) {\\n        T=timeToLive;        \\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        M[tokenId]=currentTime+T;\\n        S.insert(M[tokenId]);\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if(M.find(tokenId)==M.end())     \\n            return ;\\n        if(M[tokenId]<=currentTime)\\n            return ;\\n        S.erase(S.find(M[tokenId]));\\n        M[tokenId]=currentTime+T;\\n        S.insert(M[tokenId]);\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int ans=0;\\n        for(int v:S){\\n            if(v>currentTime)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120759,
                "title": "python-faster-than-100-dictionary-binary-search",
                "content": "![image](https://assets.leetcode.com/users/images/1a1951ec-ff01-41bf-bea4-80f56bb13d42_1616346345.508527.png)\\n\\n\\n```\\nfrom collections import defaultdict\\nfrom typing import Dict, List, Tuple\\n\\n\\nclass AuthenticationManager:\\n\\n    def __init__(self, timeToLive: int):\\n        self._ttl = timeToLive\\n\\t\\t# dictionary to store the token and its (provision, expiry time)\\n\\t\\tself._tokens: Dict[str, Tuple[int, int]] = {}\\n\\n\\t\\t# stores all the unique expiry times - the arr is automatically set in increasing order\\n\\t\\t# this array is helpful to perform binary search for `countUnexpiredTokens` calls\\n        self._token_expiry_timeline: List[int] = []\\n\\n\\t\\t# since we store the array with unique values of expiry, overlapping\\n\\t\\t# expiries of many different tokens, this dictionary helps in keeping\\n\\t\\t# a count of tokens sharing same expiry - helps to decide if particular\\n\\t\\t# expiry can be removed if the token is renewed and there was only one\\n\\t\\t# such token using that expiry - this is important or else, after renewal\\n\\t\\t# older expiry will linger in this array\\n        self._expiry_time_count: Dict[int, int] = defaultdict(int)\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        if tokenId in self._tokens:\\n            return\\n        expiry = currentTime + self._ttl\\n        self._tokens[tokenId] = (currentTime, expiry)\\n\\n\\t\\t# Maintain unique expiries in _token_expiry_timeline\\n        if len(self._token_expiry_timeline) == 0 \\\\\\n                or (len(self._token_expiry_timeline) > 0 and self._token_expiry_timeline[-1] < expiry):\\n            self._token_expiry_timeline.append(expiry)\\n        self._expiry_time_count[expiry] += 1\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if tokenId not in self._tokens:\\n            return\\n        older_expiry = self._tokens[tokenId][1]\\n        if currentTime >= older_expiry:\\n            return\\n\\t\\t\\n\\t\\t# comment at decalaration of `_expiry_time_count` at `__init__`\\n\\t\\t# explains this logic\\n\\t\\tif self._expiry_time_count[older_expiry] == 1:\\n            self._token_expiry_timeline.remove(older_expiry)\\n        self._expiry_time_count[older_expiry] -= 1\\n\\n\\t\\t# since the token becomes eligible for renew, remove older entry\\n\\t\\t# and reuse `generate` function\\n        del self._tokens[tokenId]\\n        self.generate(tokenId, currentTime)\\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n\\t\\t# Some quick checks to bail out fast\\n        if not self._token_expiry_timeline:\\n            return 0\\n        if self._token_expiry_timeline[-1] <= currentTime:\\n            return 0\\n        # binary search the max value in array <= currentTime\\n        n = len(self._token_expiry_timeline)\\n        left, right = 0, n\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if self._token_expiry_timeline[mid] <= currentTime:\\n                left = mid + 1\\n            else:\\n                right = mid\\n\\t\\t# remaining items are not expired\\n        return n - left\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom typing import Dict, List, Tuple\\n\\n\\nclass AuthenticationManager:\\n\\n    def __init__(self, timeToLive: int):\\n        self._ttl = timeToLive\\n\\t\\t# dictionary to store the token and its (provision, expiry time)\\n\\t\\tself._tokens: Dict[str, Tuple[int, int]] = {}\\n\\n\\t\\t# stores all the unique expiry times - the arr is automatically set in increasing order\\n\\t\\t# this array is helpful to perform binary search for `countUnexpiredTokens` calls\\n        self._token_expiry_timeline: List[int] = []\\n\\n\\t\\t# since we store the array with unique values of expiry, overlapping\\n\\t\\t# expiries of many different tokens, this dictionary helps in keeping\\n\\t\\t# a count of tokens sharing same expiry - helps to decide if particular\\n\\t\\t# expiry can be removed if the token is renewed and there was only one\\n\\t\\t# such token using that expiry - this is important or else, after renewal\\n\\t\\t# older expiry will linger in this array\\n        self._expiry_time_count: Dict[int, int] = defaultdict(int)\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        if tokenId in self._tokens:\\n            return\\n        expiry = currentTime + self._ttl\\n        self._tokens[tokenId] = (currentTime, expiry)\\n\\n\\t\\t# Maintain unique expiries in _token_expiry_timeline\\n        if len(self._token_expiry_timeline) == 0 \\\\\\n                or (len(self._token_expiry_timeline) > 0 and self._token_expiry_timeline[-1] < expiry):\\n            self._token_expiry_timeline.append(expiry)\\n        self._expiry_time_count[expiry] += 1\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if tokenId not in self._tokens:\\n            return\\n        older_expiry = self._tokens[tokenId][1]\\n        if currentTime >= older_expiry:\\n            return\\n\\t\\t\\n\\t\\t# comment at decalaration of `_expiry_time_count` at `__init__`\\n\\t\\t# explains this logic\\n\\t\\tif self._expiry_time_count[older_expiry] == 1:\\n            self._token_expiry_timeline.remove(older_expiry)\\n        self._expiry_time_count[older_expiry] -= 1\\n\\n\\t\\t# since the token becomes eligible for renew, remove older entry\\n\\t\\t# and reuse `generate` function\\n        del self._tokens[tokenId]\\n        self.generate(tokenId, currentTime)\\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n\\t\\t# Some quick checks to bail out fast\\n        if not self._token_expiry_timeline:\\n            return 0\\n        if self._token_expiry_timeline[-1] <= currentTime:\\n            return 0\\n        # binary search the max value in array <= currentTime\\n        n = len(self._token_expiry_timeline)\\n        left, right = 0, n\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if self._token_expiry_timeline[mid] <= currentTime:\\n                left = mid + 1\\n            else:\\n                right = mid\\n\\t\\t# remaining items are not expired\\n        return n - left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1118849,
                "title": "interval-with-expiration-time-c",
                "content": "using hashmap to record the expiration time and ordered map to record the start and expiration time and then use prefix sum to get the count\\n```\\n    unordered_map<string,int> token;\\n    map<int,int> mp;\\n    int tl;\\n    AuthenticationManager(int timeToLive) {\\n        tl=timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        token[tokenId]=currentTime+tl;\\n        mp[currentTime]++;\\n        mp[currentTime+tl]--;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if(!token.count(tokenId) || token[tokenId]<=currentTime) return;\\n        int pre=token[tokenId];//expire time\\n        mp[pre]++,mp[currentTime+tl]--;\\n        token[tokenId]=currentTime+tl;// start time not changed\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int pre=0;\\n        for(auto t: mp){\\n            if(t.first>currentTime) return pre; //count after expire\\n            pre+=t.second;\\n        }\\n        return 0;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n    unordered_map<string,int> token;\\n    map<int,int> mp;\\n    int tl;\\n    AuthenticationManager(int timeToLive) {\\n        tl=timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        token[tokenId]=currentTime+tl;\\n        mp[currentTime]++;\\n        mp[currentTime+tl]--;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if(!token.count(tokenId) || token[tokenId]<=currentTime) return;\\n        int pre=token[tokenId];//expire time\\n        mp[pre]++,mp[currentTime+tl]--;\\n        token[tokenId]=currentTime+tl;// start time not changed\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int pre=0;\\n        for(auto t: mp){\\n            if(t.first>currentTime) return pre; //count after expire\\n            pre+=t.second;\\n        }\\n        return 0;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 4039083,
                "title": "beats-92-c-priority-queue-map",
                "content": "# **Intuition**\\nThe goal of this problem is to design a class that manages authentication tokens with a certain time-to-live (TTL) value and provides functions for generating, renewing, and counting unexpired tokens based on the current time.\\n\\n# **Approach**\\nTo solve this problem, we can use an unordered map (`ump`) to store the expiration time of each token based on its ID. We can also use a priority queue (`pq`) to keep track of tokens sorted by their expiration time, with the token that will expire soonest at the top of the queue.\\n\\n1. In the constructor (`AuthenticationManager`), we initialize the time-to-live (`ttl`) value.\\n\\n2. In the `generate` function, we calculate the expiration time for a token based on the current time and TTL, update the `ump` with the expiration time for the token, and push the token with its expiration time onto the priority queue.\\n\\n3. In the `renew` function, we check if the token exists in the `ump` and if its expiration time is greater than the current time. If both conditions are met, we update the expiration time for the token in the `ump`.\\n\\n4. In the `countUnexpiredTokens` function, we iterate through the priority queue while it\\'s not empty. For each token at the top of the queue, we check if its original expiration time is greater than the current time. If it is, we pop it from the queue and check if its actual expiration time (as stored in `ump`) is greater than the current time. If it is, we push it back onto the queue. Finally, we return the size of the priority queue, which represents the count of unexpired tokens.\\n\\n## **Complexity**\\n- **Time complexity:**\\n  - `generate` and `renew` functions both have a time complexity of O(1) because they involve simple map updates.\\n  - The `countUnexpiredTokens` function has a time complexity of O(logn) where \\'n\\' is the number of tokens in the priority queue. In the worst case, we may have to pop and push tokens back onto the queue.\\n- **Space complexity:**\\n  - The space complexity is O(n) because we are using two data structures to store tokens: an unordered map (`ump`) to store the expiration times and a priority queue (`pq`) to store tokens sorted by expiration time.\\n\\n# Code\\n```\\nclass AuthenticationManager {\\n\\nprivate:\\n    struct compare\\n    {\\n        bool operator()(pair<string, int> p1, pair<string, int> p2)\\n        {\\n            return p1.second > p2.second;\\n        }\\n    };\\n    \\n    int ttl;\\n    unordered_map<string, int> ump;\\n    priority_queue<pair<string, int>, vector<pair<string, int>>, compare> pq;\\n\\npublic:\\n    AuthenticationManager(int timeToLive) \\n    {\\n        ttl = timeToLive;\\n    }\\n\\n    void generate(string tokenId, int currentTime) \\n    {\\n        ump[tokenId] = currentTime + ttl;\\n        pq.push({tokenId, currentTime + ttl});\\n    }\\n\\n    void renew(string tokenId, int currentTime) \\n    {\\n        if(ump.find(tokenId) != ump.end() && ump[tokenId] > currentTime)\\n        {\\n            ump[tokenId] = currentTime + ttl;\\n        }\\n    }\\n\\n    int countUnexpiredTokens(int currentTime) \\n    {\\n        while (!pq.empty()) \\n        {\\n            int originalExpiryTime = pq.top().second;\\n            string tokenId = pq.top().first;\\n            if (originalExpiryTime > currentTime)\\n            {\\n                break;\\n            }\\n\\n            pq.pop();\\n            int actualExpiryTime = ump[tokenId];\\n            if (actualExpiryTime > currentTime)\\n            {\\n                pq.push({tokenId,actualExpiryTime});\\n            }\\n        }\\n        return pq.size();\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Design",
                    "Ordered Map",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass AuthenticationManager {\\n\\nprivate:\\n    struct compare\\n    {\\n        bool operator()(pair<string, int> p1, pair<string, int> p2)\\n        {\\n            return p1.second > p2.second;\\n        }\\n    };\\n    \\n    int ttl;\\n    unordered_map<string, int> ump;\\n    priority_queue<pair<string, int>, vector<pair<string, int>>, compare> pq;\\n\\npublic:\\n    AuthenticationManager(int timeToLive) \\n    {\\n        ttl = timeToLive;\\n    }\\n\\n    void generate(string tokenId, int currentTime) \\n    {\\n        ump[tokenId] = currentTime + ttl;\\n        pq.push({tokenId, currentTime + ttl});\\n    }\\n\\n    void renew(string tokenId, int currentTime) \\n    {\\n        if(ump.find(tokenId) != ump.end() && ump[tokenId] > currentTime)\\n        {\\n            ump[tokenId] = currentTime + ttl;\\n        }\\n    }\\n\\n    int countUnexpiredTokens(int currentTime) \\n    {\\n        while (!pq.empty()) \\n        {\\n            int originalExpiryTime = pq.top().second;\\n            string tokenId = pq.top().first;\\n            if (originalExpiryTime > currentTime)\\n            {\\n                break;\\n            }\\n\\n            pq.pop();\\n            int actualExpiryTime = ump[tokenId];\\n            if (actualExpiryTime > currentTime)\\n            {\\n                pq.push({tokenId,actualExpiryTime});\\n            }\\n        }\\n        return pq.size();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949575,
                "title": "python3-dictionary-deque-beat-98-runtime",
                "content": "# Intuition\\n* The problem has an inherent FIFO nature - tokens are added with strictly increasing timestamps, and the tokens which are added first will also expire first since TTL is the same for all tokens. This should inspire using a queue. \\n* I used a hashmap with the queue just to keep track of the tokenids, but it turned out to be redundant.\\n* When you get a call to renew or count unexpired tokens, look at the queue and start popping tokens one by one until the head of the queue is an unexpired token. This is amortized O(1) - you do a constant amount of work (queue.popleft()) per expired token. \\n\\n\\n# Complexity\\n- Time complexity:\\n- Generate: O(1)\\n- Renew: O(n)\\n- Processing expiry: Amortized O(1)\\n- CountUnexpiredTokens: O(1) (once expiry is processed, just get the length of the queue)\\n\\n- Space complexity: O(n) for queue. \\n\\n# Code\\n```\\nfrom collections import deque\\n\\nclass AuthenticationManager:\\n\\n    def __init__(self, timeToLive: int):\\n        self.tokens = {} # Dictionary from tokenId to expiry time.\\n        self.token_queue = deque() # helps keep track of which tokens to expire next. \\n        self.ttl = timeToLive\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        expiry = currentTime + self.ttl\\n        self.tokens[tokenId] = expiry\\n        self.token_queue.append((expiry, tokenId))\\n\\n\\n    def process_expiry(self, currentTime: int) -> int:\\n        count = 0\\n        while self.token_queue and self.token_queue[0][0] <= currentTime:\\n            exp, tok = self.token_queue.popleft()\\n            del self.tokens[tok]\\n            count += 1\\n        return count\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if tokenId not in self.tokens:\\n            return\\n        if currentTime >= self.tokens[tokenId]:\\n            # token is already expired. \\n            # process expiry\\n            num_expired = self.process_expiry(currentTime)\\n            return\\n        # token not expired, process renewal\\n        idx = 0\\n        while self.token_queue[idx][1] != tokenId:\\n            idx += 1\\n        del self.token_queue[idx]\\n        del self.tokens[tokenId]\\n        self.generate(tokenId, currentTime)\\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        self.process_expiry(currentTime)\\n        return len(self.token_queue)\\n\\n\\n# Your AuthenticationManager object will be instantiated and called as such:\\n# obj = AuthenticationManager(timeToLive)\\n# obj.generate(tokenId,currentTime)\\n# obj.renew(tokenId,currentTime)\\n# param_3 = obj.countUnexpiredTokens(currentTime)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass AuthenticationManager:\\n\\n    def __init__(self, timeToLive: int):\\n        self.tokens = {} # Dictionary from tokenId to expiry time.\\n        self.token_queue = deque() # helps keep track of which tokens to expire next. \\n        self.ttl = timeToLive\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        expiry = currentTime + self.ttl\\n        self.tokens[tokenId] = expiry\\n        self.token_queue.append((expiry, tokenId))\\n\\n\\n    def process_expiry(self, currentTime: int) -> int:\\n        count = 0\\n        while self.token_queue and self.token_queue[0][0] <= currentTime:\\n            exp, tok = self.token_queue.popleft()\\n            del self.tokens[tok]\\n            count += 1\\n        return count\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if tokenId not in self.tokens:\\n            return\\n        if currentTime >= self.tokens[tokenId]:\\n            # token is already expired. \\n            # process expiry\\n            num_expired = self.process_expiry(currentTime)\\n            return\\n        # token not expired, process renewal\\n        idx = 0\\n        while self.token_queue[idx][1] != tokenId:\\n            idx += 1\\n        del self.token_queue[idx]\\n        del self.tokens[tokenId]\\n        self.generate(tokenId, currentTime)\\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        self.process_expiry(currentTime)\\n        return len(self.token_queue)\\n\\n\\n# Your AuthenticationManager object will be instantiated and called as such:\\n# obj = AuthenticationManager(timeToLive)\\n# obj.generate(tokenId,currentTime)\\n# obj.renew(tokenId,currentTime)\\n# param_3 = obj.countUnexpiredTokens(currentTime)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677473,
                "title": "java-using-hashmap",
                "content": "# Code\\n```\\nclass AuthenticationManager {\\n\\n    HashMap<String, Integer> map;\\n    int time;\\n    public AuthenticationManager(int timeToLive) {\\n        map = new HashMap<>();\\n        time = timeToLive;\\n    }\\n\\n    public void generate(String tokenId, int currentTime) {\\n        map.put(tokenId, currentTime + time);\\n    }\\n\\n    public void renew(String tokenId, int currentTime) {\\n        int expires = map.getOrDefault(tokenId, 0);\\n        if (expires > currentTime) map.put(tokenId, currentTime + time);\\n    }\\n\\n    public int countUnexpiredTokens(int currentTime) {\\n        int count = 0;\\n        for (String key : map.keySet()) if (map.get(key) > currentTime) count++;\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass AuthenticationManager {\\n\\n    HashMap<String, Integer> map;\\n    int time;\\n    public AuthenticationManager(int timeToLive) {\\n        map = new HashMap<>();\\n        time = timeToLive;\\n    }\\n\\n    public void generate(String tokenId, int currentTime) {\\n        map.put(tokenId, currentTime + time);\\n    }\\n\\n    public void renew(String tokenId, int currentTime) {\\n        int expires = map.getOrDefault(tokenId, 0);\\n        if (expires > currentTime) map.put(tokenId, currentTime + time);\\n    }\\n\\n    public int countUnexpiredTokens(int currentTime) {\\n        int count = 0;\\n        for (String key : map.keySet()) if (map.get(key) > currentTime) count++;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3560411,
                "title": "java-easy-100-solution-using-hashmap-and-treemap",
                "content": "```java\\nimport java.util.*;\\n\\nclass AuthenticationManager {\\n    private final TreeMap<Integer, String> timestamps;\\n    private final Map<String, Integer> tokens;\\n    private final int timeToLive;\\n\\n    public AuthenticationManager(final int timeToLive) {\\n        this.timestamps = new TreeMap<>();\\n        this.tokens = new HashMap<>();\\n        this.timeToLive = timeToLive;\\n    }\\n\\n    public void generate(final String tokenId, final int currentTime) {\\n        removeExpiredTokens(currentTime);\\n        tokens.put(tokenId, currentTime);\\n        timestamps.put(currentTime, tokenId);\\n    }\\n\\n    public void renew(final String tokenId, final int currentTime) {\\n        removeExpiredTokens(currentTime);\\n        if (tokens.containsKey(tokenId)) {\\n            int tokenTime = tokens.get(tokenId);\\n            if (currentTime - tokenTime < timeToLive) {\\n                timestamps.remove(tokenTime);\\n                timestamps.put(currentTime, tokenId);\\n                tokens.put(tokenId, currentTime);\\n            }\\n        }\\n    }\\n\\n    public int countUnexpiredTokens(final int currentTime) {\\n        removeExpiredTokens(currentTime);\\n        return tokens.size();\\n    }\\n    \\n    private void removeExpiredTokens(final int currentTime) {\\n        final Iterator<Map.Entry<Integer, String>> iterator = timestamps.entrySet().iterator();\\n        while (iterator.hasNext()) {\\n            Map.Entry<Integer, String> entry = iterator.next();\\n            int tokenTime = entry.getKey();\\n            if (currentTime - tokenTime >= timeToLive) {\\n                String tokenId = entry.getValue();\\n                iterator.remove();\\n                tokens.remove(tokenId);\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nimport java.util.*;\\n\\nclass AuthenticationManager {\\n    private final TreeMap<Integer, String> timestamps;\\n    private final Map<String, Integer> tokens;\\n    private final int timeToLive;\\n\\n    public AuthenticationManager(final int timeToLive) {\\n        this.timestamps = new TreeMap<>();\\n        this.tokens = new HashMap<>();\\n        this.timeToLive = timeToLive;\\n    }\\n\\n    public void generate(final String tokenId, final int currentTime) {\\n        removeExpiredTokens(currentTime);\\n        tokens.put(tokenId, currentTime);\\n        timestamps.put(currentTime, tokenId);\\n    }\\n\\n    public void renew(final String tokenId, final int currentTime) {\\n        removeExpiredTokens(currentTime);\\n        if (tokens.containsKey(tokenId)) {\\n            int tokenTime = tokens.get(tokenId);\\n            if (currentTime - tokenTime < timeToLive) {\\n                timestamps.remove(tokenTime);\\n                timestamps.put(currentTime, tokenId);\\n                tokens.put(tokenId, currentTime);\\n            }\\n        }\\n    }\\n\\n    public int countUnexpiredTokens(final int currentTime) {\\n        removeExpiredTokens(currentTime);\\n        return tokens.size();\\n    }\\n    \\n    private void removeExpiredTokens(final int currentTime) {\\n        final Iterator<Map.Entry<Integer, String>> iterator = timestamps.entrySet().iterator();\\n        while (iterator.hasNext()) {\\n            Map.Entry<Integer, String> entry = iterator.next();\\n            int tokenTime = entry.getKey();\\n            if (currentTime - tokenTime >= timeToLive) {\\n                String tokenId = entry.getValue();\\n                iterator.remove();\\n                tokens.remove(tokenId);\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3279676,
                "title": "c-accepted-easy-to-understand",
                "content": "```\\npublic class AuthenticationManager {\\n    public int ttl;\\n    Dictionary<string,int> tokens;\\n    public AuthenticationManager(int timeToLive) {\\n        this.ttl = timeToLive;\\n        tokens=new();\\n    }\\n    \\n    public void Generate(string tokenId, int currentTime) {\\n        tokens.Add(tokenId,currentTime);\\n    }\\n    \\n    public void Renew(string tokenId, int currentTime) {\\n        if(tokens.ContainsKey(tokenId))\\n            if(currentTime-tokens[tokenId]<ttl)\\n                tokens[tokenId]=currentTime;\\n    }\\n    \\n    public int CountUnexpiredTokens(int currentTime) {\\n        int count=0;\\n        foreach(var kvp in tokens){\\n            if(currentTime-kvp.Value<ttl)\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager obj = new AuthenticationManager(timeToLive);\\n * obj.Generate(tokenId,currentTime);\\n * obj.Renew(tokenId,currentTime);\\n * int param_3 = obj.CountUnexpiredTokens(currentTime);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\npublic class AuthenticationManager {\\n    public int ttl;\\n    Dictionary<string,int> tokens;\\n    public AuthenticationManager(int timeToLive) {\\n        this.ttl = timeToLive;\\n        tokens=new();\\n    }\\n    \\n    public void Generate(string tokenId, int currentTime) {\\n        tokens.Add(tokenId,currentTime);\\n    }\\n    \\n    public void Renew(string tokenId, int currentTime) {\\n        if(tokens.ContainsKey(tokenId))\\n            if(currentTime-tokens[tokenId]<ttl)\\n                tokens[tokenId]=currentTime;\\n    }\\n    \\n    public int CountUnexpiredTokens(int currentTime) {\\n        int count=0;\\n        foreach(var kvp in tokens){\\n            if(currentTime-kvp.Value<ttl)\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager obj = new AuthenticationManager(timeToLive);\\n * obj.Generate(tokenId,currentTime);\\n * obj.Renew(tokenId,currentTime);\\n * int param_3 = obj.CountUnexpiredTokens(currentTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2797269,
                "title": "js-simple-solution",
                "content": "```\\n/**\\n * @param {number} timeToLive\\n */\\nvar AuthenticationManager = function (timeToLive) {\\n  this.timeToLive = timeToLive;\\n  this.currentTime = 0;\\n  this.tokens = {};\\n};\\n\\n/**\\n * @param {string} tokenId\\n * @param {number} currentTime\\n * @return {void}\\n */\\nAuthenticationManager.prototype.generate = function (tokenId, currentTime) {\\n  this.currentTime = currentTime;\\n  this.tokens[tokenId] = this.currentTime + this.timeToLive;\\n};\\n\\n/**\\n * @param {string} tokenId\\n * @param {number} currentTime\\n * @return {void}\\n */\\nAuthenticationManager.prototype.renew = function (tokenId, currentTime) {\\n  this.currentTime = currentTime;\\n  if (this.tokens[tokenId] > this.currentTime) {\\n    this.tokens[tokenId] = this.currentTime + this.timeToLive;\\n  } else {\\n    delete this.tokens[tokenId];\\n  }\\n};\\n\\n/**\\n * @param {number} currentTime\\n * @return {number}\\n */\\nAuthenticationManager.prototype.countUnexpiredTokens = function (currentTime) {\\n  this.currentTime = currentTime;\\n  let count = 0;\\n  for (let tokenId in this.tokens) {\\n    if (this.tokens[tokenId] > this.currentTime) {\\n      count++;\\n    } else {\\n      delete this.tokens[tokenId];\\n    }\\n  }\\n  return count;\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * var obj = new AuthenticationManager(timeToLive)\\n * obj.generate(tokenId,currentTime)\\n * obj.renew(tokenId,currentTime)\\n * var param_3 = obj.countUnexpiredTokens(currentTime)\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\n/**\\n * @param {number} timeToLive\\n */\\nvar AuthenticationManager = function (timeToLive) {\\n  this.timeToLive = timeToLive;\\n  this.currentTime = 0;\\n  this.tokens = {};\\n};\\n\\n/**\\n * @param {string} tokenId\\n * @param {number} currentTime\\n * @return {void}\\n */\\nAuthenticationManager.prototype.generate = function (tokenId, currentTime) {\\n  this.currentTime = currentTime;\\n  this.tokens[tokenId] = this.currentTime + this.timeToLive;\\n};\\n\\n/**\\n * @param {string} tokenId\\n * @param {number} currentTime\\n * @return {void}\\n */\\nAuthenticationManager.prototype.renew = function (tokenId, currentTime) {\\n  this.currentTime = currentTime;\\n  if (this.tokens[tokenId] > this.currentTime) {\\n    this.tokens[tokenId] = this.currentTime + this.timeToLive;\\n  } else {\\n    delete this.tokens[tokenId];\\n  }\\n};\\n\\n/**\\n * @param {number} currentTime\\n * @return {number}\\n */\\nAuthenticationManager.prototype.countUnexpiredTokens = function (currentTime) {\\n  this.currentTime = currentTime;\\n  let count = 0;\\n  for (let tokenId in this.tokens) {\\n    if (this.tokens[tokenId] > this.currentTime) {\\n      count++;\\n    } else {\\n      delete this.tokens[tokenId];\\n    }\\n  }\\n  return count;\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * var obj = new AuthenticationManager(timeToLive)\\n * obj.generate(tokenId,currentTime)\\n * obj.renew(tokenId,currentTime)\\n * var param_3 = obj.countUnexpiredTokens(currentTime)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2638735,
                "title": "java-hashmap-treeset",
                "content": "The algorithm is pretty straightforward, the idea is to add and renew the keys with the added time to live, so we can keep the expiration value and to use a TreeSet for keeping it in a sorted manner with time complexity of O(Log (n)) for add and remove and O (M Log (n)) (where M is the number of items which will be traversed after the \"midpoint\" is found) for .tailSet().  The HashMap has the only purpose to store the expiration value of each key.\\n\\nThe Algorithm is kind of unstable and has performance between 44%  and 93%.\\n\\n```\\nclass AuthenticationManager {\\n\\n    int timeToLive;\\n    TreeSet<Integer> treeSet;\\n    Map<String, Integer> map;\\n    public AuthenticationManager(int timeToLive) {\\n        this.timeToLive = timeToLive;\\n        treeSet = new TreeSet<>();\\n        map = new HashMap<>();\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        map.put(tokenId, currentTime + timeToLive);\\n        treeSet.add(currentTime + timeToLive);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        \\n        Integer time = map.get(tokenId);\\n\\t\\t// If null the token was never added, or it has expired before the renew call, which makes it invalid for renewing\\n        if (time == null || time <= currentTime) return;\\n       \\n\\t   \\n\\t   // Update the hashmap and treeSet with the new values\\n        map.put(tokenId, currentTime + timeToLive);\\n        treeSet.remove(time);\\n        treeSet.add(currentTime + timeToLive);\\n        \\n\\t\\t// Clearing the treeset from already expired timestamps, it doesn\\'t really improve the time execution, with about 10% only.\\n        while (!treeSet.isEmpty() && treeSet.lower(currentTime) != null) {\\n            treeSet.remove(treeSet.lower(currentTime));\\n        }\\n    }\\n    \\n\\t// Return the number of timestamps in the treeset, which have greated expiry time than the currentTime\\n    public int countUnexpiredTokens(int currentTime) {\\n        return treeSet.tailSet(currentTime, false).size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass AuthenticationManager {\\n\\n    int timeToLive;\\n    TreeSet<Integer> treeSet;\\n    Map<String, Integer> map;\\n    public AuthenticationManager(int timeToLive) {\\n        this.timeToLive = timeToLive;\\n        treeSet = new TreeSet<>();\\n        map = new HashMap<>();\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        map.put(tokenId, currentTime + timeToLive);\\n        treeSet.add(currentTime + timeToLive);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        \\n        Integer time = map.get(tokenId);\\n\\t\\t// If null the token was never added, or it has expired before the renew call, which makes it invalid for renewing\\n        if (time == null || time <= currentTime) return;\\n       \\n\\t   \\n\\t   // Update the hashmap and treeSet with the new values\\n        map.put(tokenId, currentTime + timeToLive);\\n        treeSet.remove(time);\\n        treeSet.add(currentTime + timeToLive);\\n        \\n\\t\\t// Clearing the treeset from already expired timestamps, it doesn\\'t really improve the time execution, with about 10% only.\\n        while (!treeSet.isEmpty() && treeSet.lower(currentTime) != null) {\\n            treeSet.remove(treeSet.lower(currentTime));\\n        }\\n    }\\n    \\n\\t// Return the number of timestamps in the treeset, which have greated expiry time than the currentTime\\n    public int countUnexpiredTokens(int currentTime) {\\n        return treeSet.tailSet(currentTime, false).size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2558808,
                "title": "c-single-map-solution",
                "content": "This Solution is Also works very fine.\\n```\\nclass AuthenticationManager {\\npublic:\\n    int n;\\n    AuthenticationManager(int timeToLive) {\\n        n = timeToLive;\\n    }\\n    unordered_map<string, int> mp;\\n    void generate(string tokenId, int currentTime) {\\n        if(mp.find(tokenId) == mp.end()){\\n            mp.insert({tokenId, currentTime});\\n        }\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if(mp.find(tokenId) != mp.end()){\\n            if(n + mp[tokenId] > currentTime){\\n                mp[tokenId] = currentTime;\\n            }\\n        }\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int ans = 0;\\n        for(auto x : mp){\\n            if(x.second + n > currentTime){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass AuthenticationManager {\\npublic:\\n    int n;\\n    AuthenticationManager(int timeToLive) {\\n        n = timeToLive;\\n    }\\n    unordered_map<string, int> mp;\\n    void generate(string tokenId, int currentTime) {\\n        if(mp.find(tokenId) == mp.end()){\\n            mp.insert({tokenId, currentTime});\\n        }\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if(mp.find(tokenId) != mp.end()){\\n            if(n + mp[tokenId] > currentTime){\\n                mp[tokenId] = currentTime;\\n            }\\n        }\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int ans = 0;\\n        for(auto x : mp){\\n            if(x.second + n > currentTime){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2290263,
                "title": "c-easy-solution-using-stl",
                "content": "```\\nclass AuthenticationManager {\\n    int timeToLive;\\n    unordered_map<string, int> tokens;\\npublic:\\n    AuthenticationManager(int timeToLive) {\\n        this->timeToLive = timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        tokens[tokenId] = currentTime;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if(tokens.find(tokenId) == tokens.end())\\n            return;\\n        if(tokens[tokenId] + timeToLive <= currentTime)\\n            tokens.erase(tokenId);\\n        else\\n            tokens[tokenId] = currentTime;\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int count = 0;\\n        unordered_map<string, int>:: iterator p;\\n        for (p = tokens.begin(); p != tokens.end(); p++){\\n            if(p->second + timeToLive > currentTime)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass AuthenticationManager {\\n    int timeToLive;\\n    unordered_map<string, int> tokens;\\npublic:\\n    AuthenticationManager(int timeToLive) {\\n        this->timeToLive = timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        tokens[tokenId] = currentTime;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if(tokens.find(tokenId) == tokens.end())\\n            return;\\n        if(tokens[tokenId] + timeToLive <= currentTime)\\n            tokens.erase(tokenId);\\n        else\\n            tokens[tokenId] = currentTime;\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int count = 0;\\n        unordered_map<string, int>:: iterator p;\\n        for (p = tokens.begin(); p != tokens.end(); p++){\\n            if(p->second + timeToLive > currentTime)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2208208,
                "title": "rust-token-hashmap",
                "content": "```rust\\nuse std::{\\n    cell::RefCell,\\n    cmp::Ordering,\\n    collections::hash_map::Entry::Occupied,\\n    collections::{hash_map::Entry::Vacant, BTreeSet},\\n    collections::{BTreeMap, BinaryHeap, HashMap, HashSet, VecDeque},\\n    rc::Rc,\\n};\\n\\n\\n\\nstruct AuthenticationManager {\\n    time_to_live: i32,\\n    tokens: HashMap<String, i32>,\\n}\\n\\nimpl AuthenticationManager {\\n    fn new(time_to_live: i32) -> Self {\\n        Self {\\n            time_to_live,\\n            tokens: HashMap::new(),\\n        }\\n    }\\n\\n    fn generate(&mut self, token_id: String, current_time: i32) {\\n        self.tokens\\n            .insert(token_id, current_time + self.time_to_live);\\n    }\\n\\n    fn renew(&mut self, token_id: String, current_time: i32) {\\n        self.clean_expired_tokens(current_time);\\n        match self.tokens.entry(token_id) {\\n            Occupied(mut entry) => *entry.get_mut() = current_time + self.time_to_live,\\n            Vacant(_) => (),\\n        }\\n    }\\n\\n    fn count_unexpired_tokens(&mut self, current_time: i32) -> i32 {\\n        self.clean_expired_tokens(current_time);\\n        self.tokens.len() as i32\\n    }\\n\\n    fn clean_expired_tokens(&mut self, current_time: i32) {\\n        self.tokens.retain(|_, exp_time| *exp_time > current_time)\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```rust\\nuse std::{\\n    cell::RefCell,\\n    cmp::Ordering,\\n    collections::hash_map::Entry::Occupied,\\n    collections::{hash_map::Entry::Vacant, BTreeSet},\\n    collections::{BTreeMap, BinaryHeap, HashMap, HashSet, VecDeque},\\n    rc::Rc,\\n};\\n\\n\\n\\nstruct AuthenticationManager {\\n    time_to_live: i32,\\n    tokens: HashMap<String, i32>,\\n}\\n\\nimpl AuthenticationManager {\\n    fn new(time_to_live: i32) -> Self {\\n        Self {\\n            time_to_live,\\n            tokens: HashMap::new(),\\n        }\\n    }\\n\\n    fn generate(&mut self, token_id: String, current_time: i32) {\\n        self.tokens\\n            .insert(token_id, current_time + self.time_to_live);\\n    }\\n\\n    fn renew(&mut self, token_id: String, current_time: i32) {\\n        self.clean_expired_tokens(current_time);\\n        match self.tokens.entry(token_id) {\\n            Occupied(mut entry) => *entry.get_mut() = current_time + self.time_to_live,\\n            Vacant(_) => (),\\n        }\\n    }\\n\\n    fn count_unexpired_tokens(&mut self, current_time: i32) -> i32 {\\n        self.clean_expired_tokens(current_time);\\n        self.tokens.len() as i32\\n    }\\n\\n    fn clean_expired_tokens(&mut self, current_time: i32) {\\n        self.tokens.retain(|_, exp_time| *exp_time > current_time)\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2185230,
                "title": "c-simple-hash-map-design",
                "content": "```\\nclass AuthenticationManager {\\n    int ttl_;\\n    unordered_map<string, int> s_;\\npublic:\\n    AuthenticationManager(int ttl): ttl_(ttl) {\\n        \\n    }\\n    \\n    void generate(string tid, int ct) {\\n        s_[tid] = ct;\\n    }\\n    \\n    void renew(string tid, int ct) {\\n        if (s_.find(tid) == s_.end()) return;\\n        if (s_[tid] + ttl_ <= ct) s_.erase(tid);\\n        else s_[tid] = ct;\\n    }\\n    \\n    int countUnexpiredTokens(int ct) {\\n        int cnt = 0;\\n        vector<string> to_exp;\\n        for (auto& [token, time] : s_) {\\n            if (time + ttl_ <= ct) to_exp.emplace_back(token);\\n            else cnt++;\\n        }\\n        for (const auto& t : to_exp) s_.erase(t);\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass AuthenticationManager {\\n    int ttl_;\\n    unordered_map<string, int> s_;\\npublic:\\n    AuthenticationManager(int ttl): ttl_(ttl) {\\n        \\n    }\\n    \\n    void generate(string tid, int ct) {\\n        s_[tid] = ct;\\n    }\\n    \\n    void renew(string tid, int ct) {\\n        if (s_.find(tid) == s_.end()) return;\\n        if (s_[tid] + ttl_ <= ct) s_.erase(tid);\\n        else s_[tid] = ct;\\n    }\\n    \\n    int countUnexpiredTokens(int ct) {\\n        int cnt = 0;\\n        vector<string> to_exp;\\n        for (auto& [token, time] : s_) {\\n            if (time + ttl_ <= ct) to_exp.emplace_back(token);\\n            else cnt++;\\n        }\\n        for (const auto& t : to_exp) s_.erase(t);\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166547,
                "title": "simple-and-readable-java-solution-hashmap",
                "content": "```\\nclass AuthenticationManager {\\n    private int ttl;\\n    private Map<String, Integer> map;\\n\\n    public AuthenticationManager(int timeToLive) {\\n        this.ttl = timeToLive;\\n        this.map = new HashMap<>();\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        map.put(tokenId, currentTime + this.ttl);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        Integer expirationTime = this.map.getOrDefault(tokenId, null);\\n        if (expirationTime == null || expirationTime <= currentTime)\\n            return;\\n        \\n        generate(tokenId, currentTime);\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        int count = 0;\\n        for (Map.Entry<String, Integer> entry: this.map.entrySet())\\n            if (entry.getValue() > currentTime)\\n                count++;\\n        \\n        return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass AuthenticationManager {\\n    private int ttl;\\n    private Map<String, Integer> map;\\n\\n    public AuthenticationManager(int timeToLive) {\\n        this.ttl = timeToLive;\\n        this.map = new HashMap<>();\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        map.put(tokenId, currentTime + this.ttl);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        Integer expirationTime = this.map.getOrDefault(tokenId, null);\\n        if (expirationTime == null || expirationTime <= currentTime)\\n            return;\\n        \\n        generate(tokenId, currentTime);\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        int count = 0;\\n        for (Map.Entry<String, Integer> entry: this.map.entrySet())\\n            if (entry.getValue() > currentTime)\\n                count++;\\n        \\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899981,
                "title": "go-language-using-fibonacciheap",
                "content": "```\\n// Heap Node.\\ntype Node struct {\\n\\t// \\u0421\\u043E\\u0434\\u0435\\u0440\\u0436\\u0438\\u043C\\u043E\\u0435 \\u0443\\u0437\\u043B\\u0430.\\n\\tx string\\n\\t// \\u041A\\u043B\\u044E\\u0447\\n\\tkey int\\n\\t// \\u041F\\u0440\\u0435\\u0434\\u043E\\u043A \\u0443\\u0437\\u043B\\u0430\\n\\tparent *Node\\n\\t// \\u041B\\u0435\\u0432\\u044B\\u0439 \\u0431\\u0440\\u0430\\u0442\\u0441\\u043A\\u0438\\u0439 / \\u0441\\u0435\\u0441\\u0442\\u0440\\u0438\\u043D\\u0441\\u043A\\u0438\\u0439 \\u0443\\u0437\\u0435\\u043B\\n\\tleft *Node\\n\\t// \\u041F\\u0440\\u0430\\u0432\\u044B\\u0439 \\u0431\\u0440\\u0430\\u0442\\u0441\\u043A\\u0438\\u0439 / \\u0441\\u0435\\u0441\\u0442\\u0440\\u0438\\u043D\\u0441\\u043A\\u0438\\u0439 \\u0443\\u0437\\u0435\\u043B\\n\\tright *Node\\n\\t// \\u041F\\u0440\\u044F\\u043C\\u043E\\u0439 \\u043F\\u043E\\u0442\\u043E\\u043C\\u043E\\u043A \\u0443\\u0437\\u043B\\u0430\\n\\tchild *Node\\n\\t// \\u0420\\u0430\\u043D\\u0433 \\u0443\\u0437\\u043B\\u0430 = \\u043A\\u043E\\u043B-\\u0432\\u043E \\u043F\\u0440\\u044F\\u043C\\u044B\\u0445 \\u043F\\u043E\\u0442\\u043E\\u043C\\u043A\\u043E\\u0432\\n\\trank int\\n\\t// \\u041F\\u0435\\u0440\\u0435\\u043C\\u0435\\u0449\\u0430\\u043B\\u0438\\u0441\\u044C \\u043B\\u0438 \\u0440\\u0430\\u043D\\u0435\\u0435 \\u043F\\u043E\\u0442\\u043E\\u043C\\u043A\\u0438 \\u044D\\u0442\\u043E\\u0433\\u043E \\u0443\\u0437\\u043B\\u0430\\n\\tmarked bool\\n}\\n\\nfunc ConstructNode(x string, key int) Node {\\n\\t// Node initialization.\\n\\tthis := Node{\\n\\t\\tx:   x,\\n\\t\\tkey: key,\\n\\t}\\n\\treturn this\\n}\\n\\nfunc (this *Node) _extract() {\\n\\t// \\u0423\\u0434\\u0430\\u043B\\u0435\\u043D\\u0438\\u0435 \\u0441\\u0432\\u044F\\u0437\\u0435\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0434 \\u043F\\u0435\\u0440\\u0435\\u043D\\u043E\\u0441\\u043E\\u043C \\u0443\\u0437\\u043B\\u0430.\\n\\tthis.parent = nil\\n\\tthis.left = nil\\n\\tthis.right = nil\\n}\\n\\nfunc (this *Node) __repr__() string {\\n\\t// Node representation.\\n\\treturn fmt.Sprintf(\"Node(x={%d})\", this.x)\\n}\\n\\n// \\u0424\\u0438\\u0431\\u043E\\u043D\\u0430\\u0447\\u0447\\u0438\\u0435\\u0432\\u0430 \\u043A\\u0443\\u0447\\u0430.\\ntype FibonacciHeap struct {\\n\\tminNode *Node\\n}\\n\\nfunc ConstructHeap(node *Node) *FibonacciHeap {\\n\\t/*\\n\\t   \\u0421\\u043E\\u0437\\u0434\\u0430\\u043D\\u0438\\u0435 \\u043D\\u043E\\u0432\\u043E\\u0439 \\u0444\\u0438\\u0431\\u043E\\u043D\\u0430\\u0447\\u0447\\u0438\\u0435\\u0432\\u043E\\u0439 \\u043A\\u0443\\u0447\\u0438.\\n\\n\\t   \\u0412\\u0440\\u0435\\u043C\\u044F \\u0440\\u0430\\u0431\\u043E\\u0442\\u044B: O(1)\\n\\t*/\\n\\tthis := &FibonacciHeap{minNode: node}\\n\\treturn this\\n}\\n\\nfunc (this *FibonacciHeap) insert(node *Node) {\\n\\t/*\\n\\t   \\u0412\\u0441\\u0442\\u0430\\u0432\\u043A\\u0430 \\u0443\\u0437\\u043B\\u0430 node \\u0432 \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u043A\\u043E\\u0440\\u043D\\u0435\\u0432\\u044B\\u0445 \\u0443\\u0437\\u043B\\u043E\\u0432.\\n\\n\\t   \\u0412\\u0440\\u0435\\u043C\\u044F \\u0440\\u0430\\u0431\\u043E\\u0442\\u044B: O(1)\\n\\t*/\\n\\th2 := ConstructHeap(nil)\\n\\th2._set_min(node)\\n\\tthis.meld(h2)\\n}\\n\\nfunc (this *FibonacciHeap) _set_min(node *Node) {\\n\\t/*\\n\\t   \\u0423\\u0441\\u0442\\u0430\\u043D\\u043E\\u0432\\u043A\\u0430 \\u043C\\u0438\\u043D\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u043E\\u0433\\u043E \\u0443\\u0437\\u043B\\u0430.\\n\\n\\t   \\u0412\\u0440\\u0435\\u043C\\u044F \\u0440\\u0430\\u0431\\u043E\\u0442\\u044B: O(1)\\n\\t*/\\n\\tthis.minNode = node\\n}\\n\\nfunc (this *FibonacciHeap) _update_min(node *Node) {\\n\\t/*\\n\\t   \\u041E\\u0431\\u043D\\u043E\\u0432\\u043B\\u0435\\u043D\\u0438\\u0435 \\u043C\\u0438\\u043D\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u043E\\u0433\\u043E \\u0443\\u0437\\u043B\\u0430, \\u0435\\u0441\\u043B\\u0438 \\u043A\\u043B\\u044E\\u0447 \\u043C\\u0435\\u043D\\u044C\\u0448\\u0435.\\n\\n\\t   \\u0412\\u0440\\u0435\\u043C\\u044F \\u0440\\u0430\\u0431\\u043E\\u0442\\u044B: O(1)\\n\\t*/\\n\\tcurrent := this.find_min()\\n\\tif current == nil {\\n\\t\\tthis._set_min(node)\\n\\t} else if node != nil && node.key <= current.key {\\n\\t\\tthis._set_min(node)\\n\\t}\\n}\\n\\nfunc (this *FibonacciHeap) find_min() *Node {\\n\\t/*\\n\\t   \\u041F\\u043E\\u0438\\u0441\\u043A \\u043C\\u0438\\u043D\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u043E\\u0433\\u043E \\u0443\\u0437\\u043B\\u0430.\\n\\n\\t   \\u0412\\u0440\\u0435\\u043C\\u044F \\u0440\\u0430\\u0431\\u043E\\u0442\\u044B: O(1)\\n\\t*/\\n\\treturn this.minNode\\n}\\n\\nfunc (this *FibonacciHeap) meld(h *FibonacciHeap) {\\n\\t/*\\n\\t   \\u041E\\u0431\\u044A\\u0435\\u0434\\u0438\\u043D\\u0435\\u043D\\u0438\\u0435 \\u0434\\u0432\\u0443\\u0445 \\u0444\\u0438\\u0431\\u043E\\u043D\\u0430\\u0447\\u0447\\u0438\\u0435\\u0432\\u044B\\u0445 \\u043A\\u0443\\u0447.\\n\\n\\t   \\u0412\\u0440\\u0435\\u043C\\u044F \\u0440\\u0430\\u0431\\u043E\\u0442\\u044B: O(1)\\n\\t*/\\n\\tnode1 := this.find_min()\\n\\tnode2 := h.find_min()\\n\\t// \\u0421\\u043A\\u043B\\u0435\\u0438\\u0432\\u0430\\u043D\\u0438\\u0435 \\u0434\\u0432\\u0443\\u0445 \\u0434\\u0432\\u0443\\u0441\\u0432\\u044F\\u0437\\u043D\\u044B\\u0445 \\u0441\\u043F\\u0438\\u0441\\u043A\\u043E\\u0432 (\\u043A\\u043E\\u043B\\u0435\\u0446)\\n\\t// x - \\u0443\\u0434\\u0430\\u043B\\u044F\\u0435\\u043C\\u0430\\u044F \\u0441\\u0432\\u044F\\u0437\\u044C\\n\\t// left1 <-x node1 -> right1\\n\\t//       X\\n\\t// left2 <-x node2 -> right2\\n\\n\\t// \\u0414\\u043E\\u0431\\u0430\\u0432\\u043B\\u044F\\u0435\\u043C\\u0430\\u044F \\u043A\\u0443\\u0447\\u0430 \\u043F\\u0443\\u0441\\u0442\\u0430\\n\\tif node2 == nil {\\n\\t\\treturn\\n\\t}\\n\\n\\t// \\u0418\\u0441\\u0445\\u043E\\u0434\\u043D\\u0430\\u044F \\u043A\\u0443\\u0447\\u0430 \\u043F\\u0443\\u0441\\u0442\\u0430\\n\\tif node1 == nil {\\n\\t\\tthis._set_min(node2)\\n\\t\\treturn\\n\\t}\\n\\n\\t// \\u041F\\u043E\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u0443 \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0434\\u0432\\u0443\\u0441\\u0432\\u044F\\u0437\\u043D\\u044B\\u0439 \\u043A\\u043E\\u043B\\u044C\\u0446\\u0435\\u0432\\u043E\\u0439, \\u0442\\u043E \\u0435\\u0441\\u043B\\u0438 \\u0435\\u0441\\u0442\\u044C \\u043B\\u0435\\u0432\\u044B\\u0439 \\u0443\\u0437\\u0435\\u043B,\\n\\t// \\u0442\\u043E \\u0441\\u0443\\u0449\\u0435\\u0441\\u0442\\u0432\\u0443\\u0435\\u0442 \\u043F\\u0440\\u0430\\u0432\\u044B\\u0439 (\\u0440\\u0430\\u0432\\u0435\\u043D \\u043B\\u0435\\u0432\\u043E\\u043C\\u0443 \\u0438\\u043B\\u0438 \\u0434\\u0440\\u0443\\u0433\\u043E\\u043C\\u0443)\\n\\t// \\u0415\\u0441\\u043B\\u0438 \\u0432 \\u0441\\u043F\\u0438\\u0441\\u043A\\u0435 1 \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442, \\u0442\\u043E \\u043E\\u043D \\u043D\\u0435 \\u0443\\u043A\\u0430\\u0437\\u044B\\u0432\\u0430\\u0435\\u0442 \\u0441\\u0430\\u043C \\u043D\\u0430 \\u0441\\u0435\\u0431\\u044F = None\\n\\tleft1 := node1.left\\n\\tleft2 := node2.left\\n\\n\\t// \\u0412 \\u0438\\u0441\\u0445\\u043E\\u0434\\u043D\\u043E\\u0439 \\u043A\\u0443\\u0447\\u0435 1 \\u043A\\u043E\\u0440\\u043D\\u0435\\u0432\\u043E\\u0439 \\u0443\\u0437\\u0435\\u043B\\n\\tif left1 == nil {\\n\\t\\tif left2 != nil {\\n\\t\\t\\t// \\u041F\\u043E \\u043B\\u0435\\u0432\\u043E\\u043C\\u0443 \\u0443\\u0437\\u043B\\u0443 \\u0432\\u0442\\u043E\\u0440\\u043E\\u0439 \\u043A\\u0443\\u0447\\u0438\\n\\t\\t\\t//      node1\\n\\t\\t\\t//   |        |\\n\\t\\t\\t// left2 <-x node2\\n\\t\\t\\tnode1.left = left2\\n\\t\\t\\tnode1.right = node2\\n\\t\\t\\tleft2.right = node1\\n\\t\\t\\tnode2.left = node1\\n\\t\\t} else {\\n\\t\\t\\t// \\u0412 \\u043E\\u0431\\u0435\\u0438\\u0445 \\u043A\\u0443\\u0447\\u0430\\u0445 1 \\u043A\\u043E\\u0440\\u043D\\u0435\\u0432\\u043E\\u0439 \\u0443\\u0437\\u0435\\u043B\\n\\t\\t\\t// node1\\n\\t\\t\\t//   |\\n\\t\\t\\t// node2\\n\\t\\t\\tnode1.left = node2\\n\\t\\t\\tnode1.right = node2\\n\\t\\t\\tnode2.left = node1\\n\\t\\t\\tnode2.right = node1\\n\\t\\t}\\n\\t} else {\\n\\t\\t// \\u0421\\u043A\\u043B\\u0435\\u0438\\u0432\\u0430\\u0435\\u043C \\u0447\\u0435\\u0440\\u0435\\u0437 \\u043B\\u0435\\u0432\\u044B\\u0439 \\u043A\\u043E\\u0440\\u043D\\u0435\\u0432\\u043E\\u0439 \\u0443\\u0437\\u0435\\u043B \\u0432\\u0442\\u043E\\u0440\\u043E\\u0439 \\u043A\\u0443\\u0447\\u0438\\n\\t\\tif left2 != nil {\\n\\t\\t\\t// left1 <-x node1\\n\\t\\t\\t//        X\\n\\t\\t\\t// left2 <-x node2\\n\\t\\t\\t// \\u043D\\u0430\\u0438\\u0441\\u043A\\u043E\\u0441\\u043E\\u043A\\n\\t\\t\\tleft1.right = node2\\n\\t\\t\\tnode1.left = left2\\n\\t\\t\\tleft2.right = node1\\n\\t\\t\\tnode2.left = left1\\n\\t\\t\\t// \\u0412\\u043E \\u0432\\u0442\\u043E\\u0440\\u043E\\u0439 \\u043A\\u0443\\u0447\\u0435 1 \\u043A\\u043E\\u0440\\u043D\\u0435\\u0432\\u043E\\u0439 \\u0443\\u0437\\u0435\\u043B\\n\\t\\t} else {\\n\\t\\t\\t// left1 <-x node1\\n\\t\\t\\t//   |        |\\n\\t\\t\\t//      node2\\n\\t\\t\\tnode2.left = left1\\n\\t\\t\\tnode2.right = node1\\n\\t\\t\\tleft1.right = node2\\n\\t\\t\\tnode1.left = node2\\n\\t\\t}\\n\\t}\\n\\t// \\u0415\\u0441\\u043B\\u0438 \\u043D\\u0443\\u0436\\u043D\\u043E, \\u043E\\u0431\\u043D\\u043E\\u0432\\u043B\\u044F\\u0435\\u043C \\u043C\\u0438\\u043D\\u0438\\u043C\\u0443\\u043C\\n\\tthis._update_min(node2)\\n}\\n\\nfunc (this *FibonacciHeap) delete_min() *Node {\\n\\t/*\\n\\t   \\u0418\\u0437\\u0432\\u043B\\u0435\\u0447\\u0435\\u043D\\u0438\\u0435 \\u043C\\u0438\\u043D\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u043E\\u0433\\u043E \\u0443\\u0437\\u043B\\u0430.\\n\\n\\t   \\tx\\n\\t   \\t/ | \\\\\\n\\t   c1 c2 c3\\n\\t   \\u0410\\u043C\\u043E\\u0440\\u0442\\u0438\\u0437\\u0438\\u0440\\u043E\\u0432\\u0430\\u043D\\u043D\\u043E\\u0435 \\u0432\\u0440\\u0435\\u043C\\u044F \\u0440\\u0430\\u0431\\u043E\\u0442\\u044B: O(log n)\\n\\t*/\\n\\troot := this.find_min()\\n\\tif root == nil {\\n\\t\\t// raise ValueError(\"\\u041A\\u0443\\u0447\\u0430 \\u043F\\u0443\\u0441\\u0442\\u0430\")\\n\\t\\treturn nil\\n\\t}\\n\\t// \\u0423\\u0441\\u0442\\u0430\\u043D\\u0430\\u0432\\u043B\\u0438\\u0432\\u0430\\u0435\\u043C \\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u043E \\u043C\\u0438\\u043D\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u044B\\u0439 \\u0443\\u0437\\u0435\\u043B \\u043D\\u0430 \\u043B\\u0435\\u0432\\u044B\\u0439\\n\\tthis._set_min(root.left)\\n\\t// \\u0423\\u0434\\u0430\\u043B\\u044F\\u0435\\u043C \\u0438\\u0437 \\u0441\\u043F\\u0438\\u0441\\u043A\\u0430 \\u043C\\u0438\\u043D\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u044B\\u0439 \\u0443\\u0437\\u0435\\u043B\\n\\tthis._unlink(root)\\n\\t// \\u0421\\u043E\\u0437\\u0434\\u0430\\u0435\\u043C \\u043D\\u043E\\u0432\\u0443\\u044E \\u043A\\u0443\\u0447\\u0443 \\u0438\\u0437 \\u043F\\u043E\\u0442\\u043E\\u043C\\u043A\\u043E\\u0432 root (\\u0443 \\u043D\\u0438\\u0445 \\u043F\\u0440\\u0435\\u0436\\u043D\\u0438\\u0439 parent)\\n\\th := ConstructHeap(root.child)\\n\\tthis.meld(h)\\n\\tthis._consolidate()\\n\\troot._extract()\\n\\troot.child = nil\\n\\treturn root\\n}\\n\\nfunc (this *FibonacciHeap) _unlink(node *Node) *Node {\\n\\t/*\\n\\t   \\u0418\\u0437\\u0432\\u043B\\u0435\\u0447\\u0435\\u043D\\u0438\\u0435 \\u0443\\u0437\\u043B\\u0430 \\u0438\\u0437 \\u0434\\u0432\\u0443\\u0445\\u0441\\u0432\\u044F\\u0437\\u043D\\u043E\\u0433\\u043E \\u0441\\u043F\\u0438\\u0441\\u043A\\u0430.\\n\\n\\t   \\u0412\\u043E\\u0437\\u0432\\u0440\\u0430\\u0449\\u0430\\u0435\\u0442 \\u043B\\u0435\\u0432\\u044B\\u0439 \\u0443\\u0437\\u0435\\u043B \\u0438\\u0437 \\u043E\\u0441\\u0442\\u0430\\u0432\\u0448\\u0438\\u0445\\u0441\\u044F \\u0432 \\u0441\\u043F\\u0438\\u0441\\u043A\\u0435, \\u043B\\u0438\\u0431\\u043E None\\n\\t   left - node - right = left - right\\n\\t   \\u0412\\u0440\\u0435\\u043C\\u044F \\u0440\\u0430\\u0431\\u043E\\u0442\\u044B: O(1)\\n\\t*/\\n\\tleft := node.left\\n\\tright := node.right\\n\\n\\t// \\u0412 \\u0441\\u043F\\u0438\\u0441\\u043A\\u0435 1 \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442 - \\u0443\\u0434\\u0430\\u043B\\u044F\\u0435\\u043C\\u044B\\u0439\\n\\tif left == nil {\\n\\t\\treturn nil\\n\\t}\\n\\n\\tif left == right {\\n\\t\\t// \\u0412 \\u0441\\u043F\\u0438\\u0441\\u043A\\u0435 \\u0431\\u044B\\u043B\\u043E 2 \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u0430\\n\\t\\tleft.left = nil\\n\\t\\tleft.right = nil\\n\\t} else {\\n\\t\\tleft.right = right\\n\\t\\tright.left = left\\n\\t}\\n\\n\\treturn left\\n}\\n\\nfunc (this *FibonacciHeap) _consolidate() {\\n\\t/*\\n\\t   \\u0423\\u043F\\u043B\\u043E\\u0442\\u043D\\u0435\\u043D\\u0438\\u0435 \\u0441\\u043F\\u0438\\u0441\\u043A\\u0430 \\u043A\\u043E\\u0440\\u043D\\u0435\\u0439 - \\u0441\\u043A\\u043B\\u0435\\u0438\\u0432\\u0430\\u043D\\u0438\\u0435 \\u0434\\u0435\\u0440\\u0435\\u0432\\u044C\\u0435\\u0432 \\u0441 \\u043E\\u0434\\u0438\\u043D\\u0430\\u043A\\u043E\\u0432\\u044B\\u043C \\u0440\\u0430\\u043D\\u0433\\u043E\\u043C.\\n\\n\\t   \\u041E\\u0431\\u043D\\u043E\\u0432\\u043B\\u044F\\u0435\\u0442 \\u043C\\u0438\\u043D\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u044B\\u0439 \\u0443\\u0437\\u0435\\u043B\\n\\t   \\u0438 \\u0443\\u0441\\u0442\\u0430\\u043D\\u0430\\u0432\\u043B\\u0438\\u0432\\u0430\\u0435\\u0442 parent=None \\u0434\\u043B\\u044F \\u0432\\u0441\\u0435\\u0445 \\u043A\\u043E\\u0440\\u043D\\u0435\\u0432\\u044B\\u0445 \\u0443\\u0437\\u043B\\u043E\\u0432\\n\\t   \\u0412\\u0440\\u0435\\u043C\\u044F \\u0440\\u0430\\u0431\\u043E\\u0442\\u044B: O(log n)\\n\\t*/\\n\\t// \\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u044B\\u0439 \\u043C\\u0438\\u043D\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u044B\\u0439 \\u0443\\u0437\\u0435\\u043B\\n\\troot := this.find_min()\\n\\tif root == nil {\\n\\t\\treturn\\n\\t}\\n\\n\\t// \\u0421\\u043B\\u043E\\u0432\\u0430\\u0440\\u044C \\u043A\\u043E\\u0440\\u043D\\u0435\\u0432\\u044B\\u0445 \\u0443\\u0437\\u043B\\u043E\\u0432 \\u0432\\u0438\\u0434\\u0430 \\u0440\\u0430\\u043D\\u0433 -> \\u0443\\u0437\\u0435\\u043B\\n\\tranked := map[int]*Node{}\\n\\tranked[root.rank] = root\\n\\troot.parent = nil\\n\\tnode := root.right\\n\\n\\tfor {\\n\\t\\tif node == nil {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\t// \\u0423 \\u043A\\u043E\\u0440\\u043D\\u044F \\u043D\\u0435\\u0442 \\u043F\\u0440\\u0435\\u0434\\u043A\\u043E\\u0432\\n\\t\\tnode.parent = nil\\n\\t\\t// \\u0422\\u0435\\u043A\\u0443\\u0449\\u0438\\u0439 \\u0443\\u0437\\u0435\\u043B\\n\\t\\tmelded := node\\n\\t\\t// \\u0421\\u043B\\u0435\\u0434\\u0443\\u044E\\u0449\\u0438\\u0439 \\u043F\\u0440\\u043E\\u0441\\u043C\\u0430\\u0442\\u0440\\u0438\\u0432\\u0430\\u0435\\u043C\\u044B\\u0439 \\u0443\\u0437\\u0435\\u043B\\n\\t\\tnode = node.right\\n\\t\\tv, ok := ranked[node.rank]\\n\\t\\tif ok && v == node {\\n\\t\\t\\t// \\u041C\\u044B \\u0442\\u0430\\u043C \\u0443\\u0436\\u0435 \\u0431\\u044B\\u043B\\u0438, \\u043F\\u043E\\u044D\\u0442\\u043E\\u043C\\u0443 \\u044D\\u0442\\u0430 \\u0438\\u0442\\u0435\\u0440\\u0430\\u0446\\u0438\\u044F \\u043F\\u043E\\u0441\\u043B\\u0435\\u0434\\u043D\\u044F\\u044F\\n\\t\\t\\tnode = nil\\n\\t\\t}\\n\\n\\t\\tfor {\\n\\t\\t\\t// \\u0412 \\u0441\\u043F\\u0438\\u0441\\u043A\\u0435 \\u043A\\u043E\\u0440\\u043D\\u0435\\u0439 \\u0435\\u0441\\u0442\\u044C \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E \\u0441 \\u0442\\u0430\\u043A\\u0438\\u043C \\u0436\\u0435 \\u0440\\u0430\\u043D\\u0433\\u043E\\u043C.\\n\\t\\t\\trank := melded.rank\\n\\n\\t\\t\\tv, ok := ranked[rank]\\n\\t\\t\\tif !ok {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t\\t// \\u0421\\u043A\\u043B\\u0435\\u0438\\u0432\\u0430\\u0435\\u043C\\n\\t\\t\\tmelded = this._link(melded, v)\\n\\t\\t\\t// \\u0438 \\u0443\\u0434\\u0430\\u043B\\u044F\\u0435\\u043C \\u0438\\u0437 \\u0441\\u043B\\u043E\\u0432\\u0430\\u0440\\u044F \\u043F\\u0440\\u0435\\u0436\\u043D\\u0438\\u0439 \\u0440\\u0430\\u043D\\u0433\\n\\t\\t\\tdelete(ranked, rank)\\n\\t\\t}\\n\\t\\t// \\u043E\\u0431\\u043D\\u043E\\u0432\\u043B\\u044F\\u0435\\u043C \\u0441 \\u043D\\u043E\\u0432\\u044B\\u043C \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435\\u043C \\u0440\\u0430\\u043D\\u0433\\u0430 \\u043F\\u043E\\u043B\\u0443\\u0447\\u0438\\u0432\\u0448\\u0435\\u0435\\u0441\\u044F \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E\\n\\t\\tranked[melded.rank] = melded\\n\\t\\t// \\u041E\\u0431\\u043D\\u043E\\u0432\\u043B\\u044F\\u0435\\u043C \\u043C\\u0438\\u043D\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u044B\\u0439 \\u0443\\u0437\\u0435\\u043B\\n\\t\\tthis._update_min(melded)\\n\\t}\\n}\\n\\nfunc (this *FibonacciHeap) _link(node1 *Node, node2 *Node) *Node {\\n\\t/*\\n\\t   \\u0421\\u043A\\u043B\\u0435\\u0438\\u0432\\u0430\\u043D\\u0438\\u0435 \\u0434\\u0432\\u0443\\u0445 \\u043A\\u043E\\u0440\\u043D\\u0435\\u0439.\\n\\n\\t   \\u041A\\u043E\\u0440\\u043D\\u0435\\u043C \\u0441\\u0442\\u0430\\u043D\\u043E\\u0432\\u0438\\u0442\\u0441\\u044F \\u0443\\u0437\\u0435\\u043B \\u0441 \\u043C\\u0435\\u043D\\u044C\\u0448\\u0438\\u043C \\u043A\\u043B\\u044E\\u0447\\u043E\\u043C, \\u0432\\u0442\\u043E\\u0440\\u043E\\u0439 - \\u0435\\u0433\\u043E \\u043F\\u043E\\u0442\\u043E\\u043C\\u043A\\u043E\\u043C\\n\\t   \\u0412\\u043E\\u0437\\u0432\\u0440\\u0430\\u0449\\u0430\\u0435\\u0442 \\u043F\\u043E\\u043B\\u0443\\u0447\\u0438\\u0432\\u0448\\u0438\\u0439\\u0441\\u044F \\u043A\\u043E\\u0440\\u0435\\u043D\\u044C\\n\\t   \\u0412\\u0440\\u0435\\u043C\\u044F \\u0440\\u0430\\u0431\\u043E\\u0442\\u044B: O(1)\\n\\t*/\\n\\tif node1.key > node2.key {\\n\\t\\tnode1, node2 = node2, node1\\n\\t}\\n\\t// node1              node1\\n\\t//   |    ->            |\\n\\t// child      node2 - child\\n\\n\\t// node2 \\u0438\\u0437\\u0432\\u043B\\u0435\\u043A\\u0430\\u0435\\u0442\\u0441\\u044F \\u0438\\u0437 \\u0441\\u043F\\u0438\\u0441\\u043A\\u0430 \\u043A\\u043E\\u0440\\u043D\\u0435\\u0439\\n\\tthis._unlink(node2)\\n\\tnode2._extract()\\n\\t// \\u0443\\u0431\\u0438\\u0440\\u0430\\u0435\\u0442\\u0441\\u044F \\u043E\\u0442\\u043C\\u0435\\u0442\\u043A\\u0430\\n\\tnode2.marked = false\\n\\t// \\u0438 \\u043E\\u043D \\u0441\\u0442\\u0430\\u043D\\u043E\\u0432\\u0438\\u0442\\u0441\\u044F \\u043F\\u043E\\u0442\\u043E\\u043C\\u043A\\u043E\\u043C node1\\n\\tnode2.parent = node1\\n\\t// \\u041E\\u0431\\u043D\\u043E\\u0432\\u043B\\u044F\\u0435\\u043C \\u0440\\u0430\\u043D\\u0433 \\u043F\\u043E\\u043B\\u0443\\u0447\\u0438\\u0432\\u0448\\u0435\\u0433\\u043E\\u0441\\u044F \\u0434\\u0435\\u0440\\u0435\\u0432\\u0430\\n\\tnode1.rank += 1\\n\\n\\t// \\u041F\\u043E\\u0442\\u043E\\u043C\\u043E\\u043A \\u043F\\u0435\\u0440\\u0432\\u043E\\u0433\\u043E \\u043A\\u043E\\u0440\\u043D\\u044F\\n\\tchild := node1.child\\n\\tif child == nil {\\n\\t\\t// \\u0415\\u0441\\u043B\\u0438 \\u043D\\u0435\\u0442 \\u043F\\u043E\\u0442\\u043E\\u043C\\u043A\\u043E\\u0432\\n\\t\\tnode1.child = node2\\n\\t} else {\\n\\t\\tleft := child.left\\n\\t\\tif left == nil {\\n\\t\\t\\t// \\u041E\\u0434\\u0438\\u043D \\u043F\\u043E\\u0442\\u043E\\u043C\\u043E\\u043A\\n\\t\\t\\t// child - node2\\n\\t\\t\\tchild.left = node2\\n\\t\\t\\tchild.right = node2\\n\\t\\t\\tnode2.left = child\\n\\t\\t\\tnode2.right = child\\n\\t\\t} else {\\n\\t\\t\\t// left <-x child\\n\\t\\t\\t//   |        |\\n\\t\\t\\t//      node2\\n\\t\\t\\tnode2.left = left\\n\\t\\t\\tnode2.right = child\\n\\t\\t\\tleft.right = node2\\n\\t\\t\\tchild.left = node2\\n\\t\\t}\\n\\t}\\n\\n\\treturn node1\\n}\\n\\nfunc (this *FibonacciHeap) decrease_key(node *Node, newkey int) {\\n\\t/*\\n\\t   \\u0423\\u043C\\u0435\\u043D\\u044C\\u0448\\u0435\\u043D\\u0438\\u0435 \\u043A\\u043B\\u044E\\u0447\\u0430 \\u0443\\u0437\\u043B\\u0430 node \\u0434\\u043E \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u044F newkey.\\n\\n\\t   \\u0412\\u0440\\u0435\\u043C\\u044F \\u0440\\u0430\\u0431\\u043E\\u0442\\u044B: O(1)\\n\\t*/\\n\\tnode.key = newkey\\n\\n\\tif node.parent == nil {\\n\\t\\t// \\u0423\\u0437\\u0435\\u043B - \\u043A\\u043E\\u0440\\u043D\\u0435\\u0432\\u043E\\u0439\\n\\t\\tthis._update_min(node)\\n\\t\\treturn\\n\\t}\\n\\n\\tparent := node.parent\\n\\tparent.rank -= 1\\n\\tparent.child = this._unlink(node)\\n\\tthis._cascading_cut(parent)\\n\\tnode._extract()\\n\\tthis.insert(node)\\n}\\n\\nfunc (this *FibonacciHeap) _cut(node *Node) {\\n\\t/*\\n\\t   \\u041F\\u043E\\u0434\\u0440\\u0435\\u0437\\u043A\\u0430 \\u0434\\u0435\\u0440\\u0435\\u0432\\u0430 - \\u043F\\u0435\\u0440\\u0435\\u043D\\u043E\\u0441 node \\u0432 \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u043A\\u043E\\u0440\\u043D\\u0435\\u0439.\\n\\n\\t   \\u0412\\u0440\\u0435\\u043C\\u044F \\u0440\\u0430\\u0431\\u043E\\u0442\\u044B: O(1)\\n\\t*/\\n\\tparent := node.parent\\n\\tif parent == nil {\\n\\t\\t// \\u0423\\u0437\\u0435\\u043B \\u0443\\u0436\\u0435 \\u043A\\u043E\\u0440\\u043D\\u0435\\u0432\\u043E\\u0439\\n\\t\\treturn\\n\\t}\\n\\tparent.rank -= 1\\n\\tparent.child = this._unlink(node)\\n\\tnode._extract()\\n\\tthis.insert(node)\\n}\\n\\nfunc (this *FibonacciHeap) _cascading_cut(node *Node) {\\n\\t/*\\n\\t   \\u041A\\u0430\\u0441\\u043A\\u0430\\u0434\\u043D\\u0430\\u044F \\u043F\\u043E\\u0434\\u0440\\u0435\\u0437\\u043A\\u0430 \\u0434\\u0435\\u0440\\u0435\\u0432\\u0430.\\n\\n\\t   \\u041D\\u0430\\u0447\\u0438\\u043D\\u0430\\u044F \\u043E\\u0442 \\u0443\\u0437\\u043B\\u0430 node, \\u0438 \\u043F\\u043E\\u043A\\u0430 \\u043F\\u0440\\u0435\\u0434\\u0448\\u0435\\u0441\\u0442\\u0432\\u0443\\u044E\\u0449\\u0438\\u0439 \\u0443\\u0437\\u0435\\u043B \\u0438\\u043C\\u0435\\u0435\\u0442 \\u043E\\u0442\\u043C\\u0435\\u0442\\u043A\\u0443\\n\\t   \\u043E \\u043F\\u0435\\u0440\\u0435\\u043C\\u0435\\u0449\\u0435\\u043D\\u0438\\u0438 (marked = True), \\u0432\\u0441\\u0435 \\u043E\\u043D\\u0438 \\u0441\\u0442\\u0430\\u043D\\u043E\\u0432\\u044F\\u0442\\u0441\\u044F \\u043A\\u043E\\u0440\\u043D\\u0435\\u0432\\u044B\\u043C\\u0438.\\n\\n\\t   \\u0412\\u0440\\u0435\\u043C\\u044F \\u0440\\u0430\\u0431\\u043E\\u0442\\u044B: O(log n)\\n\\t*/\\n\\tparent := node\\n\\tfor {\\n\\t\\tif parent == nil {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tif !parent.marked {\\n\\t\\t\\tparent.marked = true\\n\\t\\t\\treturn\\n\\t\\t} else {\\n\\t\\t\\tnode = parent\\n\\t\\t\\tparent = node.parent\\n\\t\\t\\tthis._cut(node)\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc (this *FibonacciHeap) remove(node *Node) *Node {\\n\\t/*\\n\\t   \\u0423\\u0434\\u0430\\u043B\\u0435\\u043D\\u0438\\u0435 \\u0443\\u0437\\u043B\\u0430 node.\\n\\n\\t   \\u0410\\u043C\\u043E\\u0440\\u0442\\u0438\\u0437\\u0438\\u0440\\u043E\\u0432\\u0430\\u043D\\u043D\\u043E\\u0435 \\u0432\\u0440\\u0435\\u043C\\u044F \\u0440\\u0430\\u0431\\u043E\\u0442\\u044B: O(log n)\\n\\t*/\\n\\tif node == this.find_min() {\\n\\t\\t// \\u0423\\u0437\\u0435\\u043B - \\u043C\\u0438\\u043D\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u044B\\u0439\\n\\t\\treturn this.delete_min()\\n\\t}\\n\\n\\tparent := node.parent\\n\\tif parent == nil {\\n\\t\\t// \\u0423\\u0437\\u0435\\u043B - \\u043A\\u043E\\u0440\\u043D\\u0435\\u0432\\u043E\\u0439\\n\\t\\tthis._unlink(node)\\n\\t} else {\\n\\t\\tparent.rank -= 1\\n\\t\\tparent.child = this._unlink(node)\\n\\t\\tthis._cascading_cut(parent)\\n\\t}\\n\\n\\th := ConstructHeap(node.child)\\n\\tthis.meld(h)\\n\\tthis._consolidate()\\n\\tnode._extract()\\n\\tnode.child = nil\\n\\treturn node\\n}\\n\\n\\n\\ntype AuthenticationManager struct {\\n    fh *FibonacciHeap\\n    timeToLive int\\n    nodes map[string]*Node\\n}\\n\\n\\nfunc Constructor(timeToLive int) AuthenticationManager {\\n    this := AuthenticationManager{\\n        fh: ConstructHeap(nil),\\n        timeToLive: timeToLive,\\n        nodes: map[string]*Node{},\\n    }\\n    return this\\n}\\n\\n\\nfunc (this *AuthenticationManager) Generate(tokenId string, currentTime int)  {\\n    expired := currentTime + this.timeToLive\\n    node := ConstructNode(tokenId, expired)\\n    this.nodes[tokenId] = &node\\n    this.fh.insert(&node)\\n}\\n\\n\\nfunc (this *AuthenticationManager) Renew(tokenId string, currentTime int)  {\\n    node, ok := this.nodes[tokenId]\\n    if !ok {\\n        return\\n    }\\n    this.fh.remove(node)\\n    if node.key <= currentTime {\\n        delete(this.nodes, tokenId)\\n        return\\n    }\\n    expired := currentTime + this.timeToLive\\n    node.key = expired\\n    this.fh.insert(node)        \\n    \\n}\\n\\n\\nfunc (this *AuthenticationManager) CountUnexpiredTokens(currentTime int) int {\\n    for {\\n        node := this.fh.find_min()\\n        if node == nil {\\n            break\\n        }\\n        if node.key <= currentTime {\\n            this.fh.delete_min()\\n            delete(this.nodes, node.x)\\n        } else {\\n            break\\n        }\\n    }\\n    return len(this.nodes)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n// Heap Node.\\ntype Node struct {\\n\\t// \\u0421\\u043E\\u0434\\u0435\\u0440\\u0436\\u0438\\u043C\\u043E\\u0435 \\u0443\\u0437\\u043B\\u0430.\\n\\tx string\\n\\t// \\u041A\\u043B\\u044E\\u0447\\n\\tkey int\\n\\t// \\u041F\\u0440\\u0435\\u0434\\u043E\\u043A \\u0443\\u0437\\u043B\\u0430\\n\\tparent *Node\\n\\t// \\u041B\\u0435\\u0432\\u044B\\u0439 \\u0431\\u0440\\u0430\\u0442\\u0441\\u043A\\u0438\\u0439 / \\u0441\\u0435\\u0441\\u0442\\u0440\\u0438\\u043D\\u0441\\u043A\\u0438\\u0439 \\u0443\\u0437\\u0435\\u043B\\n\\tleft *Node\\n\\t// \\u041F\\u0440\\u0430\\u0432\\u044B\\u0439 \\u0431\\u0440\\u0430\\u0442\\u0441\\u043A\\u0438\\u0439 / \\u0441\\u0435\\u0441\\u0442\\u0440\\u0438\\u043D\\u0441\\u043A\\u0438\\u0439 \\u0443\\u0437\\u0435\\u043B\\n\\tright *Node\\n\\t// \\u041F\\u0440\\u044F\\u043C\\u043E\\u0439 \\u043F\\u043E\\u0442\\u043E\\u043C\\u043E\\u043A \\u0443\\u0437\\u043B\\u0430\\n\\tchild *Node\\n\\t// \\u0420\\u0430\\u043D\\u0433 \\u0443\\u0437\\u043B\\u0430 = \\u043A\\u043E\\u043B-\\u0432\\u043E \\u043F\\u0440\\u044F\\u043C\\u044B\\u0445 \\u043F\\u043E\\u0442\\u043E\\u043C\\u043A\\u043E\\u0432\\n\\trank int\\n\\t// \\u041F\\u0435\\u0440\\u0435\\u043C\\u0435\\u0449\\u0430\\u043B\\u0438\\u0441\\u044C \\u043B\\u0438 \\u0440\\u0430\\u043D\\u0435\\u0435 \\u043F\\u043E\\u0442\\u043E\\u043C\\u043A\\u0438 \\u044D\\u0442\\u043E\\u0433\\u043E \\u0443\\u0437\\u043B\\u0430\\n\\tmarked bool\\n}\\n\\nfunc ConstructNode(x string, key int) Node {\\n\\t// Node initialization.\\n\\tthis := Node{\\n\\t\\tx:   x,\\n\\t\\tkey: key,\\n\\t}\\n\\treturn this\\n}\\n\\nfunc (this *Node) _extract() {\\n\\t// \\u0423\\u0434\\u0430\\u043B\\u0435\\u043D\\u0438\\u0435 \\u0441\\u0432\\u044F\\u0437\\u0435\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0434 \\u043F\\u0435\\u0440\\u0435\\u043D\\u043E\\u0441\\u043E\\u043C \\u0443\\u0437\\u043B\\u0430.\\n\\tthis.parent = nil\\n\\tthis.left = nil\\n\\tthis.right = nil\\n}\\n\\nfunc (this *Node) __repr__() string {\\n\\t// Node representation.\\n\\treturn fmt.Sprintf(\"Node(x={%d})\", this.x)\\n}\\n\\n// \\u0424\\u0438\\u0431\\u043E\\u043D\\u0430\\u0447\\u0447\\u0438\\u0435\\u0432\\u0430 \\u043A\\u0443\\u0447\\u0430.\\ntype FibonacciHeap struct {\\n\\tminNode *Node\\n}\\n\\nfunc ConstructHeap(node *Node) *FibonacciHeap {\\n\\t/*\\n\\t   \\u0421\\u043E\\u0437\\u0434\\u0430\\u043D\\u0438\\u0435 \\u043D\\u043E\\u0432\\u043E\\u0439 \\u0444\\u0438\\u0431\\u043E\\u043D\\u0430\\u0447\\u0447\\u0438\\u0435\\u0432\\u043E\\u0439 \\u043A\\u0443\\u0447\\u0438.\\n\\n\\t   \\u0412\\u0440\\u0435\\u043C\\u044F \\u0440\\u0430\\u0431\\u043E\\u0442\\u044B: O(1)\\n\\t*/\\n\\tthis := &FibonacciHeap{minNode: node}\\n\\treturn this\\n}\\n\\nfunc (this *FibonacciHeap) insert(node *Node) {\\n\\t/*\\n\\t   \\u0412\\u0441\\u0442\\u0430\\u0432\\u043A\\u0430 \\u0443\\u0437\\u043B\\u0430 node \\u0432 \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u043A\\u043E\\u0440\\u043D\\u0435\\u0432\\u044B\\u0445 \\u0443\\u0437\\u043B\\u043E\\u0432.\\n\\n\\t   \\u0412\\u0440\\u0435\\u043C\\u044F \\u0440\\u0430\\u0431\\u043E\\u0442\\u044B: O(1)\\n\\t*/\\n\\th2 := ConstructHeap(nil)\\n\\th2._set_min(node)\\n\\tthis.meld(h2)\\n}\\n\\nfunc (this *FibonacciHeap) _set_min(node *Node) {\\n\\t/*\\n\\t   \\u0423\\u0441\\u0442\\u0430\\u043D\\u043E\\u0432\\u043A\\u0430 \\u043C\\u0438\\u043D\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u043E\\u0433\\u043E \\u0443\\u0437\\u043B\\u0430.\\n\\n\\t   \\u0412\\u0440\\u0435\\u043C\\u044F \\u0440\\u0430\\u0431\\u043E\\u0442\\u044B: O(1)\\n\\t*/\\n\\tthis.minNode = node\\n}\\n\\nfunc (this *FibonacciHeap) _update_min(node *Node) {\\n\\t/*\\n\\t   \\u041E\\u0431\\u043D\\u043E\\u0432\\u043B\\u0435\\u043D\\u0438\\u0435 \\u043C\\u0438\\u043D\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u043E\\u0433\\u043E \\u0443\\u0437\\u043B\\u0430, \\u0435\\u0441\\u043B\\u0438 \\u043A\\u043B\\u044E\\u0447 \\u043C\\u0435\\u043D\\u044C\\u0448\\u0435.\\n\\n\\t   \\u0412\\u0440\\u0435\\u043C\\u044F \\u0440\\u0430\\u0431\\u043E\\u0442\\u044B: O(1)\\n\\t*/\\n\\tcurrent := this.find_min()\\n\\tif current == nil {\\n\\t\\tthis._set_min(node)\\n\\t} else if node != nil && node.key <= current.key {\\n\\t\\tthis._set_min(node)\\n\\t}\\n}\\n\\nfunc (this *FibonacciHeap) find_min() *Node {\\n\\t/*\\n\\t   \\u041F\\u043E\\u0438\\u0441\\u043A \\u043C\\u0438\\u043D\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u043E\\u0433\\u043E \\u0443\\u0437\\u043B\\u0430.\\n\\n\\t   \\u0412\\u0440\\u0435\\u043C\\u044F \\u0440\\u0430\\u0431\\u043E\\u0442\\u044B: O(1)\\n\\t*/\\n\\treturn this.minNode\\n}\\n\\nfunc (this *FibonacciHeap) meld(h *FibonacciHeap) {\\n\\t/*\\n\\t   \\u041E\\u0431\\u044A\\u0435\\u0434\\u0438\\u043D\\u0435\\u043D\\u0438\\u0435 \\u0434\\u0432\\u0443\\u0445 \\u0444\\u0438\\u0431\\u043E\\u043D\\u0430\\u0447\\u0447\\u0438\\u0435\\u0432\\u044B\\u0445 \\u043A\\u0443\\u0447.\\n\\n\\t   \\u0412\\u0440\\u0435\\u043C\\u044F \\u0440\\u0430\\u0431\\u043E\\u0442\\u044B: O(1)\\n\\t*/\\n\\tnode1 := this.find_min()\\n\\tnode2 := h.find_min()\\n\\t// \\u0421\\u043A\\u043B\\u0435\\u0438\\u0432\\u0430\\u043D\\u0438\\u0435 \\u0434\\u0432\\u0443\\u0445 \\u0434\\u0432\\u0443\\u0441\\u0432\\u044F\\u0437\\u043D\\u044B\\u0445 \\u0441\\u043F\\u0438\\u0441\\u043A\\u043E\\u0432 (\\u043A\\u043E\\u043B\\u0435\\u0446)\\n\\t// x - \\u0443\\u0434\\u0430\\u043B\\u044F\\u0435\\u043C\\u0430\\u044F \\u0441\\u0432\\u044F\\u0437\\u044C\\n\\t// left1 <-x node1 -> right1\\n\\t//       X\\n\\t// left2 <-x node2 -> right2\\n\\n\\t// \\u0414\\u043E\\u0431\\u0430\\u0432\\u043B\\u044F\\u0435\\u043C\\u0430\\u044F \\u043A\\u0443\\u0447\\u0430 \\u043F\\u0443\\u0441\\u0442\\u0430\\n\\tif node2 == nil {\\n\\t\\treturn\\n\\t}\\n\\n\\t// \\u0418\\u0441\\u0445\\u043E\\u0434\\u043D\\u0430\\u044F \\u043A\\u0443\\u0447\\u0430 \\u043F\\u0443\\u0441\\u0442\\u0430\\n\\tif node1 == nil {\\n\\t\\tthis._set_min(node2)\\n\\t\\treturn\\n\\t}\\n\\n\\t// \\u041F\\u043E\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u0443 \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0434\\u0432\\u0443\\u0441\\u0432\\u044F\\u0437\\u043D\\u044B\\u0439 \\u043A\\u043E\\u043B\\u044C\\u0446\\u0435\\u0432\\u043E\\u0439, \\u0442\\u043E \\u0435\\u0441\\u043B\\u0438 \\u0435\\u0441\\u0442\\u044C \\u043B\\u0435\\u0432\\u044B\\u0439 \\u0443\\u0437\\u0435\\u043B,\\n\\t// \\u0442\\u043E \\u0441\\u0443\\u0449\\u0435\\u0441\\u0442\\u0432\\u0443\\u0435\\u0442 \\u043F\\u0440\\u0430\\u0432\\u044B\\u0439 (\\u0440\\u0430\\u0432\\u0435\\u043D \\u043B\\u0435\\u0432\\u043E\\u043C\\u0443 \\u0438\\u043B\\u0438 \\u0434\\u0440\\u0443\\u0433\\u043E\\u043C\\u0443)\\n\\t// \\u0415\\u0441\\u043B\\u0438 \\u0432 \\u0441\\u043F\\u0438\\u0441\\u043A\\u0435 1 \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442, \\u0442\\u043E \\u043E\\u043D \\u043D\\u0435 \\u0443\\u043A\\u0430\\u0437\\u044B\\u0432\\u0430\\u0435\\u0442 \\u0441\\u0430\\u043C \\u043D\\u0430 \\u0441\\u0435\\u0431\\u044F = None\\n\\tleft1 := node1.left\\n\\tleft2 := node2.left\\n\\n\\t// \\u0412 \\u0438\\u0441\\u0445\\u043E\\u0434\\u043D\\u043E\\u0439 \\u043A\\u0443\\u0447\\u0435 1 \\u043A\\u043E\\u0440\\u043D\\u0435\\u0432\\u043E\\u0439 \\u0443\\u0437\\u0435\\u043B\\n\\tif left1 == nil {\\n\\t\\tif left2 != nil {\\n\\t\\t\\t// \\u041F\\u043E \\u043B\\u0435\\u0432\\u043E\\u043C\\u0443 \\u0443\\u0437\\u043B\\u0443 \\u0432\\u0442\\u043E\\u0440\\u043E\\u0439 \\u043A\\u0443\\u0447\\u0438\\n\\t\\t\\t//      node1\\n\\t\\t\\t//   |        |\\n\\t\\t\\t// left2 <-x node2\\n\\t\\t\\tnode1.left = left2\\n\\t\\t\\tnode1.right = node2\\n\\t\\t\\tleft2.right = node1\\n\\t\\t\\tnode2.left = node1\\n\\t\\t} else {\\n\\t\\t\\t// \\u0412 \\u043E\\u0431\\u0435\\u0438\\u0445 \\u043A\\u0443\\u0447\\u0430\\u0445 1 \\u043A\\u043E\\u0440\\u043D\\u0435\\u0432\\u043E\\u0439 \\u0443\\u0437\\u0435\\u043B\\n\\t\\t\\t// node1\\n\\t\\t\\t//   |\\n\\t\\t\\t// node2\\n\\t\\t\\tnode1.left = node2\\n\\t\\t\\tnode1.right = node2\\n\\t\\t\\tnode2.left = node1\\n\\t\\t\\tnode2.right = node1\\n\\t\\t}\\n\\t} else {\\n\\t\\t// \\u0421\\u043A\\u043B\\u0435\\u0438\\u0432\\u0430\\u0435\\u043C \\u0447\\u0435\\u0440\\u0435\\u0437 \\u043B\\u0435\\u0432\\u044B\\u0439 \\u043A\\u043E\\u0440\\u043D\\u0435\\u0432\\u043E\\u0439 \\u0443\\u0437\\u0435\\u043B \\u0432\\u0442\\u043E\\u0440\\u043E\\u0439 \\u043A\\u0443\\u0447\\u0438\\n\\t\\tif left2 != nil {\\n\\t\\t\\t// left1 <-x node1\\n\\t\\t\\t//        X\\n\\t\\t\\t// left2 <-x node2\\n\\t\\t\\t// \\u043D\\u0430\\u0438\\u0441\\u043A\\u043E\\u0441\\u043E\\u043A\\n\\t\\t\\tleft1.right = node2\\n\\t\\t\\tnode1.left = left2\\n\\t\\t\\tleft2.right = node1\\n\\t\\t\\tnode2.left = left1\\n\\t\\t\\t// \\u0412\\u043E \\u0432\\u0442\\u043E\\u0440\\u043E\\u0439 \\u043A\\u0443\\u0447\\u0435 1 \\u043A\\u043E\\u0440\\u043D\\u0435\\u0432\\u043E\\u0439 \\u0443\\u0437\\u0435\\u043B\\n\\t\\t} else {\\n\\t\\t\\t// left1 <-x node1\\n\\t\\t\\t//   |        |\\n\\t\\t\\t//      node2\\n\\t\\t\\tnode2.left = left1\\n\\t\\t\\tnode2.right = node1\\n\\t\\t\\tleft1.right = node2\\n\\t\\t\\tnode1.left = node2\\n\\t\\t}\\n\\t}\\n\\t// \\u0415\\u0441\\u043B\\u0438 \\u043D\\u0443\\u0436\\u043D\\u043E, \\u043E\\u0431\\u043D\\u043E\\u0432\\u043B\\u044F\\u0435\\u043C \\u043C\\u0438\\u043D\\u0438\\u043C\\u0443\\u043C\\n\\tthis._update_min(node2)\\n}\\n\\nfunc (this *FibonacciHeap) delete_min() *Node {\\n\\t/*\\n\\t   \\u0418\\u0437\\u0432\\u043B\\u0435\\u0447\\u0435\\u043D\\u0438\\u0435 \\u043C\\u0438\\u043D\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u043E\\u0433\\u043E \\u0443\\u0437\\u043B\\u0430.\\n\\n\\t   \\tx\\n\\t   \\t/ | \\\\\\n\\t   c1 c2 c3\\n\\t   \\u0410\\u043C\\u043E\\u0440\\u0442\\u0438\\u0437\\u0438\\u0440\\u043E\\u0432\\u0430\\u043D\\u043D\\u043E\\u0435 \\u0432\\u0440\\u0435\\u043C\\u044F \\u0440\\u0430\\u0431\\u043E\\u0442\\u044B: O(log n)\\n\\t*/\\n\\troot := this.find_min()\\n\\tif root == nil {\\n\\t\\t// raise ValueError(\"\\u041A\\u0443\\u0447\\u0430 \\u043F\\u0443\\u0441\\u0442\\u0430\")\\n\\t\\treturn nil\\n\\t}\\n\\t// \\u0423\\u0441\\u0442\\u0430\\u043D\\u0430\\u0432\\u043B\\u0438\\u0432\\u0430\\u0435\\u043C \\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u043E \\u043C\\u0438\\u043D\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u044B\\u0439 \\u0443\\u0437\\u0435\\u043B \\u043D\\u0430 \\u043B\\u0435\\u0432\\u044B\\u0439\\n\\tthis._set_min(root.left)\\n\\t// \\u0423\\u0434\\u0430\\u043B\\u044F\\u0435\\u043C \\u0438\\u0437 \\u0441\\u043F\\u0438\\u0441\\u043A\\u0430 \\u043C\\u0438\\u043D\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u044B\\u0439 \\u0443\\u0437\\u0435\\u043B\\n\\tthis._unlink(root)\\n\\t// \\u0421\\u043E\\u0437\\u0434\\u0430\\u0435\\u043C \\u043D\\u043E\\u0432\\u0443\\u044E \\u043A\\u0443\\u0447\\u0443 \\u0438\\u0437 \\u043F\\u043E\\u0442\\u043E\\u043C\\u043A\\u043E\\u0432 root (\\u0443 \\u043D\\u0438\\u0445 \\u043F\\u0440\\u0435\\u0436\\u043D\\u0438\\u0439 parent)\\n\\th := ConstructHeap(root.child)\\n\\tthis.meld(h)\\n\\tthis._consolidate()\\n\\troot._extract()\\n\\troot.child = nil\\n\\treturn root\\n}\\n\\nfunc (this *FibonacciHeap) _unlink(node *Node) *Node {\\n\\t/*\\n\\t   \\u0418\\u0437\\u0432\\u043B\\u0435\\u0447\\u0435\\u043D\\u0438\\u0435 \\u0443\\u0437\\u043B\\u0430 \\u0438\\u0437 \\u0434\\u0432\\u0443\\u0445\\u0441\\u0432\\u044F\\u0437\\u043D\\u043E\\u0433\\u043E \\u0441\\u043F\\u0438\\u0441\\u043A\\u0430.\\n\\n\\t   \\u0412\\u043E\\u0437\\u0432\\u0440\\u0430\\u0449\\u0430\\u0435\\u0442 \\u043B\\u0435\\u0432\\u044B\\u0439 \\u0443\\u0437\\u0435\\u043B \\u0438\\u0437 \\u043E\\u0441\\u0442\\u0430\\u0432\\u0448\\u0438\\u0445\\u0441\\u044F \\u0432 \\u0441\\u043F\\u0438\\u0441\\u043A\\u0435, \\u043B\\u0438\\u0431\\u043E None\\n\\t   left - node - right = left - right\\n\\t   \\u0412\\u0440\\u0435\\u043C\\u044F \\u0440\\u0430\\u0431\\u043E\\u0442\\u044B: O(1)\\n\\t*/\\n\\tleft := node.left\\n\\tright := node.right\\n\\n\\t// \\u0412 \\u0441\\u043F\\u0438\\u0441\\u043A\\u0435 1 \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442 - \\u0443\\u0434\\u0430\\u043B\\u044F\\u0435\\u043C\\u044B\\u0439\\n\\tif left == nil {\\n\\t\\treturn nil\\n\\t}\\n\\n\\tif left == right {\\n\\t\\t// \\u0412 \\u0441\\u043F\\u0438\\u0441\\u043A\\u0435 \\u0431\\u044B\\u043B\\u043E 2 \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u0430\\n\\t\\tleft.left = nil\\n\\t\\tleft.right = nil\\n\\t} else {\\n\\t\\tleft.right = right\\n\\t\\tright.left = left\\n\\t}\\n\\n\\treturn left\\n}\\n\\nfunc (this *FibonacciHeap) _consolidate() {\\n\\t/*\\n\\t   \\u0423\\u043F\\u043B\\u043E\\u0442\\u043D\\u0435\\u043D\\u0438\\u0435 \\u0441\\u043F\\u0438\\u0441\\u043A\\u0430 \\u043A\\u043E\\u0440\\u043D\\u0435\\u0439 - \\u0441\\u043A\\u043B\\u0435\\u0438\\u0432\\u0430\\u043D\\u0438\\u0435 \\u0434\\u0435\\u0440\\u0435\\u0432\\u044C\\u0435\\u0432 \\u0441 \\u043E\\u0434\\u0438\\u043D\\u0430\\u043A\\u043E\\u0432\\u044B\\u043C \\u0440\\u0430\\u043D\\u0433\\u043E\\u043C.\\n\\n\\t   \\u041E\\u0431\\u043D\\u043E\\u0432\\u043B\\u044F\\u0435\\u0442 \\u043C\\u0438\\u043D\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u044B\\u0439 \\u0443\\u0437\\u0435\\u043B\\n\\t   \\u0438 \\u0443\\u0441\\u0442\\u0430\\u043D\\u0430\\u0432\\u043B\\u0438\\u0432\\u0430\\u0435\\u0442 parent=None \\u0434\\u043B\\u044F \\u0432\\u0441\\u0435\\u0445 \\u043A\\u043E\\u0440\\u043D\\u0435\\u0432\\u044B\\u0445 \\u0443\\u0437\\u043B\\u043E\\u0432\\n\\t   \\u0412\\u0440\\u0435\\u043C\\u044F \\u0440\\u0430\\u0431\\u043E\\u0442\\u044B: O(log n)\\n\\t*/\\n\\t// \\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u044B\\u0439 \\u043C\\u0438\\u043D\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u044B\\u0439 \\u0443\\u0437\\u0435\\u043B\\n\\troot := this.find_min()\\n\\tif root == nil {\\n\\t\\treturn\\n\\t}\\n\\n\\t// \\u0421\\u043B\\u043E\\u0432\\u0430\\u0440\\u044C \\u043A\\u043E\\u0440\\u043D\\u0435\\u0432\\u044B\\u0445 \\u0443\\u0437\\u043B\\u043E\\u0432 \\u0432\\u0438\\u0434\\u0430 \\u0440\\u0430\\u043D\\u0433 -> \\u0443\\u0437\\u0435\\u043B\\n\\tranked := map[int]*Node{}\\n\\tranked[root.rank] = root\\n\\troot.parent = nil\\n\\tnode := root.right\\n\\n\\tfor {\\n\\t\\tif node == nil {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\t// \\u0423 \\u043A\\u043E\\u0440\\u043D\\u044F \\u043D\\u0435\\u0442 \\u043F\\u0440\\u0435\\u0434\\u043A\\u043E\\u0432\\n\\t\\tnode.parent = nil\\n\\t\\t// \\u0422\\u0435\\u043A\\u0443\\u0449\\u0438\\u0439 \\u0443\\u0437\\u0435\\u043B\\n\\t\\tmelded := node\\n\\t\\t// \\u0421\\u043B\\u0435\\u0434\\u0443\\u044E\\u0449\\u0438\\u0439 \\u043F\\u0440\\u043E\\u0441\\u043C\\u0430\\u0442\\u0440\\u0438\\u0432\\u0430\\u0435\\u043C\\u044B\\u0439 \\u0443\\u0437\\u0435\\u043B\\n\\t\\tnode = node.right\\n\\t\\tv, ok := ranked[node.rank]\\n\\t\\tif ok && v == node {\\n\\t\\t\\t// \\u041C\\u044B \\u0442\\u0430\\u043C \\u0443\\u0436\\u0435 \\u0431\\u044B\\u043B\\u0438, \\u043F\\u043E\\u044D\\u0442\\u043E\\u043C\\u0443 \\u044D\\u0442\\u0430 \\u0438\\u0442\\u0435\\u0440\\u0430\\u0446\\u0438\\u044F \\u043F\\u043E\\u0441\\u043B\\u0435\\u0434\\u043D\\u044F\\u044F\\n\\t\\t\\tnode = nil\\n\\t\\t}\\n\\n\\t\\tfor {\\n\\t\\t\\t// \\u0412 \\u0441\\u043F\\u0438\\u0441\\u043A\\u0435 \\u043A\\u043E\\u0440\\u043D\\u0435\\u0439 \\u0435\\u0441\\u0442\\u044C \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E \\u0441 \\u0442\\u0430\\u043A\\u0438\\u043C \\u0436\\u0435 \\u0440\\u0430\\u043D\\u0433\\u043E\\u043C.\\n\\t\\t\\trank := melded.rank\\n\\n\\t\\t\\tv, ok := ranked[rank]\\n\\t\\t\\tif !ok {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t\\t// \\u0421\\u043A\\u043B\\u0435\\u0438\\u0432\\u0430\\u0435\\u043C\\n\\t\\t\\tmelded = this._link(melded, v)\\n\\t\\t\\t// \\u0438 \\u0443\\u0434\\u0430\\u043B\\u044F\\u0435\\u043C \\u0438\\u0437 \\u0441\\u043B\\u043E\\u0432\\u0430\\u0440\\u044F \\u043F\\u0440\\u0435\\u0436\\u043D\\u0438\\u0439 \\u0440\\u0430\\u043D\\u0433\\n\\t\\t\\tdelete(ranked, rank)\\n\\t\\t}\\n\\t\\t// \\u043E\\u0431\\u043D\\u043E\\u0432\\u043B\\u044F\\u0435\\u043C \\u0441 \\u043D\\u043E\\u0432\\u044B\\u043C \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435\\u043C \\u0440\\u0430\\u043D\\u0433\\u0430 \\u043F\\u043E\\u043B\\u0443\\u0447\\u0438\\u0432\\u0448\\u0435\\u0435\\u0441\\u044F \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E\\n\\t\\tranked[melded.rank] = melded\\n\\t\\t// \\u041E\\u0431\\u043D\\u043E\\u0432\\u043B\\u044F\\u0435\\u043C \\u043C\\u0438\\u043D\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u044B\\u0439 \\u0443\\u0437\\u0435\\u043B\\n\\t\\tthis._update_min(melded)\\n\\t}\\n}\\n\\nfunc (this *FibonacciHeap) _link(node1 *Node, node2 *Node) *Node {\\n\\t/*\\n\\t   \\u0421\\u043A\\u043B\\u0435\\u0438\\u0432\\u0430\\u043D\\u0438\\u0435 \\u0434\\u0432\\u0443\\u0445 \\u043A\\u043E\\u0440\\u043D\\u0435\\u0439.\\n\\n\\t   \\u041A\\u043E\\u0440\\u043D\\u0435\\u043C \\u0441\\u0442\\u0430\\u043D\\u043E\\u0432\\u0438\\u0442\\u0441\\u044F \\u0443\\u0437\\u0435\\u043B \\u0441 \\u043C\\u0435\\u043D\\u044C\\u0448\\u0438\\u043C \\u043A\\u043B\\u044E\\u0447\\u043E\\u043C, \\u0432\\u0442\\u043E\\u0440\\u043E\\u0439 - \\u0435\\u0433\\u043E \\u043F\\u043E\\u0442\\u043E\\u043C\\u043A\\u043E\\u043C\\n\\t   \\u0412\\u043E\\u0437\\u0432\\u0440\\u0430\\u0449\\u0430\\u0435\\u0442 \\u043F\\u043E\\u043B\\u0443\\u0447\\u0438\\u0432\\u0448\\u0438\\u0439\\u0441\\u044F \\u043A\\u043E\\u0440\\u0435\\u043D\\u044C\\n\\t   \\u0412\\u0440\\u0435\\u043C\\u044F \\u0440\\u0430\\u0431\\u043E\\u0442\\u044B: O(1)\\n\\t*/\\n\\tif node1.key > node2.key {\\n\\t\\tnode1, node2 = node2, node1\\n\\t}\\n\\t// node1              node1\\n\\t//   |    ->            |\\n\\t// child      node2 - child\\n\\n\\t// node2 \\u0438\\u0437\\u0432\\u043B\\u0435\\u043A\\u0430\\u0435\\u0442\\u0441\\u044F \\u0438\\u0437 \\u0441\\u043F\\u0438\\u0441\\u043A\\u0430 \\u043A\\u043E\\u0440\\u043D\\u0435\\u0439\\n\\tthis._unlink(node2)\\n\\tnode2._extract()\\n\\t// \\u0443\\u0431\\u0438\\u0440\\u0430\\u0435\\u0442\\u0441\\u044F \\u043E\\u0442\\u043C\\u0435\\u0442\\u043A\\u0430\\n\\tnode2.marked = false\\n\\t// \\u0438 \\u043E\\u043D \\u0441\\u0442\\u0430\\u043D\\u043E\\u0432\\u0438\\u0442\\u0441\\u044F \\u043F\\u043E\\u0442\\u043E\\u043C\\u043A\\u043E\\u043C node1\\n\\tnode2.parent = node1\\n\\t// \\u041E\\u0431\\u043D\\u043E\\u0432\\u043B\\u044F\\u0435\\u043C \\u0440\\u0430\\u043D\\u0433 \\u043F\\u043E\\u043B\\u0443\\u0447\\u0438\\u0432\\u0448\\u0435\\u0433\\u043E\\u0441\\u044F \\u0434\\u0435\\u0440\\u0435\\u0432\\u0430\\n\\tnode1.rank += 1\\n\\n\\t// \\u041F\\u043E\\u0442\\u043E\\u043C\\u043E\\u043A \\u043F\\u0435\\u0440\\u0432\\u043E\\u0433\\u043E \\u043A\\u043E\\u0440\\u043D\\u044F\\n\\tchild := node1.child\\n\\tif child == nil {\\n\\t\\t// \\u0415\\u0441\\u043B\\u0438 \\u043D\\u0435\\u0442 \\u043F\\u043E\\u0442\\u043E\\u043C\\u043A\\u043E\\u0432\\n\\t\\tnode1.child = node2\\n\\t} else {\\n\\t\\tleft := child.left\\n\\t\\tif left == nil {\\n\\t\\t\\t// \\u041E\\u0434\\u0438\\u043D \\u043F\\u043E\\u0442\\u043E\\u043C\\u043E\\u043A\\n\\t\\t\\t// child - node2\\n\\t\\t\\tchild.left = node2\\n\\t\\t\\tchild.right = node2\\n\\t\\t\\tnode2.left = child\\n\\t\\t\\tnode2.right = child\\n\\t\\t} else {\\n\\t\\t\\t// left <-x child\\n\\t\\t\\t//   |        |\\n\\t\\t\\t//      node2\\n\\t\\t\\tnode2.left = left\\n\\t\\t\\tnode2.right = child\\n\\t\\t\\tleft.right = node2\\n\\t\\t\\tchild.left = node2\\n\\t\\t}\\n\\t}\\n\\n\\treturn node1\\n}\\n\\nfunc (this *FibonacciHeap) decrease_key(node *Node, newkey int) {\\n\\t/*\\n\\t   \\u0423\\u043C\\u0435\\u043D\\u044C\\u0448\\u0435\\u043D\\u0438\\u0435 \\u043A\\u043B\\u044E\\u0447\\u0430 \\u0443\\u0437\\u043B\\u0430 node \\u0434\\u043E \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u044F newkey.\\n\\n\\t   \\u0412\\u0440\\u0435\\u043C\\u044F \\u0440\\u0430\\u0431\\u043E\\u0442\\u044B: O(1)\\n\\t*/\\n\\tnode.key = newkey\\n\\n\\tif node.parent == nil {\\n\\t\\t// \\u0423\\u0437\\u0435\\u043B - \\u043A\\u043E\\u0440\\u043D\\u0435\\u0432\\u043E\\u0439\\n\\t\\tthis._update_min(node)\\n\\t\\treturn\\n\\t}\\n\\n\\tparent := node.parent\\n\\tparent.rank -= 1\\n\\tparent.child = this._unlink(node)\\n\\tthis._cascading_cut(parent)\\n\\tnode._extract()\\n\\tthis.insert(node)\\n}\\n\\nfunc (this *FibonacciHeap) _cut(node *Node) {\\n\\t/*\\n\\t   \\u041F\\u043E\\u0434\\u0440\\u0435\\u0437\\u043A\\u0430 \\u0434\\u0435\\u0440\\u0435\\u0432\\u0430 - \\u043F\\u0435\\u0440\\u0435\\u043D\\u043E\\u0441 node \\u0432 \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u043A\\u043E\\u0440\\u043D\\u0435\\u0439.\\n\\n\\t   \\u0412\\u0440\\u0435\\u043C\\u044F \\u0440\\u0430\\u0431\\u043E\\u0442\\u044B: O(1)\\n\\t*/\\n\\tparent := node.parent\\n\\tif parent == nil {\\n\\t\\t// \\u0423\\u0437\\u0435\\u043B \\u0443\\u0436\\u0435 \\u043A\\u043E\\u0440\\u043D\\u0435\\u0432\\u043E\\u0439\\n\\t\\treturn\\n\\t}\\n\\tparent.rank -= 1\\n\\tparent.child = this._unlink(node)\\n\\tnode._extract()\\n\\tthis.insert(node)\\n}\\n\\nfunc (this *FibonacciHeap) _cascading_cut(node *Node) {\\n\\t/*\\n\\t   \\u041A\\u0430\\u0441\\u043A\\u0430\\u0434\\u043D\\u0430\\u044F \\u043F\\u043E\\u0434\\u0440\\u0435\\u0437\\u043A\\u0430 \\u0434\\u0435\\u0440\\u0435\\u0432\\u0430.\\n\\n\\t   \\u041D\\u0430\\u0447\\u0438\\u043D\\u0430\\u044F \\u043E\\u0442 \\u0443\\u0437\\u043B\\u0430 node, \\u0438 \\u043F\\u043E\\u043A\\u0430 \\u043F\\u0440\\u0435\\u0434\\u0448\\u0435\\u0441\\u0442\\u0432\\u0443\\u044E\\u0449\\u0438\\u0439 \\u0443\\u0437\\u0435\\u043B \\u0438\\u043C\\u0435\\u0435\\u0442 \\u043E\\u0442\\u043C\\u0435\\u0442\\u043A\\u0443\\n\\t   \\u043E \\u043F\\u0435\\u0440\\u0435\\u043C\\u0435\\u0449\\u0435\\u043D\\u0438\\u0438 (marked = True), \\u0432\\u0441\\u0435 \\u043E\\u043D\\u0438 \\u0441\\u0442\\u0430\\u043D\\u043E\\u0432\\u044F\\u0442\\u0441\\u044F \\u043A\\u043E\\u0440\\u043D\\u0435\\u0432\\u044B\\u043C\\u0438.\\n\\n\\t   \\u0412\\u0440\\u0435\\u043C\\u044F \\u0440\\u0430\\u0431\\u043E\\u0442\\u044B: O(log n)\\n\\t*/\\n\\tparent := node\\n\\tfor {\\n\\t\\tif parent == nil {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tif !parent.marked {\\n\\t\\t\\tparent.marked = true\\n\\t\\t\\treturn\\n\\t\\t} else {\\n\\t\\t\\tnode = parent\\n\\t\\t\\tparent = node.parent\\n\\t\\t\\tthis._cut(node)\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc (this *FibonacciHeap) remove(node *Node) *Node {\\n\\t/*\\n\\t   \\u0423\\u0434\\u0430\\u043B\\u0435\\u043D\\u0438\\u0435 \\u0443\\u0437\\u043B\\u0430 node.\\n\\n\\t   \\u0410\\u043C\\u043E\\u0440\\u0442\\u0438\\u0437\\u0438\\u0440\\u043E\\u0432\\u0430\\u043D\\u043D\\u043E\\u0435 \\u0432\\u0440\\u0435\\u043C\\u044F \\u0440\\u0430\\u0431\\u043E\\u0442\\u044B: O(log n)\\n\\t*/\\n\\tif node == this.find_min() {\\n\\t\\t// \\u0423\\u0437\\u0435\\u043B - \\u043C\\u0438\\u043D\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u044B\\u0439\\n\\t\\treturn this.delete_min()\\n\\t}\\n\\n\\tparent := node.parent\\n\\tif parent == nil {\\n\\t\\t// \\u0423\\u0437\\u0435\\u043B - \\u043A\\u043E\\u0440\\u043D\\u0435\\u0432\\u043E\\u0439\\n\\t\\tthis._unlink(node)\\n\\t} else {\\n\\t\\tparent.rank -= 1\\n\\t\\tparent.child = this._unlink(node)\\n\\t\\tthis._cascading_cut(parent)\\n\\t}\\n\\n\\th := ConstructHeap(node.child)\\n\\tthis.meld(h)\\n\\tthis._consolidate()\\n\\tnode._extract()\\n\\tnode.child = nil\\n\\treturn node\\n}\\n\\n\\n\\ntype AuthenticationManager struct {\\n    fh *FibonacciHeap\\n    timeToLive int\\n    nodes map[string]*Node\\n}\\n\\n\\nfunc Constructor(timeToLive int) AuthenticationManager {\\n    this := AuthenticationManager{\\n        fh: ConstructHeap(nil),\\n        timeToLive: timeToLive,\\n        nodes: map[string]*Node{},\\n    }\\n    return this\\n}\\n\\n\\nfunc (this *AuthenticationManager) Generate(tokenId string, currentTime int)  {\\n    expired := currentTime + this.timeToLive\\n    node := ConstructNode(tokenId, expired)\\n    this.nodes[tokenId] = &node\\n    this.fh.insert(&node)\\n}\\n\\n\\nfunc (this *AuthenticationManager) Renew(tokenId string, currentTime int)  {\\n    node, ok := this.nodes[tokenId]\\n    if !ok {\\n        return\\n    }\\n    this.fh.remove(node)\\n    if node.key <= currentTime {\\n        delete(this.nodes, tokenId)\\n        return\\n    }\\n    expired := currentTime + this.timeToLive\\n    node.key = expired\\n    this.fh.insert(node)        \\n    \\n}\\n\\n\\nfunc (this *AuthenticationManager) CountUnexpiredTokens(currentTime int) int {\\n    for {\\n        node := this.fh.find_min()\\n        if node == nil {\\n            break\\n        }\\n        if node.key <= currentTime {\\n            this.fh.delete_min()\\n            delete(this.nodes, node.x)\\n        } else {\\n            break\\n        }\\n    }\\n    return len(this.nodes)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1899593,
                "title": "solution-swift-design-authentication-manager",
                "content": "```swift\\nclass AuthenticationManager {\\n    \\n    private struct Token {\\n        let id: String\\n        let time: Int\\n    }\\n    \\n    private let timeToLive:Int\\n    private var tokens: [Token] = []\\n    private var unexpTokens: [String:Int] = [:]\\n    \\n    init(_ timeToLive: Int) {\\n        self.timeToLive = timeToLive\\n    }\\n    \\n    func generate(_ id: String, _ ct: Int) {\\n        cleanTokens(ct)\\n        insert(Token(id: id, time: ct + timeToLive))\\n    }\\n    \\n    func renew(_ id: String, _ ct: Int) {\\n        cleanTokens(ct)\\n        guard let tm = unexpTokens[id] else { return }\\n        if let idx = binarySearch(Token(id: id, time: tm)) {\\n            tokens.remove(at: idx)\\n            insert(Token(id: id, time: ct + timeToLive))\\n        }\\n    }\\n    \\n    func countUnexpiredTokens(_ ct: Int) -> Int {\\n        cleanTokens(ct)\\n        return tokens.count\\n    }\\n    \\n    \\n    private func insert(_ tk: Token) {\\n        unexpTokens[tk.id] = tk.time\\n        guard !tokens.isEmpty else {\\n            tokens.append(tk)\\n            return\\n        }\\n        if let idx = binarySearch(tk) {\\n            if idx == tokens.count {\\n                tokens.append(tk)\\n            } else {\\n                tokens.insert(tk, at: idx)\\n            }\\n        }\\n    }\\n    private func binarySearch(_ tk: Token) -> Int? {\\n        guard !tokens.isEmpty else { return nil }\\n        guard tokens[0].time <= tk.time else { return 0 }\\n        guard tokens.last!.time >= tk.time else { return tokens.count }\\n        var lhs = 0, rhs = tokens.count - 1\\n        while lhs < rhs {\\n            let mid = (lhs + rhs) >> 1\\n            if tokens[mid].time >= tk.time {\\n                rhs = mid\\n            } else {\\n                lhs = mid + 1\\n            }\\n        }\\n        return lhs\\n    }\\n    \\n    private func cleanTokens(_ tm: Int) {\\n        while !tokens.isEmpty && tokens[0].time <= tm {\\n            unexpTokens.removeValue(forKey: tokens[0].id)\\n            tokens.removeFirst()\\n        }\\n    }\\n}\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * let obj = AuthenticationManager(timeToLive)\\n * obj.generate(tokenId, currentTime)\\n * obj.renew(tokenId, currentTime)\\n * let ret_3: Int = obj.countUnexpiredTokens(currentTime)\\n*/\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass AuthenticationManager {\\n    \\n    private struct Token {\\n        let id: String\\n        let time: Int\\n    }\\n    \\n    private let timeToLive:Int\\n    private var tokens: [Token] = []\\n    private var unexpTokens: [String:Int] = [:]\\n    \\n    init(_ timeToLive: Int) {\\n        self.timeToLive = timeToLive\\n    }\\n    \\n    func generate(_ id: String, _ ct: Int) {\\n        cleanTokens(ct)\\n        insert(Token(id: id, time: ct + timeToLive))\\n    }\\n    \\n    func renew(_ id: String, _ ct: Int) {\\n        cleanTokens(ct)\\n        guard let tm = unexpTokens[id] else { return }\\n        if let idx = binarySearch(Token(id: id, time: tm)) {\\n            tokens.remove(at: idx)\\n            insert(Token(id: id, time: ct + timeToLive))\\n        }\\n    }\\n    \\n    func countUnexpiredTokens(_ ct: Int) -> Int {\\n        cleanTokens(ct)\\n        return tokens.count\\n    }\\n    \\n    \\n    private func insert(_ tk: Token) {\\n        unexpTokens[tk.id] = tk.time\\n        guard !tokens.isEmpty else {\\n            tokens.append(tk)\\n            return\\n        }\\n        if let idx = binarySearch(tk) {\\n            if idx == tokens.count {\\n                tokens.append(tk)\\n            } else {\\n                tokens.insert(tk, at: idx)\\n            }\\n        }\\n    }\\n    private func binarySearch(_ tk: Token) -> Int? {\\n        guard !tokens.isEmpty else { return nil }\\n        guard tokens[0].time <= tk.time else { return 0 }\\n        guard tokens.last!.time >= tk.time else { return tokens.count }\\n        var lhs = 0, rhs = tokens.count - 1\\n        while lhs < rhs {\\n            let mid = (lhs + rhs) >> 1\\n            if tokens[mid].time >= tk.time {\\n                rhs = mid\\n            } else {\\n                lhs = mid + 1\\n            }\\n        }\\n        return lhs\\n    }\\n    \\n    private func cleanTokens(_ tm: Int) {\\n        while !tokens.isEmpty && tokens[0].time <= tm {\\n            unexpTokens.removeValue(forKey: tokens[0].id)\\n            tokens.removeFirst()\\n        }\\n    }\\n}\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * let obj = AuthenticationManager(timeToLive)\\n * obj.generate(tokenId, currentTime)\\n * obj.renew(tokenId, currentTime)\\n * let ret_3: Int = obj.countUnexpiredTokens(currentTime)\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1896120,
                "title": "java-timemap-and-authmap-using-treemap",
                "content": "```\\nclass AuthenticationManager {\\n    int ttl;\\n    TreeMap<String,Integer>authMap;\\n    TreeMap<Integer,String>timeMap;\\n    public AuthenticationManager(int timeToLive) {\\n        ttl=timeToLive;\\n        authMap=new TreeMap<>();\\n        timeMap=new TreeMap<>();\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        authMap.put(tokenId,currentTime);\\n        timeMap.put(currentTime,tokenId);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        if(!authMap.containsKey(tokenId))return;\\n        int time=authMap.get(tokenId);\\n        if(time+ttl > currentTime){\\n            timeMap.remove(time);\\n            authMap.put(tokenId,currentTime);\\n            timeMap.put(currentTime,tokenId);\\n        }\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        return timeMap.subMap(currentTime-ttl+1,currentTime).size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass AuthenticationManager {\\n    int ttl;\\n    TreeMap<String,Integer>authMap;\\n    TreeMap<Integer,String>timeMap;\\n    public AuthenticationManager(int timeToLive) {\\n        ttl=timeToLive;\\n        authMap=new TreeMap<>();\\n        timeMap=new TreeMap<>();\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        authMap.put(tokenId,currentTime);\\n        timeMap.put(currentTime,tokenId);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        if(!authMap.containsKey(tokenId))return;\\n        int time=authMap.get(tokenId);\\n        if(time+ttl > currentTime){\\n            timeMap.remove(time);\\n            authMap.put(tokenId,currentTime);\\n            timeMap.put(currentTime,tokenId);\\n        }\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        return timeMap.subMap(currentTime-ttl+1,currentTime).size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1869905,
                "title": "design-authentication-manager-solution-java",
                "content": "class AuthenticationManager {\\n    int timeToLive;\\n    Map<String, Integer> map;\\n\\n    public AuthenticationManager(int timeToLive) {\\n        this.timeToLive = timeToLive;\\n        map = new HashMap<String, Integer>();\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        map.put(tokenId, currentTime + timeToLive);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        clearMap(currentTime);\\n        if (map.get(tokenId) != null)\\n            map.put(tokenId, currentTime + timeToLive);\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        clearMap(currentTime);\\n        return map.size();\\n    }\\n    \\n    public void clearMap(int currentTime) {\\n        Iterator it = map.entrySet().iterator();\\n        while (it.hasNext()) {\\n            Map.Entry entry = (Map.Entry)it.next();\\n            if ((int)entry.getValue() <= currentTime)\\n                it.remove();\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Design"
                ],
                "code": "class AuthenticationManager {\\n    int timeToLive;\\n    Map<String, Integer> map;\\n\\n    public AuthenticationManager(int timeToLive) {\\n        this.timeToLive = timeToLive;\\n        map = new HashMap<String, Integer>();\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        map.put(tokenId, currentTime + timeToLive);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        clearMap(currentTime);\\n        if (map.get(tokenId) != null)\\n            map.put(tokenId, currentTime + timeToLive);\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        clearMap(currentTime);\\n        return map.size();\\n    }\\n    \\n    public void clearMap(int currentTime) {\\n        Iterator it = map.entrySet().iterator();\\n        while (it.hasNext()) {\\n            Map.Entry entry = (Map.Entry)it.next();\\n            if ((int)entry.getValue() <= currentTime)\\n                it.remove();\\n        }\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1863248,
                "title": "java-clean-code",
                "content": "```\\nprivate final int timeToLive;\\n    private final Map<String, Integer> tokens;\\n\\n    public AuthenticationManager(int timeToLive) {\\n        this.timeToLive = timeToLive;\\n        this.tokens = new HashMap<>();\\n    }\\n\\n    public void generate(String tokenId, int currentTime) {\\n        tokens.put(tokenId, currentTime);\\n    }\\n\\n    public void renew(String tokenId, int currentTime) {\\n        if (!tokens.containsKey(tokenId)) return;\\n\\n        if (currentTime - tokens.get(tokenId) >= timeToLive) return;\\n        tokens.put(tokenId, currentTime);\\n    }\\n\\n    public int countUnexpiredTokens(int currentTime) {\\n        int counter = 0;\\n        for (int timeStart : tokens.values()) {\\n            if (currentTime - timeStart < timeToLive)\\n                counter++;\\n        }\\n\\n        return counter;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nprivate final int timeToLive;\\n    private final Map<String, Integer> tokens;\\n\\n    public AuthenticationManager(int timeToLive) {\\n        this.timeToLive = timeToLive;\\n        this.tokens = new HashMap<>();\\n    }\\n\\n    public void generate(String tokenId, int currentTime) {\\n        tokens.put(tokenId, currentTime);\\n    }\\n\\n    public void renew(String tokenId, int currentTime) {\\n        if (!tokens.containsKey(tokenId)) return;\\n\\n        if (currentTime - tokens.get(tokenId) >= timeToLive) return;\\n        tokens.put(tokenId, currentTime);\\n    }\\n\\n    public int countUnexpiredTokens(int currentTime) {\\n        int counter = 0;\\n        for (int timeStart : tokens.values()) {\\n            if (currentTime - timeStart < timeToLive)\\n                counter++;\\n        }\\n\\n        return counter;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1389539,
                "title": "java-solution",
                "content": "```\\nclass AuthenticationManager {\\n    private int timeToLive = 0;\\n    private Map<String, Integer> map = new HashMap<>();\\n\\n    public AuthenticationManager(int timeToLive) {\\n        this.timeToLive = timeToLive;\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        map.put(tokenId, currentTime + timeToLive);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        if (map.containsKey(tokenId) && map.get(tokenId) > currentTime)\\n              generate(tokenId, currentTime);\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        map.entrySet().removeIf(e-> e.getValue() <= currentTime);\\n        return map.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass AuthenticationManager {\\n    private int timeToLive = 0;\\n    private Map<String, Integer> map = new HashMap<>();\\n\\n    public AuthenticationManager(int timeToLive) {\\n        this.timeToLive = timeToLive;\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        map.put(tokenId, currentTime + timeToLive);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        if (map.containsKey(tokenId) && map.get(tokenId) > currentTime)\\n              generate(tokenId, currentTime);\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        map.entrySet().removeIf(e-> e.getValue() <= currentTime);\\n        return map.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1329642,
                "title": "c-single-map-solution",
                "content": "```\\nclass AuthenticationManager {\\npublic:\\n    int lifetime;\\n    unordered_map<string , int> id_time; \\n    //id , time it expires \\n    AuthenticationManager(int timeToLive) {\\n        lifetime = timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int curr) {\\n        id_time[tokenId] = curr + lifetime;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n\\t//first check if it is possible to renew\\n        if(id_time.find(tokenId) == id_time.end() || id_time[tokenId] <= currentTime) \\n            return;\\n        id_time[tokenId] = currentTime + lifetime;\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int ans = 0;\\n        for(auto m : id_time) {\\n            if(m.second > currentTime)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass AuthenticationManager {\\npublic:\\n    int lifetime;\\n    unordered_map<string , int> id_time; \\n    //id , time it expires \\n    AuthenticationManager(int timeToLive) {\\n        lifetime = timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int curr) {\\n        id_time[tokenId] = curr + lifetime;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n\\t//first check if it is possible to renew\\n        if(id_time.find(tokenId) == id_time.end() || id_time[tokenId] <= currentTime) \\n            return;\\n        id_time[tokenId] = currentTime + lifetime;\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int ans = 0;\\n        for(auto m : id_time) {\\n            if(m.second > currentTime)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1135480,
                "title": "my-java-solution-using-hashmap-straight-forward-approach",
                "content": "```\\nclass AuthenticationManager {\\n\\n    private Map<String, Integer> map;\\n    private int timeToLive;\\n    public AuthenticationManager(int timeToLive) {\\n        map = new HashMap<>();    \\n        this.timeToLive = timeToLive;\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        map.put(tokenId, timeToLive + currentTime);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        if (map.containsKey(tokenId) && map.get(tokenId) > currentTime) {\\n            map.put(tokenId, timeToLive + currentTime);\\n        }\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        map.entrySet().removeIf(x -> x.getValue() <= currentTime); // prevent ConcurrentModificationException\\n        return map.size();\\n    }\\n}\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager obj = new AuthenticationManager(timeToLive);\\n * obj.generate(tokenId,currentTime);\\n * obj.renew(tokenId,currentTime);\\n * int param_3 = obj.countUnexpiredTokens(currentTime);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Design"
                ],
                "code": "```\\nclass AuthenticationManager {\\n\\n    private Map<String, Integer> map;\\n    private int timeToLive;\\n    public AuthenticationManager(int timeToLive) {\\n        map = new HashMap<>();    \\n        this.timeToLive = timeToLive;\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        map.put(tokenId, timeToLive + currentTime);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        if (map.containsKey(tokenId) && map.get(tokenId) > currentTime) {\\n            map.put(tokenId, timeToLive + currentTime);\\n        }\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        map.entrySet().removeIf(x -> x.getValue() <= currentTime); // prevent ConcurrentModificationException\\n        return map.size();\\n    }\\n}\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager obj = new AuthenticationManager(timeToLive);\\n * obj.generate(tokenId,currentTime);\\n * obj.renew(tokenId,currentTime);\\n * int param_3 = obj.countUnexpiredTokens(currentTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1127288,
                "title": "python-using-linkedhashmap",
                "content": "```\\nclass AuthenticationManager:\\n\\n    def __init__(self, timeToLive: int):\\n        self.ttl = timeToLive\\n        self.cache = OrderedDict() #linkedHashmap using in LRU cache\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self.cache[tokenId] = currentTime + self.ttl\\n        \\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if tokenId not in self.cache:\\n            return\\n        expiryTime = self.cache[tokenId]\\n        if expiryTime > currentTime:\\n            self.cache[tokenId] = currentTime + self.ttl\\n            self.cache.move_to_end(tokenId)\\n        \\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        while self.cache and next(iter(self.cache.values())) <= currentTime:\\n            self.cache.popitem(last=False)\\n        return len(self.cache)\\n            \\n        \\n# Your AuthenticationManager object will be instantiated and called as such:\\n# obj = AuthenticationManager(timeToLive)\\n# obj.generate(tokenId,currentTime)\\n# obj.renew(tokenId,currentTime)\\n# param_3 = obj.countUnexpiredTokens(currentTime)\\n```",
                "solutionTags": [],
                "code": "```\\nclass AuthenticationManager:\\n\\n    def __init__(self, timeToLive: int):\\n        self.ttl = timeToLive\\n        self.cache = OrderedDict() #linkedHashmap using in LRU cache\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self.cache[tokenId] = currentTime + self.ttl\\n        \\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if tokenId not in self.cache:\\n            return\\n        expiryTime = self.cache[tokenId]\\n        if expiryTime > currentTime:\\n            self.cache[tokenId] = currentTime + self.ttl\\n            self.cache.move_to_end(tokenId)\\n        \\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        while self.cache and next(iter(self.cache.values())) <= currentTime:\\n            self.cache.popitem(last=False)\\n        return len(self.cache)\\n            \\n        \\n# Your AuthenticationManager object will be instantiated and called as such:\\n# obj = AuthenticationManager(timeToLive)\\n# obj.generate(tokenId,currentTime)\\n# obj.renew(tokenId,currentTime)\\n# param_3 = obj.countUnexpiredTokens(currentTime)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119611,
                "title": "java-simple-code-using-hashmap",
                "content": "```\\nclass AuthenticationManager {\\n    int time;\\n    HashMap<String,Integer> arr=new HashMap<String,Integer>();\\n    public AuthenticationManager(int timeToLive) {\\n        time=timeToLive;\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        arr.put(tokenId,currentTime+time);//put tokenId,expiryTime in map\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        if(arr.containsKey(tokenId))\\n        if(currentTime<arr.get(tokenId))\\n            arr.put(tokenId,currentTime+time);//update expiryTime\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        int k=0;\\n        for(int i:arr.values()){\\n            if(i>currentTime)\\n                k++;\\n        }\\n        return k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass AuthenticationManager {\\n    int time;\\n    HashMap<String,Integer> arr=new HashMap<String,Integer>();\\n    public AuthenticationManager(int timeToLive) {\\n        time=timeToLive;\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        arr.put(tokenId,currentTime+time);//put tokenId,expiryTime in map\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        if(arr.containsKey(tokenId))\\n        if(currentTime<arr.get(tokenId))\\n            arr.put(tokenId,currentTime+time);//update expiryTime\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        int k=0;\\n        for(int i:arr.values()){\\n            if(i>currentTime)\\n                k++;\\n        }\\n        return k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119563,
                "title": "c-simple-code-easy-to-understand-using-map",
                "content": "```\\nclass AuthenticationManager {\\npublic:\\n    int live;\\n    map<string,int>m;\\n    AuthenticationManager(int timeToLive) {\\n        live = timeToLive;\\n    }\\n    void generate(string t, int time) {\\n        m[t] = time;\\n    }\\n    void renew(string t, int time) {\\n        if(m.find(t) != m.end()){\\n            if(m[t]+live > time) m[t]=time;\\n        }\\n    }\\n    int countUnexpiredTokens(int time) {\\n        int cnt=0;\\n        for(auto it:m){\\n            if(it.second+live > time) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\nPlease upvote if you like the code",
                "solutionTags": [],
                "code": "```\\nclass AuthenticationManager {\\npublic:\\n    int live;\\n    map<string,int>m;\\n    AuthenticationManager(int timeToLive) {\\n        live = timeToLive;\\n    }\\n    void generate(string t, int time) {\\n        m[t] = time;\\n    }\\n    void renew(string t, int time) {\\n        if(m.find(t) != m.end()){\\n            if(m[t]+live > time) m[t]=time;\\n        }\\n    }\\n    int countUnexpiredTokens(int time) {\\n        int cnt=0;\\n        for(auto it:m){\\n            if(it.second+live > time) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119087,
                "title": "cpp-easy-solution-fast",
                "content": "```\\nclass AuthenticationManager {\\npublic:\\n    int t;\\n    map<string,int>m1;\\n    AuthenticationManager(int timeToLive) {\\n        t=timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        m1[tokenId]=currentTime+t;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if(m1[tokenId]!=0)\\n        {\\n            if(m1[tokenId]>currentTime)\\n            {\\n                m1[tokenId]=t+currentTime;\\n            }\\n        }\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int c=0;\\n        for(auto a:m1)\\n        {\\n            if(a.second>currentTime)\\n                c++;\\n        }\\n        return c;\\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass AuthenticationManager {\\npublic:\\n    int t;\\n    map<string,int>m1;\\n    AuthenticationManager(int timeToLive) {\\n        t=timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        m1[tokenId]=currentTime+t;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if(m1[tokenId]!=0)\\n        {\\n            if(m1[tokenId]>currentTime)\\n            {\\n                m1[tokenId]=t+currentTime;\\n            }\\n        }\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int c=0;\\n        for(auto a:m1)\\n        {\\n            if(a.second>currentTime)\\n                c++;\\n        }\\n        return c;\\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119036,
                "title": "java-solution-using-hashmap",
                "content": "Note: Make sure to remove the unnecessary tokens in the renew function and countUnexpiredTokens function to avoid TLE.\\n```\\nclass AuthenticationManager {\\n    Map<String, Integer> tokens=new HashMap<>();\\n    int timeToLive;\\n    public AuthenticationManager(int timeToLive) {\\n        this.timeToLive=timeToLive;\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        if(!tokens.containsKey(tokenId)){\\n            tokens.put(tokenId,currentTime+timeToLive);\\n        }\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        if(!tokens.containsKey(tokenId)){\\n            return;\\n        }\\n        if(tokens.get(tokenId)>currentTime){\\n            tokens.put(tokenId,currentTime+timeToLive);\\n        }else{\\n            tokens.remove(tokenId);\\n        }\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        int count=0;\\n        System.out.print(tokens.size()+\" \");\\n        for(Map.Entry entry: tokens.entrySet()){\\n            System.out.print(entry.getValue());\\n            if((int)(entry.getValue()) > currentTime){\\n                // System.out.print(\"test\");\\n                count++;\\n            }else{\\n                tokens.remove(entry);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass AuthenticationManager {\\n    Map<String, Integer> tokens=new HashMap<>();\\n    int timeToLive;\\n    public AuthenticationManager(int timeToLive) {\\n        this.timeToLive=timeToLive;\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        if(!tokens.containsKey(tokenId)){\\n            tokens.put(tokenId,currentTime+timeToLive);\\n        }\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        if(!tokens.containsKey(tokenId)){\\n            return;\\n        }\\n        if(tokens.get(tokenId)>currentTime){\\n            tokens.put(tokenId,currentTime+timeToLive);\\n        }else{\\n            tokens.remove(tokenId);\\n        }\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        int count=0;\\n        System.out.print(tokens.size()+\" \");\\n        for(Map.Entry entry: tokens.entrySet()){\\n            System.out.print(entry.getValue());\\n            if((int)(entry.getValue()) > currentTime){\\n                // System.out.print(\"test\");\\n                count++;\\n            }else{\\n                tokens.remove(entry);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1118826,
                "title": "unordered-map-solution-c",
                "content": "```\\nclass AuthenticationManager {\\npublic:\\n    unordered_map<string, int> map;\\n    int expired, tol;\\n    AuthenticationManager(int timeToLive) {\\n        this->tol = timeToLive;\\n        expired = 0;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        map[tokenId] = currentTime + this->tol;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        auto itr = map.find(tokenId);\\n        if (itr != map.end() && map[tokenId] > currentTime) {\\n            generate(tokenId, currentTime);\\n        }\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        expired = 0;\\n        for (auto itr = map.begin(); itr != map.end(); itr++ ) {\\n            if (itr->second > currentTime) {\\n                expired++;\\n            }\\n        }\\n        return expired;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass AuthenticationManager {\\npublic:\\n    unordered_map<string, int> map;\\n    int expired, tol;\\n    AuthenticationManager(int timeToLive) {\\n        this->tol = timeToLive;\\n        expired = 0;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        map[tokenId] = currentTime + this->tol;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        auto itr = map.find(tokenId);\\n        if (itr != map.end() && map[tokenId] > currentTime) {\\n            generate(tokenId, currentTime);\\n        }\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        expired = 0;\\n        for (auto itr = map.begin(); itr != map.end(); itr++ ) {\\n            if (itr->second > currentTime) {\\n                expired++;\\n            }\\n        }\\n        return expired;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1118810,
                "title": "python3-dict-hashmap",
                "content": "```python\\nclass AuthenticationManager:\\n\\n    def __init__(self, timeToLive: int):\\n        self.timeToLive = timeToLive\\n        self.tokens = dict()\\n        \\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self.tokens[tokenId] = currentTime + self.timeToLive\\n        \\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if tokenId in self.tokens:\\n            token_time = self.tokens[tokenId]\\n            if token_time > currentTime:\\n                self.tokens[tokenId] = currentTime + self.timeToLive\\n            else:\\n                del self.tokens[tokenId]\\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        count = 0\\n        for tokenId, token_time in self.tokens.copy().items():\\n            if token_time <= currentTime:\\n                del self.tokens[tokenId]\\n            else:\\n                count += 1\\n\\n        return count\\n```",
                "solutionTags": [],
                "code": "```python\\nclass AuthenticationManager:\\n\\n    def __init__(self, timeToLive: int):\\n        self.timeToLive = timeToLive\\n        self.tokens = dict()\\n        \\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self.tokens[tokenId] = currentTime + self.timeToLive\\n        \\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if tokenId in self.tokens:\\n            token_time = self.tokens[tokenId]\\n            if token_time > currentTime:\\n                self.tokens[tokenId] = currentTime + self.timeToLive\\n            else:\\n                del self.tokens[tokenId]\\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        count = 0\\n        for tokenId, token_time in self.tokens.copy().items():\\n            if token_time <= currentTime:\\n                del self.tokens[tokenId]\\n            else:\\n                count += 1\\n\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1118754,
                "title": "c-2-maps-time-name",
                "content": "```\\nclass AuthenticationManager {\\n    int K; // time-to-live\\n    using Set = unordered_set<string>;\\n    using TimeMap = map<int, Set>;\\n    using NameMap = unordered_map<string, int>;\\n    TimeMap timeMap;\\n    NameMap nameMap;\\n    void processExpiry(int t) {\\n        auto last = timeMap.upper_bound(t); // < t\\n        for (auto it = timeMap.begin(); it != last; ++it) {\\n            auto [_, ids] = tie(it->first, it->second);\\n            for (auto& id: ids)\\n                nameMap.erase(id);\\n        }\\n        timeMap.erase(timeMap.begin(), last);\\n    }\\npublic:\\n    AuthenticationManager(int K) : K{ K } {\\n    }\\n    void generate(string id, int t) {\\n        timeMap[t + K].insert(id);\\n        nameMap[id] = t + K;\\n    }\\n    void renew(string id, int t) {\\n        processExpiry(t);\\n        if (nameMap.find(id) == nameMap.end()) // has it expired?\\n            return;\\n        auto last = nameMap[id];\\n        auto it = timeMap.lower_bound(last);\\n        auto [_, ids] = tie(it->first, it->second);\\n        ids.erase(id);\\n        generate(id, t);\\n    }\\n    int countUnexpiredTokens(int t) {\\n        processExpiry(t);\\n        return nameMap.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass AuthenticationManager {\\n    int K; // time-to-live\\n    using Set = unordered_set<string>;\\n    using TimeMap = map<int, Set>;\\n    using NameMap = unordered_map<string, int>;\\n    TimeMap timeMap;\\n    NameMap nameMap;\\n    void processExpiry(int t) {\\n        auto last = timeMap.upper_bound(t); // < t\\n        for (auto it = timeMap.begin(); it != last; ++it) {\\n            auto [_, ids] = tie(it->first, it->second);\\n            for (auto& id: ids)\\n                nameMap.erase(id);\\n        }\\n        timeMap.erase(timeMap.begin(), last);\\n    }\\npublic:\\n    AuthenticationManager(int K) : K{ K } {\\n    }\\n    void generate(string id, int t) {\\n        timeMap[t + K].insert(id);\\n        nameMap[id] = t + K;\\n    }\\n    void renew(string id, int t) {\\n        processExpiry(t);\\n        if (nameMap.find(id) == nameMap.end()) // has it expired?\\n            return;\\n        auto last = nameMap[id];\\n        auto it = timeMap.lower_bound(last);\\n        auto [_, ids] = tie(it->first, it->second);\\n        ids.erase(id);\\n        generate(id, t);\\n    }\\n    int countUnexpiredTokens(int t) {\\n        processExpiry(t);\\n        return nameMap.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4100082,
                "title": "amortized-o-1",
                "content": "# Code\\n```\\nfrom collections import deque\\n# Amortized O(1)\\nclass AuthenticationManager:\\n    def __init__(self, timeToLive: int):\\n        self.ttl = timeToLive \\n        self.q = deque() # history [(expiry. id)]\\n        self.tokens = {} # {id : expiry}\\n\\n    def cleanup(self, currentTime): \\n        for _ in range(len(self.q)):\\n            if self.q[0][0] <= currentTime:\\n                _, id = self.q.popleft()\\n                if id in self.tokens and self.tokens[id] <= currentTime:\\n                    del self.tokens[id]\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:                \\n        expiry = currentTime + self.ttl\\n        self.tokens[tokenId] = expiry\\n        self.q.append((expiry, tokenId))\\n    \\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        self.cleanup(currentTime)\\n        if tokenId not in self.tokens:\\n            return\\n        self.generate(tokenId, currentTime)        \\n    \\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        self.cleanup(currentTime)\\n        return len(self.tokens)\\n\\n\\n# Your AuthenticationManager object will be instantiated and called as such:\\n# obj = AuthenticationManager(timeToLive)\\n# obj.generate(tokenId,currentTime)\\n# obj.renew(tokenId,currentTime)\\n# param_3 = obj.countUnexpiredTokens(currentTime)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import deque\\n# Amortized O(1)\\nclass AuthenticationManager:\\n    def __init__(self, timeToLive: int):\\n        self.ttl = timeToLive \\n        self.q = deque() # history [(expiry. id)]\\n        self.tokens = {} # {id : expiry}\\n\\n    def cleanup(self, currentTime): \\n        for _ in range(len(self.q)):\\n            if self.q[0][0] <= currentTime:\\n                _, id = self.q.popleft()\\n                if id in self.tokens and self.tokens[id] <= currentTime:\\n                    del self.tokens[id]\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:                \\n        expiry = currentTime + self.ttl\\n        self.tokens[tokenId] = expiry\\n        self.q.append((expiry, tokenId))\\n    \\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        self.cleanup(currentTime)\\n        if tokenId not in self.tokens:\\n            return\\n        self.generate(tokenId, currentTime)        \\n    \\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        self.cleanup(currentTime)\\n        return len(self.tokens)\\n\\n\\n# Your AuthenticationManager object will be instantiated and called as such:\\n# obj = AuthenticationManager(timeToLive)\\n# obj.generate(tokenId,currentTime)\\n# obj.renew(tokenId,currentTime)\\n# param_3 = obj.countUnexpiredTokens(currentTime)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086441,
                "title": "c-easy-100-solution-using-sortedlist-dictionary",
                "content": "\\n# Code\\n```\\npublic class AuthenticationManager {\\n    private Dictionary<string, int> _dict = new Dictionary<string, int>();\\n    private SortedList<int, string> _pq = new SortedList<int, string>();\\n    private int _timeToLive = 0;\\n\\n    public AuthenticationManager(int timeToLive)\\n    {\\n        _timeToLive = timeToLive;\\n    }\\n\\n    public void Generate(string tokenId, int currentTime)\\n    {\\n        if (_dict.ContainsKey(tokenId)) return;\\n\\n        _dict[tokenId] = currentTime + _timeToLive;\\n        _pq.Add(currentTime + _timeToLive, tokenId);\\n    }\\n\\n    public void Renew(string tokenId, int currentTime)\\n    {\\n        if (!_dict.ContainsKey(tokenId)) return;\\n\\n        if (_dict[tokenId] > currentTime)\\n        {\\n            _pq.Remove(_dict[tokenId]);\\n            _dict[tokenId] = currentTime + _timeToLive;\\n            _pq.Add(currentTime + _timeToLive, tokenId);\\n        }\\n    }\\n\\n public int CountUnexpiredTokens(int currentTime) \\n    {\\n        while (_pq.Count != 0 && _pq.First().Key <= currentTime)\\n        {\\n            var tokenId = _pq.First().Value;\\n            _pq.RemoveAt(0);\\n                \\n            if (_dict[tokenId] > currentTime)\\n                _pq.Add(_dict[tokenId], tokenId);\\n            else\\n                _dict.Remove(tokenId);\\n            }\\n\\n            return _pq.Count;\\n        }\\n}\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager obj = new AuthenticationManager(timeToLive);\\n * obj.Generate(tokenId,currentTime);\\n * obj.Renew(tokenId,currentTime);\\n * int param_3 = obj.CountUnexpiredTokens(currentTime);\\n */\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class AuthenticationManager {\\n    private Dictionary<string, int> _dict = new Dictionary<string, int>();\\n    private SortedList<int, string> _pq = new SortedList<int, string>();\\n    private int _timeToLive = 0;\\n\\n    public AuthenticationManager(int timeToLive)\\n    {\\n        _timeToLive = timeToLive;\\n    }\\n\\n    public void Generate(string tokenId, int currentTime)\\n    {\\n        if (_dict.ContainsKey(tokenId)) return;\\n\\n        _dict[tokenId] = currentTime + _timeToLive;\\n        _pq.Add(currentTime + _timeToLive, tokenId);\\n    }\\n\\n    public void Renew(string tokenId, int currentTime)\\n    {\\n        if (!_dict.ContainsKey(tokenId)) return;\\n\\n        if (_dict[tokenId] > currentTime)\\n        {\\n            _pq.Remove(_dict[tokenId]);\\n            _dict[tokenId] = currentTime + _timeToLive;\\n            _pq.Add(currentTime + _timeToLive, tokenId);\\n        }\\n    }\\n\\n public int CountUnexpiredTokens(int currentTime) \\n    {\\n        while (_pq.Count != 0 && _pq.First().Key <= currentTime)\\n        {\\n            var tokenId = _pq.First().Value;\\n            _pq.RemoveAt(0);\\n                \\n            if (_dict[tokenId] > currentTime)\\n                _pq.Add(_dict[tokenId], tokenId);\\n            else\\n                _dict.Remove(tokenId);\\n            }\\n\\n            return _pq.Count;\\n        }\\n}\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager obj = new AuthenticationManager(timeToLive);\\n * obj.Generate(tokenId,currentTime);\\n * obj.Renew(tokenId,currentTime);\\n * int param_3 = obj.CountUnexpiredTokens(currentTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078632,
                "title": "python-easy-to-understand-hash-table",
                "content": "# Intuition\\nClean old tokens before renewing and counting unexpired tokens\\n\\n# Code\\n```\\nclass AuthenticationManager:\\n\\n    def __init__(self, timeToLive: int):\\n        self.ttl = timeToLive\\n        self.time = defaultdict(set)\\n        self.token = {}\\n\\n    def delete_old_tokens(self, currentTime):\\n        delete = []\\n        for expiry, tokens in self.time.items():\\n            if expiry > currentTime:\\n                break\\n            delete.append(expiry)\\n        \\n        for expiry in delete:\\n            for tokenId in self.time[expiry]:\\n                del self.token[tokenId]\\n            del self.time[expiry]\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        new_expiry = currentTime + self.ttl\\n        self.token[tokenId] = new_expiry\\n        self.time[new_expiry].add(tokenId)\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        self.delete_old_tokens(currentTime)\\n        if tokenId not in self.token: return\\n\\n        expiry = self.token[tokenId]\\n        self.time[expiry].remove(tokenId)\\n        new_expiry = currentTime + self.ttl\\n        self.token[tokenId] = new_expiry\\n        self.time[new_expiry].add(tokenId)\\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        self.delete_old_tokens(currentTime)\\n        return len(self.token)\\n        \\n\\n\\n# Your AuthenticationManager object will be instantiated and called as such:\\n# obj = AuthenticationManager(timeToLive)\\n# obj.generate(tokenId,currentTime)\\n# obj.renew(tokenId,currentTime)\\n# param_3 = obj.countUnexpiredTokens(currentTime)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass AuthenticationManager:\\n\\n    def __init__(self, timeToLive: int):\\n        self.ttl = timeToLive\\n        self.time = defaultdict(set)\\n        self.token = {}\\n\\n    def delete_old_tokens(self, currentTime):\\n        delete = []\\n        for expiry, tokens in self.time.items():\\n            if expiry > currentTime:\\n                break\\n            delete.append(expiry)\\n        \\n        for expiry in delete:\\n            for tokenId in self.time[expiry]:\\n                del self.token[tokenId]\\n            del self.time[expiry]\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        new_expiry = currentTime + self.ttl\\n        self.token[tokenId] = new_expiry\\n        self.time[new_expiry].add(tokenId)\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        self.delete_old_tokens(currentTime)\\n        if tokenId not in self.token: return\\n\\n        expiry = self.token[tokenId]\\n        self.time[expiry].remove(tokenId)\\n        new_expiry = currentTime + self.ttl\\n        self.token[tokenId] = new_expiry\\n        self.time[new_expiry].add(tokenId)\\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        self.delete_old_tokens(currentTime)\\n        return len(self.token)\\n        \\n\\n\\n# Your AuthenticationManager object will be instantiated and called as such:\\n# obj = AuthenticationManager(timeToLive)\\n# obj.generate(tokenId,currentTime)\\n# obj.renew(tokenId,currentTime)\\n# param_3 = obj.countUnexpiredTokens(currentTime)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039059,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass AuthenticationManager {\\npublic:\\n    int ttl;\\n    map<string,int>mp;\\n    set<pair<int,string>>st;\\n    AuthenticationManager(int timeToLive) {\\n        ttl=timeToLive;\\n    }\\n    void clear(int currentTime)\\n    {\\n       while(!st.empty() && begin(st)->first<=currentTime)\\n       {\\n          mp.erase(begin(st)->second);\\n          st.erase(begin(st));\\n       }\\n    }\\n    void generate(string tokenId, int currentTime) {\\n        mp[tokenId]=currentTime+ttl;\\n        st.insert({mp[tokenId],tokenId});\\n    }\\n    \\n    void renew(string tokenId, int currentTime) \\n    {\\n        clear(currentTime);\\n        auto it=mp.find(tokenId);\\n        if (it!=mp.end())\\n        {\\n            st.erase({it->second,it->first});\\n            it->second=currentTime+ttl;\\n            st.insert({it->second,it->first});\\n        }\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) \\n    {\\n        clear(currentTime);\\n        return mp.size();\\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass AuthenticationManager {\\npublic:\\n    int ttl;\\n    map<string,int>mp;\\n    set<pair<int,string>>st;\\n    AuthenticationManager(int timeToLive) {\\n        ttl=timeToLive;\\n    }\\n    void clear(int currentTime)\\n    {\\n       while(!st.empty() && begin(st)->first<=currentTime)\\n       {\\n          mp.erase(begin(st)->second);\\n          st.erase(begin(st));\\n       }\\n    }\\n    void generate(string tokenId, int currentTime) {\\n        mp[tokenId]=currentTime+ttl;\\n        st.insert({mp[tokenId],tokenId});\\n    }\\n    \\n    void renew(string tokenId, int currentTime) \\n    {\\n        clear(currentTime);\\n        auto it=mp.find(tokenId);\\n        if (it!=mp.end())\\n        {\\n            st.erase({it->second,it->first});\\n            it->second=currentTime+ttl;\\n            st.insert({it->second,it->first});\\n        }\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) \\n    {\\n        clear(currentTime);\\n        return mp.size();\\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036506,
                "title": "linkedin-oa-question-12-09-2023",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass AuthenticationManager {\\n    int ttl;\\n    map<string,int> map;\\npublic:\\n    AuthenticationManager(int timeToLive) {\\n        ttl = timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        map.insert({tokenId, currentTime + ttl});\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if(map.find(tokenId) == map.end()) return;\\n        if(map[tokenId] <= currentTime) return;\\n        map[tokenId] = currentTime + ttl;\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int count = 0;\\n        for(auto i : map){\\n            if(i.second > currentTime) count++;\\n        }\\n        return count;\\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass AuthenticationManager {\\n    int ttl;\\n    map<string,int> map;\\npublic:\\n    AuthenticationManager(int timeToLive) {\\n        ttl = timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        map.insert({tokenId, currentTime + ttl});\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if(map.find(tokenId) == map.end()) return;\\n        if(map[tokenId] <= currentTime) return;\\n        map[tokenId] = currentTime + ttl;\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int count = 0;\\n        for(auto i : map){\\n            if(i.second > currentTime) count++;\\n        }\\n        return count;\\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036311,
                "title": "linkedin-oa",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst long long inf=1e18;\\nclass AuthenticationManager {\\npublic: \\n    int n;\\n    map<string,int> mp;\\n    multiset<int> st;\\n    AuthenticationManager(int timeToLive) {\\n       n=timeToLive;        \\n    }\\n    \\n    void generate(string tokenId, int ct) {\\n       mp[tokenId]=ct+n;\\n       st.insert(ct+n);\\n    }\\n    \\n    void renew(string s, int ct) {\\n        if(mp[s]!=0 && mp[s]>ct){\\n            if(st.find(mp[s])!=st.end()) st.erase(st.find(mp[s]));\\n            mp[s]=ct+n;\\n            st.insert(ct+n);\\n        }\\n    }\\n    \\n    int countUnexpiredTokens(int ct) {\\n        auto it=st.upper_bound(ct);\\n        long long val=0;\\n        if(it==st.end()){\\n           val=inf;           \\n        }\\n        else val=*it;\\n        vector<int> temp;\\n        for(auto &p: st){\\n            if(val<=p){ break;}\\n            temp.push_back(p);\\n        }\\n        for(auto &p: temp){\\n        st.erase(st.find(p));\\n       }\\n       return st.size();\\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nconst long long inf=1e18;\\nclass AuthenticationManager {\\npublic: \\n    int n;\\n    map<string,int> mp;\\n    multiset<int> st;\\n    AuthenticationManager(int timeToLive) {\\n       n=timeToLive;        \\n    }\\n    \\n    void generate(string tokenId, int ct) {\\n       mp[tokenId]=ct+n;\\n       st.insert(ct+n);\\n    }\\n    \\n    void renew(string s, int ct) {\\n        if(mp[s]!=0 && mp[s]>ct){\\n            if(st.find(mp[s])!=st.end()) st.erase(st.find(mp[s]));\\n            mp[s]=ct+n;\\n            st.insert(ct+n);\\n        }\\n    }\\n    \\n    int countUnexpiredTokens(int ct) {\\n        auto it=st.upper_bound(ct);\\n        long long val=0;\\n        if(it==st.end()){\\n           val=inf;           \\n        }\\n        else val=*it;\\n        vector<int> temp;\\n        for(auto &p: st){\\n            if(val<=p){ break;}\\n            temp.push_back(p);\\n        }\\n        for(auto &p: temp){\\n        st.erase(st.find(p));\\n       }\\n       return st.size();\\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014731,
                "title": "javascript-1797-design-authentication-manager",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar AuthenticationManager = function (timeToLive) {\\n  const expiry = {}\\n\\n  this.generate = function (id, ct) {\\n    expiry[id] = ct + timeToLive\\n  }\\n  this.renew = function (id, ct) {\\n    for (const id in expiry) if (expiry[id] <= ct) delete expiry[id]\\n    if (expiry[id]) expiry[id] = ct + timeToLive\\n  }\\n  this.countUnexpiredTokens = function (ct) {\\n    for (const id in expiry) if (expiry[id] <= ct) delete expiry[id]\\n    return Object.keys(expiry).length\\n  }\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar AuthenticationManager = function (timeToLive) {\\n  const expiry = {}\\n\\n  this.generate = function (id, ct) {\\n    expiry[id] = ct + timeToLive\\n  }\\n  this.renew = function (id, ct) {\\n    for (const id in expiry) if (expiry[id] <= ct) delete expiry[id]\\n    if (expiry[id]) expiry[id] = ct + timeToLive\\n  }\\n  this.countUnexpiredTokens = function (ct) {\\n    for (const id in expiry) if (expiry[id] <= ct) delete expiry[id]\\n    return Object.keys(expiry).length\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4011038,
                "title": "simple-python-clean",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n# Code\\n```\\n\\'\\'\\'\\nsess , auth token , TTL secons after curr time\\n\\nif renewed exp. time = curr time + ttl\\n\\n\\nIn terms of System design we can trade of countUnexpiredTokens\\n\\'\\'\\'\\n\\n\\nclass AuthenticationManager:\\n\\n    def __init__(self, timeToLive: int):  # O(1)\\n        self.ttl = timeToLive\\n        self.tokens = {}\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:  # O(1)\\n        self.tokens[tokenId] = currentTime\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None: # O(1)\\n        if tokenId in self.tokens and self.tokens[tokenId] + self.ttl > currentTime:\\n            self.tokens[tokenId] = currentTime\\n        elif tokenId in self.tokens:\\n            del self.tokens[tokenId]\\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int: # O(N)\\n        count = 0\\n        for t in self.tokens:\\n            if self.tokens[t] + self.ttl > currentTime:\\n                count += 1\\n        return count\\n\\n\\n# Your AuthenticationManager object will be instantiated and called as such:\\n# obj = AuthenticationManager(timeToLive)\\n# obj.generate(tokenId,currentTime)\\n# obj.renew(tokenId,currentTime)\\n# param_3 = obj.countUnexpiredTokens(currentTime)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\'\\'\\'\\nsess , auth token , TTL secons after curr time\\n\\nif renewed exp. time = curr time + ttl\\n\\n\\nIn terms of System design we can trade of countUnexpiredTokens\\n\\'\\'\\'\\n\\n\\nclass AuthenticationManager:\\n\\n    def __init__(self, timeToLive: int):  # O(1)\\n        self.ttl = timeToLive\\n        self.tokens = {}\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:  # O(1)\\n        self.tokens[tokenId] = currentTime\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None: # O(1)\\n        if tokenId in self.tokens and self.tokens[tokenId] + self.ttl > currentTime:\\n            self.tokens[tokenId] = currentTime\\n        elif tokenId in self.tokens:\\n            del self.tokens[tokenId]\\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int: # O(N)\\n        count = 0\\n        for t in self.tokens:\\n            if self.tokens[t] + self.ttl > currentTime:\\n                count += 1\\n        return count\\n\\n\\n# Your AuthenticationManager object will be instantiated and called as such:\\n# obj = AuthenticationManager(timeToLive)\\n# obj.generate(tokenId,currentTime)\\n# obj.renew(tokenId,currentTime)\\n# param_3 = obj.countUnexpiredTokens(currentTime)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989923,
                "title": "heap-solution-beats-99-o-1-generate-o-1-renew-o-nlogn-count",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst thoughts:\\n- Can generate and renew using hashmaps\\n- I have to calculate the number of expired tokens for count\\n- Brute way is to check and remove each token, is there any faster approach?\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHow to solve faster?\\n- If i can have the token that\\'s gonna expire first with me at all times , i can keep removing tokens until i find the token which has an expiry time> current time.\\n- First thoughts whenever you have to keep getting minimum elements should be a heap. heappop will return the token with min expiry time.\\nWell so how do i do it actually?\\n## Generate\\n- push (timeToLive+currentTime,tokenId) to heap\\n- make hashmap[tokenid]=timeToLive+currentTime\\n- Add 1 to total\\n## Renew\\nif hashmap[tokenid] exists,\\n\\n\\n*if hashmap[tokenid] value is greater than currentTime*\\n- make hashmap[tokenid] = timeToLive+currentTime\\n- push (timeToLive+currentTime,tokenId) to heap ( i will explain why you don\\'t have to change the pre existing value later on)\\n\\n*if its value is less than currentTime it has expired*\\n- so delete hashmap[tokenid] from hashmap\\n- subtract total by 1\\n\\nNote: we can say that the hashmap stores the **most recently updated value of expiration** for each tokens.\\n\\n## Count\\n\\n**while the heap is not empty and the top element has an expiry time less or equal to currentTime               :**\\n- Remove the top element from heap, lets call it removed.\\n- if removed[1] (*ie , the tokenId*) exists in the hashmap\\n    - if it\\'s value is same as removed[0]:\\n        -  subtract 1 from total, because the hashmap stores the recent value of expiration\\n        - now delete hashmap[removed[1]] from hashmap as it is expired\\n    - if it\\'s value is not same as removed[0]\\n        - it means that the tokenId(removed[1]) is updated and there exists one more element in heap like: (renewed_exp_time,tokenid)\\n        - so don\\'t do anything.\\n- if removed[1] doesnt exist in hashmap, then it has expired and it had been taken into account while renewing.\\n\\n**return total**  \\n\\n \\n# Complexity\\n- Time complexity: \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1) generate, O(1) renew , O(nlogn) count\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) - for storing heap\\n\\n# Code\\n```\\nfrom heapq import heapify,heappop,heappush\\nclass AuthenticationManager:\\n\\n    def __init__(self, timeToLive: int):\\n            self.heap=[]\\n            heapify(self.heap)\\n            self.d={}\\n            self.total=0\\n            self.c=[]\\n            self.time_to_live=timeToLive\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self.total+=1\\n        time=currentTime+self.time_to_live\\n        self.d[tokenId]=time\\n        heappush(self.heap,(time,tokenId))        \\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        time=currentTime+self.time_to_live\\n        if(tokenId in self.d):\\n            if(self.d[tokenId]>currentTime):\\n                self.d[tokenId]=time\\n                heappush(self.heap,(time,tokenId))\\n            else:\\n                del(self.d[tokenId])\\n                self.total-=1        \\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        time=currentTime\\n        while(len(self.heap)>0 and self.heap[0][0]<=time):\\n            t,token=heappop(self.heap)\\n            if(token in self.d and self.d[token]==t):\\n                self.total-=1\\n                del(self.d[token])        \\n        return self.total\\n        \\n\\n\\n# Your AuthenticationManager object will be instantiated and called as such:\\n# obj = AuthenticationManager(timeToLive)\\n# obj.generate(tokenId,currentTime)\\n# obj.renew(tokenId,currentTime)\\n# param_3 = obj.countUnexpiredTokens(currentTime)\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom heapq import heapify,heappop,heappush\\nclass AuthenticationManager:\\n\\n    def __init__(self, timeToLive: int):\\n            self.heap=[]\\n            heapify(self.heap)\\n            self.d={}\\n            self.total=0\\n            self.c=[]\\n            self.time_to_live=timeToLive\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self.total+=1\\n        time=currentTime+self.time_to_live\\n        self.d[tokenId]=time\\n        heappush(self.heap,(time,tokenId))        \\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        time=currentTime+self.time_to_live\\n        if(tokenId in self.d):\\n            if(self.d[tokenId]>currentTime):\\n                self.d[tokenId]=time\\n                heappush(self.heap,(time,tokenId))\\n            else:\\n                del(self.d[tokenId])\\n                self.total-=1        \\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        time=currentTime\\n        while(len(self.heap)>0 and self.heap[0][0]<=time):\\n            t,token=heappop(self.heap)\\n            if(token in self.d and self.d[token]==t):\\n                self.total-=1\\n                del(self.d[token])        \\n        return self.total\\n        \\n\\n\\n# Your AuthenticationManager object will be instantiated and called as such:\\n# obj = AuthenticationManager(timeToLive)\\n# obj.generate(tokenId,currentTime)\\n# obj.renew(tokenId,currentTime)\\n# param_3 = obj.countUnexpiredTokens(currentTime)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988958,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "```\\nclass AuthenticationManager {\\n    private Map<String, Integer> map;\\n    private int period;\\n    \\n    public AuthenticationManager(int timeToLive) {\\n        map = new HashMap<>();\\n        period = timeToLive;\\n    }\\n\\n    public void generate(String tokenId, int currentTime) {\\n        map.put(tokenId, currentTime + period);\\n    }\\n\\n    public void renew(String tokenId, int currentTime) {\\n        if (map.get(tokenId) != null) {\\n            if (map.get(tokenId) > currentTime) {\\n                map.put(tokenId, currentTime + period);\\n            }\\n        }\\n    }\\n\\n    public int countUnexpiredTokens(int currentTime) {\\n        return (int) map.entrySet().stream().filter(k -> k.getValue() > currentTime).count();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Math",
                    "Design"
                ],
                "code": "```\\nclass AuthenticationManager {\\n    private Map<String, Integer> map;\\n    private int period;\\n    \\n    public AuthenticationManager(int timeToLive) {\\n        map = new HashMap<>();\\n        period = timeToLive;\\n    }\\n\\n    public void generate(String tokenId, int currentTime) {\\n        map.put(tokenId, currentTime + period);\\n    }\\n\\n    public void renew(String tokenId, int currentTime) {\\n        if (map.get(tokenId) != null) {\\n            if (map.get(tokenId) > currentTime) {\\n                map.put(tokenId, currentTime + period);\\n            }\\n        }\\n    }\\n\\n    public int countUnexpiredTokens(int currentTime) {\\n        return (int) map.entrySet().stream().filter(k -> k.getValue() > currentTime).count();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3896667,
                "title": "list-queue-hashmap-o-1-generate-renew-o-n-count",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse list as a queue for fast renews, since list is O(1) erase from anywhere.\\nUse hash map for fast access to list elements.\\nSimilar idea can be used in LRU cache.\\n\\n# Complexity\\n- Time complexity: Constant generate & renew, Linear count\\n\\n- Space complexity: Linear\\n\\n# Code\\n```\\nclass AuthenticationManager {\\n    int ttl;\\n    list<pair<string, int>> q;\\n    unordered_map<string, list<pair<string, int>>::const_iterator> m;\\npublic:\\n    AuthenticationManager(int timeToLive) {\\n        ttl = timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        m[tokenId] = q.insert(q.end(), {tokenId, currentTime});\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if (m.find(tokenId) == m.end() || m[tokenId]->second + ttl <= currentTime) {\\n            return;\\n        }\\n        q.erase(m[tokenId]);\\n        m[tokenId] = q.insert(q.end(), {tokenId, currentTime});\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        while (!q.empty() && q.front().second + ttl <= currentTime) {\\n            m.erase(q.front().first);\\n            q.pop_front();\\n        }\\n        return q.size();\\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Linked List",
                    "Queue"
                ],
                "code": "```\\nclass AuthenticationManager {\\n    int ttl;\\n    list<pair<string, int>> q;\\n    unordered_map<string, list<pair<string, int>>::const_iterator> m;\\npublic:\\n    AuthenticationManager(int timeToLive) {\\n        ttl = timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        m[tokenId] = q.insert(q.end(), {tokenId, currentTime});\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if (m.find(tokenId) == m.end() || m[tokenId]->second + ttl <= currentTime) {\\n            return;\\n        }\\n        q.erase(m[tokenId]);\\n        m[tokenId] = q.insert(q.end(), {tokenId, currentTime});\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        while (!q.empty() && q.front().second + ttl <= currentTime) {\\n            m.erase(q.front().first);\\n            q.pop_front();\\n        }\\n        return q.size();\\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3851402,
                "title": "simple-java-solution-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass AuthenticationManager {\\n\\n    private int timeToLive;\\n    private Map<String, Integer> map;\\n    \\n    public AuthenticationManager(int timeToLive) {\\n        this.timeToLive = timeToLive;\\n        this.map = new HashMap<>();\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        if(!map.containsKey(tokenId)){\\n            map.put(tokenId, currentTime);\\n        }\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        if(map.containsKey(tokenId)){\\n            Integer oldTime = map.get(tokenId);\\n            if(oldTime+this.timeToLive > currentTime){\\n                map.put(tokenId, currentTime);\\n            }\\n        }\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        Integer time;\\n        long count = map.entrySet().stream().filter(e -> (e.getValue()+this.timeToLive > currentTime)).count();\\n        return (int) count;\\n    }\\n}\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager obj = new AuthenticationManager(timeToLive);\\n * obj.generate(tokenId,currentTime);\\n * obj.renew(tokenId,currentTime);\\n * int param_3 = obj.countUnexpiredTokens(currentTime);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass AuthenticationManager {\\n\\n    private int timeToLive;\\n    private Map<String, Integer> map;\\n    \\n    public AuthenticationManager(int timeToLive) {\\n        this.timeToLive = timeToLive;\\n        this.map = new HashMap<>();\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        if(!map.containsKey(tokenId)){\\n            map.put(tokenId, currentTime);\\n        }\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        if(map.containsKey(tokenId)){\\n            Integer oldTime = map.get(tokenId);\\n            if(oldTime+this.timeToLive > currentTime){\\n                map.put(tokenId, currentTime);\\n            }\\n        }\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        Integer time;\\n        long count = map.entrySet().stream().filter(e -> (e.getValue()+this.timeToLive > currentTime)).count();\\n        return (int) count;\\n    }\\n}\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager obj = new AuthenticationManager(timeToLive);\\n * obj.generate(tokenId,currentTime);\\n * obj.renew(tokenId,currentTime);\\n * int param_3 = obj.countUnexpiredTokens(currentTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838675,
                "title": "javascript-solution-131ms-beats-100-00",
                "content": "# AuthenticationManager\\n\\nAuthenticationManager is a class that manages tokens used for authentication. It allows generating, renewing, and counting unexpired tokens.\\n\\n## Methods:\\n\\n- `AuthenticationManager(timeToLive)`: Constructor that initializes the AuthenticationManager with the given timeToLive value, representing the token expiration time in seconds.\\n\\n- `generate(tokenId, currentTime)`: Generates a new token with the given tokenId, expiring after `timeToLive` seconds.\\n\\n- `renew(tokenId, currentTime)`: Renews the token with the given tokenId if it exists and hasn\\'t expired yet.\\n\\n- `countUnexpiredTokens(currentTime)`: Counts and returns the number of unexpired tokens at the current time.\\n\\n## Complexity:\\n\\n- `generate` and `renew` methods have O(1) time complexity, directly accessing the tokens Map.\\n\\n- `countUnexpiredTokens` has O(n) time complexity in the worst case, with n being the number of tokens.\\n\\n- Space complexity is O(n) due to token storage in the Map.\\n\\nConstructor: O(n)\\n\\n# Code\\n```\\n/**\\n * @param {number} timeToLive\\n */\\nvar AuthenticationManager = function(timeToLive) {\\n    this.timeout = timeToLive;\\n    this.tokens = new Map();\\n};\\n\\n/** \\n * @param {string} tokenId \\n * @param {number} currentTime\\n * @return {void}\\n */\\nAuthenticationManager.prototype.generate = function(tokenId, currentTime) {\\n    this.tokens.set(tokenId, currentTime + this.timeout);\\n};\\n\\n/** \\n * @param {string} tokenId \\n * @param {number} currentTime\\n * @return {void}\\n */\\nAuthenticationManager.prototype.renew = function(tokenId, currentTime) {\\n    const expiresAt = this.tokens.get(tokenId);\\n    // If there is no such token or it has expired, delete it from the cache.\\n    if (!expiresAt || currentTime >= expiresAt) {\\n        this.tokens.delete(tokenId);\\n        return;\\n    }\\n    this.tokens.set(tokenId, currentTime + this.timeout)\\n};\\n\\n/** \\n * @param {number} currentTime\\n * @return {number}\\n */\\nAuthenticationManager.prototype.countUnexpiredTokens = function(currentTime) {\\n    let result = 0;\\n    for (const [tokenId, expiresAt] of this.tokens.entries()) {\\n        // If the token has expired, delete it from the cache\\n        if (currentTime >= expiresAt) {\\n            this.tokens.delete(tokenId);\\n            continue;\\n        }\\n        result += 1;\\n    }\\n    return result\\n};\\n\\n/** \\n * Your AuthenticationManager object will be instantiated and called as such:\\n * var obj = new AuthenticationManager(timeToLive)\\n * obj.generate(tokenId,currentTime)\\n * obj.renew(tokenId,currentTime)\\n * var param_3 = obj.countUnexpiredTokens(currentTime)\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\n/**\\n * @param {number} timeToLive\\n */\\nvar AuthenticationManager = function(timeToLive) {\\n    this.timeout = timeToLive;\\n    this.tokens = new Map();\\n};\\n\\n/** \\n * @param {string} tokenId \\n * @param {number} currentTime\\n * @return {void}\\n */\\nAuthenticationManager.prototype.generate = function(tokenId, currentTime) {\\n    this.tokens.set(tokenId, currentTime + this.timeout);\\n};\\n\\n/** \\n * @param {string} tokenId \\n * @param {number} currentTime\\n * @return {void}\\n */\\nAuthenticationManager.prototype.renew = function(tokenId, currentTime) {\\n    const expiresAt = this.tokens.get(tokenId);\\n    // If there is no such token or it has expired, delete it from the cache.\\n    if (!expiresAt || currentTime >= expiresAt) {\\n        this.tokens.delete(tokenId);\\n        return;\\n    }\\n    this.tokens.set(tokenId, currentTime + this.timeout)\\n};\\n\\n/** \\n * @param {number} currentTime\\n * @return {number}\\n */\\nAuthenticationManager.prototype.countUnexpiredTokens = function(currentTime) {\\n    let result = 0;\\n    for (const [tokenId, expiresAt] of this.tokens.entries()) {\\n        // If the token has expired, delete it from the cache\\n        if (currentTime >= expiresAt) {\\n            this.tokens.delete(tokenId);\\n            continue;\\n        }\\n        result += 1;\\n    }\\n    return result\\n};\\n\\n/** \\n * Your AuthenticationManager object will be instantiated and called as such:\\n * var obj = new AuthenticationManager(timeToLive)\\n * obj.generate(tokenId,currentTime)\\n * obj.renew(tokenId,currentTime)\\n * var param_3 = obj.countUnexpiredTokens(currentTime)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3820014,
                "title": "hashmap-java-solution-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass AuthenticationManager {\\n    private final int timeToLive;\\n    public Map<String,Integer> tokenList  = new HashMap();\\n    public AuthenticationManager(int ttl) {\\n        timeToLive = ttl;\\n\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        if(!tokenList.containsKey(tokenId)){\\n             tokenList.put(tokenId,currentTime+this.timeToLive);\\n            }\\n        }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        if(tokenList.containsKey(tokenId)){\\n            if(tokenList.get(tokenId) > currentTime){\\n                tokenList.put(tokenId,currentTime+timeToLive);\\n            }\\n        }\\n        \\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        int count=0;\\n        for (Map.Entry<String,Integer> entry : tokenList.entrySet()) {\\n            if(entry.getValue() > currentTime){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager obj = new AuthenticationManager(timeToLive);\\n * obj.generate(tokenId,currentTime);\\n * obj.renew(tokenId,currentTime);\\n * int param_3 = obj.countUnexpiredTokens(currentTime);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass AuthenticationManager {\\n    private final int timeToLive;\\n    public Map<String,Integer> tokenList  = new HashMap();\\n    public AuthenticationManager(int ttl) {\\n        timeToLive = ttl;\\n\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        if(!tokenList.containsKey(tokenId)){\\n             tokenList.put(tokenId,currentTime+this.timeToLive);\\n            }\\n        }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        if(tokenList.containsKey(tokenId)){\\n            if(tokenList.get(tokenId) > currentTime){\\n                tokenList.put(tokenId,currentTime+timeToLive);\\n            }\\n        }\\n        \\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        int count=0;\\n        for (Map.Entry<String,Integer> entry : tokenList.entrySet()) {\\n            if(entry.getValue() > currentTime){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager obj = new AuthenticationManager(timeToLive);\\n * obj.generate(tokenId,currentTime);\\n * obj.renew(tokenId,currentTime);\\n * int param_3 = obj.countUnexpiredTokens(currentTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750089,
                "title": "simple-solution-using-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass AuthenticationManager(object):\\n\\n    def __init__(self, timeToLive):\\n        \"\"\"\\n        :type timeToLive: int\\n        \"\"\"\\n        self.time=timeToLive\\n        self.id=[]\\n        self.ct=[]\\n        \\n        \\n\\n    def generate(self, tokenId, currentTime):\\n        \"\"\"\\n        :type tokenId: str\\n        :type currentTime: int\\n        :rtype: None\\n        \"\"\"\\n        if tokenId in self.id:\\n            g=self.ct[self.id.index(tokenId)]+self.time\\n            if currentTime<g:\\n                self.ct[self.id.index(tokenId)]=currentTime\\n        else:\\n            self.id.append(tokenId)\\n            self.ct.append(currentTime)\\n\\n        \\n\\n    def renew(self, tokenId, currentTime):\\n        \"\"\"\\n        :type tokenId: str\\n        :type currentTime: int\\n        :rtype: None\\n        \"\"\"\\n        if tokenId in self.id:\\n            g=self.ct[self.id.index(tokenId)]+self.time\\n            if g>currentTime:\\n                self.ct[self.id.index(tokenId)]=currentTime\\n        \\n            \\n        \\n\\n    def countUnexpiredTokens(self, currentTime):\\n        \"\"\"\\n        :type currentTime: int\\n        :rtype: int\\n        \"\"\"\\n        co=0\\n        #print(self.id,self.ct)\\n        for i in range(0,len(self.ct)):\\n            #print(self.ct[i],self.time)\\n            j=self.ct[i]+self.time\\n            if j>currentTime:\\n                co=co+1\\n        return co\\n        \\n\\n\\n# Your AuthenticationManager object will be instantiated and called as such:\\n# obj = AuthenticationManager(timeToLive)\\n# obj.generate(tokenId,currentTime)\\n# obj.renew(tokenId,currentTime)\\n# param_3 = obj.countUnexpiredTokens(currentTime)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass AuthenticationManager(object):\\n\\n    def __init__(self, timeToLive):\\n        \"\"\"\\n        :type timeToLive: int\\n        \"\"\"\\n        self.time=timeToLive\\n        self.id=[]\\n        self.ct=[]\\n        \\n        \\n\\n    def generate(self, tokenId, currentTime):\\n        \"\"\"\\n        :type tokenId: str\\n        :type currentTime: int\\n        :rtype: None\\n        \"\"\"\\n        if tokenId in self.id:\\n            g=self.ct[self.id.index(tokenId)]+self.time\\n            if currentTime<g:\\n                self.ct[self.id.index(tokenId)]=currentTime\\n        else:\\n            self.id.append(tokenId)\\n            self.ct.append(currentTime)\\n\\n        \\n\\n    def renew(self, tokenId, currentTime):\\n        \"\"\"\\n        :type tokenId: str\\n        :type currentTime: int\\n        :rtype: None\\n        \"\"\"\\n        if tokenId in self.id:\\n            g=self.ct[self.id.index(tokenId)]+self.time\\n            if g>currentTime:\\n                self.ct[self.id.index(tokenId)]=currentTime\\n        \\n            \\n        \\n\\n    def countUnexpiredTokens(self, currentTime):\\n        \"\"\"\\n        :type currentTime: int\\n        :rtype: int\\n        \"\"\"\\n        co=0\\n        #print(self.id,self.ct)\\n        for i in range(0,len(self.ct)):\\n            #print(self.ct[i],self.time)\\n            j=self.ct[i]+self.time\\n            if j>currentTime:\\n                co=co+1\\n        return co\\n        \\n\\n\\n# Your AuthenticationManager object will be instantiated and called as such:\\n# obj = AuthenticationManager(timeToLive)\\n# obj.generate(tokenId,currentTime)\\n# obj.renew(tokenId,currentTime)\\n# param_3 = obj.countUnexpiredTokens(currentTime)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727902,
                "title": "simple-java-solution-hashmap-easy-to-understand",
                "content": "```\\nclass AuthenticationManager {\\n\\n    int timeLimit;\\n    Map<String, Integer> hm;\\n\\n    public AuthenticationManager(int timeToLive) {\\n        timeLimit = timeToLive;\\n        hm = new HashMap<>();\\n    }\\n\\n    public void generate(String tokenId, int currentTime) {\\n        hm.put(tokenId, currentTime + timeLimit);\\n    }\\n\\n    public void renew(String tokenId, int currentTime) {\\n        if(hm.containsKey(tokenId)) {\\n            if (hm.get(tokenId) > currentTime) {\\n                hm.put(tokenId, currentTime + timeLimit);\\n            }\\n        }\\n    }\\n\\n    public int countUnexpiredTokens(int currentTime) {\\n        int count = 0;\\n        for (Integer expireTime : hm.values()) {\\n            if (expireTime > currentTime) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\nI did try this for the countUnexpiredTokens but alas even though it looks cool it was slower :(\\n```\\n    public int countUnexpiredTokens(int currentTime) {\\n        return (int) hm.values().stream().filter(et -> et > currentTime).count();\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass AuthenticationManager {\\n\\n    int timeLimit;\\n    Map<String, Integer> hm;\\n\\n    public AuthenticationManager(int timeToLive) {\\n        timeLimit = timeToLive;\\n        hm = new HashMap<>();\\n    }\\n\\n    public void generate(String tokenId, int currentTime) {\\n        hm.put(tokenId, currentTime + timeLimit);\\n    }\\n\\n    public void renew(String tokenId, int currentTime) {\\n        if(hm.containsKey(tokenId)) {\\n            if (hm.get(tokenId) > currentTime) {\\n                hm.put(tokenId, currentTime + timeLimit);\\n            }\\n        }\\n    }\\n\\n    public int countUnexpiredTokens(int currentTime) {\\n        int count = 0;\\n        for (Integer expireTime : hm.values()) {\\n            if (expireTime > currentTime) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\n    public int countUnexpiredTokens(int currentTime) {\\n        return (int) hm.values().stream().filter(et -> et > currentTime).count();\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605964,
                "title": "c-efficient-o-logn-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n    Each function has $$O(logn)$$ time complexity\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass AuthenticationManager {\\npublic:\\n    int ttl;\\n    unordered_map<string,int> mp;\\n    set<int> s;\\n    AuthenticationManager(int timeToLive) {\\n        this->ttl = timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        mp[tokenId] = currentTime + ttl;\\n        s.insert(currentTime + ttl);\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if(mp.find(tokenId)!=mp.end() && \\n        mp[tokenId] > currentTime){   \\n            s.erase(mp[tokenId]);\\n            mp[tokenId] = currentTime + ttl;\\n            s.insert(mp[tokenId]);\\n        }\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        auto lb = s.lower_bound(currentTime+1);\\n        s.erase(s.begin(),lb);\\n        return s.size();\\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Design",
                    "Ordered Set"
                ],
                "code": "```\\nclass AuthenticationManager {\\npublic:\\n    int ttl;\\n    unordered_map<string,int> mp;\\n    set<int> s;\\n    AuthenticationManager(int timeToLive) {\\n        this->ttl = timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        mp[tokenId] = currentTime + ttl;\\n        s.insert(currentTime + ttl);\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if(mp.find(tokenId)!=mp.end() && \\n        mp[tokenId] > currentTime){   \\n            s.erase(mp[tokenId]);\\n            mp[tokenId] = currentTime + ttl;\\n            s.insert(mp[tokenId]);\\n        }\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        auto lb = s.lower_bound(currentTime+1);\\n        s.erase(s.begin(),lb);\\n        return s.size();\\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453618,
                "title": "c-with-hashmap-set-binary-search-still-beats-only-43",
                "content": "\\n# Complexity\\n- Time complexity: generate & renew: $$O(1)$$ `//average `countUnexpiredTokens : $$O(logn)$$ `//hopefully`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass AuthenticationManager {\\npublic:\\n    unordered_map<string, int> token;\\n    multiset<int> time;\\n    int t2l;\\n    AuthenticationManager(int timeToLive) {\\n        t2l = timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        if(token.find(tokenId) == token.end()){\\n        token.insert({tokenId, currentTime});\\n        time.insert(currentTime);\\n        }\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if(token.find(tokenId) == token.end()) return;\\n        if(t2l + token[tokenId] > currentTime){\\n            int t = token[tokenId];\\n            token[tokenId] = currentTime;\\n            time.erase(time.find(t));\\n            time.insert(currentTime);\\n        }\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int t = currentTime - t2l;\\n        int sz = time.size();\\n        if(sz == 0) \\n            return 0;\\n        if(*(next(time.begin(), sz-1))< t) \\n            return 0;\\n        int l = 0;\\n        int r = sz;\\n        int m = l + (r - l)/2;\\n        auto it = time.begin();\\n        while(l < r){\\n            m = l + (r-l)/2;\\n            it = next(time.begin(), m);\\n            if(*it <= t)\\n                l = m +1;\\n            else\\n                r = m;\\n        }\\n        return sz - l;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass AuthenticationManager {\\npublic:\\n    unordered_map<string, int> token;\\n    multiset<int> time;\\n    int t2l;\\n    AuthenticationManager(int timeToLive) {\\n        t2l = timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        if(token.find(tokenId) == token.end()){\\n        token.insert({tokenId, currentTime});\\n        time.insert(currentTime);\\n        }\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if(token.find(tokenId) == token.end()) return;\\n        if(t2l + token[tokenId] > currentTime){\\n            int t = token[tokenId];\\n            token[tokenId] = currentTime;\\n            time.erase(time.find(t));\\n            time.insert(currentTime);\\n        }\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int t = currentTime - t2l;\\n        int sz = time.size();\\n        if(sz == 0) \\n            return 0;\\n        if(*(next(time.begin(), sz-1))< t) \\n            return 0;\\n        int l = 0;\\n        int r = sz;\\n        int m = l + (r - l)/2;\\n        auto it = time.begin();\\n        while(l < r){\\n            m = l + (r-l)/2;\\n            it = next(time.begin(), m);\\n            if(*it <= t)\\n                l = m +1;\\n            else\\n                r = m;\\n        }\\n        return sz - l;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451338,
                "title": "c-single-map-easy-solution",
                "content": "```class AuthenticationManager {\\npublic: \\n    unordered_map<string,int>mp;\\n    int t;\\n    AuthenticationManager(int timeToLive) {\\n        t=timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        mp[tokenId]= currentTime+t;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if(mp.find(tokenId)!=mp.end() && mp[tokenId]>currentTime)\\n            mp[tokenId]= currentTime+t;\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int ans=0;\\n        for(auto it: mp)\\n        {\\n            if(it.second>currentTime)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "```class AuthenticationManager {\\npublic: \\n    unordered_map<string,int>mp;\\n    int t;\\n    AuthenticationManager(int timeToLive) {\\n        t=timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        mp[tokenId]= currentTime+t;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if(mp.find(tokenId)!=mp.end() && mp[tokenId]>currentTime)\\n            mp[tokenId]= currentTime+t;\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int ans=0;\\n        for(auto it: mp)\\n        {\\n            if(it.second>currentTime)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 3393592,
                "title": "beats-100-runtime-clean-and-readable-authenticationmanager",
                "content": "# Code\\n```\\ntype TokenId = string;\\ntype ExpiresAtTime = number;\\n\\n\\nclass AuthenticationManager {\\n    private tokens = new Map<TokenId, ExpiresAtTime>([]);\\n\\n    constructor(private readonly timeToLive: number) {}\\n\\n    private isTokenOnRecord(tokenId: string) {\\n        return this.tokens.get(tokenId) !== undefined;\\n    }\\n\\n    private hasTokenExpired(tokenId: string, currentTime: number): boolean {\\n        const expiresAtTime = this.tokens.get(tokenId);\\n        if (!expiresAtTime) throw new Error(\"Token doesn\\'t exist\");\\n        return expiresAtTime <= currentTime;\\n    }\\n\\n    generate(tokenId: string, currentTime: number): void {\\n        this.tokens.set(tokenId, currentTime + this.timeToLive);\\n    }\\n\\n    renew(tokenId: string, currentTime: number): void {\\n        if (!this.isTokenOnRecord(tokenId)) return;\\n        if (!this.hasTokenExpired(tokenId, currentTime)) {\\n            this.generate(tokenId, currentTime);\\n        }\\n    }\\n\\n    countUnexpiredTokens(currentTime: number): number {\\n        const expiresAtTimes = Array.from(this.tokens.values());\\n        return expiresAtTimes.reduce((value, expiresAtTime) => expiresAtTime > currentTime ? value + 1 : value, 0);\\n    }\\n}\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * var obj = new AuthenticationManager(timeToLive)\\n * obj.generate(tokenId,currentTime)\\n * obj.renew(tokenId,currentTime)\\n * var param_3 = obj.countUnexpiredTokens(currentTime)\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype TokenId = string;\\ntype ExpiresAtTime = number;\\n\\n\\nclass AuthenticationManager {\\n    private tokens = new Map<TokenId, ExpiresAtTime>([]);\\n\\n    constructor(private readonly timeToLive: number) {}\\n\\n    private isTokenOnRecord(tokenId: string) {\\n        return this.tokens.get(tokenId) !== undefined;\\n    }\\n\\n    private hasTokenExpired(tokenId: string, currentTime: number): boolean {\\n        const expiresAtTime = this.tokens.get(tokenId);\\n        if (!expiresAtTime) throw new Error(\"Token doesn\\'t exist\");\\n        return expiresAtTime <= currentTime;\\n    }\\n\\n    generate(tokenId: string, currentTime: number): void {\\n        this.tokens.set(tokenId, currentTime + this.timeToLive);\\n    }\\n\\n    renew(tokenId: string, currentTime: number): void {\\n        if (!this.isTokenOnRecord(tokenId)) return;\\n        if (!this.hasTokenExpired(tokenId, currentTime)) {\\n            this.generate(tokenId, currentTime);\\n        }\\n    }\\n\\n    countUnexpiredTokens(currentTime: number): number {\\n        const expiresAtTimes = Array.from(this.tokens.values());\\n        return expiresAtTimes.reduce((value, expiresAtTime) => expiresAtTime > currentTime ? value + 1 : value, 0);\\n    }\\n}\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * var obj = new AuthenticationManager(timeToLive)\\n * obj.generate(tokenId,currentTime)\\n * obj.renew(tokenId,currentTime)\\n * var param_3 = obj.countUnexpiredTokens(currentTime)\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384989,
                "title": "one-liners-functions-beats-100-time-and-space-rust",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$ for all associated functions except for count_unexpired_tokens: $$O(N)$$. That N is the number of generated tokens so far.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nuse std::collections::HashMap;\\n\\nstruct AuthenticationManager {\\n    tokens: HashMap<String, i32>,\\n    live: i32,\\n}\\n\\n\\nimpl AuthenticationManager {\\n    fn new(timeToLive: i32) -> Self {\\n        Self { tokens: HashMap::new(), live: timeToLive }\\n    }\\n    \\n    fn generate(&mut self, token_id: String, current_time: i32) {\\n        self.tokens.insert(token_id, current_time + self.live);\\n    }\\n    \\n    fn renew(&mut self, token_id: String, current_time: i32) {\\n        if let Some(&val) = self.tokens.get(&token_id) {\\n            if val <= current_time { return };\\n            self.tokens.insert(token_id, current_time + self.live);\\n        }\\n    }\\n    \\n    fn count_unexpired_tokens(&self, current_time: i32) -> i32 {\\n        self.tokens.values().fold(0, |acc, &x|\\n            if x > current_time { acc + 1 } else { acc })\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\nstruct AuthenticationManager {\\n    tokens: HashMap<String, i32>,\\n    live: i32,\\n}\\n\\n\\nimpl AuthenticationManager {\\n    fn new(timeToLive: i32) -> Self {\\n        Self { tokens: HashMap::new(), live: timeToLive }\\n    }\\n    \\n    fn generate(&mut self, token_id: String, current_time: i32) {\\n        self.tokens.insert(token_id, current_time + self.live);\\n    }\\n    \\n    fn renew(&mut self, token_id: String, current_time: i32) {\\n        if let Some(&val) = self.tokens.get(&token_id) {\\n            if val <= current_time { return };\\n            self.tokens.insert(token_id, current_time + self.live);\\n        }\\n    }\\n    \\n    fn count_unexpired_tokens(&self, current_time: i32) -> i32 {\\n        self.tokens.values().fold(0, |acc, &x|\\n            if x > current_time { acc + 1 } else { acc })\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3380824,
                "title": "1797-design-authentication-manager",
                "content": "\\n\\n# Code\\n```\\nclass AuthenticationManager {\\n\\nprivate:\\n    unordered_map<string, int> m;\\n    int timeToLive;\\n\\npublic:\\n    AuthenticationManager(int timeToLive) {\\n\\n        this->timeToLive = timeToLive;\\n        \\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        \\n        m[tokenId] = (currentTime + timeToLive);\\n\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n\\n        if(m.find(tokenId) != m.end()){\\n\\n            if(m[tokenId] <= currentTime){\\n                m.erase(tokenId);\\n            }\\n            else{\\n                m[tokenId] = (currentTime + timeToLive);\\n            }\\n        }\\n        \\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n\\n\\n        for(auto it = m.begin(); it != m.end();){\\n            if(it->second <= currentTime){\\n                \\n                it = m.erase(it);\\n            }\\n            else{\\n                it++;\\n            }\\n        }\\n\\n        return m.size();\\n        \\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass AuthenticationManager {\\n\\nprivate:\\n    unordered_map<string, int> m;\\n    int timeToLive;\\n\\npublic:\\n    AuthenticationManager(int timeToLive) {\\n\\n        this->timeToLive = timeToLive;\\n        \\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        \\n        m[tokenId] = (currentTime + timeToLive);\\n\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n\\n        if(m.find(tokenId) != m.end()){\\n\\n            if(m[tokenId] <= currentTime){\\n                m.erase(tokenId);\\n            }\\n            else{\\n                m[tokenId] = (currentTime + timeToLive);\\n            }\\n        }\\n        \\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n\\n\\n        for(auto it = m.begin(); it != m.end();){\\n            if(it->second <= currentTime){\\n                \\n                it = m.erase(it);\\n            }\\n            else{\\n                it++;\\n            }\\n        }\\n\\n        return m.size();\\n        \\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367722,
                "title": "accepted-swift",
                "content": "```\\nclass AuthenticationManager {\\n\\n    private let timeToLive: Int\\n    private var tokens = [String: Int]()\\n\\n    private func clear(_ currentTime: Int) {\\n        tokens = tokens.filter { $0.value > currentTime }\\n    }\\n\\n    init(_ timeToLive: Int) {\\n        self.timeToLive = timeToLive\\n    }\\n    \\n    func generate(_ tokenId: String, _ currentTime: Int) {\\n        clear(currentTime)\\n        tokens[tokenId] = currentTime + timeToLive\\n    }\\n    \\n    func renew(_ tokenId: String, _ currentTime: Int) {\\n        clear(currentTime)\\n        guard tokens[tokenId] != nil else { return }\\n        generate(tokenId, currentTime)\\n    }\\n    \\n    func countUnexpiredTokens(_ currentTime: Int) -> Int {\\n        clear(currentTime)\\n        return tokens.count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass AuthenticationManager {\\n\\n    private let timeToLive: Int\\n    private var tokens = [String: Int]()\\n\\n    private func clear(_ currentTime: Int) {\\n        tokens = tokens.filter { $0.value > currentTime }\\n    }\\n\\n    init(_ timeToLive: Int) {\\n        self.timeToLive = timeToLive\\n    }\\n    \\n    func generate(_ tokenId: String, _ currentTime: Int) {\\n        clear(currentTime)\\n        tokens[tokenId] = currentTime + timeToLive\\n    }\\n    \\n    func renew(_ tokenId: String, _ currentTime: Int) {\\n        clear(currentTime)\\n        guard tokens[tokenId] != nil else { return }\\n        generate(tokenId, currentTime)\\n    }\\n    \\n    func countUnexpiredTokens(_ currentTime: Int) -> Int {\\n        clear(currentTime)\\n        return tokens.count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3335536,
                "title": "simple-java-solution-using-treemap-and-hashmap",
                "content": "\\n```\\nclass AuthenticationManager {\\n    HashMap<String, Integer> tokenToId = new HashMap<>();\\n    TreeMap<Integer, String> IdToToken = new TreeMap<>();\\n    int ttl = 0;\\n\\n    public AuthenticationManager(int timeToLive) {\\n        ttl = timeToLive;\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        tokenToId.put(tokenId, currentTime+ttl);\\n        IdToToken.put(currentTime+ttl, tokenId);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        if (!tokenToId.containsKey(tokenId) || tokenToId.get(tokenId) <= currentTime)\\n            return;\\n        int curr = tokenToId.get(tokenId);\\n        IdToToken.remove(curr);\\n        IdToToken.put(currentTime+ttl, tokenId);\\n        tokenToId.put(tokenId, currentTime+ttl);\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        return IdToToken.tailMap(currentTime, false).size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass AuthenticationManager {\\n    HashMap<String, Integer> tokenToId = new HashMap<>();\\n    TreeMap<Integer, String> IdToToken = new TreeMap<>();\\n    int ttl = 0;\\n\\n    public AuthenticationManager(int timeToLive) {\\n        ttl = timeToLive;\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        tokenToId.put(tokenId, currentTime+ttl);\\n        IdToToken.put(currentTime+ttl, tokenId);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        if (!tokenToId.containsKey(tokenId) || tokenToId.get(tokenId) <= currentTime)\\n            return;\\n        int curr = tokenToId.get(tokenId);\\n        IdToToken.remove(curr);\\n        IdToToken.put(currentTime+ttl, tokenId);\\n        tokenToId.put(tokenId, currentTime+ttl);\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        return IdToToken.tailMap(currentTime, false).size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326508,
                "title": "c-clean-hashmap",
                "content": "\\n\\n# Code\\n```\\nclass AuthenticationManager {\\npublic:unordered_map<string,int> p;\\n    int t=0;\\n    AuthenticationManager(int timeToLive) {\\n        t=timeToLive;\\n    }\\n    \\n    void generate(string tk, int ct) {\\n        p[tk]=ct;\\n    }\\n    \\n    void renew(string tk, int ct) {\\n        if(p.count(tk)>0 && p[tk]+t>ct)\\n         {\\n             p[tk]=ct;\\n         }\\n    }\\n    \\n    int countUnexpiredTokens(int ct) {\\n        int c=0;\\n        for(auto i : p)\\n        {\\n            if(i.second+t>ct)\\n            c++;\\n        }\\n        return c;\\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass AuthenticationManager {\\npublic:unordered_map<string,int> p;\\n    int t=0;\\n    AuthenticationManager(int timeToLive) {\\n        t=timeToLive;\\n    }\\n    \\n    void generate(string tk, int ct) {\\n        p[tk]=ct;\\n    }\\n    \\n    void renew(string tk, int ct) {\\n        if(p.count(tk)>0 && p[tk]+t>ct)\\n         {\\n             p[tk]=ct;\\n         }\\n    }\\n    \\n    int countUnexpiredTokens(int ct) {\\n        int c=0;\\n        for(auto i : p)\\n        {\\n            if(i.second+t>ct)\\n            c++;\\n        }\\n        return c;\\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3323707,
                "title": "simple-hash-map-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass AuthenticationManager {\\npublic: \\n    unordered_map<string,int> umap;\\n    int tar;\\n    AuthenticationManager(int timeToLive) {\\n        this->tar = timeToLive;\\n    }\\n    \\n    void generate(string tok, int curr) {\\n        if(umap.find(tok)!=umap.end()) return;\\n        umap[tok] = curr+tar;\\n    }\\n    \\n    void renew(string tok, int curr) {\\n    \\n        if(umap.find(tok)==umap.end()) return;\\n        if(umap[tok]>curr) umap[tok] = curr+tar;\\n    \\n    }\\n    \\n    int countUnexpiredTokens(int curr) {\\n        int cnt = 0;\\n        for(auto iter : umap){\\n            if(iter.second>curr and iter.second-tar<=curr){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Design"
                ],
                "code": "```\\nclass AuthenticationManager {\\npublic: \\n    unordered_map<string,int> umap;\\n    int tar;\\n    AuthenticationManager(int timeToLive) {\\n        this->tar = timeToLive;\\n    }\\n    \\n    void generate(string tok, int curr) {\\n        if(umap.find(tok)!=umap.end()) return;\\n        umap[tok] = curr+tar;\\n    }\\n    \\n    void renew(string tok, int curr) {\\n    \\n        if(umap.find(tok)==umap.end()) return;\\n        if(umap[tok]>curr) umap[tok] = curr+tar;\\n    \\n    }\\n    \\n    int countUnexpiredTokens(int curr) {\\n        int cnt = 0;\\n        for(auto iter : umap){\\n            if(iter.second>curr and iter.second-tar<=curr){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3322245,
                "title": "java-with-map",
                "content": "\\n\\n# Code\\n```\\nclass AuthenticationManager {\\n    private int timeToLive;\\n    Map<String, Integer> tokens;\\n\\n    public AuthenticationManager(int timeToLive) {\\n        this.timeToLive = timeToLive;\\n        this.tokens = new HashMap<>();\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        tokens.put(tokenId, currentTime + timeToLive);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        if (tokens.containsKey(tokenId) && tokens.get(tokenId) > currentTime)\\n            tokens.put(tokenId, currentTime + timeToLive);\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        int count = 0;\\n        \\n        for (int tokeTime: tokens.values())\\n            count = tokeTime > currentTime ? count + 1 : count;\\n\\n        return count;\\n    }\\n}\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager obj = new AuthenticationManager(timeToLive);\\n * obj.generate(tokenId,currentTime);\\n * obj.renew(tokenId,currentTime);\\n * int param_3 = obj.countUnexpiredTokens(currentTime);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass AuthenticationManager {\\n    private int timeToLive;\\n    Map<String, Integer> tokens;\\n\\n    public AuthenticationManager(int timeToLive) {\\n        this.timeToLive = timeToLive;\\n        this.tokens = new HashMap<>();\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        tokens.put(tokenId, currentTime + timeToLive);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        if (tokens.containsKey(tokenId) && tokens.get(tokenId) > currentTime)\\n            tokens.put(tokenId, currentTime + timeToLive);\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        int count = 0;\\n        \\n        for (int tokeTime: tokens.values())\\n            count = tokeTime > currentTime ? count + 1 : count;\\n\\n        return count;\\n    }\\n}\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager obj = new AuthenticationManager(timeToLive);\\n * obj.generate(tokenId,currentTime);\\n * obj.renew(tokenId,currentTime);\\n * int param_3 = obj.countUnexpiredTokens(currentTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317180,
                "title": "python-two-hash-maps-explained",
                "content": "We use two hashmaps to solve the problem:\\n(1) the first hashmap maps the tokenId to the expiration time of the Id\\n(2) the second hashmap maps the exipration time to a list of tokens that will expire at the time\\n\\nFor the generate method, we first check if the tokenId\\'s expiration time is smaller or equal to the currentTime. In this case, we update the hashmap to remove all the tokenIds that are already exipred.\\n\\nFor the renew method, we can do the same time to remove all the expired tokenId, and then renew the tokenId\\'s expiration time.\\n\\n```\\nclass AuthenticationManager:\\n\\n    def __init__(self, timeToLive: int):\\n        self.ttl = timeToLive\\n        # maps the tokenId to the\\n        self.token_expire_map = collections.defaultdict(int)\\n        # maps the expire time to tokenId list that will expire at the expire time\\n        self.expire_tokens_map = collections.defaultdict(set)\\n        \\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        if tokenId in self.token_expire_map:\\n            # remove the old expiration time info\\n            prev_expire_time = self.token_expire_map[tokenId]\\n            if prev_expire_time <= currentTime:\\n                expired_tokenIds = self.expire_tokens_map[prev_expire_time]\\n                for tokenId in expired_tokenIds:\\n                    del self.token_expire_map[tokenId]\\n                del self.expire_tokens_map[prev_expire_time]\\n        next_expire_time = currentTime + self.ttl\\n        self.token_expire_map[tokenId] = next_expire_time\\n        self.expire_tokens_map[next_expire_time].add(tokenId)\\n\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if tokenId in self.token_expire_map:\\n            prev_expire_time = self.token_expire_map[tokenId]\\n            if prev_expire_time <= currentTime:\\n                expired_tokenIds = self.expire_tokens_map[prev_expire_time]\\n                for tokenId in expired_tokenIds:\\n                    del self.token_expire_map[tokenId]\\n                del self.expire_tokens_map[prev_expire_time]\\n            else:\\n                # renew the expire time\\n                self.expire_tokens_map[prev_expire_time].remove(tokenId)\\n                next_expire_time = currentTime + self.ttl\\n                self.token_expire_map[tokenId] = next_expire_time\\n                self.expire_tokens_map[next_expire_time].add(tokenId)\\n        \\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        t_cnt = 0\\n        for expire_time in self.expire_tokens_map:\\n            if expire_time > currentTime:\\n                t_cnt += len(self.expire_tokens_map[expire_time])\\n        return t_cnt\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass AuthenticationManager:\\n\\n    def __init__(self, timeToLive: int):\\n        self.ttl = timeToLive\\n        # maps the tokenId to the\\n        self.token_expire_map = collections.defaultdict(int)\\n        # maps the expire time to tokenId list that will expire at the expire time\\n        self.expire_tokens_map = collections.defaultdict(set)\\n        \\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        if tokenId in self.token_expire_map:\\n            # remove the old expiration time info\\n            prev_expire_time = self.token_expire_map[tokenId]\\n            if prev_expire_time <= currentTime:\\n                expired_tokenIds = self.expire_tokens_map[prev_expire_time]\\n                for tokenId in expired_tokenIds:\\n                    del self.token_expire_map[tokenId]\\n                del self.expire_tokens_map[prev_expire_time]\\n        next_expire_time = currentTime + self.ttl\\n        self.token_expire_map[tokenId] = next_expire_time\\n        self.expire_tokens_map[next_expire_time].add(tokenId)\\n\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if tokenId in self.token_expire_map:\\n            prev_expire_time = self.token_expire_map[tokenId]\\n            if prev_expire_time <= currentTime:\\n                expired_tokenIds = self.expire_tokens_map[prev_expire_time]\\n                for tokenId in expired_tokenIds:\\n                    del self.token_expire_map[tokenId]\\n                del self.expire_tokens_map[prev_expire_time]\\n            else:\\n                # renew the expire time\\n                self.expire_tokens_map[prev_expire_time].remove(tokenId)\\n                next_expire_time = currentTime + self.ttl\\n                self.token_expire_map[tokenId] = next_expire_time\\n                self.expire_tokens_map[next_expire_time].add(tokenId)\\n        \\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        t_cnt = 0\\n        for expire_time in self.expire_tokens_map:\\n            if expire_time > currentTime:\\n                t_cnt += len(self.expire_tokens_map[expire_time])\\n        return t_cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3307367,
                "title": "a-beginner-s-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Using HashMap**\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass AuthenticationManager {\\npublic:\\n    int time = 0;\\n    unordered_map<string, int> mp;\\n    AuthenticationManager(int timeToLive) {\\n        this -> time = timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        // calculating tht total time till the token expires\\n        int timeToLive = time + currentTime;\\n        mp[tokenId] = timeToLive;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        // if we find the string in the hashmap then only we will proceed\\n        if(mp.find(tokenId) != mp.end()){\\n            // checking whether the token has not expired\\n            if(mp[tokenId] > currentTime){\\n                mp[tokenId] = currentTime + time;\\n            }\\n        }\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int cnt = 0;\\n        for(auto i: mp){\\n            if(i.second > currentTime){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass AuthenticationManager {\\npublic:\\n    int time = 0;\\n    unordered_map<string, int> mp;\\n    AuthenticationManager(int timeToLive) {\\n        this -> time = timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        // calculating tht total time till the token expires\\n        int timeToLive = time + currentTime;\\n        mp[tokenId] = timeToLive;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        // if we find the string in the hashmap then only we will proceed\\n        if(mp.find(tokenId) != mp.end()){\\n            // checking whether the token has not expired\\n            if(mp[tokenId] > currentTime){\\n                mp[tokenId] = currentTime + time;\\n            }\\n        }\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int cnt = 0;\\n        for(auto i: mp){\\n            if(i.second > currentTime){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306180,
                "title": "c",
                "content": "```\\nclass AuthenticationManager {\\nprivate:\\n    int timeToLive ;\\n    unordered_map<string, int>Map ;\\npublic:\\n    AuthenticationManager(int timeToLive) {\\n        this->timeToLive = timeToLive ;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        Map[tokenId] = currentTime + timeToLive ;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if(Map.find(tokenId) != Map.end() && Map[tokenId] > currentTime)\\n        {\\n            Map[tokenId] = currentTime + timeToLive ;    \\n        }    \\n        \\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int ret = 0 ;\\n        for(auto& m : Map){\\n            if(m.second > currentTime)\\n                ret++ ;\\n        }\\n        return ret ;\\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass AuthenticationManager {\\nprivate:\\n    int timeToLive ;\\n    unordered_map<string, int>Map ;\\npublic:\\n    AuthenticationManager(int timeToLive) {\\n        this->timeToLive = timeToLive ;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        Map[tokenId] = currentTime + timeToLive ;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if(Map.find(tokenId) != Map.end() && Map[tokenId] > currentTime)\\n        {\\n            Map[tokenId] = currentTime + timeToLive ;    \\n        }    \\n        \\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int ret = 0 ;\\n        for(auto& m : Map){\\n            if(m.second > currentTime)\\n                ret++ ;\\n        }\\n        return ret ;\\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284062,
                "title": "python3-queue-with-explanation-amortized-time-o-1-beats-99",
                "content": "# Intuition\\nFailed this question at a job interview, so glad I found it at leetcode. The trick to optimal solution is to consider amortized time for countUnexpiredTokens method. \\n\\nUse two data structures:\\n- live_tokens hashmap for storing count of live tokens (each successful call to method renew will increase count by one)\\n- timeline queue for storing each generate/renew events\\n\\nAnd also helper method _prune function which will pop expired tokens from timeline queue. When number of live tokens hits zero, then we no longer count token as active in countUnexpiredTokens method.\\n\\n# Complexity\\nn is number of calls to generate/renew methods\\n\\n- Time complexity:\\n1. generate method: O(1)\\n1. renew method: asymptotic O(n) amortized O(1)\\n1. countUnexpiredTokens method: asymptotic O(n) amortized O(1)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass AuthenticationManager:\\n\\n    def __init__(self, timeToLive: int):\\n        self.ttl = timeToLive\\n        self.live_tokens = {}\\n        self.timeline = deque()\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self.live_tokens[tokenId] = 1\\n        self.timeline.append((currentTime, tokenId))\\n    \\n    def _prune(self, currentTime):\\n        while self.timeline and self.timeline[0][0] <= (currentTime - self.ttl):\\n            _, token = self.timeline.popleft()\\n            self.live_tokens[token] -= 1\\n            if self.live_tokens[token] == 0:\\n                del self.live_tokens[token]\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        self._prune(currentTime)\\n        if tokenId in self.live_tokens:\\n            self.live_tokens[tokenId] += 1\\n            self.timeline.append((currentTime, tokenId))        \\n        \\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        self._prune(currentTime)\\n        return len(self.live_tokens)\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Queue"
                ],
                "code": "```\\nclass AuthenticationManager:\\n\\n    def __init__(self, timeToLive: int):\\n        self.ttl = timeToLive\\n        self.live_tokens = {}\\n        self.timeline = deque()\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self.live_tokens[tokenId] = 1\\n        self.timeline.append((currentTime, tokenId))\\n    \\n    def _prune(self, currentTime):\\n        while self.timeline and self.timeline[0][0] <= (currentTime - self.ttl):\\n            _, token = self.timeline.popleft()\\n            self.live_tokens[token] -= 1\\n            if self.live_tokens[token] == 0:\\n                del self.live_tokens[token]\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        self._prune(currentTime)\\n        if tokenId in self.live_tokens:\\n            self.live_tokens[tokenId] += 1\\n            self.timeline.append((currentTime, tokenId))        \\n        \\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        self._prune(currentTime)\\n        return len(self.live_tokens)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274548,
                "title": "simple-c-solution-using-dictionary-for-storing-tokens-beats-81",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class AuthenticationManager {\\n    private int ttl {get;set;}\\n    private Dictionary<string,int> dic {get;set;}\\n    public AuthenticationManager(int timeToLive) {\\n        ttl=timeToLive;\\n        dic= new();\\n    }\\n    \\n    public void Generate(string tokenId, int currentTime) {\\n        dic.Add(tokenId,ttl+currentTime);\\n    }\\n    \\n    public void Renew(string tokenId, int currentTime) {\\n        if(dic.ContainsKey(tokenId) && dic[tokenId]>currentTime) dic[tokenId]=ttl+currentTime;\\n    }\\n    \\n    public int CountUnexpiredTokens(int currentTime) {\\n        foreach(var item in dic.Where(kvp => kvp.Value <= currentTime).ToList()) dic.Remove(item.Key);\\n        return dic.Count();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class AuthenticationManager {\\n    private int ttl {get;set;}\\n    private Dictionary<string,int> dic {get;set;}\\n    public AuthenticationManager(int timeToLive) {\\n        ttl=timeToLive;\\n        dic= new();\\n    }\\n    \\n    public void Generate(string tokenId, int currentTime) {\\n        dic.Add(tokenId,ttl+currentTime);\\n    }\\n    \\n    public void Renew(string tokenId, int currentTime) {\\n        if(dic.ContainsKey(tokenId) && dic[tokenId]>currentTime) dic[tokenId]=ttl+currentTime;\\n    }\\n    \\n    public int CountUnexpiredTokens(int currentTime) {\\n        foreach(var item in dic.Where(kvp => kvp.Value <= currentTime).ToList()) dic.Remove(item.Key);\\n        return dic.Count();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3273106,
                "title": "easy-solution-with-comments-c-dictionary",
                "content": "I think it should be easy\\n```\\npublic class AuthenticationManager {\\n\\n    private int _timeToLive;\\n    private Dictionary<string, int> tokens;\\n    \\n    public AuthenticationManager(int timeToLive) {\\n        tokens = new Dictionary<string, int>();\\n        _timeToLive = timeToLive;\\n    }\\n    \\n    public void Generate(string tokenId, int currentTime) {\\n        // the Key is tokenId\\n        // the Value is time of token\\'s expiration\\n        tokens.Add(tokenId, currentTime + _timeToLive);\\n    }\\n    \\n    public void Renew(string tokenId, int currentTime) {\\n        // renew token if this token already exist and is unexpired\\n        if (tokens.ContainsKey(tokenId) && tokens[tokenId] > currentTime){\\n            tokens[tokenId] = currentTime + _timeToLive;\\n        }\\n    }\\n    \\n    public int CountUnexpiredTokens(int currentTime) {\\n        foreach (var token in tokens){\\n            // delete expired tokens, we don\\'t need them anymore\\n            if (token.Value <= currentTime){\\n                tokens.Remove(token.Key);\\n            }\\n        }\\n        return tokens.Count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class AuthenticationManager {\\n\\n    private int _timeToLive;\\n    private Dictionary<string, int> tokens;\\n    \\n    public AuthenticationManager(int timeToLive) {\\n        tokens = new Dictionary<string, int>();\\n        _timeToLive = timeToLive;\\n    }\\n    \\n    public void Generate(string tokenId, int currentTime) {\\n        // the Key is tokenId\\n        // the Value is time of token\\'s expiration\\n        tokens.Add(tokenId, currentTime + _timeToLive);\\n    }\\n    \\n    public void Renew(string tokenId, int currentTime) {\\n        // renew token if this token already exist and is unexpired\\n        if (tokens.ContainsKey(tokenId) && tokens[tokenId] > currentTime){\\n            tokens[tokenId] = currentTime + _timeToLive;\\n        }\\n    }\\n    \\n    public int CountUnexpiredTokens(int currentTime) {\\n        foreach (var token in tokens){\\n            // delete expired tokens, we don\\'t need them anymore\\n            if (token.Value <= currentTime){\\n                tokens.Remove(token.Key);\\n            }\\n        }\\n        return tokens.Count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232624,
                "title": "java-beats-92-using-map-pair",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass AuthenticationManager {\\n\\n    private final Map<String, Pair<Integer,Integer>> slotTimeTokens;\\n    private final int timeToLive;\\n\\n    public AuthenticationManager(int timeToLive) {\\n        this.timeToLive = timeToLive;\\n        this.slotTimeTokens = new HashMap<>();\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        slotTimeTokens.put(tokenId, new Pair<>(currentTime, currentTime + timeToLive));\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        Pair<Integer,Integer> pair = slotTimeTokens.get(tokenId);\\n        if(pair == null){\\n            return;\\n        }\\n\\n        if(currentTime >= pair.getValue()){\\n            return;\\n        }\\n\\n        slotTimeTokens.put(tokenId, new Pair<>(currentTime, currentTime + timeToLive));\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        int cnt = 0;\\n        return (int) slotTimeTokens.values().stream().filter(p -> p.getValue() > currentTime).count();\\n    }\\n\\n\\n    class Pair<K,V>{\\n\\n        private K key;\\n        private V value;\\n\\n        public Pair(K key, V value){\\n            this.key = key;\\n            this.value = value;\\n        }\\n\\n        public K getKey(){\\n            return this.key;\\n        }\\n\\n        public V getValue(){\\n            return this.value;\\n        }\\n\\n    }\\n}\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager obj = new AuthenticationManager(timeToLive);\\n * obj.generate(tokenId,currentTime);\\n * obj.renew(tokenId,currentTime);\\n * int param_3 = obj.countUnexpiredTokens(currentTime);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass AuthenticationManager {\\n\\n    private final Map<String, Pair<Integer,Integer>> slotTimeTokens;\\n    private final int timeToLive;\\n\\n    public AuthenticationManager(int timeToLive) {\\n        this.timeToLive = timeToLive;\\n        this.slotTimeTokens = new HashMap<>();\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        slotTimeTokens.put(tokenId, new Pair<>(currentTime, currentTime + timeToLive));\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        Pair<Integer,Integer> pair = slotTimeTokens.get(tokenId);\\n        if(pair == null){\\n            return;\\n        }\\n\\n        if(currentTime >= pair.getValue()){\\n            return;\\n        }\\n\\n        slotTimeTokens.put(tokenId, new Pair<>(currentTime, currentTime + timeToLive));\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        int cnt = 0;\\n        return (int) slotTimeTokens.values().stream().filter(p -> p.getValue() > currentTime).count();\\n    }\\n\\n\\n    class Pair<K,V>{\\n\\n        private K key;\\n        private V value;\\n\\n        public Pair(K key, V value){\\n            this.key = key;\\n            this.value = value;\\n        }\\n\\n        public K getKey(){\\n            return this.key;\\n        }\\n\\n        public V getValue(){\\n            return this.value;\\n        }\\n\\n    }\\n}\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager obj = new AuthenticationManager(timeToLive);\\n * obj.generate(tokenId,currentTime);\\n * obj.renew(tokenId,currentTime);\\n * int param_3 = obj.countUnexpiredTokens(currentTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225691,
                "title": "javascript-map",
                "content": "# Code\\n```\\n// O(n)\\nvar AuthenticationManager = function(timeToLive) {\\n    this.ttl = timeToLive;\\n    this.map = {};\\n};\\nAuthenticationManager.prototype.generate = function(tokenId, currentTime) {\\n    this.map[tokenId] = currentTime + this.ttl;\\n};\\nAuthenticationManager.prototype.renew = function(tokenId, currentTime) {\\n    let curr = this.map[tokenId];\\n    if (curr > currentTime) {\\n        this.generate(tokenId, currentTime);\\n    }\\n};\\nAuthenticationManager.prototype.countUnexpiredTokens = function(currentTime) {\\n    return Object.keys(this.map).filter(key => this.map[key] > currentTime).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// O(n)\\nvar AuthenticationManager = function(timeToLive) {\\n    this.ttl = timeToLive;\\n    this.map = {};\\n};\\nAuthenticationManager.prototype.generate = function(tokenId, currentTime) {\\n    this.map[tokenId] = currentTime + this.ttl;\\n};\\nAuthenticationManager.prototype.renew = function(tokenId, currentTime) {\\n    let curr = this.map[tokenId];\\n    if (curr > currentTime) {\\n        this.generate(tokenId, currentTime);\\n    }\\n};\\nAuthenticationManager.prototype.countUnexpiredTokens = function(currentTime) {\\n    return Object.keys(this.map).filter(key => this.map[key] > currentTime).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3225371,
                "title": "solution-in-c",
                "content": "```\\nclass AuthenticationManager {\\npublic:\\n    int n;\\n    AuthenticationManager(int timeToLive) {\\n        n = timeToLive;\\n    }\\n    unordered_map<string, int> mp;\\n    void generate(string tokenId, int currentTime) {\\n        if(mp.find(tokenId) == mp.end()){\\n            mp.insert({tokenId, currentTime});\\n        }\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if(mp.find(tokenId) != mp.end()){\\n            if(n + mp[tokenId] > currentTime){\\n                mp[tokenId] = currentTime;\\n            }\\n        }\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int ans = 0;\\n        for(auto x : mp){\\n            if(x.second + n > currentTime){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass AuthenticationManager {\\npublic:\\n    int n;\\n    AuthenticationManager(int timeToLive) {\\n        n = timeToLive;\\n    }\\n    unordered_map<string, int> mp;\\n    void generate(string tokenId, int currentTime) {\\n        if(mp.find(tokenId) == mp.end()){\\n            mp.insert({tokenId, currentTime});\\n        }\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if(mp.find(tokenId) != mp.end()){\\n            if(n + mp[tokenId] > currentTime){\\n                mp[tokenId] = currentTime;\\n            }\\n        }\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int ans = 0;\\n        for(auto x : mp){\\n            if(x.second + n > currentTime){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3221042,
                "title": "c-easy-best",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass AuthenticationManager {\\npublic:\\n    int time ;\\n    unordered_map<string ,int> mp;\\n    AuthenticationManager(int timeToLive) {\\n        time = timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        mp[tokenId] = currentTime + time;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if(mp.find(tokenId) != mp.end() && mp[tokenId] > currentTime){\\n            mp[tokenId] = currentTime + time;\\n        }\\n        return;\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int ans = 0;\\n        for(auto i:mp){\\n            if(i.second > currentTime){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass AuthenticationManager {\\npublic:\\n    int time ;\\n    unordered_map<string ,int> mp;\\n    AuthenticationManager(int timeToLive) {\\n        time = timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        mp[tokenId] = currentTime + time;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if(mp.find(tokenId) != mp.end() && mp[tokenId] > currentTime){\\n            mp[tokenId] = currentTime + time;\\n        }\\n        return;\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int ans = 0;\\n        for(auto i:mp){\\n            if(i.second > currentTime){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3186723,
                "title": "java-solution-easy-to-understand",
                "content": "# Approach\\nUsing TreeSet for it\\'s ordering advantage. Makes it easy to delete all the expired tokens.\\n\\n# Complexity\\n- Time complexity:\\nO(timeToLive)\\n\\n- Space complexity:\\nO(timeToLive)\\n\\n# Code\\n```\\nclass AuthenticationManager {\\n\\n    public class Token implements Comparable<Token> {\\n\\n        public final String id;\\n        public final int expirationDate;\\n\\n        public Token(String id, int currentTime, int time) {\\n            this.id = id;\\n            this.expirationDate = currentTime + time;\\n        }\\n\\n        public int compareTo(Token other) {\\n            return this.expirationDate - other.expirationDate;\\n        }\\n\\n    }\\n\\n    private int timeToLive;\\n    private TreeSet<Token> currentTokens;\\n    private Map<String, Token> idToTokens;\\n\\n    public AuthenticationManager(int timeToLive) {\\n        this.timeToLive = timeToLive;\\n        this.currentTokens = new TreeSet<>();\\n        this.idToTokens = new HashMap<>();\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        deleteAllExpired(currentTime);\\n        Token token = new Token(tokenId, currentTime, this.timeToLive);\\n        this.idToTokens.put(tokenId, token);\\n        this.currentTokens.add(token);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        deleteAllExpired(currentTime);\\n        if (this.idToTokens.containsKey(tokenId)) {\\n            Token token = this.idToTokens.get(tokenId);\\n            this.currentTokens.remove(token);\\n            Token renewed = new Token(tokenId, currentTime, this.timeToLive);\\n            this.idToTokens.put(tokenId, renewed);\\n            this.currentTokens.add(renewed);\\n        }\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        deleteAllExpired(currentTime);\\n        return this.currentTokens.size();\\n    }\\n\\n    private void deleteAllExpired(int currentTime) {\\n        for (Iterator i = this.currentTokens.iterator(); i.hasNext();) {\\n            Token token = (Token) i.next();\\n            if (token.expirationDate > currentTime) break;\\n            i.remove();\\n            this.idToTokens.remove(token.id);\\n        }\\n    }\\n}\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager obj = new AuthenticationManager(timeToLive);\\n * obj.generate(tokenId,currentTime);\\n * obj.renew(tokenId,currentTime);\\n * int param_3 = obj.countUnexpiredTokens(currentTime);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Design",
                    "Iterator"
                ],
                "code": "```\\nclass AuthenticationManager {\\n\\n    public class Token implements Comparable<Token> {\\n\\n        public final String id;\\n        public final int expirationDate;\\n\\n        public Token(String id, int currentTime, int time) {\\n            this.id = id;\\n            this.expirationDate = currentTime + time;\\n        }\\n\\n        public int compareTo(Token other) {\\n            return this.expirationDate - other.expirationDate;\\n        }\\n\\n    }\\n\\n    private int timeToLive;\\n    private TreeSet<Token> currentTokens;\\n    private Map<String, Token> idToTokens;\\n\\n    public AuthenticationManager(int timeToLive) {\\n        this.timeToLive = timeToLive;\\n        this.currentTokens = new TreeSet<>();\\n        this.idToTokens = new HashMap<>();\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        deleteAllExpired(currentTime);\\n        Token token = new Token(tokenId, currentTime, this.timeToLive);\\n        this.idToTokens.put(tokenId, token);\\n        this.currentTokens.add(token);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        deleteAllExpired(currentTime);\\n        if (this.idToTokens.containsKey(tokenId)) {\\n            Token token = this.idToTokens.get(tokenId);\\n            this.currentTokens.remove(token);\\n            Token renewed = new Token(tokenId, currentTime, this.timeToLive);\\n            this.idToTokens.put(tokenId, renewed);\\n            this.currentTokens.add(renewed);\\n        }\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        deleteAllExpired(currentTime);\\n        return this.currentTokens.size();\\n    }\\n\\n    private void deleteAllExpired(int currentTime) {\\n        for (Iterator i = this.currentTokens.iterator(); i.hasNext();) {\\n            Token token = (Token) i.next();\\n            if (token.expirationDate > currentTime) break;\\n            i.remove();\\n            this.idToTokens.remove(token.id);\\n        }\\n    }\\n}\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager obj = new AuthenticationManager(timeToLive);\\n * obj.generate(tokenId,currentTime);\\n * obj.renew(tokenId,currentTime);\\n * int param_3 = obj.countUnexpiredTokens(currentTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3184405,
                "title": "python3-dict-linked-list-solution-beats-98-in-time",
                "content": "The idea is to implement queue with custom Doubly linked list and store reference to nodes into dictionary:\\n- generate: create new node and append it to queue. save reference to tokenToNode map (dictionary).\\n- renew: find node for the token using tokenToNode dictionary. Remove this node from queue. This is possible because we know prev and next nodes. Update the expiration date and add the append node again.\\n- countUnexpiredTokens: while there is a node and it\\'s token expired remove it. Then just return the number of remaining nodes.\\n```\\nclass Node:\\n    def __init__(self, val):\\n        self.val = val\\n        self.next = None\\n        self.prev = None\\n        \\n        \\nclass DllQueue:\\n    def __init__(self):\\n        self.head = Node(0)\\n        self.tail = Node(-1)\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n        self.size = 0\\n    \\n    def append(self, node):\\n        prev = self.tail.prev\\n        next = self.tail\\n        \\n        node.prev = prev\\n        node.next = next\\n        \\n        prev.next = node\\n        next.prev = node\\n        \\n        self.size += 1\\n        return node\\n    \\n    def front(self):\\n        return self.head.next.val\\n    \\n    def pop(self):\\n        cur = self.remove(self.head.next)\\n        val = cur.val\\n        del cur\\n        return val\\n        \\n    def remove(self, cur):\\n        prev = cur.prev\\n        next = cur.next\\n        \\n        prev.next = cur.next\\n        next.prev = prev\\n        \\n        cur.next = None\\n        cur.prev = None\\n        \\n        self.size -= 1\\n        return cur\\n    \\n    def __len__(self):\\n        return self.size\\n\\n    \\nclass AuthenticationManager:\\n\\n    def __init__(self, timeToLive: int):\\n        self.ttl = timeToLive\\n        self.q = DllQueue()\\n        self.tokenToNode = dict()\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        expTime = currentTime + self.ttl\\n        node = self.q.append(Node([tokenId, expTime]))\\n        self.tokenToNode[tokenId] = node\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        node = self.tokenToNode.get(tokenId, None)\\n        if node:\\n            self.q.remove(node)\\n            if node.val[1] > currentTime:\\n                node.val[1] = currentTime + self.ttl\\n                self.q.append(node)\\n            else:\\n                del self.tokenToNode[tokenId]\\n    \\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        while len(self.q) and self.q.front()[1] <= currentTime:\\n            token = self.q.pop()[0]\\n            del self.tokenToNode[token]\\n        return len(self.q)\\n```",
                "solutionTags": [
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self, val):\\n        self.val = val\\n        self.next = None\\n        self.prev = None\\n        \\n        \\nclass DllQueue:\\n    def __init__(self):\\n        self.head = Node(0)\\n        self.tail = Node(-1)\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n        self.size = 0\\n    \\n    def append(self, node):\\n        prev = self.tail.prev\\n        next = self.tail\\n        \\n        node.prev = prev\\n        node.next = next\\n        \\n        prev.next = node\\n        next.prev = node\\n        \\n        self.size += 1\\n        return node\\n    \\n    def front(self):\\n        return self.head.next.val\\n    \\n    def pop(self):\\n        cur = self.remove(self.head.next)\\n        val = cur.val\\n        del cur\\n        return val\\n        \\n    def remove(self, cur):\\n        prev = cur.prev\\n        next = cur.next\\n        \\n        prev.next = cur.next\\n        next.prev = prev\\n        \\n        cur.next = None\\n        cur.prev = None\\n        \\n        self.size -= 1\\n        return cur\\n    \\n    def __len__(self):\\n        return self.size\\n\\n    \\nclass AuthenticationManager:\\n\\n    def __init__(self, timeToLive: int):\\n        self.ttl = timeToLive\\n        self.q = DllQueue()\\n        self.tokenToNode = dict()\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        expTime = currentTime + self.ttl\\n        node = self.q.append(Node([tokenId, expTime]))\\n        self.tokenToNode[tokenId] = node\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        node = self.tokenToNode.get(tokenId, None)\\n        if node:\\n            self.q.remove(node)\\n            if node.val[1] > currentTime:\\n                node.val[1] = currentTime + self.ttl\\n                self.q.append(node)\\n            else:\\n                del self.tokenToNode[tokenId]\\n    \\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        while len(self.q) and self.q.front()[1] <= currentTime:\\n            token = self.q.pop()[0]\\n            del self.tokenToNode[token]\\n        return len(self.q)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3164054,
                "title": "simple-hashmap",
                "content": "# Approach\\n- HashMap to store token key as string and time of expiry for token\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$?\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.HashMap;\\n\\nclass AuthenticationManager {\\n    private HashMap<String, Integer> tokens;\\n    private int timeToLive;\\n\\n    public AuthenticationManager(int timeToLive) {\\n        this.timeToLive = timeToLive;\\n        this.tokens = new HashMap<String, Integer>();\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        this.tokens.put(tokenId, currentTime + this.timeToLive);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        if (!this.tokens.isEmpty() && this.tokens.keySet().contains(tokenId)) {\\n            if (this.tokens.get(tokenId) > currentTime) {\\n                this.tokens.put(tokenId, currentTime + this.timeToLive);\\n            }\\n        }\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        int counter = 0;\\n        for (int expiry : this.tokens.values()) {\\n            if (expiry > currentTime) {\\n                counter++;\\n            }\\n        }\\n        return counter;\\n    }\\n}\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager obj = new AuthenticationManager(timeToLive);\\n * obj.generate(tokenId,currentTime);\\n * obj.renew(tokenId,currentTime);\\n * int param_3 = obj.countUnexpiredTokens(currentTime);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.HashMap;\\n\\nclass AuthenticationManager {\\n    private HashMap<String, Integer> tokens;\\n    private int timeToLive;\\n\\n    public AuthenticationManager(int timeToLive) {\\n        this.timeToLive = timeToLive;\\n        this.tokens = new HashMap<String, Integer>();\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        this.tokens.put(tokenId, currentTime + this.timeToLive);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        if (!this.tokens.isEmpty() && this.tokens.keySet().contains(tokenId)) {\\n            if (this.tokens.get(tokenId) > currentTime) {\\n                this.tokens.put(tokenId, currentTime + this.timeToLive);\\n            }\\n        }\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        int counter = 0;\\n        for (int expiry : this.tokens.values()) {\\n            if (expiry > currentTime) {\\n                counter++;\\n            }\\n        }\\n        return counter;\\n    }\\n}\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager obj = new AuthenticationManager(timeToLive);\\n * obj.generate(tokenId,currentTime);\\n * obj.renew(tokenId,currentTime);\\n * int param_3 = obj.countUnexpiredTokens(currentTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3157080,
                "title": "c-easy-to-understand-hashmap",
                "content": "```\\nclass AuthenticationManager {\\npublic:\\n    map<string,int>mp;\\n    int ttl = 0;\\n    AuthenticationManager(int timeToLive) {\\n        ttl = timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        //cout<<\"Generate : \"<<tokenId<<\" at \"<< currentTime<<endl;\\n        mp[tokenId]=currentTime+ttl;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        //cout<<\"Renew : \"<<tokenId<<\" at \"<< currentTime<<endl;\\n        if(mp[tokenId]>currentTime && mp.find(tokenId)!=mp.end()){\\n            //cout<<\"\\\\t\\\\t\"<<tokenId<<\" regenrated.\"<<endl;\\n            mp[tokenId]=currentTime+ttl;\\n        }\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        //cout<<\"Count : \"<< currentTime<<endl;\\n        int c = 0;\\n        for(auto token:mp){\\n            //cout<<\"\\\\t\\\\t\"<<token.first<<\" \"<<endl;\\n            if(token.second<=currentTime) continue;\\n            else ++c;\\n        }\\n        return c;\\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass AuthenticationManager {\\npublic:\\n    map<string,int>mp;\\n    int ttl = 0;\\n    AuthenticationManager(int timeToLive) {\\n        ttl = timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        //cout<<\"Generate : \"<<tokenId<<\" at \"<< currentTime<<endl;\\n        mp[tokenId]=currentTime+ttl;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        //cout<<\"Renew : \"<<tokenId<<\" at \"<< currentTime<<endl;\\n        if(mp[tokenId]>currentTime && mp.find(tokenId)!=mp.end()){\\n            //cout<<\"\\\\t\\\\t\"<<tokenId<<\" regenrated.\"<<endl;\\n            mp[tokenId]=currentTime+ttl;\\n        }\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        //cout<<\"Count : \"<< currentTime<<endl;\\n        int c = 0;\\n        for(auto token:mp){\\n            //cout<<\"\\\\t\\\\t\"<<token.first<<\" \"<<endl;\\n            if(token.second<=currentTime) continue;\\n            else ++c;\\n        }\\n        return c;\\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3144900,
                "title": "easy-python-solution-using-dict",
                "content": "```\\nclass AuthenticationManager:\\n\\n    def __init__(self, timeToLive: int):\\n        self.timeToLive = timeToLive\\n        self.tokenDict = {}\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self.tokenDict[tokenId] = currentTime + self.timeToLive\\n        # print(\\'generate --> \\', self.tokenDict, tokenId, currentTime)\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if tokenId in self.tokenDict.keys() : \\n            if self.tokenDict[tokenId] > currentTime : \\n                self.tokenDict[tokenId] = currentTime + self.timeToLive\\n\\n        # print(\\'renew --> \\', self.tokenDict, tokenId, currentTime)\\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        # print(\\'count --> \\', self.tokenDict, currentTime)\\n        counter = 0\\n        for key in self.tokenDict.keys() : \\n            if self.tokenDict[key] > currentTime : \\n                counter += 1 \\n        return counter \\n\\n\\n# Your AuthenticationManager object will be instantiated and called as such:\\n# obj = AuthenticationManager(timeToLive)\\n# obj.generate(tokenId,currentTime)\\n# obj.renew(tokenId,currentTime)\\n# param_3 = obj.countUnexpiredTokens(currentTime)\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Design"
                ],
                "code": "```\\nclass AuthenticationManager:\\n\\n    def __init__(self, timeToLive: int):\\n        self.timeToLive = timeToLive\\n        self.tokenDict = {}\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self.tokenDict[tokenId] = currentTime + self.timeToLive\\n        # print(\\'generate --> \\', self.tokenDict, tokenId, currentTime)\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if tokenId in self.tokenDict.keys() : \\n            if self.tokenDict[tokenId] > currentTime : \\n                self.tokenDict[tokenId] = currentTime + self.timeToLive\\n\\n        # print(\\'renew --> \\', self.tokenDict, tokenId, currentTime)\\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        # print(\\'count --> \\', self.tokenDict, currentTime)\\n        counter = 0\\n        for key in self.tokenDict.keys() : \\n            if self.tokenDict[key] > currentTime : \\n                counter += 1 \\n        return counter \\n\\n\\n# Your AuthenticationManager object will be instantiated and called as such:\\n# obj = AuthenticationManager(timeToLive)\\n# obj.generate(tokenId,currentTime)\\n# obj.renew(tokenId,currentTime)\\n# param_3 = obj.countUnexpiredTokens(currentTime)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3139315,
                "title": "python3-clean",
                "content": "# Intuition\\nwe can store just expiration times, that will make renew and count easier\\n\\n\\n# Code\\n```\\nclass AuthenticationManager:\\n\\n    def __init__(self, timeToLive: int):\\n        self._ttl = timeToLive\\n        self._token_expiration_time = {}\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self._token_expiration_time[tokenId] = currentTime + self._ttl\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if self._token_expiration_time.get(tokenId, 0) > currentTime:\\n            self._token_expiration_time[tokenId] = currentTime + self._ttl\\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        result = 0\\n        for token, expiration_time in self._token_expiration_time.items():\\n            if expiration_time > currentTime:\\n                result += 1\\n        return result\\n\\n\\n# Your AuthenticationManager object will be instantiated and called as such:\\n# obj = AuthenticationManager(timeToLive)\\n# obj.generate(tokenId,currentTime)\\n# obj.renew(tokenId,currentTime)\\n# param_3 = obj.countUnexpiredTokens(currentTime)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass AuthenticationManager:\\n\\n    def __init__(self, timeToLive: int):\\n        self._ttl = timeToLive\\n        self._token_expiration_time = {}\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self._token_expiration_time[tokenId] = currentTime + self._ttl\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if self._token_expiration_time.get(tokenId, 0) > currentTime:\\n            self._token_expiration_time[tokenId] = currentTime + self._ttl\\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        result = 0\\n        for token, expiration_time in self._token_expiration_time.items():\\n            if expiration_time > currentTime:\\n                result += 1\\n        return result\\n\\n\\n# Your AuthenticationManager object will be instantiated and called as such:\\n# obj = AuthenticationManager(timeToLive)\\n# obj.generate(tokenId,currentTime)\\n# obj.renew(tokenId,currentTime)\\n# param_3 = obj.countUnexpiredTokens(currentTime)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3135065,
                "title": "using-hashmap-with-explanatory-comments",
                "content": "Keep Practice :)ha\\n\\n# Code\\n```\\nclass AuthenticationManager {\\n    int time=0; //initialize with 0\\n    HashMap<String,Integer> map=new HashMap<>(); // create hashmap with string key and integer value for storing the values\\n    public AuthenticationManager(int timeToLive) {\\n        time=timeToLive; //stores in time\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        map.put(tokenId,currentTime+time);\\n        //insert the given value in hashmap for reference by usinng put method\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        if(!map.containsKey(tokenId)|| map.get(tokenId)<=currentTime){\\n            return;\\n            //as in question says. clearly we implement that statement by using if condition\\n        }\\n        map.put(tokenId,currentTime+time);//or else we have to add currentTime to time\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        List<String> list=new ArrayList<>(map.keySet()); //creating list collection for checkingthe expired tokens. \\n        for(int i=0;i<list.size();i++){\\n            if(map.get(list.get(i))<=currentTime)\\n                map.remove(list.get(i));\\n        }\\n        return map.size(); //required size that we want after iterating whole list \\n    }\\n}\\n\\n//thank you.\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager obj = new AuthenticationManager(timeToLive);\\n * obj.generate(tokenId,currentTime);\\n * obj.renew(tokenId,currentTime);\\n * int param_3 = obj.countUnexpiredTokens(currentTime);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass AuthenticationManager {\\n    int time=0; //initialize with 0\\n    HashMap<String,Integer> map=new HashMap<>(); // create hashmap with string key and integer value for storing the values\\n    public AuthenticationManager(int timeToLive) {\\n        time=timeToLive; //stores in time\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        map.put(tokenId,currentTime+time);\\n        //insert the given value in hashmap for reference by usinng put method\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        if(!map.containsKey(tokenId)|| map.get(tokenId)<=currentTime){\\n            return;\\n            //as in question says. clearly we implement that statement by using if condition\\n        }\\n        map.put(tokenId,currentTime+time);//or else we have to add currentTime to time\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        List<String> list=new ArrayList<>(map.keySet()); //creating list collection for checkingthe expired tokens. \\n        for(int i=0;i<list.size();i++){\\n            if(map.get(list.get(i))<=currentTime)\\n                map.remove(list.get(i));\\n        }\\n        return map.size(); //required size that we want after iterating whole list \\n    }\\n}\\n\\n//thank you.\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager obj = new AuthenticationManager(timeToLive);\\n * obj.generate(tokenId,currentTime);\\n * obj.renew(tokenId,currentTime);\\n * int param_3 = obj.countUnexpiredTokens(currentTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3118299,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass AuthenticationManager {\\n\\n    private int timeToLive;\\n\\n    private Map<String,Integer> tokens;\\n\\n    public AuthenticationManager(int _timeToLive) {\\n        timeToLive = _timeToLive;\\n        tokens = new HashMap<>();\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        tokens.put(tokenId,currentTime);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        if(tokens.get(tokenId) == null) return;\\n        if(isUnexpired(currentTime,tokens.get(tokenId))) tokens.put(tokenId,currentTime);\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        int result = 0;\\n        for (var entry : tokens.entrySet()) {\\n            if(isUnexpired(currentTime, entry.getValue())) result++;\\n        }\\n        return result;\\n    }\\n\\n    public boolean isUnexpired(int currentTime, int creationTime){\\n        return (currentTime - creationTime) < timeToLive;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass AuthenticationManager {\\n\\n    private int timeToLive;\\n\\n    private Map<String,Integer> tokens;\\n\\n    public AuthenticationManager(int _timeToLive) {\\n        timeToLive = _timeToLive;\\n        tokens = new HashMap<>();\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        tokens.put(tokenId,currentTime);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        if(tokens.get(tokenId) == null) return;\\n        if(isUnexpired(currentTime,tokens.get(tokenId))) tokens.put(tokenId,currentTime);\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        int result = 0;\\n        for (var entry : tokens.entrySet()) {\\n            if(isUnexpired(currentTime, entry.getValue())) result++;\\n        }\\n        return result;\\n    }\\n\\n    public boolean isUnexpired(int currentTime, int creationTime){\\n        return (currentTime - creationTime) < timeToLive;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116571,
                "title": "design-authentication-page-c-easy-approach-fast-simple",
                "content": "**IF YOU LIKE, PLEASE UPVOTE. IT HELPS\\u2764\\uFE0F\\u2764\\uFE0F**\\n\\n# Code\\n```\\nclass AuthenticationManager {\\npublic:\\n    using event = tuple<int, bool, string>;\\n    list<event> wheel;\\n    unordered_map<string, list<event>::iterator> session;\\n    int ttl;\\n\\n    AuthenticationManager(int timeToLive) : ttl{timeToLive} {\\n        \\n    }\\n\\n    inline void update(int t)\\n    {\\n        while (!wheel.empty() && std::get<0>(wheel.front()) <= t)\\n        {\\n            auto & [_, valid, id] = wheel.front();\\n            if (valid)\\n            {\\n                session.erase(id);\\n            }\\n            wheel.pop_front();\\n        }\\n    }\\n\\n    inline void new_session(string & id, int t)\\n    {\\n        int expire = t + ttl;\\n        wheel.push_back({expire, true, id});\\n        session[id] = std::prev(wheel.end());\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        update(currentTime);\\n        new_session(tokenId, currentTime);\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        update(currentTime);\\n        auto e = session.find(tokenId);\\n        if (e != session.end())\\n        {\\n            std::get<1>(*e->second) = false;\\n            new_session(tokenId, currentTime);\\n        }\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        update(currentTime);\\n        return session.size();\\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Design"
                ],
                "code": "```\\nclass AuthenticationManager {\\npublic:\\n    using event = tuple<int, bool, string>;\\n    list<event> wheel;\\n    unordered_map<string, list<event>::iterator> session;\\n    int ttl;\\n\\n    AuthenticationManager(int timeToLive) : ttl{timeToLive} {\\n        \\n    }\\n\\n    inline void update(int t)\\n    {\\n        while (!wheel.empty() && std::get<0>(wheel.front()) <= t)\\n        {\\n            auto & [_, valid, id] = wheel.front();\\n            if (valid)\\n            {\\n                session.erase(id);\\n            }\\n            wheel.pop_front();\\n        }\\n    }\\n\\n    inline void new_session(string & id, int t)\\n    {\\n        int expire = t + ttl;\\n        wheel.push_back({expire, true, id});\\n        session[id] = std::prev(wheel.end());\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        update(currentTime);\\n        new_session(tokenId, currentTime);\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        update(currentTime);\\n        auto e = session.find(tokenId);\\n        if (e != session.end())\\n        {\\n            std::get<1>(*e->second) = false;\\n            new_session(tokenId, currentTime);\\n        }\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        update(currentTime);\\n        return session.size();\\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3102790,
                "title": "c-list-hash-map-time-wheel-o-ttl",
                "content": "# Intuition\\n\\nUse a queue to keep the expiration events in a ordered manner, each element in the queue is a tuple:\\n\\n- expire time\\n- is valid\\n- token ID\\n\\nBefore every operation, first `pop()` the events that has been expired (`wheel.front().expire_time <= current Time`). If a session is renewed, mark this event as invalid (`valid := false`), and append a new event at the back of the queue. To quickly (`O(1)`) find the event to be renewed in the queue, we use a hash map to find the last valid event in the queue for each token:\\n\\n- key: token ID\\n- value: iterator points to the queue element\\n\\n\\n# Code\\n```c++\\nclass AuthenticationManager {\\npublic:\\n    using event = tuple<int, bool, string>;\\n    list<event> wheel;\\n    unordered_map<string, list<event>::iterator> session;\\n    int ttl;\\n\\n    AuthenticationManager(int timeToLive) : ttl{timeToLive} {\\n        \\n    }\\n\\n    inline void update(int t)\\n    {\\n        while (!wheel.empty() && std::get<0>(wheel.front()) <= t)\\n        {\\n            auto & [_, valid, id] = wheel.front();\\n            if (valid)\\n            {\\n                session.erase(id);\\n            }\\n            wheel.pop_front();\\n        }\\n    }\\n\\n    inline void new_session(string & id, int t)\\n    {\\n        int expire = t + ttl;\\n        wheel.push_back({expire, true, id});\\n        session[id] = std::prev(wheel.end());\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        update(currentTime);\\n        new_session(tokenId, currentTime);\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        update(currentTime);\\n        auto e = session.find(tokenId);\\n        if (e != session.end())\\n        {\\n            std::get<1>(*e->second) = false;\\n            new_session(tokenId, currentTime);\\n        }\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        update(currentTime);\\n        return session.size();\\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```c++\\nclass AuthenticationManager {\\npublic:\\n    using event = tuple<int, bool, string>;\\n    list<event> wheel;\\n    unordered_map<string, list<event>::iterator> session;\\n    int ttl;\\n\\n    AuthenticationManager(int timeToLive) : ttl{timeToLive} {\\n        \\n    }\\n\\n    inline void update(int t)\\n    {\\n        while (!wheel.empty() && std::get<0>(wheel.front()) <= t)\\n        {\\n            auto & [_, valid, id] = wheel.front();\\n            if (valid)\\n            {\\n                session.erase(id);\\n            }\\n            wheel.pop_front();\\n        }\\n    }\\n\\n    inline void new_session(string & id, int t)\\n    {\\n        int expire = t + ttl;\\n        wheel.push_back({expire, true, id});\\n        session[id] = std::prev(wheel.end());\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        update(currentTime);\\n        new_session(tokenId, currentTime);\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        update(currentTime);\\n        auto e = session.find(tokenId);\\n        if (e != session.end())\\n        {\\n            std::get<1>(*e->second) = false;\\n            new_session(tokenId, currentTime);\\n        }\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        update(currentTime);\\n        return session.size();\\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042276,
                "title": "java-solution-using-linkedhashmap-beats-100-with-detailed-description",
                "content": "# Intuition\\nWe need to maintain the sessions of different token ids and need a data structure which helps in reduce  time by sorting the sessions by their expiry time. \\n\\n# Approach\\nI have used a linked HashMap. TreeMap may also be used. \\nBenefit of using a linked HashMap is that it iterated through the key set in the order of their insertion. Everytime you add a new session, its get added as the last node and the session which is inserted last will expire last. The only case we need to handle is the case of renewal. \\nWhile you are renewing a session, clean the map of the ones already expired(to avoid renewing the already expired tokenIds). Since the renewed session will be the last to expire till that time, we have to move the tokenId to last of the LinkedHashMap\\'s linkedList to ensure the ordering, for doing it, simply remove the entry and then create a fresh entry with the new expiry.\\nWhenever we have to count the number of unexpired sessions, simply clean the map off the expired session and return the size of the map. For removing the map with the expired tokens, simply iterate through the keys and keep removing the keys till we find the first unexpired token since the linkedHashMap is sorted in the order by expiryTime\\n\\n# Complexity\\n- Time complexity:\\nComplexity of generation: O(1);\\nComplexity of renew: O(n);\\nComplexity of count: O(n);\\n\\nWorst case: O(n2) [for n operations]\\n\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass AuthenticationManager {\\n\\n    int timeToLive;\\n    Map<String, Integer> map;\\n\\n    public AuthenticationManager(int timeToLive) {\\n        this.timeToLive = timeToLive;\\n        map = new LinkedHashMap<>();\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        map.put(tokenId, currentTime+timeToLive);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        removeExpiredSessions(currentTime);\\n        if(map.containsKey(tokenId)) {\\n            map.remove(tokenId);\\n            map.put(tokenId, currentTime+timeToLive);\\n        }\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n\\n        removeExpiredSessions(currentTime);\\n        return map.size();\\n    }\\n\\n    public void removeExpiredSessions(int currentTime) {\\n        \\n        Iterator<Map.Entry<String,Integer>> iter = map.entrySet().iterator();\\n        \\n        while(iter.hasNext()) {\\n            Map.Entry<String,Integer> entry = iter.next();\\n            if(entry.getValue()<=currentTime){\\n                iter.remove();\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager obj = new AuthenticationManager(timeToLive);\\n * obj.generate(tokenId,currentTime);\\n * obj.renew(tokenId,currentTime);\\n * int param_3 = obj.countUnexpiredTokens(currentTime);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Map"
                ],
                "code": "```\\nclass AuthenticationManager {\\n\\n    int timeToLive;\\n    Map<String, Integer> map;\\n\\n    public AuthenticationManager(int timeToLive) {\\n        this.timeToLive = timeToLive;\\n        map = new LinkedHashMap<>();\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        map.put(tokenId, currentTime+timeToLive);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        removeExpiredSessions(currentTime);\\n        if(map.containsKey(tokenId)) {\\n            map.remove(tokenId);\\n            map.put(tokenId, currentTime+timeToLive);\\n        }\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n\\n        removeExpiredSessions(currentTime);\\n        return map.size();\\n    }\\n\\n    public void removeExpiredSessions(int currentTime) {\\n        \\n        Iterator<Map.Entry<String,Integer>> iter = map.entrySet().iterator();\\n        \\n        while(iter.hasNext()) {\\n            Map.Entry<String,Integer> entry = iter.next();\\n            if(entry.getValue()<=currentTime){\\n                iter.remove();\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager obj = new AuthenticationManager(timeToLive);\\n * obj.generate(tokenId,currentTime);\\n * obj.renew(tokenId,currentTime);\\n * int param_3 = obj.countUnexpiredTokens(currentTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021715,
                "title": "java-my-simple-solution",
                "content": "\\n\\n# Code\\n```\\n\\nclass AuthToken {\\n    long start;\\n    long end;\\n    \\n    AuthToken(long start, long end) {\\n        this.start = start;\\n        this.end = end;\\n    }\\n}\\n\\nclass AuthenticationManager {\\n    HashMap<String, AuthToken> tokens;\\n    int timeToLive;\\n\\n    public AuthenticationManager(int timeToLive) {\\n        this.tokens = new HashMap<>();\\n        this.timeToLive = timeToLive;\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        AuthToken newToken = new AuthToken(currentTime, currentTime + timeToLive);\\n        tokens.put(tokenId, newToken);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        AuthToken token = tokens.get(tokenId);\\n        if (token == null) { return; }\\n        boolean isNotExpired = currentTime < token.end;\\n        if (isNotExpired) {\\n            token.start = currentTime;\\n            token.end = currentTime + timeToLive;\\n        }\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        int unexpiredTokens = 0;\\n        for (AuthToken token : tokens.values()) {\\n            boolean isNotExpired = currentTime < token.end;\\n            if (isNotExpired) {\\n                unexpiredTokens++;\\n            }\\n        }\\n        return unexpiredTokens;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass AuthToken {\\n    long start;\\n    long end;\\n    \\n    AuthToken(long start, long end) {\\n        this.start = start;\\n        this.end = end;\\n    }\\n}\\n\\nclass AuthenticationManager {\\n    HashMap<String, AuthToken> tokens;\\n    int timeToLive;\\n\\n    public AuthenticationManager(int timeToLive) {\\n        this.tokens = new HashMap<>();\\n        this.timeToLive = timeToLive;\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        AuthToken newToken = new AuthToken(currentTime, currentTime + timeToLive);\\n        tokens.put(tokenId, newToken);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        AuthToken token = tokens.get(tokenId);\\n        if (token == null) { return; }\\n        boolean isNotExpired = currentTime < token.end;\\n        if (isNotExpired) {\\n            token.start = currentTime;\\n            token.end = currentTime + timeToLive;\\n        }\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        int unexpiredTokens = 0;\\n        for (AuthToken token : tokens.values()) {\\n            boolean isNotExpired = currentTime < token.end;\\n            if (isNotExpired) {\\n                unexpiredTokens++;\\n            }\\n        }\\n        return unexpiredTokens;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2966747,
                "title": "hashmap-java-solution",
                "content": "# Intuition\\nUse a HashMap which contains unexpired strings.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass AuthenticationManager {\\n    HashMap<String,Integer>unexpired;\\n    int duration;\\n    public AuthenticationManager(int timeToLive) {\\n        unexpired=new HashMap<>();\\n        this.duration=timeToLive;\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        unexpired.put(tokenId,duration+currentTime);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        if(unexpired.containsKey(tokenId)){\\n            if(unexpired.get(tokenId)>currentTime){\\n                unexpired.put(tokenId,currentTime+duration);\\n            }\\n        }\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        int cnt=0;\\n        for(String x:unexpired.keySet()){\\n            if(unexpired.get(x)>currentTime){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager obj = new AuthenticationManager(timeToLive);\\n * obj.generate(tokenId,currentTime);\\n * obj.renew(tokenId,currentTime);\\n * int param_3 = obj.countUnexpiredTokens(currentTime);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Design"
                ],
                "code": "```\\nclass AuthenticationManager {\\n    HashMap<String,Integer>unexpired;\\n    int duration;\\n    public AuthenticationManager(int timeToLive) {\\n        unexpired=new HashMap<>();\\n        this.duration=timeToLive;\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        unexpired.put(tokenId,duration+currentTime);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        if(unexpired.containsKey(tokenId)){\\n            if(unexpired.get(tokenId)>currentTime){\\n                unexpired.put(tokenId,currentTime+duration);\\n            }\\n        }\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        int cnt=0;\\n        for(String x:unexpired.keySet()){\\n            if(unexpired.get(x)>currentTime){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager obj = new AuthenticationManager(timeToLive);\\n * obj.generate(tokenId,currentTime);\\n * obj.renew(tokenId,currentTime);\\n * int param_3 = obj.countUnexpiredTokens(currentTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954089,
                "title": "golang-map",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^{2})$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\ntype AuthenticationManager struct {\\n    Map map[string]int\\n    timeToLive int\\n}\\n\\nfunc Constructor(timeToLive int) AuthenticationManager {\\n    var p AuthenticationManager\\n    p.Map = make(map[string]int)\\n    p.timeToLive = timeToLive\\n    return p\\n}\\n\\nfunc (this *AuthenticationManager) Generate(tokenId string, currentTime int)  {\\n    this.Map[tokenId] = currentTime + this.timeToLive\\n}\\n\\nfunc (this *AuthenticationManager) Renew(tokenId string, currentTime int)  {\\n    if _, ok := this.Map[tokenId]; ok && this.Map[tokenId] > currentTime {\\n        this.Map[tokenId] = currentTime + this.timeToLive\\n    }     \\n}\\n\\nfunc (this *AuthenticationManager) CountUnexpiredTokens(currentTime int) int {\\n    for key, val := range this.Map {\\n        if(val <= currentTime) {\\n            delete(this.Map, key)\\n        }\\n    }\\n    return len(this.Map)\\n}\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * obj := Constructor(timeToLive);\\n * obj.Generate(tokenId,currentTime);\\n * obj.Renew(tokenId,currentTime);\\n * param_3 := obj.CountUnexpiredTokens(currentTime);\\n */\\n```",
                "solutionTags": [
                    "Go",
                    "Hash Table",
                    "Design"
                ],
                "code": "```\\ntype AuthenticationManager struct {\\n    Map map[string]int\\n    timeToLive int\\n}\\n\\nfunc Constructor(timeToLive int) AuthenticationManager {\\n    var p AuthenticationManager\\n    p.Map = make(map[string]int)\\n    p.timeToLive = timeToLive\\n    return p\\n}\\n\\nfunc (this *AuthenticationManager) Generate(tokenId string, currentTime int)  {\\n    this.Map[tokenId] = currentTime + this.timeToLive\\n}\\n\\nfunc (this *AuthenticationManager) Renew(tokenId string, currentTime int)  {\\n    if _, ok := this.Map[tokenId]; ok && this.Map[tokenId] > currentTime {\\n        this.Map[tokenId] = currentTime + this.timeToLive\\n    }     \\n}\\n\\nfunc (this *AuthenticationManager) CountUnexpiredTokens(currentTime int) int {\\n    for key, val := range this.Map {\\n        if(val <= currentTime) {\\n            delete(this.Map, key)\\n        }\\n    }\\n    return len(this.Map)\\n}\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * obj := Constructor(timeToLive);\\n * obj.Generate(tokenId,currentTime);\\n * obj.Renew(tokenId,currentTime);\\n * param_3 := obj.CountUnexpiredTokens(currentTime);\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2954016,
                "title": "c-map",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^{2})$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass AuthenticationManager {\\n    map<string, int> Map;\\n    int timeToLive;\\npublic:\\n    AuthenticationManager(int timeToLive) {\\n        this -> timeToLive = timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        Map[tokenId] = currentTime + timeToLive;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if(Map.find(tokenId) != Map.end() && Map[tokenId] > currentTime) \\n            Map[tokenId] = currentTime + timeToLive;\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        for(auto iter = Map.begin(); iter != Map.end();) {\\n            if(iter -> second <= currentTime)\\n                iter = Map.erase(iter);\\n            else\\n                iter++;\\n        }\\n        return Map.size();\\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Design"
                ],
                "code": "```\\nclass AuthenticationManager {\\n    map<string, int> Map;\\n    int timeToLive;\\npublic:\\n    AuthenticationManager(int timeToLive) {\\n        this -> timeToLive = timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        Map[tokenId] = currentTime + timeToLive;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if(Map.find(tokenId) != Map.end() && Map[tokenId] > currentTime) \\n            Map[tokenId] = currentTime + timeToLive;\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        for(auto iter = Map.begin(); iter != Map.end();) {\\n            if(iter -> second <= currentTime)\\n                iter = Map.erase(iter);\\n            else\\n                iter++;\\n        }\\n        return Map.size();\\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2951532,
                "title": "python-hashmap-simple-solution",
                "content": "# Code\\n```\\n\\nclass AuthenticationManager:\\n\\n    def __init__(self, timeToLive: int):\\n        self.ttl = timeToLive\\n        self.tokens = defaultdict(int)\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self.tokens[tokenId] = currentTime\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if tokenId in self.tokens and self.tokens[tokenId] + self.ttl > currentTime:\\n            self.tokens[tokenId] = currentTime\\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        return sum([1 for tokenId in self.tokens if self.tokens[tokenId] + self.ttl > currentTime])\\n\\n        \\n\\n\\n# Your AuthenticationManager object will be instantiated and called as such:\\n# obj = AuthenticationManager(timeToLive)\\n# obj.generate(tokenId,currentTime)\\n# obj.renew(tokenId,currentTime)\\n# param_3 = obj.countUnexpiredTokens(currentTime)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass AuthenticationManager:\\n\\n    def __init__(self, timeToLive: int):\\n        self.ttl = timeToLive\\n        self.tokens = defaultdict(int)\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self.tokens[tokenId] = currentTime\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if tokenId in self.tokens and self.tokens[tokenId] + self.ttl > currentTime:\\n            self.tokens[tokenId] = currentTime\\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        return sum([1 for tokenId in self.tokens if self.tokens[tokenId] + self.ttl > currentTime])\\n\\n        \\n\\n\\n# Your AuthenticationManager object will be instantiated and called as such:\\n# obj = AuthenticationManager(timeToLive)\\n# obj.generate(tokenId,currentTime)\\n# obj.renew(tokenId,currentTime)\\n# param_3 = obj.countUnexpiredTokens(currentTime)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930458,
                "title": "python-dict",
                "content": "class AuthenticationManager:\\n\\n    def __init__(self, timeToLive: int):\\n        self.res = dict() \\n        self.time = timeToLive\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self.res[tokenId] = currentTime + self.time\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if self.res.get(tokenId, 0) > currentTime:\\n            self.res[tokenId] = currentTime + self.time\\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        for token in tuple(self.res.keys()):\\n            if self.res[token] <= currentTime:\\n                self.res.pop(token)\\n        return len(self.res)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class AuthenticationManager:\\n\\n    def __init__(self, timeToLive: int):\\n        self.res = dict() \\n        self.time = timeToLive\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self.res[tokenId] = currentTime + self.time\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if self.res.get(tokenId, 0) > currentTime:\\n            self.res[tokenId] = currentTime + self.time\\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        for token in tuple(self.res.keys()):\\n            if self.res[token] <= currentTime:\\n                self.res.pop(token)\\n        return len(self.res)",
                "codeTag": "Java"
            },
            {
                "id": 2904779,
                "title": "c-unordered-map-tc-o-n-sc-o-n-aux-o-n",
                "content": "```\\nclass AuthenticationManager {\\n    int timeToLive;\\n    unordered_map<string,pair<int,int>> uMap;\\npublic:\\n    AuthenticationManager(int timeToLive) {\\n        this->timeToLive = timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        uMap[tokenId] = {currentTime,currentTime+timeToLive};\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if(uMap[tokenId].second <= currentTime) // not renewing expired tokens\\n            return ;\\n        uMap[tokenId] = {currentTime,currentTime+timeToLive};\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int ans = 0;\\n        for(auto itrPair : uMap)\\n            if(itrPair.second.second > currentTime)\\n                ans++;\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Design"
                ],
                "code": "```\\nclass AuthenticationManager {\\n    int timeToLive;\\n    unordered_map<string,pair<int,int>> uMap;\\npublic:\\n    AuthenticationManager(int timeToLive) {\\n        this->timeToLive = timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        uMap[tokenId] = {currentTime,currentTime+timeToLive};\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if(uMap[tokenId].second <= currentTime) // not renewing expired tokens\\n            return ;\\n        uMap[tokenId] = {currentTime,currentTime+timeToLive};\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int ans = 0;\\n        for(auto itrPair : uMap)\\n            if(itrPair.second.second > currentTime)\\n                ans++;\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2835284,
                "title": "java-solution-with-hashmap",
                "content": "\\n# Code\\n```\\nclass AuthenticationManager {\\n\\n        int timeToLive;\\n        Map<String, Long> tokens;\\n        public AuthenticationManager(int timeToLive) {\\n            this.timeToLive = timeToLive;\\n            tokens = new HashMap<>();\\n        }\\n\\n        public void generate(String tokenId, int currentTime) {\\n            tokens.put(tokenId, (long) currentTime + timeToLive);\\n        }\\n\\n        public void renew(String tokenId, int currentTime) {\\n            if(tokens.containsKey(tokenId) && tokens.get(tokenId) > currentTime)\\n                tokens.put(tokenId, (long) (timeToLive+currentTime));\\n        }\\n\\n        public int countUnexpiredTokens(int currentTime) {\\n            int c = 0;\\n            for(Map.Entry<String, Long> entry : tokens.entrySet()){\\n                if(entry.getValue() > currentTime) c++;\\n            }\\n            return c;\\n        }\\n    }\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager obj = new AuthenticationManager(timeToLive);\\n * obj.generate(tokenId,currentTime);\\n * obj.renew(tokenId,currentTime);\\n * int param_3 = obj.countUnexpiredTokens(currentTime);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass AuthenticationManager {\\n\\n        int timeToLive;\\n        Map<String, Long> tokens;\\n        public AuthenticationManager(int timeToLive) {\\n            this.timeToLive = timeToLive;\\n            tokens = new HashMap<>();\\n        }\\n\\n        public void generate(String tokenId, int currentTime) {\\n            tokens.put(tokenId, (long) currentTime + timeToLive);\\n        }\\n\\n        public void renew(String tokenId, int currentTime) {\\n            if(tokens.containsKey(tokenId) && tokens.get(tokenId) > currentTime)\\n                tokens.put(tokenId, (long) (timeToLive+currentTime));\\n        }\\n\\n        public int countUnexpiredTokens(int currentTime) {\\n            int c = 0;\\n            for(Map.Entry<String, Long> entry : tokens.entrySet()){\\n                if(entry.getValue() > currentTime) c++;\\n            }\\n            return c;\\n        }\\n    }\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager obj = new AuthenticationManager(timeToLive);\\n * obj.generate(tokenId,currentTime);\\n * obj.renew(tokenId,currentTime);\\n * int param_3 = obj.countUnexpiredTokens(currentTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793311,
                "title": "python-3-with-ordereddict-and-bisect",
                "content": "```\\nfrom bisect import bisect\\nclass AuthenticationManager:\\n\\n    def __init__(self, timeToLive: int):\\n        self.tokens = OrderedDict()\\n        self.ttl = timeToLive\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self.tokens[tokenId] = currentTime + self.ttl\\n        self.tokens.move_to_end(tokenId)\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if tokenId in self.tokens and self.tokens[tokenId] > currentTime:\\n            self.tokens[tokenId] = currentTime + self.ttl\\n            self.tokens.move_to_end(tokenId)\\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        return len(self.tokens) - bisect(list(self.tokens.values()),currentTime)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom bisect import bisect\\nclass AuthenticationManager:\\n\\n    def __init__(self, timeToLive: int):\\n        self.tokens = OrderedDict()\\n        self.ttl = timeToLive\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self.tokens[tokenId] = currentTime + self.ttl\\n        self.tokens.move_to_end(tokenId)\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if tokenId in self.tokens and self.tokens[tokenId] > currentTime:\\n            self.tokens[tokenId] = currentTime + self.ttl\\n            self.tokens.move_to_end(tokenId)\\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        return len(self.tokens) - bisect(list(self.tokens.values()),currentTime)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780136,
                "title": "c-using-single-map-easy",
                "content": "```\\nclass AuthenticationManager {\\npublic:\\n    int time;\\n    unordered_map<string,int>mp;\\n    AuthenticationManager(int timeToLive) {\\n        time=timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        mp[tokenId]=currentTime;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if(mp.find(tokenId)!=mp.end() && mp[tokenId]+time>currentTime)\\n            mp[tokenId]=currentTime;\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int ans=0;\\n        for(auto x:mp){\\n            if(x.second +time>currentTime)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass AuthenticationManager {\\npublic:\\n    int time;\\n    unordered_map<string,int>mp;\\n    AuthenticationManager(int timeToLive) {\\n        time=timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        mp[tokenId]=currentTime;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if(mp.find(tokenId)!=mp.end() && mp[tokenId]+time>currentTime)\\n            mp[tokenId]=currentTime;\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int ans=0;\\n        for(auto x:mp){\\n            if(x.second +time>currentTime)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2745941,
                "title": "easy-hashtable-solution-better-tha-60-java",
                "content": "```\\nclass AuthenticationManager {\\n    private final int timeToLive;\\n    private final Map<String,Integer> tokens = new HashMap<>();\\n    public AuthenticationManager(int timeToLive) {\\n        this.timeToLive = timeToLive;\\n    }\\n\\n    public void generate(String tokenId, int currentTime) {\\n        if(tokens.containsKey(tokenId) && tokens.get(tokenId) > currentTime) return;\\n        tokens.put(tokenId,currentTime+timeToLive);\\n    }\\n\\n    public void renew(String tokenId, int currentTime) {\\n        if(!tokens.containsKey(tokenId) || tokens.get(tokenId) <= currentTime) return;\\n        tokens.put(tokenId,currentTime+timeToLive);\\n    }\\n\\n    public int countUnexpiredTokens(int currentTime) {\\n        if(tokens.isEmpty()) return 0;\\n        int counter = 0;\\n        Iterator<Map.Entry<String, Integer>> iterator = tokens.entrySet().iterator();\\n        while (iterator.hasNext()){\\n            Map.Entry<String, Integer> item = iterator.next();\\n            if(item.getValue() > currentTime) counter++;\\n            else iterator.remove();\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Design"
                ],
                "code": "```\\nclass AuthenticationManager {\\n    private final int timeToLive;\\n    private final Map<String,Integer> tokens = new HashMap<>();\\n    public AuthenticationManager(int timeToLive) {\\n        this.timeToLive = timeToLive;\\n    }\\n\\n    public void generate(String tokenId, int currentTime) {\\n        if(tokens.containsKey(tokenId) && tokens.get(tokenId) > currentTime) return;\\n        tokens.put(tokenId,currentTime+timeToLive);\\n    }\\n\\n    public void renew(String tokenId, int currentTime) {\\n        if(!tokens.containsKey(tokenId) || tokens.get(tokenId) <= currentTime) return;\\n        tokens.put(tokenId,currentTime+timeToLive);\\n    }\\n\\n    public int countUnexpiredTokens(int currentTime) {\\n        if(tokens.isEmpty()) return 0;\\n        int counter = 0;\\n        Iterator<Map.Entry<String, Integer>> iterator = tokens.entrySet().iterator();\\n        while (iterator.hasNext()){\\n            Map.Entry<String, Integer> item = iterator.next();\\n            if(item.getValue() > currentTime) counter++;\\n            else iterator.remove();\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2730735,
                "title": "c-intuitive-map-solution-with-explanation",
                "content": "```\\nclass AuthenticationManager {\\npublic:\\n    int expiry;\\n    unordered_map<string, int> tokens; //tokens[token_name] = creation_time\\n    AuthenticationManager(int timeToLive) {\\n        expiry = timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        tokens[tokenId] = currentTime;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n\\t    // If there are no unexpired tokens with the given tokenId, the request is ignored\\n\\t\\t//  -->  renew only valid (unexpired tokens)\\n        if (tokens.count(tokenId) > 0 && tokens[tokenId] + expiry > currentTime) {\\n            tokens[tokenId] = currentTime;\\n        }\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int cnt = 0;\\n        for (auto token : tokens) {\\n            if (token.second + expiry > currentTime) {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n\\n/*\\nif (you like this) {\\n\\tplease upvote;\\n}\\n*/\\n ```",
                "solutionTags": [],
                "code": "```\\nclass AuthenticationManager {\\npublic:\\n    int expiry;\\n    unordered_map<string, int> tokens; //tokens[token_name] = creation_time\\n    AuthenticationManager(int timeToLive) {\\n        expiry = timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        tokens[tokenId] = currentTime;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n\\t    // If there are no unexpired tokens with the given tokenId, the request is ignored\\n\\t\\t//  -->  renew only valid (unexpired tokens)\\n        if (tokens.count(tokenId) > 0 && tokens[tokenId] + expiry > currentTime) {\\n            tokens[tokenId] = currentTime;\\n        }\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int cnt = 0;\\n        for (auto token : tokens) {\\n            if (token.second + expiry > currentTime) {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n\\n/*\\nif (you like this) {\\n\\tplease upvote;\\n}\\n*/\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2724213,
                "title": "heap-method-fast-than-99",
                "content": "```\\nimport heapq\\nclass AuthenticationManager:\\n    def __init__(self, timeToLive: int):\\n        self.timeToLive=timeToLive\\n        self.token=[] #expired time\\n        heapq.heapify(self.token)\\n        self.hashMap={} #tokenId-->Expired time\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        heapq.heappush(self.token,currentTime+self.timeToLive)\\n        self.hashMap[tokenId]=currentTime+self.timeToLive\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if tokenId not in self.hashMap:\\n            return\\n        if currentTime < self.hashMap[tokenId]:\\n            self.token[self.token.index(self.hashMap[tokenId])]=currentTime+self.timeToLive\\n            heapq.heapify(self.token)\\n            self.hashMap[tokenId]=currentTime+self.timeToLive\\n        #print(self.token)\\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        self.expired(currentTime)\\n        #print(self.token)\\n        return len(self.token)\\n    \\n    def expired(self,currentTime):\\n        while len(self.token) >0 and self.token[0]<=currentTime:\\n            o=heapq.heappop(self.token)\\n            #print(self.token)\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\nclass AuthenticationManager:\\n    def __init__(self, timeToLive: int):\\n        self.timeToLive=timeToLive\\n        self.token=[] #expired time\\n        heapq.heapify(self.token)\\n        self.hashMap={} #tokenId-->Expired time\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        heapq.heappush(self.token,currentTime+self.timeToLive)\\n        self.hashMap[tokenId]=currentTime+self.timeToLive\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if tokenId not in self.hashMap:\\n            return\\n        if currentTime < self.hashMap[tokenId]:\\n            self.token[self.token.index(self.hashMap[tokenId])]=currentTime+self.timeToLive\\n            heapq.heapify(self.token)\\n            self.hashMap[tokenId]=currentTime+self.timeToLive\\n        #print(self.token)\\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        self.expired(currentTime)\\n        #print(self.token)\\n        return len(self.token)\\n    \\n    def expired(self,currentTime):\\n        while len(self.token) >0 and self.token[0]<=currentTime:\\n            o=heapq.heappop(self.token)\\n            #print(self.token)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2704861,
                "title": "python-solution-easy-to-understand-with-hashmap",
                "content": "```\\n\\nclass AuthenticationManager:\\n    class Node:\\n        def __init__(self, id, time):\\n            self.id = id\\n            self.time = time\\n        def __lt__(self, other):\\n            return self.time >= other.time\\n    def __init__(self, timeToLive: int):\\n        self.timeToLive = timeToLive \\n        self.hashMap = {}\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self.hashMap[tokenId] = currentTime\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if tokenId not in self.hashMap.keys():\\n            return None\\n        else:\\n            if currentTime >= self.hashMap[tokenId] + self.timeToLive:\\n                return None\\n            else:\\n                self.hashMap[tokenId] = currentTime \\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        count = 0\\n        for i in self.hashMap.values():\\n            if i + self.timeToLive > currentTime:\\n                count += 1\\n        return count\\n\\n\\n# Your AuthenticationManager object will be instantiated and called as such:\\n# obj = AuthenticationManager(timeToLive)\\n# obj.generate(tokenId,currentTime)\\n# obj.renew(tokenId,currentTime)\\n# param_3 = obj.countUnexpiredTokens(currentTime)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\nclass AuthenticationManager:\\n    class Node:\\n        def __init__(self, id, time):\\n            self.id = id\\n            self.time = time\\n        def __lt__(self, other):\\n            return self.time >= other.time\\n    def __init__(self, timeToLive: int):\\n        self.timeToLive = timeToLive \\n        self.hashMap = {}\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self.hashMap[tokenId] = currentTime\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if tokenId not in self.hashMap.keys():\\n            return None\\n        else:\\n            if currentTime >= self.hashMap[tokenId] + self.timeToLive:\\n                return None\\n            else:\\n                self.hashMap[tokenId] = currentTime \\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        count = 0\\n        for i in self.hashMap.values():\\n            if i + self.timeToLive > currentTime:\\n                count += 1\\n        return count\\n\\n\\n# Your AuthenticationManager object will be instantiated and called as such:\\n# obj = AuthenticationManager(timeToLive)\\n# obj.generate(tokenId,currentTime)\\n# obj.renew(tokenId,currentTime)\\n# param_3 = obj.countUnexpiredTokens(currentTime)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2698300,
                "title": "python-simple-hashmap",
                "content": "\\n    def __init__(self, timeToLive):\\n        self.timeToLive = timeToLive\\n        self.dict1 = defaultdict(int)\\n\\n    def generate(self, tokenId, currentTime):\\n        self.dict1[tokenId] = currentTime + self.timeToLive\\n\\n    def renew(self, tokenId, currentTime):\\n        if tokenId in self.dict1 and self.dict1[tokenId] > currentTime:\\n            self.dict1[tokenId] = currentTime + self.timeToLive\\n\\n    def countUnexpiredTokens(self, currentTime):\\n        total = 0\\n        \\n        for i in self.dict1:\\n            if self.dict1[i] > currentTime:\\n                total += 1\\n                \\n        return total",
                "solutionTags": [],
                "code": "\\n    def __init__(self, timeToLive):\\n        self.timeToLive = timeToLive\\n        self.dict1 = defaultdict(int)\\n\\n    def generate(self, tokenId, currentTime):\\n        self.dict1[tokenId] = currentTime + self.timeToLive\\n\\n    def renew(self, tokenId, currentTime):\\n        if tokenId in self.dict1 and self.dict1[tokenId] > currentTime:\\n            self.dict1[tokenId] = currentTime + self.timeToLive\\n\\n    def countUnexpiredTokens(self, currentTime):\\n        total = 0\\n        \\n        for i in self.dict1:\\n            if self.dict1[i] > currentTime:\\n                total += 1\\n                \\n        return total",
                "codeTag": "Python3"
            },
            {
                "id": 2693019,
                "title": "c-using-map-easy-understanding",
                "content": "```\\nclass AuthenticationManager {\\npublic:\\n    \\n    map<string,int> m;\\n    int timeToLive = 0;\\n    AuthenticationManager(int timeToLive) {\\n        this->timeToLive = timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        m[tokenId] = timeToLive+currentTime;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if(m[tokenId]>currentTime)\\n            m[tokenId]=currentTime+timeToLive;\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int ans = 0;\\n        for(auto it:m){\\n            if(it.second>currentTime)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass AuthenticationManager {\\npublic:\\n    \\n    map<string,int> m;\\n    int timeToLive = 0;\\n    AuthenticationManager(int timeToLive) {\\n        this->timeToLive = timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        m[tokenId] = timeToLive+currentTime;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if(m[tokenId]>currentTime)\\n            m[tokenId]=currentTime+timeToLive;\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int ans = 0;\\n        for(auto it:m){\\n            if(it.second>currentTime)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2690619,
                "title": "two-different-implementations-just-do-what-problem-asking-for",
                "content": "```\\nclass AuthenticationManager {\\n\\n    // token_id ==> [token_starting_time, token_expiry_time]\\n    private Map<String, int[]> tokensInfo;\\n    \\n    // tells how long a token will last(expires at : time_at_generated + timeToLive) from\\n    // current time.\\n    private int sessionTime;\\n    \\n    public AuthenticationManager(int timeToLive) {\\n        tokensInfo = new HashMap<>();\\n        sessionTime = timeToLive;\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        tokensInfo.put(tokenId, new int[]{currentTime, currentTime + sessionTime});\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        int[] tokenInfo = tokensInfo.get(tokenId);\\n        if(tokenInfo == null) return;\\n        // If given tokenId is NOT expired yet then only renew it. ignore otherwise.\\n        // In Real Life => To renew any service, you must have to apply for it before it gets expire\\n        if(currentTime < tokenInfo[1]) \\n            //tokensInfo.put(tokenId, new int[]{tokenInfo[0], currentTime + sessionTime}); //OK safe side\\n            tokenInfo[1] = currentTime + sessionTime; //updating info\\n    }\\n    \\n    // Iterate over the each tokens generated so far and count each one of them that are\\n    // expired at (up-until currentTime).\\n    public int countUnexpiredTokens(int currentTime) {\\n        int cnt = 0;\\n        for(int[] tokenInfo : tokensInfo.values()) {\\n            if(currentTime < tokenInfo[1]) cnt += 1;\\n        }\\n        return cnt;\\n    }\\n}\\n```\\n\\n```\\nEfficient Implementation Wise [Avoided Array Object in Hash-Table]\\n```\\n\\n```\\n\\nclass AuthenticationManager {\\n\\n    // token_id ==> token_expiry_time\\n    private Map<String, Integer> tokensInfo;\\n    private int sessionTime;\\n    \\n    public AuthenticationManager(int timeToLive) {\\n        tokensInfo = new HashMap<>();\\n        sessionTime = timeToLive;\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        tokensInfo.put(tokenId, currentTime + sessionTime);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        Integer expireTime = tokensInfo.get(tokenId);\\n        if(expireTime == null) return;\\n        if(currentTime < expireTime) \\n            tokensInfo.put(tokenId, currentTime + sessionTime);\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        int cnt = 0;\\n        for(Integer currentTokenExpiryTime : tokensInfo.values()) {\\n            if(currentTime < currentTokenExpiryTime) cnt += 1;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass AuthenticationManager {\\n\\n    // token_id ==> [token_starting_time, token_expiry_time]\\n    private Map<String, int[]> tokensInfo;\\n    \\n    // tells how long a token will last(expires at : time_at_generated + timeToLive) from\\n    // current time.\\n    private int sessionTime;\\n    \\n    public AuthenticationManager(int timeToLive) {\\n        tokensInfo = new HashMap<>();\\n        sessionTime = timeToLive;\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        tokensInfo.put(tokenId, new int[]{currentTime, currentTime + sessionTime});\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        int[] tokenInfo = tokensInfo.get(tokenId);\\n        if(tokenInfo == null) return;\\n        // If given tokenId is NOT expired yet then only renew it. ignore otherwise.\\n        // In Real Life => To renew any service, you must have to apply for it before it gets expire\\n        if(currentTime < tokenInfo[1]) \\n            //tokensInfo.put(tokenId, new int[]{tokenInfo[0], currentTime + sessionTime}); //OK safe side\\n            tokenInfo[1] = currentTime + sessionTime; //updating info\\n    }\\n    \\n    // Iterate over the each tokens generated so far and count each one of them that are\\n    // expired at (up-until currentTime).\\n    public int countUnexpiredTokens(int currentTime) {\\n        int cnt = 0;\\n        for(int[] tokenInfo : tokensInfo.values()) {\\n            if(currentTime < tokenInfo[1]) cnt += 1;\\n        }\\n        return cnt;\\n    }\\n}\\n```\n```\\nEfficient Implementation Wise [Avoided Array Object in Hash-Table]\\n```\n```\\n\\nclass AuthenticationManager {\\n\\n    // token_id ==> token_expiry_time\\n    private Map<String, Integer> tokensInfo;\\n    private int sessionTime;\\n    \\n    public AuthenticationManager(int timeToLive) {\\n        tokensInfo = new HashMap<>();\\n        sessionTime = timeToLive;\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        tokensInfo.put(tokenId, currentTime + sessionTime);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        Integer expireTime = tokensInfo.get(tokenId);\\n        if(expireTime == null) return;\\n        if(currentTime < expireTime) \\n            tokensInfo.put(tokenId, currentTime + sessionTime);\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        int cnt = 0;\\n        for(Integer currentTokenExpiryTime : tokensInfo.values()) {\\n            if(currentTime < currentTokenExpiryTime) cnt += 1;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2676380,
                "title": "beats-99-time-space-unexpired-token-hashmap-with-active-token-priorityqueue",
                "content": "```\\nclass AuthenticationManager {\\n    private PriorityQueue<TokenWithTTL> activeTokens;\\n    private Map<String, TokenWithTTL> tokenIdToUnexpiredToken;\\n    private int timeToLive;\\n\\n    public AuthenticationManager(int timeToLive) {\\n        activeTokens = new PriorityQueue<>();\\n        tokenIdToUnexpiredToken = new HashMap<>();\\n        this.timeToLive = timeToLive;\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        expireTokens(currentTime);\\n        TokenWithTTL tokenWithTTL = new TokenWithTTL(tokenId, currentTime + timeToLive);\\n        activeTokens.offer(tokenWithTTL);\\n        tokenIdToUnexpiredToken.put(tokenId, tokenWithTTL);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        expireTokens(currentTime);\\n        List<TokenWithTTL> tokenBuffer = new ArrayList<>();\\n        if (tokenIdToUnexpiredToken.containsKey(tokenId)) {\\n            while (!activeTokens.isEmpty() && !activeTokens.peek().tokenId.equals(tokenId)) {\\n                tokenBuffer.add(activeTokens.poll());\\n            }\\n            TokenWithTTL matchedToken = activeTokens.poll();\\n            matchedToken.expirationTime = currentTime + timeToLive;\\n            activeTokens.add(matchedToken);\\n            activeTokens.addAll(tokenBuffer);\\n        }\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        expireTokens(currentTime);\\n        return tokenIdToUnexpiredToken.size();\\n    }\\n    \\n    private void expireTokens(int currentTime) {\\n        while (!activeTokens.isEmpty() && activeTokens.peek().expirationTime <= currentTime) {\\n            TokenWithTTL expiredToken = activeTokens.poll();\\n            tokenIdToUnexpiredToken.remove(expiredToken.tokenId);\\n        }        \\n    }\\n    \\n    private static class TokenWithTTL implements Comparable<TokenWithTTL> {\\n        String tokenId;\\n        int expirationTime;\\n        \\n        public TokenWithTTL(String tokenId, int expirationTime) {\\n            this.tokenId = tokenId;\\n            this.expirationTime = expirationTime;\\n        }\\n        \\n        public int compareTo(TokenWithTTL other) {\\n            return Integer.compare(expirationTime, other.expirationTime);\\n        }\\n    }\\n}\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager obj = new AuthenticationManager(timeToLive);\\n * obj.generate(tokenId,currentTime);\\n * obj.renew(tokenId,currentTime);\\n * int param_3 = obj.countUnexpiredTokens(currentTime);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass AuthenticationManager {\\n    private PriorityQueue<TokenWithTTL> activeTokens;\\n    private Map<String, TokenWithTTL> tokenIdToUnexpiredToken;\\n    private int timeToLive;\\n\\n    public AuthenticationManager(int timeToLive) {\\n        activeTokens = new PriorityQueue<>();\\n        tokenIdToUnexpiredToken = new HashMap<>();\\n        this.timeToLive = timeToLive;\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        expireTokens(currentTime);\\n        TokenWithTTL tokenWithTTL = new TokenWithTTL(tokenId, currentTime + timeToLive);\\n        activeTokens.offer(tokenWithTTL);\\n        tokenIdToUnexpiredToken.put(tokenId, tokenWithTTL);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        expireTokens(currentTime);\\n        List<TokenWithTTL> tokenBuffer = new ArrayList<>();\\n        if (tokenIdToUnexpiredToken.containsKey(tokenId)) {\\n            while (!activeTokens.isEmpty() && !activeTokens.peek().tokenId.equals(tokenId)) {\\n                tokenBuffer.add(activeTokens.poll());\\n            }\\n            TokenWithTTL matchedToken = activeTokens.poll();\\n            matchedToken.expirationTime = currentTime + timeToLive;\\n            activeTokens.add(matchedToken);\\n            activeTokens.addAll(tokenBuffer);\\n        }\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        expireTokens(currentTime);\\n        return tokenIdToUnexpiredToken.size();\\n    }\\n    \\n    private void expireTokens(int currentTime) {\\n        while (!activeTokens.isEmpty() && activeTokens.peek().expirationTime <= currentTime) {\\n            TokenWithTTL expiredToken = activeTokens.poll();\\n            tokenIdToUnexpiredToken.remove(expiredToken.tokenId);\\n        }        \\n    }\\n    \\n    private static class TokenWithTTL implements Comparable<TokenWithTTL> {\\n        String tokenId;\\n        int expirationTime;\\n        \\n        public TokenWithTTL(String tokenId, int expirationTime) {\\n            this.tokenId = tokenId;\\n            this.expirationTime = expirationTime;\\n        }\\n        \\n        public int compareTo(TokenWithTTL other) {\\n            return Integer.compare(expirationTime, other.expirationTime);\\n        }\\n    }\\n}\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager obj = new AuthenticationManager(timeToLive);\\n * obj.generate(tokenId,currentTime);\\n * obj.renew(tokenId,currentTime);\\n * int param_3 = obj.countUnexpiredTokens(currentTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674191,
                "title": "java-priority-queue-beats-98",
                "content": "```\\nclass AuthenticationManager {\\n    int timeToLive;\\n    Map<String,Integer> time = new HashMap();\\n    PriorityQueue<String> pq = new PriorityQueue<>((a,b)->time.get(a) - time.get(b));\\n        \\n    public AuthenticationManager(int timeToLive) {\\n        this.timeToLive = timeToLive;\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        time.put(tokenId, currentTime);\\n        pq.offer(tokenId);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        if (!time.containsKey(tokenId) || currentTime - time.get(tokenId) >= timeToLive) return;\\n        pq.remove(tokenId);\\n        generate(tokenId, currentTime);\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        // Pop all expired tokens\\n        while (!pq.isEmpty() && currentTime - time.get(pq.peek()) >= timeToLive)  {\\n            time.remove(pq.poll());\\n        }\\n        return pq.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass AuthenticationManager {\\n    int timeToLive;\\n    Map<String,Integer> time = new HashMap();\\n    PriorityQueue<String> pq = new PriorityQueue<>((a,b)->time.get(a) - time.get(b));\\n        \\n    public AuthenticationManager(int timeToLive) {\\n        this.timeToLive = timeToLive;\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        time.put(tokenId, currentTime);\\n        pq.offer(tokenId);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        if (!time.containsKey(tokenId) || currentTime - time.get(tokenId) >= timeToLive) return;\\n        pq.remove(tokenId);\\n        generate(tokenId, currentTime);\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        // Pop all expired tokens\\n        while (!pq.isEmpty() && currentTime - time.get(pq.peek()) >= timeToLive)  {\\n            time.remove(pq.poll());\\n        }\\n        return pq.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2656481,
                "title": "heap-map-solution-achieves-amortized-o-1-countunexpiredtokens-time-complexity",
                "content": "```\\nclass AuthenticationManager:\\n\\n    def __init__(self, timeToLive: int):\\n        self.ttl = timeToLive\\n        self.orderedTokens = []\\n        self.mappedToken = defaultdict(int)\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        heappush(self.orderedTokens, (currentTime + self.ttl, tokenId))\\n        self.mappedToken[tokenId] = currentTime + self.ttl\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if tokenId in self.mappedToken and self.mappedToken[tokenId] > currentTime:\\n            self.mappedToken[tokenId] = currentTime + self.ttl\\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        while self.orderedTokens and self.orderedTokens[0][0] <= currentTime:\\n            endTime,tokenId = heappop(self.orderedTokens)\\n            if self.mappedToken[tokenId] != endTime:\\n                heappush(self.orderedTokens, (self.mappedToken[tokenId], tokenId))\\n\\n        return len(self.orderedTokens)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass AuthenticationManager:\\n\\n    def __init__(self, timeToLive: int):\\n        self.ttl = timeToLive\\n        self.orderedTokens = []\\n        self.mappedToken = defaultdict(int)\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        heappush(self.orderedTokens, (currentTime + self.ttl, tokenId))\\n        self.mappedToken[tokenId] = currentTime + self.ttl\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if tokenId in self.mappedToken and self.mappedToken[tokenId] > currentTime:\\n            self.mappedToken[tokenId] = currentTime + self.ttl\\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        while self.orderedTokens and self.orderedTokens[0][0] <= currentTime:\\n            endTime,tokenId = heappop(self.orderedTokens)\\n            if self.mappedToken[tokenId] != endTime:\\n                heappush(self.orderedTokens, (self.mappedToken[tokenId], tokenId))\\n\\n        return len(self.orderedTokens)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2645421,
                "title": "lol",
                "content": "# Code\\n```\\ntype Seconds = number;\\ntype TokenId = string\\ntype Token = Readonly<{\\n    ts: Seconds\\n    id: string\\n}>\\n\\nclass AuthenticationManager {\\n    private tokens: Map<TokenId, Token> = new Map()\\n    \\n    constructor(private ttl: Seconds) {}\\n\\n    generate(id: TokenId, ts: Seconds): void {\\n        this.tokens.set(id, Object.freeze({id, ts}))\\n    }\\n\\n    renew(id: TokenId, ts: Seconds): void {\\n        const token = this.tokens.get(id)\\n        if (!token) return;\\n        if (!this.isNotExpired(token, ts)){\\n            this.tokens.delete(id)\\n            return\\n        }\\n        this.tokens.set(id, Object.freeze({id, ts}))\\n        \\n    }\\n\\n    countUnexpiredTokens(ts: Seconds): number {\\n        return [...this.tokens.values()].filter((token) => this.isNotExpired(token, ts)).length\\n    }\\n\\n    isNotExpired(token: Token, ts: Seconds) {\\n        return (ts - token.ts) < this.ttl\\n    }\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Seconds = number;\\ntype TokenId = string\\ntype Token = Readonly<{\\n    ts: Seconds\\n    id: string\\n}>\\n\\nclass AuthenticationManager {\\n    private tokens: Map<TokenId, Token> = new Map()\\n    \\n    constructor(private ttl: Seconds) {}\\n\\n    generate(id: TokenId, ts: Seconds): void {\\n        this.tokens.set(id, Object.freeze({id, ts}))\\n    }\\n\\n    renew(id: TokenId, ts: Seconds): void {\\n        const token = this.tokens.get(id)\\n        if (!token) return;\\n        if (!this.isNotExpired(token, ts)){\\n            this.tokens.delete(id)\\n            return\\n        }\\n        this.tokens.set(id, Object.freeze({id, ts}))\\n        \\n    }\\n\\n    countUnexpiredTokens(ts: Seconds): number {\\n        return [...this.tokens.values()].filter((token) => this.isNotExpired(token, ts)).length\\n    }\\n\\n    isNotExpired(token: Token, ts: Seconds) {\\n        return (ts - token.ts) < this.ttl\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2642946,
                "title": "java-map-and-token-class-created",
                "content": "```\\nclass Token{\\n    String tokenid;\\n    int gtime;\\n    int etime;\\n    \\n    Token(String s,int g,int e){\\n     tokenid=s;\\n     gtime=g;\\n     etime=e;\\n    }\\n    //gtime is not used so we can take just have tokenId and etime \\n}\\n\\nclass AuthenticationManager {\\n     int timeToLive;\\n      Map<String,Token> map;\\n    \\n    public AuthenticationManager(int timeToLivee) {\\n        this.timeToLive=timeToLivee;\\n        this.map=new HashMap<String,Token>();\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        delete(currentTime);\\n        Token t=new Token(tokenId,currentTime,currentTime+timeToLive);\\n        map.put(tokenId,t);        \\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        delete(currentTime);\\n        \\n        Token t=map.get(tokenId);\\n        if(t==null)return;\\n       \\n        map.remove(t);\\n        int newTime=timeToLive+currentTime;\\n        Token token=new Token(tokenId,currentTime,newTime);\\n        map.put(tokenId,token);\\n        \\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        delete(currentTime);\\n        return map.size();\\n    }\\n    \\n    void delete(int currentTime){\\n       // if iterator not used we ll get concurrentMapmodification error\\n        Iterator<String> it = map.keySet().iterator();\\n            while(it.hasNext()) {\\n            String key = it.next();\\n            if(map.get(key).etime <= currentTime) {\\n                it.remove();\\n            }\\n        }\\n\\n        \\n    }\\n    \\n}\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager obj = new AuthenticationManager(timeToLive);\\n * obj.generate(tokenId,currentTime);\\n * obj.renew(tokenId,currentTime);\\n * int param_3 = obj.countUnexpiredTokens(currentTime);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Design"
                ],
                "code": "```\\nclass Token{\\n    String tokenid;\\n    int gtime;\\n    int etime;\\n    \\n    Token(String s,int g,int e){\\n     tokenid=s;\\n     gtime=g;\\n     etime=e;\\n    }\\n    //gtime is not used so we can take just have tokenId and etime \\n}\\n\\nclass AuthenticationManager {\\n     int timeToLive;\\n      Map<String,Token> map;\\n    \\n    public AuthenticationManager(int timeToLivee) {\\n        this.timeToLive=timeToLivee;\\n        this.map=new HashMap<String,Token>();\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        delete(currentTime);\\n        Token t=new Token(tokenId,currentTime,currentTime+timeToLive);\\n        map.put(tokenId,t);        \\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        delete(currentTime);\\n        \\n        Token t=map.get(tokenId);\\n        if(t==null)return;\\n       \\n        map.remove(t);\\n        int newTime=timeToLive+currentTime;\\n        Token token=new Token(tokenId,currentTime,newTime);\\n        map.put(tokenId,token);\\n        \\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        delete(currentTime);\\n        return map.size();\\n    }\\n    \\n    void delete(int currentTime){\\n       // if iterator not used we ll get concurrentMapmodification error\\n        Iterator<String> it = map.keySet().iterator();\\n            while(it.hasNext()) {\\n            String key = it.next();\\n            if(map.get(key).etime <= currentTime) {\\n                it.remove();\\n            }\\n        }\\n\\n        \\n    }\\n    \\n}\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager obj = new AuthenticationManager(timeToLive);\\n * obj.generate(tokenId,currentTime);\\n * obj.renew(tokenId,currentTime);\\n * int param_3 = obj.countUnexpiredTokens(currentTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629829,
                "title": "golang-map-and-priority-queue",
                "content": "```go\\ntype Token struct {\\n  id string\\n  expiry int\\n  \\n  index int // index of the item in the heap\\n}\\n\\ntype PriorityQueue []*Token\\n\\nfunc (pq PriorityQueue) Len() int           { return len(pq) }\\nfunc (pq PriorityQueue) Less(i, j int) bool {\\n  return pq[i].expiry < pq[j].expiry\\n}\\nfunc (pq PriorityQueue) Swap(i, j int) {\\n  pq[i], pq[j] = pq[j], pq[i]\\n  pq[i].index = i // maintain indices after the swap\\n  pq[j].index = j\\n}\\n\\nfunc (pq *PriorityQueue) Push(x interface{}) {\\n  item := x.(*Token)\\n  item.index = len(*pq)\\n  *pq = append(*pq, item)\\n}\\n\\nfunc (pq *PriorityQueue) Pop() interface{} {\\n  var item *Token\\n  n := len(*pq)\\n  *pq, item = (*pq)[:n-1], (*pq)[n-1]\\n  item.index = -1 // for safety\\n  return item\\n}\\n\\nfunc (pq PriorityQueue) Top() interface{} {\\n  return pq[0]\\n}\\n\\ntype AuthenticationManager struct {\\n  ttl int\\n  tokens map[string]*Token // tokens indexed by its id\\n  heap *PriorityQueue // tokens in a min heap based on the expiry\\n}\\n\\n\\nfunc Constructor(timeToLive int) AuthenticationManager {\\n  return AuthenticationManager{\\n    ttl: timeToLive,\\n    tokens: make(map[string]*Token),\\n    heap: &PriorityQueue{},\\n  }\\n}\\n\\n\\nfunc (this *AuthenticationManager) Generate(tokenId string, currentTime int)  {\\n  token := &Token{id: tokenId, expiry: currentTime + this.ttl}\\n  this.tokens[tokenId] = token\\n  heap.Push(this.heap, token)\\n}\\n\\n\\nfunc (this *AuthenticationManager) Renew(tokenId string, currentTime int)  {\\n  token, ok := this.tokens[tokenId]\\n  if !ok || token.expiry <= currentTime {\\n    return // token doesn\\'t exist; can\\'t renew\\n  }\\n  token.expiry = currentTime + this.ttl\\n  heap.Fix(this.heap, token.index)\\n}\\n\\n\\nfunc (this *AuthenticationManager) CountUnexpiredTokens(currentTime int) int {\\n  for this.heap.Len() > 0 && this.heap.Top().(*Token).expiry <= currentTime {\\n    heap.Pop(this.heap)\\n  }\\n  return this.heap.Len()\\n}\\n\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * obj := Constructor(timeToLive);\\n * obj.Generate(tokenId,currentTime);\\n * obj.Renew(tokenId,currentTime);\\n * param_3 := obj.CountUnexpiredTokens(currentTime);\\n */\\n ```",
                "solutionTags": [
                    "Go",
                    "Heap (Priority Queue)"
                ],
                "code": "```go\\ntype Token struct {\\n  id string\\n  expiry int\\n  \\n  index int // index of the item in the heap\\n}\\n\\ntype PriorityQueue []*Token\\n\\nfunc (pq PriorityQueue) Len() int           { return len(pq) }\\nfunc (pq PriorityQueue) Less(i, j int) bool {\\n  return pq[i].expiry < pq[j].expiry\\n}\\nfunc (pq PriorityQueue) Swap(i, j int) {\\n  pq[i], pq[j] = pq[j], pq[i]\\n  pq[i].index = i // maintain indices after the swap\\n  pq[j].index = j\\n}\\n\\nfunc (pq *PriorityQueue) Push(x interface{}) {\\n  item := x.(*Token)\\n  item.index = len(*pq)\\n  *pq = append(*pq, item)\\n}\\n\\nfunc (pq *PriorityQueue) Pop() interface{} {\\n  var item *Token\\n  n := len(*pq)\\n  *pq, item = (*pq)[:n-1], (*pq)[n-1]\\n  item.index = -1 // for safety\\n  return item\\n}\\n\\nfunc (pq PriorityQueue) Top() interface{} {\\n  return pq[0]\\n}\\n\\ntype AuthenticationManager struct {\\n  ttl int\\n  tokens map[string]*Token // tokens indexed by its id\\n  heap *PriorityQueue // tokens in a min heap based on the expiry\\n}\\n\\n\\nfunc Constructor(timeToLive int) AuthenticationManager {\\n  return AuthenticationManager{\\n    ttl: timeToLive,\\n    tokens: make(map[string]*Token),\\n    heap: &PriorityQueue{},\\n  }\\n}\\n\\n\\nfunc (this *AuthenticationManager) Generate(tokenId string, currentTime int)  {\\n  token := &Token{id: tokenId, expiry: currentTime + this.ttl}\\n  this.tokens[tokenId] = token\\n  heap.Push(this.heap, token)\\n}\\n\\n\\nfunc (this *AuthenticationManager) Renew(tokenId string, currentTime int)  {\\n  token, ok := this.tokens[tokenId]\\n  if !ok || token.expiry <= currentTime {\\n    return // token doesn\\'t exist; can\\'t renew\\n  }\\n  token.expiry = currentTime + this.ttl\\n  heap.Fix(this.heap, token.index)\\n}\\n\\n\\nfunc (this *AuthenticationManager) CountUnexpiredTokens(currentTime int) int {\\n  for this.heap.Len() > 0 && this.heap.Top().(*Token).expiry <= currentTime {\\n    heap.Pop(this.heap)\\n  }\\n  return this.heap.Len()\\n}\\n\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * obj := Constructor(timeToLive);\\n * obj.Generate(tokenId,currentTime);\\n * obj.Renew(tokenId,currentTime);\\n * param_3 := obj.CountUnexpiredTokens(currentTime);\\n */\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 2627183,
                "title": "javascript-detailed-explanation-using-hash-map",
                "content": "```\\n/**\\n * @param {number} timeToLive\\n */\\nvar AuthenticationManager = function(timeToLive) {\\n    // We initialize a ttl and a tokens hash map to hold the data about the tokens.\\n    this.ttl = timeToLive\\n    this.token = new Map();\\n};\\n\\n/** \\n * @param {string} tokenId \\n * @param {number} currentTime\\n * @return {void}\\n */\\nAuthenticationManager.prototype.generate = function(tokenId, currentTime) {\\n    // We set the tokenId as the key, and the currentTime + ttl to the value.\\n    // currentTime + ttl, because we want to know from ahead the full time that will take the token to expire.\\n    this.token.set(tokenId, currentTime + this.ttl);    \\n};\\n\\n/** \\n * @param {string} tokenId \\n * @param {number} currentTime\\n * @return {void}\\n */\\nAuthenticationManager.prototype.renew = function(tokenId, currentTime) {\\n    // If the token doesn\\'t exist, we return null.\\n    if(!this.token.has(tokenId)) {\\n        return null;\\n    }\\n    \\n    // We find the tokenTime by the tokenId (as I mentioned before, the tokenId is our key, so we can find our value by the key).\\n    const tokenTime = this.token.get(tokenId);\\n    \\n    // We check, if the currentTime that we want to renew the token is bigger or equal to the tokenTime that we\\'ve found, we return null.\\n    // Else, we set the new expiration time for the token. \\n    if(currentTime >= tokenTime) {\\n        return null;\\n    } else {\\n        this.token.set(tokenId, currentTime + this.ttl);\\n    }\\n}\\n\\n/** \\n * @param {number} currentTime\\n * @return {number}\\n */\\nAuthenticationManager.prototype.countUnexpiredTokens = function(currentTime) {\\n    // Declare a counter variable to count how many unexpired tokens we have.\\n    let counter = 0;\\n    \\n    // Loop over the tokens hash map.\\n    for(let [_, val] of this.token) {\\n        \\n        // We check if the current time inside of the token is bigger than the currentTime parameter, if it is we counter++.\\n        if(val > currentTime) {\\n            counter++;\\n        } \\n    }\\n    \\n    return counter;\\n};\\n\\n/** \\n * Your AuthenticationManager object will be instantiated and called as such:\\n * var obj = new AuthenticationManager(timeToLive)\\n * obj.generate(tokenId,currentTime)\\n * obj.renew(tokenId,currentTime)\\n * var param_3 = obj.countUnexpiredTokens(currentTime)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} timeToLive\\n */\\nvar AuthenticationManager = function(timeToLive) {\\n    // We initialize a ttl and a tokens hash map to hold the data about the tokens.\\n    this.ttl = timeToLive\\n    this.token = new Map();\\n};\\n\\n/** \\n * @param {string} tokenId \\n * @param {number} currentTime\\n * @return {void}\\n */\\nAuthenticationManager.prototype.generate = function(tokenId, currentTime) {\\n    // We set the tokenId as the key, and the currentTime + ttl to the value.\\n    // currentTime + ttl, because we want to know from ahead the full time that will take the token to expire.\\n    this.token.set(tokenId, currentTime + this.ttl);    \\n};\\n\\n/** \\n * @param {string} tokenId \\n * @param {number} currentTime\\n * @return {void}\\n */\\nAuthenticationManager.prototype.renew = function(tokenId, currentTime) {\\n    // If the token doesn\\'t exist, we return null.\\n    if(!this.token.has(tokenId)) {\\n        return null;\\n    }\\n    \\n    // We find the tokenTime by the tokenId (as I mentioned before, the tokenId is our key, so we can find our value by the key).\\n    const tokenTime = this.token.get(tokenId);\\n    \\n    // We check, if the currentTime that we want to renew the token is bigger or equal to the tokenTime that we\\'ve found, we return null.\\n    // Else, we set the new expiration time for the token. \\n    if(currentTime >= tokenTime) {\\n        return null;\\n    } else {\\n        this.token.set(tokenId, currentTime + this.ttl);\\n    }\\n}\\n\\n/** \\n * @param {number} currentTime\\n * @return {number}\\n */\\nAuthenticationManager.prototype.countUnexpiredTokens = function(currentTime) {\\n    // Declare a counter variable to count how many unexpired tokens we have.\\n    let counter = 0;\\n    \\n    // Loop over the tokens hash map.\\n    for(let [_, val] of this.token) {\\n        \\n        // We check if the current time inside of the token is bigger than the currentTime parameter, if it is we counter++.\\n        if(val > currentTime) {\\n            counter++;\\n        } \\n    }\\n    \\n    return counter;\\n};\\n\\n/** \\n * Your AuthenticationManager object will be instantiated and called as such:\\n * var obj = new AuthenticationManager(timeToLive)\\n * obj.generate(tokenId,currentTime)\\n * obj.renew(tokenId,currentTime)\\n * var param_3 = obj.countUnexpiredTokens(currentTime)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2597821,
                "title": "lazy-removal-of-expired-tokens",
                "content": "Time increases monotonically, a queue can be used to track the expiration times.\\nUpdates get inserted in the queue and expired times removed lazily when unexpired tokens get counted. A separate dictionary tracks the current expiration by token and expired tokens are removed lazily when the last expiry for a token is removed from the queue. Total cost is linear in generate/renew operations, counting active tokens becomes O(1).\\n\\n```\\nclass AuthenticationManager:\\n\\n    def __init__(self, timeToLive: int):\\n        self.ttl = timeToLive\\n        self.tokexpire = deque() # strictly increasing time, no need for minheap\\n        self.tokens = {} # expir time for each tokenid\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self.tokens[tokenId] = currentTime + self.ttl\\n        self.tokexpire.append((self.tokens[tokenId],tokenId))\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if tokenId not in self.tokens or self.tokens[tokenId] <= currentTime:\\n            return # cannot renew expired token\\n        self.tokens[tokenId] = currentTime + self.ttl\\n        self.tokexpire.append((self.tokens[tokenId],tokenId))\\n        \\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        # remove expired tokens if any\\n        while self.tokexpire and self.tokexpire[0][0] <= currentTime:\\n            ti, to = self.tokexpire.popleft()\\n            if self.tokens[to] == ti:\\n                del self.tokens[to]\\n        return len(self.tokens)\\n\\n```",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\nclass AuthenticationManager:\\n\\n    def __init__(self, timeToLive: int):\\n        self.ttl = timeToLive\\n        self.tokexpire = deque() # strictly increasing time, no need for minheap\\n        self.tokens = {} # expir time for each tokenid\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self.tokens[tokenId] = currentTime + self.ttl\\n        self.tokexpire.append((self.tokens[tokenId],tokenId))\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if tokenId not in self.tokens or self.tokens[tokenId] <= currentTime:\\n            return # cannot renew expired token\\n        self.tokens[tokenId] = currentTime + self.ttl\\n        self.tokexpire.append((self.tokens[tokenId],tokenId))\\n        \\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        # remove expired tokens if any\\n        while self.tokexpire and self.tokexpire[0][0] <= currentTime:\\n            ti, to = self.tokexpire.popleft()\\n            if self.tokens[to] == ti:\\n                del self.tokens[to]\\n        return len(self.tokens)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2585488,
                "title": "python-solution-easy-to-understand",
                "content": "```\\nclass AuthenticationManager:\\n    def __init__(self, timeToLive: int):\\n        self.ttl = timeToLive\\n        self.token = {}\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self.token[tokenId] = currentTime + self.ttl\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if tokenId in self.token.keys() and self.token[tokenId] > currentTime:\\n            self.token[tokenId] = currentTime + self.ttl\\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        return sum(currentTime < v for _, v in self.token.items())\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass AuthenticationManager:\\n    def __init__(self, timeToLive: int):\\n        self.ttl = timeToLive\\n        self.token = {}\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self.token[tokenId] = currentTime + self.ttl\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if tokenId in self.token.keys() and self.token[tokenId] > currentTime:\\n            self.token[tokenId] = currentTime + self.ttl\\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        return sum(currentTime < v for _, v in self.token.items())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2565398,
                "title": "c-solution-easy",
                "content": "```\\npublic class AuthenticationManager {\\n\\n            Dictionary<string, int> dic = new Dictionary<string, int>();\\n            int timeTolive;\\n            public AuthenticationManager(int timeToLive)\\n            {\\n                this.timeTolive = timeToLive;\\n            }\\n\\n            public void Generate(string tokenId, int currentTime)\\n            {\\n                dic.Add(tokenId, currentTime);\\n            }\\n\\n            public void Renew(string tokenId, int currentTime)\\n            {\\n                if (dic.ContainsKey(tokenId))\\n                {\\n                    if (dic[tokenId] + this.timeTolive > currentTime)\\n                        dic[tokenId] = currentTime;\\n                }\\n            }\\n\\n            public int CountUnexpiredTokens(int currentTime)\\n            {\\n                int count = 0;\\n                foreach(KeyValuePair<string, int> item in dic)\\n                {\\n                    if (item.Value + this.timeTolive > currentTime)\\n                        count++;\\n                }\\n                return count;\\n            }\\n}",
                "solutionTags": [
                    "C",
                    "C#"
                ],
                "code": "```\\npublic class AuthenticationManager {\\n\\n            Dictionary<string, int> dic = new Dictionary<string, int>();\\n            int timeTolive;\\n            public AuthenticationManager(int timeToLive)\\n            {\\n                this.timeTolive = timeToLive;\\n            }\\n\\n            public void Generate(string tokenId, int currentTime)\\n            {\\n                dic.Add(tokenId, currentTime);\\n            }\\n\\n            public void Renew(string tokenId, int currentTime)\\n            {\\n                if (dic.ContainsKey(tokenId))\\n                {\\n                    if (dic[tokenId] + this.timeTolive > currentTime)\\n                        dic[tokenId] = currentTime;\\n                }\\n            }\\n\\n            public int CountUnexpiredTokens(int currentTime)\\n            {\\n                int count = 0;\\n                foreach(KeyValuePair<string, int> item in dic)\\n                {\\n                    if (item.Value + this.timeTolive > currentTime)\\n                        count++;\\n                }\\n                return count;\\n            }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2512840,
                "title": "easy-python-dict",
                "content": "```\\nclass AuthenticationManager:\\n\\n    def __init__(self, timeToLive: int):\\n        self.ttl=timeToLive\\n        self.token={}\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self.token[tokenId]=currentTime+self.ttl\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if tokenId in self.token.keys():\\n          if self.token[tokenId]>currentTime:\\n             self.token[tokenId]=currentTime+self.ttl\\n        \\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        count=0\\n\\n        for k,v in self.token.items():\\n          if currentTime<v:\\n            count+=1\\n        return count    \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass AuthenticationManager:\\n\\n    def __init__(self, timeToLive: int):\\n        self.ttl=timeToLive\\n        self.token={}\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self.token[tokenId]=currentTime+self.ttl\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if tokenId in self.token.keys():\\n          if self.token[tokenId]>currentTime:\\n             self.token[tokenId]=currentTime+self.ttl\\n        \\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        count=0\\n\\n        for k,v in self.token.items():\\n          if currentTime<v:\\n            count+=1\\n        return count    \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2511640,
                "title": "a-veryyy-easy-soln-in-java",
                "content": "```\\nclass AuthenticationManager {\\n    private int ttl;\\n    private Map<String, Integer> map;\\n\\n    public AuthenticationManager(int timeToLive) {\\n        this.ttl = timeToLive;\\n        this.map = new HashMap<>();\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        map.put(tokenId, currentTime + this.ttl);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        Integer expirationTime = this.map.getOrDefault(tokenId, null);\\n        if (expirationTime == null || expirationTime <= currentTime)\\n            return;\\n        \\n        generate(tokenId, currentTime);\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        int count = 0;\\n        for (Map.Entry<String, Integer> entry: this.map.entrySet())\\n            if (entry.getValue() > currentTime)\\n                count++;\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass AuthenticationManager {\\n    private int ttl;\\n    private Map<String, Integer> map;\\n\\n    public AuthenticationManager(int timeToLive) {\\n        this.ttl = timeToLive;\\n        this.map = new HashMap<>();\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        map.put(tokenId, currentTime + this.ttl);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        Integer expirationTime = this.map.getOrDefault(tokenId, null);\\n        if (expirationTime == null || expirationTime <= currentTime)\\n            return;\\n        \\n        generate(tokenId, currentTime);\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        int count = 0;\\n        for (Map.Entry<String, Integer> entry: this.map.entrySet())\\n            if (entry.getValue() > currentTime)\\n                count++;\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2501428,
                "title": "easy-python-solution-hash-map",
                "content": "```\\nclass AuthenticationManager:\\n    def __init__(self, timeToLive: int):\\n        self.timeToLive = timeToLive\\n        self.expirationTimes = defaultdict(int)\\n        # Time: O(1)\\n        # Space: O(n) where n is the number of unexpired tokens\\n\\n        \\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self.expirationTimes[tokenId] = currentTime + self.timeToLive\\n        # Time: O(1)\\n        # Space: O(1)\\n\\n        \\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if tokenId in self.expirationTimes and self.expirationTimes[tokenId] > currentTime:\\n            self.expirationTimes[tokenId] = currentTime + self.timeToLive\\n        # Time: O(1)\\n        # Space: O(1)\\n        \\n        \\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        return sum(1 for time in list(self.expirationTimes.values()) if time > currentTime)\\n        # Time: O(n)\\n        # Space: O(n) where n is the number of unexpired tokens\\n```",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "```\\nclass AuthenticationManager:\\n    def __init__(self, timeToLive: int):\\n        self.timeToLive = timeToLive\\n        self.expirationTimes = defaultdict(int)\\n        # Time: O(1)\\n        # Space: O(n) where n is the number of unexpired tokens\\n\\n        \\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self.expirationTimes[tokenId] = currentTime + self.timeToLive\\n        # Time: O(1)\\n        # Space: O(1)\\n\\n        \\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if tokenId in self.expirationTimes and self.expirationTimes[tokenId] > currentTime:\\n            self.expirationTimes[tokenId] = currentTime + self.timeToLive\\n        # Time: O(1)\\n        # Space: O(1)\\n        \\n        \\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        return sum(1 for time in list(self.expirationTimes.values()) if time > currentTime)\\n        # Time: O(n)\\n        # Space: O(n) where n is the number of unexpired tokens\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2500698,
                "title": "cpp",
                "content": "\\tclass AuthenticationManager {\\n\\t\\tint t = 0;\\n\\t\\tunordered_map<string,int> m;\\n\\tpublic:\\n\\t\\tAuthenticationManager(int timeToLive) {\\n\\t\\t\\tt = timeToLive;\\n\\t\\t}\\n\\n\\t\\tvoid generate(string tokenId, int currentTime) {\\n\\t\\t\\tm[tokenId] = currentTime+t;\\n\\t\\t}\\n\\n\\t\\tvoid renew(string tokenId, int currentTime) {\\n\\t\\t\\tif(m.find(tokenId)!= m.end() && m[tokenId]>currentTime){\\n\\t\\t\\t\\tm[tokenId] = t+currentTime;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tint countUnexpiredTokens(int currentTime) {\\n\\t\\t\\tvector<string> b;\\n\\t\\t\\tfor(auto a : m){\\n\\t\\t\\t\\tif(a.second <= currentTime){\\n\\t\\t\\t\\t\\tb.push_back(a.first);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor(auto a: b){\\n\\t\\t\\t\\tm.erase(a);\\n\\t\\t\\t}\\n\\t\\t\\treturn m.size();\\n\\t\\t}\\n\\t};\\n",
                "solutionTags": [],
                "code": "\\tclass AuthenticationManager {\\n\\t\\tint t = 0;\\n\\t\\tunordered_map<string,int> m;\\n\\tpublic:\\n\\t\\tAuthenticationManager(int timeToLive) {\\n\\t\\t\\tt = timeToLive;\\n\\t\\t}\\n\\n\\t\\tvoid generate(string tokenId, int currentTime) {\\n\\t\\t\\tm[tokenId] = currentTime+t;\\n\\t\\t}\\n\\n\\t\\tvoid renew(string tokenId, int currentTime) {\\n\\t\\t\\tif(m.find(tokenId)!= m.end() && m[tokenId]>currentTime){\\n\\t\\t\\t\\tm[tokenId] = t+currentTime;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tint countUnexpiredTokens(int currentTime) {\\n\\t\\t\\tvector<string> b;\\n\\t\\t\\tfor(auto a : m){\\n\\t\\t\\t\\tif(a.second <= currentTime){\\n\\t\\t\\t\\t\\tb.push_back(a.first);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor(auto a: b){\\n\\t\\t\\t\\tm.erase(a);\\n\\t\\t\\t}\\n\\t\\t\\treturn m.size();\\n\\t\\t}\\n\\t};\\n",
                "codeTag": "Java"
            },
            {
                "id": 2497617,
                "title": "c-84-ms",
                "content": "```\\nclass AuthenticationManager {\\npublic:\\n    AuthenticationManager(int timeToLive) {\\n        TTL=timeToLive;\\n    }\\n    \\n    void generate(const string& tokenId, int currentTime) {\\n        int tmp=currentTime+TTL;\\n        tokens[tokenId]=tmp;\\n        times.push_back(tmp);\\n    }\\n    \\n    void renew(const string& tokenId, int currentTime) {\\n        if(currentTime<tokens[tokenId]) {\\n            times.erase(find(times.begin(),times.end(),tokens[tokenId]));\\n            generate(tokenId,currentTime);\\n        }\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        return times.end()-upper_bound(times.begin(),times.end(),currentTime);\\n    }\\nprivate:\\n        int TTL;\\n        unordered_map<string,int> tokens;\\n        vector<int> times;\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass AuthenticationManager {\\npublic:\\n    AuthenticationManager(int timeToLive) {\\n        TTL=timeToLive;\\n    }\\n    \\n    void generate(const string& tokenId, int currentTime) {\\n        int tmp=currentTime+TTL;\\n        tokens[tokenId]=tmp;\\n        times.push_back(tmp);\\n    }\\n    \\n    void renew(const string& tokenId, int currentTime) {\\n        if(currentTime<tokens[tokenId]) {\\n            times.erase(find(times.begin(),times.end(),tokens[tokenId]));\\n            generate(tokenId,currentTime);\\n        }\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        return times.end()-upper_bound(times.begin(),times.end(),currentTime);\\n    }\\nprivate:\\n        int TTL;\\n        unordered_map<string,int> tokens;\\n        vector<int> times;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2478723,
                "title": "python-easy-solution-using-hashmap",
                "content": "```\\nclass AuthenticationManager:\\n\\n    def __init__(self, timeToLive: int):\\n        self.timeToLive = timeToLive\\n        self.tokens = {}\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self.tokens[tokenId] = currentTime + self.timeToLive\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if self.tokens.get(tokenId, 0) > currentTime:\\n            self.tokens[tokenId] = currentTime + self.timeToLive\\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        count = 0\\n        for tokenId in self.tokens:\\n            if self.tokens[tokenId] > currentTime:\\n                count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass AuthenticationManager:\\n\\n    def __init__(self, timeToLive: int):\\n        self.timeToLive = timeToLive\\n        self.tokens = {}\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self.tokens[tokenId] = currentTime + self.timeToLive\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if self.tokens.get(tokenId, 0) > currentTime:\\n            self.tokens[tokenId] = currentTime + self.timeToLive\\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        count = 0\\n        for tokenId in self.tokens:\\n            if self.tokens[tokenId] > currentTime:\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2373461,
                "title": "very-easy-and-simple-to-understand-c-solution-using-map-and-set",
                "content": "<b> Up Vote if you like the solution \\n```\\nclass AuthenticationManager {\\npublic:\\n    int timeout;\\n    \\n    unordered_map<string, int> tokenMap;\\n    set<pair<int, string>> timeMap;\\n    \\n    AuthenticationManager(int timeToLive) {\\n        timeout = timeToLive;\\n    }\\n    void cleanup(int currentTime){\\n        while(!timeMap.empty() && (*timeMap.begin()).first <= currentTime){\\n            tokenMap.erase((*timeMap.begin()).second);\\n            timeMap.erase(timeMap.begin());\\n        }\\n    }\\n    void generate(string tokenId, int currentTime) {\\n        timeMap.insert({currentTime + timeout, tokenId});\\n        tokenMap[tokenId] = currentTime + timeout;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        cleanup(currentTime);\\n        auto it = tokenMap.find(tokenId);\\n        if(it != tokenMap.end()){\\n            timeMap.erase({ it->second, tokenId});\\n            timeMap.insert({currentTime + timeout, tokenId});\\n            tokenMap[tokenId] = currentTime + timeout;\\n        }\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        cleanup(currentTime);\\n        return tokenMap.size();\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass AuthenticationManager {\\npublic:\\n    int timeout;\\n    \\n    unordered_map<string, int> tokenMap;\\n    set<pair<int, string>> timeMap;\\n    \\n    AuthenticationManager(int timeToLive) {\\n        timeout = timeToLive;\\n    }\\n    void cleanup(int currentTime){\\n        while(!timeMap.empty() && (*timeMap.begin()).first <= currentTime){\\n            tokenMap.erase((*timeMap.begin()).second);\\n            timeMap.erase(timeMap.begin());\\n        }\\n    }\\n    void generate(string tokenId, int currentTime) {\\n        timeMap.insert({currentTime + timeout, tokenId});\\n        tokenMap[tokenId] = currentTime + timeout;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        cleanup(currentTime);\\n        auto it = tokenMap.find(tokenId);\\n        if(it != tokenMap.end()){\\n            timeMap.erase({ it->second, tokenId});\\n            timeMap.insert({currentTime + timeout, tokenId});\\n            tokenMap[tokenId] = currentTime + timeout;\\n        }\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        cleanup(currentTime);\\n        return tokenMap.size();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2369928,
                "title": "c-line-sweep-approach-different-approach-then-others",
                "content": "```\\nclass AuthenticationManager {\\nint end=0;\\nunordered_map <string,pair <int,int>> getTimes;\\nmap <int,int> mpTime;\\nint livecnt=0;\\npublic:\\n    \\n    \\n    \\n    \\n    // maintain map for this, method will be line sweep\\n    \\n    // mp[{currTime,string}]++, mp[{currTime+end,string}]--;\\n    \\n    /*[\"AuthenticationManager\", \"renew\", \"generate\", \"countUnexpiredTokens\", \"generate\", \"renew\", \"renew\", \"countUnexpiredTokens\"]\\n[[5], [\"aaa\", 1], [\"aaa\", 2], [6], [\"bbb\", 7], [\"aaa\", 8], [\"bbb\", 10], [15]]\\n\\n\\n\\n\\nunordered_map for maintaining {starttime,endtime}\\nmap <> for maintaining timinig information\\nlivecnt will be maintained to get livecnt \\n\\n                 \\'aaa\\' => {2,7}\\n                 \\n                 \\n                 2  => 1   \\n                 t=6   livecnt=1\\n                 7  => 0\\n                 \\n                 \\n */ \\n    AuthenticationManager(int timeToLive) {\\n        end=timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        getTimes[tokenId]={currentTime,currentTime+end};\\n        \\n        mpTime[currentTime]+=1;\\n        mpTime[currentTime+end]-=1;\\n        \\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if(getTimes.find(tokenId)==getTimes.end())return;\\n        if(getTimes[tokenId].second > currentTime)\\n        {\\n            int endTime=getTimes[tokenId].second;\\n            getTimes[tokenId].second=currentTime+end;\\n            \\n            mpTime[endTime]+=1;\\n            mpTime[currentTime+end]-=1;\\n        }\\n        return;\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int cnt=0;\\n        \\n        for(auto nj:mpTime)\\n        {\\n            if(nj.first > currentTime)break;\\n            cnt+=nj.second;\\n        }\\n        return cnt;\\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */\\n````",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass AuthenticationManager {\\nint end=0;\\nunordered_map <string,pair <int,int>> getTimes;\\nmap <int,int> mpTime;\\nint livecnt=0;\\npublic:\\n    \\n    \\n    \\n    \\n    // maintain map for this, method will be line sweep\\n    \\n    // mp[{currTime,string}]++, mp[{currTime+end,string}]--;\\n    \\n    /*[\"AuthenticationManager\", \"renew\", \"generate\", \"countUnexpiredTokens\", \"generate\", \"renew\", \"renew\", \"countUnexpiredTokens\"]\\n[[5], [\"aaa\", 1], [\"aaa\", 2], [6], [\"bbb\", 7], [\"aaa\", 8], [\"bbb\", 10], [15]]\\n\\n\\n\\n\\nunordered_map for maintaining {starttime,endtime}\\nmap <> for maintaining timinig information\\nlivecnt will be maintained to get livecnt \\n\\n                 \\'aaa\\' => {2,7}\\n                 \\n                 \\n                 2  => 1   \\n                 t=6   livecnt=1\\n                 7  => 0\\n                 \\n                 \\n */ \\n    AuthenticationManager(int timeToLive) {\\n        end=timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        getTimes[tokenId]={currentTime,currentTime+end};\\n        \\n        mpTime[currentTime]+=1;\\n        mpTime[currentTime+end]-=1;\\n        \\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if(getTimes.find(tokenId)==getTimes.end())return;\\n        if(getTimes[tokenId].second > currentTime)\\n        {\\n            int endTime=getTimes[tokenId].second;\\n            getTimes[tokenId].second=currentTime+end;\\n            \\n            mpTime[endTime]+=1;\\n            mpTime[currentTime+end]-=1;\\n        }\\n        return;\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int cnt=0;\\n        \\n        for(auto nj:mpTime)\\n        {\\n            if(nj.first > currentTime)break;\\n            cnt+=nj.second;\\n        }\\n        return cnt;\\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2290295,
                "title": "easy-cpp",
                "content": "```\\nclass AuthenticationManager {\\n    map<string,int> tokens;\\n    int time;\\npublic:\\n    AuthenticationManager(int timeToLive) {\\n        time=timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n           if(tokens.find(tokenId)==tokens.end()){\\n               tokens[tokenId]=time+currentTime;\\n           }\\n        \\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n            if(tokens.find(tokenId)!=tokens.end()){\\n                    if(currentTime<tokens[tokenId]){\\n                        tokens[tokenId]=currentTime+time;\\n                    }\\n        }\\n        \\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int count=0;\\n        for(auto itr=tokens.begin();itr!=tokens.end();itr++){\\n            if(itr->second>currentTime) count++;\\n        }\\n        return count;\\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass AuthenticationManager {\\n    map<string,int> tokens;\\n    int time;\\npublic:\\n    AuthenticationManager(int timeToLive) {\\n        time=timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n           if(tokens.find(tokenId)==tokens.end()){\\n               tokens[tokenId]=time+currentTime;\\n           }\\n        \\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n            if(tokens.find(tokenId)!=tokens.end()){\\n                    if(currentTime<tokens[tokenId]){\\n                        tokens[tokenId]=currentTime+time;\\n                    }\\n        }\\n        \\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int count=0;\\n        for(auto itr=tokens.begin();itr!=tokens.end();itr++){\\n            if(itr->second>currentTime) count++;\\n        }\\n        return count;\\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2289756,
                "title": "c-solution-hashmap",
                "content": "```\\nclass AuthenticationManager {\\n    int livingTime;\\n    unordered_map<string, int> cache; //<id, endTime>\\npublic:\\n    AuthenticationManager(int timeToLive) {\\n        livingTime=timeToLive;\\n        cache={};\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        cache[tokenId]=currentTime+livingTime;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if(cache.count(tokenId) && cache[tokenId]>currentTime)\\n            cache[tokenId]=currentTime+livingTime;\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int count=0;\\n        for(auto &[id, time]: cache)\\n            if(currentTime<time)\\n                count++;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass AuthenticationManager {\\n    int livingTime;\\n    unordered_map<string, int> cache; //<id, endTime>\\npublic:\\n    AuthenticationManager(int timeToLive) {\\n        livingTime=timeToLive;\\n        cache={};\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        cache[tokenId]=currentTime+livingTime;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if(cache.count(tokenId) && cache[tokenId]>currentTime)\\n            cache[tokenId]=currentTime+livingTime;\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int count=0;\\n        for(auto &[id, time]: cache)\\n            if(currentTime<time)\\n                count++;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2287244,
                "title": "c-easy-implementation-explained",
                "content": "* In a map store the tokenId string and time till which this token will be alive.\\n*`time = currentTime + timeToLive `*\\n\\n```\\nclass AuthenticationManager {\\npublic:\\n    int ttl;\\n    unordered_map<string, int> tokens;\\n    \\n    AuthenticationManager(int timeToLive) {\\n        this->ttl = timeToLive;    \\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        this->tokens[tokenId] = currentTime + this->ttl;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        \\n        if(this->tokens[tokenId] > currentTime){\\n            this->tokens[tokenId] = currentTime + this->ttl;\\n        }\\n        \\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        \\n        int ans = 0;\\n        for(auto token : this->tokens)\\n        {\\n            if(token.second > currentTime)\\n                ans += 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Design"
                ],
                "code": "```\\nclass AuthenticationManager {\\npublic:\\n    int ttl;\\n    unordered_map<string, int> tokens;\\n    \\n    AuthenticationManager(int timeToLive) {\\n        this->ttl = timeToLive;    \\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        this->tokens[tokenId] = currentTime + this->ttl;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        \\n        if(this->tokens[tokenId] > currentTime){\\n            this->tokens[tokenId] = currentTime + this->ttl;\\n        }\\n        \\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        \\n        int ans = 0;\\n        for(auto token : this->tokens)\\n        {\\n            if(token.second > currentTime)\\n                ans += 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2268869,
                "title": "c-priority-queue-hash-map-update-when-cleanup",
                "content": "```\\nclass AuthenticationManager {\\nprivate:\\n    int ttl;\\n    unordered_map<string, int> dict;\\n    priority_queue<pair<int, string>> pq;\\npublic:\\n    AuthenticationManager(int timeToLive) {\\n        ttl = timeToLive;\\n    }\\n    \\n    void cleanup(int currentTime) {\\n        while (pq.empty() == 0 && -pq.top().first <= currentTime) {\\n            string tokenId = pq.top().second;\\n            int ptime = -pq.top().first;\\n            int dtime = dict[tokenId];\\n            pq.pop();\\n            if (ptime == dtime)\\n                dict.erase(tokenId);\\n            else\\n                pq.push({-dtime, tokenId});\\n        }\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        dict[tokenId] = currentTime + ttl;\\n        pq.push({-currentTime-ttl, tokenId});\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        cleanup(currentTime);\\n        if (dict.find(tokenId) == dict.end())\\n            return;\\n        dict[tokenId] = currentTime + ttl;\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        cleanup(currentTime);\\n        return pq.size();\\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass AuthenticationManager {\\nprivate:\\n    int ttl;\\n    unordered_map<string, int> dict;\\n    priority_queue<pair<int, string>> pq;\\npublic:\\n    AuthenticationManager(int timeToLive) {\\n        ttl = timeToLive;\\n    }\\n    \\n    void cleanup(int currentTime) {\\n        while (pq.empty() == 0 && -pq.top().first <= currentTime) {\\n            string tokenId = pq.top().second;\\n            int ptime = -pq.top().first;\\n            int dtime = dict[tokenId];\\n            pq.pop();\\n            if (ptime == dtime)\\n                dict.erase(tokenId);\\n            else\\n                pq.push({-dtime, tokenId});\\n        }\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        dict[tokenId] = currentTime + ttl;\\n        pq.push({-currentTime-ttl, tokenId});\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        cleanup(currentTime);\\n        if (dict.find(tokenId) == dict.end())\\n            return;\\n        dict[tokenId] = currentTime + ttl;\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        cleanup(currentTime);\\n        return pq.size();\\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2188452,
                "title": "python-dictionary-easy-solution",
                "content": "```\\nclass AuthenticationManager:\\n\\n    def __init__(self, timeToLive: int):\\n        self.time = timeToLive\\n        self.tokens = {}\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self.tokens[tokenId] = currentTime + self.time\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if self.tokens.get(tokenId, 0) > currentTime:\\n            self.tokens[tokenId] = currentTime+self.time\\n            \\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        count = 0\\n        for k, v in self.tokens.items():\\n            if v > currentTime:\\n                count+=1\\n        return count\\n",
                "solutionTags": [],
                "code": "```\\nclass AuthenticationManager:\\n\\n    def __init__(self, timeToLive: int):\\n        self.time = timeToLive\\n        self.tokens = {}\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self.tokens[tokenId] = currentTime + self.time\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if self.tokens.get(tokenId, 0) > currentTime:\\n            self.tokens[tokenId] = currentTime+self.time\\n            \\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        count = 0\\n        for k, v in self.tokens.items():\\n            if v > currentTime:\\n                count+=1\\n        return count\\n",
                "codeTag": "Java"
            },
            {
                "id": 2179271,
                "title": "simple-python-solution-with-defaultdict",
                "content": "Key points of this solution:\\n1) Use **[defaultdict](https://docs.python.org/3/library/collections.html#collections.defaultdict)**, it doesn\\'t raise an exception if the requested key was not found.\\n2) Store tokens as ```{ tokenId : token expiration time }```\\n3) Delete all expired tokens on each call of ```countUnexpiredTokens```, this will keep memory usage low and the calculation of unexpired tokens as simple as the length of the ```self.tokens``` dictionary.\\n\\n\\n```\\nclass AuthenticationManager:\\n\\n    def __init__(self, timeToLive: int):\\n        self.tokens = defaultdict(int)\\n        self.ttl = timeToLive\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self.tokens[tokenId] = currentTime + self.ttl\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if self.tokens[tokenId] > currentTime:\\n            self.tokens[tokenId] = currentTime + self.ttl\\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        tokens_to_del = [x for x in self.tokens.keys() if self.tokens[x] <= currentTime]\\n        while tokens_to_del:\\n            self.tokens.pop(tokens_to_del.pop())\\n        return len(self.tokens.keys())\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```{ tokenId : token expiration time }```\n```countUnexpiredTokens```\n```self.tokens```\n```\\nclass AuthenticationManager:\\n\\n    def __init__(self, timeToLive: int):\\n        self.tokens = defaultdict(int)\\n        self.ttl = timeToLive\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self.tokens[tokenId] = currentTime + self.ttl\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if self.tokens[tokenId] > currentTime:\\n            self.tokens[tokenId] = currentTime + self.ttl\\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        tokens_to_del = [x for x in self.tokens.keys() if self.tokens[x] <= currentTime]\\n        while tokens_to_del:\\n            self.tokens.pop(tokens_to_del.pop())\\n        return len(self.tokens.keys())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2161753,
                "title": "java-hashset-solution",
                "content": "```\\nclass AuthenticationManager {\\n\\n    Set<Token> set;\\n    int timeToLive;\\n    \\n    class Token{\\n        String stringId;\\n        int expiryTime;\\n        \\n        Token(String stringId, int expiryTime){\\n            this.stringId = stringId;\\n            this.expiryTime = expiryTime;\\n        }\\n    }\\n    \\n    public AuthenticationManager(int timeToLive) {\\n        this.timeToLive = timeToLive;\\n        set = new HashSet<>();\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        set.add(new Token(tokenId, currentTime + timeToLive));\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        Token token = new Token(tokenId, currentTime + timeToLive);\\n        \\n        for(Token t : set){\\n            if(t.stringId.equals(tokenId) && currentTime < t.expiryTime){\\n                set.remove(t); //if found with same id and can be renewed I removed it and replaced with same token to avoid duplicates\\n                set.add(token);\\n                return;\\n            }\\n        }\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        int res = 0;\\n        for(Token t : set){\\n            if(t.expiryTime > currentTime)\\n                res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass AuthenticationManager {\\n\\n    Set<Token> set;\\n    int timeToLive;\\n    \\n    class Token{\\n        String stringId;\\n        int expiryTime;\\n        \\n        Token(String stringId, int expiryTime){\\n            this.stringId = stringId;\\n            this.expiryTime = expiryTime;\\n        }\\n    }\\n    \\n    public AuthenticationManager(int timeToLive) {\\n        this.timeToLive = timeToLive;\\n        set = new HashSet<>();\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        set.add(new Token(tokenId, currentTime + timeToLive));\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        Token token = new Token(tokenId, currentTime + timeToLive);\\n        \\n        for(Token t : set){\\n            if(t.stringId.equals(tokenId) && currentTime < t.expiryTime){\\n                set.remove(t); //if found with same id and can be renewed I removed it and replaced with same token to avoid duplicates\\n                set.add(token);\\n                return;\\n            }\\n        }\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        int res = 0;\\n        for(Token t : set){\\n            if(t.expiryTime > currentTime)\\n                res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2153834,
                "title": "c-easy-hashmap",
                "content": "```\\nclass AuthenticationManager {\\npublic:\\n    unordered_map<string,int> mp;\\n    int ttl;\\n    AuthenticationManager(int timeToLive) {\\n        ttl = timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        mp[tokenId] = ttl+currentTime;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if(mp[tokenId]==0 || mp[tokenId]<=currentTime)\\n            return;\\n        mp[tokenId] = ttl+currentTime;\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int c = 0;\\n        for(auto x:mp)\\n            if(x.second>currentTime)\\n                c++;\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass AuthenticationManager {\\npublic:\\n    unordered_map<string,int> mp;\\n    int ttl;\\n    AuthenticationManager(int timeToLive) {\\n        ttl = timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        mp[tokenId] = ttl+currentTime;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if(mp[tokenId]==0 || mp[tokenId]<=currentTime)\\n            return;\\n        mp[tokenId] = ttl+currentTime;\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int c = 0;\\n        for(auto x:mp)\\n            if(x.second>currentTime)\\n                c++;\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2118302,
                "title": "c-elegant-solution-clean-and-easy-to-understand-dictionary",
                "content": "\\'\\'\\'\\npublic class Token{\\n\\n    public int start;\\n    public int end;\\n    \\n    public Token(int start, int end){\\n        this.start = start;\\n        this.end = end;\\n    }\\n    public bool IsTokenActive(int currentTime) \\n        => currentTime >= start && currentTime < end;\\n}\\npublic class AuthenticationManager {\\n\\n    Dictionary<string, Token> map;\\n    int time;\\n    public AuthenticationManager(int timeToLive) {\\n        map = new Dictionary<string, Token>();\\n        time = timeToLive;\\n    }\\n    \\n    public void Generate(string tokenId, int currentTime) {\\n        map.Add(tokenId, new Token(currentTime, currentTime + time));\\n    }\\n    \\n    public void Renew(string tokenId, int currentTime) {\\n        if(!map.ContainsKey(tokenId))\\n            return;\\n        if(map[tokenId].IsTokenActive(currentTime)){\\n            map[tokenId].start = currentTime;\\n            map[tokenId].end = currentTime + time;\\n        }\\n    }   \\n    public int CountUnexpiredTokens(int currentTime) =>\\n        map.Count(x => x.Value.IsTokenActive(currentTime));\\n}\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\npublic class Token{\\n\\n    public int start;\\n    public int end;\\n    \\n    public Token(int start, int end){\\n        this.start = start;\\n        this.end = end;\\n    }\\n    public bool IsTokenActive(int currentTime) \\n        => currentTime >= start && currentTime < end;\\n}\\npublic class AuthenticationManager {\\n\\n    Dictionary<string, Token> map;\\n    int time;\\n    public AuthenticationManager(int timeToLive) {\\n        map = new Dictionary<string, Token>();\\n        time = timeToLive;\\n    }\\n    \\n    public void Generate(string tokenId, int currentTime) {\\n        map.Add(tokenId, new Token(currentTime, currentTime + time));\\n    }\\n    \\n    public void Renew(string tokenId, int currentTime) {\\n        if(!map.ContainsKey(tokenId))\\n            return;\\n        if(map[tokenId].IsTokenActive(currentTime)){\\n            map[tokenId].start = currentTime;\\n            map[tokenId].end = currentTime + time;\\n        }\\n    }   \\n    public int CountUnexpiredTokens(int currentTime) =>\\n        map.Count(x => x.Value.IsTokenActive(currentTime));\\n}\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 2108453,
                "title": "hashmap-python",
                "content": "```\\nclass AuthenticationManager:\\n    def __init__(self, timeToLive: int):\\n        self.life = timeToLive\\n        self.tokens = {}\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self.tokens[tokenId] = currentTime+self.life\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if tokenId in self.tokens and self.tokens[tokenId] > currentTime:\\n            self.tokens[tokenId] = currentTime + self.life\\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        ans = 0\\n        for i in self.tokens:\\n            if self.tokens[i] > currentTime:\\n                ans+=1\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass AuthenticationManager:\\n    def __init__(self, timeToLive: int):\\n        self.life = timeToLive\\n        self.tokens = {}\\n\\n    def generate(self, tokenId: str, currentTime: int) -> None:\\n        self.tokens[tokenId] = currentTime+self.life\\n\\n    def renew(self, tokenId: str, currentTime: int) -> None:\\n        if tokenId in self.tokens and self.tokens[tokenId] > currentTime:\\n            self.tokens[tokenId] = currentTime + self.life\\n\\n    def countUnexpiredTokens(self, currentTime: int) -> int:\\n        ans = 0\\n        for i in self.tokens:\\n            if self.tokens[i] > currentTime:\\n                ans+=1\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2089159,
                "title": "scala",
                "content": "```\\nimport scala.collection.mutable\\n\\nclass AuthenticationManager(timeToLive: Int) {\\n  private val tokenToExpiryTime = mutable.Map.empty[String, Int]\\n\\n  def generate(tokenId: String, currentTime: Int) {\\n    tokenToExpiryTime(tokenId) = currentTime + timeToLive\\n  }\\n\\n  def renew(tokenId: String, currentTime: Int) {\\n    tokenToExpiryTime.updateWith(tokenId) {\\n      _.collect { case expiryTime if expiryTime > currentTime => currentTime + timeToLive }\\n    }\\n  }\\n\\n  def countUnexpiredTokens(currentTime: Int): Int = {\\n    tokenToExpiryTime.valuesIterator.count(_ > currentTime)\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nimport scala.collection.mutable\\n\\nclass AuthenticationManager(timeToLive: Int) {\\n  private val tokenToExpiryTime = mutable.Map.empty[String, Int]\\n\\n  def generate(tokenId: String, currentTime: Int) {\\n    tokenToExpiryTime(tokenId) = currentTime + timeToLive\\n  }\\n\\n  def renew(tokenId: String, currentTime: Int) {\\n    tokenToExpiryTime.updateWith(tokenId) {\\n      _.collect { case expiryTime if expiryTime > currentTime => currentTime + timeToLive }\\n    }\\n  }\\n\\n  def countUnexpiredTokens(currentTime: Int): Int = {\\n    tokenToExpiryTime.valuesIterator.count(_ > currentTime)\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084419,
                "title": "java-using-linked-list-simple-iterative-logic-explanation",
                "content": "**Please Upvote**\\n```\\nclass Node {\\n    int val;\\n    String token;\\n    Node next;\\n    Node(int val,String token, Node next){\\n        this.val = val;\\n        this.token = token;\\n        this.next = next;\\n    }\\n}\\nclass AuthenticationManager {\\n    /*\\n        -------------------------------\\n        The basic idea is :\\n        - head will point to lastest generated token and val = time till it valid\\n        - and will replace head with newly generated token and place previous head as it next \\n        - and at time of renew will be remove the expired nodes\\n        (//since nodes after an expired node are all expired )\\n        also if contain the current token remove it from list;\\n        and add renewed as newly generated node\\n        \\n        - same for count unexpired but no token will be there and then count\\n        - \\n        ---------------------------\\n    */\\n    private Node head;\\n    \\n    private int timeToLive;\\n    \\n    private boolean renewFlag;\\n    \\n    public AuthenticationManager(int timeToLive) {\\n        \\n        this.head = null;\\n        this.timeToLive = timeToLive ;\\n        \\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        \\n        Node n = new Node(currentTime+timeToLive,tokenId,head);\\n        head = n;\\n        \\n    }\\n    private void removingExpire(String tokenId,int currentTime){\\n        renewFlag = false;\\n        if(head==null)return;\\n        if(head.val <= currentTime){\\n            head = null;\\n            return;\\n        }\\n        if(head.token.equals(tokenId)){\\n            head = head.next;\\n            renewFlag = true;\\n            return;\\n        }\\n        \\n        Node it = head;\\n        \\n        while(it!=null&&it.next!=null){\\n            if(it.next.val<=currentTime)it.next = null;\\n            else if( it.next.token.equals(tokenId) ){\\n                it.next = it.next.next;\\n                renewFlag = true;\\n            }\\n            if(it.next!=null&&it.next.val<=currentTime)it.next = null;\\n            \\n            it = it.next;\\n        }\\n            \\n    }\\n    public void renew(String tokenId, int currentTime) {\\n            \\n        removingExpire(tokenId,currentTime);\\n        \\n        if(!renewFlag)return;\\n        \\n        Node n = new Node(currentTime+timeToLive,tokenId,head);\\n        head = n;\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        // removingExpire(\"\",currentTime);\\n        int i = 0;\\n        Node it = head;\\n        while(it!=null && it.val>currentTime){\\n            i++;\\n            it = it.next;\\n        }\\n        return i;\\n    }\\n}\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager obj = new AuthenticationManager(timeToLive);\\n * obj.generate(tokenId,currentTime);\\n * obj.renew(tokenId,currentTime);\\n * int param_3 = obj.countUnexpiredTokens(currentTime);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Node {\\n    int val;\\n    String token;\\n    Node next;\\n    Node(int val,String token, Node next){\\n        this.val = val;\\n        this.token = token;\\n        this.next = next;\\n    }\\n}\\nclass AuthenticationManager {\\n    /*\\n        -------------------------------\\n        The basic idea is :\\n        - head will point to lastest generated token and val = time till it valid\\n        - and will replace head with newly generated token and place previous head as it next \\n        - and at time of renew will be remove the expired nodes\\n        (//since nodes after an expired node are all expired )\\n        also if contain the current token remove it from list;\\n        and add renewed as newly generated node\\n        \\n        - same for count unexpired but no token will be there and then count\\n        - \\n        ---------------------------\\n    */\\n    private Node head;\\n    \\n    private int timeToLive;\\n    \\n    private boolean renewFlag;\\n    \\n    public AuthenticationManager(int timeToLive) {\\n        \\n        this.head = null;\\n        this.timeToLive = timeToLive ;\\n        \\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        \\n        Node n = new Node(currentTime+timeToLive,tokenId,head);\\n        head = n;\\n        \\n    }\\n    private void removingExpire(String tokenId,int currentTime){\\n        renewFlag = false;\\n        if(head==null)return;\\n        if(head.val <= currentTime){\\n            head = null;\\n            return;\\n        }\\n        if(head.token.equals(tokenId)){\\n            head = head.next;\\n            renewFlag = true;\\n            return;\\n        }\\n        \\n        Node it = head;\\n        \\n        while(it!=null&&it.next!=null){\\n            if(it.next.val<=currentTime)it.next = null;\\n            else if( it.next.token.equals(tokenId) ){\\n                it.next = it.next.next;\\n                renewFlag = true;\\n            }\\n            if(it.next!=null&&it.next.val<=currentTime)it.next = null;\\n            \\n            it = it.next;\\n        }\\n            \\n    }\\n    public void renew(String tokenId, int currentTime) {\\n            \\n        removingExpire(tokenId,currentTime);\\n        \\n        if(!renewFlag)return;\\n        \\n        Node n = new Node(currentTime+timeToLive,tokenId,head);\\n        head = n;\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        // removingExpire(\"\",currentTime);\\n        int i = 0;\\n        Node it = head;\\n        while(it!=null && it.val>currentTime){\\n            i++;\\n            it = it.next;\\n        }\\n        return i;\\n    }\\n}\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager obj = new AuthenticationManager(timeToLive);\\n * obj.generate(tokenId,currentTime);\\n * obj.renew(tokenId,currentTime);\\n * int param_3 = obj.countUnexpiredTokens(currentTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2078809,
                "title": "c-solution",
                "content": "\\'\\'\\'\\n class AuthenticationManager {\\n public:\\n    int timeToLive;\\n    map<string, pair<int, int>> intervals;\\n    AuthenticationManager(int timeToLive) {\\n        this->timeToLive = timeToLive;\\n        //cout<<\"timeToLive: \"<<timeToLive<<endl;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        pair<int,int> p{0,0};\\n        intervals[tokenId] = p;\\n        intervals[tokenId].first = currentTime;\\n        intervals[tokenId].second = currentTime + timeToLive;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        map<string, pair<int, int>>::iterator it;\\n        it = intervals.find(tokenId);\\n        if (it != intervals.end()){\\n            if (currentTime < intervals[tokenId].second){\\n                intervals[tokenId].first = currentTime;\\n                intervals[tokenId].second = currentTime + timeToLive;\\n            }\\n        }\\n        \\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        unsigned int count = 0;\\n        for (auto it = intervals.begin();it!=intervals.end();it++){\\n            if (it->second.second>currentTime)\\n                count++;\\n            //cout<<it->second.first<<\" \"<<it->second.second<<endl;\\n        }\\n        return count;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n class AuthenticationManager {\\n public:\\n    int timeToLive;\\n    map<string, pair<int, int>> intervals;\\n    AuthenticationManager(int timeToLive) {\\n        this->timeToLive = timeToLive;\\n        //cout<<\"timeToLive: \"<<timeToLive<<endl;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        pair<int,int> p{0,0};\\n        intervals[tokenId] = p;\\n        intervals[tokenId].first = currentTime;\\n        intervals[tokenId].second = currentTime + timeToLive;\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        map<string, pair<int, int>>::iterator it;\\n        it = intervals.find(tokenId);\\n        if (it != intervals.end()){\\n            if (currentTime < intervals[tokenId].second){\\n                intervals[tokenId].first = currentTime;\\n                intervals[tokenId].second = currentTime + timeToLive;\\n            }\\n        }\\n        \\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        unsigned int count = 0;\\n        for (auto it = intervals.begin();it!=intervals.end();it++){\\n            if (it->second.second>currentTime)\\n                count++;\\n            //cout<<it->second.first<<\" \"<<it->second.second<<endl;\\n        }\\n        return count;\\n    }\\n};\\n\\'\\'\\'",
                "codeTag": "C++"
            },
            {
                "id": 2052425,
                "title": "java-46ms-beats-91-uses-two-treemaps-tokenidtoexpiry-expirytotokenid",
                "content": "```\\n/*\\nRuntime: 46 ms, faster than 91.17% of Java online submissions for Design Authentication Manager.\\nMemory Usage: 45.2 MB, less than 72.63% of Java online submissions for Design Authentication Manager.\\nElapsed dev time: 0h:22m\\n*/\\n\\nimport java.util.NavigableMap;\\n\\nclass AuthenticationManager {\\n    \\n    int ttl_in_seconds;\\n    \\n    TreeMap<String, Integer> tokenIdToExpiry;\\n    TreeMap<Integer, String> expiryToTokenId;\\n\\n    public AuthenticationManager(int ttl_in_seconds) {\\n        this.ttl_in_seconds = ttl_in_seconds;\\n        tokenIdToExpiry = new TreeMap<>();\\n        expiryToTokenId = new TreeMap<>();\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        expireTokens(currentTime);\\n        int expiry = currentTime + this.ttl_in_seconds;\\n        tokenIdToExpiry.put(tokenId, expiry);\\n        expiryToTokenId.put(expiry, tokenId);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        expireTokens(currentTime);\\n        \\n        if (tokenIdToExpiry.containsKey(tokenId)) {\\n            int curExpiry = tokenIdToExpiry.get(tokenId);\\n            expiryToTokenId.remove(curExpiry);\\n            \\n            int newExpiry = currentTime + this.ttl_in_seconds;\\n            tokenIdToExpiry.put(tokenId, newExpiry);  // overwrite previous entry\\n            expiryToTokenId.put(newExpiry, tokenId);\\n        }\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        expireTokens(currentTime);\\n        return tokenIdToExpiry.size();\\n    }\\n    \\n    private void expireTokens(int currentTime) {\\n        List<String> expiredTokens = new LinkedList<>();\\n        List<Integer> expiredTimes = new LinkedList<>();\\n        NavigableMap<Integer, String> nm = expiryToTokenId.headMap(currentTime, true);\\n        expiredTokens.addAll(nm.values());\\n        expiredTimes.addAll(nm.keySet());\\n        for (String token : expiredTokens) {\\n            tokenIdToExpiry.remove(token);\\n        }\\n        for (Integer time : expiredTimes) {\\n            expiryToTokenId.remove(time);\\n        }\\n    }\\n    \\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nRuntime: 46 ms, faster than 91.17% of Java online submissions for Design Authentication Manager.\\nMemory Usage: 45.2 MB, less than 72.63% of Java online submissions for Design Authentication Manager.\\nElapsed dev time: 0h:22m\\n*/\\n\\nimport java.util.NavigableMap;\\n\\nclass AuthenticationManager {\\n    \\n    int ttl_in_seconds;\\n    \\n    TreeMap<String, Integer> tokenIdToExpiry;\\n    TreeMap<Integer, String> expiryToTokenId;\\n\\n    public AuthenticationManager(int ttl_in_seconds) {\\n        this.ttl_in_seconds = ttl_in_seconds;\\n        tokenIdToExpiry = new TreeMap<>();\\n        expiryToTokenId = new TreeMap<>();\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        expireTokens(currentTime);\\n        int expiry = currentTime + this.ttl_in_seconds;\\n        tokenIdToExpiry.put(tokenId, expiry);\\n        expiryToTokenId.put(expiry, tokenId);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        expireTokens(currentTime);\\n        \\n        if (tokenIdToExpiry.containsKey(tokenId)) {\\n            int curExpiry = tokenIdToExpiry.get(tokenId);\\n            expiryToTokenId.remove(curExpiry);\\n            \\n            int newExpiry = currentTime + this.ttl_in_seconds;\\n            tokenIdToExpiry.put(tokenId, newExpiry);  // overwrite previous entry\\n            expiryToTokenId.put(newExpiry, tokenId);\\n        }\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        expireTokens(currentTime);\\n        return tokenIdToExpiry.size();\\n    }\\n    \\n    private void expireTokens(int currentTime) {\\n        List<String> expiredTokens = new LinkedList<>();\\n        List<Integer> expiredTimes = new LinkedList<>();\\n        NavigableMap<Integer, String> nm = expiryToTokenId.headMap(currentTime, true);\\n        expiredTokens.addAll(nm.values());\\n        expiredTimes.addAll(nm.keySet());\\n        for (String token : expiredTokens) {\\n            tokenIdToExpiry.remove(token);\\n        }\\n        for (Integer time : expiredTimes) {\\n            expiryToTokenId.remove(time);\\n        }\\n    }\\n    \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2047777,
                "title": "rust-solution",
                "content": "The input size is very small, so we don\\'t need to consider time complexity.\\n\\n```\\nuse std::collections::*;\\n\\nstruct AuthenticationManager {\\n    life: i32,\\n    alives: HashMap<String,i32>,\\n}\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl AuthenticationManager {\\n    fn new(timeToLive: i32) -> Self {\\n        AuthenticationManager {\\n            life: timeToLive,\\n            alives: HashMap::new(),\\n        }\\n    }\\n    \\n    fn generate(&mut self, token_id: String, current_time: i32) {\\n        self.alives.insert(token_id, current_time+self.life);\\n    }\\n    \\n    fn renew(&mut self, token_id: String, current_time: i32) {\\n        if let Some(life) = self.alives.get_mut(&token_id) {\\n            if current_time < *life {\\n                *life = current_time + self.life;\\n            } else {\\n                self.alives.remove(&token_id);\\n            }\\n        }\\n    }\\n    \\n    fn count_unexpired_tokens(&mut self, current_time: i32) -> i32 {\\n        let mut targets = vec![];\\n        for (key, life) in self.alives.iter_mut() {\\n            if current_time >= *life {\\n                targets.push(key.clone());\\n            }\\n        }\\n        for name in targets {\\n            self.alives.remove(&name);\\n        }\\n\\n        self.alives.keys().len() as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::*;\\n\\nstruct AuthenticationManager {\\n    life: i32,\\n    alives: HashMap<String,i32>,\\n}\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl AuthenticationManager {\\n    fn new(timeToLive: i32) -> Self {\\n        AuthenticationManager {\\n            life: timeToLive,\\n            alives: HashMap::new(),\\n        }\\n    }\\n    \\n    fn generate(&mut self, token_id: String, current_time: i32) {\\n        self.alives.insert(token_id, current_time+self.life);\\n    }\\n    \\n    fn renew(&mut self, token_id: String, current_time: i32) {\\n        if let Some(life) = self.alives.get_mut(&token_id) {\\n            if current_time < *life {\\n                *life = current_time + self.life;\\n            } else {\\n                self.alives.remove(&token_id);\\n            }\\n        }\\n    }\\n    \\n    fn count_unexpired_tokens(&mut self, current_time: i32) -> i32 {\\n        let mut targets = vec![];\\n        for (key, life) in self.alives.iter_mut() {\\n            if current_time >= *life {\\n                targets.push(key.clone());\\n            }\\n        }\\n        for name in targets {\\n            self.alives.remove(&name);\\n        }\\n\\n        self.alives.keys().len() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2025570,
                "title": "c-clean-solution",
                "content": "class AuthenticationManager {\\nprivate:\\n    map<string,long long> mp;\\n    int timeToLive;\\npublic:\\n    AuthenticationManager(int timeToLive) {\\n        this->timeToLive = timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        mp.insert(make_pair(tokenId,currentTime));\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if(mp.find(tokenId) == mp.end()){\\n            return;\\n        }\\n        int x = mp[tokenId];\\n        if(x+timeToLive > currentTime){\\n            mp[tokenId] = currentTime;\\n        }\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int ans = 0;\\n        for(auto it=mp.begin();it!=mp.end();it++){\\n            int x = it->second;\\n            if(x + timeToLive > currentTime){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */",
                "solutionTags": [],
                "code": "class AuthenticationManager {\\nprivate:\\n    map<string,long long> mp;\\n    int timeToLive;\\npublic:\\n    AuthenticationManager(int timeToLive) {\\n        this->timeToLive = timeToLive;\\n    }\\n    \\n    void generate(string tokenId, int currentTime) {\\n        mp.insert(make_pair(tokenId,currentTime));\\n    }\\n    \\n    void renew(string tokenId, int currentTime) {\\n        if(mp.find(tokenId) == mp.end()){\\n            return;\\n        }\\n        int x = mp[tokenId];\\n        if(x+timeToLive > currentTime){\\n            mp[tokenId] = currentTime;\\n        }\\n    }\\n    \\n    int countUnexpiredTokens(int currentTime) {\\n        int ans = 0;\\n        for(auto it=mp.begin();it!=mp.end();it++){\\n            int x = it->second;\\n            if(x + timeToLive > currentTime){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager* obj = new AuthenticationManager(timeToLive);\\n * obj->generate(tokenId,currentTime);\\n * obj->renew(tokenId,currentTime);\\n * int param_3 = obj->countUnexpiredTokens(currentTime);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 2021233,
                "title": "javascript-solution",
                "content": "```\\nclass AuthenticationManager {\\n    constructor(timeToLive) {\\n        this.hashmap = {};\\n        this.ttl = timeToLive;\\n    }\\n\\n    generate(tokenId, currentTime) {\\n        this.hashmap[tokenId] = currentTime + this.ttl;\\n    }\\n\\n    renew(tokenId, currentTime) {\\n        const existing = this.hashmap[tokenId];\\n\\n        if (existing && existing > currentTime) {\\n            this.hashmap[tokenId] = currentTime + this.ttl;\\n        }\\n    }\\n\\n    countUnexpiredTokens(currentTime) {\\n        return Object.keys(this.hashmap)\\n            .filter(x => this.hashmap[x] > currentTime)\\n            .length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass AuthenticationManager {\\n    constructor(timeToLive) {\\n        this.hashmap = {};\\n        this.ttl = timeToLive;\\n    }\\n\\n    generate(tokenId, currentTime) {\\n        this.hashmap[tokenId] = currentTime + this.ttl;\\n    }\\n\\n    renew(tokenId, currentTime) {\\n        const existing = this.hashmap[tokenId];\\n\\n        if (existing && existing > currentTime) {\\n            this.hashmap[tokenId] = currentTime + this.ttl;\\n        }\\n    }\\n\\n    countUnexpiredTokens(currentTime) {\\n        return Object.keys(this.hashmap)\\n            .filter(x => this.hashmap[x] > currentTime)\\n            .length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2006587,
                "title": "java-hashmap-easy",
                "content": "```\\nclass AuthenticationManager {\\n    int timeToLive;\\n    Map<String, Integer> tokenMap;\\n    public AuthenticationManager(int timeToLive) {\\n        this.timeToLive = timeToLive;\\n        tokenMap = new HashMap<>();\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        tokenMap.put(tokenId, currentTime + timeToLive);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        if(tokenMap.containsKey(tokenId) && tokenMap.get(tokenId) > currentTime) {\\n            tokenMap.put(tokenId, currentTime + timeToLive);\\n        }\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        Iterator iterator = tokenMap.entrySet().iterator();\\n        while(iterator.hasNext()) {\\n            Map.Entry<String, Integer> entry = (Map.Entry<String, Integer>)iterator.next();\\n            if(entry.getValue() <= currentTime) {\\n                iterator.remove();\\n            }\\n        }\\n        return tokenMap.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass AuthenticationManager {\\n    int timeToLive;\\n    Map<String, Integer> tokenMap;\\n    public AuthenticationManager(int timeToLive) {\\n        this.timeToLive = timeToLive;\\n        tokenMap = new HashMap<>();\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        tokenMap.put(tokenId, currentTime + timeToLive);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        if(tokenMap.containsKey(tokenId) && tokenMap.get(tokenId) > currentTime) {\\n            tokenMap.put(tokenId, currentTime + timeToLive);\\n        }\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n        Iterator iterator = tokenMap.entrySet().iterator();\\n        while(iterator.hasNext()) {\\n            Map.Entry<String, Integer> entry = (Map.Entry<String, Integer>)iterator.next();\\n            if(entry.getValue() <= currentTime) {\\n                iterator.remove();\\n            }\\n        }\\n        return tokenMap.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2055121,
                "content": [
                    {
                        "username": "cube_89",
                        "content": "This question ask in Linkedin online assessment !"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "the example in the problem description and test case are not consistent. The test case shows that renew will not renew if the currentTime is equal to the tokenId\\'s previous expiration time, but, the sample in the question showed otherwise."
                    },
                    {
                        "username": "cswartzell",
                        "content": "There is something very wrong with at least the Python driver code giving this problem very difficult behavior. Maybe I'm just missing something but it seems very weird. It seems like maybe a concurency issue, but I dont know. The behaviors seem very odd\n\n\nFor one, I get different results if I store my tokens as a class attribute or an instance variable, but if there is only one instance of the class these are functionally identical.  Furthermore, if I run the debugger on my code for test cases that fail I get a DIFFERENT output, and the testcases always pass. How can running the problem in debug give a different answer then when run at speed? Try the below code by using only lines 2 OR 4\n\n```\nclass AuthenticationManager:\n    # token = dict()  #This is a class attribute and if there is only a single instance, is functionally identical to self.token = dict() yet this fails and gives nonsense answers for testcases. \n    def __init__(self, timeToLive):\n        self.token = dict() #This is an instance variable. Again, if there is only one instance of a class, then this is functionally identical to a class attribute. Feel free to try it either way\n        self.time = timeToLive\n\n    def generate(self, tokenId, currentTime):\n        self.token[tokenId] = currentTime   \n\n    def renew(self, tokenId, currentTime):\n        if tokenId in self.token and self.token[tokenId]>currentTime-self.time:\n            self.token[tokenId] = currentTime\n\n    def countUnexpiredTokens(self, currentTime):\n        return sum(1 for expiry_time in self.token.values() if expiry_time > currentTime-self.time)\n```\n\n\nSimilarly, what could the difference be as to whether we are storing the exipry time in the token (currentTime + timeToLive) and then just checking if the currentTime is > than this expiry time or instead storing just the currentTime the token was generated then checking if it is expired (tokenTime < currentTime - timeToLive)? We are literally just changing where we add the offset. The result is functionally identical yet again this fails \n\nThis works:\n```\nclass AuthenticationManager:\n    def __init__(self, timeToLive):\n        self.token = dict()\n        self.time = timeToLive\n\n    def generate(self, tokenId, currentTime):\n        self.token[tokenId] = currentTime   \n\n    def renew(self, tokenId, currentTime):\n        if tokenId in self.token and self.token[tokenId]>currentTime-self.time:\n            self.token[tokenId] = currentTime\n\n    def countUnexpiredTokens(self, currentTime):\n        return sum(1 for expiry_time in self.token.values() if expiry_time > currentTime-self.time)\n```\n\nThis doesn't, despite seeming mathematically identical:\n```\nclass AuthenticationManager:\n    def __init__(self, timeToLive):\n        self.token = dict()\n        self.time = timeToLive\n\n    def generate(self, tokenId, currentTime):\n        self.token[tokenId] = currentTime + self.time  \n\n    def renew(self, tokenId, currentTime):\n        if tokenId in self.token and self.token[tokenId]>currentTime:\n            self.token[tokenId] = currentTime + self.time\n\n    def countUnexpiredTokens(self, currentTime):\n        return sum(1 for expiry_time in self.token.values() if expiry_time > currentTime)\n```\n\nHow could it matter where I add the same offset? What am I missing?"
                    },
                    {
                        "username": "Tony1ee",
                        "content": "https://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-"
                    }
                ]
            },
            {
                "id": 1801428,
                "content": [
                    {
                        "username": "cube_89",
                        "content": "This question ask in Linkedin online assessment !"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "the example in the problem description and test case are not consistent. The test case shows that renew will not renew if the currentTime is equal to the tokenId\\'s previous expiration time, but, the sample in the question showed otherwise."
                    },
                    {
                        "username": "cswartzell",
                        "content": "There is something very wrong with at least the Python driver code giving this problem very difficult behavior. Maybe I'm just missing something but it seems very weird. It seems like maybe a concurency issue, but I dont know. The behaviors seem very odd\n\n\nFor one, I get different results if I store my tokens as a class attribute or an instance variable, but if there is only one instance of the class these are functionally identical.  Furthermore, if I run the debugger on my code for test cases that fail I get a DIFFERENT output, and the testcases always pass. How can running the problem in debug give a different answer then when run at speed? Try the below code by using only lines 2 OR 4\n\n```\nclass AuthenticationManager:\n    # token = dict()  #This is a class attribute and if there is only a single instance, is functionally identical to self.token = dict() yet this fails and gives nonsense answers for testcases. \n    def __init__(self, timeToLive):\n        self.token = dict() #This is an instance variable. Again, if there is only one instance of a class, then this is functionally identical to a class attribute. Feel free to try it either way\n        self.time = timeToLive\n\n    def generate(self, tokenId, currentTime):\n        self.token[tokenId] = currentTime   \n\n    def renew(self, tokenId, currentTime):\n        if tokenId in self.token and self.token[tokenId]>currentTime-self.time:\n            self.token[tokenId] = currentTime\n\n    def countUnexpiredTokens(self, currentTime):\n        return sum(1 for expiry_time in self.token.values() if expiry_time > currentTime-self.time)\n```\n\n\nSimilarly, what could the difference be as to whether we are storing the exipry time in the token (currentTime + timeToLive) and then just checking if the currentTime is > than this expiry time or instead storing just the currentTime the token was generated then checking if it is expired (tokenTime < currentTime - timeToLive)? We are literally just changing where we add the offset. The result is functionally identical yet again this fails \n\nThis works:\n```\nclass AuthenticationManager:\n    def __init__(self, timeToLive):\n        self.token = dict()\n        self.time = timeToLive\n\n    def generate(self, tokenId, currentTime):\n        self.token[tokenId] = currentTime   \n\n    def renew(self, tokenId, currentTime):\n        if tokenId in self.token and self.token[tokenId]>currentTime-self.time:\n            self.token[tokenId] = currentTime\n\n    def countUnexpiredTokens(self, currentTime):\n        return sum(1 for expiry_time in self.token.values() if expiry_time > currentTime-self.time)\n```\n\nThis doesn't, despite seeming mathematically identical:\n```\nclass AuthenticationManager:\n    def __init__(self, timeToLive):\n        self.token = dict()\n        self.time = timeToLive\n\n    def generate(self, tokenId, currentTime):\n        self.token[tokenId] = currentTime + self.time  \n\n    def renew(self, tokenId, currentTime):\n        if tokenId in self.token and self.token[tokenId]>currentTime:\n            self.token[tokenId] = currentTime + self.time\n\n    def countUnexpiredTokens(self, currentTime):\n        return sum(1 for expiry_time in self.token.values() if expiry_time > currentTime)\n```\n\nHow could it matter where I add the same offset? What am I missing?"
                    },
                    {
                        "username": "Tony1ee",
                        "content": "https://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-"
                    }
                ]
            },
            {
                "id": 1956655,
                "content": [
                    {
                        "username": "cube_89",
                        "content": "This question ask in Linkedin online assessment !"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "the example in the problem description and test case are not consistent. The test case shows that renew will not renew if the currentTime is equal to the tokenId\\'s previous expiration time, but, the sample in the question showed otherwise."
                    },
                    {
                        "username": "cswartzell",
                        "content": "There is something very wrong with at least the Python driver code giving this problem very difficult behavior. Maybe I'm just missing something but it seems very weird. It seems like maybe a concurency issue, but I dont know. The behaviors seem very odd\n\n\nFor one, I get different results if I store my tokens as a class attribute or an instance variable, but if there is only one instance of the class these are functionally identical.  Furthermore, if I run the debugger on my code for test cases that fail I get a DIFFERENT output, and the testcases always pass. How can running the problem in debug give a different answer then when run at speed? Try the below code by using only lines 2 OR 4\n\n```\nclass AuthenticationManager:\n    # token = dict()  #This is a class attribute and if there is only a single instance, is functionally identical to self.token = dict() yet this fails and gives nonsense answers for testcases. \n    def __init__(self, timeToLive):\n        self.token = dict() #This is an instance variable. Again, if there is only one instance of a class, then this is functionally identical to a class attribute. Feel free to try it either way\n        self.time = timeToLive\n\n    def generate(self, tokenId, currentTime):\n        self.token[tokenId] = currentTime   \n\n    def renew(self, tokenId, currentTime):\n        if tokenId in self.token and self.token[tokenId]>currentTime-self.time:\n            self.token[tokenId] = currentTime\n\n    def countUnexpiredTokens(self, currentTime):\n        return sum(1 for expiry_time in self.token.values() if expiry_time > currentTime-self.time)\n```\n\n\nSimilarly, what could the difference be as to whether we are storing the exipry time in the token (currentTime + timeToLive) and then just checking if the currentTime is > than this expiry time or instead storing just the currentTime the token was generated then checking if it is expired (tokenTime < currentTime - timeToLive)? We are literally just changing where we add the offset. The result is functionally identical yet again this fails \n\nThis works:\n```\nclass AuthenticationManager:\n    def __init__(self, timeToLive):\n        self.token = dict()\n        self.time = timeToLive\n\n    def generate(self, tokenId, currentTime):\n        self.token[tokenId] = currentTime   \n\n    def renew(self, tokenId, currentTime):\n        if tokenId in self.token and self.token[tokenId]>currentTime-self.time:\n            self.token[tokenId] = currentTime\n\n    def countUnexpiredTokens(self, currentTime):\n        return sum(1 for expiry_time in self.token.values() if expiry_time > currentTime-self.time)\n```\n\nThis doesn't, despite seeming mathematically identical:\n```\nclass AuthenticationManager:\n    def __init__(self, timeToLive):\n        self.token = dict()\n        self.time = timeToLive\n\n    def generate(self, tokenId, currentTime):\n        self.token[tokenId] = currentTime + self.time  \n\n    def renew(self, tokenId, currentTime):\n        if tokenId in self.token and self.token[tokenId]>currentTime:\n            self.token[tokenId] = currentTime + self.time\n\n    def countUnexpiredTokens(self, currentTime):\n        return sum(1 for expiry_time in self.token.values() if expiry_time > currentTime)\n```\n\nHow could it matter where I add the same offset? What am I missing?"
                    },
                    {
                        "username": "Tony1ee",
                        "content": "https://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-"
                    }
                ]
            }
        ]
    }
]